void _os_eventlink_xref_dispose(uint64_t a1)
{
  _os_object_release_internal(a1);
}

void _os_eventlink_explicit_dispose(void *a1)
{
}

void _os_eventlink_dispose(uint64_t a1)
{
  if (*(void *)(a1 + 24)) {
    free(*(void **)(a1 + 16));
  }
  if (*(_DWORD *)(a1 + 32) && *(_DWORD *)(a1 + 32) != -1) {
    mach_port_deallocate(mach_task_self_, *(_DWORD *)(a1 + 32));
  }
  if (*(_DWORD *)(a1 + 36))
  {
    if (*(_DWORD *)(a1 + 36) != -1) {
      mach_port_deallocate(mach_task_self_, *(_DWORD *)(a1 + 36));
    }
  }
}

void *os_eventlink_create(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_eventlink_create_internal(a1, a2, a3, a4, a5, a6, a7, a8);
}

void *_os_eventlink_create_internal(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v10 = _os_object_alloc(_OS_os_eventlink_vtable, 0x30uLL, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    if (a1)
    {
      v9 = _dispatch_strdup_if_mutable(a1);
      if (v9 != a1) {
        v10[3] |= 1uLL;
      }
      v10[2] = v9;
    }
    return v10;
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 12;
    return 0;
  }
}

uint64_t os_eventlink_activate(uint64_t a1)
{
  uint64_t v6 = a1;
  unsigned int v5 = 0;
  if (!*(_DWORD *)(a1 + 32) || *(_DWORD *)(v6 + 32) == -1)
  {
    if (_os_eventlink_is_cancelled(*(void *)(v6 + 24)))
    {
      unsigned int v5 = 89;
      uint64_t v8 = 1;
      uint64_t v9 = 1;
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
      return v5;
    }
    else
    {
      memset(__b, 0, sizeof(__b));
      unsigned int v3 = mach_eventlink_create();
      if (v3) {
        return _mach_error_to_errno(v3);
      }
      uint64_t v1 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v6 + 32), (unint64_t *)&v1, __b[4], memory_order_relaxed, memory_order_relaxed);
      if (!v1)
      {
        return _mach_error_to_errno(v3);
      }
      else
      {
        if (LODWORD(__b[4]) && LODWORD(__b[4]) != -1) {
          mach_port_deallocate(mach_task_self_, __b[4]);
        }
        if (HIDWORD(__b[4]) && HIDWORD(__b[4]) != -1) {
          mach_port_deallocate(mach_task_self_, HIDWORD(__b[4]));
        }
        return 22;
      }
    }
  }
  else
  {
    return v5;
  }
}

BOOL _os_eventlink_is_cancelled(char a1)
{
  return (a1 & 2) == 2;
}

uint64_t _mach_error_to_errno(unsigned int a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if (v1)
  {
    return -1;
  }
  else
  {
    switch(v2)
    {
      case 0:
        int v4 = 0;
        goto LABEL_13;
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
        return -1;
      case 4:
        int v4 = 22;
        goto LABEL_13;
      case 13:
        int v4 = 37;
        goto LABEL_13;
      case 14:
        int v4 = 53;
        goto LABEL_13;
      case 15:
      case 37:
        int v4 = 89;
        goto LABEL_13;
      case 49:
        int v4 = 60;
LABEL_13:
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v4;
        unsigned int v5 = v4;
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v5;
}

uint64_t os_eventlink_extract_remote_port(uint64_t a1, unsigned int *a2)
{
  if (!_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
      return 89;
    }
    unsigned int v3 = __swp(0, (unsigned int *)(a1 + 36));
    if (v3 && v3 != -1)
    {
      *a2 = v3;
      return 0;
    }
  }
  **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  return 22;
}

BOOL _os_eventlink_inactive(int a1)
{
  return a1 == 0;
}

void *os_eventlink_create_with_port(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_name_t v10 = a2;
  internal = _os_eventlink_create_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!internal) {
    return 0;
  }
  if (mach_port_mod_refs(mach_task_self_, v10, 0, 1))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (*((_DWORD *)internal + 8))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  *((_DWORD *)internal + 8) = v10;
  return internal;
}

void *os_eventlink_create_remote_with_eventlink(const char *a1, uint64_t a2)
{
  v13 = a1;
  uint64_t v12 = a2;
  mach_port_name_t name = 0;
  int v10 = os_eventlink_extract_remote_port(a2, &name);
  if (v10)
  {
    uint64_t v15 = 1;
    uint64_t v16 = 1;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = v10;
    return 0;
  }
  else
  {
    uint64_t v9 = os_eventlink_create_with_port(v13, name, v2, v3, v4, v5, v6, v7);
    mach_port_mod_refs(mach_task_self_, name, 0, -1);
    return v9;
  }
}

uint64_t os_eventlink_associate(uint64_t a1, uint64_t a2)
{
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    if (a2 != 1) {
      _dispatch_thread_getspecific(3uLL);
    }
    unsigned int v3 = mach_eventlink_associate();
    return _mach_error_to_errno(v3);
  }
}

void *_dispatch_thread_getspecific(pthread_key_t a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2) {
    return pthread_getspecific(a1);
  }
  else {
    return *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * a1);
  }
}

uint64_t os_eventlink_disassociate(uint64_t a1)
{
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    return 0;
  }
  else
  {
    unsigned int v2 = mach_eventlink_disassociate();
    if (v2 == 37) {
      return 0;
    }
    else {
      return _mach_error_to_errno(v2);
    }
  }
}

uint64_t os_eventlink_wait_until(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v6 = _os_clockid_normalize_to_machabs(a2, a3);
  uint64_t v4 = mach_absolute_time();
  return os_eventlink_wait_until_internal(a1, a2, v4 + v6, a4);
}

uint64_t _os_clockid_normalize_to_machabs(int a1, uint64_t a2)
{
  uint64_t v3 = 0;
  if (a1 == 32) {
    return a2;
  }
  return v3;
}

uint64_t os_eventlink_wait_until_internal(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2 != 32)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 40);
    unsigned int v6 = mach_eventlink_wait_until();
    if (v6 || !a4)
    {
      if (v6 == 15 && !_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
      {
        _os_assert_log();
        _os_crash();
        __break(1u);
      }
    }
    else
    {
      *a4 = *(void *)(a1 + 40) - v5;
    }
    return _mach_error_to_errno(v6);
  }
}

uint64_t os_eventlink_wait(uint64_t a1, void *a2)
{
  return os_eventlink_wait_until_internal(a1, 32, 0, a2);
}

uint64_t os_eventlink_signal(uint64_t a1)
{
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    unsigned int v2 = mach_eventlink_signal();
    return _mach_error_to_errno(v2);
  }
}

uint64_t os_eventlink_signal_and_wait(uint64_t a1, void *a2)
{
  return os_eventlink_signal_and_wait_until_internal(a1, 32, 0, a2);
}

uint64_t os_eventlink_signal_and_wait_until_internal(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  if (a2 != 32)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 40);
    unsigned int v6 = mach_eventlink_signal_wait_until();
    if (v6 || !a4)
    {
      if (v6 == 15 && !_os_eventlink_is_cancelled(*(void *)(a1 + 24)))
      {
        _os_assert_log();
        _os_crash();
        __break(1u);
      }
    }
    else
    {
      *a4 = *(void *)(a1 + 40) - v5;
    }
    return _mach_error_to_errno(v6);
  }
}

uint64_t os_eventlink_signal_and_wait_until(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v6 = _os_clockid_normalize_to_machabs(a2, a3);
  uint64_t v4 = mach_absolute_time();
  return os_eventlink_signal_and_wait_until_internal(a1, a2, v4 + v6, a4);
}

uint64_t os_eventlink_cancel(uint64_t a1)
{
  uint64_t result = _os_eventlink_is_cancelled(*(void *)(a1 + 24));
  if ((result & 1) == 0)
  {
    atomic_fetch_or_explicit((atomic_ullong *volatile)(a1 + 24), 2uLL, memory_order_relaxed);
    mach_port_name_t name = *(_DWORD *)(a1 + 32);
    if (name)
    {
      if (name != -1)
      {
        if (mach_port_mod_refs(mach_task_self_, name, 0, 1))
        {
          _os_assert_log();
          _os_crash();
          __break(1u);
        }
        return mach_eventlink_destroy();
      }
    }
  }
  return result;
}

void _os_workgroup_explicit_xref_dispose(uint64_t a1)
{
}

void _os_workgroup_explicit_dispose(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _os_workgroup_interval_explicit_xref_dispose(uint64_t a1)
{
}

void _os_workgroup_interval_explicit_dispose(void *a1)
{
  _os_workgroup_interval_dispose();
  _os_workgroup_explicit_dispose(a1, v1, v2, v3, v4, v5, v6, v7);
}

void _os_workgroup_xref_dispose(uint64_t a1)
{
  uint64_t v1 = *(void (***)(void))(a1 + 48);
  if (v1)
  {
    v1[1](*v1);
    free(v1);
  }
}

uint64_t _os_workgroup_interval_xref_dispose(uint64_t result)
{
  if ((*(void *)(result + 24) & 8) != 0)
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x2528);
  }
  return result;
}

void _os_workgroup_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 60)) {
    _dispatch_abort(165, *(_DWORD *)(a1 + 60) == 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v8 = *(void *)(a1 + 24);
  if (_os_workgroup_has_backing_workinterval(a1))
  {
    if (mach_port_mod_refs(mach_task_self_, *(_DWORD *)(a1 + 40), 0, -1)) {
      _os_assumes_log();
    }
    if (_os_workgroup_is_configurable(v8) && work_interval_destroy()) {
      _os_assumes_log();
    }
  }
  if ((v8 & 4) != 0) {
    free(*(void **)(a1 + 16));
  }
}

BOOL _os_workgroup_has_backing_workinterval(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) != 0;
}

BOOL _os_workgroup_is_configurable(char a1)
{
  return (a1 & 1) == 1;
}

uint64_t _os_workgroup_interval_dispose()
{
  return work_interval_instance_free();
}

uint64_t _os_workgroup_tsd_cleanup(uint64_t result)
{
  if (result)
  {
    __snprintf_chk(v1, 0x200uLL, 0, 0x200uLL, "BUG IN CLIENT: Thread exiting without leaving workgroup '%s'", *(const char **)(result + 16));
    _os_crash();
    __break(1u);
    JUMPOUT(0x27D8);
  }
  return result;
}

void _os_workgroup_join_token_tsd_cleanup(void *a1)
{
  if (a1)
  {
    if (a1[1])
    {
      _os_assert_log();
      _os_crash();
      __break(1u);
    }
    _os_workgroup_leave_update_wg(a1[2]);
    free(a1);
  }
}

void _os_workgroup_leave_update_wg(uint64_t a1)
{
  if (_os_workgroup_get_current() != (void *)a1)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (!atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 60), 0xFFFFFFFF, memory_order_relaxed))
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Joined count underflowed";
    __break(1u);
  }
  _os_workgroup_set_current(0);
}

uint64_t _workgroup_init()
{
  return pthread_install_workgroup_functions_np();
}

uint64_t _os_workgroup_get_backing_workinterval(uint64_t a1)
{
  if (a1 && _os_workgroup_has_backing_workinterval(a1)) {
    return *(unsigned int *)(a1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t os_workgroup_interval_data_set_flags(_DWORD *a1, int a2)
{
  unsigned int v3 = 0;
  if (!_os_workgroup_client_interval_data_is_valid(a1) || (a2 & 0xFFFFFFFE) != 0) {
    return 22;
  }
  else {
    a1[1] = a2;
  }
  return v3;
}

BOOL _os_workgroup_client_interval_data_is_valid(_DWORD *a1)
{
  BOOL v2 = 0;
  if (a1) {
    return _os_workgroup_client_interval_data_initialized(a1);
  }
  return v2;
}

uint64_t os_workgroup_interval_data_set_telemetry(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4)
{
  if (_os_workgroup_telemetry_flavor_is_valid(a2) && (a2 != 1 || a4 == 40))
  {
    *(_WORD *)(a1 + 16) = a2;
    *(void *)(a1 + 8) = a3;
    *(_WORD *)(a1 + 18) = a4;
    return 0;
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

BOOL _os_workgroup_telemetry_flavor_is_valid(__int16 a1)
{
  return a1 == 1;
}

uint64_t os_workgroup_attr_set_interval_type(uint64_t a1, unsigned __int16 a2)
{
  unsigned int v3 = 0;
  if (_os_workgroup_client_attr_is_valid((_DWORD *)a1) && _os_workgroup_type_is_interval_type(a2)) {
    *(_WORD *)(a1 + 8) = a2;
  }
  else {
    return 22;
  }
  return v3;
}

BOOL _os_workgroup_client_attr_is_valid(_DWORD *a1)
{
  BOOL v2 = 0;
  if (a1) {
    return _os_workgroup_client_attr_initialized(a1);
  }
  return v2;
}

BOOL _os_workgroup_type_is_interval_type(unsigned __int16 a1)
{
  BOOL v2 = 0;
  if (a1) {
    return a1 <= 0xAu;
  }
  return v2;
}

uint64_t os_workgroup_attr_set_flags(_DWORD *a1, int a2)
{
  unsigned int v3 = 0;
  if (_os_workgroup_client_attr_is_valid(a1)) {
    a1[1] = a2;
  }
  else {
    return 22;
  }
  return v3;
}

uint64_t os_workgroup_attr_set_telemetry_flavor(uint64_t a1, __int16 a2)
{
  unsigned int v3 = 0;
  if (_os_workgroup_client_attr_is_valid((_DWORD *)a1) && _os_workgroup_telemetry_flavor_is_valid(a2)) {
    *(_WORD *)(a1 + 10) = a2;
  }
  else {
    return 22;
  }
  return v3;
}

__int16 *os_workgroup_interval_copy_current_4AudioToolbox()
{
  object = (__int16 *)_os_workgroup_get_current();
  if (object)
  {
    if (_os_workgroup_type_is_audio_type(object[28])) {
      return (__int16 *)os_retain(object);
    }
    else {
      return 0;
    }
  }
  return object;
}

void *_os_workgroup_get_current()
{
  return _dispatch_thread_getspecific(0x74uLL);
}

BOOL _os_workgroup_type_is_audio_type(__int16 a1)
{
  BOOL v2 = 1;
  if (a1 != 4) {
    return a1 == 3;
  }
  return v2;
}

void *os_workgroup_create(const char *a1, _DWORD *a2)
{
  v13 = a1;
  uint64_t v12 = a2;
  v11 = 0;
  uint64_t work_interval = 0;
  memset(__b, 0, sizeof(__b));
  uint64_t v12 = _os_workgroup_client_attr_resolve(__b, v12, (uint64_t)&_os_workgroup_attr_default);
  if (v12)
  {
    if (_os_workgroup_type_is_default_type(*((_WORD *)v12 + 4)))
    {
      if (_os_workgroup_attr_is_propagating((uint64_t)v12))
      {
        uint64_t v17 = 1;
        uint64_t v20 = 1;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(StatusReg + 8) = 45;
        return 0;
      }
      else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)v12))
      {
        uint64_t v18 = 1;
        uint64_t v19 = 1;
        unint64_t v26 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v26 + 8) = 45;
        return 0;
      }
      else
      {
        uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v12);
        if (work_interval)
        {
          v11 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
          v11[4] = work_interval;
          *((_DWORD *)v11 + 10) = 0;
          v11[3] = 1;
          *((_WORD *)v11 + 28) = *((_WORD *)v12 + 4);
          _os_workgroup_set_name((uint64_t)v11, v13);
          return v11;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      uint64_t v16 = 1;
      uint64_t v21 = 1;
      unint64_t v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v24 + 8) = 22;
      return 0;
    }
  }
  else
  {
    uint64_t v15 = 1;
    uint64_t v22 = 1;
    unint64_t v23 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v23 + 8) = 22;
    return 0;
  }
}

_DWORD *_os_workgroup_client_attr_resolve(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  if (a2)
  {
    if (!_os_workgroup_client_attr_is_valid(a2)) {
      return 0;
    }
    memcpy(a1, a2, 0x40uLL);
    if (*a1 == 799564724)
    {
      if (!a1[1]) {
        a1[1] = *(_DWORD *)(a3 + 4);
      }
      if (!*((_WORD *)a1 + 4)) {
        *((_WORD *)a1 + 4) = *(_WORD *)(a3 + 8);
      }
    }
    else if (*a1 != 799564740)
    {
      return 0;
    }
    *a1 = 2015762650;
  }
  else
  {
    memcpy(a1, (const void *)a3, 0x40uLL);
  }
  if (!_os_workgroup_attr_is_resolved(a1))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    JUMPOUT(0x32F0);
  }
  return a1;
}

BOOL _os_workgroup_type_is_default_type(__int16 a1)
{
  return a1 == 0;
}

BOOL _os_workgroup_attr_is_propagating(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) & 2) == 0;
}

BOOL _os_workgroup_attr_has_telemetry_enabled(uint64_t a1)
{
  return *(_WORD *)(a1 + 10) != 0;
}

uint64_t _os_workgroup_create_work_interval(uint64_t a1)
{
  _wg_type_to_wi_flags(*(_WORD *)(a1 + 8));
  _os_workgroup_attr_is_differentiated(a1);
  _os_workgroup_attr_has_workload_id(a1);
  _os_workgroup_attr_has_telemetry_enabled(a1);
  *(_DWORD *)&v2[8] = 0;
  *(void *)uint64_t v2 = work_interval_create();
  if (*(_DWORD *)v2) {
    return 0;
  }
  if ((int)work_interval_copy_port() >= 0) {
    return *(void *)&v2[4];
  }
  work_interval_destroy();
  return 0;
}

void _os_workgroup_set_name(uint64_t a1, const char *a2)
{
  uint64_t v4 = (uint64_t)a2;
  if (a2)
  {
    uint64_t v3 = _dispatch_strdup_if_mutable(a2);
    if (v3 != (const char *)v4)
    {
      *(void *)(a1 + 24) |= 4uLL;
      uint64_t v4 = (uint64_t)v3;
    }
  }
  *(void *)(a1 + 16) = v4;
  uint64_t v2 = *(void *)(a1 + 24);
  if (_os_workgroup_has_backing_workinterval(a1) && _os_workgroup_is_configurable(v2)) {
    _os_workgroup_set_work_interval_name(a1, v4);
  }
}

void *os_workgroup_interval_create(const char *a1, int a2, _DWORD *a3)
{
  uint64_t v15 = a1;
  int v14 = a2;
  v13 = a3;
  uint64_t v12 = 0;
  uint64_t work_interval = 0;
  memset(__b, 0, sizeof(__b));
  v13 = _os_workgroup_client_attr_resolve(__b, v13, (uint64_t)&_os_workgroup_interval_attr_default);
  if (v13)
  {
    if (_os_workgroup_type_is_interval_type(*((_WORD *)v13 + 4)))
    {
      if (_os_workgroup_attr_is_differentiated((uint64_t)v13))
      {
        if (_os_workgroup_attr_is_propagating((uint64_t)v13))
        {
          uint64_t v20 = 1;
          uint64_t v21 = 1;
          unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(StatusReg + 8) = 45;
          return 0;
        }
        else
        {
          uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v13);
          if (work_interval)
          {
            uint64_t v12 = _os_object_alloc(_OS_os_workgroup_interval_vtable, 0x50uLL, v3, v4, v5, v6, v7, v8);
            v12[4] = work_interval;
            *((_DWORD *)v12 + 10) = 0;
            *((_DWORD *)v12 + 16) = v14;
            v12[9] = work_interval_instance_alloc();
            *((_DWORD *)v12 + 17) = 0;
            *((_WORD *)v12 + 28) = *((_WORD *)v13 + 4);
            v12[3] = 1;
            *((_WORD *)v12 + 22) = *((_WORD *)v13 + 5);
            _os_workgroup_set_name((uint64_t)v12, v15);
            return v12;
          }
          else
          {
            return 0;
          }
        }
      }
      else
      {
        uint64_t v19 = 1;
        uint64_t v22 = 1;
        unint64_t v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v27 + 8) = 22;
        return 0;
      }
    }
    else
    {
      uint64_t v18 = 1;
      uint64_t v23 = 1;
      unint64_t v26 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v26 + 8) = 22;
      return 0;
    }
  }
  else
  {
    uint64_t v17 = 1;
    uint64_t v24 = 1;
    unint64_t v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v25 + 8) = 22;
    return 0;
  }
}

BOOL _os_workgroup_attr_is_differentiated(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) & 4) == 0;
}

void *os_workgroup_create_with_workload_id(const char *a1, const char *a2, _DWORD *a3)
{
  v44 = a1;
  v43 = a2;
  v42 = a3;
  v41 = 0;
  uint64_t work_interval = 0;
  v39 = &_os_workgroup_with_workload_id_attr_default;
  memset(__b, 0, sizeof(__b));
  v42 = _os_workgroup_client_attr_resolve(__b, v42, (uint64_t)&_os_workgroup_with_workload_id_attr_default);
  if (v42)
  {
    v42 = (_DWORD *)_os_workgroup_workload_id_attr_resolve(v43, (uint64_t)v42, (uint64_t)v39);
    if (v42)
    {
      if (v42[1] == v39[1])
      {
        if (_os_workgroup_type_is_default_type(*((_WORD *)v42 + 4)))
        {
          if (_os_workgroup_attr_is_propagating((uint64_t)v42))
          {
            _dispatch_log("BUG IN CLIENT of %s: Unsupported attribute flags: 0x%x", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"os_workgroup_create_with_workload_id");
            uint64_t v50 = 1;
            uint64_t v53 = 1;
            unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(StatusReg + 8) = 45;
            return 0;
          }
          else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)v42))
          {
            uint64_t v51 = 1;
            uint64_t v52 = 1;
            unint64_t v63 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(v63 + 8) = 45;
            return 0;
          }
          else
          {
            uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v42);
            if (work_interval)
            {
              v41 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v31, v32, v33, v34, v35, v36);
              v41[4] = work_interval;
              *((_DWORD *)v41 + 10) = 0;
              v41[3] = 1;
              *((_WORD *)v41 + 28) = *((_WORD *)v42 + 4);
              if (_os_workgroup_set_work_interval_workload_id((uint64_t)v41, (uint64_t)v43, v42[3]))
              {
                _os_object_release((uint64_t)v41);
                return 0;
              }
              else
              {
                _os_workgroup_set_name((uint64_t)v41, v44);
                return v41;
              }
            }
            else
            {
              return 0;
            }
          }
        }
        else
        {
          _dispatch_log("BUG IN CLIENT of %s: Non-default workload type: %s (%hd)", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"os_workgroup_create_with_workload_id");
          uint64_t v49 = 1;
          uint64_t v54 = 1;
          unint64_t v61 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(v61 + 8) = 22;
          return 0;
        }
      }
      else
      {
        _dispatch_log("BUG IN CLIENT of %s: Non-default attribute flags: 0x%x", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"os_workgroup_create_with_workload_id");
        uint64_t v48 = 1;
        uint64_t v55 = 1;
        unint64_t v60 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v60 + 8) = 22;
        return 0;
      }
    }
    else
    {
      _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and attribute interval type: %s vs %hd", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"os_workgroup_create_with_workload_id");
      uint64_t v47 = 1;
      uint64_t v56 = 1;
      unint64_t v59 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v59 + 8) = 22;
      return 0;
    }
  }
  else
  {
    _dispatch_log("BUG IN CLIENT of %s: Invalid attribute pointer", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"os_workgroup_create_with_workload_id");
    uint64_t v46 = 1;
    uint64_t v57 = 1;
    unint64_t v58 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v58 + 8) = 22;
    return 0;
  }
}

uint64_t _os_workgroup_workload_id_attr_resolve(const char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  uint64_t v6 = a3;
  unsigned __int16 v5 = 0;
  __int16 v4 = _os_workgroup_lookup_type_from_workload_id(a1, (unsigned int *)(a2 + 12), (__int16 *)&v5);
  if (!_os_workgroup_type_is_default_type(v4))
  {
    if (*(unsigned __int16 *)(v7 + 8) == *(unsigned __int16 *)(v6 + 8))
    {
      *(_WORD *)(v7 + 8) = v4;
    }
    else if (*(unsigned __int16 *)(v7 + 8) == v5)
    {
      *(_WORD *)(v7 + 8) = v4;
    }
    else if (v4 != *(_WORD *)(v7 + 8))
    {
      return 0;
    }
    return v7;
  }
  return v7;
}

uint64_t _os_workgroup_set_work_interval_workload_id(uint64_t a1, uint64_t a2, int a3)
{
  if (!*(_DWORD *)(a1 + 40) || *(_DWORD *)(a1 + 40) == -1)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 40);
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workgroup port";
    qword_F42C0 = v3;
    __break(1u);
    JUMPOUT(0x3DB8);
  }
  if (a3)
  {
    unsigned int v13 = a3 & 0xFFFFFFFE;
    __strlcpy_chk();
    _wg_type_to_wi_flags(*(_WORD *)(a1 + 56));
    unsigned int v12 = __work_interval_ctl();
    if (v12 == -1)
    {
      unsigned int v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v12) {
        _dispatch_bug(576, (int)v12, v4, v5, v6, v7, v8, v9);
      }
    }
    if (v12 || (v13 & 1) != 0)
    {
      if (v12) {
        unsigned int v11 = 0;
      }
      else {
        unsigned int v11 = v13;
      }
      _dispatch_log("BUG IN CLIENT of %s: Unable to set kernel workload ID: %s (0x%x) -> %d (0x%x)", v12, v11, v5, v6, v7, v8, v9, (uint64_t)"_os_workgroup_set_work_interval_workload_id");
      if (!v12) {
        return 37;
      }
    }
    else
    {
      *(void *)(a1 + 24) |= 0x10uLL;
    }
    return v12;
  }
  else
  {
    return 0;
  }
}

void *os_workgroup_interval_create_with_workload_id(const char *a1, const char *a2, int a3, _DWORD *a4)
{
  uint64_t v53 = a1;
  uint64_t v52 = a2;
  int v51 = a3;
  uint64_t v50 = a4;
  uint64_t v49 = 0;
  uint64_t work_interval = 0;
  uint64_t v47 = &_os_workgroup_interval_attr_default;
  memset(__b, 0, sizeof(__b));
  uint64_t v50 = _os_workgroup_client_attr_resolve(__b, v50, (uint64_t)&_os_workgroup_interval_attr_default);
  if (v50)
  {
    uint64_t v50 = (_DWORD *)_os_workgroup_workload_id_attr_resolve(v52, (uint64_t)v50, (uint64_t)v47);
    if (v50)
    {
      if (v50[1] == v47[1])
      {
        if (_os_workgroup_type_is_interval_type(*((_WORD *)v50 + 4)))
        {
          if (_os_workgroup_attr_is_differentiated((uint64_t)v50))
          {
            if (_os_workgroup_attr_is_propagating((uint64_t)v50))
            {
              _dispatch_log("BUG IN CLIENT of %s: Unsupported attribute flags: 0x%x", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"os_workgroup_interval_create_with_workload_id");
              uint64_t v60 = 1;
              uint64_t v61 = 1;
              unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
              **(_DWORD **)(StatusReg + 8) = 45;
              return 0;
            }
            else
            {
              uint64_t work_interval = _os_workgroup_create_work_interval((uint64_t)v50);
              if (work_interval)
              {
                uint64_t v49 = _os_object_alloc(_OS_os_workgroup_interval_vtable, 0x50uLL, v39, v40, v41, v42, v43, v44);
                v49[4] = work_interval;
                *((_DWORD *)v49 + 10) = 0;
                *((_DWORD *)v49 + 16) = v51;
                v49[9] = work_interval_instance_alloc();
                *((_DWORD *)v49 + 17) = 0;
                *((_WORD *)v49 + 28) = *((_WORD *)v50 + 4);
                v49[3] = 1;
                *((_WORD *)v49 + 22) = *((_WORD *)v50 + 5);
                if (_os_workgroup_set_work_interval_workload_id((uint64_t)v49, (uint64_t)v52, v50[3]))
                {
                  _os_object_release((uint64_t)v49);
                  return 0;
                }
                else
                {
                  _os_workgroup_set_name((uint64_t)v49, v53);
                  return v49;
                }
              }
              else
              {
                return 0;
              }
            }
          }
          else
          {
            _dispatch_log("BUG IN CLIENT of %s: Invalid attribute flags: 0x%x", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"os_workgroup_interval_create_with_workload_id");
            uint64_t v59 = 1;
            uint64_t v62 = 1;
            unint64_t v71 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(v71 + 8) = 22;
            return 0;
          }
        }
        else
        {
          _dispatch_log("BUG IN CLIENT of %s: Invalid workload interval type: %s (%hd)", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"os_workgroup_interval_create_with_workload_id");
          uint64_t v58 = 1;
          uint64_t v63 = 1;
          unint64_t v70 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(v70 + 8) = 22;
          return 0;
        }
      }
      else
      {
        _dispatch_log("BUG IN CLIENT of %s: Non-default attribute flags: 0x%x", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"os_workgroup_interval_create_with_workload_id");
        uint64_t v57 = 1;
        uint64_t v64 = 1;
        unint64_t v69 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v69 + 8) = 22;
        return 0;
      }
    }
    else
    {
      _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and attribute interval type: %s vs %hd", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"os_workgroup_interval_create_with_workload_id");
      uint64_t v56 = 1;
      uint64_t v65 = 1;
      unint64_t v68 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v68 + 8) = 22;
      return 0;
    }
  }
  else
  {
    _dispatch_log("BUG IN CLIENT of %s: Invalid attribute pointer", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"os_workgroup_interval_create_with_workload_id");
    uint64_t v55 = 1;
    uint64_t v66 = 1;
    unint64_t v67 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v67 + 8) = 22;
    return 0;
  }
}

uint64_t os_workgroup_join_self(os_workgroup_s *a1, os_workgroup_join_token_opaque_s *a2)
{
  return os_workgroup_join(a1, a2);
}

int os_workgroup_join(os_workgroup_t wg, os_workgroup_join_token_t token_out)
{
  if (_os_workgroup_get_current())
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 37;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else
  {
    uint64_t v4 = *((void *)wg + 3);
    if ((v4 & 2) != 0)
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
    else
    {
      int v3 = 0;
      if (_os_workgroup_has_backing_workinterval((uint64_t)wg))
      {
        if (_os_workgroup_is_configurable(v4)) {
          int v3 = work_interval_join();
        }
        else {
          int v3 = work_interval_join_port();
        }
      }
      if (v3)
      {
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
      else
      {
        _os_workgroup_join_update_wg((uint64_t)wg, (uint64_t)token_out);
        return 0;
      }
    }
  }
}

void os_workgroup_leave_self(os_workgroup_s *a1, os_workgroup_join_token_opaque_s *a2)
{
}

void os_workgroup_leave(os_workgroup_t wg, os_workgroup_join_token_t token)
{
  if (!_os_workgroup_join_token_initialized(token))
  {
    _os_crash();
    __break(1u);
  }
  int v8 = *(_DWORD *)token->opaque;
  if (v8 != _dispatch_thread_getspecific(3uLL))
  {
    _os_crash();
    __break(1u);
  }
  current = (os_workgroup_s *)_os_workgroup_get_current();
  if (*(os_workgroup_s **)&token->opaque[12] != current || current != wg)
  {
    _os_crash();
    __break(1u);
  }
  if (*(void *)&token->opaque[4])
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (_os_workgroup_has_backing_workinterval((uint64_t)wg) && work_interval_leave()) {
    _dispatch_bug(1686, 0, v2, v3, v4, v5, v6, v7);
  }
  _os_workgroup_leave_update_wg((uint64_t)wg);
}

os_workgroup_parallel_t os_workgroup_parallel_create(const char *name, os_workgroup_attr_t attr)
{
  uint64_t v12 = name;
  __src = attr;
  uint64_t v10 = 0;
  memset(__b, 0, sizeof(__b));
  if (__src)
  {
    if (!_os_workgroup_client_attr_is_valid(__src))
    {
      uint64_t v14 = 1;
      uint64_t v23 = 1;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(StatusReg + 8) = 22;
      return 0;
    }
    memcpy(__b, __src, sizeof(__b));
    __src = __b;
    if (__b[0] == 799564724)
    {
      if (!*((_DWORD *)__src + 1)) {
        *((_DWORD *)__src + 1) = 6;
      }
      if (!*((_WORD *)__src + 4)) {
        *((_WORD *)__src + 4) = 64;
      }
    }
    else if (__b[0] != 799564740)
    {
      uint64_t v15 = 1;
      uint64_t v22 = 1;
      unint64_t v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v25 + 8) = 22;
      return 0;
    }
    *(_DWORD *)__src = 2015762650;
  }
  else
  {
    memcpy(__b, &_os_workgroup_parallel_attr_default, sizeof(__b));
    __src = __b;
  }
  if (!_os_workgroup_attr_is_resolved(__src))
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
    JUMPOUT(0x4ADCLL);
  }
  if (_os_workgroup_type_is_parallel_type(*((_WORD *)__src + 4)))
  {
    if (_os_workgroup_attr_is_propagating((uint64_t)__src))
    {
      uint64_t v17 = 1;
      uint64_t v20 = 1;
      unint64_t v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v27 + 8) = 45;
      return 0;
    }
    else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)__src))
    {
      uint64_t v18 = 1;
      uint64_t v19 = 1;
      unint64_t v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v28 + 8) = 45;
      return 0;
    }
    else
    {
      uint64_t v10 = _os_object_alloc(_OS_os_workgroup_parallel_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
      v10[4] = 0;
      v10[3] = 1;
      *((_WORD *)v10 + 28) = *((_WORD *)__src + 4);
      _os_workgroup_set_name((uint64_t)v10, v12);
      return (os_workgroup_parallel_t)v10;
    }
  }
  else
  {
    uint64_t v16 = 1;
    uint64_t v21 = 1;
    unint64_t v26 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v26 + 8) = 22;
    return 0;
  }
}

BOOL _os_workgroup_attr_is_resolved(_DWORD *a1)
{
  return *a1 == 2015762650;
}

BOOL _os_workgroup_type_is_parallel_type(__int16 a1)
{
  return a1 == 64;
}

int os_workgroup_copy_port(os_workgroup_t wg, mach_port_t *mach_port_out)
{
  if (!wg)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (!mach_port_out)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  *mach_port_out = 0;
  if ((*((void *)wg + 3) & 2) != 0) {
    return 22;
  }
  if (!_os_workgroup_has_backing_workinterval((uint64_t)wg)) {
    return 22;
  }
  if (mach_port_mod_refs(mach_task_self_, *((_DWORD *)wg + 10), 0, 1))
  {
    _dispatch_bug(1419, 0, v2, v3, v4, v5, v6, v7);
    return 12;
  }
  else
  {
    *mach_port_out = *((_DWORD *)wg + 10);
    return 0;
  }
}

os_workgroup_t os_workgroup_create_with_port(const char *name, mach_port_t mach_port)
{
  uint64_t v13 = name;
  mach_port_name_t namea = mach_port;
  if (mach_port && namea != -1)
  {
    __int16 v11 = 0;
    if (_os_workgroup_get_wg_wi_types_from_port(namea, &v11, 0))
    {
      return 0;
    }
    else
    {
      BOOL v10 = mach_port_mod_refs(mach_task_self_, namea, 0, 1) == 0;
      BOOL v16 = v10;
      uint64_t v15 = 1443;
      if (v10)
      {
        uint64_t v9 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
        *((_DWORD *)v9 + 10) = namea;
        *((_WORD *)v9 + 28) = v11;
        _os_workgroup_set_name((uint64_t)v9, v13);
        return (os_workgroup_t)v9;
      }
      else
      {
        _dispatch_bug(v15, v16, v2, v3, v4, v5, v6, v7);
        return 0;
      }
    }
  }
  else
  {
    uint64_t v17 = 1;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0;
  }
}

uint64_t _os_workgroup_get_wg_wi_types_from_port(uint64_t a1, _WORD *a2, _DWORD *a3)
{
  unsigned int flags_from_port = work_interval_get_flags_from_port();
  if (flags_from_port)
  {
    return flags_from_port;
  }
  else
  {
    __int16 v6 = _wi_flags_to_wg_type(0);
    int v5 = _wi_flags_to_wi_type(0);
    if (a2) {
      *a2 = v6;
    }
    if (a3) {
      *a3 = v5;
    }
    return 0;
  }
}

void *os_workgroup_create_with_workload_id_and_port(const char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  mach_port_name_t name = a3;
  if (a3 && name != -1)
  {
    __int16 v41 = 0;
    int v40 = 0;
    int wg_wi_types_from_port = _os_workgroup_get_wg_wi_types_from_port(name, &v41, &v40);
    if (wg_wi_types_from_port)
    {
      _dispatch_log("BUG IN CLIENT of %s: Invalid mach port 0x%x", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
      return 0;
    }
    else
    {
      int v38 = 0;
      if (_os_workgroup_workload_id_is_valid_for_wi_type(v43, v40, (unsigned int *)&v38))
      {
        BOOL v37 = mach_port_mod_refs(mach_task_self_, name, 0, 1) == 0;
        BOOL v47 = v37;
        uint64_t v46 = 1488;
        if (v37)
        {
          uint64_t v36 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v22, v23, v24, v25, v26, v27);
          *((_DWORD *)v36 + 10) = name;
          *((_WORD *)v36 + 28) = v41;
          int wg_wi_types_from_port = _os_workgroup_set_work_interval_workload_id((uint64_t)v36, (uint64_t)v43, v38);
          if (!wg_wi_types_from_port || wg_wi_types_from_port == 37)
          {
            _os_workgroup_set_name((uint64_t)v36, v44);
            return v36;
          }
          else
          {
            _os_object_release((uint64_t)v36);
            return 0;
          }
        }
        else
        {
          _dispatch_bug(v46, v47, v22, v23, v24, v25, v26, v27);
          _dispatch_log("BUG IN CLIENT of %s: Invalid mach port 0x%x", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
          return 0;
        }
      }
      else
      {
        _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and port interval type: %s vs %hd", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
        uint64_t v49 = 1;
        uint64_t v50 = 1;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(StatusReg + 8) = 22;
        return 0;
      }
    }
  }
  else
  {
    _dispatch_log("BUG IN CLIENT of %s: Invalid mach port 0x%x", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
    uint64_t v48 = 1;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0;
  }
}

BOOL _os_workgroup_workload_id_is_valid_for_wi_type(const char *a1, int a2, unsigned int *a3)
{
  uint64_t v8 = a1;
  int v7 = a2;
  __int16 v6 = a3;
  unsigned __int16 v5 = 0;
  __int16 v4 = _os_workgroup_lookup_type_from_workload_id(a1, a3, (__int16 *)&v5);
  return _os_workgroup_type_is_default_type(v4)
      || _wg_type_to_wi_type(v5) == v7
      || _wg_type_to_wi_type(v4) == v7;
}

os_workgroup_t os_workgroup_create_with_workgroup(const char *name, os_workgroup_t wg)
{
  if ((*((void *)wg + 3) & 2) == 0)
  {
    uint64_t v9 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
    *((_WORD *)v9 + 28) = *((_WORD *)wg + 28);
    if (_os_workgroup_has_backing_workinterval((uint64_t)wg))
    {
      if (mach_port_mod_refs(mach_task_self_, *((_DWORD *)wg + 10), 0, 1))
      {
        free(v9);
        return 0;
      }
      *((_DWORD *)v9 + 10) = *((_DWORD *)wg + 10);
    }
    _os_workgroup_set_name((uint64_t)v9, name);
    return (os_workgroup_t)v9;
  }
  **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  return 0;
}

void *os_workgroup_create_with_workload_id_and_workgroup(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v34 = a1;
  uint64_t v33 = (const char *)a2;
  uint64_t v32 = a3;
  uint64_t v31 = 0;
  uint64_t v30 = 0;
  uint64_t v29 = *(void *)(a3 + 24);
  uint64_t v30 = v29;
  uint64_t v28 = v29;
  uint64_t v31 = v29;
  if ((v29 & 2) != 0)
  {
    _dispatch_log("BUG IN CLIENT of %s: Workgroup already cancelled", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
    uint64_t v36 = 1;
    uint64_t v39 = 1;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0;
  }
  else
  {
    int v27 = 0;
    uint64_t v24 = v33;
    int v8 = _wg_type_to_wi_type(*(_WORD *)(v32 + 56));
    if (_os_workgroup_workload_id_is_valid_for_wi_type(v24, v8, (unsigned int *)&v27))
    {
      uint64_t v26 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v10, v11, v12, v13, v14, v15);
      *((_WORD *)v26 + 28) = *(_WORD *)(v32 + 56);
      if (_os_workgroup_has_backing_workinterval(v32))
      {
        if (mach_port_mod_refs(mach_task_self_, *(_DWORD *)(v32 + 40), 0, 1))
        {
          _dispatch_log("BUG IN CLIENT of %s: Invalid workgroup port 0x%x", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
          free(v26);
          return 0;
        }
        *((_DWORD *)v26 + 10) = *(_DWORD *)(v32 + 40);
        int v25 = _os_workgroup_set_work_interval_workload_id((uint64_t)v26, (uint64_t)v33, v27);
        if (v25 && v25 != 37)
        {
          _os_object_release((uint64_t)v26);
          return 0;
        }
      }
      _os_workgroup_set_name((uint64_t)v26, v34);
      return v26;
    }
    _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and workgroup interval type: %s vs %hd", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
    uint64_t v37 = 1;
    uint64_t v38 = 1;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = 22;
    return 0;
  }
}

uint64_t _wg_type_to_wi_type(unsigned __int16 a1)
{
  int v1 = _wg_type_to_wi_flags(a1);
  return _wi_flags_to_wi_type(v1);
}

int os_workgroup_max_parallel_threads(os_workgroup_t wg, os_workgroup_mpt_attr_t attr)
{
  if (!wg)
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  if (*((_WORD *)wg + 28) != 4 && *((_WORD *)wg + 28) != 3) {
    return pthread_qos_max_parallelism();
  }
  else {
    return pthread_time_constraint_max_parallelism();
  }
}

void _os_workgroup_join_update_wg(uint64_t a1, uint64_t a2)
{
  if (_os_workgroup_get_current()) {
    __assert_rtn("_os_workgroup_join_update_wg", "workgroup.c", 1653, "cur_wg == NULL");
  }
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 60), 1u, memory_order_relaxed);
  __memset_chk();
  *(_DWORD *)a2 = 1298094680;
  *(_DWORD *)(a2 + 4) = _dispatch_thread_getspecific(3uLL);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = a1;
  _os_workgroup_set_current(a1);
}

void _os_workgroup_set_current(uint64_t a1)
{
  if (a1) {
    _os_object_retain_internal(a1);
  }
  current = _os_workgroup_get_current();
  _dispatch_thread_setspecific(116, a1);
  if (current) {
    _os_object_release_internal((uint64_t)current);
  }
}

BOOL _os_workgroup_join_token_initialized(_DWORD *a1)
{
  return *a1 == 1298094680;
}

uint64_t os_workgroup_set_working_arena(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (!is_mul_ok(4uLL, a3)
    || 4 * (unint64_t)a3 >= 0xFFFFFFFFFFFFFFE8
    || (uint64_t v18 = (_DWORD *)malloc_type_calloc()) == 0)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 12;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else
  {
    v18[4] = a3;
    *(void *)uint64_t v18 = a2;
    *((void *)v18 + 1) = a4;
    uint64_t v16 = 0;
    int v15 = 0;
    long long v17 = *(_OWORD *)(a1 + 48);
    do
    {
      if (_wg_joined_cnt(v17, *((uint64_t *)&v17 + 1))) {
        break;
      }
      _wg_arena(v17, *((unint64_t *)&v17 + 1));
      uint64_t v16 = v4;
      _X1 = *((void *)&v17 + 1);
      _X2 = v18;
      __asm { CASP            X0, X1, X2, X3, [X8] }
      *(void *)&long long v12 = _X0;
      *((void *)&v12 + 1) = *((void *)&v17 + 1);
      BOOL v14 = _X0 == (unint64_t)v17;
      if (_X0 != (unint64_t)v17) {
        long long v17 = v12;
      }
      int v15 = v14;
    }
    while (!v14);
    if (v15)
    {
      if (v16)
      {
        v16[1](*v16);
        free(v16);
      }
      return 0;
    }
    else
    {
      free(v18);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
}

unint64_t _wg_joined_cnt(uint64_t a1, uint64_t a2)
{
  return (a2 & 0xFFFFFFFF00000000) >> 32;
}

__n128 _wg_arena(unint64_t a1, unint64_t a2)
{
  result.n128_u64[0] = a1;
  result.n128_u64[1] = a2;
  return result;
}

uint64_t os_workgroup_get_working_arena(uint64_t a1, unsigned int *a2)
{
  if (_os_workgroup_get_current() != (void *)a1)
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x60B8);
  }
  if (!*(_DWORD *)(a1 + 60)) {
    _dispatch_abort(1765, *(_DWORD *)(a1 + 60) != 0, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v13 = *(void *)(a1 + 48);
  if (!v13) {
    return 0;
  }
  if (a2 && !*(_DWORD *)(v13 + 16))
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x6188);
  }
  if (a2)
  {
    unsigned int add_explicit = 0;
    char v11 = 0;
    for (unsigned int i = 0; i < *(_DWORD *)(v13 + 16); ++i)
    {
      int v9 = *(_DWORD *)(v13 + 24 + 4 * i);
      if (v9 == _dispatch_thread_getspecific(3uLL))
      {
        unsigned int add_explicit = i;
        char v11 = 1;
        break;
      }
    }
    if ((v11 & 1) == 0)
    {
      unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v13 + 20), 1u, memory_order_relaxed);
      if (add_explicit >= *(_DWORD *)(v13 + 16))
      {
        _os_crash();
        __break(1u);
        JUMPOUT(0x62B8);
      }
      *(_DWORD *)(v13 + 24 + 4 * add_explicit) = _dispatch_thread_getspecific(3uLL);
    }
    *a2 = add_explicit;
  }
  return *(void *)v13;
}

void os_workgroup_cancel(os_workgroup_t wg)
{
}

BOOL os_workgroup_testcancel(os_workgroup_t wg)
{
  return (*((void *)wg + 3) & 2) != 0;
}

int os_workgroup_interval_start(os_workgroup_interval_t wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t data)
{
  if (_os_workgroup_get_current() != wg)
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x6430);
  }
  if (!_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data)
    && deadline >= start
    && _start_time_is_in_past(*((_DWORD *)wg + 16), start))
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
    {
      BOOL v10 = _os_workgroup_interval_data_complexity(data);
      int v8 = 0;
      for (uint64_t i = *((void *)wg + 3); ; uint64_t i = v5)
      {
        if ((i & 0xA) != 0)
        {
          int v8 = 22;
          goto LABEL_20;
        }
        if (!_os_workgroup_is_configurable(i))
        {
          int v8 = 1;
          goto LABEL_20;
        }
        if (v10 && !_os_workgroup_has_workload_id(i)) {
          break;
        }
        uint64_t v4 = i;
        uint64_t v5 = i;
        atomic_compare_exchange_strong_explicit((os_workgroup_interval_t)((char *)wg + 24), (unint64_t *)&v5, i | 8, memory_order_relaxed, memory_order_relaxed);
        if (v5 == v4) {
          goto LABEL_20;
        }
      }
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
LABEL_20:
      if (v8)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v8;
        return v8;
      }
      else
      {
        work_interval_instance_clear();
        work_interval_instance_set_start();
        work_interval_instance_set_deadline();
        work_interval_instance_set_complexity();
        int v9 = work_interval_instance_start();
        if (v9)
        {
          atomic_fetch_and_explicit((os_workgroup_interval_t)((char *)wg + 24), 0xFFFFFFFFFFFFFFF7, memory_order_relaxed);
        }
        else if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
        {
          _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v9;
      }
    }
    else
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

BOOL _os_workgroup_interval_invalid_telemetry_request(uint64_t a1, uint64_t a2)
{
  BOOL v3 = 0;
  if (_os_workgroup_interval_data_telemetry_requested(a2)) {
    return *(unsigned __int16 *)(a2 + 16) != *(unsigned __int16 *)(a1 + 44);
  }
  return v3;
}

BOOL _start_time_is_in_past(int a1, uint64_t a2)
{
  if (a1 == 32) {
    return a2 <= mach_absolute_time();
  }
  return v3;
}

BOOL _os_workgroup_interval_data_complexity(_DWORD *a1)
{
  uint64_t v2 = 0;
  if (_os_workgroup_client_interval_data_is_valid(a1)) {
    return (a1[1] & 1) != 0;
  }
  return v2;
}

BOOL _os_workgroup_has_workload_id(char a1)
{
  return (a1 & 0x10) != 0;
}

BOOL _os_workgroup_interval_data_telemetry_requested(uint64_t a1)
{
  BOOL v2 = 0;
  if (a1) {
    return _os_workgroup_telemetry_flavor_is_valid(*(_WORD *)(a1 + 16));
  }
  return v2;
}

uint64_t _os_workgroup_interval_copy_telemetry_data(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = a1;
  uint64_t v5 = a2;
  memset(__b, 0, sizeof(__b));
  uint64_t result = work_interval_instance_get_telemetry_data();
  if (*(_WORD *)(v5 + 16) == 1)
  {
    BOOL v3 = *(void **)(v5 + 8);
    *BOOL v3 = __b[0];
    v3[3] = __b[3];
    v3[4] = __b[4];
    v3[1] = __b[1];
    v3[2] = __b[2];
  }
  return result;
}

int os_workgroup_interval_update(os_workgroup_interval_t wg, uint64_t deadline, os_workgroup_interval_data_t data)
{
  if (_os_workgroup_get_current() != wg)
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x6B80);
  }
  if (_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
  {
    BOOL v6 = _os_workgroup_interval_data_complexity(data);
    uint64_t v5 = *((void *)wg + 3);
    if (_os_workgroup_is_configurable(v5))
    {
      if ((!v6 || _os_workgroup_has_workload_id(v5)) && (v5 & 8) != 0)
      {
        work_interval_instance_set_deadline();
        work_interval_instance_set_complexity();
        int v4 = work_interval_instance_update();
        if (v4)
        {
          int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        }
        else if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
        {
          _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v4;
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 1;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

int os_workgroup_interval_finish(os_workgroup_interval_t wg, os_workgroup_interval_data_t data)
{
  if (_os_workgroup_get_current() != wg)
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x6F84);
  }
  if (_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
  {
    BOOL v5 = _os_workgroup_interval_data_complexity(data);
    uint64_t v4 = *((void *)wg + 3);
    if (_os_workgroup_is_configurable(v4))
    {
      if ((!v5 || _os_workgroup_has_workload_id(v4)) && (v4 & 8) != 0)
      {
        if (*((_DWORD *)wg + 16) == 32) {
          mach_absolute_time();
        }
        work_interval_instance_set_finish();
        work_interval_instance_set_complexity();
        int v3 = work_interval_instance_finish();
        if (v3)
        {
          int v3 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        }
        else
        {
          atomic_fetch_and_explicit((os_workgroup_interval_t)((char *)wg + 24), 0xFFFFFFFFFFFFFFF7, memory_order_relaxed);
          if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data)) {
            _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
          }
        }
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v3;
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 1;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

uint64_t _os_workgroup_pthread_create_with_workgroup(pthread_t *a1, uint64_t a2, const pthread_attr_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = (void *)_dispatch_calloc();
  _os_object_retain_internal(a2);
  *uint64_t v7 = a2;
  v7[1] = a4;
  v7[2] = a5;
  unsigned int v6 = pthread_create(a1, a3, (void *(__cdecl *)(void *))_os_workgroup_pthread_start, v7);
  if (v6)
  {
    _os_object_release_internal(a2);
    free(v7);
  }
  return v6;
}

uint64_t _os_workgroup_pthread_start(void *a1)
{
  int v9 = a1;
  int v8 = a1;
  os_workgroup_t v7 = 0;
  os_workgroup_t v7 = (os_workgroup_t)*a1;
  unsigned int v6 = 0;
  unsigned int v6 = (uint64_t (*)(uint64_t))a1[1];
  uint64_t v5 = 0;
  uint64_t v5 = a1[2];
  free(a1);
  memset(&token_out, 0, sizeof(token_out));
  int v3 = os_workgroup_join(v7, &token_out);
  if (v3)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: pthread_start os_workgroup_join failed";
    qword_F42C0 = v3;
    __break(1u);
    JUMPOUT(0x7564);
  }
  uint64_t v2 = v6(v5);
  os_workgroup_leave(v7, &token_out);
  _os_object_release_internal((uint64_t)v7);
  return v2;
}

BOOL _os_workgroup_client_interval_data_initialized(_DWORD *a1)
{
  return *a1 == 1386695757;
}

BOOL _os_workgroup_client_attr_initialized(_DWORD *a1)
{
  BOOL v2 = 1;
  if (*a1 != 799564724) {
    return *a1 == 799564740;
  }
  return v2;
}

uint64_t _wg_type_to_wi_flags(unsigned __int16 a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    char v1 = 1;
  }
  else
  {
    uint64_t v2 = 0;
    char v1 = 0;
  }
  if (v1)
  {
    _os_crash();
    __break(1u);
    JUMPOUT(0x7734);
  }
  switch(v2)
  {
    case 0:
      unsigned int v4 = 4;
      break;
    case 1:
      unsigned int v4 = 4;
      break;
    case 2:
      unsigned int v4 = 805306372;
      break;
    case 3:
      unsigned int v4 = 268435484;
      break;
    case 4:
      unsigned int v4 = 268435480;
      break;
    case 5:
      unsigned int v4 = 0x20000000;
      break;
    case 6:
      unsigned int v4 = 0x20000000;
      break;
    case 7:
      unsigned int v4 = 0x40000000;
      break;
    case 8:
      unsigned int v4 = 1342177280;
      break;
    case 9:
      unsigned int v4 = 1610612800;
      break;
    case 10:
      unsigned int v4 = 1879048256;
      break;
    default:
      JUMPOUT(0);
  }
  return v4;
}

BOOL _os_workgroup_attr_has_workload_id(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 12) & 1) != 0;
}

void _os_workgroup_set_work_interval_name(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a1 + 40) || *(_DWORD *)(a1 + 40) == -1)
  {
    uint64_t v2 = *(unsigned int *)(a1 + 40);
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workgroup port";
    qword_F42C0 = v2;
    __break(1u);
    JUMPOUT(0x7824);
  }
  if (a2) {
    uint64_t v9 = __strlcpy_chk();
  }
  else {
    uint64_t v9 = 0;
  }
  if (v9)
  {
    if (__work_interval_ctl() == -1)
    {
      int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v10) {
        _dispatch_bug(534, v10, v3, v4, v5, v6, v7, v8);
      }
    }
  }
}

uint64_t _os_workgroup_lookup_type_from_workload_id(const char *a1, unsigned int *a2, __int16 *a3)
{
  unsigned __int16 v7 = 0;
  __int16 v6 = 0;
  unsigned int v5 = 0;
  if (!a1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Workload identifier must not be NULL";
    __break(1u);
    JUMPOUT(0x79D4);
  }
  for (unint64_t i = 0; i < 2; ++i)
  {
    if (!strcasecmp(a1, (&_os_workgroup_workload_id_table)[2 * i]))
    {
      unsigned __int16 v7 = (unsigned __int16)(&_os_workgroup_workload_id_table)[2 * i + 1];
      __int16 v6 = *((_WORD *)&_os_workgroup_workload_id_table + 8 * i + 5);
      if (_os_workgroup_type_is_default_type(v6)) {
        __int16 v6 = v7;
      }
      unsigned int v5 = *((_DWORD *)&_os_workgroup_workload_id_table + 4 * i + 3) & 0xFFFFFFFA | 1;
      if (_os_workgroup_type_is_default_type(v7))
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workload ID type";
        qword_F42C0 = i;
        __break(1u);
        JUMPOUT(0x7AF0);
      }
      break;
    }
  }
  if (!v5) {
    unsigned int v5 = 1;
  }
  *a2 = v5;
  *a3 = v6;
  return v7;
}

uint64_t _wi_flags_to_wg_type(int a1)
{
  BOOL v4 = (a1 & 4) != 0;
  int v3 = _wi_flags_to_wi_type(a1);
  if (v3)
  {
    switch(v3)
    {
      case 268435456:
        if (v4) {
          return 3;
        }
        else {
          return 4;
        }
      case 536870912:
        return 5;
      case 805306368:
        return 2;
      case 1073741824:
        return 7;
      case 1342177280:
        return 8;
      case 1610612736:
        return 9;
      case 1879048192:
        return 10;
      default:
        __snprintf_chk(v7, 0x200uLL, 0, 0x200uLL, "BUG IN DISPATCH: Invalid wi flags = %u", a1);
        _os_crash();
        __break(1u);
        JUMPOUT(0x7D10);
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _wi_flags_to_wi_type(int a1)
{
  return a1 & 0xF0000000;
}

uint64_t _dispatch_thread_setspecific(uint64_t result, uint64_t a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    __break(1u);
    JUMPOUT(0x7DD0);
  }
  *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = a2;
  return result;
}

uint64_t dispatch_atfork_prepare()
{
  uint64_t v0 = _voucher_atfork_prepare();
  return _os_object_atfork_prepare(v0);
}

void *dispatch_atfork_parent(uint64_t a1)
{
  return _voucher_atfork_parent();
}

void dispatch_atfork_child(uint64_t a1)
{
  _os_object_atfork_prepare(a1);
  _voucher_atfork_child();
  _dispatch_event_loop_atfork_child();
  if (_dispatch_unsafe_fork) {
    _dispatch_child_of_unsafe_fork = 1;
  }
  _dispatch_queue_atfork_child(v1, v2, v3, v4, v5, v6, v7, v8);
  _dispatch_unsafe_fork = 0;
}

uint64_t _dispatch_sigmask()
{
  v8[9] = 4;
  v8[8] = 5;
  v8[7] = 7;
  v8[6] = 8;
  v8[5] = 10;
  v8[4] = 11;
  v8[3] = 12;
  v8[2] = 13;
  v8[1] = 27;
  v8[0] = -67116761;
  int v7 = pthread_sigmask(1, v8, 0);
  uint64_t v10 = v7;
  uint64_t v9 = 108;
  if (v7) {
    _dispatch_bug(v9, v10, v0, v1, v2, v3, v4, v5);
  }
  return v7;
}

BOOL _dispatch_is_multithreaded()
{
  return (_dispatch_unsafe_fork & 1) != 0;
}

uint64_t _dispatch_is_fork_of_multithreaded_parent()
{
  return _dispatch_child_of_unsafe_fork & 1;
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  uint64_t v2 = (dispatch_queue_s *)_dispatch_thread_getspecific(0x14uLL);
  if (v2) {
    return v2;
  }
  else {
    return (dispatch_queue_t)&off_F0680;
  }
}

unint64_t _dispatch_queue_attr_to_info(uint64_t *a1)
{
  unsigned int v5 = 0;
  if (a1)
  {
    if (a1 < (uint64_t *)&_dispatch_queue_attr_concurrent || a1 >= qword_ECA38)
    {
      uint64_t v3 = 0;
      if (*a1) {
        uint64_t v3 = *a1;
      }
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue attribute";
      qword_F42C0 = v3;
      __break(1u);
      JUMPOUT(0x83E0);
    }
    HIWORD(v6) = (unint64_t)((((((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) & 1) << 21) | ((((((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) & 2) == 0) << 20)) >> 16;
    BYTE1(v6) = -(((unint64_t)(((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) >> 2) & 0xF);
    unint64_t v4 = (unint64_t)(((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) >> 6;
    int v1 = (v4 * (unsigned __int128)0x2492492492492493uLL) >> 64;
    LOBYTE(v6) = v4 - 7 * ((v1 + ((v4 - v1) >> 1)) >> 2);
    v4 /= 7uLL;
    return v6 & 0xFFF0FFFF | ((v4 - (((v4 / 3) & 0x7FFFFFFF) + 2 * (v4 / 3))) << 18) | (((v4 / 3) - (((v4 / 3 / 3) & 0x7FFFFFFF) + 2 * (v4 / 3 / 3))) << 16);
  }
  return v5;
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  unsigned __int8 v8 = relative_priority;
  if (qos_class == QOS_CLASS_UNSPECIFIED
    || qos_class == 5
    || qos_class == QOS_CLASS_BACKGROUND
    || qos_class == QOS_CLASS_UTILITY
    || qos_class == QOS_CLASS_DEFAULT
    || qos_class == QOS_CLASS_USER_INITIATED
    || qos_class == QOS_CLASS_USER_INTERACTIVE)
  {
    BOOL v6 = 0;
    if (relative_priority >= -15) {
      BOOL v6 = relative_priority <= 0;
    }
    BOOL v11 = v6;
  }
  else
  {
    BOOL v11 = 0;
  }
  if (!v11) {
    return attr;
  }
  int v7 = _dispatch_queue_attr_to_info((uint64_t *)attr);
  if (qos_class <= 5)
  {
    uint64_t v4 = qos_class - 5;
    char v3 = 0;
  }
  else
  {
    uint64_t v4 = qos_class - 5;
    char v3 = 1;
  }
  if ((v3 & 1) == 0)
  {
    switch(v4)
    {
      case 0:
        unsigned __int8 v12 = 1;
        return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 17:
      case 18:
      case 19:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        break;
      case 4:
        unsigned __int8 v12 = 2;
        return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
      case 12:
        unsigned __int8 v12 = 3;
        return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
      case 16:
        unsigned __int8 v12 = 4;
        return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
      case 20:
        unsigned __int8 v12 = 5;
        return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
      case 28:
        unsigned __int8 v12 = 6;
        return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
      default:
        JUMPOUT(0);
    }
  }
  unsigned __int8 v12 = 0;
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v7 & 0xFFFF0000 | v12 | (v8 << 8));
}

char *_dispatch_queue_attr_from_info(unsigned int a1)
{
  return (char *)&_dispatch_queue_attr_concurrent
       + 21504 * (BYTE2(a1) & 3)
       + 7168 * ((a1 >> 18) & 3)
       + 1024 * a1
       + 32 * (((a1 >> 20) & 1) == 0)
       + 16 * ((a1 >> 21) & 1)
       + -64 * ((__int16)a1 >> 8);
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  unsigned int v2 = _dispatch_queue_attr_to_info((uint64_t *)attr) & 0xFFDFFFFF | 0x200000;
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v2);
}

char *dispatch_queue_attr_make_with_overcommit(uint64_t *a1, char a2)
{
  char v5 = a2 & 1;
  int v3 = _dispatch_queue_attr_to_info(a1);
  if (v5) {
    unsigned int v4 = v3 & 0xFFFCFFFF | 0x10000;
  }
  else {
    unsigned int v4 = v3 & 0xFFFCFFFF | 0x20000;
  }
  return _dispatch_queue_attr_from_info(v4);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  unsigned int v3 = _dispatch_queue_attr_to_info((uint64_t *)attr) & 0xFFF3FFFF | ((frequency & 3) << 18);
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v3);
}

void _dispatch_object_no_invoke(uint64_t *a1)
{
  uint64_t v2 = 0;
  if (*a1) {
    uint64_t v2 = *a1;
  }
  uint64_t v1 = *(void *)(v2 + 16);
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: do_invoke called";
  qword_F42C0 = v1;
  __break(1u);
}

void _dispatch_object_no_dispose(uint64_t *a1)
{
  uint64_t v2 = 0;
  if (*a1) {
    uint64_t v2 = *a1;
  }
  uint64_t v1 = *(void *)(v2 + 16);
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: do_dispose called";
  qword_F42C0 = v1;
  __break(1u);
}

uint64_t _dispatch_object_missing_debug()
{
  return __strlcpy_chk();
}

void _dispatch_queue_no_activate(uint64_t *a1)
{
  uint64_t v2 = 0;
  if (*a1) {
    uint64_t v2 = *a1;
  }
  uint64_t v1 = *(void *)(v2 + 16);
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: dq_activate called";
  qword_F42C0 = v1;
  __break(1u);
}

void _dispatch_data_destructor_free_block_invoke(id a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: free destructor called";
  __break(1u);
}

void _dispatch_data_destructor_none_block_invoke_2(id a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: none destructor called";
  __break(1u);
}

void _dispatch_data_destructor_vm_deallocate_block_invoke_3(id a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: vmdeallocate destructor called";
  __break(1u);
}

void _dispatch_data_destructor_inline_block_invoke_4(id a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: inline destructor called";
  __break(1u);
}

BOOL _dispatch_parse_BOOL(const char *a1)
{
  BOOL v2 = 1;
  if (strcasecmp(a1, "YES"))
  {
    BOOL v2 = 1;
    if (strcasecmp(a1, "Y"))
    {
      BOOL v2 = 1;
      if (strcasecmp(a1, "TRUE")) {
        return atoi(a1) != 0;
      }
    }
  }
  return v2;
}

BOOL _dispatch_getenv_BOOL(const char *a1, char a2)
{
  char v4 = a2 & 1;
  *(void *)&v3[4] = getenv(a1);
  if (*(void *)&v3[4]) {
    *(_DWORD *)unsigned int v3 = _dispatch_parse_BOOL(*(const char **)&v3[4]);
  }
  else {
    *(void *)unsigned int v3 = v4 & 1;
  }
  return *(_DWORD *)v3 != 0;
}

uint64_t _dispatch_build_init(size_t a1)
{
  v2[1] = a1;
  *(void *)unsigned int v3 = 0x4100000001;
  v2[0] = 16;
  return sysctl(v3, 2u, &_dispatch_build, v2, 0, 0);
}

uint64_t _dispatch_continuation_get_function_symbol(uint64_t a1)
{
  if ((*(unsigned char *)a1 & 0x20) != 0)
  {
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t v10 = _Block_get_invoke_fn(v13);
    BOOL v11 = 0;
    if (v10) {
      BOOL v11 = (uint64_t (*)())v10;
    }
    if (v11 == _dispatch_block_special_invoke)
    {
      if (*(void *)(v13 + 32) != 3512316172)
      {
        uint64_t v1 = *(void *)(v13 + 32);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
        qword_F42C0 = v1;
        __break(1u);
        JUMPOUT(0x907CLL);
      }
      uint64_t v14 = v13 + 32;
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v8 = _Block_get_invoke_fn(*(void *)(v14 + 40));
    uint64_t v9 = 0;
    if (v8) {
      uint64_t v9 = v8;
    }
    uint64_t v7 = 0;
    if (v9) {
      return v9;
    }
    return v7;
  }
  else if ((*(unsigned char *)a1 & 0x10) != 0)
  {
    uint64_t v5 = _Block_get_invoke_fn(*(void *)(a1 + 40));
    uint64_t v6 = 0;
    if (v5) {
      uint64_t v6 = v5;
    }
    uint64_t v4 = 0;
    if (v6) {
      return v6;
    }
    return v4;
  }
  else
  {
    uint64_t v3 = 0;
    if (*(void *)(a1 + 32)) {
      return *(void *)(a1 + 32);
    }
    return v3;
  }
}

uint64_t _Block_get_invoke_fn(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v2 = 0;
  if (v3) {
    return v3;
  }
  return v2;
}

void _dispatch_debugv(uint64_t *a1, const char *a2, va_list a3)
{
  uint64_t v14 = _dispatch_uptime() - dispatch_log_basetime;
  uint64_t v3 = _dispatch_thread_getspecific(0);
  int v16 = __snprintf_chk(v23, 0x800uLL, 0, 0xFFFFFFFFFFFFFFFFLL, "%llu\t\t%p\t", v14, v3);
  if (v16 >= 0)
  {
    if ((unint64_t)v16 <= 0x800) {
      uint64_t v12 = v16;
    }
    else {
      uint64_t v12 = 2048;
    }
    uint64_t v13 = v12;
  }
  else
  {
    uint64_t v13 = 0;
  }
  if (a1)
  {
    uint64_t v18 = v13 + _dispatch_object_debug2(a1, (uint64_t)&v23[v13], 2048 - v13);
    if ((unint64_t)(v18 + 2) >= 0x800) {
      _dispatch_abort(1433, (unint64_t)(v18 + 2) < 0x800, v4, v5, v6, v7, v8, v9);
    }
    v23[v18] = 58;
    uint64_t v10 = v18 + 1;
    uint64_t v19 = v18 + 2;
    v23[v10] = 32;
    v23[v19] = 0;
  }
  else
  {
    uint64_t v19 = v13 + __strlcpy_chk();
  }
  int v17 = __vsnprintf_chk(&v23[v19], 2048 - v19, 0, 0xFFFFFFFFFFFFFFFFLL, a2, a3);
  if (v17 >= 0) {
    uint64_t v11 = v17;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v15 = v19 + v11;
  if ((unint64_t)(v19 + v11) > 0x7FF) {
    uint64_t v15 = 2047;
  }
  if (_dispatch_logv_pred != -1) {
    dispatch_once_f(&_dispatch_logv_pred, 0, (dispatch_function_t)_dispatch_logv_init);
  }
  if ((dispatch_log_disabled & 1) == 0)
  {
    if (dispatch_logfile == -1) {
      _dispatch_syslog();
    }
    else {
      _dispatch_log_file((uint64_t)v23, v15);
    }
  }
}

void _dispatch_object_debug(uint64_t *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t _dispatch_temporary_resource_shortage()
{
  return sleep_NOCANCEL();
}

uint64_t _dispatch_calloc()
{
  while (1)
  {
    uint64_t v1 = malloc_type_calloc();
    if (v1) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }
  return v1;
}

const char *_dispatch_strdup_if_mutable(const char *a1)
{
  strlen(a1);
  if (((_dyld_is_memory_immutable() ^ 1) & 1) == 0) {
    return a1;
  }
  uint64_t v8 = malloc_type_malloc();
  if (v8) {
    __memcpy_chk();
  }
  else {
    _dispatch_bug(1515, 0, v1, v2, v3, v4, v5, v6);
  }
  return (const char *)v8;
}

void *_dispatch_Block_copy(const void *a1)
{
  if (!a1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: NULL was passed where a block should have been";
    __break(1u);
    JUMPOUT(0x99A0);
  }
  while (1)
  {
    uint64_t v2 = _Block_copy(a1);
    if (v2) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }
  return v2;
}

void _dispatch_call_block_and_release(void (**a1)(void))
{
}

uint64_t _dispatch_client_callout(uint64_t a1, uint64_t (*a2)(uint64_t))
{
  return a2(a1);
}

uint64_t _dispatch_client_callout2(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  return a3(a1, a2);
}

uint64_t _dispatch_client_callout3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  return a4(a1, a2, a3);
}

uint64_t _dispatch_client_callout4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, void))
{
  return a5(a1, a2, a3, a4);
}

uint64_t _dispatch_client_callout3_a(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  return a4(a1, a2, a3);
}

void *_os_object_alloc_bridged(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_objc_alloc(a1, a2, a3, a4, a5, a6, a7, a8);
}

void *_os_objc_alloc(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 8) {
    _dispatch_abort(1693, a2 >= 8, a3, a4, a5, a6, a7, a8);
  }
  while (1)
  {
    uint64_t v10 = (void *)malloc_type_calloc();
    if (v10) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }
  uint64_t v9 = 0;
  if (a1) {
    uint64_t v9 = a1;
  }
  void *v10 = v9;
  return v10;
}

void *_os_object_alloc_realized(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 0x10) {
    _dispatch_abort(1711, a2 >= 0x10, a3, a4, a5, a6, a7, a8);
  }
  uint64_t result = _os_objc_alloc(a1, a2, a3, a4, a5, a6, a7, a8);
  *((_DWORD *)result + 2) = 1;
  *((_DWORD *)result + 3) = 1;
  return result;
}

void *_os_object_alloc(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1;
  if (!a1) {
    uint64_t v9 = &_os_object_vtable;
  }
  return _os_object_alloc_realized((uint64_t)v9, a2, a3, a4, a5, a6, a7, a8);
}

void _os_object_dealloc(void *a1)
{
  *a1 = 512;
  free(a1);
}

void _os_object_xref_dispose(uint64_t a1)
{
  atomic_load_explicit((atomic_uint *volatile)(a1 + 12), memory_order_acquire);
  uint64_t v2 = 0;
  if (*(void *)a1) {
    uint64_t v2 = *(void (***)(uint64_t))a1;
  }
  if (*v2)
  {
    uint64_t v1 = 0;
    if (*(void *)a1) {
      uint64_t v1 = *(void (***)(uint64_t))a1;
    }
    (*v1)(a1);
  }
  else
  {
    _os_object_release_internal(a1);
  }
}

void _os_object_dispose(uint64_t *a1)
{
  atomic_load_explicit((atomic_uint *volatile)(a1 + 1), memory_order_acquire);
  uint64_t v2 = 0;
  if (*a1) {
    uint64_t v2 = *a1;
  }
  if (*(void *)(v2 + 8))
  {
    uint64_t v1 = 0;
    if (*a1) {
      uint64_t v1 = *a1;
    }
    (*(void (**)(uint64_t *))(v1 + 8))(a1);
  }
  else
  {
    _os_object_dealloc(a1);
  }
}

void *__cdecl os_retain(void *object)
{
  if (object) {
    return (void *)_os_object_retain((uint64_t)object);
  }
  else {
    return 0;
  }
}

void os_release(void *object)
{
  if (object) {
    _os_object_release((uint64_t)object);
  }
}

uint64_t _dispatch_autorelease_pool_push()
{
  uint64_t v1 = 0;
  if (_dispatch_begin_NSAutoReleasePool) {
    return _dispatch_begin_NSAutoReleasePool();
  }
  return v1;
}

uint64_t _dispatch_autorelease_pool_pop(uint64_t result)
{
  if (_dispatch_end_NSAutoReleasePool) {
    return _dispatch_end_NSAutoReleasePool(result);
  }
  return result;
}

uint64_t _dispatch_last_resort_autorelease_pool_push(uint64_t a1)
{
  uint64_t result = _dispatch_autorelease_pool_push();
  *(void *)(a1 + 24) = result;
  return result;
}

uint64_t _dispatch_last_resort_autorelease_pool_pop(uint64_t a1)
{
  uint64_t result = _dispatch_autorelease_pool_pop(*(void *)(a1 + 24));
  *(void *)(a1 + 24) = 0;
  return result;
}

uint64_t dispatch_mach_msg_get_context(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  if (*(_DWORD *)(v3 + 4) >= 0x3Cu) {
    return *(void *)(v3 + 52);
  }
  return v2;
}

uint64_t _dispatch_wakeup_runloop_thread()
{
  return 0;
}

void _dispatch_mach_notify_port_destroyed(uint64_t a1, unsigned int a2)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: unexpected receipt of port-destroyed";
  qword_F42C0 = a2;
  __break(1u);
}

uint64_t sub_A410()
{
  return 5;
}

void _dispatch_mach_notify_no_senders(uint64_t a1, unsigned int a2)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: unexpected receipt of no-more-senders";
  qword_F42C0 = a2;
  __break(1u);
}

uint64_t sub_A468()
{
  return 5;
}

uint64_t _dispatch_mach_notify_send_once(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_log("Corruption: An app/library deleted a libdispatch dead-name notification", a2, a3, a4, a5, a6, a7, a8, v9);
  return 0;
}

uint64_t _dispatch_mach_xpc_no_handle_message()
{
  return 0;
}

uint64_t _dispatch_mach_msg_context_no_async_reply_queue()
{
  return 0;
}

void _dispatch_mach_default_async_reply_handler()
{
  qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_mach_default_async_reply_handler called";
  qword_F42C0 = (uint64_t)_dispatch_mach_xpc_hooks;
  __break(1u);
}

void sub_A530()
{
}

uint64_t _dispatch_mach_enable_sigterm()
{
  return 1;
}

uint64_t _dispatch_logv_init(uint64_t a1)
{
  uint64_t v10 = a1;
  char v9 = 1;
  uint64_t result = (uint64_t)getenv("LIBDISPATCH_LOG");
  __s1 = (char *)result;
  if (result)
  {
    uint64_t result = strcmp(__s1, "YES");
    if (result)
    {
      uint64_t result = strcmp(__s1, "NO");
      if (result)
      {
        uint64_t result = strcmp(__s1, "syslog");
        if (result)
        {
          uint64_t result = strcmp(__s1, "file");
          if (result)
          {
            uint64_t result = strcmp(__s1, "stderr");
            if (!result)
            {
              char v9 = 1;
              dispatch_logfile = 2;
            }
          }
          else
          {
            char v9 = 1;
          }
        }
        else
        {
          char v9 = 0;
        }
      }
      else
      {
        dispatch_log_disabled = 1;
      }
    }
  }
  if ((dispatch_log_disabled & 1) == 0)
  {
    if ((v9 & 1) != 0 && dispatch_logfile == -1)
    {
      pid_t v2 = getpid();
      __snprintf_chk(v11, 0x400uLL, 0, 0x400uLL, "/var/tmp/libdispatch.%d.log", v2);
      uint64_t result = open_NOCANCEL();
      dispatch_logfile = result;
    }
    if (dispatch_logfile != -1)
    {
      v7.tv_sec = 0;
      *(void *)&v7.tv_usec = 0;
      gettimeofday(&v7, 0);
      dispatch_log_basetime = _dispatch_uptime();
      int v5 = dispatch_logfile;
      uint64_t v6 = getprogname();
      if (v6) {
        uint64_t v4 = v6;
      }
      else {
        uint64_t v4 = "";
      }
      pid_t v3 = getpid();
      return dprintf(v5, "=== log file opened for %s[%u] at %ld.%06u ===\n", v4, v3, v7.tv_sec, v7.tv_usec);
    }
  }
  return result;
}

uint64_t _dispatch_log_file(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + a2) = 10;
  do
    uint64_t result = write_NOCANCEL();
  while (result == -1 && **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) == 4);
  return result;
}

uint64_t _dispatch_logv_file(const char *a1, va_list a2)
{
  uint64_t v2 = _dispatch_uptime();
  int v6 = __snprintf_chk(v10, 0x800uLL, 0, 0xFFFFFFFFFFFFFFFFLL, "%llu\t", v2 - dispatch_log_basetime);
  if (v6 >= 0)
  {
    if ((unint64_t)v6 <= 0x800) {
      uint64_t v4 = v6;
    }
    else {
      uint64_t v4 = 2048;
    }
    uint64_t v5 = v4;
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t result = __vsnprintf_chk(&v10[v5], 2048 - v5, 0, 0xFFFFFFFFFFFFFFFFLL, a1, a2);
  if ((int)result >= 0)
  {
    unint64_t v7 = v5 + (int)result;
    if (v7 > 0x7FF) {
      unint64_t v7 = 2047;
    }
    return _dispatch_log_file((uint64_t)v10, v7);
  }
  return result;
}

uint64_t _dispatch_syslog()
{
  return _simple_asl_log();
}

void _dispatch_vsyslog(char *a1, char *a2)
{
  size_t v2[2] = a1;
  v2[1] = a2;
  v2[0] = 0;
  vasprintf(v2, a1, a2);
  if (v2[0])
  {
    _dispatch_syslog();
    free(v2[0]);
  }
}

uint64_t _dispatch_uptime()
{
  return mach_absolute_time();
}

uint64_t _dispatch_object_debug2(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = 0;
  if (*a1) {
    uint64_t v4 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(v4 + 40))(a1, a2, a3);
}

uint64_t _os_object_retain_internal(uint64_t result)
{
  int add_explicit = *(_DWORD *)(result + 8);
  if (add_explicit != 0x7FFFFFFF) {
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 8), 1u, memory_order_relaxed);
  }
  if (add_explicit <= 0)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xAD1CLL);
  }
  return result;
}

uint64_t _os_object_retain_internal_n(uint64_t result, unsigned __int16 a2)
{
  int add_explicit = *(_DWORD *)(result + 8);
  if (add_explicit != 0x7FFFFFFF) {
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 8), a2, memory_order_relaxed);
  }
  if (add_explicit <= 0)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xAE24);
  }
  return result;
}

void _os_object_release_internal(uint64_t a1)
{
  signed int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != 0x7FFFFFFF) {
    signed int v2 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v2 < 1)
  {
    if (v2 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xAF78);
    }
    int v1 = *(_DWORD *)(a1 + 12);
    if (v1 >= 1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0xAFD8);
    }
    _os_object_dispose((uint64_t *)a1);
  }
}

void _os_object_release_internal_n(uint64_t a1, unsigned __int16 a2)
{
  signed int v3 = *(_DWORD *)(a1 + 8);
  if (v3 != 0x7FFFFFFF) {
    signed int v3 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), -a2, memory_order_release) - a2;
  }
  if (v3 < 1)
  {
    if (v3 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB13CLL);
    }
    int v2 = *(_DWORD *)(a1 + 12);
    if (v2 >= 1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_F42C0 = v2;
      __break(1u);
      JUMPOUT(0xB19CLL);
    }
    _os_object_dispose((uint64_t *)a1);
  }
}

uint64_t _os_object_retain(uint64_t result)
{
  int add_explicit = *(_DWORD *)(result + 12);
  if (add_explicit != 0x7FFFFFFF) {
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 12), 1u, memory_order_relaxed);
  }
  if (add_explicit <= 0)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xB2A0);
  }
  return result;
}

uint64_t _os_object_retain_with_resurrect(uint64_t a1)
{
  unsigned int add_explicit = *(_DWORD *)(a1 + 12);
  if (add_explicit != 0x7FFFFFFF) {
    unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 12), 1u, memory_order_relaxed);
  }
  if ((int)(add_explicit + 1) <= 0)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an over-released object";
    __break(1u);
    JUMPOUT(0xB3ACLL);
  }
  if (!add_explicit) {
    _os_object_retain_internal(a1);
  }
  return a1;
}

void _os_object_release(uint64_t a1)
{
  signed int v1 = *(_DWORD *)(a1 + 12);
  if (v1 != 0x7FFFFFFF) {
    signed int v1 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 12), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v1 < 1)
  {
    if (v1 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB524);
    }
    char v2 = 1;
  }
  else
  {
    char v2 = 0;
  }
  if (v2 == 1) {
    _os_object_xref_dispose(a1);
  }
}

void _os_object_release_without_xref_dispose(uint64_t a1)
{
  signed int v1 = *(_DWORD *)(a1 + 12);
  if (v1 != 0x7FFFFFFF) {
    signed int v1 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 12), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v1 < 1)
  {
    if (v1 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB6A0);
    }
    char v2 = 1;
  }
  else
  {
    char v2 = 0;
  }
  if (v2 == 1) {
    _os_object_release_internal(a1);
  }
}

void *_dispatch_object_alloc(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_object_alloc_realized(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_object_dealloc(void *a1)
{
  *a1 = 0;
  free(a1);
}

void dispatch_retain(dispatch_object_t object)
{
}

void dispatch_release(dispatch_object_t object)
{
  signed int v1 = *((_DWORD *)object + 3);
  if (v1 != 0x7FFFFFFF) {
    signed int v1 = atomic_fetch_add_explicit((atomic_uint *volatile)((char *)object + 12), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v1 < 1)
  {
    if (v1 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB8B4);
    }
    char v2 = 1;
  }
  else
  {
    char v2 = 0;
  }
  if (v2 == 1)
  {
    atomic_load_explicit((atomic_uint *volatile)((char *)object + 12), memory_order_acquire);
    _dispatch_xref_dispose((uint64_t)object);
  }
}

void _dispatch_xref_dispose(uint64_t a1)
{
  uint64_t v10 = 0;
  if (*(void *)a1) {
    uint64_t v10 = *(void *)a1;
  }
  if ((*(void *)(v10 + 16) & 0xF0) == 0x10)
  {
    _dispatch_queue_xref_dispose(a1);
    uint64_t v9 = 0;
    if (*(void *)a1) {
      uint64_t v9 = *(void *)a1;
    }
    uint64_t v8 = *(void *)(v9 + 16);
    switch(v8)
    {
      case 275:
        _dispatch_source_xref_dispose((uint64_t *)a1);
        break;
      case 531:
        _dispatch_channel_xref_dispose(a1);
        break;
      case 787:
        if ((*(_WORD *)(a1 + 116) >> 4)) {
          *(void *)(*(void *)(a1 + 88) + 48) = 195952365;
        }
        break;
      case 395025:
        _dispatch_runloop_queue_xref_dispose(a1, v1, v2, v3, v4, v5, v6, v7);
        break;
    }
  }
  _dispatch_release_tailcall(a1);
}

void _dispatch_release_tailcall(uint64_t a1)
{
}

void _dispatch_dispose(uint64_t *a1)
{
  uint64_t v9 = a1;
  uint64_t v8 = 0;
  uint64_t v8 = (uint64_t (***)())a1[3];
  dispatch_function_t v7 = 0;
  uint64_t v10 = a1;
  uint64_t v4 = 0;
  if (a1[5]) {
    uint64_t v4 = (void (__cdecl *)(void *))a1[5];
  }
  dispatch_function_t v7 = v4;
  uint64_t v6 = 0;
  uint64_t v6 = (void *)v9[4];
  char v5 = 1;
  if (v9[2] != -1985229329)
  {
    uint64_t v1 = v9[2];
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while enqueued";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0xBC24);
  }
  BOOL v3 = 0;
  if (v8) {
    BOOL v3 = v8[8] == (uint64_t (**)())((char *)&dword_14 + 2);
  }
  if (v3)
  {
    int v13 = 4;
    uint64_t v12 = 0;
    int v11 = 0;
    uint64_t v8 = &off_F0600;
  }
  uint64_t v2 = 0;
  if (*v9) {
    uint64_t v2 = *v9;
  }
  (*(void (**)(uint64_t *, char *))(v2 + 32))(v9, &v5);
  if (v5)
  {
    _dispatch_object_finalize();
    _dispatch_object_dealloc(v9);
  }
  if (v7 && v6) {
    dispatch_channel_async_f((dispatch_queue_t)v8, v6, v7);
  }
  if (v8) {
    _dispatch_release_tailcall((uint64_t)v8);
  }
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  uint64_t v2 = 0;
  if (*(void *)object) {
    uint64_t v2 = *(void *)object;
  }
  if ((*(void *)(v2 + 16) & 0x40000) != 0) {
    return 0;
  }
  else {
    return (void *)*((void *)object + 4);
  }
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  uint64_t v2 = 0;
  if (*(void *)object) {
    uint64_t v2 = *(void *)object;
  }
  if ((*(void *)(v2 + 16) & 0x40000) == 0) {
    *((void *)object + 4) = context;
  }
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
  uint64_t v3 = 0;
  if (*(void *)object) {
    uint64_t v3 = *(void *)object;
  }
  if ((*(void *)(v3 + 16) & 0x40000) == 0)
  {
    dispatch_function_t v2 = 0;
    if (finalizer) {
      dispatch_function_t v2 = finalizer;
    }
    *((void *)object + 5) = v2;
  }
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  dispatch_queue_t v19 = queue;
  char v18 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    uint64_t v17 = 0;
    if (*(void *)object) {
      uint64_t v17 = *(void *)object;
    }
    LOBYTE(v16) = 1;
    if ((*(unsigned char *)(v17 + 18) & 1) == 0)
    {
      uint64_t v15 = 0;
      if (*(void *)object) {
        uint64_t v15 = *(void *)object;
      }
      int v16 = (*(unsigned __int8 *)(v15 + 18) >> 1) & 1;
    }
    char v18 = v16;
  }
  if ((v18 & 1) == 0)
  {
    char v14 = 0;
    if (queue)
    {
      char v14 = 0;
      if ((*((unsigned char *)queue + 87) & 8) != 0)
      {
        if (*(void *)object >= 0x1000uLL)
        {
          uint64_t v13 = 0;
          if (*(void *)object) {
            uint64_t v13 = *(void *)object;
          }
          char v12 = 1;
          if (*(void *)(v13 + 16) != 1)
          {
            uint64_t v11 = 0;
            if (*(void *)object) {
              uint64_t v11 = *(void *)object;
            }
            BOOL is_timer = 0;
            if (*(unsigned char *)(v11 + 16) == 19) {
              BOOL is_timer = _dispatch_source_is_timer((uint64_t)object);
            }
            char v12 = is_timer;
          }
          char v21 = v12 & 1;
        }
        else
        {
          char v21 = 1;
        }
        char v14 = v21 ^ 1;
      }
    }
    if (v14)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
      qword_F42C0 = (uint64_t)object;
      __break(1u);
      JUMPOUT(0xC39CLL);
    }
    uint64_t v9 = 0;
    if (*(void *)object) {
      uint64_t v9 = *(void *)object;
    }
    if ((*(void *)(v9 + 16) & 0xF0) == 0x10)
    {
      _dispatch_lane_set_target_queue((uint64_t)object, (uint64_t)v19, v2, v3, v4, v5, v6, v7);
    }
    else
    {
      uint64_t v8 = 0;
      if (*(void *)object) {
        uint64_t v8 = *(void *)object;
      }
      if (*(void *)(v8 + 16) == 4)
      {
        _dispatch_io_set_target_queue((uint64_t)object, (uint64_t)v19);
      }
      else
      {
        if (!v19) {
          dispatch_queue_t v19 = (dispatch_queue_t)&off_F0600;
        }
        _dispatch_retain((uint64_t)v19);
        uint64_t v22 = atomic_exchange_explicit((atomic_ullong *volatile)((char *)object + 24), (unint64_t)v19, memory_order_release);
        if (v22) {
          _dispatch_release(v22);
        }
      }
    }
  }
}

void dispatch_activate(dispatch_object_t object)
{
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    uint64_t v9 = 0;
    if (*(void *)object) {
      uint64_t v9 = *(void *)object;
    }
    if (*(unsigned char *)(v9 + 16) == 18)
    {
      _dispatch_workloop_activate((uint64_t)object, v1, v2, v3, v4, v5, v6, v7);
    }
    else
    {
      uint64_t v8 = 0;
      if (*(void *)object) {
        uint64_t v8 = *(void *)object;
      }
      if ((*(void *)(v8 + 16) & 0xF0) == 0x10) {
        _dispatch_lane_resume((uint64_t)object, 1);
      }
    }
  }
}

void dispatch_suspend(dispatch_object_t object)
{
  char v7 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    uint64_t v6 = 0;
    if (*(void *)object) {
      uint64_t v6 = *(void *)object;
    }
    LOBYTE(v5) = 1;
    if ((*(unsigned char *)(v6 + 18) & 1) == 0)
    {
      uint64_t v4 = 0;
      if (*(void *)object) {
        uint64_t v4 = *(void *)object;
      }
      int v5 = (*(unsigned __int8 *)(v4 + 18) >> 1) & 1;
    }
    char v7 = v5;
  }
  if ((v7 & 1) == 0)
  {
    uint64_t v3 = 0;
    if (*(void *)object) {
      uint64_t v3 = *(void *)object;
    }
    if ((*(void *)(v3 + 16) & 0xF0) == 0x10)
    {
      uint64_t v2 = 0;
      if (*(void *)object) {
        uint64_t v2 = *(void *)object;
      }
      BOOL v1 = 0;
      if (*(unsigned char *)(v2 + 16) == 18) {
        BOOL v1 = _dispatch_workloop_uses_bound_thread((uint64_t)object);
      }
      if (v1)
      {
        qword_F4290 = (uint64_t)"API MISUSE: Object type does not support suspension";
        __break(1u);
        JUMPOUT(0xC8FCLL);
      }
      _dispatch_lane_suspend((uint64_t)object);
    }
  }
}

void dispatch_resume(dispatch_object_t object)
{
  char v7 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    uint64_t v6 = 0;
    if (*(void *)object) {
      uint64_t v6 = *(void *)object;
    }
    LOBYTE(v5) = 1;
    if ((*(unsigned char *)(v6 + 18) & 1) == 0)
    {
      uint64_t v4 = 0;
      if (*(void *)object) {
        uint64_t v4 = *(void *)object;
      }
      int v5 = (*(unsigned __int8 *)(v4 + 18) >> 1) & 1;
    }
    char v7 = v5;
  }
  if ((v7 & 1) == 0)
  {
    uint64_t v3 = 0;
    if (*(void *)object) {
      uint64_t v3 = *(void *)object;
    }
    if ((*(void *)(v3 + 16) & 0xF0) == 0x10)
    {
      uint64_t v2 = 0;
      if (*(void *)object) {
        uint64_t v2 = *(void *)object;
      }
      BOOL v1 = 0;
      if (*(unsigned char *)(v2 + 16) == 18) {
        BOOL v1 = _dispatch_workloop_uses_bound_thread((uint64_t)object);
      }
      if (v1)
      {
        qword_F4290 = (uint64_t)"API MISUSE: Object type does not support resume";
        __break(1u);
        JUMPOUT(0xCB68);
      }
      _dispatch_lane_resume((uint64_t)object, 0);
    }
  }
}

uint64_t _dispatch_retain(uint64_t result)
{
  int add_explicit = *(_DWORD *)(result + 8);
  if (add_explicit != 0x7FFFFFFF) {
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 8), 1u, memory_order_relaxed);
  }
  if (add_explicit <= 0)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xCC88);
  }
  return result;
}

void _dispatch_release(uint64_t a1)
{
  signed int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != 0x7FFFFFFF) {
    signed int v2 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v2 < 1)
  {
    if (v2 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xCDD8);
    }
    int v1 = *(_DWORD *)(a1 + 12);
    if (v1 >= 1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0xCE38);
    }
    _os_object_dispose((uint64_t *)a1);
  }
}

void *_dispatch_block_create(void *a1, void *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  uint64_t v34 = a3;
  uint64_t v33 = a4;
  __int16 v41 = v24;
  int v40 = a1;
  uint64_t v39 = a2;
  uint64_t v38 = a3;
  uint64_t v37 = a4;
  uint64_t v50 = v24;
  uint64_t v49 = a1;
  uint64_t v48 = a2;
  uint64_t v47 = a3;
  uint64_t v46 = a4;
  v24[0] = 0;
  v24[1] = a1;
  int v25 = 0;
  int v26 = 0;
  uint64_t v27 = a3;
  uint64_t v28 = a2;
  uint64_t v29 = a4;
  dispatch_group_t v30 = 0;
  uint64_t v31 = 0;
  int v32 = 0;
  uint64_t v10 = _NSConcreteStackBlock;
  int v11 = 1174405120;
  int v12 = 0;
  uint64_t v13 = ___dispatch_block_create_block_invoke;
  char v14 = &__block_descriptor_tmp_1;
  uint64_t v43 = v15;
  uint64_t v42 = v24;
  uint64_t v52 = v15;
  int v51 = v24;
  uint64_t v53 = v15;
  v15[0] = 3512316172;
  v15[1] = a1;
  int v16 = 0;
  int v17 = 0;
  uint64_t v18 = a3;
  dispatch_queue_t v19 = a2;
  uint64_t v20 = 0;
  dispatch_group_t v21 = 0;
  uint64_t v22 = 0;
  int v23 = 0;
  if (a2 && v19 != (void *)-1) {
    a1 = voucher_retain(v19);
  }
  if (v51[5])
  {
    a1 = _dispatch_Block_copy((const void *)v51[5]);
    uint64_t v20 = a1;
  }
  if (*v51) {
    dispatch_group_t v21 = (dispatch_group_t)_dispatch_group_create_and_enter((uint64_t)a1, (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  }
  uint64_t v9 = _dispatch_Block_copy(&v10);
  v45 = v15;
  uint64_t v54 = v15;
  uint64_t v55 = v15;
  if (v15[0] == 3512316172)
  {
    if (v21)
    {
      if (!v17) {
        dispatch_group_leave(v21);
      }
      _os_object_release_without_xref_dispose((uint64_t)v21);
    }
    if (v22) {
      _os_object_release_internal_n(v22, 2u);
    }
    if (v20) {
      _Block_release(v20);
    }
    if (v19 && v19 != (void *)-1) {
      voucher_release(v19);
    }
  }
  uint64_t v44 = v24;
  uint64_t v56 = v24;
  uint64_t v57 = v24;
  if (v24[0] == 3512316172)
  {
    if (v30)
    {
      if (!v26) {
        dispatch_group_leave(v30);
      }
      _os_object_release_without_xref_dispose((uint64_t)v30);
    }
    if (v31) {
      _os_object_release_internal_n(v31, 2u);
    }
    if (v29) {
      _Block_release(v29);
    }
    if (v28 && v28 != (void *)-1) {
      voucher_release(v28);
    }
  }
  return v9;
}

void ___dispatch_block_create_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

char *__copy_helper_block_8_32c35_ZTS29dispatch_block_private_data_s(char *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2 + 4;
  uint64_t v8 = result + 32;
  *((void *)result + 4) = 3512316172;
  *((void *)result + 5) = a2[5];
  *((_DWORD *)result + 12) = 0;
  *((_DWORD *)result + 13) = 0;
  *((void *)result + 7) = a2[7];
  *((void *)result + 8) = a2[8];
  *((void *)result + 9) = 0;
  *((void *)result + 10) = 0;
  *((void *)result + 11) = 0;
  *((_DWORD *)result + 24) = 0;
  if (*((void *)result + 8) && *((void *)result + 8) != -1) {
    uint64_t result = (char *)voucher_retain(*((void **)result + 8));
  }
  if (v9[5])
  {
    uint64_t result = (char *)_dispatch_Block_copy((const void *)v9[5]);
    *((void *)v8 + 5) = result;
  }
  if (*v9)
  {
    uint64_t result = (char *)_dispatch_group_create_and_enter((uint64_t)result, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    *((void *)v8 + 6) = result;
  }
  return result;
}

void __destroy_helper_block_8_32c35_ZTS29dispatch_block_private_data_s(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  if (*(void *)(a1 + 32) == 3512316172)
  {
    if (*(void *)(a1 + 80))
    {
      if (!*(_DWORD *)(a1 + 52)) {
        dispatch_group_leave(*(dispatch_group_t *)(a1 + 80));
      }
      _os_object_release_without_xref_dispose(*(void *)(v1 + 48));
    }
    if (*(void *)(v1 + 56)) {
      _os_object_release_internal_n(*(void *)(v1 + 56), 2u);
    }
    if (*(void *)(v1 + 40)) {
      _Block_release(*(const void **)(v1 + 40));
    }
    if (*(void *)(v1 + 32))
    {
      if (*(void *)(v1 + 32) != -1) {
        voucher_release(*(void **)(v1 + 32));
      }
    }
  }
}

void _dispatch_sema4_create_slow(atomic_uint *a1, int a2)
{
  kern_return_t v4;
  kern_return_t v5;
  semaphore_t semaphore;
  int policy;
  atomic_uint *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t StatusReg;

  uint64_t v8 = a1;
  policy = a2;
  semaphore = 0;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  if (policy)
  {
    uint64_t v4 = semaphore_create(mach_task_self_, &semaphore, policy, 0);
    if (v4 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0xD7ECLL);
    }
    if (v4 == 15)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_F42C0 = 15;
      __break(1u);
      JUMPOUT(0xD840);
    }
    if (v4)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_F42C0 = v4;
      __break(1u);
      JUMPOUT(0xD890);
    }
    int v3 = 0;
    atomic_compare_exchange_strong_explicit(v8, (unsigned int *)&v3, semaphore, memory_order_relaxed, memory_order_relaxed);
    if (v3)
    {
      int v5 = semaphore_destroy(mach_task_self_, semaphore);
      if (v5 == -301)
      {
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xD99CLL);
      }
      if (v5 == 15)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
        qword_F42C0 = 15;
        __break(1u);
        JUMPOUT(0xD9F0);
      }
      if (v5)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
        qword_F42C0 = v5;
        __break(1u);
        JUMPOUT(0xDA40);
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
    char v14 = 9;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v9 = *(void *)(StatusReg + 72);
    if (v9)
    {
      uint64_t v18 = 9;
      int v17 = 0;
      dispatch_queue_t v19 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      *(void *)(v19 + 72) = 0;
      uint64_t v10 = v9;
    }
    else
    {
      uint64_t v10 = _os_semaphore_create();
    }
    semaphore = v10;
    int v2 = 0;
    atomic_compare_exchange_strong_explicit(v8, (unsigned int *)&v2, v10, memory_order_relaxed, memory_order_relaxed);
    if (v2)
    {
      int v12 = semaphore;
      int v11 = 0;
      uint64_t v13 = 9;
      int v11 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72);
      int v16 = 9;
      uint64_t v15 = semaphore;
      *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72) = semaphore;
      if (v11) {
        _os_semaphore_dispose();
      }
    }
  }
}

uint64_t _dispatch_sema4_dispose_slow(uint64_t result, int a2)
{
  semaphore_t semaphore = *(_DWORD *)result;
  *(_DWORD *)uint64_t result = -1;
  if (a2)
  {
    uint64_t result = semaphore_destroy(mach_task_self_, semaphore);
    if (result == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0xDB94);
    }
    if (result == 15)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_F42C0 = 15;
      __break(1u);
      JUMPOUT(0xDBE8);
    }
    if (result)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_F42C0 = (int)result;
      __break(1u);
      JUMPOUT(0xDC38);
    }
  }
  else
  {
    uint64_t v3 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72);
    *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72) = semaphore;
    if (v3) {
      return _os_semaphore_dispose();
    }
  }
  return result;
}

uint64_t _dispatch_sema4_signal(semaphore_t *a1, uint64_t a2)
{
  do
  {
    uint64_t result = semaphore_signal(*a1);
    if (result == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0xDCD8);
    }
    if (result == 15)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_F42C0 = 15;
      __break(1u);
      JUMPOUT(0xDD2CLL);
    }
    if (result)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_F42C0 = (int)result;
      __break(1u);
      JUMPOUT(0xDD7CLL);
    }
    --a2;
  }
  while (a2);
  return result;
}

uint64_t _dispatch_sema4_wait(semaphore_t *a1)
{
  do
    uint64_t result = semaphore_wait(*a1);
  while (result == 14);
  if (result == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0xDE44);
  }
  if (result == 15)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
    qword_F42C0 = 15;
    __break(1u);
    JUMPOUT(0xDE98);
  }
  if (result)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
    qword_F42C0 = (int)result;
    __break(1u);
    JUMPOUT(0xDEE8);
  }
  return result;
}

uint64_t _dispatch_sema4_timedwait(semaphore_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  kern_return_t v11;
  mach_timespec_t v12;

  do
  {
    unint64_t v10 = _dispatch_timeout(a2, a2, a3, a4, a5, a6, a7, a8);
    v12.tv_sec = v10 / 0x3B9ACA00;
    v12.tv_nsec = v10 % 0x3B9ACA00;
    mach_timespec_t v8 = v12;
    int v11 = semaphore_timedwait(*a1, v8);
  }
  while (v11 == 14);
  switch(v11)
  {
    case 49:
      return 1;
    case -301:
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0xE020);
    case 15:
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_F42C0 = 15;
      __break(1u);
      JUMPOUT(0xE074);
    default:
      if (v11)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
        qword_F42C0 = v11;
        __break(1u);
        JUMPOUT(0xE0C4);
      }
      return 0;
  }
}

uint64_t _dispatch_wait_on_address(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v23 = a2;
  unint64_t v20 = _dispatch_timeout(a3, a2, a3, a4, a5, a6, a7, a8);
  if (v20)
  {
    if (v20 == -1)
    {
      return _dispatch_ulock_wait(a1, v23, 0);
    }
    else
    {
      do
      {
        if (v20 % 0x3E8) {
          unint64_t v17 = v20 / 0x3E8 + 1;
        }
        else {
          unint64_t v17 = v20 / 0x3E8;
        }
        uint64_t v19 = v17;
        if (v17 > 0xFFFFFFFF) {
          uint64_t v19 = 0xFFFFFFFFLL;
        }
        unsigned int v18 = _dispatch_ulock_wait(a1, v23, v19);
        BOOL v16 = 0;
        if (v19 == 0xFFFFFFFFLL)
        {
          BOOL v16 = 0;
          if (v18 == 60)
          {
            unint64_t v20 = _dispatch_timeout(a3, v8, v9, v10, v11, v12, v13, v14);
            BOOL v16 = v20 != 0;
          }
        }
      }
      while (v16);
      return v18;
    }
  }
  else
  {
    return 60;
  }
}

uint64_t _dispatch_ulock_wait(uint64_t a1, unsigned int a2, int a3)
{
  return _dlock_wait(a1, a2, a3);
}

uint64_t _dispatch_wake_by_address()
{
  return _dispatch_ulock_wake();
}

uint64_t _dispatch_ulock_wake()
{
  return _dlock_wake();
}

uint64_t _dispatch_thread_event_signal_slow()
{
  return _dispatch_ulock_wake();
}

BOOL _dispatch_thread_event_wait_slow(BOOL result)
{
  uint64_t v10 = (atomic_uint *)result;
  while (1)
  {
    unsigned int explicit = atomic_load_explicit(v10, memory_order_acquire);
    if (!explicit) {
      break;
    }
    if (explicit != -1)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt thread event value";
      qword_F42C0 = explicit;
      __break(1u);
      JUMPOUT(0xE424);
    }
    int v8 = _dispatch_ulock_wait((uint64_t)v10, 0xFFFFFFFF, 0);
    BOOL v7 = 1;
    if (v8)
    {
      BOOL v7 = 1;
      if (v8 != 14) {
        BOOL v7 = v8 == 4;
      }
    }
    uint64_t result = v7;
    if (!v7) {
      _dispatch_abort(559, v7, v1, v2, v3, v4, v5, v6);
    }
  }
  return result;
}

uint64_t _dispatch_unfair_lock_lock_slow(atomic_uint *a1)
{
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  int v7 = result & 0xFFFFFFFC;
  unsigned int v4 = result & 0xFFFFFFFC;
  while (1)
  {
    for (int i = *(_DWORD *)a1; ; int i = v3)
    {
      if ((i & 0xFFFFFFFC) != 0)
      {
        unsigned int v5 = i | 1;
        if ((i | 1) == i) {
          break;
        }
      }
      else
      {
        unsigned int v5 = v4;
      }
      int v2 = i;
      int v3 = i;
      atomic_compare_exchange_strong_explicit(a1, (unsigned int *)&v3, v5, memory_order_acquire, memory_order_acquire);
      if (v3 == v2) {
        break;
      }
    }
    if (((i ^ v7) & 0xFFFFFFFC) == 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to lock recursively";
      __break(1u);
      JUMPOUT(0xE658);
    }
    if (v5 == v4) {
      return result;
    }
    uint64_t result = _dispatch_unfair_lock_wait((uint64_t)a1, v5, 0);
    if (result == 66) {
      v4 |= 1u;
    }
  }
}

uint64_t _dispatch_unfair_lock_wait(uint64_t a1, unsigned int a2, int a3)
{
  return _dlock_wait(a1, a2, a3);
}

void *_dispatch_unfair_lock_unlock_slow(uint64_t a1, unsigned int a2)
{
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  if (((a2 ^ result) & 0xFFFFFFFC) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: lock not owned by current thread";
    qword_F42C0 = a2;
    __break(1u);
    JUMPOUT(0xE788);
  }
  if (a2) {
    return (void *)_dispatch_unfair_lock_wake();
  }
  return result;
}

uint64_t _dispatch_unfair_lock_wake()
{
  return _dlock_wake();
}

uint64_t _dispatch_once_wait(atomic_ullong *a1)
{
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  int v6 = result & 0xFFFFFFFC;
LABEL_2:
  for (uint64_t i = *(void *)a1; i != -1; uint64_t i = v3)
  {
    if ((i & 3) == 2)
    {
      __dmb(9u);
      if ((unint64_t)(4 * MEMORY[0xFFFFFC180] - i + 2) >= 0x10) {
        *(void *)a1 = -1;
      }
      return result;
    }
    uint64_t v4 = i | 1;
    if ((i | 1) != i)
    {
      uint64_t v2 = i;
      uint64_t v3 = i;
      atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v3, v4, memory_order_relaxed, memory_order_relaxed);
      if (v3 != v2) {
        continue;
      }
    }
    if (((i ^ v6) & 0xFFFFFFFC) == 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to lock recursively";
      __break(1u);
      JUMPOUT(0xEA18);
    }
    uint64_t result = _dispatch_unfair_lock_wait((uint64_t)a1, v4, 0);
    goto LABEL_2;
  }
  return result;
}

uint64_t _dispatch_gate_broadcast_slow(uint64_t a1, unsigned int a2)
{
  if (((a2 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: lock not owned by current thread";
    qword_F42C0 = a2;
    __break(1u);
    JUMPOUT(0xEACCLL);
  }
  return _dispatch_unfair_lock_wake();
}

uint64_t _dispatch_firehose_gate_wait(uint64_t a1, unsigned int a2)
{
  return _dispatch_unfair_lock_wait(a1, a2, 0);
}

uint64_t _dlock_wait(uint64_t a1, unsigned int a2, int a3)
{
  while (1)
  {
    int v5 = __ulock_wait();
    if (v5 >= 1) {
      return 66;
    }
    int v4 = -v5;
    if (!v5) {
      return 0;
    }
    if (v4 != 4) {
      break;
    }
    if (a3) {
      return -v5;
    }
  }
  if (v4 != 14 && v4 != 60)
  {
    if (v4 != 105)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: ulock_wait() failed";
      qword_F42C0 = -v5;
      __break(1u);
      JUMPOUT(0xECB0);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Owner in ulock is unknown - possible memory corruption";
    qword_F42C0 = a2;
    __break(1u);
    JUMPOUT(0xEC5CLL);
  }
  return -v5;
}

uint64_t _dlock_wake()
{
  uint64_t result = __ulock_wake();
  if (result && result != -2)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: ulock_wake() failed";
    qword_F42C0 = -(int)result;
    __break(1u);
    JUMPOUT(0xED70);
  }
  return result;
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  if (value < 0) {
    return 0;
  }
  int v7 = _dispatch_object_alloc((uint64_t)_OS_dispatch_semaphore_vtable, 0x48uLL, v1, v2, v3, v4, v5, v6);
  v7[2] = -1985229329;
  v7[3] = &off_F0600;
  v7[6] = value;
  *((_DWORD *)v7 + 16) = 0;
  v7[7] = value;
  return (dispatch_semaphore_t)v7;
}

uint64_t _dispatch_semaphore_dispose(uint64_t result)
{
  if (*(void *)(result + 48) < *(void *)(result + 56))
  {
    uint64_t v1 = *(void *)(result + 56) - *(void *)(result + 48);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Semaphore object deallocated while in use (current value < original value)";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0xEEB4);
  }
  if (*(_DWORD *)(result + 64)) {
    return _dispatch_sema4_dispose_slow(result + 64, 0);
  }
  return result;
}

uint64_t _dispatch_semaphore_signal_slow(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 64)) {
    _dispatch_sema4_create_slow((atomic_uint *)(a1 + 64), 0);
  }
  _dispatch_sema4_signal((semaphore_t *)(a1 + 64), 1);
  return 1;
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)((char *)dsema + 48), 1uLL, memory_order_release);
  if ((uint64_t)(add_explicit + 1) >= 1) {
    return 0;
  }
  if (add_explicit == 0x7FFFFFFFFFFFFFFFLL)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_semaphore_signal()";
    qword_F42C0 = 0x8000000000000000;
    __break(1u);
    JUMPOUT(0xF070);
  }
  return _dispatch_semaphore_signal_slow((uint64_t)dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  if ((uint64_t)(atomic_fetch_add_explicit((atomic_ullong *volatile)((char *)dsema + 48), 0xFFFFFFFFFFFFFFFFLL, memory_order_acquire)- 1) < 0)return _dispatch_semaphore_wait_slow((uint64_t)dsema, timeout, v2, v3, v4, v5, v6, v7); {
  else
  }
    return 0;
}

uint64_t _dispatch_semaphore_wait_slow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 64)) {
    _dispatch_sema4_create_slow((atomic_uint *)(a1 + 64), 0);
  }
  if (a2 != -1)
  {
    if (a2 && (_dispatch_sema4_timedwait((semaphore_t *)(a1 + 64), a2, a3, a4, a5, a6, a7, a8) & 1) == 0) {
      return 0;
    }
    uint64_t v12 = *(void *)(a1 + 48);
    while (v12 < 0)
    {
      uint64_t v11 = v12;
      uint64_t v8 = v12;
      uint64_t v9 = v12;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t *)&v9, v12 + 1, memory_order_relaxed, memory_order_relaxed);
      if (v9 != v8) {
        uint64_t v11 = v9;
      }
      uint64_t v12 = v11;
      if (v9 == v8) {
        return 49;
      }
    }
  }
  _dispatch_sema4_wait((semaphore_t *)(a1 + 64));
  return 0;
}

dispatch_group_t dispatch_group_create(void)
{
  uint64_t v7 = (dispatch_group_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_group_vtable, 0x48uLL, v0, v1, v2, v3, v4, v5);
  *((void *)v7 + 2) = -1985229329;
  *((void *)v7 + 3) = &off_F0600;
  return v7;
}

void *_dispatch_group_create_and_enter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = _dispatch_object_alloc((uint64_t)_OS_dispatch_group_vtable, 0x48uLL, a3, a4, a5, a6, a7, a8);
  v9[2] = -1985229329;
  v9[3] = &off_F0600;
  *((_DWORD *)v9 + 12) = -4;
  _dispatch_retain((uint64_t)v9);
  return v9;
}

uint64_t _dispatch_group_dispose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  if (v1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Group object deallocated while in use";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0xF534);
  }
  return result;
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  for (uint64_t i = *((void *)group + 6); ; uint64_t i = v8)
  {
    if ((i & 0xFFFFFFFC) == 0)
    {
      __dmb(9u);
      return 0;
    }
    if (!timeout) {
      return 49;
    }
    unint64_t v10 = i | 1;
    if (i) {
      break;
    }
    uint64_t v7 = i;
    uint64_t v8 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)group + 48), (unint64_t *)&v8, v10, memory_order_relaxed, memory_order_relaxed);
    if (v8 == v7) {
      break;
    }
  }
  return _dispatch_group_wait_slow((uint64_t)group, HIDWORD(v10), timeout, v2, v3, v4, v5, v6);
}

uint64_t _dispatch_group_wait_slow(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  do
  {
    int v9 = _dispatch_wait_on_address(a1 + 52, a2, a3, 0, a5, a6, a7, a8);
    if (a2 != atomic_load_explicit((atomic_uint *volatile)(a1 + 52), memory_order_acquire)) {
      return 0;
    }
  }
  while (v9 != 60);
  return 49;
}

void dispatch_group_leave(dispatch_group_t group)
{
  unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)((char *)group + 48), 4uLL, memory_order_release);
  if ((add_explicit & 0xFFFFFFFC) == 0xFFFFFFFC)
  {
    unint64_t v5 = add_explicit + 4;
    do
    {
      if ((v5 & 0xFFFFFFFC) != 0) {
        unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFFDLL;
      }
      else {
        unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
      }
      if (v5 == v6) {
        break;
      }
      unint64_t v3 = v5;
      unint64_t v1 = v5;
      unint64_t v2 = v5;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)group + 48), &v2, v6, memory_order_relaxed, memory_order_relaxed);
      if (v2 != v1) {
        unint64_t v3 = v2;
      }
      unint64_t v5 = v3;
    }
    while (v2 != v1);
    _dispatch_group_wake((uint64_t)group, v5, 1);
  }
  else if ((add_explicit & 0xFFFFFFFC) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_group_leave()";
    qword_F42C0 = 0;
    __break(1u);
    JUMPOUT(0xF990);
  }
}

void _dispatch_group_wake(uint64_t a1, char a2, char a3)
{
  unsigned __int16 v13 = (a3 & 1) != 0;
  if ((a2 & 2) != 0)
  {
    uint64_t v10 = *(void *)(a1 + 56);
    if (!v10) {
      uint64_t v10 = _dispatch_wait_for_enqueuer((unint64_t *)(a1 + 56));
    }
    *(void *)(a1 + 56) = 0;
    unint64_t v11 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 64), 0, memory_order_release) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v12 = (void *)v10;
    do
    {
      int v9 = (uint64_t *)v12[6];
      uint64_t v8 = 0;
      if (v12 != (void *)v11)
      {
        uint64_t v7 = v12[2];
        if (!v7) {
          uint64_t v7 = _dispatch_wait_for_enqueuer(v12 + 2);
        }
        uint64_t v8 = (void *)v7;
      }
      unsigned int v3 = (v12[1] & 0x3FFF00uLL) >> 8;
      unsigned int v4 = __clz(__rbit32(v3));
      if (v3) {
        unsigned int v5 = v4 + 1;
      }
      else {
        unsigned int v5 = 0;
      }
      uint64_t v6 = 0;
      if (*v9) {
        uint64_t v6 = *v9;
      }
      (*(void (**)(uint64_t *, void *, void))(v6 + 72))(v9, v12, v5);
      _dispatch_release((uint64_t)v9);
      uint64_t v12 = v8;
    }
    while (v8);
    ++v13;
  }
  if (a2) {
    _dispatch_wake_by_address();
  }
  if (v13) {
    _dispatch_release_n(a1, v13);
  }
}

void dispatch_group_enter(dispatch_group_t group)
{
  unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)((char *)group + 48), 0xFFFFFFFC, memory_order_acquire);
  if ((add_explicit & 0xFFFFFFFC) == 0) {
    _dispatch_retain((uint64_t)group);
  }
  if ((add_explicit & 0xFFFFFFFC) == 4)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many nested calls to dispatch_group_enter()";
    qword_F42C0 = add_explicit;
    __break(1u);
    JUMPOUT(0xFE88);
  }
}

void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  dispatch_group_t v21 = _dispatch_thread_getspecific(0x16uLL);
  if (v21)
  {
    _dispatch_thread_setspecific(22, v21[2]);
    unint64_t v17 = v21;
  }
  else
  {
    unint64_t v17 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  *unint64_t v17 = 260;
  v17[4] = work;
  v17[5] = context;
  unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v23 <= 0x10FF) {
    uint64_t v24 = v23;
  }
  else {
    uint64_t v24 = 4351;
  }
  int v25 = _dispatch_thread_getspecific(0x1CuLL);
  if (v25) {
    os_retain(v25);
  }
  v17[3] = v25;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  if (v17[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v22 = v24;
  if (v24 && (*((_DWORD *)queue + 21) & 0x40000000) == 0 && (*((_DWORD *)queue + 21) & 0xFFF) != 0) {
    uint64_t v22 = 0;
  }
  v17[1] = v22;
  v17[6] = queue;
  _dispatch_retain((uint64_t)queue);
  v17[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)group + 64);
  unint64_t v18 = atomic_exchange_explicit((atomic_ullong *volatile)((char *)group + 64), (unint64_t)v17, memory_order_release);
  if (v18)
  {
    *(void *)(v18 + 16) = v17;
  }
  else
  {
    _dispatch_retain((uint64_t)group);
    *((void *)group + 7) = v17;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v18)
  {
    for (uint64_t i = *((void *)group + 6); ; uint64_t i = v12)
    {
      uint64_t v19 = i | 2;
      if (!i) {
        break;
      }
      uint64_t v11 = i;
      uint64_t v12 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)group + 48), (unint64_t *)&v12, v19, memory_order_release, memory_order_relaxed);
      if (v12 == v11) {
        return;
      }
    }
    _dispatch_group_wake((uint64_t)group, v19, 0);
  }
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v22 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v22)
  {
    _dispatch_thread_setspecific(22, v22[2]);
    unint64_t v17 = v22;
  }
  else
  {
    unint64_t v17 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  dispatch_group_t v21 = _dispatch_Block_copy(block);
  uint64_t v12 = _Block_get_invoke_fn((uint64_t)block);
  unsigned __int16 v13 = 0;
  if (v12) {
    unsigned __int16 v13 = (uint64_t (*)())v12;
  }
  if (v13 == _dispatch_block_special_invoke)
  {
    *unint64_t v17 = 276;
    v17[5] = (uint64_t)v21;
    _dispatch_continuation_init_slow(v17, (unint64_t)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *unint64_t v17 = 276;
    v17[4] = (uint64_t)_dispatch_call_block_and_release;
    v17[5] = (uint64_t)v21;
    unint64_t v24 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v24 <= 0x10FF) {
      uint64_t v25 = v24;
    }
    else {
      uint64_t v25 = 4351;
    }
    int v26 = _dispatch_thread_getspecific(0x1CuLL);
    if (v26) {
      os_retain(v26);
    }
    v17[3] = (uint64_t)v26;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    if (v17[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v23 = v25;
    if (v25 && (*((_DWORD *)queue + 21) & 0x40000000) == 0 && (*((_DWORD *)queue + 21) & 0xFFF) != 0) {
      uint64_t v23 = 0;
    }
    v17[1] = v23;
  }
  v17[6] = (uint64_t)queue;
  _dispatch_retain((uint64_t)queue);
  v17[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)group + 64);
  unint64_t v18 = atomic_exchange_explicit((atomic_ullong *volatile)((char *)group + 64), (unint64_t)v17, memory_order_release);
  if (v18)
  {
    *(void *)(v18 + 16) = v17;
  }
  else
  {
    _dispatch_retain((uint64_t)group);
    *((void *)group + 7) = v17;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v18)
  {
    for (uint64_t i = *((void *)group + 6); ; uint64_t i = v11)
    {
      uint64_t v19 = i | 2;
      if (!i) {
        break;
      }
      uint64_t v10 = i;
      uint64_t v11 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)group + 48), (unint64_t *)&v11, v19, memory_order_release, memory_order_relaxed);
      if (v11 == v10) {
        return;
      }
    }
    _dispatch_group_wake((uint64_t)group, v19, 0);
  }
}

void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  unint64_t v20 = _dispatch_thread_getspecific(0x16uLL);
  if (v20)
  {
    _dispatch_thread_setspecific(22, v20[2]);
    uint64_t v19 = v20;
  }
  else
  {
    uint64_t v19 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  *uint64_t v19 = 268;
  v19[4] = work;
  v19[5] = context;
  unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v23 <= 0x10FF) {
    unint64_t v24 = v23;
  }
  else {
    unint64_t v24 = 4351;
  }
  uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
  if (v25) {
    os_retain(v25);
  }
  v19[3] = v25;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  if (v19[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  unint64_t v22 = v24;
  unsigned int v21 = 0;
  if (v24)
  {
    if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
    {
      unsigned int v11 = v24 >> 8;
      unsigned int v12 = __clz(__rbit32(v11));
      if (v11) {
        unsigned int v13 = v12 + 1;
      }
      else {
        unsigned int v13 = 0;
      }
      unsigned int v21 = v13;
    }
    else
    {
      unint64_t v22 = 0;
    }
  }
  v19[1] = v22;
  dispatch_group_enter(group);
  v19[6] = group;
  uint64_t v14 = 0;
  if (*(void *)queue) {
    uint64_t v14 = *(void *)queue;
  }
  (*(void (**)(dispatch_queue_t, void *, void))(v14 + 72))(queue, v19, v21);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  unint64_t v22 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v22)
  {
    _dispatch_thread_setspecific(22, v22[2]);
    uint64_t v19 = v22;
  }
  else
  {
    uint64_t v19 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  unint64_t v20 = _dispatch_Block_copy(block);
  uint64_t v14 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v15 = 0;
  if (v14) {
    uint64_t v15 = (uint64_t (*)())v14;
  }
  if (v15 == _dispatch_block_special_invoke)
  {
    *uint64_t v19 = 284;
    v19[5] = (uint64_t)v20;
    unsigned int inited = _dispatch_continuation_init_slow(v19, (unint64_t)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *uint64_t v19 = 284;
    v19[4] = (uint64_t)_dispatch_call_block_and_release;
    v19[5] = (uint64_t)v20;
    unint64_t v25 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v25 <= 0x10FF) {
      unint64_t v26 = v25;
    }
    else {
      unint64_t v26 = 4351;
    }
    uint64_t v27 = _dispatch_thread_getspecific(0x1CuLL);
    if (v27) {
      os_retain(v27);
    }
    v19[3] = (uint64_t)v27;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    if (v19[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v24 = v26;
    unsigned int v23 = 0;
    if (v26)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v10 = v26 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v23 = v12;
      }
      else
      {
        unint64_t v24 = 0;
      }
    }
    v19[1] = v24;
    unsigned int inited = v23;
  }
  dispatch_group_enter(group);
  v19[6] = (uint64_t)group;
  uint64_t v13 = 0;
  if (*(void *)queue) {
    uint64_t v13 = *(void *)queue;
  }
  (*(void (**)(dispatch_queue_t, uint64_t *, void))(v13 + 72))(queue, v19, inited);
}

void _dispatch_release_n(uint64_t a1, int a2)
{
  int v3 = *(_DWORD *)(a1 + 8);
  if (v3 != 0x7FFFFFFF) {
    int v3 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), -a2, memory_order_release) - a2;
  }
  if (v3 < 1)
  {
    if (v3 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x120DCLL);
    }
    int v2 = *(_DWORD *)(a1 + 12);
    if (v2 >= 1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_F42C0 = v2;
      __break(1u);
      JUMPOUT(0x1213CLL);
    }
    _os_object_dispose((uint64_t *)a1);
  }
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  uint64_t v4 = _Block_get_invoke_fn((uint64_t)block);
  function = 0;
  if (v4) {
    function = (void (__cdecl *)(void *))v4;
  }
  dispatch_once_f(predicate, block, function);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  unint64_t explicit = atomic_load_explicit((atomic_ullong *volatile)predicate, memory_order_acquire);
  if (explicit != -1)
  {
    if ((explicit & 3) == 2)
    {
      if (4 * MEMORY[0xFFFFFC180] + 2 - explicit >= 0x10) {
        *predicate = -1;
      }
    }
    else
    {
      unint64_t v8 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      uint64_t v3 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)predicate, (unint64_t *)&v3, v8, memory_order_relaxed, memory_order_relaxed);
      if (v3) {
        _dispatch_once_wait((atomic_ullong *)predicate);
      }
      else {
        _dispatch_once_callout((atomic_ullong *)predicate, (uint64_t)context, (void (*)(void (**)(void)))function);
      }
    }
  }
}

uint64_t _dispatch_once_callout(atomic_ullong *a1, uint64_t a2, void (*a3)(void (**a1)(void)))
{
  if (a3 == _dispatch_call_block_and_release && a2) {
    _Block_get_invoke_fn(a2);
  }
  _dispatch_client_callout(a2, (uint64_t (*)(uint64_t))a3);
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  unsigned int v7 = atomic_exchange_explicit(a1, 4 * MEMORY[0xFFFFFC180] + 2, memory_order_release);
  if (v7 != (result & 0xFFFFFFFC)) {
    return _dispatch_gate_broadcast_slow((uint64_t)a1, v7);
  }
  return result;
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  uint64_t v6 = 0;
  if (*(void *)queue) {
    uint64_t v6 = *(void *)queue;
  }
  uint64_t v7 = *(unsigned __int8 *)(v6 + 16);
  BOOL v5 = 0;
  if (v7 != 17) {
    BOOL v5 = v7 != 18;
  }
  if (v5)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: invalid queue passed to dispatch_assert_queue()";
    qword_F42C0 = v7;
    __break(1u);
    JUMPOUT(0x127DCLL);
  }
  int v13 = *((void *)queue + 7);
  if (((v13 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    dispatch_queue_t v11 = queue;
    unsigned int v10 = 0;
    uint64_t v9 = 0;
    uint64_t v14 = &v9;
    _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v9, 0x15uLL, (pthread_key_t *)&v10, v1, v2, v3, v4);
    while (v9)
    {
      if (v9 == (unsigned char *)v11)
      {
        char v12 = 1;
        goto LABEL_20;
      }
      unint64_t v18 = &v9;
      unint64_t v17 = v10;
      BOOL v16 = v9;
      if (v10)
      {
        uint64_t v15 = 0;
        uint64_t v15 = (unsigned char *)v16[3];
        if (v15)
        {
          *unint64_t v18 = v15;
          if (v16 == (void *)*v17) {
            v18[1] = (unsigned char *)v17[1];
          }
        }
        else
        {
          *unint64_t v18 = (unsigned char *)*v17;
          v18[1] = (unsigned char *)v17[1];
        }
      }
      else
      {
        *unint64_t v18 = (unsigned char *)v16[3];
      }
    }
    char v12 = 0;
LABEL_20:
    if (!v12) {
      _dispatch_assert_queue_fail(queue, 1);
    }
  }
}

void _dispatch_assert_queue_fail(void *a1, char a2)
{
  uint64_t v14 = a1;
  char v13 = a2 & 1;
  char v12 = 0;
  uint64_t v2 = "";
  if ((a2 & 1) == 0) {
    uint64_t v2 = "not ";
  }
  unsigned int v10 = (const char *)v14[9];
  if (v10) {
    asprintf(&v12, "%sBlock was %sexpected to execute on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", v2, v10, v14);
  }
  else {
    asprintf(&v12, "%sBlock was %sexpected to execute on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", v2, "", v14);
  }
  dispatch_queue_t v11 = v12;
  _dispatch_log("%s", v3, v4, v5, v6, v7, v8, v9, (uint64_t)v12);
  qword_F4290 = (uint64_t)v11;
  __break(1u);
}

void sub_12ACC()
{
  free(*(void **)(v0 - 24));
  __break(1u);
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  uint64_t v6 = 0;
  if (*(void *)queue) {
    uint64_t v6 = *(void *)queue;
  }
  uint64_t v7 = *(unsigned __int8 *)(v6 + 16);
  BOOL v5 = 0;
  if (v7 != 17) {
    BOOL v5 = v7 != 18;
  }
  if (v5)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: invalid queue passed to dispatch_assert_queue_not()";
    qword_F42C0 = v7;
    __break(1u);
    JUMPOUT(0x12BC8);
  }
  int v13 = *((void *)queue + 7);
  if (((v13 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0) {
    _dispatch_assert_queue_fail(queue, 0);
  }
  dispatch_queue_t v11 = queue;
  unsigned int v10 = 0;
  uint64_t v9 = 0;
  uint64_t v14 = &v9;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v9, 0x15uLL, (pthread_key_t *)&v10, v1, v2, v3, v4);
  while (v9)
  {
    if (v9 == (unsigned char *)v11)
    {
      char v12 = 1;
      goto LABEL_21;
    }
    unint64_t v18 = &v9;
    unint64_t v17 = v10;
    BOOL v16 = v9;
    if (v10)
    {
      uint64_t v15 = 0;
      uint64_t v15 = (unsigned char *)v16[3];
      if (v15)
      {
        *unint64_t v18 = v15;
        if (v16 == (void *)*v17) {
          v18[1] = (unsigned char *)v17[1];
        }
      }
      else
      {
        *unint64_t v18 = (unsigned char *)*v17;
        v18[1] = (unsigned char *)v17[1];
      }
    }
    else
    {
      *unint64_t v18 = (unsigned char *)v16[3];
    }
  }
  char v12 = 0;
LABEL_21:
  if (v12) {
    _dispatch_assert_queue_fail(queue, 0);
  }
}

void dispatch_assert_queue_barrier(dispatch_queue_t queue)
{
  if (*((_WORD *)queue + 40) != 1 && (!*((void *)queue + 3) || (*((void *)queue + 7) & 0x40000000000000) == 0)) {
    _dispatch_assert_queue_barrier_fail(queue);
  }
}

void _dispatch_assert_queue_barrier_fail(void *a1)
{
  dispatch_queue_t v11 = a1;
  unsigned int v10 = 0;
  uint64_t v8 = (const char *)a1[9];
  if (v8) {
    asprintf(&v10, "%sBlock was expected to act as a barrier on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", v8, v11);
  }
  else {
    asprintf(&v10, "%sBlock was expected to act as a barrier on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", "", v11);
  }
  uint64_t v9 = v10;
  _dispatch_log("%s", v1, v2, v3, v4, v5, v6, v7, (uint64_t)v10);
  qword_F4290 = (uint64_t)v9;
  __break(1u);
}

void sub_12F64()
{
  free(*(void **)(v0 - 16));
  __break(1u);
}

uint64_t dispatch_allow_send_signals()
{
  return _pthread_workqueue_allow_send_signals();
}

void _dispatch_set_priority_and_mach_voucher_slow(uint64_t a1, int a2)
{
  uint64_t v14 = a1;
  int v12 = 0;
  if (a1)
  {
    if (_dispatch_set_qos_class_enabled)
    {
      uint64_t v11 = (uint64_t)_dispatch_thread_getspecific(4uLL);
      if (v14 != v11)
      {
        if ((v11 & 0x1000000) != 0)
        {
          int v12 = 16;
          v14 |= (unint64_t)_dispatch_thread_getspecific(0x19uLL) & 0x80000000;
        }
        else
        {
          v14 |= v11 & 0x88000000;
        }
        if ((v11 & 0xFFFFFF) != 0) {
          v12 |= 1u;
        }
        int v8 = qword_F0138;
        if (((v8 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Changing the QoS while on the manager queue";
          qword_F42C0 = v14;
          __break(1u);
          JUMPOUT(0x131A4);
        }
        if ((BYTE3(v14) >> 1))
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Cannot raise oneself to manager";
          qword_F42C0 = v14;
          __break(1u);
          JUMPOUT(0x131F8);
        }
        if ((v11 & 0x2000000) != 0)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Cannot turn a manager thread into a normal one";
          qword_F42C0 = v11;
          __break(1u);
          JUMPOUT(0x13248);
        }
      }
    }
  }
  if (a2 != -1) {
    v12 |= 2u;
  }
  unsigned int v10 = _dispatch_thread_getspecific(0x1DuLL);
  if (v10 && (v10[45] & 2) != 0) {
    _dispatch_event_loop_drain(1u);
  }
  if (v12)
  {
    int v9 = _pthread_set_properties_self();
    if (v9 == 22)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: _pthread_set_properties_self failed";
      qword_F42C0 = v14;
      __break(1u);
      JUMPOUT(0x13330);
    }
    if (v9) {
      _dispatch_bug(206, v9, v2, v3, v4, v5, v6, v7);
    }
  }
}

uint64_t _dispatch_set_priority_and_voucher_slow(uint64_t a1, _DWORD *a2, char a3)
{
  uint64_t v16 = -1;
  int v15 = -1;
  if (a2 != (_DWORD *)-1)
  {
    BOOL v14 = (a3 & 4) != 0;
    uint64_t v16 = (uint64_t)_dispatch_thread_getspecific(0x1CuLL);
    if ((_DWORD *)v16 == a2 && (a3 & 2) != 0)
    {
      if (v14 && a2) {
        os_release(a2);
      }
      uint64_t v16 = -1;
    }
    else
    {
      if (!v14 && a2) {
        os_retain(a2);
      }
      if ((_DWORD *)v16 == a2)
      {
        int v20 = -1;
      }
      else
      {
        _dispatch_thread_setspecific(28, (uint64_t)a2);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v3, v4, v5, v6, v7, v8, v9, 400);
        if (a2) {
          int v13 = a2[8];
        }
        else {
          int v13 = 0;
        }
        if (v16) {
          int v12 = *(_DWORD *)(v16 + 32);
        }
        else {
          int v12 = 0;
        }
        if (v13 == v12) {
          int v11 = -1;
        }
        else {
          int v11 = v13;
        }
        int v20 = v11;
      }
      int v15 = v20;
    }
  }
  if ((a3 & 8) == 0) {
    _dispatch_set_priority_and_mach_voucher_slow(a1, v15);
  }
  if (v16 != -1 && (a3 & 2) != 0)
  {
    if (v16) {
      os_release((void *)v16);
    }
    return -1;
  }
  return v16;
}

void _dispatch_async_redirect_invoke(void *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v58 = a1;
  uint64_t v57 = a2;
  unsigned int v56 = a3;
  long long v55 = 0uLL;
  uint64_t v54 = (void *)a1[7];
  int v53 = a1[5];
  uint64_t v46 = 0;
  if (a1[4]) {
    uint64_t v46 = (void *)a1[4];
  }
  uint64_t v52 = v58[6];
  if (v53) {
    unsigned int v56 = v56 & 0xFCFFFFFF | v53;
  }
  uint64_t v50 = _dispatch_thread_getspecific(0x14uLL);
  if (v46)
  {
    v128 = v46;
    unsigned int v127 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v45 = 0;
    if (*v46) {
      uint64_t v45 = *v46;
    }
    uint64_t v130 = *(void *)(v45 + 16) & 0x10000;
    uint64_t v129 = 1946;
    if (!v130) {
      _dispatch_abort(v129, 0, v3, v4, v5, v6, v7, v8);
    }
    unsigned int v150 = *((_DWORD *)v128 + 21);
    unsigned int v149 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v150 = v150 & 0xFFF0FFFF | v149 & 0xF0000;
    _dispatch_thread_setspecific(25, v150);
    uint64_t v126 = (uint64_t)v128;
    uint64_t v131 = (uint64_t)v128;
    _dispatch_thread_setspecific(20, (uint64_t)v128);
    unsigned int v49 = v127;
    int v141 = *(_DWORD *)(v52 + 84);
    unsigned int v140 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v139 = v140;
    if (v140)
    {
      if ((v141 & 0xFFF) != 0)
      {
        v139 &= 0x880F0000;
        if ((v140 & 0xFFF) <= (v141 & 0xFFFu)) {
          int v44 = v141 & 0xFFF;
        }
        else {
          int v44 = v140 & 0xFFF;
        }
        v139 |= v44;
        unsigned int v143 = v141 & 0xF000;
        unsigned int v145 = v139 & 0xF00;
        if (v143 >> 12 <= v145 >> 8) {
          v141 &= 0x40000000u;
        }
        else {
          v141 &= 0x4400F000u;
        }
        v139 |= v141;
      }
      else
      {
        if ((v139 & 0xFFF) != 0) {
          v139 |= 0x40000000u;
        }
        unsigned int v142 = v141 & 0xF000;
        unsigned int v144 = v139 & 0xF00;
        if (v142 >> 12 > v144 >> 8) {
          unsigned int v139 = v139 & 0xFFFF0FFF | v141 & 0x400F000;
        }
      }
    }
    else
    {
      unsigned int v139 = v141 & 0xFFF0FFFF;
    }
    _dispatch_thread_setspecific(25, v139);
  }
  else
  {
    int v134 = *(_DWORD *)(v52 + 84);
    unsigned int v133 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v132 = v133;
    if (v133)
    {
      if ((v134 & 0xFFF) != 0)
      {
        v132 &= 0x880F0000;
        if ((v133 & 0xFFF) <= (v134 & 0xFFFu)) {
          int v43 = v134 & 0xFFF;
        }
        else {
          int v43 = v133 & 0xFFF;
        }
        v132 |= v43;
        unsigned int v136 = v134 & 0xF000;
        unsigned int v138 = v132 & 0xF00;
        if (v136 >> 12 <= v138 >> 8) {
          v134 &= 0x40000000u;
        }
        else {
          v134 &= 0x4400F000u;
        }
        v132 |= v134;
      }
      else
      {
        if ((v132 & 0xFFF) != 0) {
          v132 |= 0x40000000u;
        }
        unsigned int v135 = v134 & 0xF000;
        unsigned int v137 = v132 & 0xF00;
        if (v135 >> 12 > v137 >> 8) {
          unsigned int v132 = v132 & 0xFFFF0FFF | v134 & 0x400F000;
        }
      }
    }
    else
    {
      unsigned int v132 = v134 & 0xFFF0FFFF;
    }
    _dispatch_thread_setspecific(25, v132);
    unsigned int v49 = v133;
  }
  uint64_t v147 = v52;
  v146 = &v55;
  v153 = &v55;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v55, v9, v10, v11, v12, v13);
  _dispatch_thread_setspecific_pair(20, v147, 21, (uint64_t)v146, v14, v15, v16, v17);
  uint64_t v48 = (uint64_t)v58;
  uint64_t v64 = v58;
  uint64_t v63 = 516;
  uint64_t v62 = 0;
  uint64_t v62 = (_DWORD *)v58[3];
  uint64_t v61 = 4;
  uint64_t v86 = 1;
  uint64_t v85 = 600;
  v64[3] = -1;
  if (v62 != (_DWORD *)-1)
  {
    int v79 = 771817480;
    v78 = v62;
    v77 = v64;
    unsigned int v76 = 0;
    if (v62) {
      unsigned int v42 = v78[8];
    }
    else {
      unsigned int v42 = 0;
    }
    unsigned int v76 = v42;
    int v84 = v79;
    uint64_t v83 = v42;
    v82 = v77;
    uint64_t v81 = 0;
    uint64_t v80 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v24, v25, v26, v27, v28, v29, v30, 607);
  }
  unint64_t v68 = v64[1];
  uint64_t v67 = (uint64_t)v62;
  uint64_t v66 = v61 | 2;
  uint64_t v65 = 0;
  if (v68 != -1)
  {
    unint64_t v115 = v68;
    uint64_t v114 = v66;
    unsigned int v113 = 0;
    unsigned int v113 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v112 = 0;
    unsigned int v121 = v113;
    unsigned int v122 = v113 & 0xF00;
    unsigned int v120 = v122 >> 8;
    uint64_t v119 = v113;
    if (v122 >> 8) {
      v119 |= 1 << (v120 + 7);
    }
    uint64_t v112 = v119;
    uint64_t v123 = v119;
    unint64_t v111 = v119 & 0xFFFFFF00;
    BOOL v110 = 0;
    BOOL v41 = 1;
    if ((v114 & 1) == 0) {
      BOOL v41 = (v115 & 0x10000000) != 0;
    }
    BOOL v110 = v41;
    unint64_t v117 = v115;
    v115 &= 0xFFFFFFu;
    if (v115)
    {
      if (v115 >= v111)
      {
        if (v110 || (v113 & 0x44000000) != 0) {
          uint64_t v116 = v115;
        }
        else {
          uint64_t v116 = v112;
        }
      }
      else
      {
        uint64_t v116 = v112;
      }
    }
    else
    {
      unsigned int v118 = v113 & 0xF000;
      unsigned int v109 = v118 >> 12;
      if (v118 >> 12)
      {
        unsigned int v125 = v109;
        uint64_t v124 = 1 << (v109 + 7);
        uint64_t v40 = v124 | 0xFF;
      }
      else
      {
        uint64_t v40 = v112;
      }
      uint64_t v116 = v40;
    }
    uint64_t v65 = v116;
  }
  uint64_t v72 = v65;
  uint64_t v71 = v67;
  uint64_t v70 = v66;
  uint64_t v95 = v65;
  BOOL v108 = v65 != -1;
  uint64_t v107 = 2395;
  if (v65 == -1) {
    _dispatch_abort(v107, v108, v18, v19, v20, v21, v22, v23);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v106 = v95;
    uint64_t v105 = 4261412863;
    uint64_t v104 = 0;
    v95 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v94 = 0;
    v97 = 0;
    v97 = _dispatch_thread_getspecific(4uLL);
    unint64_t v94 = (unint64_t)v97;
    uint64_t v93 = 0x1000000;
    uint64_t v92 = 2281701376;
    if ((v97 & 0x1000000) != 0)
    {
      if (v95)
      {
        uint64_t v39 = v95;
      }
      else
      {
        unint64_t v103 = v94;
        uint64_t v102 = v93;
        uint64_t v101 = 0;
        uint64_t v39 = v94 & (~v93 | 0xFFFFFF);
      }
      uint64_t v96 = v39;
    }
    else
    {
      unint64_t v100 = v94;
      uint64_t v99 = v92;
      uint64_t v98 = 0;
      v94 &= ~v92 | 0xFFFFFF;
      if (v95 == v94) {
        uint64_t v96 = 0;
      }
      else {
        uint64_t v96 = v95;
      }
    }
  }
  else
  {
    uint64_t v96 = 0;
  }
  uint64_t v72 = v96;
  if (v96) {
    goto LABEL_92;
  }
  if (v71 == -1)
  {
    uint64_t v73 = -1;
    goto LABEL_93;
  }
  uint64_t v38 = (void *)v71;
  if (v38 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_92:
    uint64_t v73 = _dispatch_set_priority_and_voucher_slow(v72, (_DWORD *)v71, v70);
  }
  else
  {
    BOOL v69 = (v70 & 4) != 0;
    if ((v70 & 2) != 0)
    {
      if (v69 && v71)
      {
        object = (void *)v71;
        os_release((void *)v71);
      }
      uint64_t v71 = -1;
    }
    else if (!v69 && v71)
    {
      v75 = (void *)v71;
      os_retain((void *)v71);
    }
    uint64_t v73 = v71;
  }
LABEL_93:
  uint64_t v89 = v48;
  v88 = 0;
  v88 = _dispatch_thread_getspecific(0x16uLL);
  int v87 = 0;
  if (v88) {
    int v37 = v88[2] + 1;
  }
  else {
    int v37 = 1;
  }
  int v87 = v37;
  if (v37 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(v89 + 16) = v88;
    *(_DWORD *)(v89 + 8) = v87;
    _dispatch_thread_setspecific(22, v89);
    uint64_t v90 = 0;
  }
  else
  {
    uint64_t v90 = v89;
  }
  uint64_t v47 = (void *)v90;
  _dispatch_continuation_pop(v54, v57, v56, v52);
  if (v47) {
    _dispatch_continuation_free_to_cache_limit(v47);
  }
  v148 = &v55;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v55, v31, v32, v33, v34, v35);
  if (v46)
  {
    v91 = v50;
    _dispatch_thread_setspecific(20, (uint64_t)v50);
  }
  unsigned int v152 = v49;
  unsigned int v151 = 0;
  unsigned int v151 = _dispatch_thread_getspecific(0x19uLL);
  v152 &= 0xFFF0FFFF;
  v152 |= v151 & 0xF0000;
  _dispatch_thread_setspecific(25, v152);
  for (uint64_t i = *(void *)(v52 + 24); ; uint64_t i = *(void *)(i + 24))
  {
    BOOL v36 = 0;
    if (*(void *)(i + 24)) {
      BOOL v36 = i != (void)v50;
    }
    if (!v36) {
      break;
    }
    uint64_t v59 = i;
    uint64_t v60 = i;
    _dispatch_lane_non_barrier_complete(i, 0);
  }
  _dispatch_lane_non_barrier_complete(v52, 1u);
}

void *_dispatch_workloop_stealer_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v22 = a3;
  uint64_t v25 = (_DWORD *)a1[3];
  a1[3] = -1;
  if (v25 != (_DWORD *)-1)
  {
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v8, v9, v10, v11, v12, v13, v14, 607);
  }
  uint64_t v28 = a1[1];
  uint64_t v27 = 0;
  if (v28 != -1)
  {
    unsigned int v35 = _dispatch_thread_getspecific(0x19uLL);
    int v38 = (unsigned __int16)(v35 & 0xF00) >> 8;
    unint64_t v37 = v35;
    if (v38) {
      unint64_t v37 = v35 | (unint64_t)(1 << (v38 + 7));
    }
    if ((v28 & 0xFFFFFF) != 0)
    {
      if ((v28 & 0xFFFFFFuLL) >= (v37 & 0xFFFFFF00))
      {
        if ((v28 & 0x10000000) != 0 || (v35 & 0x44000000) != 0) {
          uint64_t v36 = v28 & 0xFFFFFF;
        }
        else {
          uint64_t v36 = v37;
        }
      }
      else
      {
        uint64_t v36 = v37;
      }
    }
    else
    {
      int v34 = (unsigned __int16)(v35 & 0xF000) >> 12;
      if (v34) {
        uint64_t v19 = (1 << (v34 + 7)) | 0xFF;
      }
      else {
        uint64_t v19 = v37;
      }
      uint64_t v36 = v19;
    }
    uint64_t v27 = v36;
  }
  if (v27 == -1) {
    _dispatch_abort(2395, 0, a3, a4, a5, a6, a7, a8);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v32 = v27 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v31 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v31 & 0x1000000) != 0)
    {
      if (v32) {
        unint64_t v18 = v27 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v18 = v31 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v33 = v18;
    }
    else if (v32 == (v31 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v33 = 0;
    }
    else
    {
      unint64_t v33 = v27 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v33 = 0;
  }
  if (v33) {
    goto LABEL_38;
  }
  if (v25 == (_DWORD *)-1) {
    goto LABEL_39;
  }
  if (v25 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_38:
    _dispatch_set_priority_and_voucher_slow(v33, v25, 6);
  }
  else if (v25)
  {
    os_release(v25);
  }
LABEL_39:
  uint64_t v29 = _dispatch_thread_getspecific(0x16uLL);
  if (v29) {
    int v17 = v29[2] + 1;
  }
  else {
    int v17 = 1;
  }
  if (v17 <= _dispatch_continuation_cache_limit)
  {
    a1[2] = v29;
    *((_DWORD *)a1 + 2) = v17;
    _dispatch_thread_setspecific(22, (uint64_t)a1);
    uint64_t v30 = 0;
  }
  else
  {
    uint64_t v30 = a1;
  }
  uint64_t v20 = (uint64_t *)a1[6];
  uint64_t v16 = 0;
  if (*v20) {
    uint64_t v16 = *v20;
  }
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t *, uint64_t, void))(v16 + 48))(v20, a2, v22 | 1u);
  if (v30) {
    return _dispatch_continuation_free_to_cache_limit(v30);
  }
  return result;
}

uint64_t _dispatch_queue_override_invoke(void *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v52 = _dispatch_thread_getspecific(0x14uLL);
  __int16 v50 = 4;
  int v51 = (void *)a1[6];
  uint64_t v92 = a1[7];
  unsigned int v91 = _dispatch_thread_getspecific(0x19uLL);
  uint64_t v49 = 0;
  if (*(void *)v92) {
    uint64_t v49 = *(void *)v92;
  }
  if ((*(void *)(v49 + 16) & 0x10000) == 0) {
    _dispatch_abort(1946, 0, v3, v4, v5, v6, v7, v8);
  }
  int v93 = *(_DWORD *)(v92 + 84);
  unsigned int v94 = v93 & 0xFFF0FFFF | _dispatch_thread_getspecific(0x19uLL) & 0xF0000;
  _dispatch_thread_setspecific(25, v94);
  _dispatch_thread_setspecific(20, v92);
  uint64_t v48 = 0;
  if (*a1) {
    uint64_t v48 = *a1;
  }
  if (*(void *)(v48 + 16) == 1792)
  {
    a3 |= 1u;
    __int16 v50 = 516;
  }
  unsigned int v56 = (_DWORD *)a1[3];
  a1[3] = -1;
  if (v56 != (_DWORD *)-1)
  {
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v15, v16, v17, v18, v19, v20, v21, 607);
  }
  uint64_t v58 = a1[1];
  unint64_t v57 = 0;
  if (v58 != -1)
  {
    unsigned int v85 = _dispatch_thread_getspecific(0x19uLL);
    int v88 = (unsigned __int16)(v85 & 0xF00) >> 8;
    unint64_t v87 = v85;
    if (v88) {
      unint64_t v87 = v85 | (unint64_t)(1 << (v88 + 7));
    }
    if ((v58 & 0xFFFFFF) != 0)
    {
      if ((v58 & 0xFFFFFF) >= (unint64_t)(v87 & 0xFFFFFF00))
      {
        if ((v58 & 0x10000000) != 0 || (v85 & 0x44000000) != 0) {
          unint64_t v86 = v58 & 0xFFFFFF;
        }
        else {
          unint64_t v86 = v87;
        }
      }
      else
      {
        unint64_t v86 = v87;
      }
    }
    else
    {
      int v84 = (unsigned __int16)(v85 & 0xF000) >> 12;
      if (v84) {
        uint64_t v47 = (1 << (v84 + 7)) | 0xFF;
      }
      else {
        uint64_t v47 = v87;
      }
      unint64_t v86 = v47;
    }
    unint64_t v57 = v86;
  }
  if (v57 == -1) {
    _dispatch_abort(2395, 0, v9, v10, v11, v12, v13, v14);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v79 = v57 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v78 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v78 & 0x1000000) != 0)
    {
      if (v79) {
        unint64_t v46 = v57 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v46 = v78 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v80 = v46;
    }
    else if (v79 == (v78 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v80 = 0;
    }
    else
    {
      unint64_t v80 = v57 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v80 = 0;
  }
  if (v80) {
    goto LABEL_46;
  }
  if (v56 == (_DWORD *)-1) {
    goto LABEL_47;
  }
  if (v56 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_46:
    _dispatch_set_priority_and_voucher_slow(v80, v56, v50 & 4 | 2);
  }
  else if (v56)
  {
    os_release(v56);
  }
LABEL_47:
  uint64_t v59 = _dispatch_thread_getspecific(0x16uLL);
  if (v59) {
    int v45 = v59[2] + 1;
  }
  else {
    int v45 = 1;
  }
  if (v45 <= _dispatch_continuation_cache_limit)
  {
    a1[2] = v59;
    *((_DWORD *)a1 + 2) = v45;
    _dispatch_thread_setspecific(22, (uint64_t)a1);
    uint64_t v60 = 0;
  }
  else
  {
    uint64_t v60 = a1;
  }
  if (*v51 >= 0x1000uLL)
  {
    uint64_t v44 = 0;
    if (*v51) {
      uint64_t v44 = *v51;
    }
    if (*(void *)(v44 + 16) == 1)
    {
      uint64_t v43 = 0;
      if (*v51) {
        uint64_t v43 = *v51;
      }
      (*(void (**)(void *, void, void))(v43 + 24))(v51, 0, (a3 >> 21) & 1);
    }
    else
    {
      uint64_t v42 = 0;
      if (*v51) {
        uint64_t v42 = *v51;
      }
      (*(void (**)(void *, uint64_t, void))(v42 + 48))(v51, a2, a3);
    }
    goto LABEL_137;
  }
  uint64_t v62 = 0;
  if ((a3 & 0x1000000) != 0) {
    uint64_t v62 = _dispatch_autorelease_pool_push();
  }
  uint64_t v61 = *v51;
  uint64_t v67 = (_DWORD *)v51[3];
  uint64_t v66 = *v51 & 4;
  if (v66) {
    v51[3] = -1;
  }
  if (v67 != (_DWORD *)-1)
  {
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v28, v29, v30, v31, v32, v33, v34, 607);
  }
  uint64_t v69 = v51[1];
  unint64_t v68 = 0;
  if (v69 != -1)
  {
    unsigned int v82 = _dispatch_thread_getspecific(0x19uLL);
    int v90 = (unsigned __int16)(v82 & 0xF00) >> 8;
    unint64_t v89 = v82;
    if (v90) {
      unint64_t v89 = v82 | (unint64_t)(1 << (v90 + 7));
    }
    if ((v69 & 0xFFFFFF) != 0)
    {
      if ((v69 & 0xFFFFFF) >= (unint64_t)(v89 & 0xFFFFFF00))
      {
        if ((v69 & 0x10000000) != 0 || (v82 & 0x44000000) != 0) {
          unint64_t v83 = v69 & 0xFFFFFF;
        }
        else {
          unint64_t v83 = v89;
        }
      }
      else
      {
        unint64_t v83 = v89;
      }
    }
    else
    {
      int v81 = (unsigned __int16)(v82 & 0xF000) >> 12;
      if (v81) {
        uint64_t v41 = (1 << (v81 + 7)) | 0xFF;
      }
      else {
        uint64_t v41 = v89;
      }
      unint64_t v83 = v41;
    }
    unint64_t v68 = v83;
  }
  if (v68 == -1) {
    _dispatch_abort(2395, 0, v22, v23, v24, v25, v26, v27);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v76 = v68 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v75 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v75 & 0x1000000) != 0)
    {
      if (v76) {
        unint64_t v40 = v68 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v40 = v75 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v77 = v40;
    }
    else if (v76 == (v75 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v77 = 0;
    }
    else
    {
      unint64_t v77 = v68 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v77 = 0;
  }
  if (v77)
  {
LABEL_105:
    _dispatch_set_priority_and_voucher_slow(v77, v67, v66 | 2);
    goto LABEL_106;
  }
  if (v67 != (_DWORD *)-1)
  {
    if (v67 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if ((v66 & 4) != 0 && v67) {
        os_release(v67);
      }
      goto LABEL_106;
    }
    goto LABEL_105;
  }
LABEL_106:
  if ((v61 & 4) != 0)
  {
    uint64_t v70 = _dispatch_thread_getspecific(0x16uLL);
    if (v70) {
      int v39 = v70[2] + 1;
    }
    else {
      int v39 = 1;
    }
    if (v39 <= _dispatch_continuation_cache_limit)
    {
      v51[2] = v70;
      *((_DWORD *)v51 + 2) = v39;
      _dispatch_thread_setspecific(22, (uint64_t)v51);
      uint64_t v71 = 0;
    }
    else
    {
      uint64_t v71 = v51;
    }
    uint64_t v63 = v71;
  }
  else
  {
    uint64_t v63 = 0;
  }
  if ((v61 & 8) != 0)
  {
    dispatch_group_t group = (dispatch_group_t)v51[6];
    uint64_t v38 = 0;
    if (*(void *)group) {
      uint64_t v38 = *(void *)group;
    }
    if (*(void *)(v38 + 16) != 514)
    {
      uint64_t v37 = 0;
      if (*(void *)group) {
        uint64_t v37 = *(void *)group;
      }
      uint64_t v35 = *(void *)(v37 + 16);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected object type";
      qword_F42C0 = v35;
      __break(1u);
      JUMPOUT(0x17988);
    }
    uint64_t v74 = v51[5];
    uint64_t v73 = (void (*)(void (**)(void)))v51[4];
    if (v73 == _dispatch_call_block_and_release && v74) {
      _Block_get_invoke_fn(v74);
    }
    _dispatch_client_callout(v74, (uint64_t (*)(uint64_t))v73);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    dispatch_group_leave(group);
  }
  else
  {
    uint64_t v65 = v51[5];
    uint64_t v64 = (void (*)(void (**)(void)))v51[4];
    if (v64 == _dispatch_call_block_and_release && v65) {
      _Block_get_invoke_fn(v65);
    }
    _dispatch_client_callout(v65, (uint64_t (*)(uint64_t))v64);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
  }
  if (v63) {
    _dispatch_continuation_free_to_cache_limit(v63);
  }
  if (v62) {
    _dispatch_autorelease_pool_pop(v62);
  }
LABEL_137:
  if ((v50 & 0x200) == 0 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  if (v60) {
    _dispatch_continuation_free_to_cache_limit(v60);
  }
  unsigned int v95 = _dispatch_thread_getspecific(0x19uLL);
  _dispatch_thread_setspecific(25, v91 & 0xFFF0FFFF | v95 & 0xF0000);
  return _dispatch_thread_setspecific(20, (uint64_t)v52);
}

void *_dispatch_continuation_free_to_cache_limit(void *a1)
{
  _dispatch_continuation_free_to_heap(a1);
  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  uint64_t v5 = result;
  if (result)
  {
    int v3 = *((_DWORD *)result + 2) - _dispatch_continuation_cache_limit;
    if (v3 > 0)
    {
      do
      {
        uint64_t v4 = v5[2];
        _dispatch_continuation_free_to_heap(v5);
        --v3;
        BOOL v2 = 0;
        if (v3)
        {
          uint64_t v5 = (void *)v4;
          BOOL v2 = v4 != 0;
        }
      }
      while (v2);
      return (void *)_dispatch_thread_setspecific(22, v4);
    }
  }
  return result;
}

void _dispatch_continuation_pop(void *a1, uint64_t a2, int a3, uint64_t a4)
{
}

void _dispatch_continuation_pop_inline(void *a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned __int16 v29 = HIWORD(a3);
  uint64_t v27 = (void (**)(uint64_t))_dispatch_thread_getspecific(0x18uLL);
  if (v27) {
    (*v27)(a4);
  }
  unsigned int v28 = v29 << 16;
  if (*a1 >= 0x1000uLL)
  {
    uint64_t v26 = 0;
    if (*a1) {
      uint64_t v26 = *a1;
    }
    if (*(void *)(v26 + 16) == 1)
    {
      uint64_t v25 = 0;
      if (*a1) {
        uint64_t v25 = *a1;
      }
      (*(void (**)(void *, void, void))(v25 + 24))(a1, 0, (v28 >> 21) & 1);
    }
    else
    {
      uint64_t v24 = 0;
      if (*a1) {
        uint64_t v24 = *a1;
      }
      (*(void (**)(void *, uint64_t, void))(v24 + 48))(a1, a2, v28);
    }
    goto LABEL_87;
  }
  uint64_t v34 = 0;
  if ((v28 & 0x1000000) != 0) {
    uint64_t v34 = _dispatch_autorelease_pool_push();
  }
  uint64_t v33 = *a1;
  int v39 = (_DWORD *)a1[3];
  uint64_t v38 = *a1 & 4;
  if (v38) {
    a1[3] = -1;
  }
  if (v39 != (_DWORD *)-1)
  {
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v10, v11, v12, v13, v14, v15, v16, 607);
  }
  uint64_t v41 = a1[1];
  uint64_t v40 = 0;
  if (v41 != -1)
  {
    unsigned int v17 = _dispatch_thread_getspecific(0x19uLL);
    int v53 = (unsigned __int16)(v17 & 0xF00) >> 8;
    unint64_t v52 = v17;
    if (v53) {
      unint64_t v52 = v17 | (unint64_t)(1 << (v53 + 7));
    }
    if ((v41 & 0xFFFFFF) != 0)
    {
      if ((v41 & 0xFFFFFFuLL) >= (v52 & 0xFFFFFF00))
      {
        if ((v41 & 0x10000000) != 0 || (v17 & 0x44000000) != 0) {
          uint64_t v51 = v41 & 0xFFFFFF;
        }
        else {
          uint64_t v51 = v52;
        }
      }
      else
      {
        uint64_t v51 = v52;
      }
    }
    else
    {
      int v50 = (unsigned __int16)(v17 & 0xF000) >> 12;
      if (v50) {
        uint64_t v23 = (1 << (v50 + 7)) | 0xFF;
      }
      else {
        uint64_t v23 = v52;
      }
      uint64_t v51 = v23;
    }
    uint64_t v40 = v51;
  }
  if (v40 == -1) {
    _dispatch_abort(2395, 0, v4, v5, v6, v7, v8, v9);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v48 = v40 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v47 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v47 & 0x1000000) != 0)
    {
      if (v48) {
        unint64_t v22 = v40 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v22 = v47 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v49 = v22;
    }
    else if (v48 == (v47 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v49 = 0;
    }
    else
    {
      unint64_t v49 = v40 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v49 = 0;
  }
  if (v49)
  {
LABEL_55:
    _dispatch_set_priority_and_voucher_slow(v49, v39, v38 | 2);
    goto LABEL_56;
  }
  if (v39 != (_DWORD *)-1)
  {
    if (v39 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if ((v38 & 4) != 0 && v39) {
        os_release(v39);
      }
      goto LABEL_56;
    }
    goto LABEL_55;
  }
LABEL_56:
  if ((v33 & 4) != 0)
  {
    uint64_t v42 = _dispatch_thread_getspecific(0x16uLL);
    if (v42) {
      int v21 = v42[2] + 1;
    }
    else {
      int v21 = 1;
    }
    if (v21 <= _dispatch_continuation_cache_limit)
    {
      a1[2] = v42;
      *((_DWORD *)a1 + 2) = v21;
      _dispatch_thread_setspecific(22, (uint64_t)a1);
      uint64_t v43 = 0;
    }
    else
    {
      uint64_t v43 = a1;
    }
    uint64_t v35 = v43;
  }
  else
  {
    uint64_t v35 = 0;
  }
  if ((v33 & 8) != 0)
  {
    dispatch_group_t group = (dispatch_group_t)a1[6];
    uint64_t v20 = 0;
    if (*(void *)group) {
      uint64_t v20 = *(void *)group;
    }
    if (*(void *)(v20 + 16) != 514)
    {
      uint64_t v19 = 0;
      if (*(void *)group) {
        uint64_t v19 = *(void *)group;
      }
      uint64_t v18 = *(void *)(v19 + 16);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected object type";
      qword_F42C0 = v18;
      __break(1u);
      JUMPOUT(0x1905CLL);
    }
    uint64_t v46 = a1[5];
    int v45 = (void (*)(void (**)(void)))a1[4];
    if (v45 == _dispatch_call_block_and_release && v46) {
      _Block_get_invoke_fn(v46);
    }
    _dispatch_client_callout(v46, (uint64_t (*)(uint64_t))v45);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    dispatch_group_leave(group);
  }
  else
  {
    uint64_t v37 = a1[5];
    uint64_t v36 = (void (*)(void (**)(void)))a1[4];
    if (v36 == _dispatch_call_block_and_release && v37) {
      _Block_get_invoke_fn(v37);
    }
    _dispatch_client_callout(v37, (uint64_t (*)(uint64_t))v36);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
  }
  if (v35) {
    _dispatch_continuation_free_to_cache_limit(v35);
  }
  if (v34) {
    _dispatch_autorelease_pool_pop(v34);
  }
LABEL_87:
  if (v27) {
    v27[1](a4);
  }
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  if ((flags & 0xFFFFFF00) != 0) {
    return 0;
  }
  else {
    return _dispatch_block_create_with_voucher_and_priority(flags, 0, 0, block, v2, v3, v4, v5);
  }
}

void *_dispatch_block_create_with_voucher_and_priority(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = a1;
  if ((a1 & 0xA) != 0) {
    uint64_t v23 = a1 | 0x40000000;
  }
  if ((v23 & 0x20) != 0) {
    v23 &= ~0x10uLL;
  }
  uint64_t v22 = v23;
  if ((v23 & 0x80000000) == 0)
  {
    if ((v23 & 2) != 0)
    {
      a2 = 0;
      uint64_t v22 = v23 | 0x80000000;
    }
    else if ((v23 & 0x40) != 0)
    {
      a2 = -1;
      uint64_t v22 = v23 | 0x80000000;
    }
    else if ((v23 & 4) != 0)
    {
      a2 = -3;
      uint64_t v22 = v23 | 0x80000000;
    }
  }
  if (a2 == -3) {
    a2 = (uint64_t)_dispatch_thread_getspecific(0x1CuLL);
  }
  if ((v23 & 4) != 0 && (v22 & 0x40000000) == 0)
  {
    unint64_t v25 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v25 <= 0x10FF) {
      uint64_t v26 = v25;
    }
    else {
      uint64_t v26 = 4351;
    }
    a3 = v26;
    v22 |= 0x40000000uLL;
  }
  uint64_t v18 = _dispatch_block_create((void *)v22, (void *)a2, a3, a4, a5, a6, a7, a8);
  uint64_t v16 = _Block_get_invoke_fn((uint64_t)v18);
  unsigned int v17 = 0;
  if (v16) {
    unsigned int v17 = (uint64_t (*)())v16;
  }
  if (v17 == _dispatch_block_special_invoke)
  {
    if (v18[4] != 3512316172)
    {
      uint64_t v14 = v18[4];
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v14;
      __break(1u);
      JUMPOUT(0x1978CLL);
    }
    uint64_t v24 = (char *)(v18 + 4);
  }
  else
  {
    uint64_t v24 = 0;
  }
  if (!v24) {
    _dispatch_abort(405, 0, v8, v9, v10, v11, v12, v13);
  }
  _Block_get_invoke_fn((uint64_t)a4);
  _dispatch_thread_getspecific(4uLL);
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  return v18;
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  if ((flags & 0xFFFFFF00) != 0) {
    return 0;
  }
  if (qos_class == QOS_CLASS_UNSPECIFIED
    || qos_class == 5
    || qos_class == QOS_CLASS_BACKGROUND
    || qos_class == QOS_CLASS_UTILITY
    || qos_class == QOS_CLASS_DEFAULT
    || qos_class == QOS_CLASS_USER_INITIATED
    || qos_class == QOS_CLASS_USER_INTERACTIVE)
  {
    BOOL v10 = 0;
    if (relative_priority >= -15) {
      BOOL v10 = relative_priority <= 0;
    }
    BOOL v14 = v10;
  }
  else
  {
    BOOL v14 = 0;
  }
  if (!v14) {
    return 0;
  }
  uint64_t v4 = _pthread_qos_class_encode();
  return _dispatch_block_create_with_voucher_and_priority(flags | 0x40000000, 0, v4, block, v5, v6, v7, v8);
}

void *dispatch_block_create_with_voucher(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 0xFFFFFF00) != 0) {
    return 0;
  }
  else {
    return _dispatch_block_create_with_voucher_and_priority(a1 & 0xFFFFFFFF7FFFFFBFLL | 0x80000000, a2, 0, a3, a5, a6, a7, a8);
  }
}

void *dispatch_block_create_with_voucher_and_qos_class(uint64_t a1, uint64_t a2, int a3, int a4, const void *a5)
{
  if ((a1 & 0xFFFFFF00) != 0) {
    return 0;
  }
  if (!a3 || a3 == 5 || a3 == 9 || a3 == 17 || a3 == 21 || a3 == 25 || a3 == 33)
  {
    BOOL v11 = 0;
    if (a4 >= -15) {
      BOOL v11 = a4 <= 0;
    }
    BOOL v16 = v11;
  }
  else
  {
    BOOL v16 = 0;
  }
  if (!v16) {
    return 0;
  }
  uint64_t v5 = _pthread_qos_class_encode();
  return _dispatch_block_create_with_voucher_and_priority(a1 & 0xFFFFFFFF3FFFFFB7 | 0xC0000000, a2, v5, a5, v6, v7, v8, v9);
}

void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t block)
{
  dispatch_block_flags_t v15 = flags;
  dispatch_block_t v14 = block;
  dispatch_block_flags_t v16 = flags;
  if ((flags & 0xFFFFFF00) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid flags passed to dispatch_block_perform()";
    qword_F42C0 = v15;
    __break(1u);
    JUMPOUT(0x19DBCLL);
  }
  dispatch_block_flags_t v17 = v15;
  if ((v15 & 0xA) != 0) {
    v17 |= 0x40000000uLL;
  }
  if ((v17 & 0x20) != 0) {
    v17 &= ~0x10uLL;
  }
  dispatch_block_flags_t v15 = v17;
  uint64_t v13 = -1;
  if ((v17 & 2) != 0)
  {
    uint64_t v13 = 0;
    v15 |= 0x80000000uLL;
  }
  uint64_t v12 = 0;
  v8[0] = 0xD159B10CuLL;
  *((void *)&v8[0] + 1) = v15;
  v8[1] = 8uLL;
  uint64_t v9 = v13;
  dispatch_block_t v10 = v14;
  long long v11 = 0uLL;
  _dispatch_block_invoke_direct((uint64_t)v8, (uint64_t)block, v2, v3, v4, v5, v6, v7);
}

void _dispatch_block_invoke_direct(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = *(void *)(a1 + 8);
  unsigned int v16 = *(_DWORD *)(a1 + 16);
  if ((v16 >> 2))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_F42C0 = v16;
    __break(1u);
    JUMPOUT(0x19F54);
  }
  if (v16) {
    goto LABEL_56;
  }
  uint64_t v15 = 0;
  uint64_t v19 = 0;
  if ((v17 & 0x40000000) != 0 && ((v17 & 0x20) != 0 || (v17 & 0x10) == 0))
  {
    unint64_t v20 = *(void *)(a1 + 24) & 0xFFFFFFLL;
    int v21 = _dispatch_thread_getspecific(4uLL);
    if ((v21 & 0xFFFFFF) != 0 && (v21 & 0xFFFFFF) < v20) {
      uint64_t v19 = v21 & 0xFFFFFF;
    }
  }
  if (v19) {
    uint64_t v15 = *(void *)(a1 + 24);
  }
  uint64_t v14 = -1;
  if ((v17 & 0x80000000) != 0) {
    uint64_t v14 = *(void *)(a1 + 32);
  }
  if (v15 == -1) {
    _dispatch_abort(2395, 0, a3, a4, a5, a6, a7, a8);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v25 = v15 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v8 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v8 & 0x1000000) != 0)
    {
      if (v25) {
        unint64_t v13 = v15 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v13 = v8 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v26 = v13;
    }
    else if (v25 == (v8 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v26 = 0;
    }
    else
    {
      unint64_t v26 = v15 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v26 = 0;
  }
  if (v26) {
    goto LABEL_33;
  }
  if (v14 == -1)
  {
    uint64_t v22 = -1;
    goto LABEL_34;
  }
  if ((void *)v14 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_33:
    uint64_t v22 = _dispatch_set_priority_and_voucher_slow(v26, v14, 0);
  }
  else
  {
    if (v14) {
      os_retain((void *)v14);
    }
    uint64_t v22 = v14;
  }
LABEL_34:
  *(_DWORD *)(a1 + 64) = _dispatch_thread_getspecific(3uLL);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = _Block_get_invoke_fn(v10);
  uint64_t v12 = 0;
  if (v11) {
    uint64_t v12 = (void (*)(void (**)(void)))v11;
  }
  if (v12 == _dispatch_call_block_and_release && v10) {
    _Block_get_invoke_fn(v10);
  }
  _dispatch_client_callout(v10, (uint64_t (*)(uint64_t))v12);
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v23 & 0x1000000) != 0)
    {
      if ((v19 & 0x2FFFFFF) != 0) {
        unint64_t v9 = v19 & 0x2FFFFFF;
      }
      else {
        unint64_t v9 = v23 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v24 = v9;
    }
    else if ((v19 & 0x2FFFFFF) == (v23 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v24 = 0;
    }
    else
    {
      unint64_t v24 = v19 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v24 = 0;
  }
  if (v24) {
    goto LABEL_55;
  }
  if (v22 == -1) {
    goto LABEL_56;
  }
  if ((void *)v22 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_55:
    _dispatch_set_priority_and_voucher_slow(v24, v22, 6);
    goto LABEL_56;
  }
  if (v22) {
    os_release((void *)v22);
  }
LABEL_56:
  if ((v16 & 8) == 0 && !atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 20), 1u, memory_order_relaxed)) {
    dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  }
}

void _dispatch_block_sync_invoke(uint64_t a1)
{
  uint64_t v11 = _Block_get_invoke_fn(a1);
  uint64_t v12 = 0;
  if (v11) {
    uint64_t v12 = (uint64_t (*)())v11;
  }
  if (v12 == _dispatch_block_special_invoke)
  {
    if (*(void *)(a1 + 32) != 3512316172)
    {
      uint64_t v1 = *(void *)(a1 + 32);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0x1AAB8);
    }
    uint64_t v17 = a1 + 32;
  }
  else
  {
    uint64_t v17 = 0;
  }
  unsigned int v15 = *(_DWORD *)(v17 + 16);
  if ((v15 >> 2))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_F42C0 = v15;
    __break(1u);
    JUMPOUT(0x1AB44);
  }
  if (v15) {
    goto LABEL_50;
  }
  uint64_t v14 = -1;
  if ((*(void *)(v17 + 8) & 0x80000000) != 0)
  {
    uint64_t v18 = *(_DWORD **)(v17 + 32);
    unsigned __int16 v2 = (unsigned __int16)_dispatch_thread_getspecific(0x19uLL);
    int v27 = (unsigned __int16)(v2 & 0xF00) >> 8;
    unint64_t v26 = v2;
    if (v27) {
      unint64_t v26 = v2 | (unint64_t)(1 << (v27 + 7));
    }
    int v25 = (unsigned __int16)(v2 & 0xF000) >> 12;
    if (v25) {
      uint64_t v10 = (1 << (v25 + 7)) | 0xFF;
    }
    else {
      uint64_t v10 = v26;
    }
    if (v10 == -1) {
      _dispatch_abort(2395, 0, v3, v4, v5, v6, v7, v8);
    }
    if (_dispatch_set_qos_class_enabled)
    {
      unint64_t v23 = v10 & 0xFFFFFFFF02FFFFFFLL;
      unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      if ((v22 & 0x1000000) != 0)
      {
        if (v23) {
          unint64_t v9 = v10 & 0xFFFFFFFF02FFFFFFLL;
        }
        else {
          unint64_t v9 = v22 & 0xFFFFFFFFFEFFFFFFLL;
        }
        unint64_t v24 = v9;
      }
      else if (v23 == (v22 & 0xFFFFFFFF77FFFFFFLL))
      {
        unint64_t v24 = 0;
      }
      else
      {
        unint64_t v24 = v10 & 0xFFFFFFFF02FFFFFFLL;
      }
    }
    else
    {
      unint64_t v24 = 0;
    }
    if (!v24)
    {
      if (v18 == (_DWORD *)-1)
      {
        uint64_t v19 = -1;
LABEL_37:
        uint64_t v14 = v19;
        goto LABEL_38;
      }
      if (v18 == _dispatch_thread_getspecific(0x1CuLL))
      {
        if (v18) {
          os_retain(v18);
        }
        uint64_t v19 = (uint64_t)v18;
        goto LABEL_37;
      }
    }
    uint64_t v19 = _dispatch_set_priority_and_voucher_slow(v24, v18, 0);
    goto LABEL_37;
  }
LABEL_38:
  (*(void (**)(void))(*(void *)(v17 + 40) + 16))();
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v20 & 0x1000000) != 0) {
      unint64_t v21 = v20 & 0xFFFFFFFFFEFFFFFFLL;
    }
    else {
      unint64_t v21 = 0;
    }
  }
  else
  {
    unint64_t v21 = 0;
  }
  if (v21) {
    goto LABEL_49;
  }
  if (v14 == -1) {
    goto LABEL_50;
  }
  if ((void *)v14 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    _dispatch_set_priority_and_voucher_slow(v21, (_DWORD *)v14, 6);
    goto LABEL_50;
  }
  if (v14) {
    os_release((void *)v14);
  }
LABEL_50:
  if ((v15 & 8) == 0 && !atomic_fetch_add_explicit((atomic_uint *volatile)(v17 + 20), 1u, memory_order_relaxed)) {
    dispatch_group_leave(*(dispatch_group_t *)(v17 + 48));
  }
  uint64_t v13 = __swp(0, (unsigned int *)(v17 + 56));
  if (v13) {
    _dispatch_release_2(v13);
  }
}

void _dispatch_release_2(uint64_t a1)
{
  signed int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != 0x7FFFFFFF) {
    signed int v2 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 8), 0xFFFFFFFE, memory_order_release) - 2;
  }
  if (v2 < 1)
  {
    if (v2 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x1B600);
    }
    int v1 = *(_DWORD *)(a1 + 12);
    if (v1 >= 1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0x1B660);
    }
    _os_object_dispose((uint64_t *)a1);
  }
}

void dispatch_block_cancel(dispatch_block_t block)
{
  uint64_t v2 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v3 = 0;
  if (v2) {
    uint64_t v3 = (uint64_t (*)())v2;
  }
  if (v3 == _dispatch_block_special_invoke)
  {
    if (*((void *)block + 4) != 3512316172)
    {
      uint64_t v1 = *((void *)block + 4);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0x1B7A4);
    }
    uint64_t v5 = (char *)block + 32;
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (!v5)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_cancel()";
    __break(1u);
    JUMPOUT(0x1B7ECLL);
  }
  atomic_fetch_or_explicit((atomic_uint *volatile)(v5 + 16), 1u, memory_order_relaxed);
}

intptr_t dispatch_block_testcancel(dispatch_block_t block)
{
  uint64_t v3 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v4 = 0;
  if (v3) {
    uint64_t v4 = (uint64_t (*)())v3;
  }
  if (v4 == _dispatch_block_special_invoke)
  {
    if (*((void *)block + 4) != 3512316172)
    {
      uint64_t v1 = *((void *)block + 4);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0x1B9A0);
    }
    uint64_t v6 = (char *)block + 32;
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (!v6)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_testcancel()";
    __break(1u);
    JUMPOUT(0x1B9E8);
  }
  return *((_DWORD *)v6 + 4) & 1;
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  uint64_t v10 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v11 = 0;
  if (v10) {
    uint64_t v11 = (uint64_t (*)())v10;
  }
  if (v11 == _dispatch_block_special_invoke)
  {
    if (*((void *)block + 4) != 3512316172)
    {
      uint64_t v2 = *((void *)block + 4);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v2;
      __break(1u);
      JUMPOUT(0x1BB38);
    }
    unint64_t v20 = (char *)block + 32;
  }
  else
  {
    unint64_t v20 = 0;
  }
  if (!v20)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_wait()";
    __break(1u);
    JUMPOUT(0x1BB80);
  }
  unsigned int v17 = atomic_fetch_or_explicit((atomic_uint *volatile)(v20 + 16), 2u, memory_order_relaxed);
  if ((v17 & 6) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be waited for more than once";
    qword_F42C0 = v17;
    __break(1u);
    JUMPOUT(0x1BC28);
  }
  unint64_t v16 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  unsigned int v15 = (uint64_t *)__swp(0, (unsigned int *)v20 + 14);
  if (v15)
  {
    uint64_t v9 = 0;
    if (*v15) {
      uint64_t v9 = *v15;
    }
    unsigned int v3 = (v16 & 0x3FFF00) >> 8;
    unsigned int v4 = __clz(__rbit32(v3));
    if (v3) {
      uint64_t v5 = v4 + 1;
    }
    else {
      uint64_t v5 = 0;
    }
    (*(void (**)(uint64_t *, uint64_t, uint64_t))(v9 + 64))(v15, v5, 9);
  }
  int v14 = *((_DWORD *)v20 + 16);
  if (v14 && (_dispatch_set_qos_class_enabled & 1) != 0) {
    _pthread_qos_override_start_direct();
  }
  int v13 = *((_DWORD *)v20 + 5);
  char v8 = 1;
  if (v13 <= 1)
  {
    BOOL v7 = 0;
    if (v14) {
      BOOL v7 = v15 != 0;
    }
    char v8 = v7;
  }
  if (v8)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_F42C0 = v13;
    __break(1u);
    JUMPOUT(0x1BE90);
  }
  intptr_t v12 = dispatch_group_wait(*((dispatch_group_t *)v20 + 6), timeout);
  if (v14 && (_dispatch_set_qos_class_enabled & 1) != 0) {
    _pthread_qos_override_end_direct();
  }
  if (v12) {
    atomic_fetch_and_explicit((atomic_uint *volatile)(v20 + 16), 0xFFFFFFFD, memory_order_relaxed);
  }
  else {
    atomic_fetch_or_explicit((atomic_uint *volatile)(v20 + 16), 4u, memory_order_relaxed);
  }
  return v12;
}

void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block)
{
  uint64_t v4 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v5 = 0;
  if (v4) {
    uint64_t v5 = (uint64_t (*)())v4;
  }
  if (v5 == _dispatch_block_special_invoke)
  {
    if (*((void *)block + 4) != 3512316172)
    {
      uint64_t v3 = *((void *)block + 4);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v3;
      __break(1u);
      JUMPOUT(0x1C148);
    }
    uint64_t v11 = (char *)block + 32;
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (!v11)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_notify()";
    qword_F42C0 = (uint64_t)block;
    __break(1u);
    JUMPOUT(0x1C1A8);
  }
  int v6 = *((_DWORD *)v11 + 5);
  if (v6 >= 2)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and observed";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x1C22CLL);
  }
  dispatch_group_notify(*((dispatch_group_t *)v11 + 6), queue, notification_block);
}

uint64_t _dispatch_continuation_init_slow(uint64_t *a1, unint64_t a2, int a3)
{
  uint64_t v38 = a1[5];
  uint64_t v28 = _Block_get_invoke_fn(v38);
  unsigned __int16 v29 = 0;
  if (v28) {
    unsigned __int16 v29 = (uint64_t (*)())v28;
  }
  if (v29 == _dispatch_block_special_invoke)
  {
    if (*(void *)(v38 + 32) != 3512316172)
    {
      uint64_t v3 = *(void *)(v38 + 32);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v3;
      __break(1u);
      JUMPOUT(0x1C38CLL);
    }
    uint64_t v39 = v38 + 32;
  }
  else
  {
    uint64_t v39 = 0;
  }
  uint64_t v33 = *(void *)(v39 + 8);
  uint64_t v32 = *a1;
  _dispatch_retain_2(a2);
  uint64_t v10 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v39 + 56), (unint64_t *)&v10, a2, memory_order_relaxed, memory_order_relaxed);
  if (v10) {
    _dispatch_release_2(a2);
  }
  if ((v32 & 4) != 0) {
    a1[4] = (uint64_t)_dispatch_block_async_invoke_and_release;
  }
  else {
    a1[4] = (uint64_t)_dispatch_block_async_invoke;
  }
  int v35 = a3 | v33;
  if ((v33 & 0x40000000) != 0)
  {
    uint64_t v31 = *(void *)(v39 + 24) & 0xFFFFFFLL;
  }
  else if ((v35 & 0x40000000) != 0)
  {
    uint64_t v31 = 0;
  }
  else
  {
    unint64_t v44 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v44 <= 0x10FF) {
      uint64_t v45 = v44;
    }
    else {
      uint64_t v45 = 4351;
    }
    uint64_t v31 = v45;
  }
  uint64_t v41 = v31;
  if (v31)
  {
    if ((v35 & 0x20) != 0)
    {
      uint64_t v41 = v31 | 0x10000000;
    }
    else if ((*(_DWORD *)(a2 + 84) & 0x40000000) == 0 && (*(_DWORD *)(a2 + 84) & 0xFFF) != 0)
    {
      uint64_t v41 = 0;
    }
  }
  a1[1] = v41;
  if (v33) {
    v32 |= 2uLL;
  }
  if ((v33 & 0x80000000) != 0)
  {
    uint64_t v30 = *(void **)(v39 + 32);
    if (!v30 || v30 == (void *)-1)
    {
      uint64_t v27 = *(void *)(v39 + 32);
    }
    else
    {
      os_retain(v30);
      uint64_t v27 = (uint64_t)v30;
    }
    a1[3] = v27;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 746);
    uint64_t v42 = a1[3];
    if (v42 != -1 && MEMORY[0xFFFFFC100]) {
LABEL_45:
    }
      kdebug_trace();
  }
  else
  {
    uint64_t v43 = 0;
    if (v35 < 0) {
      _dispatch_abort(583, v35 >= 0, v4, v5, v6, v7, v8, v9);
    }
    if ((v35 & 0x40) == 0)
    {
      uint64_t v46 = _dispatch_thread_getspecific(0x1CuLL);
      if (v46) {
        os_retain(v46);
      }
      uint64_t v43 = (uint64_t)v46;
    }
    a1[3] = v43;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v18, v19, v20, v21, v22, v23, v24, 589);
    if (a1[3] != -1 && MEMORY[0xFFFFFC100]) {
      goto LABEL_45;
    }
  }
  *a1 = v32 | 0x20;
  unint64_t v40 = (a1[1] & 0x3FFF00uLL) >> 8;
  unsigned int v25 = __clz(__rbit32(v40));
  if (v40) {
    return v25 + 1;
  }
  else {
    return 0;
  }
}

void _dispatch_block_async_invoke_and_release(void *a1)
{
}

void _dispatch_block_async_invoke(void *a1)
{
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v17 = _dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22, v17[2]);
    *uint64_t v17 = 262;
    v17[4] = work;
    v17[5] = context;
    unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v20 <= 0x10FF) {
      unint64_t v21 = v20;
    }
    else {
      unint64_t v21 = 4351;
    }
    uint64_t v22 = _dispatch_thread_getspecific(0x1CuLL);
    if (v22) {
      os_retain(v22);
    }
    v17[3] = v22;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    if (v17[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v19 = v21;
    unsigned int v18 = 0;
    if (v21)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v10 = v21 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v18 = v12;
      }
      else
      {
        unint64_t v19 = 0;
      }
    }
    v17[1] = v19;
    uint64_t v13 = 0;
    if (*(void *)queue) {
      uint64_t v13 = *(void *)queue;
    }
    (*(void (**)(dispatch_queue_t, void *, void))(v13 + 72))(queue, v17, v18);
  }
  else
  {
    _dispatch_async_f_slow((uint64_t *)queue, (uint64_t)context, (uint64_t)work, 0, 6);
  }
}

uint64_t _dispatch_async_f_slow(uint64_t *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unint64_t v26 = (void *)_dispatch_continuation_alloc_from_heap();
  unint64_t v32 = 0;
  *unint64_t v26 = a5 | 0x100;
  v26[4] = a3;
  v26[5] = a2;
  if ((a4 & 0x40000000) == 0)
  {
    unint64_t v36 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v36 <= 0x10FF) {
      uint64_t v37 = v36;
    }
    else {
      uint64_t v37 = 4351;
    }
    unint64_t v32 = v37;
  }
  int v35 = 0;
  if (a4 < 0) {
    _dispatch_abort(583, a4 >= 0, v5, v6, v7, v8, v9, v10);
  }
  if ((a4 & 0x40) == 0)
  {
    uint64_t v38 = _dispatch_thread_getspecific(0x1CuLL);
    if (v38) {
      os_retain(v38);
    }
    int v35 = v38;
  }
  v26[3] = v35;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 589);
  if (v26[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v34 = v32;
  unsigned int v33 = 0;
  if (v32)
  {
    if ((a4 & 0x20) != 0)
    {
      uint64_t v34 = v32 | 0x10000000;
      unsigned int v18 = (v32 | 0x10000000) >> 8;
      unsigned int v19 = __clz(__rbit32(v18));
      if (v18) {
        unsigned int v20 = v19 + 1;
      }
      else {
        unsigned int v20 = 0;
      }
      unsigned int v33 = v20;
    }
    else if ((*((_DWORD *)a1 + 21) & 0x40000000) != 0 || (*((_DWORD *)a1 + 21) & 0xFFF) == 0)
    {
      unsigned int v21 = v32 >> 8;
      unsigned int v22 = __clz(__rbit32(v21));
      if (v21) {
        unsigned int v23 = v22 + 1;
      }
      else {
        unsigned int v23 = 0;
      }
      unsigned int v33 = v23;
    }
    else
    {
      uint64_t v34 = 0;
    }
  }
  v26[1] = v34;
  uint64_t v25 = 0;
  if (*a1) {
    uint64_t v25 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void *, void))(v25 + 72))(a1, v26, v33);
}

uint64_t _dispatch_barrier_async_detached_f(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = _dispatch_thread_getspecific(0x16uLL);
  if (v12)
  {
    _dispatch_thread_setspecific(22, v12[2]);
    uint64_t v11 = v12;
  }
  else
  {
    uint64_t v11 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  void *v11 = 262;
  v11[4] = a3;
  v11[5] = a2;
  v11[3] = -1;
  v11[1] = -1;
  uint64_t v7 = 0;
  if (*a1) {
    uint64_t v7 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void *, void, uint64_t, uint64_t, uint64_t))(v7 + 72))(a1, v11, 0, v3, v4, v5);
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
  unsigned int v18 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22, v18[2]);
    uint64_t v17 = v18;
  }
  else
  {
    uint64_t v17 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  unsigned int v19 = _dispatch_Block_copy(block);
  uint64_t v13 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v14 = 0;
  if (v13) {
    uint64_t v14 = (uint64_t (*)())v13;
  }
  if (v14 == _dispatch_block_special_invoke)
  {
    *uint64_t v17 = 278;
    v17[5] = (uint64_t)v19;
    unsigned int inited = _dispatch_continuation_init_slow(v17, (unint64_t)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *uint64_t v17 = 278;
    v17[4] = (uint64_t)_dispatch_call_block_and_release;
    v17[5] = (uint64_t)v19;
    unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v23 <= 0x10FF) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = 4351;
    }
    uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
    if (v25) {
      os_retain(v25);
    }
    v17[3] = (uint64_t)v25;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    if (v17[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v22 = v24;
    unsigned int v21 = 0;
    if (v24)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v9 = v24 >> 8;
        unsigned int v10 = __clz(__rbit32(v9));
        if (v9) {
          unsigned int v11 = v10 + 1;
        }
        else {
          unsigned int v11 = 0;
        }
        unsigned int v21 = v11;
      }
      else
      {
        unint64_t v22 = 0;
      }
    }
    v17[1] = v22;
    unsigned int inited = v21;
  }
  uint64_t v12 = 0;
  if (*(void *)queue) {
    uint64_t v12 = *(void *)queue;
  }
  (*(void (**)(dispatch_queue_t, uint64_t *, void))(v12 + 72))(queue, v17, inited);
}

void dispatch_channel_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v17 = _dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22, v17[2]);
    *uint64_t v17 = 260;
    v17[4] = work;
    v17[5] = context;
    unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v20 <= 0x10FF) {
      unint64_t v21 = v20;
    }
    else {
      unint64_t v21 = 4351;
    }
    unint64_t v22 = _dispatch_thread_getspecific(0x1CuLL);
    if (v22) {
      os_retain(v22);
    }
    v17[3] = v22;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    if (v17[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v19 = v21;
    unsigned int v18 = 0;
    if (v21)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v10 = v21 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v18 = v12;
      }
      else
      {
        unint64_t v19 = 0;
      }
    }
    v17[1] = v19;
    uint64_t v13 = 0;
    if (*(void *)queue) {
      uint64_t v13 = *(void *)queue;
    }
    (*(void (**)(dispatch_queue_t, void *, void))(v13 + 72))(queue, v17, v18);
  }
  else
  {
    _dispatch_async_f_slow((uint64_t *)queue, (uint64_t)context, (uint64_t)work, 0, 4);
  }
}

uint64_t dispatch_async_enforce_qos_class_f(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v18 = _dispatch_thread_getspecific(0x16uLL);
  if (!v18) {
    return _dispatch_async_f_slow(a1, a2, a3, 32, 4);
  }
  _dispatch_thread_setspecific(22, v18[2]);
  *unsigned int v18 = 260;
  v18[4] = a3;
  v18[5] = a2;
  unint64_t v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v21 <= 0x10FF) {
    uint64_t v22 = v21;
  }
  else {
    uint64_t v22 = 4351;
  }
  unint64_t v23 = _dispatch_thread_getspecific(0x1CuLL);
  if (v23) {
    os_retain(v23);
  }
  v18[3] = v23;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  if (v18[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v20 = v22;
  unsigned int v19 = 0;
  if (v22)
  {
    uint64_t v20 = v22 | 0x10000000;
    unsigned int v11 = (v22 | 0x10000000uLL) >> 8;
    unsigned int v12 = __clz(__rbit32(v11));
    if (v11) {
      unsigned int v13 = v12 + 1;
    }
    else {
      unsigned int v13 = 0;
    }
    unsigned int v19 = v13;
  }
  v18[1] = v20;
  uint64_t v14 = 0;
  if (*a1) {
    uint64_t v14 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void *, void))(v14 + 72))(a1, v18, v19);
}

void dispatch_channel_async(dispatch_queue_t queue, dispatch_block_t block)
{
  unsigned int v18 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22, v18[2]);
    uint64_t v17 = v18;
  }
  else
  {
    uint64_t v17 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  unsigned int v19 = _dispatch_Block_copy(block);
  uint64_t v13 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v14 = 0;
  if (v13) {
    uint64_t v14 = (uint64_t (*)())v13;
  }
  if (v14 == _dispatch_block_special_invoke)
  {
    *uint64_t v17 = 276;
    v17[5] = (uint64_t)v19;
    unsigned int inited = _dispatch_continuation_init_slow(v17, (unint64_t)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *uint64_t v17 = 276;
    v17[4] = (uint64_t)_dispatch_call_block_and_release;
    v17[5] = (uint64_t)v19;
    unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v23 <= 0x10FF) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = 4351;
    }
    uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
    if (v25) {
      os_retain(v25);
    }
    v17[3] = (uint64_t)v25;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    if (v17[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v22 = v24;
    unsigned int v21 = 0;
    if (v24)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        unsigned int v9 = v24 >> 8;
        unsigned int v10 = __clz(__rbit32(v9));
        if (v9) {
          unsigned int v11 = v10 + 1;
        }
        else {
          unsigned int v11 = 0;
        }
        unsigned int v21 = v11;
      }
      else
      {
        unint64_t v22 = 0;
      }
    }
    v17[1] = v22;
    unsigned int inited = v21;
  }
  uint64_t v12 = 0;
  if (*(void *)queue) {
    uint64_t v12 = *(void *)queue;
  }
  (*(void (**)(dispatch_queue_t, uint64_t *, void))(v12 + 72))(queue, v17, inited);
}

uint64_t _dispatch_barrier_trysync_or_async_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), unsigned int a4)
{
  unsigned int v4 = _dispatch_thread_getspecific(3uLL);
  uint64_t v18 = (4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  BOOL v16 = 0;
  uint64_t v17 = *(void *)(a1 + 56);
  do
  {
    if (v17 != (v18 | v17 & 0x3000000000)) {
      break;
    }
    uint64_t v9 = v17;
    uint64_t v10 = v17;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v10, v4 & 0xFFFFFFFC | 0x60000000000002 | ((unint64_t)((a4 & 1) != 0) << 58) | v17 & 0x3000000000, memory_order_acquire, memory_order_acquire);
    if (v10 != v9) {
      uint64_t v17 = v10;
    }
    BOOL v16 = v10 == v9;
  }
  while (v10 != v9);
  if (!v16) {
    return _dispatch_barrier_async_detached_f((uint64_t *)a1, a2, (uint64_t)a3);
  }
  if (a4) {
    _dispatch_retain_2(a1);
  }
  return _dispatch_barrier_trysync_or_async_f_complete(a1, a2, a3, a4, v5, v6, v7, v8);
}

uint64_t _dispatch_retain_2(uint64_t result)
{
  int add_explicit = *(_DWORD *)(result + 8);
  if (add_explicit != 0x7FFFFFFF) {
    int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 8), 2u, memory_order_relaxed);
  }
  if (add_explicit <= 0)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0x1FECCLL);
  }
  return result;
}

uint64_t _dispatch_barrier_trysync_or_async_f_complete(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v23 = a4;
  unsigned int v22 = 4;
  uint64_t v28 = a1;
  uint64_t v27 = a2;
  unint64_t v26 = a3;
  long long v25 = 0uLL;
  uint64_t v41 = a1;
  unint64_t v40 = &v25;
  uint64_t v43 = &v25;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v25, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v41, 21, (uint64_t)v40, v8, v9, v10, v11);
  uint64_t v35 = v27;
  uint64_t v34 = v26;
  unsigned int v33 = 0;
  if ((char *)v26 == (char *)_dispatch_call_block_and_release && v35)
  {
    uint64_t v20 = _Block_get_invoke_fn(v35);
    unsigned int v21 = 0;
    if (v20) {
      unsigned int v21 = (uint64_t (*)(uint64_t))v20;
    }
    unsigned int v19 = v21;
  }
  else
  {
    unsigned int v19 = v34;
  }
  unsigned int v33 = v19;
  uint64_t v37 = v35;
  unint64_t v36 = v19;
  int v32 = 0;
  int v31 = 0;
  int v30 = 0;
  int v29 = 0;
  _dispatch_client_callout(v35, v34);
  uint64_t v39 = v35;
  uint64_t v38 = v33;
  uint64_t v42 = &v25;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v25, v12, v13, v14, v15, v16);
  if ((v23 & 1) != 0
    && ((atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 56), 0xFC00000000000000, memory_order_relaxed)
       - 0x400000000000000) & 0xFF80000000000000) == 0)
  {
    unsigned int v22 = 5;
  }
  uint64_t v18 = 0;
  if (*(void *)a1) {
    uint64_t v18 = *(void *)a1;
  }
  return (*(uint64_t (**)(uint64_t, void, void))(v18 + 64))(a1, 0, v22);
}

void dispatch_barrier_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  *(_DWORD *)&v11[8] = 0;
  *(void *)uint64_t v11 = _dispatch_thread_getspecific(3uLL);
  uint64_t v10 = 0;
  if (*(void *)queue) {
    uint64_t v10 = *(void *)queue;
  }
  if (*(unsigned char *)(v10 + 16) != 17) {
    goto LABEL_7;
  }
  LOBYTE(v9) = 0;
  if ((*((_DWORD *)queue + 20) & 0x1000000) != 0) {
    int v9 = (BYTE2(*((_DWORD *)queue + 20)) >> 2) & 1;
  }
  if ((v9 & 1) == 0) {
    char v15 = 1;
  }
  else {
LABEL_7:
  }
    char v15 = 0;
  if ((v15 & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
    __break(1u);
    JUMPOUT(0x204B0);
  }
  unint64_t v18 = (unint64_t)(4096 - *((unsigned __int16 *)queue + 40)) << 41;
  BOOL v16 = 0;
  uint64_t v17 = *((void *)queue + 7);
  do
  {
    if (v17 != (v18 | v17 & 0x3000000000)) {
      break;
    }
    uint64_t v7 = v17;
    uint64_t v8 = v17;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)queue + 56), (unint64_t *)&v8, *(_DWORD *)v11 & 0xFFFFFFFC | 0x60000000000002 | v17 & 0x3000000000, memory_order_acquire, memory_order_acquire);
    if (v8 != v7) {
      uint64_t v17 = v8;
    }
    BOOL v16 = v8 == v7;
  }
  while (v8 != v7);
  if (v16)
  {
    if (*(void *)(*((void *)queue + 3) + 24)) {
      _dispatch_sync_recurse((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, *(void *)&v11[4] | 2);
    }
    else {
      _dispatch_lane_barrier_sync_invoke_and_complete((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0, v3, v4, v5, v6);
    }
  }
  else
  {
    _dispatch_sync_f_slow((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 2, (uint64_t)queue, *(void *)&v11[4] | 2, v5, v6);
  }
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  if (*((_WORD *)queue + 40) == 1)
  {
    _dispatch_barrier_sync_f((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0);
  }
  else
  {
    uint64_t v10 = 0;
    if (*(void *)queue) {
      uint64_t v10 = *(void *)queue;
    }
    if (*(unsigned char *)(v10 + 16) != 17) {
      goto LABEL_9;
    }
    LOBYTE(v9) = 0;
    if ((*((_DWORD *)queue + 20) & 0x1000000) != 0) {
      int v9 = (BYTE2(*((_DWORD *)queue + 20)) >> 2) & 1;
    }
    if ((v9 & 1) == 0) {
      char v11 = 1;
    }
    else {
LABEL_9:
    }
      char v11 = 0;
    if ((v11 & 1) == 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
      __break(1u);
      JUMPOUT(0x208FCLL);
    }
    if (*((void *)queue + 6))
    {
      char v13 = 0;
    }
    else
    {
      for (unint64_t i = *((void *)queue + 7); ; unint64_t i = v8)
      {
        if (i >> 54 || (i & 0x8000000000) != 0 || (i & 0x10000000000) != 0)
        {
          char v13 = 0;
          goto LABEL_23;
        }
        unint64_t v7 = i;
        unint64_t v8 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)queue + 56), &v8, i + 0x20000000000, memory_order_relaxed, memory_order_relaxed);
        if (v8 == v7) {
          break;
        }
      }
      char v13 = 1;
    }
LABEL_23:
    if (v13)
    {
      if (*(void *)(*((void *)queue + 3) + 24)) {
        _dispatch_sync_recurse((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0);
      }
      else {
        _dispatch_sync_invoke_and_complete((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0, v3, v4, v5, v6);
      }
    }
    else
    {
      _dispatch_sync_f_slow((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0, (uint64_t)queue, 0, v5, v6);
    }
  }
}

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v4 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v5 = 0;
  if (v4) {
    uint64_t v5 = (uint64_t (*)())v4;
  }
  if (v5 == _dispatch_block_special_invoke)
  {
    _dispatch_sync_block_with_privdata((unint64_t)queue, (uint64_t)block, 18);
  }
  else
  {
    uint64_t v2 = _Block_get_invoke_fn((uint64_t)block);
    uint64_t v3 = 0;
    if (v2) {
      uint64_t v3 = (uint64_t (*)(uint64_t))v2;
    }
    _dispatch_barrier_sync_f((uint64_t)queue, (uint64_t)block, v3, 18);
  }
}

void _dispatch_sync_block_with_privdata(unint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = _Block_get_invoke_fn(a2);
  unsigned int v19 = 0;
  if (v18) {
    unsigned int v19 = (uint64_t (*)())v18;
  }
  if (v19 == _dispatch_block_special_invoke)
  {
    if (*(void *)(a2 + 32) != 3512316172)
    {
      uint64_t v9 = *(void *)(a2 + 32);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v9;
      __break(1u);
      JUMPOUT(0x20DD0);
    }
    uint64_t v32 = a2 + 32;
  }
  else
  {
    uint64_t v32 = 0;
  }
  uint64_t v22 = 0;
  uint64_t v21 = *(void *)(v32 + 8);
  if (v21) {
    uint64_t v24 = a3 | 0x22;
  }
  else {
    uint64_t v24 = a3 | 0x20;
  }
  uint64_t v27 = 0;
  if ((v21 & 0x40000000) != 0 && ((v21 & 0x20) != 0 || (v21 & 0x10) == 0))
  {
    unint64_t v28 = *(void *)(v32 + 24) & 0xFFFFFFLL;
    int v29 = _dispatch_thread_getspecific(4uLL);
    if ((v29 & 0xFFFFFF) != 0 && (v29 & 0xFFFFFF) < v28) {
      uint64_t v27 = v29 & 0xFFFFFF;
    }
  }
  if (v27) {
    uint64_t v22 = *(void *)(v32 + 24);
  }
  uint64_t v20 = -1;
  if ((v21 & 0x80000000) != 0) {
    uint64_t v20 = *(void *)(v32 + 32);
  }
  if (v22 == -1) {
    _dispatch_abort(2395, 0, v3, v4, v5, v6, v7, v8);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v35 = v22 & 0xFFFFFFFF02FFFFFFLL;
    unint64_t v10 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v10 & 0x1000000) != 0)
    {
      if (v35) {
        unint64_t v17 = v22 & 0xFFFFFFFF02FFFFFFLL;
      }
      else {
        unint64_t v17 = v10 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v36 = v17;
    }
    else if (v35 == (v10 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v36 = 0;
    }
    else
    {
      unint64_t v36 = v22 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v36 = 0;
  }
  if (v36)
  {
LABEL_40:
    uint64_t v30 = _dispatch_set_priority_and_voucher_slow(v36, (_DWORD *)v20, 0);
    goto LABEL_41;
  }
  if (v20 != -1)
  {
    if ((void *)v20 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if (v20) {
        os_retain((void *)v20);
      }
      uint64_t v30 = v20;
      goto LABEL_41;
    }
    goto LABEL_40;
  }
  uint64_t v30 = -1;
LABEL_41:
  _dispatch_retain_2(a1);
  uint64_t v15 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v32 + 56), (unint64_t *)&v15, a1, memory_order_relaxed, memory_order_relaxed);
  if (v15) {
    _dispatch_release_2(a1);
  }
  if ((v24 & 2) != 0) {
    _dispatch_barrier_sync_f(a1, a2, (uint64_t (*)(uint64_t))_dispatch_block_sync_invoke, v24);
  }
  else {
    _dispatch_sync_f(a1, a2, (uint64_t (*)(uint64_t))_dispatch_block_sync_invoke, v24, v11, v12, v13, v14);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v33 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v33 & 0x1000000) != 0)
    {
      if ((v27 & 0x2FFFFFF) != 0) {
        unint64_t v16 = v27 & 0x2FFFFFF;
      }
      else {
        unint64_t v16 = v33 & 0xFFFFFFFFFEFFFFFFLL;
      }
      unint64_t v34 = v16;
    }
    else if ((v27 & 0x2FFFFFF) == (v33 & 0xFFFFFFFF77FFFFFFLL))
    {
      unint64_t v34 = 0;
    }
    else
    {
      unint64_t v34 = v27 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    unint64_t v34 = 0;
  }
  if (v34) {
    goto LABEL_62;
  }
  if (v30 == -1) {
    return;
  }
  if ((void *)v30 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_62:
    _dispatch_set_priority_and_voucher_slow(v34, (_DWORD *)v30, 6);
  }
  else if (v30)
  {
    os_release((void *)v30);
  }
}

void _dispatch_barrier_sync_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  unsigned int v12 = _dispatch_thread_getspecific(3uLL);
  uint64_t v11 = 0;
  if (*(void *)a1) {
    uint64_t v11 = *(void *)a1;
  }
  if (*(unsigned char *)(v11 + 16) != 17) {
    goto LABEL_7;
  }
  LOBYTE(v10) = 0;
  if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
    int v10 = (BYTE2(*(_DWORD *)(a1 + 80)) >> 2) & 1;
  }
  if ((v10 & 1) == 0) {
    char v17 = 1;
  }
  else {
LABEL_7:
  }
    char v17 = 0;
  if ((v17 & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
    __break(1u);
    JUMPOUT(0x217FCLL);
  }
  unint64_t v20 = (unint64_t)(4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  BOOL v18 = 0;
  uint64_t v19 = *(void *)(a1 + 56);
  do
  {
    if (v19 != (v20 | v19 & 0x3000000000)) {
      break;
    }
    uint64_t v8 = v19;
    uint64_t v9 = v19;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, v12 & 0xFFFFFFFC | 0x60000000000002 | v19 & 0x3000000000, memory_order_acquire, memory_order_acquire);
    if (v9 != v8) {
      uint64_t v19 = v9;
    }
    BOOL v18 = v9 == v8;
  }
  while (v9 != v8);
  if (v18)
  {
    if (*(void *)(*(void *)(a1 + 24) + 24)) {
      _dispatch_sync_recurse(a1, a2, a3, a4 | 2);
    }
    else {
      _dispatch_lane_barrier_sync_invoke_and_complete(a1, a2, a3, 0, v4, v5, v6, v7);
    }
  }
  else
  {
    _dispatch_sync_f_slow(a1, a2, a3, 2, a1, a4 | 2, v6, v7);
  }
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v8 = _Block_get_invoke_fn((uint64_t)block);
  uint64_t v9 = 0;
  if (v8) {
    uint64_t v9 = (uint64_t (*)())v8;
  }
  if (v9 == _dispatch_block_special_invoke)
  {
    _dispatch_sync_block_with_privdata((unint64_t)queue, (uint64_t)block, 16);
  }
  else
  {
    uint64_t v6 = _Block_get_invoke_fn((uint64_t)block);
    uint64_t v7 = 0;
    if (v6) {
      uint64_t v7 = (uint64_t (*)(uint64_t))v6;
    }
    _dispatch_sync_f((uint64_t)queue, (uint64_t)block, v7, 16, v2, v3, v4, v5);
  }
}

void _dispatch_sync_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 80) == 1)
  {
    _dispatch_barrier_sync_f(a1, a2, a3, a4);
  }
  else
  {
    uint64_t v11 = 0;
    if (*(void *)a1) {
      uint64_t v11 = *(void *)a1;
    }
    if (*(unsigned char *)(v11 + 16) != 17) {
      goto LABEL_9;
    }
    LOBYTE(v10) = 0;
    if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
      int v10 = (BYTE2(*(_DWORD *)(a1 + 80)) >> 2) & 1;
    }
    if ((v10 & 1) == 0) {
      char v12 = 1;
    }
    else {
LABEL_9:
    }
      char v12 = 0;
    if ((v12 & 1) == 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
      __break(1u);
      JUMPOUT(0x21D94);
    }
    if (*(void *)(a1 + 48))
    {
      char v14 = 0;
    }
    else
    {
      for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v9)
      {
        if (i >> 54 || (i & 0x8000000000) != 0 || (i & 0x10000000000) != 0)
        {
          char v14 = 0;
          goto LABEL_23;
        }
        unint64_t v8 = i;
        unint64_t v9 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v9, i + 0x20000000000, memory_order_relaxed, memory_order_relaxed);
        if (v9 == v8) {
          break;
        }
      }
      char v14 = 1;
    }
LABEL_23:
    if (v14)
    {
      if (*(void *)(*(void *)(a1 + 24) + 24)) {
        _dispatch_sync_recurse(a1, a2, a3, a4);
      }
      else {
        _dispatch_sync_invoke_and_complete(a1, a2, a3, 0, a5, a6, a7, a8);
      }
    }
    else
    {
      _dispatch_sync_f_slow(a1, a2, a3, 0, a1, a4, a7, a8);
    }
  }
}

void dispatch_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  if (*((void *)queue + 3))
  {
    uint64_t v8 = 128;
    if (*((_WORD *)queue + 40) == 1) {
      uint64_t v8 = 130;
    }
    _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)context, (uint64_t)work, v8);
  }
  else
  {
    _dispatch_sync_function_invoke((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, v3, v4, v5, v6, v7);
  }
}

uint64_t _dispatch_sync_function_invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a1;
  uint64_t v23 = a2;
  uint64_t v22 = a3;
  long long v21 = 0uLL;
  uint64_t v37 = a1;
  unint64_t v36 = &v21;
  uint64_t v39 = &v21;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v21, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v37, 21, (uint64_t)v36, v8, v9, v10, v11);
  uint64_t v31 = v23;
  uint64_t v30 = v22;
  int v29 = 0;
  if ((char *)v22 == (char *)_dispatch_call_block_and_release && v31)
  {
    uint64_t v19 = _Block_get_invoke_fn(v31);
    unint64_t v20 = 0;
    if (v19) {
      unint64_t v20 = (uint64_t (*)(uint64_t))v19;
    }
    BOOL v18 = v20;
  }
  else
  {
    BOOL v18 = v30;
  }
  int v29 = v18;
  uint64_t v33 = v31;
  uint64_t v32 = v18;
  int v28 = 0;
  int v27 = 0;
  int v26 = 0;
  int v25 = 0;
  _dispatch_client_callout(v31, v30);
  uint64_t v35 = v31;
  unint64_t v34 = v29;
  uint64_t v38 = &v21;
  return _dispatch_thread_setspecific_packed_pair(20, 21, &v21, v12, v13, v14, v15, v16);
}

void _dispatch_async_and_wait_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  uint64_t v11 = a4;
  unint64_t v15 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  unint64_t v10 = v15;
  int v9 = _dispatch_thread_getspecific(3uLL);
  memset(__b, 0, sizeof(__b));
  __b[0] = v11;
  __b[1] = v15 | 0x10000000;
  __b[2] = 0;
  __b[3] = _dispatch_thread_getspecific(0x1CuLL);
  __b[4] = _dispatch_async_and_wait_invoke;
  void __b[5] = __b;
  unint64_t __b[6] = 0;
  __b[7] = v14;
  __b[8] = v12;
  __b[9] = v13;
  memset(&__b[10], 0, 20);
  HIDWORD(__b[12]) = v9;
  LOWORD(__b[13]) = 0;
  BYTE2(__b[13]) = 0;
  _dispatch_async_and_wait_recurse(v14, (uint64_t)__b, v9, v11, v4, v5, v6, v7);
}

void dispatch_barrier_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  if (*((void *)queue + 3)) {
    _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)context, (uint64_t)work, 130);
  }
  else {
    _dispatch_sync_function_invoke((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, v3, v4, v5, v6, v7);
  }
}

void dispatch_barrier_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  if (*((void *)queue + 3))
  {
    uint64_t v4 = _Block_get_invoke_fn((uint64_t)block);
    uint64_t v5 = 0;
    if (v4) {
      uint64_t v5 = (uint64_t (*)())v4;
    }
    if (v5 == _dispatch_block_special_invoke)
    {
      _dispatch_async_and_wait_block_with_privdata((uint64_t)queue, (uint64_t)block, 146);
    }
    else
    {
      uint64_t v2 = _Block_get_invoke_fn((uint64_t)block);
      uint64_t v3 = 0;
      if (v2) {
        uint64_t v3 = v2;
      }
      _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)block, v3, 146);
    }
  }
  else
  {
    dispatch_barrier_sync(queue, block);
  }
}

void _dispatch_async_and_wait_block_with_privdata(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = a1;
  uint64_t v23 = a2;
  uint64_t v22 = a3;
  long long v21 = 0;
  uint64_t v36 = a2;
  uint64_t v49 = a2;
  uint64_t v10 = _Block_get_invoke_fn(a2);
  uint64_t v11 = 0;
  if (v10) {
    uint64_t v11 = (uint64_t (*)())v10;
  }
  if (v11 == _dispatch_block_special_invoke)
  {
    uint64_t v35 = v36 + 32;
    unint64_t v34 = (uint64_t *)(v36 + 32);
    if (*(void *)(v36 + 32) != 3512316172)
    {
      uint64_t v33 = 0;
      uint64_t v3 = *v34;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v3;
      __break(1u);
      JUMPOUT(0x2282CLL);
    }
    uint64_t v37 = v34;
  }
  else
  {
    uint64_t v37 = 0;
  }
  long long v21 = v37;
  uint64_t v20 = 0;
  uint64_t v20 = v37[1];
  unint64_t v19 = 0;
  BOOL v18 = 0;
  if (v37[1]) {
    v22 |= 0x22uLL;
  }
  else {
    v22 |= 0x20uLL;
  }
  unint64_t v4 = v21[3];
  uint64_t v29 = v20;
  unint64_t v28 = v4;
  unint64_t v27 = 0;
  unint64_t v26 = 0;
  if ((v20 & 0x40000000) != 0 && ((v29 & 0x20) != 0 || (v29 & 0x10) == 0))
  {
    unint64_t v32 = v28;
    v28 &= 0xFFFFFFuLL;
    unint64_t v30 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    unint64_t v31 = v30;
    unint64_t v27 = v30 & 0xFFFFFF;
    if ((v30 & 0xFFFFFF) != 0 && v27 < v28) {
      unint64_t v26 = v27;
    }
  }
  if (v26)
  {
    unint64_t v19 = v21[3];
  }
  else
  {
    int v25 = _dispatch_thread_getspecific(4uLL);
    unint64_t v19 = (unint64_t)v25;
  }
  if ((*((unsigned char *)v21 + 11) & 0x80) != 0) {
    BOOL v18 = (void *)v21[4];
  }
  else {
    BOOL v18 = _dispatch_thread_getspecific(0x1CuLL);
  }
  unint64_t v48 = v21;
  uint64_t v47 = v24;
  uint64_t v46 = v24;
  _dispatch_retain_2(v24);
  uint64_t v45 = 0;
  BOOL v44 = 0;
  uint64_t v42 = v24;
  uint64_t v41 = v24;
  uint64_t v43 = v24;
  uint64_t v5 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v21 + 7), (unint64_t *)&v5, v24, memory_order_relaxed, memory_order_relaxed);
  if (v5) {
    uint64_t v45 = v5;
  }
  BOOL v40 = v5 == 0;
  BOOL v44 = v5 == 0;
  BOOL v39 = v44;
  if (v5)
  {
    uint64_t v38 = v47;
    _dispatch_release_2(v47);
  }
  int v17 = _dispatch_thread_getspecific(3uLL);
  v12[0] = v22;
  v12[1] = v19 | 0x10000000;
  v12[2] = 0;
  v12[3] = v18;
  v12[4] = _dispatch_async_and_wait_invoke;
  v12[5] = v12;
  v12[6] = 0;
  v12[7] = v24;
  v12[8] = _dispatch_block_sync_invoke;
  v12[9] = v23;
  long long v13 = 0uLL;
  int v14 = 0;
  int v15 = v17;
  uint64_t v16 = 0;
  _dispatch_async_and_wait_recurse(v24, (uint64_t)v12, v17, v22, v6, v7, v8, v9);
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  if (*((void *)queue + 3))
  {
    uint64_t v6 = 144;
    if (*((_WORD *)queue + 40) == 1) {
      uint64_t v6 = 146;
    }
    uint64_t v4 = _Block_get_invoke_fn((uint64_t)block);
    uint64_t v5 = 0;
    if (v4) {
      uint64_t v5 = (uint64_t (*)())v4;
    }
    if (v5 == _dispatch_block_special_invoke)
    {
      _dispatch_async_and_wait_block_with_privdata((uint64_t)queue, (uint64_t)block, v6);
    }
    else
    {
      uint64_t v2 = _Block_get_invoke_fn((uint64_t)block);
      uint64_t v3 = 0;
      if (v2) {
        uint64_t v3 = v2;
      }
      _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)block, v3, v6);
    }
  }
  else
  {
    dispatch_sync(queue, block);
  }
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  if (key)
  {
    uint64_t v11 = *((void *)queue + 11);
    uint64_t v9 = 0;
    if (*(void *)queue) {
      uint64_t v9 = *(void *)queue;
    }
    if (*(unsigned char *)(v9 + 16) == 17)
    {
      uint64_t v8 = 0;
      if (*(void *)queue) {
        uint64_t v8 = *(void *)queue;
      }
      BOOL v7 = 1;
      if (*(void *)(v8 + 16) != 394769)
      {
        uint64_t v6 = 0;
        if (*(void *)queue) {
          uint64_t v6 = *(void *)queue;
        }
        BOOL v7 = (*(unsigned char *)(v6 + 18) & 2) == 0;
      }
      BOOL v16 = v7;
    }
    else
    {
      uint64_t v5 = 0;
      if (*(void *)queue) {
        uint64_t v5 = *(void *)queue;
      }
      BOOL v16 = *(unsigned char *)(v5 + 16) == 18;
    }
    if (!v16)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue doesn't support dispatch_queue_set_specific";
      __break(1u);
      JUMPOUT(0x22FCCLL);
    }
    if (!context || v11)
    {
      if (!v11) {
        return;
      }
    }
    else
    {
      _dispatch_queue_init_specific((uint64_t)queue);
      uint64_t v11 = *((void *)queue + 11);
    }
    unsigned int v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    int v4 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v11, (unsigned int *)&v4, v17, memory_order_acquire, memory_order_acquire);
    if (v4) {
      _dispatch_unfair_lock_lock_slow((atomic_uint *)v11);
    }
    for (unint64_t i = *(uint64_t **)(v11 + 8); i; unint64_t i = (uint64_t *)i[3])
    {
      if (*i == (void)key)
      {
        unint64_t v19 = i;
        goto LABEL_29;
      }
    }
    unint64_t v19 = 0;
LABEL_29:
    if (v19)
    {
      if (v19[2]) {
        _dispatch_barrier_async_detached_f((uint64_t *)&off_F0600, v19[1], v19[2]);
      }
      if (context)
      {
        v19[1] = (uint64_t)context;
        v19[2] = (uint64_t)destructor;
      }
      else
      {
        if (v19[3]) {
          *(void *)(v19[3] + 32) = v19[4];
        }
        else {
          *(void *)(v11 + 16) = v19[4];
        }
        *(void *)v19[4] = v19[3];
        v19[3] = -1;
        v19[4] = -1;
        free(v19);
      }
    }
    else if (context)
    {
      uint64_t v10 = (void *)_dispatch_calloc();
      void *v10 = key;
      v10[1] = context;
      v10[2] = destructor;
      v10[3] = 0;
      v10[4] = *(void *)(v11 + 16);
      **(void **)(v11 + 16) = v10;
      *(void *)(v11 + 16) = v10 + 3;
    }
    unsigned int v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    unsigned int v21 = atomic_exchange_explicit((atomic_uint *volatile)v11, 0, memory_order_release);
    if (v21 != v20) {
      _dispatch_unfair_lock_unlock_slow(v11, v21);
    }
  }
}

void _dispatch_queue_init_specific(uint64_t a1)
{
  uint64_t v2 = (void *)_dispatch_calloc();
  v2[1] = 0;
  size_t v2[2] = v2 + 1;
  uint64_t v1 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 88), (unint64_t *)&v1, (unint64_t)v2, memory_order_release, memory_order_relaxed);
  if (v1) {
    _dispatch_queue_specific_head_dispose(v2);
  }
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  if (!key) {
    return 0;
  }
  uint64_t v12 = *((void *)queue + 11);
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  if (*(void *)queue) {
    uint64_t v9 = *(void *)queue;
  }
  if (*(unsigned char *)(v9 + 16) == 17)
  {
    uint64_t v8 = 0;
    if (*(void *)queue) {
      uint64_t v8 = *(void *)queue;
    }
    BOOL v7 = 1;
    if (*(void *)(v8 + 16) != 394769)
    {
      uint64_t v6 = 0;
      if (*(void *)queue) {
        uint64_t v6 = *(void *)queue;
      }
      BOOL v7 = (*(void *)(v6 + 16) & 0x20000) == 0;
    }
    BOOL v14 = v7;
  }
  else
  {
    uint64_t v5 = 0;
    if (*(void *)queue) {
      uint64_t v5 = *(void *)queue;
    }
    BOOL v14 = *(unsigned char *)(v5 + 16) == 18;
  }
  BOOL v4 = 0;
  if (v14) {
    BOOL v4 = v12 != 0;
  }
  if (v4)
  {
    unsigned int v15 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    int v2 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v12, (unsigned int *)&v2, v15, memory_order_acquire, memory_order_acquire);
    if (v2) {
      _dispatch_unfair_lock_lock_slow((atomic_uint *)v12);
    }
    for (uint64_t i = *(void *)(v12 + 8); i; uint64_t i = *(void *)(i + 24))
    {
      if (*(const void **)i == key)
      {
        uint64_t v17 = i;
        goto LABEL_27;
      }
    }
    uint64_t v17 = 0;
LABEL_27:
    if (v17) {
      uint64_t v11 = *(void **)(v17 + 8);
    }
    unsigned int v18 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    unsigned int v19 = atomic_exchange_explicit((atomic_uint *volatile)v12, 0, memory_order_release);
    if (v19 != v18) {
      _dispatch_unfair_lock_unlock_slow(v12, v19);
    }
  }
  return v11;
}

void *__cdecl dispatch_get_specific(const void *key)
{
  *((void *)&v11 + 1) = key;
  *(void *)&long long v11 = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v10 = 0;
  if (v11 != 0)
  {
    do
    {
      uint64_t v13 = *(void *)(v11 + 88);
      uint64_t v12 = 0;
      uint64_t v9 = 0;
      if (*(void *)v11) {
        uint64_t v9 = *(void *)v11;
      }
      if (*(unsigned char *)(v9 + 16) == 17)
      {
        uint64_t v8 = 0;
        if (*(void *)v11) {
          uint64_t v8 = *(void *)v11;
        }
        BOOL v7 = 1;
        if (*(void *)(v8 + 16) != 394769)
        {
          uint64_t v6 = 0;
          if (*(void *)v11) {
            uint64_t v6 = *(void *)v11;
          }
          BOOL v7 = (*(void *)(v6 + 16) & 0x20000) == 0;
        }
        BOOL v14 = v7;
      }
      else
      {
        uint64_t v5 = 0;
        if (*(void *)v11) {
          uint64_t v5 = *(void *)v11;
        }
        BOOL v14 = *(unsigned char *)(v5 + 16) == 18;
      }
      BOOL v4 = 0;
      if (v14) {
        BOOL v4 = v13 != 0;
      }
      if (v4)
      {
        unsigned int v15 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
        int v1 = 0;
        atomic_compare_exchange_strong_explicit((atomic_uint *volatile)v13, (unsigned int *)&v1, v15, memory_order_acquire, memory_order_acquire);
        if (v1) {
          _dispatch_unfair_lock_lock_slow((atomic_uint *)v13);
        }
        for (uint64_t i = *(void **)(v13 + 8); i; uint64_t i = (void *)i[3])
        {
          if (*i == *((void *)&v11 + 1))
          {
            uint64_t v17 = i;
            goto LABEL_26;
          }
        }
        uint64_t v17 = 0;
LABEL_26:
        if (v17) {
          uint64_t v12 = (void *)v17[1];
        }
        unsigned int v18 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
        unsigned int v19 = atomic_exchange_explicit((atomic_uint *volatile)v13, 0, memory_order_release);
        if (v19 != v18) {
          _dispatch_unfair_lock_unlock_slow(v13, v19);
        }
      }
      uint64_t v10 = v12;
      *(void *)&long long v11 = *(void *)(v11 + 24);
      BOOL v3 = 0;
      if (!v12) {
        BOOL v3 = (void)v11 != 0;
      }
    }
    while (v3);
  }
  return v10;
}

uint64_t dispatch_queue_set_label_nocopy(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 8) != 0x7FFFFFFF)
  {
    if ((BYTE2(*(_DWORD *)(result + 80)) >> 5))
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change label for this queue";
      qword_F42C0 = result;
      __break(1u);
      JUMPOUT(0x24054);
    }
    *(void *)(result + 72) = a2;
  }
  return result;
}

uint64_t _dispatch_queue_compute_priority_and_wlh(uint64_t a1, uint64_t *a2)
{
  int v16 = *(_DWORD *)(a1 + 84);
  unsigned int v14 = v16 & 0xFFF;
  unsigned int v13 = (unsigned __int16)(v16 & 0xF000) >> 12;
  unint64_t v12 = *(void *)(a1 + 24);
  uint64_t v11 = -4;
  if ((*(void *)(a1 + 56) & 0x2000000000) != 0) {
    uint64_t v11 = a1;
  }
  while (1)
  {
    uint64_t v8 = 0;
    if (*(void *)v12) {
      uint64_t v8 = *(uint64_t (***)())v12;
    }
    if (((unint64_t)v8[2] & 0x10000) != 0)
    {
LABEL_40:
      BOOL v5 = 0;
      if (v12 >= (unint64_t)&_dispatch_root_queues) {
        BOOL v5 = v12 < (unint64_t)&qword_F0A80;
      }
      BOOL v4 = 1;
      if (!v5) {
        BOOL v4 = *(void *)(v12 + 64) == 22;
      }
      if (v4)
      {
        if (!v13) {
          unsigned int v13 = (*(_DWORD *)(v12 + 84) & 0xF000u) >> 12;
        }
        if (v14 < (*(_DWORD *)(v12 + 84) & 0xFFFu)) {
          unsigned int v14 = *(_DWORD *)(v12 + 84) & 0xFFF;
        }
        unsigned int v15 = v14 | *(_DWORD *)(v12 + 84) & 0x88000000;
        if ((v16 & 0x40000000) != 0 || (v16 & 0xFFF) == 0)
        {
          v15 |= v16 & 0x40000000;
          if (v13 > (unsigned __int16)(v15 & 0xF00) >> 8)
          {
            if (v13) {
              int v3 = (v13 << 12) & 0xF000 | 0x4000000;
            }
            else {
              int v3 = 0;
            }
            v15 |= v3;
          }
        }
        if (a2) {
          *a2 = v11;
        }
        return v15;
      }
      else
      {
        if (a2) {
          *a2 = -4;
        }
        return 0x2000000;
      }
    }
    if ((uint64_t (***)())v12 == &_dispatch_mgr_q)
    {
      if (a2) {
        *a2 = -4;
      }
      return 0x2000000;
    }
    BOOL v7 = 0;
    if ((*(_DWORD *)(v12 + 80) & 0x40000) != 0) {
      BOOL v7 = (*(_DWORD *)(v12 + 80) & 0x1000000) == 0;
    }
    if (v7)
    {
      if (a2) {
        *a2 = -4;
      }
      return *(unsigned int *)(v12 + 84);
    }
    if ((*(void *)(v12 + 56) & 0xFF80000000000000) != 0)
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      if (a2) {
        *a2 = 0;
      }
      return 0;
    }
    if ((*(void *)(v12 + 56) & 0x2000000000) == 0) {
      break;
    }
    uint64_t v11 = v12;
    uint64_t v6 = 0;
    if (*(void *)v12) {
      uint64_t v6 = *(uint64_t (***)())v12;
    }
    if (*((unsigned char *)v6 + 16) == 18) {
      atomic_fetch_and_explicit((atomic_uint *volatile)(a1 + 80), 0xFFBFFFFF, memory_order_relaxed);
    }
LABEL_34:
    int v9 = *(_DWORD *)(v12 + 84);
    unint64_t v12 = *(void *)(v12 + 24);
    if ((v9 & 0x20000000) != 0) {
      goto LABEL_40;
    }
    if (!v13) {
      unsigned int v13 = (unsigned __int16)(v9 & 0xF000) >> 12;
    }
    unsigned int v10 = v9 & 0xFFF;
    if (v14 < v10) {
      unsigned int v14 = v10;
    }
  }
  if ((*(_DWORD *)(v12 + 80) & 0x400000) == 0) {
    goto LABEL_34;
  }
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  if (a2) {
    *a2 = 0;
  }
  return 0;
}

void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
{
  uint64_t v5 = 0;
  if (*(void *)object) {
    uint64_t v5 = *(void *)object;
  }
  if ((*(void *)(v5 + 16) & 0xF0) != 0x10)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class_floor called on invalid object type";
    __break(1u);
    JUMPOUT(0x24B10);
  }
  uint64_t v4 = 0;
  if (*(void *)object) {
    uint64_t v4 = *(void *)object;
  }
  if (*(unsigned char *)(v4 + 16) == 18)
  {
    dispatch_workloop_set_qos_class_floor((uint64_t)object, qos_class, relative_priority, 0);
  }
  else
  {
    switch(qos_class)
    {
      case 5u:
        int v7 = 1;
        break;
      case 9u:
        int v7 = 2;
        break;
      case 0x11u:
        int v7 = 3;
        break;
      case 0x15u:
        int v7 = 4;
        break;
      case 0x19u:
        int v7 = 5;
        break;
      case 0x21u:
        int v7 = 6;
        break;
      default:
        int v7 = 0;
        break;
    }
    if (v7) {
      int v3 = (relative_priority - 1) | ((v7 & 0xF) << 8);
    }
    else {
      int v3 = 0;
    }
    int v6 = v3;
    if (v3) {
      int v6 = v3 | 0x40000000;
    }
    *((_DWORD *)object + 21) = v6 | *((_DWORD *)object + 21) & 0xBFFFF000;
    uint64_t v8 = *((void *)object + 7);
    if ((~v8 & 0x180000000000000) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
      qword_F42C0 = v8;
      __break(1u);
      JUMPOUT(0x24D78);
    }
  }
}

uint64_t dispatch_workloop_set_qos_class_floor(uint64_t a1, int a2, char a3, char a4)
{
  uint64_t v10 = *(void *)(a1 + 56);
  if ((~v10 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v10;
    __break(1u);
    JUMPOUT(0x24EB8);
  }
  if (!*(void *)(a1 + 200)) {
    *(void *)(a1 + 200) = _dispatch_calloc();
  }
  uint64_t result = (a2 - 5);
  switch(a2)
  {
    case 5:
      int v9 = 1;
      break;
    case 9:
      int v9 = 2;
      break;
    case 17:
      int v9 = 3;
      break;
    case 21:
      int v9 = 4;
      break;
    case 25:
      int v9 = 5;
      break;
    case 33:
      int v9 = 6;
      break;
    default:
      int v9 = 0;
      break;
  }
  if (v9)
  {
    *(_DWORD *)(*(void *)(a1 + 200) + 4) = (a3 - 1) | ((v9 & 0xF) << 8);
    **(_DWORD **)(a1 + 200) |= 8u;
  }
  else
  {
    *(_DWORD *)(*(void *)(a1 + 200) + 4) = 0;
    **(_DWORD **)(a1 + 200) &= ~8u;
  }
  if (a4)
  {
    *(_DWORD *)(*(void *)(a1 + 200) + 16) = 2;
    **(_DWORD **)(a1 + 200) |= 2u;
  }
  else
  {
    **(_DWORD **)(a1 + 200) &= ~2u;
  }
  return result;
}

uint64_t dispatch_set_qos_class(uint64_t *a1, int a2, char a3)
{
  uint64_t v6 = 0;
  if (*a1) {
    uint64_t v6 = *a1;
  }
  if ((*(void *)(v6 + 16) & 0xF0) != 0x10) {
    goto LABEL_7;
  }
  uint64_t v5 = 0;
  if (*a1) {
    uint64_t v5 = *a1;
  }
  if (*(unsigned char *)(v5 + 16) == 18)
  {
LABEL_7:
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class called on invalid object type";
    __break(1u);
    JUMPOUT(0x251FCLL);
  }
  uint64_t result = (a2 - 5);
  switch(a2)
  {
    case 5:
      int v8 = 1;
      break;
    case 9:
      int v8 = 2;
      break;
    case 17:
      int v8 = 3;
      break;
    case 21:
      int v8 = 4;
      break;
    case 25:
      int v8 = 5;
      break;
    case 33:
      int v8 = 6;
      break;
    default:
      int v8 = 0;
      break;
  }
  if (v8) {
    int v4 = (a3 - 1) | ((v8 & 0xF) << 8);
  }
  else {
    int v4 = 0;
  }
  *((_DWORD *)a1 + 21) = v4 | *((_DWORD *)a1 + 21) & 0xBFFFF000;
  uint64_t v9 = a1[7];
  if ((~v9 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v9;
    __break(1u);
    JUMPOUT(0x253CCLL);
  }
  return result;
}

uint64_t dispatch_set_qos_class_fallback(uint64_t *a1, int a2)
{
  uint64_t v4 = 0;
  if (*a1) {
    uint64_t v4 = *a1;
  }
  if ((*(void *)(v4 + 16) & 0xF0) != 0x10)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class_fallback called on invalid object type";
    __break(1u);
    JUMPOUT(0x254E4);
  }
  uint64_t result = (a2 - 5);
  switch(a2)
  {
    case 5:
      int v6 = 1;
      break;
    case 9:
      int v6 = 2;
      break;
    case 17:
      int v6 = 3;
      break;
    case 21:
      int v6 = 4;
      break;
    case 25:
      int v6 = 5;
      break;
    case 33:
      int v6 = 6;
      break;
    default:
      int v6 = 0;
      break;
  }
  if (v6) {
    int v3 = ((v6 & 0xF) << 12) | 0x4000000;
  }
  else {
    int v3 = 0;
  }
  *((_DWORD *)a1 + 21) = v3 | *((_DWORD *)a1 + 21) & 0xFBFF0FFF;
  uint64_t v7 = a1[7];
  if ((~v7 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v7;
    __break(1u);
    JUMPOUT(0x256ACLL);
  }
  return result;
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)_dispatch_lane_create_with_target(label, (uint64_t *)attr, (uint64_t (***)())target, 0);
}

uint64_t *_dispatch_lane_create_with_target(const char *a1, uint64_t *a2, uint64_t (***a3)(), char a4)
{
  unsigned int v41 = _dispatch_queue_attr_to_info(a2);
  unsigned int v40 = v41;
  int v39 = BYTE2(v41) & 3;
  if ((v41 & 0x30000) != 0 && a3 && a3[3])
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot specify both overcommit and a non-global target queue";
    qword_F42C0 = (uint64_t)a3;
    __break(1u);
    JUMPOUT(0x2582CLL);
  }
  if (!a3) {
    goto LABEL_17;
  }
  unint64_t v34 = 0;
  if (*a3) {
    unint64_t v34 = *a3;
  }
  if (v34[2] == (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    if ((v41 & 0x30000) == 0)
    {
      if ((*((unsigned char *)a3 + 87) & 0x80) != 0) {
        int v39 = 1;
      }
      else {
        int v39 = 2;
      }
    }
    if (!(_BYTE)v41) {
      unsigned int v40 = (*((_DWORD *)a3 + 21) & 0xF00u) >> 8;
    }
    a3 = 0;
  }
  else
  {
LABEL_17:
    if (a3 && (*((unsigned char *)a3 + 87) & 8) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target object to cooperative root queue - not implemented";
      qword_F42C0 = (uint64_t)a3;
      __break(1u);
      JUMPOUT(0x25990);
    }
    if (!a3 || a3[3])
    {
      if ((v41 & 0x30000) == 0)
      {
        if ((v41 >> 20)) {
          int v10 = 2;
        }
        else {
          int v10 = 1;
        }
        int v39 = v10;
      }
    }
    else if ((v41 & 0x30000) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot specify an overcommit attribute and use this kind of target queue";
      qword_F42C0 = (uint64_t)a3;
      __break(1u);
      JUMPOUT(0x259FCLL);
    }
  }
  if (!a3)
  {
    if (v40) {
      unsigned int v33 = v40;
    }
    else {
      unsigned int v33 = 4;
    }
    if (v33 > 6)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
      qword_F42C0 = v33;
      __break(1u);
      JUMPOUT(0x25B04);
    }
    int v45 = 0;
    if (((2 * (v39 == 1)) & 2) != 0)
    {
      int v45 = 1;
    }
    else if (((2 * (v39 == 1)) & 4) != 0)
    {
      int v45 = 2;
    }
    a3 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v33 + v45 - 3)];
    if (!a3)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue attribute";
      qword_F42C0 = v40;
      __break(1u);
      JUMPOUT(0x25BBCLL);
    }
  }
  if ((a4 & 1) != 0 && ((v41 & 0x200000) != 0 || ((v41 >> 18) & 3) != 0)) {
    a4 = 0;
  }
  if (a4) {
    int v11 = 0x400000;
  }
  else {
    int v11 = 0;
  }
  int v37 = v11;
  if ((v41 & 0x100000) != 0) {
    uint64_t v38 = _OS_dispatch_queue_concurrent_vtable;
  }
  else {
    uint64_t v38 = _OS_dispatch_queue_serial_vtable;
  }
  int v32 = (v41 >> 18) & 3;
  if (v32 == 1)
  {
    int v37 = v11 | 0x10000;
  }
  else if (v32 == 2)
  {
    int v37 = v11 | 0x20000;
  }
  if (a1)
  {
    uint64_t v36 = _dispatch_strdup_if_mutable(a1);
    if (v36 != a1)
    {
      v37 |= 0x200000u;
      a1 = v36;
    }
  }
  uint64_t v35 = _dispatch_object_alloc((uint64_t)v38, 0x78uLL, v4, v5, v6, v7, v8, v9);
  if ((v41 >> 21)) {
    uint64_t v16 = 0x180000000000000;
  }
  else {
    uint64_t v16 = 0;
  }
  if ((v41 >> 20)) {
    uint64_t v17 = 4094;
  }
  else {
    uint64_t v17 = 1;
  }
  _dispatch_queue_init(v35, v37, v17, v16, v12, v13, v14, v15);
  v35[9] = (uint64_t)a1;
  if ((_BYTE)v41) {
    int v31 = (BYTE1(v41) - 1) | ((v41 & 0xF) << 8);
  }
  else {
    int v31 = 0;
  }
  *((_DWORD *)v35 + 21) = v31;
  if (v39 == 1) {
    *((_DWORD *)v35 + 21) |= 0x80000000;
  }
  if ((v41 & 0x200000) == 0)
  {
    _dispatch_queue_priority_inherit_from_target((uint64_t)v35, (unint64_t)a3);
    _dispatch_lane_inherit_wlh_from_target((uint64_t)v35, (unint64_t)a3, v18, v19, v20, v21, v22, v23);
  }
  _dispatch_retain((uint64_t)a3);
  v35[3] = (uint64_t)a3;
  _dispatch_object_debug(v35, "%s", v24, v25, v26, v27, v28, v29, (char)"_dispatch_lane_create_with_target");
  return v35;
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)_dispatch_lane_create_with_target(label, (uint64_t *)attr, 0, 1);
}

void dispatch_queue_create_with_accounting_override_voucher()
{
  qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unsupported interface";
  __break(1u);
}

uint64_t sub_25EE0()
{
  return v1;
}

void _dispatch_lane_class_dispose(uint64_t a1, unsigned char *a2)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v2 = *(void *)(a1 + 48);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a queue while items are enqueued";
    qword_F42C0 = v2;
    __break(1u);
    JUMPOUT(0x25F68);
  }
  *(void *)(a1 + 104) = 512;
  *(void *)(a1 + 48) = 512;
  uint64_t v5 = *(void *)(a1 + 56);
  unint64_t v4 = (unint64_t)(4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  uint64_t v3 = 0;
  if (*(void *)a1) {
    uint64_t v3 = *(void *)a1;
  }
  if (*(unsigned char *)(v3 + 18)) {
    unint64_t v4 = 0x60000000000000;
  }
  if ((*(void *)(a1 + 56) & 0xFFFFFF48FFFFFFFFLL) != v4)
  {
    if ((*(_DWORD *)(a1 + 56) & 0xFFFFFFFC) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Premature release of a locked queue";
      qword_F42C0 = v5;
      __break(1u);
      JUMPOUT(0x260D8);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a queue with corrupt state";
    qword_F42C0 = v5;
    __break(1u);
    JUMPOUT(0x2611CLL);
  }
  _dispatch_queue_dispose(a1, a2);
}

void _dispatch_queue_dispose(uint64_t a1, unsigned char *a2)
{
  if (*(void *)(a1 + 72) && (*(_DWORD *)(a1 + 80) & 0x200000) != 0) {
    free(*(void **)(a1 + 72));
  }
  uint64_t v3 = (void *)__swp(0x200u, (unsigned int *)(a1 + 88));
  if (v3) {
    _dispatch_queue_specific_head_dispose(v3);
  }
  if (*(_DWORD *)(a1 + 96))
  {
    _dispatch_object_finalize();
    *a2 = 0;
    *(void *)(a1 + 72) = "<released queue, pending free>";
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 32) = 0;
    signed int v5 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 96), 0xFFFFFFFF, memory_order_relaxed) - 1;
    if (v5 < 0)
    {
      if (v5 <= -2)
      {
        qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x2639CLL);
      }
      *(void *)(a1 + 56) = 0xDEAD000000000000;
      _dispatch_object_dealloc((void *)a1);
    }
  }
  else
  {
    *(void *)(a1 + 56) = 0xDEAD000000000000;
  }
}

void _dispatch_lane_dispose(uint64_t *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

uint64_t _dispatch_queue_xref_dispose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 56);
  if ((v1 & 0xFF80000000000000) != 0)
  {
    if ((v1 & 0x180000000000000) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of an inactive object";
      qword_F42C0 = v1;
      __break(1u);
      JUMPOUT(0x2656CLL);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a suspended object";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0x265B0);
  }
  atomic_fetch_or_explicit((atomic_uint *volatile)(result + 80), 0x800000u, memory_order_relaxed);
  return result;
}

uint64_t _dispatch_lane_suspend(uint64_t result)
{
  for (unint64_t i = *(void *)(result + 56); ; unint64_t i = v2)
  {
    if (i >= 0xFC00000000000000) {
      return _dispatch_lane_suspend_slow(result);
    }
    unint64_t v1 = i;
    unint64_t v2 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(result + 56), &v2, i + 0x400000000000000, memory_order_relaxed, memory_order_relaxed);
    if (v2 == v1) {
      break;
    }
  }
  if ((i & 0xFF80000000000000) == 0) {
    return _dispatch_retain_2(result);
  }
  return result;
}

uint64_t _dispatch_lane_suspend_slow(uint64_t a1)
{
  int v11 = (atomic_uint *)(a1 + 100);
  unsigned int v10 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v1 = 0;
  atomic_compare_exchange_strong_explicit(v11, (unsigned int *)&v1, v10, memory_order_acquire, memory_order_acquire);
  if (v1) {
    _dispatch_unfair_lock_lock_slow(v11);
  }
  unint64_t v7 = 0x7C00000000000000;
  if (!*(_DWORD *)(a1 + 112)) {
    unint64_t v7 = 0x7A00000000000000;
  }
  for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v3)
  {
    if (i < v7)
    {
      uint64_t v16 = (atomic_uint *)(a1 + 100);
      unsigned int v6 = _dispatch_thread_getspecific(3uLL);
      unsigned int v15 = atomic_exchange_explicit(v16, 0, memory_order_release);
      if (v15 == (v6 & 0xFFFFFFFC))
      {
        BOOL v17 = 0;
      }
      else
      {
        _dispatch_unfair_lock_unlock_slow((uint64_t)v16, v15);
        BOOL v17 = (v15 & 2) != 0;
      }
      if (v17)
      {
        unsigned int v12 = _dispatch_thread_getspecific(0x19uLL);
        if (!((v12 & 0xF0000) >> 16)) {
          _dispatch_thread_setspecific(25, v12 & 0xFFF0FFFF | 0x10000);
        }
      }
      return _dispatch_lane_suspend(a1);
    }
    unint64_t v2 = i;
    unint64_t v3 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v3, i - v7, memory_order_relaxed, memory_order_relaxed);
    if (v3 == v2) {
      break;
    }
  }
  unsigned int v4 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a1 + 112) = v4 + 32;
  if (v4 >= 0xFFFFFFE0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many nested calls to dispatch_suspend()";
    __break(1u);
    JUMPOUT(0x269F4);
  }
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  unsigned int v13 = atomic_exchange_explicit((atomic_uint *volatile)(a1 + 100), 0, memory_order_release);
  if (v13 == (result & 0xFFFFFFFC))
  {
    BOOL v14 = 0;
  }
  else
  {
    uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v13);
    BOOL v14 = (v13 & 2) != 0;
  }
  if (v14)
  {
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
    if (!((result & 0xF0000) >> 16)) {
      return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
    }
  }
  return result;
}

void _dispatch_lane_resume(uint64_t a1, int a2)
{
  unint64_t v17 = (unint64_t)(*(unsigned __int16 *)(a1 + 80) - 1) << 41;
  unint64_t v16 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002;
  uint64_t v9 = 0;
  if (*(void *)a1) {
    uint64_t v9 = *(void *)a1;
  }
  BOOL v15 = *(unsigned char *)(v9 + 16) == 19;
  if (a2 == 1)
  {
    for (unint64_t i = *(void *)(a1 + 56); (~i & 0x180000000000000) == 0; unint64_t i = v3)
    {
      if (i >> 58) {
        unint64_t v11 = i - 0x80000000000000;
      }
      else {
        unint64_t v11 = i - 0x100000000000000;
      }
      unint64_t v2 = i;
      unint64_t v3 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v3, v11, memory_order_relaxed, memory_order_relaxed);
      if (v3 == v2) {
        goto LABEL_45;
      }
    }
  }
  else
  {
    if (a2 != 2)
    {
      for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v7)
      {
        if (v15 && i >> 55 == 3)
        {
          unint64_t v11 = i - 0x100000000000000;
        }
        else
        {
          unint64_t v13 = i - 0x400000000000000;
          if (i < 0x400000000000000)
          {
            if ((i & 0x200000000000000) == 0)
            {
              if ((~i & 0x180000000000000) == 0)
              {
                qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Over-resume of an inactive object";
                qword_F42C0 = a1;
                __break(1u);
                JUMPOUT(0x2752CLL);
              }
              qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Over-resume of an object";
              qword_F42C0 = a1;
              __break(1u);
              JUMPOUT(0x27570);
            }
            _dispatch_lane_resume_slow(a1);
            return;
          }
          if ((v13 & 0x180000000000000) == 0x100000000000000)
          {
            unint64_t v11 = i - 0x480000000000000;
          }
          else if (v13 >> 53)
          {
            unint64_t v11 = v13 | 0x8000000000;
          }
          else if ((i & 0xFFFFFFFC) != 0)
          {
            unint64_t v11 = v13 | 0x8000000000;
          }
          else if (v15 || (v13 & 0x10000000000) == 0 && (v13 + v17) >> 53)
          {
            unint64_t v11 = v13 & 0xFFFFFFF000000001;
          }
          else
          {
            unint64_t v11 = v13 & 0x7700000001 | v16;
          }
        }
        unint64_t v6 = i;
        unint64_t v7 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v7, v11, memory_order_release, memory_order_relaxed);
        if (v7 == v6) {
          goto LABEL_45;
        }
      }
    }
    for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v5)
    {
      if ((i & 0x180000000000000) == 0)
      {
        _dispatch_release_2_tailcall(a1);
        return;
      }
      unint64_t v12 = i - 0x80000000000000;
      if ((i - 0x80000000000000) >> 53) {
        unint64_t v11 = v12 | 0x8000000000;
      }
      else {
        unint64_t v11 = (i & 0xFFFFFFFC) != 0 ? v12 | 0x8000000000 : v12 & 0xFFFFFFF000000001;
      }
      unint64_t v4 = i;
      unint64_t v5 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v5, v11, memory_order_release, memory_order_relaxed);
      if (v5 == v4) {
        break;
      }
    }
    if ((v11 & 0x180000000000000) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt activation state";
      qword_F42C0 = a1;
      __break(1u);
      JUMPOUT(0x270B4);
    }
LABEL_45:
    if ((v11 & 0x180000000000000) == 0x80000000000000)
    {
      _dispatch_lane_resume_activate((uint64_t *)a1);
      return;
    }
    if ((v11 & 0xFF80000000000000) == 0)
    {
      unsigned int v10 = 1;
      if (((i ^ v11) & 0x40000000000000) != 0)
      {
        unsigned int v10 = 5;
      }
      else if (v11 >> 53)
      {
        if ((i & 0x2000000000) != 0) {
          _dispatch_event_loop_assert_not_owned(a1);
        }
        _dispatch_release_2(a1);
        return;
      }
      uint64_t v8 = 0;
      if (*(void *)a1) {
        uint64_t v8 = *(void *)a1;
      }
      (*(void (**)(uint64_t, unint64_t, void))(v8 + 64))(a1, (i & 0x700000000) >> 32, v10);
    }
  }
}

void _dispatch_release_2_tailcall(uint64_t a1)
{
}

uint64_t _dispatch_lane_resume_slow(uint64_t a1)
{
  unint64_t v11 = (atomic_uint *)(a1 + 100);
  unsigned int v10 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v1 = 0;
  atomic_compare_exchange_strong_explicit(v11, (unsigned int *)&v1, v10, memory_order_acquire, memory_order_acquire);
  if (v1) {
    _dispatch_unfair_lock_lock_slow(v11);
  }
  uint64_t v7 = 0x7C00000000000000;
  int v6 = *(_DWORD *)(a1 + 112);
  if (v6)
  {
    if (v6 == 32) {
      uint64_t v7 = 0x7A00000000000000;
    }
    for (uint64_t i = *(void *)(a1 + 56); !__CFADD__(i, v7); uint64_t i = v4)
    {
      uint64_t v3 = i;
      uint64_t v4 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v4, i + v7, memory_order_relaxed, memory_order_relaxed);
      if (v4 == v3)
      {
        *(_DWORD *)(a1 + 112) -= 32;
        uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
        unsigned int v13 = atomic_exchange_explicit((atomic_uint *volatile)(a1 + 100), 0, memory_order_release);
        if (v13 == (result & 0xFFFFFFFC))
        {
          BOOL v14 = 0;
        }
        else
        {
          uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v13);
          BOOL v14 = (v13 & 2) != 0;
        }
        if (v14)
        {
          uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
          if (!((result & 0xF0000) >> 16)) {
            return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
          }
        }
        return result;
      }
    }
  }
  unsigned int v15 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  unsigned int v16 = atomic_exchange_explicit((atomic_uint *volatile)(a1 + 100), 0, memory_order_release);
  if (v16 == v15)
  {
    BOOL v17 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow(a1 + 100, v16);
    BOOL v17 = (v16 & 2) != 0;
  }
  if (v17)
  {
    unsigned int v12 = _dispatch_thread_getspecific(0x19uLL);
    if (!((v12 & 0xF0000) >> 16)) {
      _dispatch_thread_setspecific(25, v12 & 0xFFF0FFFF | 0x10000);
    }
  }
  return _dispatch_lane_resume(a1, 0);
}

uint64_t _dispatch_lane_resume_activate(uint64_t *a1)
{
  uint64_t v4 = 0;
  if (*a1) {
    uint64_t v4 = *a1;
  }
  uint64_t v3 = 0;
  if (*(void *)(v4 + 56)) {
    uint64_t v3 = *(void *)(v4 + 56);
  }
  if (v3)
  {
    uint64_t v2 = 0;
    if (*a1) {
      uint64_t v2 = *a1;
    }
    (*(void (**)(uint64_t *))(v2 + 56))(a1);
  }
  return _dispatch_lane_resume(a1, 2);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  dispatch_queue_t v5 = queue;
  if (!queue)
  {
    uint64_t v4 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
    if (v4) {
      uint64_t v3 = v4;
    }
    else {
      uint64_t v3 = &off_F0680;
    }
    dispatch_queue_t v5 = (dispatch_queue_t)v3;
  }
  if (*((void *)v5 + 9)) {
    return (const char *)*((void *)v5 + 9);
  }
  else {
    return "";
  }
}

dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *relative_priority_ptr)
{
  unsigned int v6 = (*((_DWORD *)queue + 21) & 0xF00u) >> 8;
  if (relative_priority_ptr)
  {
    if (v6)
    {
      int v7 = *((_DWORD *)queue + 21);
      if ((v7 & 0xF00) != 0) {
        int v8 = (char)v7 + 1;
      }
      else {
        int v8 = 0;
      }
      int v5 = v8;
    }
    else
    {
      int v5 = 0;
    }
    *relative_priority_ptr = v5;
  }
  if (v6 <= 1)
  {
    uint64_t v3 = v6 - 1;
    char v2 = 0;
  }
  else
  {
    uint64_t v3 = v6 - 1;
    char v2 = 1;
  }
  if (v2) {
    return 0;
  }
  switch(v3)
  {
    case 0:
      dispatch_qos_class_t v9 = 5;
      break;
    case 1:
      dispatch_qos_class_t v9 = QOS_CLASS_BACKGROUND;
      break;
    case 2:
      dispatch_qos_class_t v9 = QOS_CLASS_UTILITY;
      break;
    case 3:
      dispatch_qos_class_t v9 = QOS_CLASS_DEFAULT;
      break;
    case 4:
      dispatch_qos_class_t v9 = QOS_CLASS_USER_INITIATED;
      break;
    case 5:
      dispatch_qos_class_t v9 = QOS_CLASS_USER_INTERACTIVE;
      break;
    default:
      JUMPOUT(0);
  }
  return v9;
}

uint64_t dispatch_queue_set_width(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = 0;
  if (*a1) {
    uint64_t v4 = *a1;
  }
  uint64_t v5 = *(void *)(v4 + 16);
  uint64_t v3 = 0;
  if (*a1) {
    uint64_t v3 = *a1;
  }
  if (*(unsigned char *)(v3 + 16) != 17)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected dispatch object type";
    qword_F42C0 = v5;
    __break(1u);
    JUMPOUT(0x28004);
  }
  if (v5 != 529)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot set width of a serial queue";
    qword_F42C0 = v5;
    __break(1u);
    JUMPOUT(0x28058);
  }
  if ((a2 & 0x80000000) != 0) {
    return _dispatch_barrier_async_detached_f(a1, a2, (uint64_t)_dispatch_lane_set_width);
  }
  else {
    return _dispatch_barrier_trysync_or_async_f((uint64_t)a1, a2, (uint64_t (*)(uint64_t))_dispatch_lane_set_width, 1u);
  }
}

void _dispatch_lane_set_width(int a1)
{
  uint64_t v27 = (char *)_dispatch_thread_getspecific(0x14uLL);
  if (a1 >= 0)
  {
    if (a1) {
      int v25 = a1;
    }
    else {
      int v25 = 1;
    }
    unsigned int v28 = v25;
    goto LABEL_47;
  }
  int v7 = _dispatch_thread_getspecific(4uLL);
  unsigned int v8 = 0;
  unsigned int v9 = (v7 & 0x3FFF00) >> 8;
  unsigned int v10 = __clz(__rbit32(v9));
  if (v9) {
    unsigned int v8 = v10 + 1;
  }
  switch(a1)
  {
    case -3:
      goto LABEL_36;
    case -2:
      int v34 = 0;
      if (v8)
      {
        if (v8 <= 1)
        {
          uint64_t v12 = v8 - 1;
          char v11 = 0;
        }
        else
        {
          uint64_t v12 = v8 - 1;
          char v11 = 1;
        }
        if ((v11 & 1) == 0)
        {
          switch(v12)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
LABEL_53:
              JUMPOUT(0);
          }
        }
        int v34 = pthread_qos_max_parallelism();
      }
      if (v34 <= 0) {
        int v35 = MEMORY[0xFFFFFC035];
      }
      else {
        int v35 = v34;
      }
      unsigned int v28 = v35;
      break;
    case -1:
      int v32 = 0;
      if (v8)
      {
        if (v8 <= 1)
        {
          uint64_t v14 = v8 - 1;
          char v13 = 0;
        }
        else
        {
          uint64_t v14 = v8 - 1;
          char v13 = 1;
        }
        if ((v13 & 1) == 0)
        {
          switch(v14)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              goto LABEL_53;
          }
        }
        int v32 = pthread_qos_max_parallelism();
      }
      if (v32 <= 0) {
        unsigned int v33 = MEMORY[0xFFFFFC036];
      }
      else {
        unsigned int v33 = v32;
      }
      if (MEMORY[0xFFFFFC034] < v33) {
        unsigned int v33 = MEMORY[0xFFFFFC034];
      }
      unsigned int v28 = v33;
      break;
    default:
LABEL_36:
      int v30 = 0;
      if (v8)
      {
        if (v8 <= 1)
        {
          uint64_t v16 = v8 - 1;
          char v15 = 0;
        }
        else
        {
          uint64_t v16 = v8 - 1;
          char v15 = 1;
        }
        if ((v15 & 1) == 0)
        {
          switch(v16)
          {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              goto LABEL_53;
          }
        }
        int v30 = pthread_qos_max_parallelism();
      }
      if (v30 <= 0) {
        int v31 = MEMORY[0xFFFFFC036];
      }
      else {
        int v31 = v30;
      }
      unsigned int v28 = v31;
      break;
  }
LABEL_47:
  if (v28 > 0xFFEuLL) {
    LOWORD(v28) = 4094;
  }
  for (int i = *((_DWORD *)v27 + 20); ; int i = v18)
  {
    int v17 = i;
    int v18 = i;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v27 + 80), (unsigned int *)&v18, i & 0xFFFF0000 | (unsigned __int16)v28, memory_order_relaxed, memory_order_relaxed);
    if (v18 == v17) {
      break;
    }
  }
  _dispatch_lane_inherit_wlh_from_target((uint64_t)v27, *((void *)v27 + 3), v1, v2, v3, v4, v5, v6);
  _dispatch_object_debug((uint64_t *)v27, "%s", v19, v20, v21, v22, v23, v24, (char)"_dispatch_lane_set_width");
}

void _dispatch_lane_set_target_queue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v13 = (uint64_t (***)())a2;
  if (!a2) {
    char v13 = &(&_dispatch_root_queues)[16 * (unint64_t)((*(_WORD *)(a1 + 80) == 1) + 9)];
  }
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v9)
  {
    if ((~i & 0x180000000000000) != 0)
    {
      char v16 = 0;
      goto LABEL_13;
    }
    uint64_t v8 = i;
    uint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, i + 0x400000000000000, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  LOBYTE(v11) = 1;
  if ((i & 0xFF80000000000000) != 0) {
    int v11 = (HIBYTE(i) >> 1) & 1;
  }
  if (v11)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many calls to dispatch_suspend() prior to calling dispatch_"
                           "set_target_queue() or dispatch_set_*_handler()";
    __break(1u);
    JUMPOUT(0x29364);
  }
  char v16 = 1;
LABEL_13:
  if (v16 == 1)
  {
    _dispatch_retain((uint64_t)v13);
    uint64_t v17 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 24), (unint64_t)v13, memory_order_release);
    if (v17) {
      _dispatch_release(v17);
    }
    _dispatch_lane_resume(a1, 0);
  }
  else
  {
    if (((BYTE2(*(_DWORD *)(a1 + 80)) >> 6) & 1) == 0)
    {
      if ((*(_DWORD *)(a1 + 80) & 0x100000) != 0)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of a queue already targeted by oth"
                               "er dispatch objects";
        __break(1u);
        JUMPOUT(0x294DCLL);
      }
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of this object after it has been activated";
      __break(1u);
      JUMPOUT(0x29508);
    }
    uint64_t v10 = 0;
    if (*(void *)a1) {
      uint64_t v10 = *(void *)a1;
    }
    uint64_t v12 = *(unsigned __int8 *)(v10 + 16);
    if (v12 == 17)
    {
      if ((*(_DWORD *)(a1 + 80) & 0x100000) != 0) {
        _dispatch_bug_deprecated((uint64_t)"Changing the target of a queue already targeted by other dispatch objects", a2, a3, a4, a5, a6, a7, a8);
      }
    }
    else
    {
      if (*(unsigned char *)(v10 + 16) != 19)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected dispatch object type";
        qword_F42C0 = v12;
        __break(1u);
        JUMPOUT(0x296A0);
      }
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      _dispatch_bug_deprecated((uint64_t)"Changing the target of a source after it has been activated", a2, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_retain((uint64_t)v13);
    _dispatch_barrier_trysync_or_async_f(a1, (uint64_t)v13, (uint64_t (*)(uint64_t))_dispatch_lane_legacy_set_target_queue, 1u);
  }
}

void _dispatch_lane_legacy_set_target_queue(unint64_t a1)
{
  uint64_t v23 = (char *)_dispatch_thread_getspecific(0x14uLL);
  uint64_t v21 = *((void *)v23 + 3);
  if ((*((_DWORD *)v23 + 20) & 0x100000) != 0)
  {
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_bug_deprecated((uint64_t)"Changing the target of a queue already targeted by other dispatch objects", v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v22 = _dispatch_queue_priority_inherit_from_target((uint64_t)v23, a1);
  _dispatch_lane_inherit_wlh_from_target((uint64_t)v23, (unint64_t)v22, v8, v9, v10, v11, v12, v13);
  unsigned int v25 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v14 = 0;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v23 + 100), (unsigned int *)&v14, v25, memory_order_acquire, memory_order_acquire);
  if (v14) {
    _dispatch_unfair_lock_lock_slow((atomic_uint *)(v23 + 100));
  }
  if (((BYTE2(*((_DWORD *)v23 + 20)) >> 6) & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of this object after it has been activated";
    __break(1u);
    JUMPOUT(0x299A0);
  }
  *((void *)v23 + 3) = v22;
  unsigned int v27 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  unsigned int v28 = atomic_exchange_explicit((atomic_uint *volatile)(v23 + 100), 0, memory_order_release);
  if (v28 == v27)
  {
    BOOL v29 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)(v23 + 100), v28);
    BOOL v29 = (v28 & 2) != 0;
  }
  if (v29)
  {
    unsigned int v26 = _dispatch_thread_getspecific(0x19uLL);
    if (!((v26 & 0xF0000) >> 16)) {
      _dispatch_thread_setspecific(25, v26 & 0xFFF0FFFF | 0x10000);
    }
  }
  _dispatch_object_debug((uint64_t *)v23, "%s", v15, v16, v17, v18, v19, v20, (char)"_dispatch_lane_legacy_set_target_queue");
  _dispatch_release_tailcall(v21);
}

void _dispatch_poll_for_events_4launchd()
{
  _dispatch_return_to_kernel();
}

void _dispatch_return_to_kernel()
{
  uint64_t v7 = _dispatch_thread_getspecific(0x1DuLL);
  BOOL v6 = 0;
  if (v7) {
    BOOL v6 = v7[3] != -4;
  }
  if (v6)
  {
    if ((*((unsigned char *)v7 + 45) & 4) == 0) {
      _dispatch_abort(3612, (*((unsigned char *)v7 + 45) & 4) != 0, v0, v1, v2, v3, v4, v5);
    }
    _dispatch_event_loop_drain(1u);
  }
  else
  {
    _dispatch_thread_setspecific(5, 0);
  }
}

BOOL dispatch_swift_job_should_yield()
{
  return _dispatch_thread_getspecific(0x78uLL) != 0;
}

uint64_t _dispatch_lane_serial_drain(uint64_t *a1, uint64_t a2, int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v44 = a1;
  uint64_t v43 = a2;
  unsigned int v42 = a3 & 0xFFFDFFFF;
  unsigned int v41 = a4;
  char v40 = 1;
  uint64_t v39 = 0;
  uint64_t v39 = a1[3];
  long long v38 = 0uLL;
  uint64_t v34 = *a4;
  if (!a1[6]) {
    return 0;
  }
  v156 = v44;
  v155 = &v38;
  v160 = &v38;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v38, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v156, 21, (uint64_t)v155, v8, v9, v10, v11);
  if ((v40 & 1) != 0 || (uint64_t v46 = v34, (v34 & 0x40000000000000) != 0)) {
    uint64_t v35 = 0x40000000000000;
  }
  else {
    uint64_t v35 = v34 & 0x3FFE0000000000;
  }
  unint64_t v89 = v44;
  int v88 = (unint64_t *)(v44 + 13);
  uint64_t v87 = 0;
  uint64_t v86 = 0;
  uint64_t v85 = v44[13];
  uint64_t v86 = v85;
  uint64_t v84 = v85;
  uint64_t v87 = v85;
  if (!v85) {
    uint64_t v87 = _dispatch_wait_for_enqueuer(v88);
  }
  uint64_t v83 = v87;
  int v37 = (void *)v87;
  while (1)
  {
    uint64_t v47 = v44[7];
    if ((v47 & 0xFF80000000000000) != 0 || v39 != v44[3]) {
      break;
    }
    if (v40) {
      goto LABEL_37;
    }
    uint64_t v62 = v37;
    int v61 = 0;
    unsigned int v152 = v37;
    if (*v37 > 0xFFFuLL)
    {
      uint64_t v32 = 0;
      if (*v62) {
        uint64_t v32 = *v62;
      }
      if ((*(void *)(v32 + 16) & 0xF0) == 0x10)
      {
        int v60 = 0;
        int v59 = *((_DWORD *)v62 + 20);
        int v60 = v59;
        int v58 = v59;
        int v61 = v59;
        BOOL v63 = (v59 & 0x80000) != 0;
      }
      else
      {
        BOOL v63 = 0;
      }
    }
    else
    {
      BOOL v63 = (*(_DWORD *)v62 & 2) != 0;
    }
    if (v63)
    {
LABEL_37:
      if ((v40 & 1) == 0 && v35 != 0x40000000000000)
      {
        v172 = v44;
        uint64_t v171 = v35;
        uint64_t v170 = 0;
        unint64_t v169 = 0;
        unint64_t v168 = 0;
        unint64_t v168 = ((unint64_t)(*((unsigned __int16 *)v44 + 40) - 1) << 41) | 0x10000000000;
        BOOL v167 = 0;
        v166 = (atomic_ullong *)(v44 + 7);
        uint64_t v170 = v44[7];
        do
        {
          unint64_t v169 = v170 - v171;
          uint64_t v174 = v170;
          if ((v170 & 0x10000000000) == 0) {
            v169 += v168;
          }
          unint64_t v173 = v169;
          if (!(v169 >> 53))
          {
            v169 += 0x20000000000;
            v169 += 0x40000000000000;
            v169 -= 0x10000000000;
          }
          v169 &= ~0x8000000000uLL;
          unint64_t v165 = v169;
          uint64_t v19 = v170;
          uint64_t v20 = v170;
          atomic_compare_exchange_strong_explicit(v166, (unint64_t *)&v20, v169, memory_order_acquire, memory_order_acquire);
          if (v20 != v19) {
            uint64_t v170 = v20;
          }
          BOOL v164 = v20 == v19;
          BOOL v167 = v20 == v19;
        }
        while (v20 != v19);
        BOOL v163 = v167;
        if ((v169 & 0x40000000000000) == 0) {
          goto LABEL_122;
        }
        uint64_t v35 = 0x40000000000000;
      }
      v175 = v37;
      v177 = v37;
      if (*v37 >= 0x1000uLL) {
        char v176 = 0;
      }
      else {
        char v176 = *v175 & 1;
      }
      if (v176 == 1 && (v42 & 0x80000) == 0)
      {
        *(void *)(v43 + 8) = v37;
        if ((v42 & 8) != 0)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Deferred continuation on source, mach channel or mgr";
          __break(1u);
          JUMPOUT(0x2AF5CLL);
        }
        v157 = &v38;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v38, v13, v14, v15, v16, v17);
        return v44[3];
      }
      uint64_t v119 = v44;
      unsigned int v118 = v37;
      unint64_t v117 = v37;
      uint64_t v116 = 0;
      uint64_t v115 = 0;
      uint64_t v114 = 0;
      uint64_t v113 = 0;
      uint64_t v112 = v37[2];
      uint64_t v113 = v112;
      uint64_t v111 = v112;
      uint64_t v116 = v112;
      uint64_t v110 = v112;
      uint64_t v109 = v112;
      v44[13] = v112;
      uint64_t v108 = v110;
      if (!v116)
      {
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        uint64_t v107 = v119 + 6;
        BOOL v104 = 0;
        unint64_t v103 = (atomic_ullong *)(v119 + 6);
        uint64_t v114 = v119[6];
        while (1)
        {
          uint64_t v151 = v114;
          if (v117 != (void *)(v114 & 0xFFFFFFFFFFFFFFF8)) {
            break;
          }
          uint64_t v115 = 0;
          uint64_t v93 = 0;
          uint64_t v21 = v114;
          uint64_t v22 = v114;
          atomic_compare_exchange_strong_explicit(v103, (unint64_t *)&v22, 0, memory_order_release, memory_order_relaxed);
          if (v22 != v21) {
            uint64_t v114 = v22;
          }
          BOOL v92 = v22 == v21;
          BOOL v104 = v22 == v21;
          if (v22 == v21) {
            goto LABEL_64;
          }
        }
        uint64_t v102 = v117;
        uint64_t v101 = 0;
        uint64_t v100 = 0;
        uint64_t v99 = v117[2];
        uint64_t v100 = v99;
        uint64_t v98 = v99;
        uint64_t v101 = v99;
        if (!v99) {
          uint64_t v101 = _dispatch_wait_for_enqueuer(v102 + 2);
        }
        uint64_t v97 = v101;
        uint64_t v116 = v101;
        uint64_t v96 = v101;
        uint64_t v95 = v101;
        v119[13] = v101;
        uint64_t v94 = v96;
LABEL_64:
        BOOL v91 = v104;
      }
      uint64_t v90 = v116;
      uint64_t v36 = (void *)v116;
LABEL_103:
      _dispatch_continuation_pop_inline(v37, v43, v42, (uint64_t)v44);
      goto LABEL_10;
    }
    if (v35 == 0x40000000000000)
    {
      atomic_fetch_xor_explicit((atomic_ullong *volatile)(v44 + 7), 0x40000000000000uLL, memory_order_release);
      uint64_t v35 = (unint64_t)*((unsigned __int16 *)v44 + 40) << 41;
    }
    else if (!v35)
    {
      uint64_t v54 = v37;
      v154 = v37;
      if (*v37 < 0x1000uLL && (*v54 & 0x81) != 0)
      {
        v188 = v44;
        uint64_t v186 = 0x20000000000;
        uint64_t v185 = 0x20000000000;
        uint64_t v187 = 0x20000000000;
        unint64_t v183 = 0;
        uint64_t v181 = 0x20000000000;
        uint64_t v180 = 0x20000000000;
        uint64_t v182 = 0x20000000000;
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 7), 0x20000000000uLL, memory_order_relaxed);
        unint64_t v183 = add_explicit;
        unint64_t v178 = add_explicit;
        unint64_t v184 = add_explicit + v187;
      }
      else
      {
        uint64_t v71 = v44;
        unint64_t v70 = 0;
        unint64_t v69 = 0;
        BOOL v68 = 0;
        uint64_t v67 = (atomic_ullong *)(v44 + 7);
        unint64_t v70 = v44[7];
        do
        {
          unint64_t v73 = v70;
          char v31 = 1;
          if (!(v70 >> 53))
          {
            unint64_t v75 = v70;
            char v31 = 1;
            if ((v70 & 0x8000000000) == 0)
            {
              unint64_t v74 = v70;
              char v31 = BYTE5(v70) & 1;
            }
          }
          if (v31)
          {
            BOOL v72 = 0;
            goto LABEL_84;
          }
          unint64_t v69 = v70 + 0x20000000000;
          unint64_t v66 = v70 + 0x20000000000;
          unint64_t v23 = v70;
          unint64_t v24 = v70;
          atomic_compare_exchange_strong_explicit(v67, &v24, v70 + 0x20000000000, memory_order_acquire, memory_order_acquire);
          if (v24 != v23) {
            unint64_t v70 = v24;
          }
          BOOL v65 = v24 == v23;
          BOOL v68 = v24 == v23;
        }
        while (v24 != v23);
        BOOL v64 = v68;
        BOOL v72 = v68;
LABEL_84:
        if (!v72)
        {
LABEL_122:
          *v41 &= 0x4000000001uLL;
          v158 = &v38;
          _dispatch_thread_setspecific_packed_pair(20, 21, &v38, v13, v14, v15, v16, v17);
          return -1;
        }
      }
      uint64_t v35 = 0x20000000000;
    }
    unsigned int v149 = v44;
    v148 = v37;
    uint64_t v147 = v37;
    uint64_t v146 = 0;
    uint64_t v145 = 0;
    uint64_t v144 = 0;
    uint64_t v143 = 0;
    uint64_t v142 = v37[2];
    uint64_t v143 = v142;
    uint64_t v141 = v142;
    uint64_t v146 = v142;
    uint64_t v140 = v142;
    uint64_t v139 = v142;
    v44[13] = v142;
    uint64_t v138 = v140;
    if (!v146)
    {
      uint64_t v135 = 0;
      uint64_t v136 = 0;
      unsigned int v137 = v149 + 6;
      BOOL v134 = 0;
      unsigned int v133 = (atomic_ullong *)(v149 + 6);
      uint64_t v144 = v149[6];
      while (1)
      {
        uint64_t v150 = v144;
        if (v147 != (void *)(v144 & 0xFFFFFFFFFFFFFFF8)) {
          break;
        }
        uint64_t v145 = 0;
        uint64_t v123 = 0;
        uint64_t v25 = v144;
        uint64_t v26 = v144;
        atomic_compare_exchange_strong_explicit(v133, (unint64_t *)&v26, 0, memory_order_release, memory_order_relaxed);
        if (v26 != v25) {
          uint64_t v144 = v26;
        }
        BOOL v122 = v26 == v25;
        BOOL v134 = v26 == v25;
        if (v26 == v25) {
          goto LABEL_95;
        }
      }
      unsigned int v132 = v147;
      uint64_t v131 = 0;
      uint64_t v130 = 0;
      uint64_t v129 = v147[2];
      uint64_t v130 = v129;
      uint64_t v128 = v129;
      uint64_t v131 = v129;
      if (!v129) {
        uint64_t v131 = _dispatch_wait_for_enqueuer(v132 + 2);
      }
      uint64_t v127 = v131;
      uint64_t v146 = v131;
      uint64_t v126 = v131;
      uint64_t v125 = v131;
      v149[13] = v131;
      uint64_t v124 = v126;
LABEL_95:
      BOOL v121 = v134;
    }
    uint64_t v120 = v146;
    uint64_t v36 = (void *)v146;
    unsigned int v56 = v37;
    v153 = v37;
    if (*v37 < 0x1000uLL && (*v56 & 0x81) != 0)
    {
      v35 -= 0x20000000000;
      _dispatch_non_barrier_waiter_redirect_or_wake(v44, (uint64_t)v37, v12, v13, v14, v15, v16, v17);
    }
    else
    {
      if ((v42 & 0x20000) == 0) {
        goto LABEL_103;
      }
      v35 -= 0x20000000000;
      int v50 = v44;
      unint64_t v51 = (unint64_t)*((unsigned int *)v44 + 15) << 32;
      v51 &= 0x700000000uLL;
      _dispatch_continuation_redirect_push((uint64_t)v44, v37, HIDWORD(v51));
    }
LABEL_10:
    BOOL v18 = *(void *)(v43 + 8) == 0;
    BOOL v49 = *(void *)(v43 + 8) == 0;
    uint64_t v48 = 3803;
    if (!v18) {
      _dispatch_abort(v48, v49, v27, v13, v14, v15, v16, v17);
    }
    int v37 = v36;
    if (!v36)
    {
      if (!v44[6]) {
        break;
      }
      unsigned int v82 = v44;
      int v81 = (unint64_t *)(v44 + 13);
      uint64_t v80 = 0;
      uint64_t v79 = 0;
      uint64_t v78 = v44[13];
      uint64_t v79 = v78;
      uint64_t v77 = v78;
      uint64_t v80 = v78;
      if (!v78) {
        uint64_t v80 = _dispatch_wait_for_enqueuer(v81);
      }
      uint64_t v76 = v80;
      int v37 = (void *)v80;
    }
    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    if ((v40 & 1) == (*((_WORD *)v44 + 40) == 1))
    {
      char v33 = 0;
      if ((v42 & 0x4000000) == 0)
      {
        uint64_t v162 = v43;
        v161 = 0;
        v161 = _dispatch_thread_getspecific(0x78uLL);
        char v33 = v161 & 1;
      }
      if ((v33 & 1) == 0)
      {
        if ((v42 & 0x100000) == 0) {
          continue;
        }
        unint64_t v52 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
        unint64_t v53 = (unint64_t)v52[15] << 32;
        v53 &= 0x700000000uLL;
        if (HIDWORD(v53) <= *((unsigned __int8 *)v52 + 100)) {
          continue;
        }
      }
    }
    break;
  }
  if (v35 == 0x40000000000000) {
    uint64_t v35 = ((unint64_t)*((unsigned __int16 *)v44 + 40) << 41) + 0x40000000000000;
  }
  if (v37)
  {
    v194 = v44;
    uint64_t v193 = v35;
    v192 = v37;
    unsigned __int16 v191 = 0;
    unsigned __int16 v191 = *((_WORD *)v44 + 40);
    unint64_t v190 = 0;
    if (v191 >= 2u)
    {
      v189 = v192;
      v199 = v192;
      int v198 = 0;
      v201 = v192;
      if (*v192 > 0xFFFuLL)
      {
        uint64_t v30 = 0;
        if (*v199) {
          uint64_t v30 = *v199;
        }
        if ((*(void *)(v30 + 16) & 0xF0) == 0x10)
        {
          int v197 = 0;
          int v196 = *((_DWORD *)v199 + 20);
          int v197 = v196;
          int v195 = v196;
          int v198 = v196;
          BOOL v200 = (v196 & 0x80000) != 0;
        }
        else
        {
          BOOL v200 = 0;
        }
      }
      else
      {
        BOOL v200 = (*(_DWORD *)v199 & 2) != 0;
      }
      if (v200)
      {
        unint64_t v190 = ((unint64_t)(v191 - 1) << 41) + 0x10000000000;
        v193 -= v190;
      }
    }
    uint64_t v35 = v193;
  }
  *v41 &= 0x4000000001uLL;
  *v41 |= v35;
  v159 = &v38;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v38, v13, v14, v15, v16, v17);
  if (v37) {
    return v44[3];
  }
  else {
    return 0;
  }
}

void _dispatch_queue_invoke_finish(uint64_t a1, uint64_t a2, uint64_t (***a3)(), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = *(void *)(a2 + 8);
  int v16 = *(_DWORD *)(a2 + 16);
  if (v17)
  {
    *(unsigned char *)(v17 + 106) = *(unsigned char *)(v17 + 106) & 0x7F | 0x80;
    *(void *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    uint64_t v18 = a4 & 0x4000000001;
    if (v16) {
      _dispatch_workloop_drain_barrier_waiter(a1, v17, v16, 1u, v18, a6, a7, a8);
    }
    else {
      _dispatch_lane_drain_barrier_waiter(a1, v17, 1u, v18, a5, a6, a7, a8);
    }
  }
  else
  {
    uint64_t v12 = 1;
    if (a3 == &_dispatch_mgr_q) {
      uint64_t v12 = 0x4000000000;
    }
    for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v9)
    {
      unint64_t v13 = (i - a4) & 0xFFFFFF7700000001 | 0x8000000000;
      if (v13 < 0x20000000000000 && (v13 & 0x4000000001) == 0) {
        v13 |= v12;
      }
      uint64_t v8 = i;
      uint64_t v9 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, v13, memory_order_release, memory_order_relaxed);
      if (v9 == v8) {
        break;
      }
    }
    uint64_t v15 = i - a4;
    BOOL v11 = 0;
    if ((v15 & 0x1000000000) != 0) {
      BOOL v11 = (v15 & 0x800000000) != 0;
    }
    if (v11)
    {
      unsigned int v21 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v13) & 7u) > (v21 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25, v21 & 0xFFF0FFFF | ((BYTE4(v13) & 7) << 16));
      }
    }
    if (((v15 ^ v13) & v12) != 0)
    {
      if ((v13 & 0x4000000001) == 0) {
        _dispatch_abort(3979, (v13 & 0x4000000001) != 0, (uint64_t)a3, a4, a5, a6, a7, a8);
      }
      if ((v13 & 0x2000000000) != 0)
      {
        _dispatch_event_loop_poke(a1, v13, 1, a4, a5, a6, a7, a8);
      }
      else
      {
        uint64_t v10 = 0;
        if (*a3) {
          uint64_t v10 = *a3;
        }
        ((void (*)(uint64_t (***)(), uint64_t, unint64_t))v10[9])(a3, a1, (v13 & 0x700000000) >> 32);
      }
    }
    else
    {
      _dispatch_release_2_tailcall(a1);
    }
  }
}

void _dispatch_workloop_drain_barrier_waiter(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = *(_DWORD *)(a2 + 100) & 0xFFFFFFFC;
  uint64_t v14 = *(void *)(a2 + 16);
  *(void *)(a1 + 104 + 8 * (a3 - 1)) = v14;
  if (!v14)
  {
    uint64_t v12 = (atomic_ullong *)(a1 + 152 + 8 * (a3 - 1));
    for (uint64_t i = *(void *)v12; a2 == (i & 0xFFFFFFFFFFFFFFF8); uint64_t i = v8)
    {
      uint64_t v8 = i;
      atomic_compare_exchange_strong_explicit(v12, (unint64_t *)&v8, 0, memory_order_release, memory_order_relaxed);
      if (v8 == i) {
        goto LABEL_10;
      }
    }
    uint64_t v11 = *(void *)(a2 + 16);
    if (!v11) {
      uint64_t v11 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16));
    }
    uint64_t v14 = v11;
    *(void *)(a1 + 104 + 8 * (a3 - 1)) = v11;
  }
LABEL_10:
  BOOL v15 = v14 != 0;
LABEL_11:
  if (!v15)
  {
    for (int j = 6; j; --j)
    {
      if (*(void *)(a1 + 152 + 8 * (j - 1)))
      {
        char v26 = 1;
        goto LABEL_18;
      }
    }
    char v26 = 0;
LABEL_18:
    BOOL v15 = v26;
  }
  for (unint64_t k = *(void *)(a1 + 56); ; unint64_t k = v10)
  {
    if ((k & 0x2000000000) != 0 && (k & 2) != 0 && (k & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFF7FFFFFFFDLL, memory_order_relaxed);
      goto LABEL_11;
    }
    unint64_t v16 = k & 0xFFFFFF7700000001 | v18;
    if ((k & 0x2000000000) != 0)
    {
      if (!v15)
      {
        if ((k & 0x8000000000) != 0)
        {
          atomic_fetch_xor_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_acquire);
          goto LABEL_11;
        }
        unint64_t v16 = k & 0xFFFFFF7000000000 | v18 & 0xFFFFFFF8FFFFFFFELL;
      }
    }
    else
    {
      v16 -= a5;
    }
    unint64_t v9 = k;
    unint64_t v10 = k;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v10, v16, memory_order_release, memory_order_relaxed);
    if (v10 == v9) {
      break;
    }
  }
  _dispatch_barrier_waiter_redirect_or_wake(a1, a2, a4, k, v16, a6, a7, a8);
}

void _dispatch_lane_drain_barrier_waiter(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *(_DWORD *)(a2 + 100) & 0xFFFFFFFC;
  uint64_t v22 = *(void *)(a2 + 16);
  *(void *)(a1 + 104) = v22;
  if (!v22)
  {
    for (uint64_t i = *(void *)(a1 + 48); a2 == (i & 0xFFFFFFFFFFFFFFF8); uint64_t i = v9)
    {
      uint64_t v8 = i;
      uint64_t v9 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t *)&v9, 0, memory_order_release, memory_order_relaxed);
      if (v9 == v8) {
        goto LABEL_9;
      }
    }
    uint64_t v20 = *(void *)(a2 + 16);
    if (!v20) {
      uint64_t v20 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16));
    }
    uint64_t v22 = v20;
    *(void *)(a1 + 104) = v20;
  }
LABEL_9:
  uint64_t v15 = v22;
LABEL_10:
  for (unint64_t j = *(void *)(a1 + 56); ; unint64_t j = v11)
  {
    if ((j & 0x2000000000) != 0 && (j & 2) != 0 && (j & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFF7FFFFFFFDLL, memory_order_relaxed);
      goto LABEL_10;
    }
    unint64_t v12 = j & 0xFFFFFF7700000001 | v14;
    if ((j & 0x2000000000) != 0)
    {
      if (!v15)
      {
        if ((j & 0x8000000000) != 0)
        {
          atomic_fetch_xor_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_acquire);
          uint64_t v15 = *(void *)(a1 + 104);
          goto LABEL_10;
        }
        unint64_t v12 = j & 0xFFFFFF7000000000 | v14 & 0xFFFFFFF8FFFFFFFELL;
      }
    }
    else
    {
      v12 -= a4;
    }
    unint64_t v10 = j;
    unint64_t v11 = j;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v11, v12, memory_order_release, memory_order_relaxed);
    if (v11 == v10) {
      break;
    }
  }
  _dispatch_barrier_waiter_redirect_or_wake(a1, a2, a3, j, v12, a6, a7, a8);
}

void _dispatch_lane_activate(uint64_t a1)
{
  unint64_t v9 = *(void *)(a1 + 24);
  int v8 = *(_DWORD *)(a1 + 84);
  if ((unsigned __int16)(v8 & 0xF000) >> 12 <= ((unsigned __int16)(v8 & 0xF00) >> 8)
    || (unsigned __int16)(v8 & 0xF00) >> 8 && (v8 & 0x40000000) == 0)
  {
    *(_DWORD *)(a1 + 84) = v8 & 0xFBFF0FFF;
  }
  uint64_t v1 = _dispatch_queue_priority_inherit_from_target(a1, v9);
  _dispatch_lane_inherit_wlh_from_target(a1, (unint64_t)v1, v2, v3, v4, v5, v6, v7);
}

uint64_t (***_dispatch_queue_priority_inherit_from_target(uint64_t a1, unint64_t a2))()
{
  unint64_t v9 = a2;
  unsigned int v8 = *(_DWORD *)(a1 + 84);
  BOOL v6 = 0;
  if ((v8 & 0x20000000) == 0) {
    BOOL v6 = (v8 & 0x44000FFF) != 0;
  }
  if (v6)
  {
    BOOL v5 = 0;
    if (a2 >= (unint64_t)&_dispatch_root_queues) {
      BOOL v5 = a2 < (unint64_t)&unk_F0A80;
    }
    if (v5)
    {
      unsigned int v7 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
      if (!v7) {
        unsigned int v7 = 4;
      }
      int v12 = 2 * (v8 >> 31);
      BOOL v4 = 1;
      if (v7) {
        BOOL v4 = v7 > 6;
      }
      if (v4)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
        qword_F42C0 = v7;
        __break(1u);
        JUMPOUT(0x2C98CLL);
      }
      int v11 = 0;
      if ((v12 & 2) != 0)
      {
        int v11 = 1;
      }
      else if ((v12 & 4) != 0)
      {
        int v11 = 2;
      }
      return &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v7 + v11 - 3)];
    }
    return (uint64_t (***)())v9;
  }
  else
  {
    BOOL v3 = 0;
    if (a2 >= (unint64_t)&_dispatch_root_queues) {
      BOOL v3 = a2 < (unint64_t)&unk_F0A80;
    }
    if (v3)
    {
      unsigned int v8 = *(_DWORD *)(a2 + 84) | 0x20000000;
    }
    else if ((v8 & 0x20000000) != 0)
    {
      v8 &= 0xFBFF0FFF;
    }
    *(_DWORD *)(a1 + 84) = v8;
    return (uint64_t (***)())a2;
  }
}

void _dispatch_lane_inherit_wlh_from_target(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = 0;
  if (*(void *)a2) {
    uint64_t v15 = *(void *)a2;
  }
  if ((*(void *)(v15 + 16) & 0x10000) != 0)
  {
    if (_dispatch_base_lane_is_wlh((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8)) {
      uint64_t v19 = 0x2000000000;
    }
    else {
      uint64_t v19 = 0x1000000000;
    }
  }
  else
  {
    uint64_t v19 = 0;
  }
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v9)
  {
    unint64_t v20 = i & 0xFFFFFFCFFFFFFFFFLL | v19;
    if (i == v20) {
      break;
    }
    uint64_t v8 = i;
    uint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, v20, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  if ((i & 0x2000000000) != 0 && (v20 & 0x2000000000) == 0)
  {
    uint64_t v18 = _dispatch_thread_getspecific(0x1DuLL);
    if (v18)
    {
      if (v18[3] == a1) {
        _dispatch_event_loop_leave_immediate(v20);
      }
    }
  }
  uint64_t v14 = 0;
  if (*(void *)a2) {
    uint64_t v14 = *(void *)a2;
  }
  if ((*(void *)(v14 + 16) & 0x10000) == 0)
  {
    int v17 = 0;
    unsigned int v16 = 0;
    uint64_t v13 = 0;
    if (*(void *)a2) {
      uint64_t v13 = *(void *)a2;
    }
    if (*(unsigned char *)(v13 + 16) == 18)
    {
      int v17 = 0x400000;
      BOOL v12 = 0;
      if (*(void *)(a2 + 24) >= (unint64_t)&_dispatch_root_queues) {
        BOOL v12 = *(void *)(a2 + 24) < (unint64_t)&unk_F0A80;
      }
      if (!v12)
      {
        unsigned int v16 = 0x1000000;
        if (_dispatch_workloop_uses_bound_thread(a2)) {
          unsigned int v16 = 17039360;
        }
      }
    }
    else
    {
      unsigned int v16 = *(_DWORD *)(a2 + 80) & 0x1000000;
      if (v16) {
        unsigned int v16 = *(_DWORD *)(a2 + 80) & 0x1040000;
      }
    }
    if (v17)
    {
      for (int j = *(_DWORD *)(a2 + 80); ((j | 0x100000) & ~v17) != j; int j = v11)
      {
        int v10 = j;
        int v11 = j;
        atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a2 + 80), (unsigned int *)&v11, (j | 0x100000) & ~v17, memory_order_relaxed, memory_order_relaxed);
        if (v11 == v10) {
          break;
        }
      }
    }
    else
    {
      atomic_fetch_or_explicit((atomic_uint *volatile)(a2 + 80), 0x100000u, memory_order_relaxed);
    }
    if (v16) {
      atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 80), v16, memory_order_relaxed);
    }
  }
}

void _dispatch_lane_invoke(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = a1;
  uint64_t v51 = a2;
  unsigned int v50 = a3;
  int v49 = 0;
  uint64_t v48 = _dispatch_lane_invoke2;
  uint64_t v47 = a1;
  v46[8] = 0;
  *(void *)uint64_t v46 = (a3 & 1) == 0;
  uint64_t v45 = 0;
  if ((a3 & 3) == 0)
  {
    *(void *)(v47 + 16) = -1985229329;
    BOOL v44 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v43 = v47;
    unint64_t v74 = v44;
    uint64_t v73 = v47;
    int v72 = 0;
    int v71 = 0;
    v172 = v44;
    uint64_t v171 = v47;
  }
  v50 |= v49;
  if ((v50 & 2) != 0)
  {
    uint64_t v45 = 0x40020000000001;
  }
  else
  {
    uint64_t v102 = v47;
    unsigned int v101 = v50;
    uint64_t v100 = 0;
    uint64_t v100 = (uint64_t)(*(unsigned __int16 *)(v47 + 80) - 1) << 41;
    unsigned int v115 = _dispatch_thread_getspecific(3uLL);
    uint64_t v99 = v115 & 0xFFFFFFFC | 0x20000000000000;
    unint64_t v97 = 0;
    unint64_t v96 = 0;
    uint64_t v95 = 0;
    unint64_t v98 = 0xFFE00000FFFFFFFCLL;
    if (v50)
    {
      v98 |= 0x4000000000uLL;
      uint64_t v95 = 0;
    }
    else if ((v101 & 0x40000) != 0)
    {
      uint64_t v95 = 0x4000000000;
    }
    else
    {
      v98 |= 0x4000000000uLL;
      uint64_t v95 = 1;
    }
    BOOL v108 = (v101 & 2) == 0;
    uint64_t v107 = 1323;
    if ((v101 & 2) != 0) {
      _dispatch_abort(v107, v108, v8, v9, v10, v11, v12, v13);
    }
    unsigned int v94 = 0;
    unsigned int v112 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v114 = v112 & 0xF00;
    unsigned int v111 = v114 >> 8;
    unsigned int v113 = v112 & 0xF000;
    unsigned int v110 = v113 >> 12;
    int v116 = v112 & 0xF0000;
    unsigned int v109 = (v112 & 0xF0000) >> 16;
    if (v114 >> 8 <= v113 >> 12) {
      unsigned int v38 = v110;
    }
    else {
      unsigned int v38 = v111;
    }
    if (v38 <= v109)
    {
      unsigned int v36 = v109;
    }
    else
    {
      if (v111 <= v110) {
        unsigned int v37 = v110;
      }
      else {
        unsigned int v37 = v111;
      }
      unsigned int v36 = v37;
    }
    unsigned int v94 = v36;
LABEL_22:
    BOOL v93 = 0;
    BOOL v92 = (atomic_ullong *)(v102 + 56);
    unint64_t v97 = *(void *)(v102 + 56);
    do
    {
      unint64_t v96 = v97;
      if ((v97 & v98) != 0)
      {
        if (!v95) {
          break;
        }
        v96 ^= v95;
      }
      else
      {
        unint64_t v149 = v97;
        unsigned int v148 = v94;
        unint64_t v151 = v97;
        BOOL v35 = 0;
        if ((v97 & 0x1000000000) != 0)
        {
          uint64_t v150 = v149 & 0x700000000;
          BOOL v35 = v148 < (v149 & 0x700000000) >> 32;
        }
        if (v35)
        {
          unint64_t v153 = v97;
          uint64_t v154 = v97 & 0x700000000;
          unsigned int v152 = (v97 & 0x700000000) >> 32;
          unsigned int v158 = _dispatch_thread_getspecific(3uLL);
          unsigned int v157 = v152;
          if (_dispatch_set_qos_class_enabled)
          {
            unsigned int v160 = v157;
            uint64_t v159 = 0;
            if (v157) {
              uint64_t v159 = 1 << (v160 + 7);
            }
            _pthread_workqueue_override_start_direct();
          }
          unsigned int v156 = v152;
          unsigned int v155 = _dispatch_thread_getspecific(0x19uLL);
          int v161 = v155 & 0xF0000;
          if (v152 > (v155 & 0xF0000) >> 16)
          {
            unsigned int v155 = v155 & 0xFFF0FFFF | (v156 << 16);
            _dispatch_thread_setspecific(25, v155);
          }
          unsigned int v94 = v152;
          goto LABEL_22;
        }
        unint64_t v96 = v96 & 0x7700000001 | v99;
        unint64_t v104 = v97;
        if ((v97 & 0x10000000000) != 0 || v97 + v100 < 0x20000000000000) {
          v96 |= 0x40000000000000uLL;
        }
      }
      unint64_t v91 = v96;
      unint64_t v16 = v97;
      unint64_t v17 = v97;
      atomic_compare_exchange_strong_explicit(v92, &v17, v96, memory_order_acquire, memory_order_acquire);
      if (v17 != v16) {
        unint64_t v97 = v17;
      }
      BOOL v90 = v17 == v16;
      BOOL v93 = v17 == v16;
    }
    while (v17 != v16);
    BOOL v89 = v93;
    BOOL v106 = (v97 & v95) == v95;
    uint64_t v105 = 1356;
    if ((v97 & v95) != v95) {
      _dispatch_abort(v105, v106, v14, v15, a5, a6, a7, a8);
    }
    if ((v97 & v98) != 0)
    {
      uint64_t v103 = 0;
    }
    else
    {
      v96 &= v95 | 0x60000000000000;
      v97 &= 0x3FFE0000000000uLL;
      uint64_t v103 = v96 - v97;
    }
    uint64_t v45 = v103;
  }
  if (v45)
  {
    unsigned int v42 = 0;
    if ((v50 & 0x40000) != 0)
    {
      unsigned int v42 = 0;
    }
    else
    {
      int v78 = *(_DWORD *)(v47 + 84);
      unsigned int v77 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v76 = v77;
      if (v77)
      {
        if ((v78 & 0xFFF) != 0)
        {
          v76 &= 0x880F0000;
          if ((v77 & 0xFFF) <= (v78 & 0xFFFu)) {
            int v34 = v78 & 0xFFF;
          }
          else {
            int v34 = v77 & 0xFFF;
          }
          v76 |= v34;
          unsigned int v80 = v78 & 0xF000;
          unsigned int v82 = v76 & 0xF00;
          if (v80 >> 12 <= v82 >> 8) {
            v78 &= 0x40000000u;
          }
          else {
            v78 &= 0x4400F000u;
          }
          v76 |= v78;
        }
        else
        {
          if ((v76 & 0xFFF) != 0) {
            v76 |= 0x40000000u;
          }
          unsigned int v79 = v78 & 0xF000;
          unsigned int v81 = v76 & 0xF00;
          if (v79 >> 12 > v81 >> 8) {
            unsigned int v76 = v76 & 0xFFFF0FFF | v78 & 0x400F000;
          }
        }
      }
      else
      {
        unsigned int v76 = v78 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v76);
      unsigned int v42 = v77;
    }
    if ((v50 & 0x100000) != 0)
    {
      uint64_t v56 = v52;
      int v55 = 0;
      int v54 = *(_DWORD *)(v52 + 80);
      int v55 = v54;
      int v53 = v54;
      if ((v54 & 0x400000) != 0)
      {
        uint64_t v68 = v52;
        int v67 = 0x400000;
        int v65 = -4194305;
        int v64 = -4194305;
        int v66 = -4194305;
        int v60 = -4194305;
        int v59 = -4194305;
        int v61 = -4194305;
        unsigned int v58 = atomic_fetch_and_explicit((atomic_uint *volatile)(v52 + 80), 0xFFBFFFFF, memory_order_relaxed);
        unsigned int v62 = v58;
        unsigned int v57 = v58;
        unsigned int v63 = v58 & 0xFFBFFFFF;
      }
    }
    uint64_t v41 = v47;
    uint64_t v119 = v47;
    unsigned int v118 = v50;
    int v117 = 0;
    uint64_t v164 = v47;
    uint64_t v163 = 256;
    uint64_t v170 = 1;
    uint64_t v169 = 730;
    int v162 = 0;
    uint64_t v168 = v47;
    int v167 = 0;
    int v166 = *(_DWORD *)(v47 + 80);
    int v167 = v166;
    int v165 = v166;
    int v162 = v166 & 0x30000;
    int v117 = (v166 & 0x30000) << 8;
    if (v117) {
      unsigned int v118 = v118 & 0xFCFFFFFF | v117;
    }
    unsigned int v50 = v118;
    do
    {
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v51);
      }
      uint64_t v40 = v47;
      *(void *)&v46[1] = v48(v47, v51, v50, &v45);
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0)
      {
        long long v39 = 0uLL;
        uint64_t v84 = v47;
        uint64_t v83 = &v39;
        int v88 = &v39;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v39, v19, a5, a6, a7, a8);
        _dispatch_thread_setspecific_pair(20, v84, 21, (uint64_t)v83, v20, v21, v22, v23);
        _dispatch_last_resort_autorelease_pool_pop(v51);
        uint64_t v85 = &v39;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v39, v24, v25, v26, v27, v28);
      }
      BOOL v70 = *(void *)&v46[1] != 1;
      uint64_t v69 = 2018;
      if (*(void *)&v46[1] == 1) {
        _dispatch_abort(v69, v70, v18, v19, a5, a6, a7, a8);
      }
      BOOL v33 = 0;
      if (*(void *)&v46[1]) {
        BOOL v33 = *(void *)&v46[1] != -1;
      }
      if (v33) {
        break;
      }
      uint64_t v139 = v47;
      uint64_t v138 = v45;
      BOOL v137 = *(void *)&v46[1] == 0;
      uint64_t v136 = 0;
      unint64_t v135 = 0;
      BOOL v134 = 0;
      unsigned int v133 = (atomic_ullong *)(v47 + 56);
      uint64_t v136 = *(void *)(v47 + 56);
      do
      {
        unint64_t v135 = (v136 - v138) & 0xFFFFFFF700000001;
        uint64_t v141 = v136;
        if ((v136 & 0xFF80000000000000) == 0)
        {
          uint64_t v142 = v136;
          if ((v136 & 0x8000000000) != 0)
          {
            uint64_t v131 = 0x8000000000;
            uint64_t v130 = 0x8000000000;
            uint64_t v132 = 0x8000000000;
            unint64_t v128 = 0;
            uint64_t v126 = 0x8000000000;
            uint64_t v125 = 0x8000000000;
            uint64_t v127 = 0x8000000000;
            xor_unint64_t explicit = atomic_fetch_xor_explicit((atomic_ullong *volatile)(v139 + 56), 0x8000000000uLL, memory_order_acquire);
            unint64_t v128 = xor_explicit;
            unint64_t v123 = xor_explicit;
            unint64_t v129 = xor_explicit ^ v132;
            char v140 = 0;
            goto LABEL_101;
          }
          if (v137) {
            v135 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v135 |= 0x8000000000uLL;
          }
        }
        unint64_t v122 = v135;
        uint64_t v29 = v136;
        uint64_t v30 = v136;
        atomic_compare_exchange_strong_explicit(v133, (unint64_t *)&v30, v135, memory_order_release, memory_order_relaxed);
        if (v30 != v29) {
          uint64_t v136 = v30;
        }
        BOOL v121 = v30 == v29;
        BOOL v134 = v30 == v29;
      }
      while (v30 != v29);
      BOOL v120 = v134;
      uint64_t v144 = v136;
      uint64_t v146 = v136;
      BOOL v32 = 0;
      if ((v136 & 0x1000000000) != 0) {
        BOOL v32 = (v144 & 0x800000000) != 0;
      }
      if (v32)
      {
        uint64_t v143 = v136 & 0x700000000;
        uint64_t v145 = v136 & 0x700000000;
        LODWORD(v145) = _dispatch_thread_getspecific(0x19uLL);
        int v147 = v145 & 0xF0000;
        if (HIDWORD(v145) > (v145 & 0xF0000) >> 16)
        {
          LODWORD(v145) = v145 & 0xFFF0FFFF;
          LODWORD(v145) = v145 | (HIDWORD(v145) << 16);
          _dispatch_thread_setspecific(25, v145);
        }
      }
      char v140 = 1;
LABEL_101:
      if (v140)
      {
        uint64_t v45 = 0;
        *(void *)&v46[1] = 0;
        break;
      }
      *(void *)&v46[1] = _dispatch_thread_getspecific(0x14uLL);
      uint64_t v31 = 0;
      if (**(void **)&v46[1]) {
        uint64_t v31 = **(void **)&v46[1];
      }
    }
    while ((*(void *)(v31 + 16) & 0x10000) != 0 || (v46[0] & 1) == 0);
    if ((v50 & 0x40000) == 0)
    {
      unsigned int v87 = v42;
      unsigned int v86 = 0;
      unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
      v87 &= 0xFFF0FFFF;
      v87 |= v86 & 0xF0000;
      _dispatch_thread_setspecific(25, v87);
    }
  }
  if (v46[0])
  {
    uint64_t v75 = v47;
    uint64_t v173 = v47;
    int v178 = 772079660;
    uint64_t v177 = v47;
    uint64_t v176 = 0;
    uint64_t v175 = 0;
    uint64_t v174 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v179 = v75;
  }
  if (*(void *)&v46[1]) {
    _dispatch_queue_invoke_finish(v47, v51, *(uint64_t (****)())&v46[1], v45, a5, a6, a7, a8);
  }
  else {
    _dispatch_release_2_tailcall(v47);
  }
}

uint64_t _dispatch_lane_invoke2(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v9 = *(void **)(a1 + 24);
  if (_dispatch_thread_getspecific(0x14uLL) != v9) {
    return (uint64_t)v9;
  }
  if (*(_WORD *)(a1 + 80) == 1) {
    return _dispatch_lane_serial_drain((uint64_t *)a1, a2, a3, a4, v4, v5, v6, v7);
  }
  return _dispatch_lane_concurrent_drain((uint64_t *)a1, a2, a3, a4, v4, v5, v6, v7);
}

uint64_t dispatch_workloop_copy_current()
{
  BOOL v3 = (uint64_t *)_dispatch_thread_getspecific(0x1BuLL);
  if (v3 && v3 != (uint64_t *)-4)
  {
    uint64_t v1 = 0;
    if (*v3) {
      uint64_t v1 = *v3;
    }
    if (*(unsigned char *)(v1 + 16) == 18) {
      uint64_t v4 = (uint64_t)v3;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (!v4) {
    return 0;
  }
  _os_object_retain_with_resurrect(v4);
  return v4;
}

BOOL dispatch_workloop_is_current(void *a1)
{
  return _dispatch_thread_getspecific(0x1BuLL) == a1;
}

BOOL _dispatch_workloop_uses_bound_thread(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 200);
  return v2 && (*v2 & 0x40) != 0;
}

BOOL _dispatch_workloop_should_yield_4NW()
{
  BOOL v3 = _dispatch_thread_getspecific(0x1BuLL);
  if (v3 && v3 != (void *)-4)
  {
    uint64_t v1 = 0;
    if (*v3) {
      uint64_t v1 = *v3;
    }
    if (*(unsigned char *)(v1 + 16) == 18) {
      uint64_t v4 = v3;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  return v4
      && (((unint64_t)*((unsigned int *)v4 + 15) << 32) & 0x700000000) >> 32 > *((unsigned __int8 *)v4 + 100);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  return (dispatch_workloop_t)_dispatch_workloop_create(label, 0, v1, v2, v3, v4, v5, v6);
}

uint64_t *_dispatch_workloop_create(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a1;
  int v21 = 0x10000;
  if (a1)
  {
    uint64_t v20 = _dispatch_strdup_if_mutable(a1);
    if (v20 != v24)
    {
      int v21 = 2162688;
      uint64_t v24 = v20;
    }
  }
  if (_dispatch_kevent_workqueue_enabled) {
    uint64_t v25 = 0x2000000000;
  }
  else {
    uint64_t v25 = 0x1000000000;
  }
  uint64_t v23 = a2 | v25;
  uint64_t v19 = _dispatch_object_alloc((uint64_t)_OS_dispatch_workloop_vtable, 0xD0uLL, a3, a4, a5, a6, a7, a8);
  _dispatch_queue_init(v19, v21, 1, v23, v8, v9, v10, v11);
  v19[9] = (uint64_t)v24;
  v19[3] = (uint64_t)&off_F0680;
  if ((v23 & 0x180000000000000) == 0) {
    *((_DWORD *)v19 + 21) = -2080358400;
  }
  _dispatch_object_debug(v19, "%s", v12, v13, v14, v15, v16, v17, (char)"_dispatch_workloop_create");
  return v19;
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)_dispatch_workloop_create(label, 0x180000000000000, v1, v2, v3, v4, v5, v6);
}

void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t workloop, dispatch_autorelease_frequency_t frequency)
{
  if (frequency == DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)
  {
    for (int i = *((_DWORD *)workloop + 20); (i & 0xFFFCFFFF | 0x10000) != i; int i = v3)
    {
      int v2 = i;
      int v3 = i;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)((char *)workloop + 80), (unsigned int *)&v3, i & 0xFFFCFFFF | 0x10000, memory_order_relaxed, memory_order_relaxed);
      if (v3 == v2) {
        break;
      }
    }
  }
  else
  {
    for (int j = *((_DWORD *)workloop + 20); (j & 0xFFFCFFFF | 0x20000) != j; int j = v5)
    {
      int v4 = j;
      int v5 = j;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)((char *)workloop + 80), (unsigned int *)&v5, j & 0xFFFCFFFF | 0x20000, memory_order_relaxed, memory_order_relaxed);
      if (v5 == v4) {
        break;
      }
    }
  }
  uint64_t v6 = *((void *)workloop + 7);
  if ((~v6 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x2F0CCLL);
  }
}

uint64_t dispatch_workloop_set_scheduler_priority(uint64_t result, int a2, char a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 56);
  if ((~v6 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x2F18CLL);
  }
  if (!*(void *)(result + 200))
  {
    uint64_t result = _dispatch_calloc();
    *(void *)(v5 + 200) = result;
  }
  if (a2)
  {
    *(_DWORD *)(*(void *)(v5 + 200) + 8) = a2;
    **(_DWORD **)(v5 + 200) |= 1u;
  }
  else
  {
    *(_DWORD *)(*(void *)(v5 + 200) + 8) = 0;
    **(_DWORD **)(v5 + 200) &= ~1u;
  }
  if (a3)
  {
    *(_DWORD *)(*(void *)(v5 + 200) + 16) = 2;
    **(_DWORD **)(v5 + 200) |= 2u;
  }
  else
  {
    **(_DWORD **)(v5 + 200) &= ~2u;
  }
  return result;
}

uint64_t dispatch_workloop_set_uses_bound_thread(uint64_t a1)
{
  if (_dispatch_workloop_bound_thread_pred != -1) {
    dispatch_once_f(&_dispatch_workloop_bound_thread_pred, 0, (dispatch_function_t)_dispatch_workloop_bound_thread_init_once);
  }
  if (_dispatch_thread_bound_kqwl_enabled)
  {
    uint64_t v4 = *(void *)(a1 + 56);
    if ((~v4 & 0x180000000000000) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
      qword_F42C0 = v4;
      __break(1u);
      JUMPOUT(0x2F39CLL);
    }
    if (!*(void *)(a1 + 200)) {
      *(void *)(a1 + 200) = _dispatch_calloc();
    }
    **(_DWORD **)(a1 + 200) |= 0x40u;
    return 0;
  }
  else
  {
    return -1;
  }
}

void dispatch_workloop_set_os_workgroup(dispatch_workloop_t workloop, os_workgroup_t workgroup)
{
  uint64_t v5 = *((void *)workloop + 7);
  if ((~v5 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v5;
    __break(1u);
    JUMPOUT(0x2F4B8);
  }
  if (!*((void *)workloop + 25)) {
    *((void *)workloop + 25) = _dispatch_calloc();
  }
  uint64_t v2 = *(void *)(*((void *)workloop + 25) + 32);
  if (v2) {
    _os_object_release(v2);
  }
  _os_object_retain((uint64_t)workgroup);
  *(void *)(*((void *)workloop + 25) + 32) = workgroup;
}

uint64_t dispatch_workloop_set_qos_class(uint64_t a1, int a2, char a3)
{
  return dispatch_workloop_set_qos_class_floor(a1, a2, 0, a3);
}

uint64_t dispatch_workloop_set_cpupercent(uint64_t result, char a2, int a3)
{
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 56);
  if ((~v6 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x2F638);
  }
  if (!*(void *)(result + 200))
  {
    uint64_t result = _dispatch_calloc();
    *(void *)(v5 + 200) = result;
  }
  if ((**(unsigned char **)(v5 + 200) & 9) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: workloop qos class or priority must be set before cpupercent";
    __break(1u);
    JUMPOUT(0x2F6B4);
  }
  *(unsigned char *)(*(void *)(v5 + 200) + 20) = a2;
  *(_DWORD *)(*(void *)(v5 + 200) + 24) = a3;
  **(_DWORD **)(v5 + 200) |= 4u;
  return result;
}

__n128 _dispatch_workloop_set_observer_hooks_4IOHID(uint64_t a1, __n128 *a2)
{
  uint64_t v5 = *(void *)(a1 + 56);
  if ((~v5 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v5;
    __break(1u);
    JUMPOUT(0x2F7ACLL);
  }
  if (!*(void *)(a1 + 200)) {
    *(void *)(a1 + 200) = _dispatch_calloc();
  }
  __n128 result = *a2;
  *(__n128 *)(*(void *)(a1 + 200) + 40) = *a2;
  **(_DWORD **)(a1 + 200) |= 0x20u;
  return result;
}

void _dispatch_workloop_dispose(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = *(void *)(a1 + 56);
  if (_dispatch_kevent_workqueue_enabled) {
    uint64_t v27 = 0x2000000000;
  }
  else {
    uint64_t v27 = 0x1000000000;
  }
  if (v24 != (v27 | 0x1FFE0000000000))
  {
    if ((v24 & 0xFFFFFFFC) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a locked workloop";
      qword_F42C0 = v24;
      __break(1u);
      JUMPOUT(0x2F91CLL);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a workloop with corrupt state";
    qword_F42C0 = v24;
    __break(1u);
    JUMPOUT(0x2F960);
  }
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_workloop_dispose");
  for (unint64_t i = 0; i < 6; ++i)
  {
    if (*(void *)(a1 + 8 * i + 152))
    {
      uint64_t v22 = *(void *)(a1 + 8 * i + 152);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a workloop while items are enqueued";
      qword_F42C0 = v22;
      __break(1u);
      JUMPOUT(0x2FA2CLL);
    }
    *(void *)(a1 + 8 * i + 152) = 512;
    *(void *)(a1 + 8 * i + 104) = 512;
  }
  if (*(void *)(a1 + 48))
  {
    for (unint64_t j = 0; j <= 5; ++j)
    {
      if (*(_DWORD *)(*(void *)(a1 + 48) + 32 * j)) {
        _dispatch_abort(4557, *(_DWORD *)(*(void *)(a1 + 48) + 32 * j) == 0, v8, v9, v10, v11, v12, v13);
      }
    }
    free(*(void **)(a1 + 48));
    *(void *)(a1 + 48) = 0;
  }
  if (*(void *)(a1 + 200))
  {
    if ((**(unsigned char **)(a1 + 200) & 0x10) != 0)
    {
      int v20 = _pthread_workloop_destroy();
      if (v20) {
        _dispatch_bug(4566, v20, v14, v15, v16, v17, v18, v19);
      }
    }
  }
  if (*(void *)(a1 + 200))
  {
    if (*(void *)(*(void *)(a1 + 200) + 32)) {
      _os_object_release(*(void *)(*(void *)(a1 + 200) + 32));
    }
    free(*(void **)(a1 + 200));
  }
  _dispatch_queue_dispose(a1, a2);
}

void _dispatch_workloop_activate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFEFFFFFFFFFFFFFFLL, memory_order_relaxed) & 0x180000000000000) == 0x180000000000000)
  {
    if (*(void *)(a1 + 200)) {
      _dispatch_workloop_activate_attributes(a1);
    }
    if (!*(_DWORD *)(a1 + 84)) {
      *(_DWORD *)(a1 + 84) = 67125248;
    }
    *(_DWORD *)(a1 + 84) |= 0x80000000;
    atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFF7FFFFFFFFFFFFFLL, memory_order_relaxed);
    _dispatch_workloop_wakeup(a1, 0, 1, a4, a5, a6, a7, a8);
  }
}

uint64_t _dispatch_workloop_activate_attributes(uint64_t a1)
{
  uint64_t v12 = *(void *)(a1 + 200);
  memset(&v14, 0, sizeof(v14));
  pthread_attr_init(&v14);
  if ((*(unsigned char *)v12 & 8) != 0) {
    *(_DWORD *)(a1 + 84) |= *(_DWORD *)(v12 + 4) | 0x40000000;
  }
  if (*(unsigned char *)v12)
  {
    pthread_attr_setschedparam(&v14, (const sched_param *)(v12 + 8));
    *(void *)(a1 + 24) = &_dispatch_custom_workloop_root_queue;
  }
  if (*(void *)(v12 + 32))
  {
    *(void *)(a1 + 24) = &_dispatch_custom_workloop_root_queue;
    if (_os_workgroup_get_backing_workinterval(*(void *)(v12 + 32))) {
      pthread_attr_setworkinterval_np();
    }
  }
  if ((*(unsigned char *)v12 & 0x40) != 0)
  {
    if (_dispatch_root_queues_pred != -1) {
      dispatch_once_f(&_dispatch_root_queues_pred, 0, (dispatch_function_t)_dispatch_root_queues_init_once);
    }
    *(void *)(a1 + 24) = &_dispatch_custom_workloop_overcommit_root_queue;
  }
  if ((*(unsigned char *)v12 & 2) != 0) {
    pthread_attr_setschedpolicy(&v14, *(_DWORD *)(v12 + 16));
  }
  if ((*(unsigned char *)v12 & 4) != 0) {
    pthread_attr_setcpupercent_np();
  }
  BOOL v10 = 0;
  if (*(void *)(a1 + 200)) {
    BOOL v10 = (**(unsigned char **)(a1 + 200) & 0x47) != 0;
  }
  char v9 = 1;
  if (!v10)
  {
    BOOL v8 = 0;
    if (*(void *)(a1 + 200))
    {
      BOOL v8 = 0;
      if (*(void *)(*(void *)(a1 + 200) + 32)) {
        BOOL v8 = _os_workgroup_get_backing_workinterval(*(void *)(*(void *)(a1 + 200) + 32)) != 0;
      }
    }
    char v9 = v8;
  }
  if (v9)
  {
    int v11 = _pthread_workloop_create();
    if (v11)
    {
      switch(v11)
      {
        case '!':
          if ((*(_DWORD *)v12 & 0x40) == 0) {
            _dispatch_abort(4509, 0, v1, v2, v3, v4, v5, v6);
          }
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Process has too many threads.";
          qword_F42C0 = a1;
          __break(1u);
          JUMPOUT(0x30154);
        case '-':
          _dispatch_workloop_activate_tg_unsupported_fallback(a1);
          break;
        case 'N':
          _dispatch_workloop_activate_simulator_fallback(a1, (uint64_t)&v14, v1, v2, v3, v4, v5, v6);
          break;
        default:
          _dispatch_abort(4514, v11, v1, v2, v3, v4, v5, v6);
      }
    }
    else
    {
      *(_DWORD *)v12 |= 0x10u;
    }
  }
  return pthread_attr_destroy(&v14);
}

void _dispatch_workloop_wakeup(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 >> 2))
  {
    _dispatch_workloop_barrier_complete(a1, a2, a3);
    return;
  }
  if ((a3 & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid way to wake up a workloop";
    qword_F42C0 = a3;
    __break(1u);
    JUMPOUT(0x3024CLL);
  }
  if ((a3 >> 3)) {
    goto LABEL_39;
  }
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v9)
  {
    unint64_t v14 = i;
    if ((i & 0x700000000uLL) < (unint64_t)a2 << 32)
    {
      unint64_t v14 = i & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a2 << 32);
      if ((v14 & 0x1000000000) != 0) {
        v14 |= 0x800000000uLL;
      }
    }
    uint64_t v11 = v14;
    if ((v14 & 0x700000000) >> 32) {
      uint64_t v11 = v14 | 1;
    }
    if ((a3 & 2) != 0)
    {
      v11 |= 0x8000000000uLL;
    }
    else if (v11 == i)
    {
      goto LABEL_39;
    }
    uint64_t v8 = i;
    uint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, v11, memory_order_release, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  if ((i & 0xFF80000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Waking up an inactive workloop";
    qword_F42C0 = i;
    __break(1u);
    JUMPOUT(0x30460);
  }
  if ((i ^ v11))
  {
    uint64_t v13 = *(uint64_t **)(a1 + 24);
    if ((a3 & 1) == 0) {
      _dispatch_abort(1929, a3 & 1, a3, a4, a5, a6, a7, a8);
    }
    if ((v11 & 0x2000000000) != 0)
    {
      _dispatch_event_loop_poke(a1, v11, 1, a4, a5, a6, a7, a8);
    }
    else
    {
      uint64_t v10 = 0;
      if (*v13) {
        uint64_t v10 = *v13;
      }
      (*(void (**)(uint64_t *, uint64_t, unint64_t))(v10 + 72))(v13, a1, (v11 & 0x700000000uLL) >> 32);
    }
    return;
  }
  if (((i ^ v11) & 0x700000000) == 0)
  {
LABEL_39:
    _dispatch_release_2_tailcall(a1);
    return;
  }
  if ((v11 & 0xFF80000000000000) != 0 || (v11 & 0x4000000000) != 0 || (v11 & 1) == 0 && (v11 & 0xFFFFFFFC) == 0) {
    _dispatch_abort(5301, 0, a3, a4, a5, a6, a7, a8);
  }
  if ((v11 & 0x2000000000) != 0) {
    _dispatch_event_loop_poke(a1, v11, a3 | 0x80000000, a4, a5, a6, a7, a8);
  }
  else {
    _dispatch_queue_wakeup_with_override_slow(a1, v11, a3);
  }
}

void _dispatch_workloop_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = a1;
  uint64_t v51 = a2;
  unsigned int v50 = a3 & 0xFFEDFFFF | 0x100000;
  int v49 = 0;
  uint64_t v48 = _dispatch_workloop_invoke2;
  uint64_t v47 = a1;
  v46[8] = 0;
  *(void *)uint64_t v46 = (a3 & 1) == 0;
  uint64_t v45 = 0;
  if ((a3 & 3) == 0)
  {
    *(void *)(v47 + 16) = -1985229329;
    BOOL v44 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v43 = v47;
    unint64_t v74 = v44;
    uint64_t v73 = v47;
    int v72 = 0;
    int v71 = 0;
    v172 = v44;
    uint64_t v171 = v47;
  }
  v50 |= v49;
  if ((v50 & 2) != 0)
  {
    uint64_t v45 = 0x40020000000001;
  }
  else
  {
    uint64_t v102 = v47;
    unsigned int v101 = v50;
    uint64_t v100 = 0;
    uint64_t v100 = (uint64_t)(*(unsigned __int16 *)(v47 + 80) - 1) << 41;
    unsigned int v115 = _dispatch_thread_getspecific(3uLL);
    uint64_t v99 = v115 & 0xFFFFFFFC | 0x20000000000000;
    unint64_t v97 = 0;
    unint64_t v96 = 0;
    uint64_t v95 = 0;
    unint64_t v98 = 0xFFE00000FFFFFFFCLL;
    if (v50)
    {
      v98 |= 0x4000000000uLL;
      uint64_t v95 = 0;
    }
    else if ((v101 & 0x40000) != 0)
    {
      uint64_t v95 = 0x4000000000;
    }
    else
    {
      v98 |= 0x4000000000uLL;
      uint64_t v95 = 1;
    }
    BOOL v108 = (v101 & 2) == 0;
    uint64_t v107 = 1323;
    if ((v101 & 2) != 0) {
      _dispatch_abort(v107, v108, v8, v9, v10, v11, v12, v13);
    }
    unsigned int v94 = 0;
    unsigned int v112 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v114 = v112 & 0xF00;
    unsigned int v111 = v114 >> 8;
    unsigned int v113 = v112 & 0xF000;
    unsigned int v110 = v113 >> 12;
    int v116 = v112 & 0xF0000;
    unsigned int v109 = (v112 & 0xF0000) >> 16;
    if (v114 >> 8 <= v113 >> 12) {
      unsigned int v38 = v110;
    }
    else {
      unsigned int v38 = v111;
    }
    if (v38 <= v109)
    {
      unsigned int v36 = v109;
    }
    else
    {
      if (v111 <= v110) {
        unsigned int v37 = v110;
      }
      else {
        unsigned int v37 = v111;
      }
      unsigned int v36 = v37;
    }
    unsigned int v94 = v36;
LABEL_22:
    BOOL v93 = 0;
    BOOL v92 = (atomic_ullong *)(v102 + 56);
    unint64_t v97 = *(void *)(v102 + 56);
    do
    {
      unint64_t v96 = v97;
      if ((v97 & v98) != 0)
      {
        if (!v95) {
          break;
        }
        v96 ^= v95;
      }
      else
      {
        unint64_t v149 = v97;
        unsigned int v148 = v94;
        unint64_t v151 = v97;
        BOOL v35 = 0;
        if ((v97 & 0x1000000000) != 0)
        {
          uint64_t v150 = v149 & 0x700000000;
          BOOL v35 = v148 < (v149 & 0x700000000) >> 32;
        }
        if (v35)
        {
          unint64_t v153 = v97;
          uint64_t v154 = v97 & 0x700000000;
          unsigned int v152 = (v97 & 0x700000000) >> 32;
          unsigned int v158 = _dispatch_thread_getspecific(3uLL);
          unsigned int v157 = v152;
          if (_dispatch_set_qos_class_enabled)
          {
            unsigned int v160 = v157;
            uint64_t v159 = 0;
            if (v157) {
              uint64_t v159 = 1 << (v160 + 7);
            }
            _pthread_workqueue_override_start_direct();
          }
          unsigned int v156 = v152;
          unsigned int v155 = _dispatch_thread_getspecific(0x19uLL);
          int v161 = v155 & 0xF0000;
          if (v152 > (v155 & 0xF0000) >> 16)
          {
            unsigned int v155 = v155 & 0xFFF0FFFF | (v156 << 16);
            _dispatch_thread_setspecific(25, v155);
          }
          unsigned int v94 = v152;
          goto LABEL_22;
        }
        unint64_t v96 = v96 & 0x7700000001 | v99;
        unint64_t v104 = v97;
        if ((v97 & 0x10000000000) != 0 || v97 + v100 < 0x20000000000000) {
          v96 |= 0x40000000000000uLL;
        }
      }
      unint64_t v91 = v96;
      unint64_t v16 = v97;
      unint64_t v17 = v97;
      atomic_compare_exchange_strong_explicit(v92, &v17, v96, memory_order_acquire, memory_order_acquire);
      if (v17 != v16) {
        unint64_t v97 = v17;
      }
      BOOL v90 = v17 == v16;
      BOOL v93 = v17 == v16;
    }
    while (v17 != v16);
    BOOL v89 = v93;
    BOOL v106 = (v97 & v95) == v95;
    uint64_t v105 = 1356;
    if ((v97 & v95) != v95) {
      _dispatch_abort(v105, v106, v14, v15, a5, a6, a7, a8);
    }
    if ((v97 & v98) != 0)
    {
      uint64_t v103 = 0;
    }
    else
    {
      v96 &= v95 | 0x60000000000000;
      v97 &= 0x3FFE0000000000uLL;
      uint64_t v103 = v96 - v97;
    }
    uint64_t v45 = v103;
  }
  if (v45)
  {
    unsigned int v42 = 0;
    if ((v50 & 0x40000) != 0)
    {
      unsigned int v42 = 0;
    }
    else
    {
      int v78 = *(_DWORD *)(v47 + 84);
      unsigned int v77 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v76 = v77;
      if (v77)
      {
        if ((v78 & 0xFFF) != 0)
        {
          v76 &= 0x880F0000;
          if ((v77 & 0xFFF) <= (v78 & 0xFFFu)) {
            int v34 = v78 & 0xFFF;
          }
          else {
            int v34 = v77 & 0xFFF;
          }
          v76 |= v34;
          unsigned int v80 = v78 & 0xF000;
          unsigned int v82 = v76 & 0xF00;
          if (v80 >> 12 <= v82 >> 8) {
            v78 &= 0x40000000u;
          }
          else {
            v78 &= 0x4400F000u;
          }
          v76 |= v78;
        }
        else
        {
          if ((v76 & 0xFFF) != 0) {
            v76 |= 0x40000000u;
          }
          unsigned int v79 = v78 & 0xF000;
          unsigned int v81 = v76 & 0xF00;
          if (v79 >> 12 > v81 >> 8) {
            unsigned int v76 = v76 & 0xFFFF0FFF | v78 & 0x400F000;
          }
        }
      }
      else
      {
        unsigned int v76 = v78 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v76);
      unsigned int v42 = v77;
    }
    if ((v50 & 0x100000) != 0)
    {
      uint64_t v56 = v52;
      int v55 = 0;
      int v54 = *(_DWORD *)(v52 + 80);
      int v55 = v54;
      int v53 = v54;
      if ((v54 & 0x400000) != 0)
      {
        uint64_t v68 = v52;
        int v67 = 0x400000;
        int v65 = -4194305;
        int v64 = -4194305;
        int v66 = -4194305;
        int v60 = -4194305;
        int v59 = -4194305;
        int v61 = -4194305;
        unsigned int v58 = atomic_fetch_and_explicit((atomic_uint *volatile)(v52 + 80), 0xFFBFFFFF, memory_order_relaxed);
        unsigned int v62 = v58;
        unsigned int v57 = v58;
        unsigned int v63 = v58 & 0xFFBFFFFF;
      }
    }
    uint64_t v41 = v47;
    uint64_t v119 = v47;
    unsigned int v118 = v50;
    int v117 = 0;
    uint64_t v164 = v47;
    uint64_t v163 = 256;
    uint64_t v170 = 1;
    uint64_t v169 = 730;
    int v162 = 0;
    uint64_t v168 = v47;
    int v167 = 0;
    int v166 = *(_DWORD *)(v47 + 80);
    int v167 = v166;
    int v165 = v166;
    int v162 = v166 & 0x30000;
    int v117 = (v166 & 0x30000) << 8;
    if (v117) {
      unsigned int v118 = v118 & 0xFCFFFFFF | v117;
    }
    unsigned int v50 = v118;
    do
    {
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v51);
      }
      uint64_t v40 = v47;
      *(void *)&v46[1] = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t *))v48)(v47, v51, v50, &v45);
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0)
      {
        long long v39 = 0uLL;
        uint64_t v84 = v47;
        uint64_t v83 = &v39;
        int v88 = &v39;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v39, v19, a5, a6, a7, a8);
        _dispatch_thread_setspecific_pair(20, v84, 21, (uint64_t)v83, v20, v21, v22, v23);
        _dispatch_last_resort_autorelease_pool_pop(v51);
        uint64_t v85 = &v39;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v39, v24, v25, v26, v27, v28);
      }
      BOOL v70 = *(void *)&v46[1] != 1;
      uint64_t v69 = 2018;
      if (*(void *)&v46[1] == 1) {
        _dispatch_abort(v69, v70, v18, v19, a5, a6, a7, a8);
      }
      BOOL v33 = 0;
      if (*(void *)&v46[1]) {
        BOOL v33 = *(void *)&v46[1] != -1;
      }
      if (v33) {
        break;
      }
      uint64_t v139 = v47;
      uint64_t v138 = v45;
      BOOL v137 = *(void *)&v46[1] == 0;
      uint64_t v136 = 0;
      unint64_t v135 = 0;
      BOOL v134 = 0;
      unsigned int v133 = (atomic_ullong *)(v47 + 56);
      uint64_t v136 = *(void *)(v47 + 56);
      do
      {
        unint64_t v135 = (v136 - v138) & 0xFFFFFFF700000001;
        uint64_t v141 = v136;
        if ((v136 & 0xFF80000000000000) == 0)
        {
          uint64_t v142 = v136;
          if ((v136 & 0x8000000000) != 0)
          {
            uint64_t v131 = 0x8000000000;
            uint64_t v130 = 0x8000000000;
            uint64_t v132 = 0x8000000000;
            unint64_t v128 = 0;
            uint64_t v126 = 0x8000000000;
            uint64_t v125 = 0x8000000000;
            uint64_t v127 = 0x8000000000;
            xor_unint64_t explicit = atomic_fetch_xor_explicit((atomic_ullong *volatile)(v139 + 56), 0x8000000000uLL, memory_order_acquire);
            unint64_t v128 = xor_explicit;
            unint64_t v123 = xor_explicit;
            unint64_t v129 = xor_explicit ^ v132;
            char v140 = 0;
            goto LABEL_101;
          }
          if (v137) {
            v135 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v135 |= 0x8000000000uLL;
          }
        }
        unint64_t v122 = v135;
        uint64_t v29 = v136;
        uint64_t v30 = v136;
        atomic_compare_exchange_strong_explicit(v133, (unint64_t *)&v30, v135, memory_order_release, memory_order_relaxed);
        if (v30 != v29) {
          uint64_t v136 = v30;
        }
        BOOL v121 = v30 == v29;
        BOOL v134 = v30 == v29;
      }
      while (v30 != v29);
      BOOL v120 = v134;
      uint64_t v144 = v136;
      uint64_t v146 = v136;
      BOOL v32 = 0;
      if ((v136 & 0x1000000000) != 0) {
        BOOL v32 = (v144 & 0x800000000) != 0;
      }
      if (v32)
      {
        uint64_t v143 = v136 & 0x700000000;
        uint64_t v145 = v136 & 0x700000000;
        LODWORD(v145) = _dispatch_thread_getspecific(0x19uLL);
        int v147 = v145 & 0xF0000;
        if (HIDWORD(v145) > (v145 & 0xF0000) >> 16)
        {
          LODWORD(v145) = v145 & 0xFFF0FFFF;
          LODWORD(v145) = v145 | (HIDWORD(v145) << 16);
          _dispatch_thread_setspecific(25, v145);
        }
      }
      char v140 = 1;
LABEL_101:
      if (v140)
      {
        uint64_t v45 = 0;
        *(void *)&v46[1] = 0;
        break;
      }
      *(void *)&v46[1] = _dispatch_thread_getspecific(0x14uLL);
      uint64_t v31 = 0;
      if (**(void **)&v46[1]) {
        uint64_t v31 = **(void **)&v46[1];
      }
    }
    while ((*(void *)(v31 + 16) & 0x10000) != 0 || (v46[0] & 1) == 0);
    if ((v50 & 0x40000) == 0)
    {
      unsigned int v87 = v42;
      unsigned int v86 = 0;
      unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
      v87 &= 0xFFF0FFFF;
      v87 |= v86 & 0xF0000;
      _dispatch_thread_setspecific(25, v87);
    }
  }
  if (v46[0])
  {
    uint64_t v75 = v47;
    uint64_t v173 = v47;
    int v178 = 772079660;
    uint64_t v177 = v47;
    uint64_t v176 = 0;
    uint64_t v175 = 0;
    uint64_t v174 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v179 = v75;
  }
  if (*(void *)&v46[1]) {
    _dispatch_queue_invoke_finish(v47, v51, *(uint64_t (****)())&v46[1], v45, a5, a6, a7, a8);
  }
  else {
    _dispatch_release_2_tailcall(v47);
  }
}

uint64_t _dispatch_workloop_invoke2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = a1;
  uint64_t v34 = a2;
  int v33 = a3;
  BOOL v32 = (void *)a4;
  uint64_t v31 = 0;
  uint64_t v31 = *(_DWORD **)(a1 + 200);
  long long v30 = 0uLL;
  if (v31 && (*v31 & 0x20) != 0)
  {
    unsigned int v50 = v31 + 10;
    _dispatch_thread_setspecific(24, (uint64_t)(v31 + 10));
  }
  uint64_t v41 = v35;
  uint64_t v40 = &v30;
  BOOL v44 = &v30;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v30, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v41, 21, (uint64_t)v40, v8, v9, v10, v11);
  do
  {
LABEL_5:
    for (unsigned int i = 6; i && !*(void *)(v35 + 152 + 8 * (int)(i - 1)); --i)
      ;
    if (!i)
    {
      *BOOL v32 = (*v32 & 1) + 0x40020000000000;
      uint64_t v43 = &v30;
      _dispatch_thread_setspecific_packed_pair(20, 21, &v30, v12, v13, v14, v15, v16);
      uint64_t v49 = 0;
      _dispatch_thread_setspecific(24, 0);
      return 0;
    }
    uint64_t v71 = v35;
    unsigned int v70 = i;
    uint64_t v69 = 0;
    unint64_t v68 = 0;
    unsigned int v74 = i;
    unint64_t v67 = (unint64_t)i << 32;
    BOOL v66 = 0;
    int v65 = (atomic_ullong *)(v35 + 56);
    uint64_t v69 = *(void *)(v35 + 56);
    do
    {
      if ((v69 & 0x700000000uLL) <= v67)
      {
        char v72 = 1;
        goto LABEL_22;
      }
      uint64_t v73 = v69;
      if ((v69 & 0x8000000000) != 0)
      {
        uint64_t v63 = 0x8000000000;
        uint64_t v62 = 0x8000000000;
        uint64_t v64 = 0x8000000000;
        unint64_t v60 = 0;
        uint64_t v58 = 0x8000000000;
        uint64_t v57 = 0x8000000000;
        uint64_t v59 = 0x8000000000;
        xor_unint64_t explicit = atomic_fetch_xor_explicit((atomic_ullong *volatile)(v71 + 56), 0x8000000000uLL, memory_order_acquire);
        unint64_t v60 = xor_explicit;
        unint64_t v55 = xor_explicit;
        unint64_t v61 = xor_explicit ^ v64;
        char v72 = 0;
        goto LABEL_22;
      }
      unint64_t v68 = v69 & 0xFFFFFFF8FFFFFFFFLL | v67;
      unint64_t v54 = v68;
      uint64_t v17 = v69;
      uint64_t v18 = v69;
      atomic_compare_exchange_strong_explicit(v65, (unint64_t *)&v18, v68, memory_order_relaxed, memory_order_relaxed);
      if (v18 != v17) {
        uint64_t v69 = v18;
      }
      BOOL v53 = v18 == v17;
      BOOL v66 = v18 == v17;
    }
    while (v18 != v17);
    BOOL v52 = v66;
    uint64_t v51 = 0;
    uint64_t v51 = _dispatch_thread_getspecific(0x1DuLL);
    if (v51)
    {
      v51[45] = v51[45] & 0xFD | 2;
      _dispatch_return_to_kernel();
    }
    char v72 = 1;
LABEL_22:
    ;
  }
  while (((v72 ^ 1) & 1) != 0);
  *(unsigned char *)(v35 + 100) = i;
  uint64_t v27 = (unint64_t *)(v35 + 104 + 8 * (int)(i - 1));
  uint64_t v26 = *v27;
  if (!*v27) {
    uint64_t v26 = _dispatch_wait_for_enqueuer(v27);
  }
  uint64_t v29 = (void *)v26;
  while (1)
  {
    uint64_t v45 = v29;
    uint64_t v47 = v29;
    if (*v29 <= 0xFFFuLL && (*v45 & 1) != 0) {
      break;
    }
    uint64_t v25 = (void *)v29[2];
    *(void *)(v35 + 104 + 8 * (int)(i - 1)) = v25;
    if (!v25)
    {
      uint64_t v23 = (atomic_ullong *)(v35 + 152 + 8 * (int)(i - 1));
      for (uint64_t j = *(void *)v23; ; uint64_t j = v19)
      {
        uint64_t v39 = j;
        if (v29 != (void *)(j & 0xFFFFFFFFFFFFFFF8)) {
          break;
        }
        uint64_t v19 = j;
        atomic_compare_exchange_strong_explicit(v23, (unint64_t *)&v19, 0, memory_order_release, memory_order_relaxed);
        if (v19 == j) {
          goto LABEL_40;
        }
      }
      uint64_t v22 = v29[2];
      if (!v22) {
        uint64_t v22 = _dispatch_wait_for_enqueuer(v29 + 2);
      }
      uint64_t v25 = (void *)v22;
      *(void *)(v35 + 104 + 8 * (int)(i - 1)) = v22;
    }
LABEL_40:
    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    _dispatch_continuation_pop_inline(v29, v34, v33, v35);
    unsigned int i = *(unsigned __int8 *)(v35 + 100);
    uint64_t v29 = v25;
    BOOL v21 = 0;
    if (v25)
    {
      uint64_t v37 = v35;
      unint64_t v38 = (unint64_t)*(unsigned int *)(v35 + 60) << 32;
      v38 &= 0x700000000uLL;
      BOOL v21 = HIDWORD(v38) <= i;
    }
    if (!v21) {
      goto LABEL_5;
    }
  }
  *(_DWORD *)(v34 + 16) = i;
  *(void *)(v34 + 8) = v29;
  *(unsigned char *)(v35 + 100) = 0;
  unsigned int v42 = &v30;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v30, v12, v13, v14, v15, v16);
  uint64_t v48 = 0;
  _dispatch_thread_setspecific(24, 0);
  return *(void *)(v35 + 24);
}

void _dispatch_workloop_barrier_complete(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v20 = 0;
LABEL_2:
  for (unsigned int i = 6; i; --i)
  {
    if (*(void *)(a1 + 152 + 8 * (int)(i - 1)))
    {
      uint64_t v18 = (unint64_t *)(a1 + 104 + 8 * (int)(i - 1));
      uint64_t v17 = (void *)*v18;
      if (!*v18) {
        uint64_t v17 = (void *)_dispatch_wait_for_enqueuer(v18);
      }
      if (*v17 <= 0xFFFuLL && (*v17 & 0x81) != 0)
      {
        _dispatch_workloop_drain_barrier_waiter(a1, v17, i, a3, 0);
        return;
      }
      uint64_t v20 = 1;
    }
  }
  BOOL v14 = 0;
  if (v20) {
    BOOL v14 = (a3 & 1) == 0;
  }
  if (v14)
  {
    _dispatch_retain_2(a1);
    a3 |= 1u;
  }
LABEL_18:
  for (unint64_t j = *(void *)(a1 + 56); ; unint64_t j = v4)
  {
    if ((j & 0x2000000000) != 0 && (j & 2) != 0 && (j & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFF7FFFFFFFDLL, memory_order_relaxed);
      goto LABEL_18;
    }
    unint64_t v27 = j;
    unint64_t v26 = (unint64_t)a2 << 32;
    if ((j & 0x700000000) < v26)
    {
      unint64_t v27 = j & 0xFFFFFFF8FFFFFFFFLL | v26;
      if (j & 0x1000000000 | v26 & 0x1000000000) {
        v27 |= 0x800000000uLL;
      }
    }
    if (v20)
    {
      unint64_t v15 = (v27 - 0x40020000000000) & 0xFFFFFFF700000000 | 1;
    }
    else
    {
      if ((j & 0x8000000000) != 0)
      {
        atomic_fetch_xor_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_acquire);
        goto LABEL_2;
      }
      unint64_t v15 = (j & 0x2000000000) != 0
          ? (v27 - 0x40020000000000) & 0xFFFFFFF000000000
          : (v27 - 0x40020000000000) & 0xFFFFFFF000000001;
    }
    unint64_t v3 = j;
    unint64_t v4 = j;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v4, v15, memory_order_release, memory_order_relaxed);
    if (v4 == v3) {
      break;
    }
  }
  BOOL v11 = ((j ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
  if (!v11) {
    _dispatch_abort(4827, v11, v5, v6, v7, v8, v9, v10);
  }
  if ((j & 0x4000000000) != 0) {
    _dispatch_abort(4828, (j & 0x4000000000) == 0, v5, v6, v7, v8, v9, v10);
  }
  if ((j & 0x2000000000) != 0)
  {
    if ((v15 & 0x4000000000) != 0) {
      _dispatch_abort(4845, (v15 & 0x4000000000) == 0, v5, v6, v7, v8, v9, v10);
    }
    if ((j & 1) != 0 || (v15 & 1) != 0 || (j & 2) == 0)
    {
      _dispatch_event_loop_end_ownership(a1, j, v15, a3, v7, v8, v9, v10);
      return;
    }
    _dispatch_event_loop_assert_not_owned(a1);
    goto LABEL_83;
  }
  BOOL v13 = 0;
  if ((j & 0x1000000000) != 0) {
    BOOL v13 = (j & 0x800000000) != 0;
  }
  if (v13)
  {
    unsigned int v24 = _dispatch_thread_getspecific(0x19uLL);
    if ((BYTE4(j) & 7u) > (v24 & 0xF0000) >> 16) {
      _dispatch_thread_setspecific(25, v24 & 0xFFF0FFFF | ((BYTE4(j) & 7) << 16));
    }
  }
  if (!v20) {
    goto LABEL_83;
  }
  if ((j ^ v15))
  {
    if ((v15 & 0x4000000001) == 0) {
      _dispatch_abort(4864, (v15 & 0x4000000001) != 0, v5, v6, v7, v8, v9, v10);
    }
    uint64_t v25 = *(uint64_t **)(a1 + 24);
    if ((a3 & 1) == 0) {
      _dispatch_abort(1929, a3 & 1, v5, v6, v7, v8, v9, v10);
    }
    if ((v15 & 0x2000000000) != 0)
    {
      _dispatch_event_loop_poke(a1, v15, 1, v6, v7, v8, v9, v10);
    }
    else
    {
      uint64_t v12 = 0;
      if (*v25) {
        uint64_t v12 = *v25;
      }
      (*(void (**)(uint64_t *, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(v12 + 72))(v25, a1, (v15 & 0x700000000) >> 32, v6, v7, v8);
    }
    return;
  }
  if ((v15 & 0xFF80000000000000) != 0 || (v15 & 0x4000000000) != 0 || (v15 & 1) == 0 && (v15 & 0xFFFFFFFC) == 0)
  {
LABEL_83:
    if (a3) {
      _dispatch_release_2_tailcall(a1);
    }
    return;
  }
  BOOL v29 = (v15 & 0xFF80000000000000) == 0 && (v15 & 0x4000000000) == 0 && ((v15 & 1) != 0 || (v15 & 0xFFFFFFFC) != 0);
  if (!v29) {
    _dispatch_abort(5301, v29, v5, v6, v7, v8, v9, v10);
  }
  if ((v15 & 0x2000000000) != 0) {
    _dispatch_event_loop_poke(a1, v15, a3 | 0x80000000, v6, v7, v8, v9, v10);
  }
  else {
    _dispatch_queue_wakeup_with_override_slow(a1, v15, a3);
  }
}

void _dispatch_workloop_push(uint64_t a1, void *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a3;
  if (*a2 <= 0xFFFuLL && (*a2 & 0x81) != 0)
  {
    _dispatch_workloop_push_waiter(a1, (unint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    if (a3 < (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8) {
      unsigned int v9 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
    }
    if (!v9) {
      unsigned int v9 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    }
    a2[2] = 0;
    _dispatch_thread_setspecific(122, a1 + 152 + 8 * (int)(v9 - 1));
    unint64_t v8 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 152 + 8 * (int)(v9 - 1)), (unint64_t)a2, memory_order_release);
    if (v8)
    {
      *(void *)(v8 + 16) = a2;
    }
    else
    {
      _dispatch_retain_2_unsafe(a1);
      *(void *)(a1 + 104 + 8 * (int)(v9 - 1)) = a2;
    }
    _dispatch_thread_setspecific(122, 0);
    if (!v8) {
      _dispatch_workloop_wakeup(a1, v9, 3);
    }
  }
}

void _dispatch_workloop_push_waiter(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v32 = a3;
  uint64_t v39 = *(void *)(a2 + 8);
  if ((v39 & 0x20000000) != 0) {
    _dispatch_abort(458, (*(void *)(a2 + 8) & 0x20000000) == 0, a3, a4, a5, a6, a7, a8);
  }
  unsigned int v8 = (v39 & 0x3FFF00uLL) >> 8;
  __int16 v9 = __clz(__rbit32(v8));
  if (v8) {
    __int16 v10 = v9 + 1;
  }
  else {
    __int16 v10 = 0;
  }
  if (a3 < (unsigned __int16)((v10 << 8) & 0xF00) >> 8) {
    unsigned int v32 = (unsigned __int16)((v10 << 8) & 0xF00) >> 8;
  }
  if (!v32) {
    unsigned int v32 = 4;
  }
  *(void *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, a1 + 152 + 8 * (int)(v32 - 1));
  unint64_t v31 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 152 + 8 * (int)(v32 - 1)), a2, memory_order_release);
  if (v31) {
    *(void *)(v31 + 16) = a2;
  }
  else {
    *(void *)(a1 + 104 + 8 * (int)(v32 - 1)) = a2;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v31)
  {
    if ((*(void *)a2 & 0x80) == 0) {
      goto LABEL_19;
    }
    unint64_t v35 = *(void *)(a1 + 24);
    BOOL v21 = 0;
    if (v35 >= (unint64_t)&_dispatch_root_queues) {
      BOOL v21 = v35 < (unint64_t)&unk_F0A80;
    }
    if (v21)
    {
LABEL_19:
      unint64_t v29 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002;
      for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v18)
      {
        unint64_t v37 = i;
        unint64_t v36 = (unint64_t)v32 << 32;
        if ((i & 0x700000000) < v36)
        {
          unint64_t v37 = i & 0xFFFFFFF8FFFFFFFFLL | v36;
          if (i & 0x1000000000 | v36 & 0x1000000000) {
            v37 |= 0x800000000uLL;
          }
        }
        unint64_t v27 = v37 | 0x8000000000;
        if ((i & 0xFFFFFFFC) == 0 && (i & 0x4000000001) == 0) {
          unint64_t v27 = v37 & 0x7700000001 | v29;
        }
        unint64_t v17 = i;
        unint64_t v18 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v18, v27, memory_order_release, memory_order_relaxed);
        if (v18 == v17) {
          break;
        }
      }
      if ((v27 & 0x2000000000) != 0 && *(void *)(a2 + 48) != -4)
      {
        int v20 = *(_DWORD *)(a2 + 100);
        *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xFB | (4
                                                            * (v20 == _dispatch_thread_getspecific(3uLL)));
      }
      if (((i ^ v27) & 0x40000000000000) != 0)
      {
        if ((*(unsigned char *)(a2 + 106) & 4) == 0) {
          goto LABEL_48;
        }
        unint64_t v26 = (unint64_t *)(a1 + 104 + 8 * (int)(v32 - 1));
        uint64_t v25 = *v26;
        if (!*v26) {
          uint64_t v25 = _dispatch_wait_for_enqueuer(v26);
        }
        if (v25 == a2)
        {
          *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xF7 | 8;
          if ((*(void *)a2 & 0x80) != 0) {
            *(void *)(a2 + 56) = a1;
          }
          uint64_t v24 = *(void *)(a2 + 16);
          *(void *)(a1 + 104 + 8 * (int)(v32 - 1)) = v24;
          if (!v24)
          {
            for (uint64_t j = *(void *)(a1 + 152 + 8 * (int)(v32 - 1)); a2 == (j & 0xFFFFFFFFFFFFFFF8); uint64_t j = v19)
            {
              uint64_t v19 = j;
              atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 152 + 8 * (int)(v32 - 1)), (unint64_t *)&v19, 0, memory_order_release, memory_order_relaxed);
              if (v19 == j) {
                return;
              }
            }
            uint64_t v22 = *(void *)(a2 + 16);
            if (!v22) {
              uint64_t v22 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16));
            }
            *(void *)(a1 + 104 + 8 * (int)(v32 - 1)) = v22;
          }
        }
        else
        {
LABEL_48:
          _dispatch_workloop_barrier_complete(a1, v32, 0);
        }
      }
      else if (((i ^ v27) & 0x700000000) != 0)
      {
        if ((v27 & 0xFF80000000000000) != 0 || (v27 & 0x4000000000) != 0) {
          BOOL v40 = 0;
        }
        else {
          BOOL v40 = (v27 & 1) != 0 || (v27 & 0x2000000000) == 0 && (v27 & 0xFFFFFFFC) != 0;
        }
        if (v40)
        {
          BOOL v38 = (v27 & 0xFF80000000000000) == 0
             && (v27 & 0x4000000000) == 0
             && ((v27 & 1) != 0 || (v27 & 0xFFFFFFFC) != 0);
          if (!v38) {
            _dispatch_abort(5301, v38, v11, v12, v13, v14, v15, v16);
          }
          if ((v27 & 0x2000000000) != 0) {
            _dispatch_event_loop_poke(a1, v27, 0x80000000, v12, v13, v14, v15, v16);
          }
          else {
            _dispatch_queue_wakeup_with_override_slow(a1, v27, 0);
          }
        }
      }
    }
    else
    {
      *(void *)(a2 + 56) = a1;
      *(void *)a2 &= ~0x80uLL;
      _dispatch_retain_2_unsafe(a1);
      _dispatch_workloop_wakeup(a1, v32, 3);
    }
  }
}

uint64_t _dispatch_retain_2_unsafe(uint64_t a1)
{
  return _dispatch_retain_n_unsafe(a1, 2u);
}

uint64_t dispatch_thread_get_current_override_qos_floor()
{
  uint64_t v7 = 0;
  uint64_t v0 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v9 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
  if ((unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8 <= v9) {
    unsigned int v6 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
  }
  else {
    unsigned int v6 = (unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8;
  }
  if (v6 <= (v0 & 0xF0000) >> 16)
  {
    unsigned int v4 = (v0 & 0xF0000) >> 16;
  }
  else
  {
    if ((unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8 <= v9) {
      int v5 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
    }
    else {
      int v5 = (unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8;
    }
    unsigned int v4 = v5;
  }
  if (v4 != 15)
  {
    LODWORD(v7) = 1;
    if (v4 <= 1)
    {
      uint64_t v2 = v4 - 1;
      char v1 = 0;
    }
    else
    {
      uint64_t v2 = v4 - 1;
      char v1 = 1;
    }
    if (v1)
    {
      int v8 = 0;
    }
    else
    {
      switch(v2)
      {
        case 0:
          int v8 = 5;
          break;
        case 1:
          int v8 = 9;
          break;
        case 2:
          int v8 = 17;
          break;
        case 3:
          int v8 = 21;
          break;
        case 4:
          int v8 = 25;
          break;
        case 5:
          int v8 = 33;
          break;
        default:
          JUMPOUT(0);
      }
    }
    HIDWORD(v7) = v8;
  }
  return v7;
}

uint64_t dispatch_thread_override_self(unsigned int a1)
{
  if (a1 <= 5)
  {
    uint64_t v2 = a1 - 5;
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = a1 - 5;
    char v1 = 1;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        unsigned int v4 = 1;
        goto LABEL_13;
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 17:
      case 18:
      case 19:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        break;
      case 4:
        unsigned int v4 = 2;
        goto LABEL_13;
      case 12:
        unsigned int v4 = 3;
        goto LABEL_13;
      case 16:
        unsigned int v4 = 4;
        goto LABEL_13;
      case 20:
        unsigned int v4 = 5;
        goto LABEL_13;
      case 28:
        unsigned int v4 = 6;
        goto LABEL_13;
      default:
        JUMPOUT(0);
    }
  }
  unsigned int v4 = 0;
LABEL_13:
  _dispatch_thread_getspecific(3uLL);
  if (_dispatch_set_qos_class_enabled) {
    _pthread_workqueue_override_start_direct();
  }
  unsigned int v5 = _dispatch_thread_getspecific(0x19uLL);
  if (v4 > (v5 & 0xF0000) >> 16) {
    _dispatch_thread_setspecific(25, v5 & 0xFFF0FFFF | (v4 << 16));
  }
  return 0;
}

uint64_t dispatch_lock_override_start_with_debounce(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3 <= 5)
  {
    uint64_t v4 = a3 - 5;
    char v3 = 0;
  }
  else
  {
    uint64_t v4 = a3 - 5;
    char v3 = 1;
  }
  if ((v3 & 1) == 0)
  {
    switch(v4)
    {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
        break;
      default:
        JUMPOUT(0);
    }
  }
  if (_dispatch_set_qos_class_enabled) {
    return _pthread_workqueue_override_start_direct_check_owner();
  }
  else {
    return 0;
  }
}

uint64_t dispatch_lock_override_end(unsigned int a1)
{
  if (a1 <= 5)
  {
    uint64_t v2 = a1 - 5;
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = a1 - 5;
    char v1 = 1;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        unsigned int v4 = 1;
        goto LABEL_13;
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 17:
      case 18:
      case 19:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        break;
      case 4:
        unsigned int v4 = 2;
        goto LABEL_13;
      case 12:
        unsigned int v4 = 3;
        goto LABEL_13;
      case 16:
        unsigned int v4 = 4;
        goto LABEL_13;
      case 20:
        unsigned int v4 = 5;
        goto LABEL_13;
      case 28:
        unsigned int v4 = 6;
        goto LABEL_13;
      default:
        JUMPOUT(0);
    }
  }
  unsigned int v4 = 0;
LABEL_13:
  unsigned int v5 = _dispatch_thread_getspecific(0x19uLL);
  if (v4 > (v5 & 0xF0000) >> 16) {
    _dispatch_thread_setspecific(25, v5 & 0xFFF0FFFF | (v4 << 16));
  }
  return 0;
}

void _dispatch_queue_wakeup(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v24 = a3;
  uint64_t v23 = (uint64_t (***)())a4;
  uint64_t v19 = 1;
  if (a4 == -1) {
    _dispatch_abort(5360, 0, a3, -1, a5, a6, a7, a8);
  }
  if (a4 && (a3 & 1) == 0)
  {
    _dispatch_retain_2(a1);
    v24 |= 1u;
  }
  if ((v24 & 4) != 0)
  {
    uint64_t v17 = 0;
    if (*(void *)a1) {
      uint64_t v17 = *(void *)a1;
    }
    if (*(unsigned char *)(v17 + 16) != 19) {
      _dispatch_abort(5378, *(unsigned __int8 *)(v17 + 16) == 19, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v31 = a2;
    if (!a2) {
      unsigned int v31 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    }
    if (v31 <= (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8) {
      unsigned int v16 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
    }
    else {
      unsigned int v16 = v31;
    }
    _dispatch_lane_class_barrier_complete(a1, v16, v24, v23, 0x40020000000000);
    return;
  }
  if (v23)
  {
    if (v23 == &_dispatch_mgr_q) {
      uint64_t v19 = 0x4000000000;
    }
    unsigned int v30 = a2;
    if (!a2) {
      unsigned int v30 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    }
    if (v30 <= (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8) {
      unsigned int v15 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
    }
    else {
      unsigned int v15 = v30;
    }
    for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v9)
    {
      unint64_t v29 = i;
      unint64_t v28 = (unint64_t)v15 << 32;
      if ((i & 0x700000000) < v28)
      {
        unint64_t v29 = i & 0xFFFFFFF8FFFFFFFFLL | v28;
        if (i & 0x1000000000 | v28 & 0x1000000000) {
          v29 |= 0x800000000uLL;
        }
      }
      unint64_t v20 = v29;
      if ((v24 & 0x20) != 0 && (i & 0x180000000000000) == 0x80000000000000) {
        unint64_t v20 = v29 & 0xFF7FFFFFFFFFFFFFLL;
      }
      BOOL v14 = 0;
      if ((v20 & 0xFF80000000000000) == 0)
      {
        BOOL v14 = 0;
        if ((i & 0x4000000001) == 0)
        {
          BOOL v13 = 1;
          if ((i & 0xFFFFFFFC) != 0) {
            BOOL v13 = v19 != 0x4000000000;
          }
          BOOL v14 = v13;
        }
      }
      if (v14) {
        v20 |= v19;
      }
      if ((v24 & 2) != 0)
      {
        v20 |= 0x8000000000uLL;
      }
      else if (v20 == i)
      {
        goto LABEL_95;
      }
      unint64_t v8 = i;
      unint64_t v9 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v9, v20, memory_order_release, memory_order_relaxed);
      if (v9 == v8) {
        break;
      }
    }
LABEL_63:
    if (((i ^ v20) & v19) != 0)
    {
      if (v23 == (uint64_t (***)())((char *)&def_131C + 1)) {
        unint64_t v18 = *(uint64_t (****)())(a1 + 24);
      }
      else {
        unint64_t v18 = v23;
      }
      if ((v20 & 0x4000000001) == 0) {
        _dispatch_abort(5519, (v20 & 0x4000000001) != 0, a3, a4, a5, a6, a7, a8);
      }
      if ((v24 & 1) == 0) {
        _dispatch_abort(1929, v24 & 1, a3, a4, a5, a6, a7, a8);
      }
      if ((v20 & 0x2000000000) != 0)
      {
        _dispatch_event_loop_poke(a1, v20, 1, a4, a5, a6, a7, a8);
      }
      else
      {
        uint64_t v12 = 0;
        if (*v18) {
          uint64_t v12 = *v18;
        }
        ((void (*)(uint64_t (***)(), uint64_t, unint64_t, uint64_t))v12[9])(v18, a1, (v20 & 0x700000000) >> 32, a4);
      }
      return;
    }
    if (((i ^ v20) & 0x700000000) != 0
      && (v20 & 0xFF80000000000000) == 0
      && (v20 & 0x4000000000) == 0
      && ((v20 & 1) != 0 || (v20 & 0xFFFFFFFC) != 0))
    {
      if ((v20 & 0xFF80000000000000) != 0 || (v20 & 0x4000000000) != 0 || (v20 & 1) == 0 && (v20 & 0xFFFFFFFC) == 0) {
        _dispatch_abort(5301, 0, a3, a4, a5, a6, a7, a8);
      }
      if ((v20 & 0x2000000000) != 0) {
        _dispatch_event_loop_poke(a1, v20, v24 | 0x80000000, a4, a5, a6, a7, a8);
      }
      else {
        _dispatch_queue_wakeup_with_override_slow(a1, v20, v24);
      }
      return;
    }
  }
  else if (a2)
  {
    for (unint64_t i = *(void *)(a1 + 56); (i & 0xFFFFFFFC) != 0 || (i & 0x4000000001) != 0; unint64_t i = v11)
    {
      unint64_t v27 = i;
      unint64_t v26 = (unint64_t)a2 << 32;
      if ((i & 0x700000000) < v26)
      {
        unint64_t v27 = i & 0xFFFFFFF8FFFFFFFFLL | v26;
        if (i & 0x1000000000 | v26 & 0x1000000000) {
          v27 |= 0x800000000uLL;
        }
      }
      unint64_t v20 = v27;
      if ((i & 0x2000000000) != 0 && (i & 0xFF80000000000000) == 0 && (i & 0x4000000000) == 0) {
        unint64_t v20 = v27 | 1;
      }
      if (v20 == i) {
        break;
      }
      unint64_t v10 = i;
      unint64_t v11 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v11, v20, memory_order_relaxed, memory_order_relaxed);
      if (v11 == v10)
      {
        uint64_t v23 = (uint64_t (***)())(&def_131C + 1);
        if (((i ^ v20) & 1) != 0 && (v24 & 1) == 0)
        {
          _dispatch_retain_2(a1);
          v24 |= 1u;
        }
        goto LABEL_63;
      }
    }
  }
LABEL_95:
  if (v24) {
    _dispatch_release_2_tailcall(a1);
  }
}

void _dispatch_lane_class_barrier_complete(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t (***a4)(), uint64_t a5)
{
  if (a4 == &_dispatch_mgr_q)
  {
    unint64_t v18 = &_dispatch_mgr_q;
    uint64_t v19 = 0x4000000000;
  }
  else if (a4)
  {
    if (a4 == (uint64_t (***)())((char *)&def_131C + 1)) {
      uint64_t v17 = *(uint64_t (****)())(a1 + 24);
    }
    else {
      uint64_t v17 = a4;
    }
    unint64_t v18 = v17;
    uint64_t v19 = 1;
  }
  else
  {
    unint64_t v18 = 0;
    uint64_t v19 = 0;
  }
LABEL_9:
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v6)
  {
    if ((i & 0x2000000000) != 0 && (i & 2) != 0 && (i & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFF7FFFFFFFDLL, memory_order_relaxed);
      goto LABEL_9;
    }
    unint64_t v30 = i - a5;
    unint64_t v29 = (unint64_t)a2 << 32;
    if (((i - a5) & 0x700000000uLL) < v29)
    {
      unint64_t v30 = v30 & 0xFFFFFFF8FFFFFFFFLL | v29;
      if ((v30 & 0x1000000000) != 0) {
        v30 |= 0x800000000uLL;
      }
    }
    unint64_t v20 = v30 & 0xFFFFFFF700000001;
    if ((i & 0xFF80000000000000) != 0)
    {
      if ((i & 0x2000000000) != 0) {
        unint64_t v20 = v30 & 0xFFFFFFF700000000;
      }
    }
    else if (v19)
    {
      if ((i & 0x4000000001) == 0) {
        v20 |= v19;
      }
    }
    else
    {
      if ((i & 0x8000000000) != 0)
      {
        atomic_fetch_xor_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_acquire);
        unsigned int v25 = a3 | 4;
        uint64_t v16 = 0;
        if (*(void *)a1) {
          uint64_t v16 = *(void *)a1;
        }
        (*(void (**)(uint64_t, void, void))(v16 + 64))(a1, a2, v25);
        return;
      }
      unint64_t v20 = v30 & 0xFFFFFFF000000001;
    }
    uint64_t v5 = i;
    uint64_t v6 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v6, v20, memory_order_release, memory_order_relaxed);
    if (v6 == v5) {
      break;
    }
  }
  uint64_t v22 = i - a5;
  BOOL v13 = ((v22 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
  if (!v13) {
    _dispatch_abort(1424, v13, v7, v8, v9, v10, v11, v12);
  }
  if ((v22 & 0x4000000000) != 0) {
    _dispatch_abort(1425, (v22 & 0x4000000000) == 0, v7, v8, v9, v10, v11, v12);
  }
  if ((v22 & 0x2000000000) == 0)
  {
    BOOL v15 = 0;
    if ((v22 & 0x1000000000) != 0) {
      BOOL v15 = (v22 & 0x800000000) != 0;
    }
    if (v15)
    {
      unsigned int v28 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v22) & 7u) > (v28 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25, v28 & 0xFFF0FFFF | ((BYTE4(v22) & 7) << 16));
      }
    }
    if (v18)
    {
      if (((v22 ^ v20) & v19) != 0)
      {
        if ((v20 & 0x4000000001) == 0) {
          _dispatch_abort(1464, (v20 & 0x4000000001) != 0, v7, v8, v9, v10, v11, v12);
        }
        if ((a3 & 1) == 0) {
          _dispatch_abort(1929, a3 & 1, v7, v8, v9, v10, v11, v12);
        }
        if ((v20 & 0x2000000000) != 0)
        {
          _dispatch_event_loop_poke(a1, v20, 1, v8, v9, v10, v11, v12);
        }
        else
        {
          BOOL v14 = 0;
          if (*v18) {
            BOOL v14 = *v18;
          }
          ((void (*)(uint64_t (***)(), uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))v14[9])(v18, a1, (v20 & 0x700000000) >> 32, v8, v9, v10);
        }
        return;
      }
      if ((v20 & 0xFF80000000000000) == 0
        && (v20 & 0x4000000000) == 0
        && ((v20 & 1) != 0 || (v20 & 0xFFFFFFFC) != 0))
      {
        BOOL v31 = (v20 & 0xFF80000000000000) == 0
           && (v20 & 0x4000000000) == 0
           && ((v20 & 1) != 0 || (v20 & 0xFFFFFFFC) != 0);
        if (!v31) {
          _dispatch_abort(5301, v31, v7, v8, v9, v10, v11, v12);
        }
        if ((v20 & 0x2000000000) != 0) {
          _dispatch_event_loop_poke(a1, v20, a3 | 0x80000000, v8, v9, v10, v11, v12);
        }
        else {
          _dispatch_queue_wakeup_with_override_slow(a1, v20, a3);
        }
        return;
      }
    }
    if ((a3 & 1) == 0) {
      return;
    }
LABEL_82:
    _dispatch_release_2_tailcall(a1);
    return;
  }
  if ((v20 & 0x4000000000) != 0) {
    _dispatch_abort(1442, (v20 & 0x4000000000) == 0, v7, v8, v9, v10, v11, v12);
  }
  if ((v22 & 1) != 0 || (v20 & 1) != 0 || (v22 & 2) == 0)
  {
    _dispatch_event_loop_end_ownership(a1, v22, v20, a3, v9, v10, v11, v12);
    return;
  }
  _dispatch_event_loop_assert_not_owned(a1);
  if (a3) {
    goto LABEL_82;
  }
}

void _dispatch_lane_wakeup(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 4) != 0) {
    _dispatch_lane_barrier_complete(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    _dispatch_queue_wakeup(a1, a2, a3, *(void *)(a1 + 48) != 0, a5, a6, a7, a8);
  }
}

void _dispatch_lane_barrier_complete(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = 0;
  if (*(void *)(a1 + 48) && (*(void *)(a1 + 56) & 0xFF80000000000000) == 0)
  {
    uint64_t v18 = *(void *)(a1 + 104);
    if (!v18) {
      uint64_t v18 = _dispatch_wait_for_enqueuer((unint64_t *)(a1 + 104));
    }
    char v10 = 1;
    if (*(_WORD *)(a1 + 80) != 1)
    {
      if (*(void *)v18 > 0xFFFuLL)
      {
        uint64_t v9 = 0;
        if (*(void *)v18) {
          uint64_t v9 = *(void *)v18;
        }
        BOOL v17 = (*(void *)(v9 + 16) & 0xF0) == 0x10 && (*(_DWORD *)(v18 + 80) & 0x80000) != 0;
      }
      else
      {
        BOOL v17 = (*(void *)v18 & 2) != 0;
      }
      char v10 = v17;
    }
    if (v10)
    {
      if (*(void *)v18 <= 0xFFFuLL && (*(void *)v18 & 0x81) != 0)
      {
        _dispatch_lane_drain_barrier_waiter(a1, v18, a3, 0, a5, a6, a7, a8);
        return;
      }
    }
    else if (*(unsigned __int16 *)(a1 + 80) > 1u)
    {
      if (*(void *)v18 > 0xFFFuLL)
      {
        uint64_t v8 = 0;
        if (*(void *)v18) {
          uint64_t v8 = *(void *)v18;
        }
        BOOL v16 = (*(void *)(v8 + 16) & 0xF0) == 0x10 && (*(_DWORD *)(v18 + 80) & 0x80000) != 0;
      }
      else
      {
        BOOL v16 = (*(void *)v18 & 2) != 0;
      }
      if (!v16)
      {
        _dispatch_lane_drain_non_barriers(a1, v18, a3, a4, a5, a6, a7, a8);
        return;
      }
    }
    if ((a3 & 1) == 0)
    {
      _dispatch_retain_2(a1);
      a3 |= 1u;
    }
    uint64_t v12 = (uint64_t (***)())(&def_131C + 1);
  }
  _dispatch_lane_class_barrier_complete(a1, a2, a3, v12, ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000);
}

void _dispatch_lane_push(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = 0;
  if (*a2 <= 0xFFFuLL && (*a2 & 0x81) != 0)
  {
    _dispatch_lane_push_waiter(a1, (unint64_t)a2, a3);
  }
  else
  {
    if (*(_DWORD *)(a1 + 8) == 0x7FFFFFFF) {
      _dispatch_abort(5669, *(_DWORD *)(a1 + 8) != 0x7FFFFFFF, a3, a4, a5, a6, a7, a8);
    }
    if (a3 <= (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8) {
      unsigned int v15 = 0;
    }
    else {
      unsigned int v15 = a3;
    }
    a2[2] = 0;
    _dispatch_thread_setspecific(122, a1 + 48);
    unint64_t v10 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t)a2, memory_order_release);
    if (v10)
    {
      unsigned int v16 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32;
      BOOL v9 = 1;
      if (v16) {
        BOOL v9 = v16 < v15;
      }
      if (v9)
      {
        _dispatch_retain_2_unsafe(a1);
        unsigned int v11 = 1;
      }
    }
    else
    {
      _dispatch_retain_2_unsafe(a1);
      unsigned int v11 = 3;
    }
    if (v10) {
      *(void *)(v10 + 16) = a2;
    }
    else {
      *(void *)(a1 + 104) = a2;
    }
    _dispatch_thread_setspecific(122, 0);
    if (v11)
    {
      uint64_t v8 = 0;
      if (*(void *)a1) {
        uint64_t v8 = *(void *)a1;
      }
      (*(void (**)(uint64_t, void, void))(v8 + 64))(a1, v15, v11);
    }
  }
}

void _dispatch_lane_push_waiter(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (*(void *)(a2 + 48) != -4) {
    a3 = 0;
  }
  *(void *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, a1 + 48);
  unint64_t v39 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 48), a2, memory_order_release);
  if (v39) {
    *(void *)(v39 + 16) = a2;
  }
  else {
    *(void *)(a1 + 104) = a2;
  }
  _dispatch_thread_setspecific(122, 0);
  if (v39)
  {
    if (a3)
    {
      for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v15)
      {
        unint64_t v31 = i;
        unint64_t v30 = (unint64_t)a3 << 32;
        if ((i & 0x700000000) < v30)
        {
          unint64_t v31 = i & 0xFFFFFFF8FFFFFFFFLL | v30;
          if (i & 0x1000000000 | v30 & 0x1000000000) {
            v31 |= 0x800000000uLL;
          }
        }
        uint64_t v24 = v31;
        if (i == v31) {
          break;
        }
        unint64_t v14 = i;
        unint64_t v15 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v15, v31, memory_order_relaxed, memory_order_relaxed);
        if (v15 == v14)
        {
          if ((v31 & 0xFF80000000000000) != 0 || (v31 & 0x4000000000) != 0) {
            BOOL v40 = 0;
          }
          else {
            BOOL v40 = (v31 & 1) != 0 || (v31 & 0x2000000000) == 0 && (v31 & 0xFFFFFFFC) != 0;
          }
          if (!v40) {
            return;
          }
          BOOL v35 = (v31 & 0xFF80000000000000) == 0
             && (v31 & 0x4000000000) == 0
             && ((v31 & 1) != 0 || (v31 & 0xFFFFFFFC) != 0);
          if (!v35) {
            _dispatch_abort(5301, v35, v3, v4, v5, v6, v7, v8);
          }
          if ((v31 & 0x2000000000) == 0)
          {
            _dispatch_queue_wakeup_with_override_slow(a1, v31, 0);
            return;
          }
          goto LABEL_74;
        }
      }
    }
  }
  else
  {
    if ((*(_DWORD *)(a1 + 80) & 0x40000) == 0 || (*(_DWORD *)(a1 + 80) & 0x1000000) != 0)
    {
      if ((*(void *)a2 & 0x80) != 0)
      {
        char v21 = 1;
        if ((*(_DWORD *)(a1 + 80) & 0x1000000) == 0)
        {
          char v20 = 0;
          if ((*(void *)(a1 + 56) & 0x3000000000) != 0)
          {
            BOOL v19 = 0;
            if (*(void *)(a1 + 24) >= (unint64_t)&_dispatch_root_queues) {
              BOOL v19 = *(void *)(a1 + 24) < (unint64_t)&unk_F0A80;
            }
            char v20 = !v19;
          }
          char v21 = v20;
        }
        char v42 = v21 & 1;
      }
      else
      {
        char v42 = 0;
      }
    }
    else
    {
      char v42 = 1;
    }
    if (v42)
    {
      *(void *)a2 &= ~0x80uLL;
      *(void *)(a2 + 56) = a1;
      uint64_t v18 = 0;
      if (*(void *)a1) {
        uint64_t v18 = *(void *)a1;
      }
      (*(void (**)(uint64_t, void, uint64_t))(v18 + 64))(a1, a3, 2);
    }
    else
    {
      uint64_t v23 = (uint64_t)(*(unsigned __int16 *)(a1 + 80) - 1) << 41;
      unint64_t v22 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002;
      for (unint64_t j = *(void *)(a1 + 56); ; unint64_t j = v11)
      {
        unint64_t v33 = j;
        unint64_t v32 = (unint64_t)a3 << 32;
        if ((j & 0x700000000) < v32)
        {
          unint64_t v33 = j & 0xFFFFFFF8FFFFFFFFLL | v32;
          if (j & 0x1000000000 | v32 & 0x1000000000) {
            v33 |= 0x800000000uLL;
          }
        }
        uint64_t v24 = v33 | 0x8000000000;
        BOOL v17 = 1;
        if ((j & 0xFFFFFFFC) == 0) {
          BOOL v17 = j >= 0x20000000000000;
        }
        if (!v17
          && ((j & 0x2000000000) == 0 || (j & 0x4000000001) == 0)
          && ((j & 0x10000000000) != 0 || (unint64_t)(v24 + v23) < 0x20000000000000))
        {
          uint64_t v24 = v33 & 0x7700000001 | v22;
        }
        unint64_t v10 = j;
        unint64_t v11 = j;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v11, v24, memory_order_release, memory_order_relaxed);
        if (v11 == v10) {
          break;
        }
      }
      if ((j & 0x2000000000) != 0 && *(void *)(a2 + 48) != -4)
      {
        int v16 = *(_DWORD *)(a2 + 100);
        *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xFB | (4
                                                            * (v16 == _dispatch_thread_getspecific(3uLL)));
      }
      if (((j ^ v24) & 0x40000000000000) != 0)
      {
        if ((*(unsigned char *)(a2 + 106) & 4) != 0 && *(void *)(a1 + 104) == a2)
        {
          *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xF7 | 8;
          if ((*(void *)a2 & 0x80) != 0) {
            *(void *)(a2 + 56) = a1;
          }
          uint64_t v38 = *(void *)(a2 + 16);
          *(void *)(a1 + 104) = v38;
          if (!v38)
          {
            for (uint64_t k = *(void *)(a1 + 48); a2 == (k & 0xFFFFFFFFFFFFFFF8); uint64_t k = v13)
            {
              uint64_t v12 = k;
              uint64_t v13 = k;
              atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t *)&v13, 0, memory_order_release, memory_order_relaxed);
              if (v13 == v12) {
                return;
              }
            }
            uint64_t v36 = *(void *)(a2 + 16);
            if (!v36) {
              uint64_t v36 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16));
            }
            *(void *)(a1 + 104) = v36;
          }
        }
        else
        {
          _dispatch_lane_barrier_complete(a1, a3, 0, v4, v5, v6, v7, v8);
        }
      }
      else if (((j ^ v24) & 0x700000000) != 0)
      {
        if ((v24 & 0xFF80000000000000) != 0 || (v24 & 0x4000000000) != 0) {
          BOOL v41 = 0;
        }
        else {
          BOOL v41 = (v24 & 1) != 0 || (v24 & 0x2000000000) == 0 && (v24 & 0xFFFFFFFC) != 0;
        }
        if (v41)
        {
          BOOL v34 = (v24 & 0xFF80000000000000) == 0
             && (v24 & 0x4000000000) == 0
             && ((v24 & 1) != 0 || (v24 & 0xFFFFFFFC) != 0);
          if (!v34) {
            _dispatch_abort(5301, v34, v9, v4, v5, v6, v7, v8);
          }
          if ((v24 & 0x2000000000) != 0) {
LABEL_74:
          }
            _dispatch_event_loop_poke(a1, v24, 0x80000000, v4, v5, v6, v7, v8);
          else {
            _dispatch_queue_wakeup_with_override_slow(a1, v24, 0);
          }
        }
      }
    }
  }
}

void _dispatch_lane_concurrent_push(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v16 = 0;
  if ((*(unsigned char *)(a1 + 87) & 8) != 0)
  {
    if (*(void *)a2 >= 0x1000uLL)
    {
      uint64_t v15 = 0;
      if (*(void *)a2) {
        uint64_t v15 = *(void *)a2;
      }
      char v14 = 1;
      if (*(void *)(v15 + 16) != 1)
      {
        uint64_t v13 = 0;
        if (*(void *)a2) {
          uint64_t v13 = *(void *)a2;
        }
        BOOL is_timer = 0;
        if (*(unsigned char *)(v13 + 16) == 19) {
          BOOL is_timer = _dispatch_source_is_timer(a2);
        }
        char v14 = is_timer;
      }
      char v21 = v14 & 1;
    }
    else
    {
      char v21 = 1;
    }
    char v16 = v21 ^ 1;
  }
  if (v16)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
    qword_F42C0 = a2;
    __break(1u);
    JUMPOUT(0x3942CLL);
  }
  if (*(void *)(a1 + 48)) {
    goto LABEL_40;
  }
  if (*(void *)a2 < 0x1000uLL && (*(void *)a2 & 0x81) != 0) {
    goto LABEL_40;
  }
  if (*(void *)a2 > 0xFFFuLL)
  {
    uint64_t v11 = 0;
    if (*(void *)a2) {
      uint64_t v11 = *(void *)a2;
    }
    BOOL v22 = (*(void *)(v11 + 16) & 0xF0) == 0x10 && (*(_DWORD *)(a2 + 80) & 0x80000) != 0;
  }
  else
  {
    BOOL v22 = (*(_DWORD *)a2 & 2) != 0;
  }
  if (v22) {
    goto LABEL_40;
  }
  for (unint64_t i = *(void *)(a1 + 56); ; unint64_t i = v9)
  {
    char v10 = 1;
    if (!(i >> 53))
    {
      char v10 = 1;
      if ((i & 0x8000000000) == 0) {
        char v10 = BYTE5(i) & 1;
      }
    }
    if (v10)
    {
      char v24 = 0;
      goto LABEL_38;
    }
    unint64_t v8 = i;
    unint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v9, i + 0x20000000000, memory_order_acquire, memory_order_acquire);
    if (v9 == v8) {
      break;
    }
  }
  char v24 = 1;
LABEL_38:
  if (v24 != 1) {
LABEL_40:
  }
    _dispatch_lane_push(a1, (void *)a2, a3, a4, a5, a6, a7, a8);
  else {
    _dispatch_continuation_redirect_push(a1, (void *)a2, a3);
  }
}

uint64_t _dispatch_continuation_redirect_push(uint64_t a1, void *a2, unsigned int a3)
{
  char v10 = a2;
  BOOL v6 = 0;
  if (*a2 > 0xFFFuLL)
  {
    uint64_t v5 = 0;
    if (*a2) {
      uint64_t v5 = *a2;
    }
    BOOL v6 = *(void *)(v5 + 16) == 256;
  }
  if (!v6)
  {
    uint64_t v13 = _dispatch_thread_getspecific(0x16uLL);
    if (v13)
    {
      _dispatch_thread_setspecific(22, v13[2]);
      uint64_t v12 = v13;
    }
    else
    {
      uint64_t v12 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    v10[2] = 0;
    *uint64_t v12 = &unk_ECC58;
    v12[4] = 0;
    v12[5] = (*(_DWORD *)(a1 + 80) & 0x30000u) << 8;
    v12[6] = a1;
    v12[7] = v10;
    v12[3] = -1;
    v12[1] = -1;
    _dispatch_retain_2(a1);
    char v10 = v12;
  }
  else if (!a2[5])
  {
    a2[5] = (*(_DWORD *)(a1 + 80) & 0x30000u) << 8;
  }
  uint64_t v7 = *(uint64_t **)(a1 + 24);
  if (!a3) {
    a3 = (*((_DWORD *)v7 + 21) & 0xF00u) >> 8;
  }
  uint64_t v4 = 0;
  if (*v7) {
    uint64_t v4 = *v7;
  }
  return (*(uint64_t (**)(uint64_t *, void *, void))(v4 + 72))(v7, v10, a3);
}

uint64_t dispatch_async_swift_job(uint64_t *a1, uint64_t *a2, int a3)
{
  uint64_t v5 = 0;
  if (*a2) {
    uint64_t v5 = *a2;
  }
  uint64_t v6 = *(void *)(v5 + 16);
  if (v6 != 1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Used Swift only SPI to enqueue non-Swift runtime objects into dispatch";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x39C3CLL);
  }
  uint64_t v4 = 0;
  if (*a1) {
    uint64_t v4 = *a1;
  }
  switch(a3)
  {
    case 5:
      unsigned int v7 = 1;
      break;
    case 9:
      unsigned int v7 = 2;
      break;
    case 17:
      unsigned int v7 = 3;
      break;
    case 21:
      unsigned int v7 = 4;
      break;
    case 25:
      unsigned int v7 = 5;
      break;
    case 33:
      unsigned int v7 = 6;
      break;
    default:
      unsigned int v7 = 0;
      break;
  }
  return (*(uint64_t (**)(uint64_t *, uint64_t *, void))(v4 + 72))(a1, a2, v7);
}

void _dispatch_channel_dispose(uint64_t a1, unsigned char *a2)
{
  *(void *)(a1 + 88) = 0;
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_channel_xref_dispose(uint64_t a1)
{
  if (*(void *)(*(void *)(a1 + 88) + 24) && (*(_DWORD *)(a1 + 80) & 0x10000000) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a channel that has not been cancelled, but has a can"
                           "cel acknowledgement callback";
    qword_F42C0 = a1;
    __break(1u);
    JUMPOUT(0x39EECLL);
  }
  uint64_t v2 = 0;
  if (*(void *)a1) {
    uint64_t v2 = *(void *)a1;
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(v2 + 64))(a1, 0, 2);
}

void _dispatch_channel_invoke(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = a1;
  uint64_t v51 = a2;
  unsigned int v50 = a3;
  int v49 = 8;
  uint64_t v48 = _dispatch_channel_invoke2;
  uint64_t v47 = a1;
  v46[8] = 0;
  *(void *)uint64_t v46 = (a3 & 1) == 0;
  uint64_t v45 = 0;
  if ((a3 & 3) == 0)
  {
    *(void *)(v47 + 16) = -1985229329;
    BOOL v44 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v43 = v47;
    unsigned int v74 = v44;
    uint64_t v73 = v47;
    int v72 = 0;
    int v71 = 0;
    v172 = v44;
    uint64_t v171 = v47;
  }
  v50 |= v49;
  if ((v50 & 2) != 0)
  {
    uint64_t v45 = 0x40020000000001;
  }
  else
  {
    uint64_t v102 = v47;
    unsigned int v101 = v50;
    uint64_t v100 = 0;
    uint64_t v100 = (uint64_t)(*(unsigned __int16 *)(v47 + 80) - 1) << 41;
    unsigned int v115 = _dispatch_thread_getspecific(3uLL);
    uint64_t v99 = v115 & 0xFFFFFFFC | 0x20000000000000;
    unint64_t v97 = 0;
    unint64_t v96 = 0;
    uint64_t v95 = 0;
    unint64_t v98 = 0xFFE00000FFFFFFFCLL;
    if (v50)
    {
      v98 |= 0x4000000000uLL;
      uint64_t v95 = 0;
    }
    else if ((v101 & 0x40000) != 0)
    {
      uint64_t v95 = 0x4000000000;
    }
    else
    {
      v98 |= 0x4000000000uLL;
      uint64_t v95 = 1;
    }
    BOOL v108 = (v101 & 2) == 0;
    uint64_t v107 = 1323;
    if ((v101 & 2) != 0) {
      _dispatch_abort(v107, v108, v8, v9, v10, v11, v12, v13);
    }
    unsigned int v94 = 0;
    unsigned int v112 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v114 = v112 & 0xF00;
    unsigned int v111 = v114 >> 8;
    unsigned int v113 = v112 & 0xF000;
    unsigned int v110 = v113 >> 12;
    int v116 = v112 & 0xF0000;
    unsigned int v109 = (v112 & 0xF0000) >> 16;
    if (v114 >> 8 <= v113 >> 12) {
      unsigned int v38 = v110;
    }
    else {
      unsigned int v38 = v111;
    }
    if (v38 <= v109)
    {
      unsigned int v36 = v109;
    }
    else
    {
      if (v111 <= v110) {
        unsigned int v37 = v110;
      }
      else {
        unsigned int v37 = v111;
      }
      unsigned int v36 = v37;
    }
    unsigned int v94 = v36;
LABEL_22:
    BOOL v93 = 0;
    BOOL v92 = (atomic_ullong *)(v102 + 56);
    unint64_t v97 = *(void *)(v102 + 56);
    do
    {
      unint64_t v96 = v97;
      if ((v97 & v98) != 0)
      {
        if (!v95) {
          break;
        }
        v96 ^= v95;
      }
      else
      {
        unint64_t v149 = v97;
        unsigned int v148 = v94;
        unint64_t v151 = v97;
        BOOL v35 = 0;
        if ((v97 & 0x1000000000) != 0)
        {
          uint64_t v150 = v149 & 0x700000000;
          BOOL v35 = v148 < (v149 & 0x700000000) >> 32;
        }
        if (v35)
        {
          unint64_t v153 = v97;
          uint64_t v154 = v97 & 0x700000000;
          unsigned int v152 = (v97 & 0x700000000) >> 32;
          unsigned int v158 = _dispatch_thread_getspecific(3uLL);
          unsigned int v157 = v152;
          if (_dispatch_set_qos_class_enabled)
          {
            unsigned int v160 = v157;
            uint64_t v159 = 0;
            if (v157) {
              uint64_t v159 = 1 << (v160 + 7);
            }
            _pthread_workqueue_override_start_direct();
          }
          unsigned int v156 = v152;
          unsigned int v155 = _dispatch_thread_getspecific(0x19uLL);
          int v161 = v155 & 0xF0000;
          if (v152 > (v155 & 0xF0000) >> 16)
          {
            unsigned int v155 = v155 & 0xFFF0FFFF | (v156 << 16);
            _dispatch_thread_setspecific(25, v155);
          }
          unsigned int v94 = v152;
          goto LABEL_22;
        }
        unint64_t v96 = v96 & 0x7700000001 | v99;
        unint64_t v104 = v97;
        if ((v97 & 0x10000000000) != 0 || v97 + v100 < 0x20000000000000) {
          v96 |= 0x40000000000000uLL;
        }
      }
      unint64_t v91 = v96;
      unint64_t v16 = v97;
      unint64_t v17 = v97;
      atomic_compare_exchange_strong_explicit(v92, &v17, v96, memory_order_acquire, memory_order_acquire);
      if (v17 != v16) {
        unint64_t v97 = v17;
      }
      BOOL v90 = v17 == v16;
      BOOL v93 = v17 == v16;
    }
    while (v17 != v16);
    BOOL v89 = v93;
    BOOL v106 = (v97 & v95) == v95;
    uint64_t v105 = 1356;
    if ((v97 & v95) != v95) {
      _dispatch_abort(v105, v106, v14, v15, a5, a6, a7, a8);
    }
    if ((v97 & v98) != 0)
    {
      uint64_t v103 = 0;
    }
    else
    {
      v96 &= v95 | 0x60000000000000;
      v97 &= 0x3FFE0000000000uLL;
      uint64_t v103 = v96 - v97;
    }
    uint64_t v45 = v103;
  }
  if (v45)
  {
    unsigned int v42 = 0;
    if ((v50 & 0x40000) != 0)
    {
      unsigned int v42 = 0;
    }
    else
    {
      int v78 = *(_DWORD *)(v47 + 84);
      unsigned int v77 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v76 = v77;
      if (v77)
      {
        if ((v78 & 0xFFF) != 0)
        {
          v76 &= 0x880F0000;
          if ((v77 & 0xFFF) <= (v78 & 0xFFFu)) {
            int v34 = v78 & 0xFFF;
          }
          else {
            int v34 = v77 & 0xFFF;
          }
          v76 |= v34;
          unsigned int v80 = v78 & 0xF000;
          unsigned int v82 = v76 & 0xF00;
          if (v80 >> 12 <= v82 >> 8) {
            v78 &= 0x40000000u;
          }
          else {
            v78 &= 0x4400F000u;
          }
          v76 |= v78;
        }
        else
        {
          if ((v76 & 0xFFF) != 0) {
            v76 |= 0x40000000u;
          }
          unsigned int v79 = v78 & 0xF000;
          unsigned int v81 = v76 & 0xF00;
          if (v79 >> 12 > v81 >> 8) {
            unsigned int v76 = v76 & 0xFFFF0FFF | v78 & 0x400F000;
          }
        }
      }
      else
      {
        unsigned int v76 = v78 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v76);
      unsigned int v42 = v77;
    }
    if ((v50 & 0x100000) != 0)
    {
      uint64_t v56 = v52;
      int v55 = 0;
      int v54 = *(_DWORD *)(v52 + 80);
      int v55 = v54;
      int v53 = v54;
      if ((v54 & 0x400000) != 0)
      {
        uint64_t v68 = v52;
        int v67 = 0x400000;
        int v65 = -4194305;
        int v64 = -4194305;
        int v66 = -4194305;
        int v60 = -4194305;
        int v59 = -4194305;
        int v61 = -4194305;
        unsigned int v58 = atomic_fetch_and_explicit((atomic_uint *volatile)(v52 + 80), 0xFFBFFFFF, memory_order_relaxed);
        unsigned int v62 = v58;
        unsigned int v57 = v58;
        unsigned int v63 = v58 & 0xFFBFFFFF;
      }
    }
    uint64_t v41 = v47;
    uint64_t v119 = v47;
    unsigned int v118 = v50;
    int v117 = 0;
    uint64_t v164 = v47;
    uint64_t v163 = 256;
    uint64_t v170 = 1;
    uint64_t v169 = 730;
    int v162 = 0;
    uint64_t v168 = v47;
    int v167 = 0;
    int v166 = *(_DWORD *)(v47 + 80);
    int v167 = v166;
    int v165 = v166;
    int v162 = v166 & 0x30000;
    int v117 = (v166 & 0x30000) << 8;
    if (v117) {
      unsigned int v118 = v118 & 0xFCFFFFFF | v117;
    }
    unsigned int v50 = v118;
    do
    {
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v51);
      }
      uint64_t v40 = v47;
      *(void *)&v46[1] = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t *))v48)(v47, v51, v50, &v45);
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0)
      {
        long long v39 = 0uLL;
        uint64_t v84 = v47;
        uint64_t v83 = &v39;
        int v88 = &v39;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v39, v19, a5, a6, a7, a8);
        _dispatch_thread_setspecific_pair(20, v84, 21, (uint64_t)v83, v20, v21, v22, v23);
        _dispatch_last_resort_autorelease_pool_pop(v51);
        uint64_t v85 = &v39;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v39, v24, v25, v26, v27, v28);
      }
      BOOL v70 = *(void *)&v46[1] != 1;
      uint64_t v69 = 2018;
      if (*(void *)&v46[1] == 1) {
        _dispatch_abort(v69, v70, v18, v19, a5, a6, a7, a8);
      }
      BOOL v33 = 0;
      if (*(void *)&v46[1]) {
        BOOL v33 = *(void *)&v46[1] != -1;
      }
      if (v33) {
        break;
      }
      uint64_t v139 = v47;
      uint64_t v138 = v45;
      BOOL v137 = *(void *)&v46[1] == 0;
      uint64_t v136 = 0;
      unint64_t v135 = 0;
      BOOL v134 = 0;
      unsigned int v133 = (atomic_ullong *)(v47 + 56);
      uint64_t v136 = *(void *)(v47 + 56);
      do
      {
        unint64_t v135 = (v136 - v138) & 0xFFFFFFF700000001;
        uint64_t v141 = v136;
        if ((v136 & 0xFF80000000000000) == 0)
        {
          uint64_t v142 = v136;
          if ((v136 & 0x8000000000) != 0)
          {
            uint64_t v131 = 0x8000000000;
            uint64_t v130 = 0x8000000000;
            uint64_t v132 = 0x8000000000;
            unint64_t v128 = 0;
            uint64_t v126 = 0x8000000000;
            uint64_t v125 = 0x8000000000;
            uint64_t v127 = 0x8000000000;
            xor_unint64_t explicit = atomic_fetch_xor_explicit((atomic_ullong *volatile)(v139 + 56), 0x8000000000uLL, memory_order_acquire);
            unint64_t v128 = xor_explicit;
            unint64_t v123 = xor_explicit;
            unint64_t v129 = xor_explicit ^ v132;
            char v140 = 0;
            goto LABEL_101;
          }
          if (v137) {
            v135 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v135 |= 0x8000000000uLL;
          }
        }
        unint64_t v122 = v135;
        uint64_t v29 = v136;
        uint64_t v30 = v136;
        atomic_compare_exchange_strong_explicit(v133, (unint64_t *)&v30, v135, memory_order_release, memory_order_relaxed);
        if (v30 != v29) {
          uint64_t v136 = v30;
        }
        BOOL v121 = v30 == v29;
        BOOL v134 = v30 == v29;
      }
      while (v30 != v29);
      BOOL v120 = v134;
      uint64_t v144 = v136;
      uint64_t v146 = v136;
      BOOL v32 = 0;
      if ((v136 & 0x1000000000) != 0) {
        BOOL v32 = (v144 & 0x800000000) != 0;
      }
      if (v32)
      {
        uint64_t v143 = v136 & 0x700000000;
        uint64_t v145 = v136 & 0x700000000;
        LODWORD(v145) = _dispatch_thread_getspecific(0x19uLL);
        int v147 = v145 & 0xF0000;
        if (HIDWORD(v145) > (v145 & 0xF0000) >> 16)
        {
          LODWORD(v145) = v145 & 0xFFF0FFFF;
          LODWORD(v145) = v145 | (HIDWORD(v145) << 16);
          _dispatch_thread_setspecific(25, v145);
        }
      }
      char v140 = 1;
LABEL_101:
      if (v140)
      {
        uint64_t v45 = 0;
        *(void *)&v46[1] = 0;
        break;
      }
      *(void *)&v46[1] = _dispatch_thread_getspecific(0x14uLL);
      uint64_t v31 = 0;
      if (**(void **)&v46[1]) {
        uint64_t v31 = **(void **)&v46[1];
      }
    }
    while ((*(void *)(v31 + 16) & 0x10000) != 0 || (v46[0] & 1) == 0);
    if ((v50 & 0x40000) == 0)
    {
      unsigned int v87 = v42;
      unsigned int v86 = 0;
      unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
      v87 &= 0xFFF0FFFF;
      v87 |= v86 & 0xF0000;
      _dispatch_thread_setspecific(25, v87);
    }
  }
  if (v46[0])
  {
    uint64_t v75 = v47;
    uint64_t v173 = v47;
    int v178 = 772079660;
    uint64_t v177 = v47;
    uint64_t v176 = 0;
    uint64_t v175 = 0;
    uint64_t v174 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v179 = v75;
  }
  if (*(void *)&v46[1]) {
    _dispatch_queue_invoke_finish(v47, v51, *(uint64_t (****)())&v46[1], v45, a5, a6, a7, a8);
  }
  else {
    _dispatch_release_2_tailcall(v47);
  }
}

uint64_t _dispatch_channel_invoke2(void *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v32 = a1;
  uint64_t v31 = a2;
  int v30 = a3;
  uint64_t v29 = a4;
  uint64_t v28 = 0;
  uint64_t v28 = a1[11];
  long long v22 = (unint64_t)a1;
  uint64_t v23 = 0;
  uint64_t v24 = a2;
  uint64_t v25 = a3 & 0xFFFDFFFF;
  uint64_t v26 = 0;
  long long v27 = 0uLL;
  uint64_t v75 = a1;
  uint64_t v74 = (uint64_t)&v22 + 8;
  unsigned int v77 = (char *)&v22 + 8;
  _dispatch_thread_getspecific_packed_pair(20, 21, (long long *)((char *)&v22 + 8), a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v75, 21, v74, v8, v9, v10, v11);
  if (_dispatch_channel_invoke_cancel_check((uint64_t)v32, (uint64_t)&v22, v28))
  {
    do
    {
      uint64_t v21 = (void *)v27;
      if (!(void)v27)
      {
        if (!v32[6]) {
          break;
        }
        uint64_t v41 = v32;
        uint64_t v40 = v32 + 13;
        uint64_t v39 = 0;
        uint64_t v38 = 0;
        uint64_t v37 = v32[13];
        uint64_t v38 = v37;
        uint64_t v36 = v37;
        uint64_t v39 = v37;
        if (!v37) {
          uint64_t v39 = _dispatch_wait_for_enqueuer(v40);
        }
        uint64_t v35 = v39;
        uint64_t v21 = (void *)v39;
      }
      int v78 = v21;
      unsigned int v80 = v21;
      if (*v21 >= 0x1000uLL) {
        char v79 = 0;
      }
      else {
        char v79 = *v78 & 1;
      }
      if (v79)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: sync waiter found on channel";
        __break(1u);
        JUMPOUT(0x3B794);
      }
      BOOL v33 = v21;
      uint64_t v73 = v21;
      if (*v21 < 0x1000uLL && (*v33 & 0x400) != 0)
      {
        *(void *)&long long v27 = v21;
        BYTE8(v27) = 0;
        uint64_t v20 = 0;
        if ((v25 & 0x1000000) != 0) {
          uint64_t v20 = _dispatch_autorelease_pool_push();
        }
        if ((*(unsigned int (**)(void *, long long *, void))(v28 + 16))(v32, &v22, v32[4]))
        {
          if ((BYTE8(v27) & 1) == 0)
          {
            qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel didn't call dispatch_channel_drain";
            __break(1u);
            JUMPOUT(0x3B880);
          }
        }
        else
        {
          uint64_t v26 = -1;
        }
        if (v20) {
          _dispatch_autorelease_pool_pop(v20);
        }
      }
      else
      {
        int v71 = v32;
        BOOL v70 = v21;
        uint64_t v69 = v21;
        uint64_t v68 = 0;
        uint64_t v67 = 0;
        uint64_t v66 = 0;
        uint64_t v65 = 0;
        uint64_t v64 = v21[2];
        uint64_t v65 = v64;
        uint64_t v63 = v64;
        uint64_t v68 = v64;
        uint64_t v62 = v64;
        uint64_t v61 = v64;
        v32[13] = v64;
        uint64_t v60 = v62;
        if (!v68)
        {
          uint64_t v57 = 0;
          uint64_t v58 = 0;
          int v59 = v71 + 6;
          BOOL v56 = 0;
          int v55 = (atomic_ullong *)(v71 + 6);
          uint64_t v66 = v71[6];
          while (1)
          {
            uint64_t v72 = v66;
            if (v69 != (void *)(v66 & 0xFFFFFFFFFFFFFFF8)) {
              break;
            }
            uint64_t v67 = 0;
            uint64_t v45 = 0;
            uint64_t v17 = v66;
            uint64_t v18 = v66;
            atomic_compare_exchange_strong_explicit(v55, (unint64_t *)&v18, 0, memory_order_release, memory_order_relaxed);
            if (v18 != v17) {
              uint64_t v66 = v18;
            }
            BOOL v44 = v18 == v17;
            BOOL v56 = v18 == v17;
            if (v18 == v17) {
              goto LABEL_35;
            }
          }
          int v54 = v69;
          uint64_t v53 = 0;
          uint64_t v52 = 0;
          uint64_t v51 = v69[2];
          uint64_t v52 = v51;
          uint64_t v50 = v51;
          uint64_t v53 = v51;
          if (!v51) {
            uint64_t v53 = _dispatch_wait_for_enqueuer(v54 + 2);
          }
          uint64_t v49 = v53;
          uint64_t v68 = v53;
          uint64_t v48 = v53;
          uint64_t v47 = v53;
          v71[13] = v53;
          uint64_t v46 = v48;
LABEL_35:
          BOOL v43 = v56;
        }
        uint64_t v42 = v68;
        *(void *)&long long v27 = v68;
        _dispatch_continuation_pop_inline(v21, v31, v30, (uint64_t)v32);
        if ((_dispatch_channel_invoke_checks((uint64_t)v32, (uint64_t)&v22, v28) & 1) == 0) {
          break;
        }
      }
    }
    while (!v26);
  }
  unsigned int v76 = (char *)&v22 + 8;
  _dispatch_thread_setspecific_packed_pair(20, 21, (long long *)((char *)&v22 + 8), v12, v13, v14, v15, v16);
  return v26;
}

uint64_t dispatch_channel_foreach_work_item_peek_f(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, void))
{
  if (*(unsigned char *)(result + 56))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Called peek after drain";
    __break(1u);
    JUMPOUT(0x3BBD0);
  }
  uint64_t v5 = *(void *)result;
  for (unint64_t i = *(void **)(result + 48); *i < 0x1000uLL && (*(_DWORD *)i & 0x400) != 0; unint64_t i = v3)
  {
    __n128 result = a3(a2, i[5]);
    if ((result & 1) == 0 || i == *(void **)(v5 + 48)) {
      break;
    }
    uint64_t v3 = (void *)i[2];
    if (!v3)
    {
      __n128 result = _dispatch_wait_for_enqueuer(i + 2);
      uint64_t v3 = (void *)result;
    }
  }
  return result;
}

void dispatch_channel_drain_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = a1;
  uint64_t v60 = a2;
  int v59 = (uint64_t (*)(uint64_t, void, uint64_t *))a3;
  uint64_t v58 = 0;
  uint64_t v58 = *(void *)a1;
  uint64_t v57 = 0;
  uint64_t v57 = *(void *)(v58 + 88);
  BOOL v56 = 0;
  uint64_t v55 = 1028;
  uint64_t v54 = 0;
  if (*(unsigned char *)(a1 + 56))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Called drain twice in the same invoke";
    __break(1u);
    JUMPOUT(0x3BDCCLL);
  }
  *(unsigned char *)(v61 + 56) = 1;
  do
  {
    BOOL v56 = *(void **)(v61 + 48);
    if (!v56)
    {
      if (!*(void *)(v58 + 48)) {
        break;
      }
      uint64_t v113 = v58;
      unsigned int v112 = (unint64_t *)(v58 + 104);
      uint64_t v111 = 0;
      uint64_t v110 = 0;
      uint64_t v109 = *(void *)(v58 + 104);
      uint64_t v110 = v109;
      uint64_t v108 = v109;
      uint64_t v111 = v109;
      if (!v109) {
        uint64_t v111 = _dispatch_wait_for_enqueuer(v112);
      }
      uint64_t v107 = v111;
      BOOL v56 = (void *)v111;
    }
    uint64_t v105 = v56;
    uint64_t v180 = v56;
    if (*v56 >= 0x1000uLL || (*v105 & 0x400) == 0) {
      break;
    }
    uint64_t v143 = v58;
    uint64_t v142 = v56;
    uint64_t v141 = v56;
    uint64_t v140 = 0;
    uint64_t v139 = 0;
    uint64_t v138 = 0;
    uint64_t v137 = 0;
    uint64_t v136 = v56[2];
    uint64_t v137 = v136;
    uint64_t v135 = v136;
    uint64_t v140 = v136;
    uint64_t v134 = v136;
    uint64_t v133 = v136;
    *(void *)(v58 + 104) = v136;
    uint64_t v132 = v134;
    if (!v140)
    {
      uint64_t v129 = 0;
      uint64_t v130 = 0;
      uint64_t v131 = v143 + 48;
      BOOL v128 = 0;
      uint64_t v127 = (atomic_ullong *)(v143 + 48);
      uint64_t v138 = *(void *)(v143 + 48);
      while (1)
      {
        uint64_t v179 = v138;
        if (v141 != (void *)(v138 & 0xFFFFFFFFFFFFFFF8)) {
          break;
        }
        uint64_t v139 = 0;
        uint64_t v117 = 0;
        uint64_t v8 = v138;
        uint64_t v9 = v138;
        atomic_compare_exchange_strong_explicit(v127, (unint64_t *)&v9, 0, memory_order_release, memory_order_relaxed);
        if (v9 != v8) {
          uint64_t v138 = v9;
        }
        BOOL v116 = v9 == v8;
        BOOL v128 = v9 == v8;
        if (v9 == v8) {
          goto LABEL_22;
        }
      }
      uint64_t v126 = v141;
      uint64_t v125 = 0;
      uint64_t v124 = 0;
      uint64_t v123 = v141[2];
      uint64_t v124 = v123;
      uint64_t v122 = v123;
      uint64_t v125 = v123;
      if (!v123) {
        uint64_t v125 = _dispatch_wait_for_enqueuer(v126 + 2);
      }
      uint64_t v121 = v125;
      uint64_t v140 = v125;
      uint64_t v120 = v125;
      uint64_t v119 = v125;
      *(void *)(v143 + 104) = v125;
      uint64_t v118 = v120;
LABEL_22:
      BOOL v115 = v128;
    }
    uint64_t v114 = v140;
    *(void *)(v61 + 48) = v140;
    unsigned int v101 = v56;
    uint64_t v102 = v56;
    uint64_t v52 = (uint64_t)v56;
    __int16 v50 = v55;
    int v147 = v56;
    uint64_t v146 = v55;
    uint64_t v145 = 0;
    uint64_t v145 = (_DWORD *)v56[3];
    uint64_t v144 = v55 & 4;
    uint64_t v169 = 1;
    uint64_t v168 = 600;
    if ((v55 & 4) != 0) {
      v147[3] = -1;
    }
    if (v145 != (_DWORD *)-1)
    {
      int v162 = 771817480;
      int v161 = v145;
      unsigned int v160 = v147;
      unsigned int v159 = 0;
      if (v145) {
        unsigned int v45 = v161[8];
      }
      else {
        unsigned int v45 = 0;
      }
      unsigned int v159 = v45;
      int v167 = v162;
      uint64_t v166 = v45;
      int v165 = v160;
      uint64_t v164 = 0;
      uint64_t v163 = 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v10, v11, v12, v13, v14, v15, v16, 607);
    }
    unint64_t v151 = v147[1];
    uint64_t v150 = (uint64_t)v145;
    uint64_t v149 = v144 | 2;
    uint64_t v148 = 0;
    if (v151 != -1)
    {
      unint64_t v204 = v151;
      uint64_t v203 = v149;
      unsigned int v202 = 0;
      unsigned int v202 = _dispatch_thread_getspecific(0x19uLL);
      uint64_t v201 = 0;
      unsigned int v210 = v202;
      unsigned int v211 = v202 & 0xF00;
      unsigned int v209 = v211 >> 8;
      uint64_t v208 = v202;
      if (v211 >> 8) {
        v208 |= 1 << (v209 + 7);
      }
      uint64_t v201 = v208;
      uint64_t v212 = v208;
      unint64_t v200 = v208 & 0xFFFFFF00;
      char v199 = 0;
      LOBYTE(v44) = 1;
      if ((v203 & 1) == 0) {
        int v44 = (BYTE3(v204) >> 4) & 1;
      }
      char v199 = v44;
      unint64_t v206 = v204;
      v204 &= 0xFFFFFFuLL;
      if (v204)
      {
        if (v204 >= v200)
        {
          if ((v199 & 1) != 0 || (v202 & 0x44000000) != 0) {
            uint64_t v205 = v204;
          }
          else {
            uint64_t v205 = v201;
          }
        }
        else
        {
          uint64_t v205 = v201;
        }
      }
      else
      {
        unsigned int v207 = v202 & 0xF000;
        unsigned int v198 = v207 >> 12;
        if (v207 >> 12)
        {
          unsigned int v214 = v198;
          uint64_t v213 = 1 << (v198 + 7);
          uint64_t v43 = v213 | 0xFF;
        }
        else
        {
          uint64_t v43 = v201;
        }
        uint64_t v205 = v43;
      }
      uint64_t v148 = v205;
    }
    uint64_t v155 = v148;
    uint64_t v154 = v150;
    uint64_t v153 = v149;
    uint64_t v184 = v148;
    BOOL v197 = v148 != -1;
    uint64_t v196 = 2395;
    if (v148 == -1) {
      _dispatch_abort(v196, v197, a3, a4, a5, a6, a7, a8);
    }
    if (_dispatch_set_qos_class_enabled)
    {
      uint64_t v195 = v184;
      uint64_t v194 = 4261412863;
      uint64_t v193 = 0;
      v184 &= 0xFFFFFFFF02FFFFFFLL;
      unint64_t v183 = 0;
      uint64_t v186 = 0;
      uint64_t v186 = _dispatch_thread_getspecific(4uLL);
      unint64_t v183 = (unint64_t)v186;
      uint64_t v182 = 0x1000000;
      uint64_t v181 = 2281701376;
      if ((v186 & 0x1000000) != 0)
      {
        if (v184)
        {
          uint64_t v42 = v184;
        }
        else
        {
          unint64_t v192 = v183;
          uint64_t v191 = v182;
          uint64_t v190 = 0;
          uint64_t v42 = v183 & (~v182 | 0xFFFFFF);
        }
        uint64_t v185 = v42;
      }
      else
      {
        unint64_t v189 = v183;
        uint64_t v188 = v181;
        uint64_t v187 = 0;
        v183 &= ~v181 | 0xFFFFFF;
        if (v184 == v183) {
          uint64_t v185 = 0;
        }
        else {
          uint64_t v185 = v184;
        }
      }
    }
    else
    {
      uint64_t v185 = 0;
    }
    uint64_t v155 = v185;
    if (v185) {
      goto LABEL_74;
    }
    if (v154 != -1)
    {
      uint64_t v41 = (void *)v154;
      if (v41 == _dispatch_thread_getspecific(0x1CuLL))
      {
        BOOL v152 = (v153 & 4) != 0;
        if ((v153 & 2) != 0)
        {
          if (v152 && v154)
          {
            object = (void *)v154;
            os_release((void *)v154);
          }
          uint64_t v154 = -1;
        }
        else if (!v152 && v154)
        {
          unsigned int v158 = (void *)v154;
          os_retain((void *)v154);
        }
        uint64_t v156 = v154;
        goto LABEL_75;
      }
LABEL_74:
      uint64_t v156 = _dispatch_set_priority_and_voucher_slow(v155, (_DWORD *)v154, v153);
      goto LABEL_75;
    }
    uint64_t v156 = -1;
LABEL_75:
    if ((v50 & 0x200) == 0)
    {
      uint64_t v99 = v56;
      uint64_t v100 = v56;
      uint64_t v173 = v58;
      v172 = v56;
      int v171 = 0;
      int v170 = 0;
      uint64_t v229 = v58;
      v228 = v56;
    }
    if ((v50 & 4) != 0)
    {
      uint64_t v176 = v52;
      uint64_t v175 = 0;
      uint64_t v175 = _dispatch_thread_getspecific(0x16uLL);
      int v174 = 0;
      if (v175) {
        int v40 = v175[2] + 1;
      }
      else {
        int v40 = 1;
      }
      int v174 = v40;
      if (v40 <= _dispatch_continuation_cache_limit)
      {
        *(void *)(v176 + 16) = v175;
        *(_DWORD *)(v176 + 8) = v174;
        _dispatch_thread_setspecific(22, v176);
        uint64_t v177 = 0;
      }
      else
      {
        uint64_t v177 = v176;
      }
      uint64_t v51 = (void *)v177;
    }
    else
    {
      uint64_t v51 = 0;
    }
    uint64_t v49 = 0;
    if (*(unsigned char *)(v61 + 35)) {
      uint64_t v49 = _dispatch_autorelease_pool_push();
    }
    unint64_t v97 = v56;
    unint64_t v98 = v56;
    char v53 = v59(v60, v56[5], &v54) ^ 1;
    if (v49) {
      _dispatch_autorelease_pool_pop(v49);
    }
    if ((v50 & 0x200) == 0)
    {
      uint64_t v178 = v52;
      uint64_t v230 = v52;
      int v235 = 772079660;
      uint64_t v234 = v52;
      uint64_t v233 = 0;
      uint64_t v232 = 0;
      uint64_t v231 = 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      uint64_t v236 = v178;
    }
    if (v51) {
      _dispatch_continuation_free_to_cache_limit(v51);
    }
  }
  while ((v53 & 1) == 0 && (_dispatch_channel_invoke_checks(v58, v61, v57) & 1) != 0);
  if (v54)
  {
    uint64_t v85 = 0;
    unsigned int v87 = 0;
    unsigned int v87 = _dispatch_thread_getspecific(0x16uLL);
    if (v87) {
      _dispatch_thread_setspecific(22, v87[2]);
    }
    uint64_t v85 = v87;
    if (v87) {
      unsigned int v86 = v85;
    }
    else {
      unsigned int v86 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    unint64_t v48 = (unint64_t)v86;
    uint64_t v68 = v58;
    uint64_t v67 = v86;
    uint64_t v66 = v54;
    uint64_t v65 = 0;
    uint64_t v64 = 0;
    uint64_t v63 = v55;
    uint64_t v62 = 0;
    *unsigned int v86 = v55 | 0x100;
    v67[4] = v65;
    v67[5] = v66;
    if ((v64 & 0x40000000) == 0)
    {
      unint64_t v216 = 0;
      int v215 = 1;
      unint64_t v218 = 0;
      unint64_t v218 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      unint64_t v219 = v218;
      unint64_t v216 = v218 & 0xFFFFFF;
      if ((v215 & 2) != 0 || (v223 = 5, uint64_t v222 = 4096, v216 <= 0x10FF))
      {
        uint64_t v217 = v216;
      }
      else
      {
        int v221 = 5;
        uint64_t v220 = 4096;
        uint64_t v217 = 4351;
      }
      uint64_t v62 = v217;
    }
    unsigned int v80 = v67;
    uint64_t v79 = v64;
    int v78 = 0;
    BOOL v104 = (int)v64 >= 0;
    uint64_t v103 = 583;
    if ((int)v64 < 0) {
      _dispatch_abort(v103, v104, v17, v18, v19, v20, v21, v22);
    }
    if ((v79 & 0x40) == 0)
    {
      v226 = 0;
      v226 = _dispatch_thread_getspecific(0x1CuLL);
      if (v226)
      {
        v227 = v226;
        os_retain(v226);
      }
      int v78 = v226;
    }
    v80[3] = v78;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v23, v24, v25, v26, v27, v28, v29, 589);
    uint64_t v30 = v80[3];
    int v84 = 771817476;
    uint64_t v83 = v30;
    unsigned int v82 = v80;
    if (v30 != -1)
    {
      unsigned int v81 = 0;
      unsigned int v39 = v83 ? *(_DWORD *)(v83 + 32) : 0;
      unsigned int v81 = v39;
      int v92 = v84;
      uint64_t v91 = v39;
      BOOL v90 = v82;
      uint64_t v89 = 0;
      uint64_t v88 = 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
    }
    uint64_t v77 = v68;
    unsigned int v76 = v67;
    unint64_t v75 = v62;
    uint64_t v74 = v64;
    unsigned int v73 = 0;
    uint64_t v72 = v68;
    if (v62)
    {
      BOOL v71 = (v74 & 0x20) != 0;
      BOOL v70 = 0;
      BOOL v70 = (*(_DWORD *)(v72 + 84) & 0x40000000) != 0;
      BOOL v69 = 0;
      BOOL v69 = (*(_DWORD *)(v72 + 84) & 0xFFF) != 0;
      if ((v74 & 0x20) != 0)
      {
        v75 |= 0x10000000uLL;
        unint64_t v224 = v75 >> 8;
        unsigned int v31 = v75 >> 8;
        unsigned int v32 = __clz(__rbit32(v31));
        if (v31) {
          unsigned int v33 = v32 + 1;
        }
        else {
          unsigned int v33 = 0;
        }
        unsigned int v73 = v33;
      }
      else if (v70 || !v69)
      {
        unint64_t v225 = v75 >> 8;
        unsigned int v34 = v75 >> 8;
        unsigned int v35 = __clz(__rbit32(v34));
        if (v34) {
          unsigned int v36 = v35 + 1;
        }
        else {
          unsigned int v36 = 0;
        }
        unsigned int v73 = v36;
      }
      else
      {
        unint64_t v75 = 0;
      }
    }
    v76[1] = v75;
    unint64_t v95 = v48;
    unint64_t v96 = v48;
    uint64_t v47 = *(void *)(v61 + 48);
    *(void *)(v48 + 16) = v47;
    BOOL v38 = 0;
    if (!v47)
    {
      uint64_t v37 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v58 + 48), (unint64_t *)&v37, v48, memory_order_release, memory_order_relaxed);
      BOOL v38 = v37 != 0;
    }
    if (v38)
    {
      uint64_t v46 = *(void *)(v58 + 104);
      if (!v46) {
        uint64_t v46 = _dispatch_wait_for_enqueuer((unint64_t *)(v58 + 104));
      }
      *(void *)(v48 + 16) = v46;
    }
    *(void *)(v58 + 104) = v48;
    unint64_t v93 = v48;
    unint64_t v94 = v48;
    *(void *)(v61 + 48) = v48;
  }
}

uint64_t _dispatch_channel_invoke_checks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (_dispatch_channel_invoke_cancel_check(a1, a2, a3))
  {
    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    if ((*(_DWORD *)(a2 + 32) & 0x100000) != 0
      && (unsigned int v7 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL),
          (((unint64_t)v7[15] << 32) & 0x700000000) >> 32 > *((unsigned __int8 *)v7 + 100)))
    {
      *(void *)(a2 + 40) = *(void *)(a1 + 24);
      char v6 = 0;
    }
    else if ((unint64_t)_dispatch_thread_getspecific(0x78uLL))
    {
      *(void *)(a2 + 40) = *(void *)(a1 + 24);
      char v6 = 0;
    }
    else if ((*(void *)(a1 + 56) & 0xFF80000000000000) != 0)
    {
      *(void *)(a2 + 40) = *(void *)(a1 + 24);
      char v6 = 0;
    }
    else
    {
      char v6 = 1;
    }
  }
  else
  {
    char v6 = 0;
  }
  return v6 & 1;
}

uint64_t dispatch_channel_foreach_work_item_peek(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = _Block_get_invoke_fn(a2);
  uint64_t v5 = 0;
  if (v4) {
    uint64_t v5 = (uint64_t (*)(uint64_t, void))v4;
  }
  uint64_t v3 = 0;
  if (v5) {
    uint64_t v3 = v5;
  }
  return dispatch_channel_foreach_work_item_peek_f(a1, a2, v3);
}

void dispatch_channel_drain(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = _Block_get_invoke_fn(a2);
  uint64_t v9 = 0;
  if (v8) {
    uint64_t v9 = v8;
  }
  uint64_t v7 = 0;
  if (v9) {
    uint64_t v7 = v9;
  }
  dispatch_channel_drain_f(a1, a2, v7, v2, v3, v4, v5, v6);
}

void _dispatch_channel_wakeup(uint64_t a1, unsigned int a2, unsigned int a3)
{
  BOOL v8 = 0;
  if (((*(unsigned __int8 (**)(uint64_t, void))(*(void *)(a1 + 88) + 8))(a1, *(void *)(a1 + 32)) ^ 1))
  {
    _dispatch_queue_wakeup(a1, a2, a3, -1, v3, v4, v5, v6);
  }
  else if (*(void *)(a1 + 48))
  {
    _dispatch_queue_wakeup(a1, a2, a3, 1, v3, v4, v5, v6);
  }
  else
  {
    if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0) {
      BOOL v8 = ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0;
    }
    _dispatch_queue_wakeup(a1, a2, a3, v8, v3, v4, v5, v6);
  }
}

uint64_t *dispatch_channel_create(const char *a1, uint64_t (***a2)(), uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = a1;
  int v16 = 0x4000000;
  if (!*a4)
  {
    uint64_t v8 = *a4;
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unsupported callbacks version";
    qword_F42C0 = v8;
    __break(1u);
    JUMPOUT(0x3DC20);
  }
  if (a1)
  {
    uint64_t v15 = _dispatch_strdup_if_mutable(a1);
    if (v15 != v20)
    {
      int v16 = 69206016;
      uint64_t v20 = v15;
    }
  }
  if (a2) {
    _dispatch_retain((uint64_t)a2);
  }
  else {
    a2 = &off_F0680;
  }
  uint64_t v14 = _dispatch_object_alloc((uint64_t)_OS_dispatch_channel_vtable, 0x78uLL, a3, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_queue_init(v14, v16, 1, 0x180000000000000, v9, v10, v11, v12);
  v14[9] = (uint64_t)v20;
  v14[3] = (uint64_t)a2;
  v14[11] = (uint64_t)a4;
  v14[4] = a3;
  if (!a4[3])
  {
    *((_WORD *)v14 + 58) |= 8u;
    --*((_DWORD *)v14 + 2);
  }
  return v14;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> _dispatch_queue_init(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 & 0xFE7FFFCFFFFFFFFFLL) != 0) {
    _dispatch_abort(1223, (a4 & 0xFE7FFFCFFFFFFFFFLL) == 0, a3, a4, a5, a6, a7, a8);
  }
  if ((a4 & 0x180000000000000) != 0)
  {
    *((_DWORD *)a1 + 2) += 2;
    uint64_t v8 = 0;
    if (*a1) {
      uint64_t v8 = *a1;
    }
    if (*(unsigned char *)(v8 + 16) == 19) {
      ++*((_DWORD *)a1 + 2);
    }
  }
  a1[2] = -1985229329;
  *((_DWORD *)a1 + 20) = a2 | (unsigned __int16)a3;
  a1[7] = ((4096 - (unsigned __int16)a3) << 41) | a4;
  a1[8] = atomic_fetch_add_explicit((atomic_ullong *volatile)&_dispatch_queue_serial_numbers, 1uLL, memory_order_relaxed);
}

uint64_t dispatch_channel_enqueue(uint64_t a1, uint64_t a2)
{
  int v16 = _dispatch_thread_getspecific(0x16uLL);
  if (!v16) {
    return _dispatch_channel_enqueue_slow((uint64_t *)a1, a2);
  }
  _dispatch_thread_setspecific(22, v16[2]);
  *int v16 = 1284;
  v16[4] = 0;
  v16[5] = a2;
  unint64_t v19 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v19 <= 0x10FF) {
    unint64_t v20 = v19;
  }
  else {
    unint64_t v20 = 4351;
  }
  uint64_t v21 = _dispatch_thread_getspecific(0x1CuLL);
  if (v21) {
    os_retain(v21);
  }
  v16[3] = v21;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
  if (v16[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  unint64_t v18 = v20;
  unsigned int v17 = 0;
  if (v20)
  {
    if ((*(_DWORD *)(a1 + 84) & 0x40000000) != 0 || (*(_DWORD *)(a1 + 84) & 0xFFF) == 0)
    {
      unsigned int v10 = v20 >> 8;
      unsigned int v11 = __clz(__rbit32(v10));
      if (v10) {
        unsigned int v12 = v11 + 1;
      }
      else {
        unsigned int v12 = 0;
      }
      unsigned int v17 = v12;
    }
    else
    {
      unint64_t v18 = 0;
    }
  }
  v16[1] = v18;
  uint64_t v13 = 0;
  if (*(void *)a1) {
    uint64_t v13 = *(void *)a1;
  }
  return (*(uint64_t (**)(uint64_t, void *, void))(v13 + 72))(a1, v16, v17);
}

uint64_t _dispatch_channel_enqueue_slow(uint64_t *a1, uint64_t a2)
{
  uint64_t v14 = (void *)_dispatch_continuation_alloc_from_heap();
  *uint64_t v14 = 1284;
  v14[4] = 0;
  v14[5] = a2;
  unint64_t v19 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v19 <= 0x10FF) {
    unint64_t v20 = v19;
  }
  else {
    unint64_t v20 = 4351;
  }
  uint64_t v21 = _dispatch_thread_getspecific(0x1CuLL);
  if (v21) {
    os_retain(v21);
  }
  v14[3] = v21;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
  if (v14[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  unint64_t v18 = v20;
  unsigned int v17 = 0;
  if (v20)
  {
    if ((*((_DWORD *)a1 + 21) & 0x40000000) != 0 || (*((_DWORD *)a1 + 21) & 0xFFF) == 0)
    {
      unsigned int v9 = v20 >> 8;
      unsigned int v10 = __clz(__rbit32(v9));
      if (v9) {
        unsigned int v11 = v10 + 1;
      }
      else {
        unsigned int v11 = 0;
      }
      unsigned int v17 = v11;
    }
    else
    {
      unint64_t v18 = 0;
    }
  }
  v14[1] = v18;
  uint64_t v13 = 0;
  if (*a1) {
    uint64_t v13 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void *, void))(v13 + 72))(a1, v14, v17);
}

uint64_t dispatch_channel_wakeup(uint64_t *a1, unsigned int a2)
{
  if (a2 <= 5)
  {
    uint64_t v3 = a2 - 5;
    char v2 = 0;
  }
  else
  {
    uint64_t v3 = a2 - 5;
    char v2 = 1;
  }
  if ((v2 & 1) == 0)
  {
    switch(v3)
    {
      case 0:
        unsigned int v6 = 1;
        goto LABEL_13;
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 17:
      case 18:
      case 19:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        break;
      case 4:
        unsigned int v6 = 2;
        goto LABEL_13;
      case 12:
        unsigned int v6 = 3;
        goto LABEL_13;
      case 16:
        unsigned int v6 = 4;
        goto LABEL_13;
      case 20:
        unsigned int v6 = 5;
        goto LABEL_13;
      case 28:
        unsigned int v6 = 6;
        goto LABEL_13;
      default:
        JUMPOUT(0);
    }
  }
  unsigned int v6 = 0;
LABEL_13:
  uint64_t v5 = 0;
  if (*a1) {
    uint64_t v5 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void, uint64_t))(v5 + 64))(a1, v6, 2);
}

void _dispatch_mgr_queue_push(uint64_t a1, void *a2)
{
  if (*a2 < 0x1000uLL && (*a2 & 0x81) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Waiter pushed onto manager";
    __break(1u);
    JUMPOUT(0x3EE44);
  }
  a2[2] = 0;
  _dispatch_thread_setspecific(122, a1 + 48);
  unint64_t v11 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t)a2, memory_order_release);
  if (v11) {
    *(void *)(v11 + 16) = a2;
  }
  else {
    *(void *)(a1 + 104) = a2;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v11)
  {
    int v7 = atomic_fetch_or_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_release);
    if (((v7 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0) {
      _dispatch_event_loop_poke(-8, 0, 0, v2, v3, v4, v5, v6);
    }
  }
}

void _dispatch_mgr_queue_wakeup()
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Don't try to wake up or override the manager";
  __break(1u);
}

void sub_3F0F8()
{
}

void _dispatch_mgr_thread()
{
  if (_dispatch_kevent_workqueue_enabled)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Manager queue invoked with kevent workqueue enabled";
    __break(1u);
    JUMPOUT(0x3F160);
  }
  _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_mgr_q);
  _dispatch_mgr_priority_init();
  unint64_t v4 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x40020000000000;
  for (unint64_t i = qword_F0138; ; unint64_t i = v1)
  {
    BOOL v3 = 1;
    if (!(i >> 53)) {
      BOOL v3 = (i & 0xFFFFFFFC) != 0;
    }
    if (v3)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
      qword_F42C0 = i;
      __break(1u);
      JUMPOUT(0x3F29CLL);
    }
    unint64_t v0 = i;
    unint64_t v1 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)&qword_F0138, &v1, i & 0x7700000001 | v4, memory_order_acquire, memory_order_acquire);
    if (v1 == v0)
    {
      uint64_t v2 = pthread_self();
      pthread_get_stackaddr_np(v2);
      __memset_chk();
      _dispatch_mgr_invoke();
    }
  }
}

void _dispatch_mgr_priority_init()
{
  unint64_t v11 = off_F00A0;
  __attr = (pthread_attr_t *)off_F00A0;
  sched_param v9 = 0;
  qos_class_t v8 = pthread_attr_getschedparam((const pthread_attr_t *)off_F00A0, &v9);
  uint64_t v13 = (int)v8;
  uint64_t v12 = 6262;
  if (v8) {
    _dispatch_bug(v12, v13, v0, v1, v2, v3, v4, v5);
  }
  __qos_class[1] = v8;
  __qos_class[0] = QOS_CLASS_UNSPECIFIED;
  pthread_attr_get_qos_class_np(__attr, __qos_class, 0);
  if (dword_F4574 > __qos_class[0] && (_dispatch_set_qos_class_enabled & 1) != 0)
  {
    pthread_set_qos_class_self_np((qos_class_t)dword_F4574, 0);
    int v6 = _dispatch_mgr_sched_qos2prio(dword_F4574);
    if (v6 > v9.sched_priority) {
      v9.sched_priority = v6;
    }
  }
  if (_dispatch_mgr_sched > v9.sched_priority) {
    _dispatch_mgr_priority_apply();
  }
}

void _dispatch_mgr_invoke()
{
  memset(__b, 0, sizeof(__b));
  memset(__b, 0, 20);
  __b[3] = -4;
  __b[4] = &v7;
  LODWORD(__b[5]) = 0x100000;
  WORD2(__b[5]) &= 0xFE00u;
  BYTE5(__b[5]) &= ~2u;
  BYTE5(__b[5]) &= ~4u;
  uint64_t v13 = __b;
  _dispatch_thread_setspecific(29, (uint64_t)__b);
  while (1)
  {
    _dispatch_mgr_queue_drain();
    if (byte_F432E) {
      _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v0, v1, v2, v3, v4, v5);
    }
    uint64_t v12 = &_dispatch_mgr_q;
    uint64_t v9 = qword_F0130;
    uint64_t v10 = qword_F0130;
    uint64_t v8 = qword_F0130;
    uint64_t v11 = qword_F0130;
    _dispatch_event_loop_drain(qword_F0130 != 0);
  }
}

void _dispatch_kevent_workqueue_init()
{
  if (_dispatch_root_queues_pred != -1) {
    dispatch_once_f(&_dispatch_root_queues_pred, 0, (dispatch_function_t)_dispatch_root_queues_init_once);
  }
  if (_dispatch_kevent_workqueue_enabled)
  {
    if (_dispatch_mgr_sched_pred != -1) {
      dispatch_once_f(&_dispatch_mgr_sched_pred, 0, (dispatch_function_t)_dispatch_mgr_sched_init);
    }
    int v8 = _dispatch_mgr_sched;
    uint64_t v7 = 0;
    if (dword_F4574) {
      uint64_t v7 = _pthread_qos_class_encode();
    }
    if (v8 > dword_F4578) {
      uint64_t v7 = v8 | 0x20000000;
    }
    if (v7)
    {
      int v6 = _pthread_workqueue_set_event_manager_priority();
      if (v6) {
        _dispatch_bug(6510, v6, v0, v1, v2, v3, v4, v5);
      }
    }
  }
}

uint64_t _dispatch_mgr_sched_init(uint64_t a1)
{
  uint64_t v26 = a1;
  sched_param v25 = 0;
  uint64_t v24 = (pthread_attr_t *)off_F00A0;
  int v23 = pthread_attr_init((pthread_attr_t *)off_F00A0);
  uint64_t v32 = v23;
  uint64_t v31 = 6165;
  if (v23) {
    _dispatch_bug(v31, v32, v1, v2, v3, v4, v5, v6);
  }
  int v22 = pthread_attr_getschedpolicy(v24, &dword_F457C);
  uint64_t v30 = v22;
  uint64_t v29 = 6167;
  if (v22) {
    _dispatch_bug(v29, v30, v7, v8, v9, v10, v11, v12);
  }
  int v21 = pthread_attr_getschedparam(v24, &v25);
  uint64_t v28 = v21;
  uint64_t v27 = 6168;
  if (v21) {
    _dispatch_bug(v27, v28, v13, v14, v15, v16, v17, v18);
  }
  uint64_t result = qos_class_main();
  unsigned int v20 = result;
  if (result == 21) {
    unsigned int v20 = 25;
  }
  if (v20)
  {
    dword_F4574 = v20;
    uint64_t result = _dispatch_mgr_sched_qos2prio(v20);
    v25.sched_priority = result;
  }
  dword_F4578 = v25.sched_priority;
  _dispatch_mgr_sched = v25.sched_priority;
  return result;
}

void _dispatch_root_queue_poke(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 48))
  {
    uint64_t v11 = 0;
    if (*(void *)a1) {
      uint64_t v11 = *(uint64_t (***)())a1;
    }
    BOOL v10 = 1;
    if (v11[2] != (uint64_t (*)())((char *)&loc_50310 + 1))
    {
      uint64_t v9 = 0;
      if (*(void *)a1) {
        uint64_t v9 = *(uint64_t (***)())a1;
      }
      BOOL v10 = v9[2] == (uint64_t (*)())((char *)&loc_50910 + 1);
    }
    if (!v10
      || (int v8 = 0,
          atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 112), (unsigned int *)&v8, a2, memory_order_release, memory_order_relaxed), !v8))
    {
      _dispatch_root_queue_poke_slow((uint64_t (***)())a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
}

void _dispatch_root_queue_poke_slow(uint64_t (***a1)(), signed int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v85 = a1;
  signed int v84 = a2;
  int v83 = a3;
  signed int v82 = a2;
  int v81 = 78;
  unint64_t v97 = &_dispatch_root_queues_pred;
  unint64_t v96 = 0;
  dispatch_function_t v95 = (dispatch_function_t)_dispatch_root_queues_init_once;
  if (_dispatch_root_queues_pred != -1) {
    dispatch_once_f(v97, v96, v95);
  }
  int v94 = 3;
  unint64_t v93 = v85;
  uint64_t v92 = v84;
  uint64_t v32 = 0;
  if (*v85) {
    uint64_t v32 = *v85;
  }
  if (v32[2] == (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    int v106 = *((_DWORD *)v85 + 21);
    int v105 = 0;
    uint64_t v104 = 0;
    if ((v106 & 0x4000000) != 0)
    {
      uint64_t v104 = v106 & 0x8E000000 | 0xFFLL;
      int v105 = (unsigned __int16)(v106 & 0xF000) >> 12;
      BOOL v109 = v105 != 0;
      uint64_t v108 = 523;
      if (!v105) {
        _dispatch_abort(v108, v109, a3, a4, a5, a6, a7, a8);
      }
    }
    else
    {
      uint64_t v104 = v106 & 0x8E0000FF;
      int v105 = (unsigned __int16)(v106 & 0xF00) >> 8;
      if (!v105)
      {
        uint64_t v107 = v104;
LABEL_13:
        int v80 = _pthread_workqueue_addthreads();
        uint64_t v91 = v80;
        uint64_t v90 = 6840;
        if (v80) {
          _dispatch_bug(v90, v91, v8, v9, v10, v11, v12, v13);
        }
        int v79 = v80;
        return;
      }
    }
    uint64_t v107 = v104 | (1 << (v105 + 7));
    goto LABEL_13;
  }
  uint64_t v31 = 0;
  if (*v85) {
    uint64_t v31 = *v85;
  }
  if (v31[2] == (uint64_t (*)())((char *)&loc_50910 + 1))
  {
    int v100 = *((_DWORD *)v85 + 21);
    int v99 = 0;
    uint64_t v98 = 0;
    if ((v100 & 0x4000000) != 0)
    {
      uint64_t v98 = v100 & 0x8E000000 | 0xFFLL;
      int v99 = (unsigned __int16)(v100 & 0xF000) >> 12;
      BOOL v103 = v99 != 0;
      uint64_t v102 = 523;
      if (!v99) {
        _dispatch_abort(v102, v103, a3, a4, a5, a6, a7, a8);
      }
    }
    else
    {
      uint64_t v98 = v100 & 0x8E0000FF;
      int v99 = (unsigned __int16)(v100 & 0xF00) >> 8;
      if (!v99)
      {
        uint64_t v101 = v98;
LABEL_26:
        int v78 = _pthread_workqueue_add_cooperativethreads();
        uint64_t v89 = v78;
        uint64_t v88 = 6848;
        if (v78) {
          _dispatch_bug(v88, v89, v14, v15, v16, v17, v18, v19);
        }
        int v77 = v78;
        return;
      }
    }
    uint64_t v101 = v98 | (1 << (v99 + 7));
    goto LABEL_26;
  }
  unsigned int v76 = 0;
  unsigned int v76 = v85[4];
  uint64_t v30 = 0;
  if (v76[9]) {
    uint64_t v30 = v76[9];
  }
  if (v30)
  {
    while (dispatch_semaphore_signal((dispatch_semaphore_t)(v76 + 9)))
    {
      if (!--v82) {
        return;
      }
    }
  }
  BOOL v75 = 0;
  BOOL v75 = *((int *)v85 + 21) < 0;
  if (v75)
  {
    signed int v73 = v82;
    signed int v72 = v82;
    signed int v74 = v82;
    signed int v68 = v82;
    signed int v67 = v82;
    signed int v69 = v82;
    unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v85 + 14), v82, memory_order_relaxed);
    unsigned int v70 = add_explicit;
    unsigned int v65 = add_explicit;
    unsigned int v71 = add_explicit + v82;
  }
  else
  {
    int v64 = 0;
    BOOL v63 = 0;
    signed int v61 = v82;
    signed int v60 = v82;
    signed int v62 = v82;
    int v20 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v85 + 14), (unsigned int *)&v20, v82, memory_order_relaxed, memory_order_relaxed);
    if (v20) {
      int v64 = v20;
    }
    BOOL v59 = v20 == 0;
    BOOL v63 = v20 == 0;
    BOOL v58 = v63;
    if (v20) {
      return;
    }
  }
  signed int v57 = 0;
  int v56 = 0;
  int v55 = 0;
  int v54 = *((_DWORD *)v85 + 25);
  int v55 = v54;
  int v53 = v54;
  int v56 = v54;
  while (1)
  {
    if (v56 >= v83) {
      signed int v29 = v56 - v83;
    }
    else {
      signed int v29 = 0;
    }
    signed int v57 = v29;
    if (v82 > v29)
    {
      int v51 = v82 - v57;
      int v50 = v82 - v57;
      int v52 = v82 - v57;
      int v46 = v82 - v57;
      int v45 = v82 - v57;
      int v47 = v82 - v57;
      unsigned int v44 = atomic_fetch_add_explicit((atomic_uint *volatile)(v85 + 14), v57 - v82, memory_order_relaxed);
      unsigned int v48 = v44;
      unsigned int v43 = v44;
      unsigned int v49 = v44 - (v82 - v57);
      signed int v82 = v57;
    }
    if (!v82) {
      break;
    }
    int v42 = v56;
    BOOL v41 = 0;
    int v39 = v56 - v82;
    int v38 = v56 - v82;
    int v40 = v56 - v82;
    int v21 = v56;
    int v22 = v56;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)((char *)v85 + 100), (unsigned int *)&v22, v56 - v82, memory_order_acquire, memory_order_acquire);
    if (v22 != v21) {
      int v42 = v22;
    }
    BOOL v37 = v22 == v56;
    BOOL v41 = v22 == v56;
    int v56 = v42;
    BOOL v36 = v22 == v21;
    if (v22 == v21)
    {
      unsigned int v35 = (pthread_attr_t *)v76;
      uint64_t v34 = 0;
      unsigned int v33 = (pthread_t *)&v34;
      if (v85 == &_dispatch_mgr_root_queue) {
        unsigned int v33 = (pthread_t *)_dispatch_mgr_root_queue_init();
      }
      do
      {
        _dispatch_retain((uint64_t)v85);
        while (1)
        {
          int v81 = pthread_create(v33, v35, (void *(__cdecl *)(void *))_dispatch_worker_thread, v85);
          if (!v81) {
            break;
          }
          if (v81 != 35)
          {
            uint64_t v87 = v81;
            uint64_t v86 = 6907;
            _dispatch_bug(6907, v81, v23, v24, v25, v26, v27, v28);
          }
          _dispatch_temporary_resource_shortage();
        }
        --v82;
      }
      while (v82);
      return;
    }
  }
}

void _dispatch_root_queue_poke_and_wakeup(uint64_t a1, signed int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = 0;
  if (*(void *)a1) {
    uint64_t v13 = *(uint64_t (***)())a1;
  }
  BOOL v12 = 1;
  if (v13[2] != (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    uint64_t v11 = 0;
    if (*(void *)a1) {
      uint64_t v11 = *(uint64_t (***)())a1;
    }
    BOOL v12 = v11[2] == (uint64_t (*)())((char *)&loc_50910 + 1);
  }
  if (!v12) {
    goto LABEL_15;
  }
  for (int i = *(_DWORD *)(a1 + 112); ; int i = v9)
  {
    unsigned int v10 = i ? i : a2;
    int v8 = i;
    int v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 112), (unsigned int *)&v9, v10, memory_order_release, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  if (i <= 0) {
LABEL_15:
  }
    _dispatch_root_queue_poke_slow((uint64_t (***)())a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_root_queue_wakeup(uint64_t a1, uint64_t a2, char a3)
{
  if ((a3 & 8) == 0)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 84);
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Don't try to wake up or override a root queue";
    qword_F42C0 = v3;
    __break(1u);
    JUMPOUT(0x4098CLL);
  }
  if (a3) {
    _dispatch_release_2_tailcall(a1);
  }
}

void _dispatch_root_queue_push(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v28 = _dispatch_thread_getspecific(0x1DuLL);
  char v23 = 0;
  if (v28) {
    char v23 = v28[44];
  }
  if ((v23 & 1) == 0) {
    goto LABEL_11;
  }
  uint64_t v27 = (uint64_t *)*((void *)v28 + 1);
  unsigned int v26 = *(_DWORD *)(a1 + 84) & 0x80000000;
  BOOL v22 = 1;
  if (v27) {
    BOOL v22 = *(int *)(a1 + 84) < 0;
  }
  if (!v22) {
    goto LABEL_11;
  }
  uint64_t v25 = *(void *)v28;
  unsigned int v24 = *((_DWORD *)v28 + 4);
  *(void *)uint64_t v28 = a1;
  *((void *)v28 + 1) = a2;
  *((_DWORD *)v28 + 4) = a3;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tdeferring item %p, rq %p, qos %d", v3, v4, v5, v6, v7, v8, v9, 7572);
  if (v26) {
    v28[44] = 0;
  }
  if (v27)
  {
    a3 = v24;
    a1 = v25;
    a2 = v27;
LABEL_11:
    char v21 = 0;
    if ((*(unsigned char *)(a1 + 87) & 8) != 0)
    {
      if ((unint64_t)*a2 >= 0x1000)
      {
        uint64_t v20 = 0;
        if (*a2) {
          uint64_t v20 = *a2;
        }
        char v19 = 1;
        if (*(void *)(v20 + 16) != 1)
        {
          uint64_t v18 = 0;
          if (*a2) {
            uint64_t v18 = *a2;
          }
          BOOL is_timer = 0;
          if (*(unsigned char *)(v18 + 16) == 19) {
            BOOL is_timer = _dispatch_source_is_timer((uint64_t)a2);
          }
          char v19 = is_timer;
        }
        char v32 = v19 & 1;
      }
      else
      {
        char v32 = 1;
      }
      char v21 = v32 ^ 1;
    }
    if (v21)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
      qword_F42C0 = (uint64_t)a2;
      __break(1u);
      JUMPOUT(0x40D1CLL);
    }
    unsigned int v34 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    if (v34)
    {
      BOOL v16 = 0;
      if (a3) {
        BOOL v16 = a3 != v34;
      }
      BOOL v35 = v16;
    }
    else
    {
      unsigned int v33 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
      BOOL v15 = 0;
      if (v33) {
        BOOL v15 = a3 > v33;
      }
      BOOL v35 = v15;
    }
    if (v35)
    {
      _dispatch_root_queue_push_override(a1, a2, a3);
    }
    else
    {
      a2[2] = 0;
      _dispatch_thread_setspecific(122, a1 + 48);
      unint64_t v36 = atomic_exchange_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t)a2, memory_order_release);
      if (v36) {
        *(void *)(v36 + 16) = a2;
      }
      else {
        *(void *)(a1 + 104) = a2;
      }
      _dispatch_thread_setspecific(122, 0);
      if (!v36) {
        _dispatch_root_queue_poke_and_wakeup(a1, 1, 0, v10, v11, v12, v13, v14);
      }
    }
  }
}

void _dispatch_root_queue_push_override(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  char v14 = 0;
  if ((*(unsigned char *)(a1 + 87) & 0x80) != 0)
  {
    char v14 = 2;
  }
  else if ((*(unsigned char *)(a1 + 87) & 8) != 0)
  {
    char v14 = 4;
  }
  BOOL v11 = 1;
  if (a3) {
    BOOL v11 = a3 > 6;
  }
  if (v11)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_F42C0 = a3;
    __break(1u);
    JUMPOUT(0x410DCLL);
  }
  int v20 = 0;
  if ((v14 & 2) != 0)
  {
    int v20 = 1;
  }
  else if ((v14 & 4) != 0)
  {
    int v20 = 2;
  }
  uint64_t v13 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * a3 + v20 - 3)];
  unint64_t v12 = (unint64_t)a2;
  BOOL v10 = 0;
  if ((unint64_t)*a2 >= 0x1000)
  {
    uint64_t v9 = 0;
    if (*a2) {
      uint64_t v9 = *a2;
    }
    BOOL v10 = *(void *)(v9 + 16) == 256;
  }
  if (v10)
  {
    uint64_t v8 = 0;
    if (a1) {
      uint64_t v8 = a1;
    }
    a2[4] = v8;
  }
  else
  {
    uint64_t v18 = _dispatch_thread_getspecific(0x16uLL);
    if (v18)
    {
      _dispatch_thread_setspecific(22, v18[2]);
      uint64_t v17 = v18;
    }
    else
    {
      uint64_t v17 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    unint64_t v12 = (unint64_t)v17;
    *uint64_t v17 = &unk_ECDE0;
    v17[5] = v17;
    v17[7] = a1;
    v17[6] = a2;
    v17[1] = -1;
    v17[3] = -1;
  }
  *(void *)(v12 + 16) = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(v13 + 6));
  unint64_t v19 = atomic_exchange_explicit((atomic_ullong *volatile)(v13 + 6), v12, memory_order_release);
  if (v19) {
    *(void *)(v19 + 16) = v12;
  }
  else {
    v13[13] = (uint64_t (**)())v12;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v19) {
    _dispatch_root_queue_poke_and_wakeup((uint64_t)v13, 1, 0, v3, v4, v5, v6, v7);
  }
}

void *dispatch_pthread_root_queue_create(const char *a1, int a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_pthread_root_queue_create(a1, a2, a3, a4, 0, a6, a7, a8);
}

void *_dispatch_pthread_root_queue_create(const char *a1, int a2, uint64_t a3, const void *a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v35 = a1;
  int v31 = 0;
  if (a2 < 0) {
    int v25 = (char)a2;
  }
  else {
    int v25 = 0;
  }
  if (a1)
  {
    uint64_t v30 = _dispatch_strdup_if_mutable(a1);
    if (v30 != v35)
    {
      int v31 = 0x200000;
      BOOL v35 = v30;
    }
  }
  signed int v29 = _dispatch_object_alloc((uint64_t)_OS_dispatch_queue_pthread_root_vtable, 0x140uLL, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  _dispatch_queue_init(v29, v31, 4095, 0, v8, v9, v10, v11);
  v29[9] = v35;
  v29[7] = 0x60000000000000;
  *((_DWORD *)v29 + 21) = 0x80000000;
  v29[4] = v29 + 15;
  uint64_t v28 = (pthread_attr_t *)(v29 + 15);
  _dispatch_root_queue_init_pthread_pool((uint64_t)v29, v25, 0x80000000);
  if (a3)
  {
    __memcpy_chk();
    _dispatch_mgr_priority_raise(v28);
  }
  else
  {
    int v27 = pthread_attr_init(v28);
    if (v27) {
      _dispatch_bug(7641, v27, v12, v13, v14, v15, v16, v17);
    }
  }
  int v26 = pthread_attr_setdetachstate(v28, 2);
  if (v26) {
    _dispatch_bug(7644, v26, v18, v19, v20, v21, v22, v23);
  }
  if (a4) {
    v29[23] = _dispatch_Block_copy(a4);
  }
  if (a5) {
    *(_OWORD *)(v29 + 33) = *a5;
  }
  _dispatch_object_debug(v29, "%s", v18, v19, v20, v21, v22, v23, (char)"_dispatch_pthread_root_queue_create");
  return v29;
}

void *_dispatch_pthread_root_queue_create_with_observer_hooks_4IOHID(const char *a1, int a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)a4 || !*(void *)(a4 + 8))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid pthread root queue observer hooks";
    __break(1u);
    JUMPOUT(0x41878);
  }
  return _dispatch_pthread_root_queue_create(a1, a2, a3, a5, (_OWORD *)a4, a6, a7, a8);
}

BOOL _dispatch_queue_is_exclusively_owned_by_current_thread_4IOHID(uint64_t a1)
{
  if (*(_WORD *)(a1 + 80) != 1)
  {
    uint64_t v1 = *(unsigned __int16 *)(a1 + 80);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue type";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0x4190CLL);
  }
  int v3 = *(void *)(a1 + 56);
  return ((v3 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
}

uint64_t *dispatch_pthread_root_queue_copy_current()
{
  uint64_t v2 = (uint64_t *)_dispatch_thread_getspecific(0x14uLL);
  if (!v2) {
    return 0;
  }
  while (v2[3])
    uint64_t v2 = (uint64_t *)v2[3];
  uint64_t v1 = 0;
  if (*v2) {
    uint64_t v1 = *v2;
  }
  if (*(void *)(v1 + 16) != 328721) {
    return 0;
  }
  _os_object_retain_with_resurrect((uint64_t)v2);
  return v2;
}

void _dispatch_pthread_root_queue_dispose(uint64_t *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (pthread_attr_t *)a1[4];
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_pthread_root_queue_dispose");
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  pthread_attr_destroy(v8);
  _dispatch_semaphore_dispose((uint64_t)v8[1].__opaque);
  if (v8[1].__sig) {
    _Block_release((const void *)v8[1].__sig);
  }
  a1[3] = (uint64_t)&off_F0600;
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

void _dispatch_runloop_queue_wakeup(uint64_t a1, unsigned int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 80) & 0x800000) != 0
    || (a3 & 2) != 0
    && (atomic_fetch_or_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_release) & 0xFFFFFFFC) == 0)
  {
    _dispatch_lane_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else if (*(void *)(a1 + 48))
  {
    _dispatch_runloop_queue_poke((uint64_t *)a1, a2, a3);
  }
  else
  {
    unsigned int v8 = (atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFF0FFFFFFFFLL, memory_order_relaxed) & 0x700000000) >> 32;
    if (v8)
    {
      if (*(void *)(a1 + 48)) {
        _dispatch_runloop_queue_poke((uint64_t *)a1, v8, a3);
      }
      if (_dispatch_set_qos_class_enabled) {
        _pthread_qos_override_end_direct();
      }
    }
    else if (a3)
    {
      _dispatch_release_2_tailcall(a1);
    }
  }
}

void _dispatch_runloop_queue_poke(uint64_t *a1, unsigned int a2, char a3)
{
  uint64_t v6 = 0;
  if (*a1) {
    uint64_t v6 = *a1;
  }
  if (*(void *)(v6 + 16) == 394769 && _dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(&_dispatch_main_q_handle_pred, a1, (dispatch_function_t)_dispatch_runloop_queue_handle_init);
  }
  unsigned int v14 = a2;
  if (!a2) {
    unsigned int v14 = (*((_DWORD *)a1 + 21) & 0xF000u) >> 12;
  }
  if (v14 <= (*((_DWORD *)a1 + 21) & 0xF00u) >> 8) {
    unsigned int v5 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
  }
  else {
    unsigned int v5 = v14;
  }
  for (unint64_t i = a1[7]; ; unint64_t i = v4)
  {
    unint64_t v13 = i;
    unint64_t v12 = (unint64_t)v5 << 32;
    if ((i & 0x700000000) < v12)
    {
      unint64_t v13 = i & 0xFFFFFFF8FFFFFFFFLL | v12;
      if (i & 0x1000000000 | v12 & 0x1000000000) {
        v13 |= 0x800000000uLL;
      }
    }
    if (i == v13) {
      break;
    }
    unint64_t v3 = i;
    unint64_t v4 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 7), &v4, v13, memory_order_relaxed, memory_order_relaxed);
    if (v4 == v3)
    {
      unsigned int v7 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
      if (v5 > v7)
      {
        if (_dispatch_set_qos_class_enabled) {
          _pthread_qos_override_start_direct();
        }
        if (i & 0x700000000) >> 32 > v7 && (_dispatch_set_qos_class_enabled) {
          _pthread_qos_override_end_direct();
        }
      }
      break;
    }
  }
  _dispatch_runloop_queue_class_poke((uint64_t)a1);
  if (a3) {
    _dispatch_release_2_tailcall((uint64_t)a1);
  }
}

void *_dispatch_runloop_root_queue_create_4CF(const char *a1, uint64_t a2)
{
  unsigned int v39 = _dispatch_thread_getspecific(4uLL);
  if (a2) {
    return 0;
  }
  int v38 = _dispatch_object_alloc((uint64_t)_OS_dispatch_queue_runloop_vtable, 0x78uLL, v2, v3, v4, v5, v6, v7);
  _dispatch_queue_init(v38, 0x40000, 1, 0x1000000000, v8, v9, v10, v11);
  v38[3] = &off_F0680;
  if (a1) {
    BOOL v37 = a1;
  }
  else {
    BOOL v37 = "runloop-queue";
  }
  v38[9] = v37;
  BOOL v36 = 0;
  if ((v39 & 0x22000000) == 0) {
    BOOL v36 = (v39 & 0x3F00) != 0;
  }
  if (v36)
  {
    if ((v39 & 0x20000000) != 0) {
      _dispatch_abort(458, (v39 & 0x20000000) == 0, v12, v13, v14, v15, v16, v17);
    }
    unsigned int v18 = (v39 & 0x3FFF00) >> 8;
    unsigned int v19 = __clz(__rbit32(v18));
    if (v18) {
      unsigned int v20 = v19 + 1;
    }
    else {
      unsigned int v20 = 0;
    }
    *((_DWORD *)v38 + 21) = v39 | (v20 << 8);
  }
  _dispatch_runloop_queue_handle_init(v38);
  if ((v38[10] & 0x40000) == 0) {
    _dispatch_abort(2140, (v38[10] & 0x40000) != 0, v21, v22, v23, v24, v25, v26);
  }
  if ((v38[10] & 0x1000000) != 0) {
    _dispatch_abort(2146, (v38[10] & 0x1000000) == 0, v21, v22, v23, v24, v25, v26);
  }
  for (uint64_t i = v38[7]; ; uint64_t i = v34)
  {
    unsigned int v44 = _dispatch_thread_getspecific(3uLL);
    uint64_t v33 = i;
    uint64_t v34 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v38 + 7), (unint64_t *)&v34, i & 0xFFFFFFFF00000003 | v44 & 0xFFFFFFFC, memory_order_relaxed, memory_order_relaxed);
    if (v34 == v33) {
      break;
    }
  }
  _dispatch_object_debug(v38, "%s", v27, v28, v29, v30, v31, v32, (char)"_dispatch_runloop_root_queue_create_4CF");
  return v38;
}

void _dispatch_runloop_queue_handle_init(void *a1)
{
  kern_return_t v9;
  mach_port_context_t context;
  mach_port_options_t options;
  mach_port_name_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  mach_port_name_t v17;
  void *v18;

  uint64_t v14 = a1;
  uint64_t v13 = a1;
  uint64_t v12 = 0;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  options.reserved[1] = 0;
  *(_OWORD *)&options.flags = xmmword_CA9B8;
  context = (mach_port_context_t)v13;
  uint64_t v9 = 0;
  mach_port_name_t name = 0;
  uint64_t v7 = 0;
  if (*v13) {
    uint64_t v7 = *v13;
  }
  if (*(void *)(v7 + 16) == 394769)
  {
    options.flags |= 2u;
    options.mpl.mpl_qlimit = 1;
  }
  uint64_t v9 = mach_port_construct(mach_task_self_, &options, context, &name);
  if (v9 == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x42A84);
  }
  uint64_t v16 = v9;
  uint64_t v15 = 7808;
  if (v9) {
    _dispatch_bug(v15, v16, v1, v2, v3, v4, v5, v6);
  }
  uint64_t v12 = name;
  unsigned int v18 = v13;
  uint64_t v17 = name;
  v13[4] = name;
  _dispatch_program_is_probably_callback_driven = 1;
}

uint64_t _dispatch_runloop_queue_xref_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_runloop_queue_xref_dispose");
  unsigned int v16 = (atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFF0FFFFFFFFLL, memory_order_relaxed) & 0x700000000) >> 32;
  if ((*(_DWORD *)(a1 + 80) & 0x40000) == 0) {
    _dispatch_abort(2160, (*(_DWORD *)(a1 + 80) & 0x40000) != 0, v8, v9, v10, v11, v12, v13);
  }
  if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
    _dispatch_abort(2166, (*(_DWORD *)(a1 + 80) & 0x1000000) == 0, v8, v9, v10, v11, v12, v13);
  }
  atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFFFFFFF00000003, memory_order_relaxed);
  uint64_t v15 = 0;
  if (*(void *)a1) {
    uint64_t v15 = *(void *)a1;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(v15 + 64))(a1, v16, 2);
  if (v16)
  {
    if (_dispatch_set_qos_class_enabled) {
      return _pthread_qos_override_end_direct();
    }
  }
  return result;
}

void _dispatch_runloop_queue_dispose(uint64_t *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  _dispatch_runloop_queue_handle_dispose((mach_port_context_t)a1);
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

void _dispatch_runloop_queue_handle_dispose(mach_port_context_t a1)
{
  kern_return_t v8;
  mach_port_name_t v9;

  uint64_t v9 = *(void *)(a1 + 32);
  BOOL v7 = 0;
  if (v9) {
    BOOL v7 = v9 != -1;
  }
  if (v7)
  {
    *(void *)(a1 + 32) = 0;
    uint64_t v8 = mach_port_destruct(mach_task_self_, v9, -1, a1);
    if (v8 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x4308CLL);
    }
    if (v8) {
      _dispatch_bug(7864, v8, v1, v2, v3, v4, v5, v6);
    }
  }
}

BOOL _dispatch_runloop_root_queue_perform_4CF(dispatch_object_s *a1)
{
  uint64_t v4 = 0;
  if (*(void *)a1) {
    uint64_t v4 = *(void *)a1;
  }
  if (*(void *)(v4 + 16) != 395025)
  {
    uint64_t v3 = 0;
    if (*(void *)a1) {
      uint64_t v3 = *(void *)a1;
    }
    uint64_t v1 = *(void *)(v3 + 16);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0x431F4);
  }
  dispatch_retain(a1);
  BOOL v5 = _dispatch_runloop_queue_drain_one(a1);
  dispatch_release(a1);
  return v5;
}

BOOL _dispatch_runloop_queue_drain_one(void *a1)
{
  unsigned int v70 = a1;
  if (!a1[6]) {
    return 0;
  }
  long long v69 = 0uLL;
  char v68 = 0;
  unint64_t v169 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  unint64_t v167 = v169 & 0xFFFFFFFFFFFFFFFELL;
  if ((v169 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    char v168 = 0;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v6, v7, v8, v9, v10, v11, v12, 825);
    unint64_t v171 = v167;
    if (v167)
    {
      if (v171 != -4)
      {
        unint64_t v170 = v171;
        uint64_t v184 = (void *)v171;
        int v181 = 1;
        int v180 = 1;
        int v182 = 1;
        int v176 = 1;
        int v175 = 1;
        int v177 = 1;
        unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v171 + 96), 0xFFFFFFFF, memory_order_relaxed);
        unsigned int v178 = add_explicit;
        unsigned int v173 = add_explicit;
        unsigned int v179 = add_explicit - 1;
        int v183 = add_explicit - 1;
        if (((add_explicit - 1) & 0x80000000) != 0)
        {
          if (v183 <= -2)
          {
            qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x43414);
          }
          v184[7] = 0xDEAD000000000000;
          v172 = v184;
          _dispatch_object_dealloc(v184);
        }
      }
    }
    _dispatch_thread_setspecific(27, -4);
    char v168 = 1;
  }
  char v68 = v168;
  signed int v67 = v70;
  uint64_t v155 = v70;
  uint64_t v154 = &v69;
  unsigned int v159 = &v69;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v69, v1, v2, v3, v4, v5);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v155, 21, (uint64_t)v154, v13, v14, v15, v16);
  signed int v72 = 0;
  signed int v72 = _dispatch_thread_getspecific(4uLL);
  uint64_t v66 = v72;
  unsigned int v65 = 0;
  uint64_t v123 = v72;
  char v122 = 1;
  BOOL v126 = (v72 & 0x20000000) == 0;
  uint64_t v125 = 458;
  if ((v72 & 0x20000000) != 0) {
    _dispatch_abort(v125, v126, v17, v18, v19, v20, v21, v22);
  }
  unsigned int v121 = v123 & 0x8E0000FF;
  unint64_t v124 = (unint64_t)(v123 & 0x3FFF00) >> 8;
  unsigned int v23 = (v123 & 0x3FFF00) >> 8;
  unsigned int v24 = __clz(__rbit32(v23));
  if (v23) {
    unsigned int v25 = v24 + 1;
  }
  else {
    unsigned int v25 = 0;
  }
  v121 |= v25 << 8;
  unsigned int v65 = v121;
  uint64_t v64 = 0;
  uint64_t v145 = 0;
  uint64_t v145 = _dispatch_thread_getspecific(0x1CuLL);
  if (v145)
  {
    uint64_t v146 = v145;
    os_retain(v145);
  }
  uint64_t v64 = (uint64_t)v145;
  unsigned int v63 = 0;
  unsigned int v149 = v65;
  unsigned int v148 = 0;
  unsigned int v148 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v147 = v148;
  if (v148)
  {
    if ((v149 & 0xFFF) != 0)
    {
      v147 &= 0x880F0000;
      if ((v148 & 0xFFF) > (v149 & 0xFFF)) {
        int v59 = v148 & 0xFFF;
      }
      else {
        int v59 = v149 & 0xFFF;
      }
      v147 |= v59;
      unsigned int v151 = v149 & 0xF000;
      unsigned int v153 = v147 & 0xF00;
      if (v151 >> 12 > v153 >> 8) {
        v149 &= 0x4400F000u;
      }
      else {
        v149 &= 0x40000000u;
      }
      v147 |= v149;
    }
    else
    {
      if ((v147 & 0xFFF) != 0) {
        v147 |= 0x40000000u;
      }
      unsigned int v150 = v149 & 0xF000;
      unsigned int v152 = v147 & 0xF00;
      if (v150 >> 12 > v152 >> 8)
      {
        v147 &= 0xFFFF0FFF;
        v147 |= v149 & 0x400F000;
      }
    }
  }
  else
  {
    unsigned int v147 = v149 & 0xFFF0FFFF;
  }
  _dispatch_thread_setspecific(25, v147);
  unsigned int v63 = v148;
  unsigned int v83 = 15;
  unsigned int v82 = 0;
  unsigned int v82 = _dispatch_thread_getspecific(0x19uLL);
  int v160 = v82 & 0xF0000;
  if ((v82 & 0xF0000) >> 16 < v83)
  {
    v82 &= 0xFFF0FFFF;
    v82 |= v83 << 16;
    _dispatch_thread_setspecific(25, v82);
  }
  memset(v62, 0, sizeof(v62));
  uint64_t v90 = v70;
  uint64_t v89 = v70 + 13;
  uint64_t v88 = 0;
  uint64_t v87 = 0;
  uint64_t v86 = v70[13];
  uint64_t v87 = v86;
  uint64_t v85 = v86;
  uint64_t v88 = v86;
  if (!v86) {
    uint64_t v88 = _dispatch_wait_for_enqueuer(v89);
  }
  uint64_t v84 = v88;
  signed int v61 = (void *)v88;
  uint64_t v120 = v70;
  uint64_t v119 = v88;
  uint64_t v118 = v88;
  uint64_t v117 = 0;
  uint64_t v116 = 0;
  uint64_t v115 = 0;
  uint64_t v114 = 0;
  uint64_t v113 = *(void *)(v88 + 16);
  uint64_t v114 = v113;
  uint64_t v112 = v113;
  uint64_t v117 = v113;
  uint64_t v111 = v113;
  uint64_t v110 = v113;
  v70[13] = v113;
  uint64_t v109 = v111;
  if (!v117)
  {
    uint64_t v106 = 0;
    uint64_t v107 = 0;
    uint64_t v108 = v120 + 6;
    BOOL v105 = 0;
    uint64_t v104 = (atomic_ullong *)(v120 + 6);
    uint64_t v115 = v120[6];
    while (1)
    {
      uint64_t v127 = v115;
      if (v118 != (v115 & 0xFFFFFFFFFFFFFFF8)) {
        break;
      }
      uint64_t v116 = 0;
      uint64_t v94 = 0;
      uint64_t v26 = v115;
      uint64_t v27 = v115;
      atomic_compare_exchange_strong_explicit(v104, (unint64_t *)&v27, 0, memory_order_release, memory_order_relaxed);
      if (v27 != v26) {
        uint64_t v115 = v27;
      }
      BOOL v93 = v27 == v26;
      BOOL v105 = v27 == v26;
      if (v27 == v26) {
        goto LABEL_46;
      }
    }
    uint64_t v103 = v118;
    uint64_t v102 = 0;
    uint64_t v101 = 0;
    uint64_t v100 = *(void *)(v118 + 16);
    uint64_t v101 = v100;
    uint64_t v99 = v100;
    uint64_t v102 = v100;
    if (!v100) {
      uint64_t v102 = _dispatch_wait_for_enqueuer((unint64_t *)(v103 + 16));
    }
    uint64_t v98 = v102;
    uint64_t v117 = v102;
    uint64_t v97 = v102;
    uint64_t v96 = v102;
    v120[13] = v102;
    uint64_t v95 = v97;
LABEL_46:
    BOOL v92 = v105;
  }
  uint64_t v91 = v117;
  uint64_t v60 = v117;
  _dispatch_continuation_pop_inline(v61, (uint64_t)v62, 0x80000, (uint64_t)v70);
  if (!v60)
  {
    uint64_t v58 = 0;
    if (*v70) {
      uint64_t v58 = *v70;
    }
    (*(void (**)(void *, void))(v58 + 64))(v70, 0);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: runloop queue restore", v28, v29, v30, v31, v32, v33, v34, 8135);
  unsigned int v158 = v63;
  unsigned int v157 = 0;
  unsigned int v157 = _dispatch_thread_getspecific(0x19uLL);
  v158 &= 0xFFF0FFFF;
  v158 |= v157 & 0xF0000;
  _dispatch_thread_setspecific(25, v158);
  unsigned int v162 = 0;
  unsigned int v162 = _dispatch_thread_getspecific(0x19uLL);
  int v164 = v162 & 0xF0000;
  unsigned int v161 = (v162 & 0xF0000) >> 16;
  if ((v162 & 0xF0000) >> 16)
  {
    v162 &= 0xFFF0FFFF;
    _dispatch_thread_setspecific(25, v162);
    BOOL v163 = v161 != 15;
  }
  else
  {
    BOOL v163 = 0;
  }
  uint64_t v74 = (uint64_t)v66;
  uint64_t v73 = v64;
  if (v66 == (void *)-1) {
    uint64_t v74 = 0;
  }
  uint64_t v78 = v74;
  uint64_t v77 = v73;
  uint64_t v76 = 6;
  uint64_t v131 = v74;
  BOOL v144 = v74 != -1;
  uint64_t v143 = 2395;
  if (v74 == -1) {
    _dispatch_abort(v143, v144, v35, v36, v37, v38, v39, v40);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v142 = v131;
    uint64_t v141 = 4261412863;
    uint64_t v140 = 0;
    v131 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v130 = 0;
    uint64_t v133 = 0;
    uint64_t v133 = _dispatch_thread_getspecific(4uLL);
    unint64_t v130 = (unint64_t)v133;
    uint64_t v129 = 0x1000000;
    uint64_t v128 = 2281701376;
    if ((v133 & 0x1000000) != 0)
    {
      if (v131)
      {
        uint64_t v57 = v131;
      }
      else
      {
        unint64_t v139 = v130;
        uint64_t v138 = v129;
        uint64_t v137 = 0;
        uint64_t v57 = v130 & (~v129 | 0xFFFFFF);
      }
      uint64_t v132 = v57;
    }
    else
    {
      unint64_t v136 = v130;
      uint64_t v135 = v128;
      uint64_t v134 = 0;
      v130 &= ~v128 | 0xFFFFFF;
      if (v131 == v130) {
        uint64_t v132 = 0;
      }
      else {
        uint64_t v132 = v131;
      }
    }
  }
  else
  {
    uint64_t v132 = 0;
  }
  uint64_t v78 = v132;
  if (v132)
  {
LABEL_81:
    uint64_t v79 = _dispatch_set_priority_and_voucher_slow(v78, (_DWORD *)v77, v76);
    goto LABEL_82;
  }
  if (v77 != -1)
  {
    int v56 = (void *)v77;
    if (v56 == _dispatch_thread_getspecific(0x1CuLL))
    {
      BOOL v75 = (v76 & 4) != 0;
      if ((v76 & 2) != 0)
      {
        if (v75 && v77)
        {
          object = (void *)v77;
          os_release((void *)v77);
        }
        uint64_t v77 = -1;
      }
      else if (!v75 && v77)
      {
        int v81 = (void *)v77;
        os_retain((void *)v77);
      }
      uint64_t v79 = v77;
      goto LABEL_82;
    }
    goto LABEL_81;
  }
  uint64_t v79 = -1;
LABEL_82:
  uint64_t v156 = &v69;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v69, v36, v37, v38, v39, v40);
  if (v68)
  {
    BOOL v47 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4;
    BOOL v166 = v47;
    uint64_t v165 = 871;
    if (!v47) {
      _dispatch_abort(v165, v166, v41, v42, v43, v44, v45, v46);
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: clear current", v48, v49, v50, v51, v52, v53, v54, 872);
    _dispatch_thread_setspecific(27, 0);
    _dispatch_thread_setspecific(5, 0);
  }
  _dispatch_force_cache_cleanup();
  return v60 != 0;
}

void _dispatch_runloop_root_queue_wakeup_4CF(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0;
  if (*a1) {
    uint64_t v10 = *a1;
  }
  if (*(void *)(v10 + 16) != 395025)
  {
    uint64_t v9 = 0;
    if (*a1) {
      uint64_t v9 = *a1;
    }
    uint64_t v8 = *(void *)(v9 + 16);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_F42C0 = v8;
    __break(1u);
    JUMPOUT(0x441E4);
  }
  _dispatch_runloop_queue_wakeup((uint64_t)a1, 0, 0, a4, a5, a6, a7, a8);
}

uint64_t _dispatch_runloop_root_queue_get_port_4CF(uint64_t *a1)
{
  uint64_t v4 = 0;
  if (*a1) {
    uint64_t v4 = *a1;
  }
  if (*(void *)(v4 + 16) != 395025)
  {
    uint64_t v3 = 0;
    if (*a1) {
      uint64_t v3 = *a1;
    }
    uint64_t v1 = *(void *)(v3 + 16);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0x44328);
  }
  return *((unsigned int *)a1 + 8);
}

uint64_t _dispatch_get_main_queue_handle_4CF()
{
  if (_dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(&_dispatch_main_q_handle_pred, &_dispatch_main_q, (dispatch_function_t)_dispatch_runloop_queue_handle_init);
  }
  return unk_F0020;
}

uint64_t _dispatch_get_main_queue_port_4CF()
{
  return _dispatch_get_main_queue_handle_4CF();
}

void _dispatch_main_queue_callback_4CF()
{
  if (!dword_F0070)
  {
    dword_F0070 = 1;
    _dispatch_main_queue_drain(&_dispatch_main_q);
    dword_F0070 = 0;
  }
}

void _dispatch_main_queue_drain(void *a1)
{
  uint64_t v76 = a1;
  long long v75 = 0uLL;
  if (!a1[6]) {
    return;
  }
  uint64_t v74 = v76;
  uint64_t v88 = v76;
  BOOL v92 = v76;
  int v91 = 0;
  int v90 = *((_DWORD *)v76 + 20);
  int v91 = v90;
  int v89 = v90;
  if (((BYTE2(v90) >> 2) & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_main_queue_callback_4CF called after dispatch_main()";
    __break(1u);
    JUMPOUT(0x4452CLL);
  }
  uint64_t v73 = 0;
  uint64_t v72 = 0;
  uint64_t v71 = v76[7];
  uint64_t v72 = v71;
  uint64_t v70 = v71;
  uint64_t v73 = v71;
  uint64_t v77 = v71;
  int v107 = v71;
  if (((v71 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    uint64_t v69 = v73;
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_main_queue_callback_4CF called from the wrong thread";
    qword_F42C0 = v73;
    __break(1u);
    JUMPOUT(0x445DCLL);
  }
  predicate = &_dispatch_main_q_handle_pred;
  context = v76;
  dispatch_function_t function = (dispatch_function_t)_dispatch_runloop_queue_handle_init;
  if (_dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(predicate, context, function);
  }
  unint64_t v150 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  unint64_t v148 = v150 & 0xFFFFFFFFFFFFFFFELL;
  if ((v150 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    char v149 = 0;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v6, v7, v8, v9, v10, v11, v12, 825);
    unint64_t v152 = v148;
    if (v148)
    {
      if (v152 != -4)
      {
        unint64_t v151 = v152;
        uint64_t v165 = (void *)v152;
        int v162 = 1;
        int v161 = 1;
        int v163 = 1;
        int v157 = 1;
        int v156 = 1;
        int v158 = 1;
        unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v152 + 96), 0xFFFFFFFF, memory_order_relaxed);
        unsigned int v159 = add_explicit;
        unsigned int v154 = add_explicit;
        unsigned int v160 = add_explicit - 1;
        int v164 = add_explicit - 1;
        if (((add_explicit - 1) & 0x80000000) != 0)
        {
          if (v164 <= -2)
          {
            qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x447A4);
          }
          v165[7] = 0xDEAD000000000000;
          unsigned int v153 = v165;
          _dispatch_object_dealloc(v165);
        }
      }
    }
    _dispatch_thread_setspecific(27, -4);
    char v149 = 1;
  }
  if ((v149 & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
    __break(1u);
    JUMPOUT(0x44814);
  }
  char v68 = v76;
  unint64_t v139 = v76;
  uint64_t v138 = &v75;
  uint64_t v137 = 0;
  uint64_t v140 = &v75;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v75, v1, v2, v3, v4, v5);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v139, 21, v137, v13, v14, v15, v16);
  uint64_t v78 = 0;
  uint64_t v78 = _dispatch_thread_getspecific(4uLL);
  signed int v67 = v78;
  unsigned int v66 = 0;
  uint64_t v102 = v78;
  char v101 = 1;
  BOOL v105 = (v78 & 0x20000000) == 0;
  uint64_t v104 = 458;
  if ((v78 & 0x20000000) != 0) {
    _dispatch_abort(v104, v105, v17, v18, v19, v20, v21, v22);
  }
  unsigned int v100 = v102 & 0x8E0000FF;
  unint64_t v103 = (unint64_t)(v102 & 0x3FFF00) >> 8;
  unsigned int v23 = (v102 & 0x3FFF00) >> 8;
  unsigned int v24 = __clz(__rbit32(v23));
  if (v23) {
    unsigned int v25 = v24 + 1;
  }
  else {
    unsigned int v25 = 0;
  }
  v100 |= v25 << 8;
  unsigned int v66 = v100;
  unsigned int v94 = v100 & 0xF00;
  unsigned int v65 = v94 >> 8;
  uint64_t v64 = 0;
  uint64_t v125 = 0;
  uint64_t v125 = _dispatch_thread_getspecific(0x1CuLL);
  if (v125)
  {
    BOOL v126 = v125;
    os_retain(v125);
  }
  uint64_t v64 = (uint64_t)v125;
  LOWORD(v93) = *((_DWORD *)v76 + 21);
  v93 &= 0xF00u;
  if (v65 != v93 >> 8) {
    _dispatch_main_queue_update_priority_from_thread();
  }
  unsigned int v63 = 0;
  unsigned int v129 = v66;
  unsigned int v128 = 0;
  unsigned int v128 = _dispatch_thread_getspecific(0x19uLL);
  unsigned int v127 = v128;
  if (v128)
  {
    if ((v129 & 0xFFF) != 0)
    {
      v127 &= 0x880F0000;
      if ((v128 & 0xFFF) > (v129 & 0xFFF)) {
        int v56 = v128 & 0xFFF;
      }
      else {
        int v56 = v129 & 0xFFF;
      }
      v127 |= v56;
      unsigned int v131 = v129 & 0xF000;
      unsigned int v133 = v127 & 0xF00;
      if (v131 >> 12 > v133 >> 8) {
        v129 &= 0x4400F000u;
      }
      else {
        v129 &= 0x40000000u;
      }
      v127 |= v129;
    }
    else
    {
      if ((v127 & 0xFFF) != 0) {
        v127 |= 0x40000000u;
      }
      unsigned int v130 = v129 & 0xF000;
      unsigned int v132 = v127 & 0xF00;
      if (v130 >> 12 > v132 >> 8)
      {
        v127 &= 0xFFFF0FFF;
        v127 |= v129 & 0x400F000;
      }
    }
  }
  else
  {
    unsigned int v127 = v129 & 0xFFF0FFFF;
  }
  _dispatch_thread_setspecific(25, v127);
  unsigned int v63 = v128;
  unsigned int v96 = 15;
  unsigned int v95 = 0;
  unsigned int v95 = _dispatch_thread_getspecific(0x19uLL);
  int v141 = v95 & 0xF0000;
  if ((v95 & 0xF0000) >> 16 < v96)
  {
    v95 &= 0xFFF0FFFF;
    v95 |= v96 << 16;
    _dispatch_thread_setspecific(25, v95);
  }
  memset(v62, 0, 32);
  uint64_t v59 = v76[13];
  if (!v59) {
    uint64_t v59 = _dispatch_wait_for_enqueuer(v76 + 13);
  }
  v76[13] = 0;
  unint64_t v106 = atomic_exchange_explicit((atomic_ullong *volatile)(v76 + 6), 0, memory_order_release);
  unint64_t v60 = v106 & 0xFFFFFFFFFFFFFFF8;
  signed int v61 = (void *)v59;
  do
  {
    uint64_t v58 = 0;
    if (v61 != (void *)v60)
    {
      uint64_t v57 = v61[2];
      if (!v57) {
        uint64_t v57 = _dispatch_wait_for_enqueuer(v61 + 2);
      }
      uint64_t v58 = (void *)v57;
    }
    _dispatch_continuation_pop_inline(v61, (uint64_t)v62, 0x80000, (uint64_t)v76);
    signed int v61 = v58;
  }
  while (v58);
  uint64_t v55 = 0;
  if (*v76) {
    uint64_t v55 = *v76;
  }
  (*(void (**)(void *, void))(v55 + 64))(v76, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: main queue restore", v26, v27, v28, v29, v30, v31, v32, 8098);
  unsigned int v136 = v63;
  unsigned int v135 = 0;
  unsigned int v135 = _dispatch_thread_getspecific(0x19uLL);
  v136 &= 0xFFF0FFFF;
  v136 |= v135 & 0xF0000;
  _dispatch_thread_setspecific(25, v136);
  unsigned int v143 = 0;
  unsigned int v143 = _dispatch_thread_getspecific(0x19uLL);
  int v145 = v143 & 0xF0000;
  unsigned int v142 = (v143 & 0xF0000) >> 16;
  if ((v143 & 0xF0000) >> 16)
  {
    v143 &= 0xFFF0FFFF;
    _dispatch_thread_setspecific(25, v143);
    BOOL v144 = v142 != 15;
  }
  else
  {
    BOOL v144 = 0;
  }
  uint64_t v80 = (uint64_t)v67;
  uint64_t v79 = v64;
  if (v67 == (void *)-1) {
    uint64_t v80 = 0;
  }
  uint64_t v84 = v80;
  uint64_t v83 = v79;
  uint64_t v82 = 6;
  uint64_t v111 = v80;
  BOOL v124 = v80 != -1;
  uint64_t v123 = 2395;
  if (v80 == -1) {
    _dispatch_abort(v123, v124, v33, v34, v35, v36, v37, v38);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v122 = v111;
    uint64_t v121 = 4261412863;
    uint64_t v120 = 0;
    v111 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v110 = 0;
    uint64_t v113 = 0;
    uint64_t v113 = _dispatch_thread_getspecific(4uLL);
    unint64_t v110 = (unint64_t)v113;
    uint64_t v109 = 0x1000000;
    uint64_t v108 = 2281701376;
    if ((v113 & 0x1000000) != 0)
    {
      if (v111)
      {
        uint64_t v54 = v111;
      }
      else
      {
        unint64_t v119 = v110;
        uint64_t v118 = v109;
        uint64_t v117 = 0;
        uint64_t v54 = v110 & (~v109 | 0xFFFFFF);
      }
      uint64_t v112 = v54;
    }
    else
    {
      unint64_t v116 = v110;
      uint64_t v115 = v108;
      uint64_t v114 = 0;
      v110 &= ~v108 | 0xFFFFFF;
      if (v111 == v110) {
        uint64_t v112 = 0;
      }
      else {
        uint64_t v112 = v111;
      }
    }
  }
  else
  {
    uint64_t v112 = 0;
  }
  uint64_t v84 = v112;
  if (v112)
  {
LABEL_84:
    uint64_t v85 = _dispatch_set_priority_and_voucher_slow(v84, (_DWORD *)v83, v82);
    goto LABEL_85;
  }
  if (v83 != -1)
  {
    uint64_t v53 = (void *)v83;
    if (v53 == _dispatch_thread_getspecific(0x1CuLL))
    {
      BOOL v81 = (v82 & 4) != 0;
      if ((v82 & 2) != 0)
      {
        if (v81 && v83)
        {
          object = (void *)v83;
          os_release((void *)v83);
        }
        uint64_t v83 = -1;
      }
      else if (!v81 && v83)
      {
        uint64_t v87 = (void *)v83;
        os_retain((void *)v83);
      }
      uint64_t v85 = v83;
      goto LABEL_85;
    }
    goto LABEL_84;
  }
  uint64_t v85 = -1;
LABEL_85:
  uint64_t v134 = &v75;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v75, v34, v35, v36, v37, v38);
  BOOL v45 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4;
  BOOL v147 = v45;
  uint64_t v146 = 871;
  if (!v45) {
    _dispatch_abort(v146, v147, v39, v40, v41, v42, v43, v44);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\twlh[anon]: clear current", v46, v47, v48, v49, v50, v51, v52, 872);
  _dispatch_thread_setspecific(27, 0);
  _dispatch_thread_setspecific(5, 0);
  _dispatch_force_cache_cleanup();
}

uint64_t _dispatch_main_queue_push(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v3 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  unsigned int v4 = 0;
  unsigned int v5 = (v3 & 0x3FFF00) >> 8;
  unsigned int v6 = __clz(__rbit32(v5));
  if (v5) {
    unsigned int v4 = v6 + 1;
  }
  unsigned int v22 = v4;
  *(void *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(a1 + 6));
  for (uint64_t i = a1[6]; ; uint64_t i = v14)
  {
    if (v22 <= (i & 7u)) {
      unsigned int v20 = i & 7;
    }
    else {
      unsigned int v20 = v22;
    }
    if ((a2 & 7) != 0) {
      _dispatch_abort(1647, (a2 & 7) == 0, v7, v8, v9, v10, v11, v12);
    }
    if ((v20 & 0xFFFFFFF8) != 0) {
      _dispatch_abort(1648, (v20 & 0xFFFFFFF8) == 0, v7, v8, v9, v10, v11, v12);
    }
    uint64_t v13 = i;
    uint64_t v14 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 6), (unint64_t *)&v14, a2 | v20, memory_order_release, memory_order_relaxed);
    if (v14 == v13) {
      break;
    }
  }
  if ((i & 0xFFFFFFFFFFFFFFF8) != 0) {
    *(void *)((i & 0xFFFFFFFFFFFFFFF8) + 16) = a2;
  }
  else {
    a1[13] = a2;
  }
  uint64_t result = _dispatch_thread_setspecific(122, 0);
  if (i)
  {
    if ((i & 7u) < v22 && (a1[10] & 0x40000) != 0)
    {
      uint64_t v18 = 0;
      if (*a1) {
        uint64_t v18 = *a1;
      }
      return (*(uint64_t (**)(uint64_t *, void, uint64_t))(v18 + 64))(a1, a3, 2);
    }
    else
    {
      if (a3 <= (*((_DWORD *)a1 + 21) & 0xF00u) >> 8) {
        unsigned int v26 = 0;
      }
      else {
        unsigned int v26 = a3;
      }
      unsigned int v27 = (((unint64_t)*((unsigned int *)a1 + 15) << 32) & 0x700000000) >> 32;
      BOOL v17 = 1;
      if (v27) {
        BOOL v17 = v27 < v26;
      }
      if (v17)
      {
        uint64_t v16 = 0;
        if (*a1) {
          uint64_t v16 = *a1;
        }
        return (*(uint64_t (**)(uint64_t *, void, void))(v16 + 64))(a1, v26, 0);
      }
    }
  }
  else
  {
    uint64_t v19 = 0;
    if (*a1) {
      uint64_t v19 = *a1;
    }
    return (*(uint64_t (**)(uint64_t *, void, uint64_t))(v19 + 64))(a1, a3, 2);
  }
  return result;
}

void _dispatch_main_queue_wakeup(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 80) & 0x40000) != 0)
  {
    if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0) {
      _dispatch_abort(8306, (*(_DWORD *)(a1 + 80) & 0x1000000) == 0, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_runloop_queue_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    _dispatch_lane_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void dispatch_main(void)
{
  if (_dispatch_root_queues_pred != -1) {
    dispatch_once_f(&_dispatch_root_queues_pred, 0, (dispatch_function_t)_dispatch_root_queues_init_once);
  }
  if (pthread_main_np())
  {
    if (!dword_F0070)
    {
      dword_F0070 = 1;
      _dispatch_main_queue_drain(&_dispatch_main_q);
      dword_F0070 = 0;
      _dispatch_object_debug((uint64_t *)&_dispatch_main_q, "%s", v0, v1, v2, v3, v4, v5, (char)"dispatch_main");
      _dispatch_program_is_probably_callback_driven = 1;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      pthread_exit(0);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_main called from a block on the main queue";
    __break(1u);
  }
  else
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_main() must be called on the main thread";
    __break(1u);
  }
  JUMPOUT(0x45C24);
}

void sub_45D14()
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  if ((flags & 0xFFFFFFFFFFFFFFF9) != 0) {
    return 0;
  }
  if ((flags & 2) != 0 && (flags & 4) != 0) {
    return 0;
  }
  switch(identifier)
  {
    case -32768:
      int v4 = 2;
      break;
    case -128:
      int v4 = 3;
      break;
    case -2:
      int v4 = 3;
      break;
    default:
      if (identifier)
      {
        if (identifier == 2)
        {
          int v4 = 5;
        }
        else
        {
          switch((int)identifier)
          {
            case 5:
              int v5 = 1;
              break;
            case 9:
              int v5 = 2;
              break;
            case 17:
              int v5 = 3;
              break;
            case 21:
              int v5 = 4;
              break;
            case 25:
              int v5 = 5;
              break;
            case 33:
              int v5 = 6;
              break;
            default:
              int v5 = 0;
              break;
          }
          int v4 = v5;
        }
      }
      else
      {
        int v4 = 4;
      }
      break;
  }
  if (!v4) {
    return 0;
  }
  int v6 = 0;
  if ((flags & 2) != 0)
  {
    int v6 = 1;
  }
  else if ((flags & 4) != 0)
  {
    int v6 = 2;
  }
  return (dispatch_queue_global_t)&(&_dispatch_root_queues)[16 * (unint64_t)(3 * v4 + v6 - 3)];
}

uint64_t libdispatch_init()
{
  if (_dispatch_getenv_BOOL("LIBDISPATCH_STRICT", 0)) {
    _dispatch_mode |= 1u;
  }
  if (_dispatch_getenv_BOOL("LIBDISPATCH_COOPERATIVE_POOL_STRICT", 0)) {
    _dispatch_mode |= 4u;
  }
  if (getenv("LIBDISPATCH_DISABLE_KEVENT_WQ")) {
    _dispatch_kevent_workqueue_enabled = 0;
  }
  qos_class_t v0 = qos_class_main();
  if (v0 <= 5)
  {
    uint64_t v2 = v0 - 5;
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = v0 - 5;
    char v1 = 1;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        int v15 = 1;
        goto LABEL_19;
      case 1:
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 17:
      case 18:
      case 19:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
        break;
      case 4:
        int v15 = 2;
        goto LABEL_19;
      case 12:
        int v15 = 3;
        goto LABEL_19;
      case 16:
        int v15 = 4;
        goto LABEL_19;
      case 20:
        int v15 = 5;
        goto LABEL_19;
      case 28:
        int v15 = 6;
        goto LABEL_19;
      default:
        JUMPOUT(0);
    }
  }
  int v15 = 0;
LABEL_19:
  if (v15) {
    int v14 = (v15 << 8) & 0xF00 | 0xFF;
  }
  else {
    int v14 = 0;
  }
  dword_F0054 = v14;
  if (!getenv("LIBDISPATCH_DISABLE_SET_QOS")) {
    _dispatch_set_qos_class_enabled = 1;
  }
  _dispatch_thread_key_create(&dispatch_priority_key, 0);
  _dispatch_thread_key_create(&dispatch_r2k_key, 0);
  _dispatch_thread_key_create(&dispatch_queue_key, (uint64_t)_dispatch_queue_cleanup);
  _dispatch_thread_key_create(&dispatch_frame_key, (uint64_t)_dispatch_frame_cleanup);
  _dispatch_thread_key_create(&dispatch_cache_key, (uint64_t)_dispatch_cache_cleanup);
  _dispatch_thread_key_create(&dispatch_context_key, (uint64_t)_dispatch_context_cleanup);
  _dispatch_thread_key_create(&dispatch_pthread_root_queue_observer_hooks_key, 0);
  _dispatch_thread_key_create(&dispatch_basepri_key, 0);
  _dispatch_thread_key_create(&dispatch_wlh_key, (uint64_t)_dispatch_wlh_cleanup);
  _dispatch_thread_key_create(&dispatch_voucher_key, (uint64_t)_voucher_thread_cleanup);
  _dispatch_thread_key_create(&dispatch_deferred_items_key, (uint64_t)_dispatch_deferred_items_cleanup);
  _dispatch_thread_key_create(&dispatch_quantum_key, 0);
  _dispatch_thread_key_create(&dispatch_dsc_key, 0);
  _dispatch_thread_key_create(&os_workgroup_join_token_key, (uint64_t)_os_workgroup_join_token_tsd_cleanup);
  _dispatch_thread_key_create(&os_workgroup_key, (uint64_t)_os_workgroup_tsd_cleanup);
  _dispatch_thread_key_create(&dispatch_enqueue_key, 0);
  _dispatch_thread_key_create(&dispatch_msgv_aux_key, (uint64_t)&_free);
  _dispatch_thread_key_create(&dispatch_set_threadname_key, 0);
  _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_main_q);
  if ((unk_F0050 & 0x40000) == 0) {
    _dispatch_abort(2140, (unk_F0050 & 0x40000) != 0, v3, v4, v5, v6, v7, v8);
  }
  if ((unk_F0050 & 0x1000000) != 0) {
    _dispatch_abort(2146, (unk_F0050 & 0x1000000) == 0, v3, v4, v5, v6, v7, v8);
  }
  for (uint64_t i = qword_F0038[0]; ; uint64_t i = v10)
  {
    unsigned int v18 = _dispatch_thread_getspecific(3uLL);
    uint64_t v9 = i;
    uint64_t v10 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)qword_F0038, (unint64_t *)&v10, i & 0xFFFFFFFF00000003 | v18 & 0xFFFFFFFC, memory_order_relaxed, memory_order_relaxed);
    if (v10 == v9) {
      break;
    }
  }
  unsigned int v16 = _dispatch_thread_getspecific(0x19uLL);
  if ((v16 & 0xF0000) >> 16 < 0xF) {
    _dispatch_thread_setspecific(25, v16 & 0xFFF0FFFF | 0xF0000);
  }
  _dispatch_time_init();
  uint64_t v12 = _os_object_atfork_prepare(v11);
  _os_object_atfork_prepare(v12);
  _voucher_init();
  return _workgroup_init();
}

void *_dispatch_thread_key_create(void *result, uint64_t a2)
{
  if (*result && a2)
  {
    uint64_t result = (void *)pthread_key_init_np();
    if (result) {
      _dispatch_abort(119, (int)result, v2, v3, v4, v5, v6, v7);
    }
  }
  return result;
}

void _dispatch_queue_cleanup(dispatch_queue_s *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != &_dispatch_main_q)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch queue is running";
    qword_F42C0 = (uint64_t)a1;
    __break(1u);
    JUMPOUT(0x46840);
  }
  _dispatch_queue_cleanup2((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_frame_cleanup(uint64_t a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch frame is active";
  qword_F42C0 = a1;
  __break(1u);
}

void sub_46894()
{
}

void _dispatch_cache_cleanup(void *a1)
{
  while (1)
  {
    uint64_t v2 = a1;
    if (!a1) {
      break;
    }
    a1 = (void *)a1[2];
    _dispatch_continuation_free_to_heap(v2);
  }
}

void _dispatch_context_cleanup(uint64_t a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch context is set";
  qword_F42C0 = a1;
  __break(1u);
}

void sub_46948()
{
}

void _dispatch_wlh_cleanup(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 & 0xFFFFFFFFFFFFFFFELL);
  signed int v1 = atomic_fetch_add_explicit((atomic_uint *volatile)((a1 & 0xFFFFFFFFFFFFFFFELL) + 96), 0xFFFFFFFF, memory_order_relaxed)- 1;
  if (v1 < 0)
  {
    if (v1 <= -2)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x46A50);
    }
    v2[7] = 0xDEAD000000000000;
    _dispatch_object_dealloc(v2);
  }
}

void _dispatch_deferred_items_cleanup(uint64_t a1)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit with unhandled deferred items";
  qword_F42C0 = a1;
  __break(1u);
}

void sub_46AC4()
{
}

void _dispatch_queue_atfork_child(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unk_F0050 & 0x40000) != 0)
  {
    if ((unk_F0050 & 0x1000000) != 0) {
      _dispatch_abort(2146, (unk_F0050 & 0x1000000) == 0, a3, a4, a5, a6, a7, a8);
    }
    for (uint64_t i = qword_F0038[0]; ; uint64_t i = v9)
    {
      unsigned int v12 = _dispatch_thread_getspecific(3uLL);
      uint64_t v8 = i;
      uint64_t v9 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)qword_F0038, (unint64_t *)&v9, i & 0xFFFFFFFF00000003 | v12 & 0xFFFFFFFC, memory_order_relaxed, memory_order_relaxed);
      if (v9 == v8) {
        break;
      }
    }
  }
  if (_dispatch_unsafe_fork)
  {
    unk_F0068 = 256;
    unk_F0030 = 256;
    qword_F0168 = 256;
    qword_F0130 = 256;
    for (unint64_t j = 0; j < 0x12; ++j)
    {
      (&_dispatch_root_queues)[16 * j + 13] = (uint64_t (**)())(&stru_B8 + 72);
      (&_dispatch_root_queues)[16 * j + 6] = (uint64_t (**)())(&stru_B8 + 72);
    }
  }
}

void _dispatch_fork_becomes_unsafe_slow()
{
  if ((atomic_fetch_or_explicit((atomic_uchar *volatile)&_dispatch_unsafe_fork, 1u, memory_order_relaxed) & 2) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Transition to multithreaded is prohibited";
    __break(1u);
    JUMPOUT(0x46E9CLL);
  }
}

uint64_t _dispatch_prohibit_transition_to_multithreaded(uint64_t result)
{
  if (result)
  {
    if (atomic_fetch_or_explicit((atomic_uchar *volatile)&_dispatch_unsafe_fork, 2u, memory_order_relaxed))
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: The executable is already multithreaded";
      __break(1u);
      JUMPOUT(0x46F74);
    }
  }
  else
  {
    atomic_fetch_and_explicit((atomic_uchar *volatile)&_dispatch_unsafe_fork, 0xFDu, memory_order_relaxed);
  }
  return result;
}

pthread_key_t _dispatch_thread_getspecific_pair(pthread_key_t result, void **a2, pthread_key_t a3, pthread_key_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (v8) {
    char v9 = 1;
  }
  else {
    char v9 = 0;
  }
  if (v9)
  {
    *a2 = _dispatch_thread_getspecific(result);
    uint64_t result = (pthread_key_t)_dispatch_thread_getspecific(a3);
    *a4 = result;
  }
  else
  {
    if (a3 != result + 1) {
      _dispatch_abort(295, a3 == result + 1, a3, (uint64_t)a4, a5, a6, a7, a8);
    }
    long long v10 = *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result);
    *a2 = (void *)v10;
    *a4 = *((void *)&v10 + 1);
  }
  return result;
}

void _dispatch_block_async_invoke2(void *a1, char a2)
{
  uint64_t v3 = _Block_get_invoke_fn((uint64_t)a1);
  uint64_t v4 = 0;
  if (v3) {
    uint64_t v4 = (uint64_t (*)())v3;
  }
  if (v4 == _dispatch_block_special_invoke)
  {
    if (a1[4] != 3512316172)
    {
      uint64_t v2 = a1[4];
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_F42C0 = v2;
      __break(1u);
      JUMPOUT(0x47224);
    }
    long long v10 = a1 + 4;
  }
  else
  {
    long long v10 = 0;
  }
  unsigned int v6 = *((_DWORD *)v10 + 4);
  if ((v6 >> 2))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x4729CLL);
  }
  if ((v6 & 1) == 0) {
    (*(void (**)(void))(v10[5] + 16))();
  }
  if ((v6 & 8) == 0 && !atomic_fetch_add_explicit((atomic_uint *volatile)((char *)v10 + 20), 1u, memory_order_relaxed)) {
    dispatch_group_leave((dispatch_group_t)v10[6]);
  }
  uint64_t v5 = __swp(0, (unsigned int *)v10 + 14);
  if (v5) {
    _dispatch_release_2(v5);
  }
  if (a2) {
    _Block_release(a1);
  }
}

void _dispatch_lane_non_barrier_complete(uint64_t a1, unsigned int a2)
{
  unint64_t v12 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v9)
  {
    unint64_t v13 = i - 0x20000000000;
    if ((i & 0xFFFFFFFC) != 0)
    {
      v13 |= 0x8000000000uLL;
    }
    else if (v13 < 0x20000000000000)
    {
      unint64_t v18 = i - 0x20000000000;
      if ((v13 & 0x10000000000) != 0) {
        unint64_t v17 = i + 0x3FFF0000000000;
      }
      else {
        unint64_t v17 = v13 + ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000;
      }
      if ((v17 & 0x3FFE0000000000) == 0x20000000000000)
      {
        unint64_t v18 = v17 & 0xFFFFFF7FFFFFFFFFLL | v12;
      }
      else if ((i & 0x8000000000) != 0)
      {
        unint64_t v18 = v13 | 1;
      }
      unint64_t v13 = v18;
    }
    uint64_t v8 = i;
    uint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, v13, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  BOOL v11 = 0;
  if ((i & 0x1000000000) != 0) {
    BOOL v11 = (i & 0x800000000) != 0;
  }
  if (v11)
  {
    unsigned int v19 = _dispatch_thread_getspecific(0x19uLL);
    if ((BYTE4(i) & 7u) > (v19 & 0xF0000) >> 16) {
      _dispatch_thread_setspecific(25, v19 & 0xFFF0FFFF | ((BYTE4(i) & 7) << 16));
    }
  }
  if (((i ^ v13) & 0x40000000000000) != 0)
  {
    _dispatch_lane_barrier_complete(a1, 0, a2, v3, v4, v5, v6, v7);
  }
  else if ((i ^ v13))
  {
    if ((a2 & 1) == 0) {
      _dispatch_retain_2(a1);
    }
    if ((v13 & 0x2000000000) != 0) {
      _dispatch_abort(1002, (v13 & 0x2000000000) == 0, v2, v3, v4, v5, v6, v7);
    }
    uint64_t v10 = 0;
    if (**(void **)(a1 + 24)) {
      uint64_t v10 = **(void **)(a1 + 24);
    }
    (*(void (**)(void, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(v10 + 72))(*(void *)(a1 + 24), a1, (v13 & 0x700000000) >> 32, v3, v4, v5);
  }
  else if (a2)
  {
    _dispatch_release_2_tailcall(a1);
  }
}

uint64_t _dispatch_thread_setspecific_pair(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (v8) {
    char v9 = 1;
  }
  else {
    char v9 = 0;
  }
  if (v9)
  {
    _dispatch_thread_setspecific(result, a2);
    return _dispatch_thread_setspecific(a3, a4);
  }
  else
  {
    if (a3 != result + 1) {
      _dispatch_abort(339, a3 == result + 1, a3, a4, a5, a6, a7, a8);
    }
    *(void *)&long long v10 = a2;
    *((void *)&v10 + 1) = a4;
    *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = v10;
  }
  return result;
}

uint64_t _dispatch_thread_getspecific_packed_pair(uint64_t result, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != result + 1) {
    _dispatch_abort(318, a2 == result + 1, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  *a3 = *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result);
  return result;
}

uint64_t _dispatch_thread_setspecific_packed_pair(uint64_t result, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != result + 1) {
    _dispatch_abort(360, a2 == result + 1, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = *a3;
  return result;
}

void _dispatch_sync_f_slow(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = a1;
  uint64_t v24 = a5;
  uint64_t v23 = a2;
  unsigned int v22 = a3;
  uint64_t v21 = a4;
  uint64_t v20 = a6;
  uint64_t v19 = a1;
  uint64_t v18 = a5;
  if (*(void *)(a5 + 24))
  {
    unint64_t v26 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    void __b[14] = v26;
    memset(__b, 0, 0x70uLL);
    __b[0] = v20 | 1;
    __b[1] = v26 | 0x10000000;
    __b[2] = 0;
    __b[3] = _dispatch_thread_getspecific(0x1CuLL);
    __b[4] = _dispatch_async_and_wait_invoke;
    void __b[5] = __b;
    void __b[6] = 0;
    __b[7] = v19;
    __b[8] = v22;
    __b[9] = v23;
    memset(&__b[10], 0, 20);
    HIDWORD(__b[12]) = _dispatch_thread_getspecific(3uLL);
    LOWORD(__b[13]) = 0;
    BYTE2(__b[13]) &= 0xFCu;
    BYTE2(__b[13]) &= ~4u;
    BYTE2(__b[13]) &= ~8u;
    BYTE2(__b[13]) &= ~0x10u;
    BYTE2(__b[13]) &= ~0x20u;
    BYTE2(__b[13]) &= ~0x40u;
    BYTE2(__b[13]) &= ~0x80u;
    uint64_t v30 = v19;
    uint64_t v29 = __b;
    int v28 = 0;
    int v27 = 0;
    uint64_t v36 = v19;
    uint64_t v35 = __b;
    __DISPATCH_WAIT_FOR_QUEUE__((uint64_t)__b, v18, v8, v9, v10, v11, v12, v13);
    if (__b[8])
    {
      uint64_t v37 = v19;
      uint64_t v34 = v19;
      uint64_t v33 = __b;
      int v32 = 0;
      int v31 = 0;
      uint64_t v39 = v19;
      uint64_t v38 = __b;
      _dispatch_sync_invoke_and_complete_recurse(v19, v23, v22, v21, (uint64_t)__b, v14, v15, v16);
    }
    else
    {
      _dispatch_sync_complete_recurse(v19, __b[7], v21);
    }
  }
  else
  {
    __b[15] = v18;
    _dispatch_sync_function_invoke(v18, v23, v22, a4, a5, a6, a7, a8);
  }
}

void _dispatch_sync_recurse(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  unsigned int v12 = _dispatch_thread_getspecific(3uLL);
  uint64_t v11 = *(void *)(a1 + 24);
  do
  {
    if (*(_WORD *)(v11 + 80) == 1)
    {
      uint64_t v19 = (4096 - *(unsigned __int16 *)(v11 + 80)) << 41;
      BOOL v17 = 0;
      uint64_t v18 = *(void *)(v11 + 56);
      do
      {
        if (v18 != (v19 | v18 & 0x3000000000)) {
          break;
        }
        uint64_t v7 = v18;
        uint64_t v8 = v18;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v11 + 56), (unint64_t *)&v8, v12 & 0xFFFFFFFC | 0x60000000000002 | v18 & 0x3000000000, memory_order_acquire, memory_order_acquire);
        if (v8 != v7) {
          uint64_t v18 = v8;
        }
        BOOL v17 = v8 == v7;
      }
      while (v8 != v7);
      if (!v17)
      {
        _dispatch_sync_f_slow(a1, a2, a3, a4, v11, 2, v5, v6);
        return;
      }
    }
    else
    {
      if (*(void *)(v11 + 48))
      {
        char v21 = 0;
      }
      else
      {
        for (unint64_t i = *(void *)(v11 + 56); ; unint64_t i = v10)
        {
          if (i >= 0x40000000000000 || (i & 0x8000000000) != 0 || (i & 0x10000000000) != 0)
          {
            char v21 = 0;
            goto LABEL_21;
          }
          unint64_t v9 = i;
          unint64_t v10 = i;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v11 + 56), &v10, i + 0x20000000000, memory_order_relaxed, memory_order_relaxed);
          if (v10 == v9) {
            break;
          }
        }
        char v21 = 1;
      }
LABEL_21:
      if ((v21 ^ 1))
      {
        _dispatch_sync_f_slow(a1, a2, a3, a4, v11, 0, v5, v6);
        return;
      }
    }
    uint64_t v11 = *(void *)(v11 + 24);
  }
  while (*(void *)(v11 + 24));
  _dispatch_sync_invoke_and_complete_recurse(a1, a2, a3, a4, 0, v4, v5, v6);
}

void _dispatch_lane_barrier_sync_invoke_and_complete(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v34 = a1;
  uint64_t v33 = a2;
  int v32 = a3;
  long long v31 = 0uLL;
  uint64_t v47 = a1;
  uint64_t v46 = &v31;
  uint64_t v49 = &v31;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v31, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v47, 21, (uint64_t)v46, v8, v9, v10, v11);
  uint64_t v41 = v33;
  uint64_t v40 = v32;
  uint64_t v39 = 0;
  if ((char *)v32 == (char *)_dispatch_call_block_and_release && v41)
  {
    uint64_t v26 = _Block_get_invoke_fn(v41);
    int v27 = 0;
    if (v26) {
      int v27 = (uint64_t (*)(uint64_t))v26;
    }
    uint64_t v25 = v27;
  }
  else
  {
    uint64_t v25 = v40;
  }
  uint64_t v39 = v25;
  uint64_t v43 = v41;
  uint64_t v42 = v25;
  int v38 = 0;
  int v37 = 0;
  int v36 = 0;
  int v35 = 0;
  _dispatch_client_callout(v41, v40);
  uint64_t v45 = v41;
  uint64_t v44 = v39;
  uint64_t v48 = &v31;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v31, v12, v13, v14, v15, v16);
  uint64_t v50 = a4;
  int v55 = 772079660;
  uint64_t v54 = a4;
  uint64_t v53 = 0;
  uint64_t v52 = 0;
  uint64_t v51 = 0;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v56 = a4;
  BOOL v24 = 1;
  if (!*(void *)(a1 + 48)) {
    BOOL v24 = *(unsigned __int16 *)(a1 + 80) > 1u;
  }
  if (!v24)
  {
    for (uint64_t i = *(void *)(a1 + 56); (i & 0xFF80008800000001) == 0; uint64_t i = v23)
    {
      uint64_t v22 = i;
      uint64_t v23 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v23, (i - 0x40020000000000) & 0xFFFFFFF000000001, memory_order_release, memory_order_relaxed);
      if (v23 == v22)
      {
        if ((i & 0x2000000000) != 0) {
          _dispatch_event_loop_assert_not_owned(a1);
        }
        return;
      }
    }
  }
  _dispatch_lane_barrier_complete(a1, 0, 0, v17, v18, v19, v20, v21);
}

void *_dispatch_async_and_wait_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v34 = a1;
  uint64_t v33 = a1;
  uint64_t v32 = 0;
  uint64_t v32 = *(void *)(a1 + 56);
  int v31 = 0;
  int v31 = (*(unsigned char *)(a1 + 106) & 3) << 24;
  uint64_t v30 = 0;
  if ((v31 & 0x1000000) != 0) {
    uint64_t v30 = _dispatch_autorelease_pool_push();
  }
  long long v29 = 0uLL;
  uint64_t v47 = v32;
  uint64_t v50 = v32;
  uint64_t v49 = &v29;
  uint64_t v48 = v33 + 80;
  uint64_t v51 = &v29;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v29, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v50, 21, v48, v8, v9, v10, v11);
  uint64_t v12 = *(uint64_t (**)(uint64_t))(v33 + 64);
  uint64_t v41 = *(void *)(v33 + 72);
  uint64_t v40 = v12;
  uint64_t v39 = 0;
  if ((char *)v12 == (char *)_dispatch_call_block_and_release && v41)
  {
    uint64_t v27 = _Block_get_invoke_fn(v41);
    int v28 = 0;
    if (v27) {
      int v28 = (uint64_t (*)(uint64_t))v27;
    }
    uint64_t v26 = v28;
  }
  else
  {
    uint64_t v26 = v40;
  }
  uint64_t v39 = v26;
  uint64_t v43 = v41;
  uint64_t v42 = v26;
  int v38 = 0;
  int v37 = 0;
  int v36 = 0;
  int v35 = 0;
  _dispatch_client_callout(v41, v40);
  uint64_t v45 = v41;
  uint64_t v44 = v39;
  uint64_t v46 = &v29;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v29, v13, v14, v15, v16, v17);
  if (v30) {
    _dispatch_autorelease_pool_pop(v30);
  }
  uint64_t result = _dispatch_thread_getspecific(0x14uLL);
  *(void *)(v33 + 56) = result;
  *(void *)(v33 + 64) = 0;
  if (*(void *)(v33 + 48) != -4) {
    return (void *)_dispatch_event_loop_cancel_waiter(v33, v19, v20, v21, v22, v23, v24, v25);
  }
  uint64_t v58 = v33 + 96;
  unsigned int v57 = 0;
  int v55 = 1;
  int v54 = 1;
  int v56 = 1;
  unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v33 + 96), 1u, memory_order_release);
  unsigned int v57 = add_explicit;
  unsigned int v52 = add_explicit;
  if (add_explicit) {
    return (void *)_dispatch_thread_event_signal_slow();
  }
  return result;
}

uint64_t __DISPATCH_WAIT_FOR_QUEUE__(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = *(void *)(a2 + 56); ; uint64_t i = v9)
  {
    if ((i & 0xFF80000000000000) != 0 || (i & 0x2000000000) == 0 || (i & 2) == 0)
    {
      uint64_t v38 = i;
      goto LABEL_9;
    }
    uint64_t v8 = i;
    uint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a2 + 56), (unint64_t *)&v9, i | 0x800000000, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  uint64_t v38 = i | 0x800000000;
LABEL_9:
  if (((v38 ^ *(_DWORD *)(a1 + 100)) & 0xFFFFFFFC) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread";
    qword_F42C0 = v38;
    __break(1u);
    JUMPOUT(0x49B14);
  }
  _dispatch_thread_getspecific_packed_pair(20, 21, (_OWORD *)(a1 + 80), a4, a5, a6, a7, a8);
  if ((v38 & 0xFF80000000000000) != 0 || (v38 & 0x1000000000) != 0)
  {
    *(void *)(a1 + 48) = -4;
  }
  else if ((v38 & 0x2000000000) != 0)
  {
    *(void *)(a1 + 48) = a2;
  }
  else
  {
    _dispatch_wait_compute_wlh(a2, a1);
  }
  if (*(void *)(a1 + 48) == -4)
  {
    unsigned int v36 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v35 = (unsigned __int16)(v36 & 0xF00) >> 8;
    unsigned int v34 = (unsigned __int16)(v36 & 0xF000) >> 12;
    if (v35 <= v34) {
      unsigned int v29 = (unsigned __int16)(v36 & 0xF000) >> 12;
    }
    else {
      unsigned int v29 = (unsigned __int16)(v36 & 0xF00) >> 8;
    }
    if (v29 <= (v36 & 0xF0000) >> 16)
    {
      char v27 = (v36 & 0xF0000) >> 16;
    }
    else
    {
      if (v35 <= v34) {
        int v28 = (unsigned __int16)(v36 & 0xF000) >> 12;
      }
      else {
        int v28 = (unsigned __int16)(v36 & 0xF00) >> 8;
      }
      char v27 = v28;
    }
    *(unsigned char *)(a1 + 105) = v27;
    *(unsigned char *)(a1 + 104) = v27;
    *(_DWORD *)(a1 + 96) = 0;
  }
  _dispatch_thread_setspecific(121, a1);
  uint64_t v26 = 0;
  if (*(void *)a2) {
    uint64_t v26 = *(void *)a2;
  }
  unint64_t v32 = (*(void *)(a1 + 8) & 0x3FFF00uLL) >> 8;
  unsigned int v10 = __clz(__rbit32(v32));
  if (v32) {
    uint64_t v11 = v10 + 1;
  }
  else {
    uint64_t v11 = 0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(v26 + 72))(a2, a1, v11);
  if (*(void *)(a1 + 48) == -4)
  {
    if (atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 96), 0xFFFFFFFF, memory_order_acquire) != 1) {
      _dispatch_thread_event_wait_slow(a1 + 96);
    }
  }
  else if ((*(unsigned char *)(a1 + 106) & 8) == 0)
  {
    _dispatch_event_loop_wait_for_ownership(a1, v12, v13, v14, v15, v16, v17, v18);
  }
  uint64_t result = _dispatch_thread_setspecific(121, 0);
  if (*(void *)(a1 + 48) == -4)
  {
    if (*(_DWORD *)(a1 + 96)) {
      _dispatch_abort(339, *(_DWORD *)(a1 + 96) == 0, v20, v21, v22, v23, v24, v25);
    }
    if (*(unsigned __int8 *)(a1 + 105) > (int)*(unsigned __int8 *)(a1 + 104))
    {
      unsigned int v33 = *(unsigned __int8 *)(a1 + 105);
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
      if ((result & 0xF0000) >> 16 < v33) {
        return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | (v33 << 16));
      }
    }
  }
  return result;
}

void _dispatch_sync_complete_recurse(uint64_t a1, uint64_t a2, char a3)
{
  BOOL v4 = (a3 & 2) != 0;
  do
  {
    if (a1 == a2) {
      break;
    }
    if (v4)
    {
      uint64_t v3 = 0;
      if (*(void *)a1) {
        uint64_t v3 = *(void *)a1;
      }
      (*(void (**)(uint64_t, void, uint64_t))(v3 + 64))(a1, 0, 4);
    }
    else
    {
      _dispatch_lane_non_barrier_complete(a1, 0);
    }
    a1 = *(void *)(a1 + 24);
    BOOL v4 = *(unsigned __int16 *)(a1 + 80) == 1;
  }
  while (*(void *)(a1 + 24));
}

void _dispatch_sync_invoke_and_complete_recurse(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v21 = a4;
  uint64_t v26 = a1;
  uint64_t v25 = a2;
  uint64_t v24 = a3;
  long long v23 = 0uLL;
  uint64_t v39 = a1;
  uint64_t v38 = &v23;
  uint64_t v41 = &v23;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v23, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v39, 21, (uint64_t)v38, v8, v9, v10, v11);
  uint64_t v33 = v25;
  unint64_t v32 = v24;
  int v31 = 0;
  if ((char *)v24 == (char *)_dispatch_call_block_and_release && v33)
  {
    uint64_t v18 = _Block_get_invoke_fn(v33);
    uint64_t v19 = 0;
    if (v18) {
      uint64_t v19 = (uint64_t (*)(uint64_t))v18;
    }
    uint64_t v17 = v19;
  }
  else
  {
    uint64_t v17 = v32;
  }
  int v31 = v17;
  uint64_t v35 = v33;
  unsigned int v34 = v17;
  int v30 = 0;
  int v29 = 0;
  int v28 = 0;
  int v27 = 0;
  _dispatch_client_callout(v33, v32);
  uint64_t v37 = v33;
  unsigned int v36 = v31;
  uint64_t v40 = &v23;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v23, v12, v13, v14, v15, v16);
  uint64_t v42 = a5;
  int v47 = 772079660;
  uint64_t v46 = a5;
  uint64_t v45 = 0;
  uint64_t v44 = 0;
  uint64_t v43 = 0;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v48 = a5;
  _dispatch_sync_complete_recurse(a1, 0, v21);
}

uint64_t _dispatch_wait_compute_wlh(uint64_t result, uint64_t a2)
{
  uint64_t v8 = result;
  int v9 = *(_DWORD *)(result + 80);
  if ((v9 & 0x400000) != 0)
  {
    *(unsigned char *)(a2 + 106) |= 0x40u;
    uint64_t v12 = (atomic_uint *)(result + 100);
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    int v2 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v8 + 100), (unsigned int *)&v2, result & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
    if (v2) {
      uint64_t result = _dispatch_unfair_lock_lock_slow(v12);
    }
  }
  uint64_t v6 = *(void *)(v8 + 24);
  for (uint64_t i = *(void *)(v6 + 56); ; uint64_t i = v4)
  {
    if ((i & 0xFF80000000000000) != 0 || (i & 0x2000000000) == 0 || (i & 2) == 0)
    {
      int v11 = HIDWORD(i);
      goto LABEL_12;
    }
    uint64_t v3 = i;
    uint64_t v4 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v6 + 56), (unint64_t *)&v4, i | 0x800000000, memory_order_relaxed, memory_order_relaxed);
    if (v4 == v3) {
      break;
    }
  }
  int v11 = HIDWORD(i) | 8;
LABEL_12:
  if ((v11 & 0xFF800000) != 0 || (v11 & 0x10) != 0)
  {
    *(unsigned char *)(a2 + 106) &= ~0x40u;
    *(void *)(a2 + 48) = -4;
  }
  else if ((v11 & 0x20) != 0)
  {
    uint64_t result = *(void *)v6;
    uint64_t v5 = 0;
    if (*(void *)v6) {
      uint64_t v5 = *(void *)v6;
    }
    if (*(unsigned char *)(v5 + 16) == 18)
    {
      *(unsigned char *)(a2 + 106) |= 0x10u;
      *(unsigned char *)(a2 + 106) &= ~0x40u;
    }
    else if ((*(unsigned char *)(a2 + 106) & 0x40) != 0 {
           && (int)(atomic_fetch_add_explicit((atomic_uint *volatile)(v6 + 96), 1u, memory_order_relaxed) + 1) <= 0)
    }
    {
      qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
      __break(1u);
      JUMPOUT(0x4A944);
    }
    *(void *)(a2 + 48) = v6;
  }
  else
  {
    uint64_t result = _dispatch_wait_compute_wlh(v6, a2);
  }
  if ((v9 & 0x400000) != 0)
  {
    if ((*(unsigned char *)(a2 + 106) & 0x10) != 0) {
      atomic_fetch_and_explicit((atomic_uint *volatile)(v8 + 80), 0xFFBFFFFF, memory_order_relaxed);
    }
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    unsigned int v13 = atomic_exchange_explicit((atomic_uint *volatile)(v8 + 100), 0, memory_order_release);
    if (v13 == (result & 0xFFFFFFFC))
    {
      BOOL v14 = 0;
    }
    else
    {
      uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(v8 + 100, v13);
      BOOL v14 = (v13 & 2) != 0;
    }
    if (v14)
    {
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
      if (!((result & 0xF0000) >> 16)) {
        return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
      }
    }
  }
  return result;
}

void _dispatch_sync_invoke_and_complete(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = a1;
  uint64_t v24 = a2;
  long long v23 = a3;
  long long v22 = 0uLL;
  uint64_t v38 = a1;
  uint64_t v37 = &v22;
  uint64_t v40 = &v22;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v22, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v38, 21, (uint64_t)v37, v8, v9, v10, v11);
  uint64_t v32 = v24;
  int v31 = v23;
  int v30 = 0;
  if ((char *)v23 == (char *)_dispatch_call_block_and_release && v32)
  {
    uint64_t v18 = _Block_get_invoke_fn(v32);
    uint64_t v19 = 0;
    if (v18) {
      uint64_t v19 = (uint64_t (*)(uint64_t))v18;
    }
    uint64_t v17 = v19;
  }
  else
  {
    uint64_t v17 = v31;
  }
  int v30 = v17;
  uint64_t v34 = v32;
  uint64_t v33 = v17;
  int v29 = 0;
  int v28 = 0;
  int v27 = 0;
  int v26 = 0;
  _dispatch_client_callout(v32, v31);
  uint64_t v36 = v32;
  uint64_t v35 = v30;
  uint64_t v39 = &v22;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v22, v12, v13, v14, v15, v16);
  uint64_t v41 = a4;
  int v46 = 772079660;
  uint64_t v45 = a4;
  uint64_t v44 = 0;
  uint64_t v43 = 0;
  uint64_t v42 = 0;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v47 = a4;
  _dispatch_lane_non_barrier_complete(a1, 0);
}

void _dispatch_async_and_wait_recurse(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = a1;
  for (uint64_t i = a4; ; *(void *)a2 = i)
  {
    char v14 = 1;
    if ((*(_DWORD *)(v16 + 80) & 0x1000000) == 0)
    {
      char v13 = 0;
      if ((*(void *)(v16 + 56) & 0x3000000000) != 0)
      {
        BOOL v12 = 0;
        if (*(void *)(v16 + 24) >= (unint64_t)&_dispatch_root_queues) {
          BOOL v12 = *(void *)(v16 + 24) < (unint64_t)&unk_F0A80;
        }
        char v13 = !v12;
      }
      char v14 = v13;
    }
    if (v14)
    {
      *(void *)a2 &= ~0x80uLL;
      *(void *)(a2 + 56) = v16;
      BOOL v17 = 0;
    }
    else if ((i & 2) != 0)
    {
      uint64_t v20 = (4096 - *(unsigned __int16 *)(v16 + 80)) << 41;
      BOOL v18 = 0;
      uint64_t v19 = *(void *)(v16 + 56);
      do
      {
        if (v19 != (v20 | v19 & 0x3000000000)) {
          break;
        }
        uint64_t v8 = v19;
        uint64_t v9 = v19;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v16 + 56), (unint64_t *)&v9, a3 & 0xFFFFFFFC | 0x60000000000002 | v19 & 0x3000000000, memory_order_acquire, memory_order_acquire);
        if (v9 != v8) {
          uint64_t v19 = v9;
        }
        BOOL v18 = v9 == v8;
      }
      while (v9 != v8);
      BOOL v17 = v18;
    }
    else
    {
      if (*(void *)(v16 + 48))
      {
        char v22 = 0;
      }
      else
      {
        for (unint64_t j = *(void *)(v16 + 56); ; unint64_t j = v11)
        {
          if (j >= 0x40000000000000 || (j & 0x8000000000) != 0 || (j & 0x10000000000) != 0)
          {
            char v22 = 0;
            goto LABEL_27;
          }
          unint64_t v10 = j;
          unint64_t v11 = j;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v16 + 56), &v11, j + 0x20000000000, memory_order_relaxed, memory_order_relaxed);
          if (v11 == v10) {
            break;
          }
        }
        char v22 = 1;
      }
LABEL_27:
      BOOL v17 = v22;
    }
    if (!v17)
    {
      _dispatch_async_and_wait_f_slow(a1, a4, a2, v16, a5, a6, a7, a8);
      return;
    }
    if ((*(_DWORD *)(v16 + 84) & 0xFFF) != 0)
    {
      unsigned int v24 = (*(_DWORD *)(v16 + 84) & 0xF00u) >> 8;
      unint64_t v23 = *(unsigned __int8 *)(v16 + 84);
      if (v24) {
        unint64_t v23 = *(unsigned __int8 *)(v16 + 84) | (unint64_t)(1 << (v24 + 7));
      }
      if (v23 > (*(void *)(a2 + 8) & 0xFFFFFFuLL)) {
        *(void *)(a2 + 8) = v23 | 0x10000000;
      }
    }
    if ((*(unsigned char *)(a2 + 106) & 3) == 0) {
      *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xFC | ((*(_DWORD *)(v16 + 80) & 0x30000u) / 0x10000) & 3;
    }
    if (!*(void *)(*(void *)(v16 + 24) + 24)) {
      break;
    }
    uint64_t v16 = *(void *)(v16 + 24);
    if (*(_WORD *)(v16 + 80) == 1) {
      i |= 2uLL;
    }
    else {
      i &= ~2uLL;
    }
  }
  _dispatch_async_and_wait_invoke_and_complete_recurse(a1, a2, (void *)v16, a4);
}

void _dispatch_async_and_wait_f_slow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a3 + 64)) {
    _dispatch_async_and_wait_invoke_and_complete_recurse(a1, a3, *(void **)(a3 + 56), a2);
  }
  else {
    _dispatch_sync_complete_recurse(a1, *(void *)(a3 + 56), a2);
  }
}

void _dispatch_async_and_wait_invoke_and_complete_recurse(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v47 = a1;
  uint64_t v46 = a2;
  uint64_t v45 = a3;
  uint64_t v44 = a4;
  int v43 = 0;
  uint64_t v42 = 0;
  uint64_t v131 = (uint64_t)a3;
  uint64_t v130 = -4;
  uint64_t v34 = 0;
  if (*a3) {
    uint64_t v34 = *a3;
  }
  if (*(unsigned char *)(v34 + 16) == 18
    || (v129 = 0, v128 = *(void *)(v131 + 56), v129 = v128, uint64_t v127 = v128, v132 = v128, (v128 & 0x2000000000) != 0))
  {
    uint64_t v130 = v131;
  }
  BOOL v126 = _dispatch_thread_getspecific(0x1BuLL);
  _dispatch_thread_setspecific(27, v130);
  uint64_t v42 = (uint64_t)v126;
  int v43 = (*(unsigned char *)(v46 + 106) & 3) << 24;
  uint64_t v41 = 0;
  if ((v43 & 0x1000000) != 0) {
    uint64_t v41 = _dispatch_autorelease_pool_push();
  }
  uint64_t v40 = 0x40000000;
  long long v39 = 0uLL;
  uint64_t v37 = *(void *)(v46 + 8);
  uint64_t v35 = *(void *)(v46 + 24);
  uint64_t v125 = v47;
  uint64_t v122 = v47;
  uint64_t v121 = &v39;
  BOOL v124 = &v39;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v39, v4, v5, v6, v7, v8);
  _dispatch_thread_setspecific_pair(20, v122, 21, (uint64_t)v121, v9, v10, v11, v12);
  uint64_t v51 = v40;
  unint64_t v50 = v37;
  unint64_t v49 = 0;
  uint64_t v48 = 0;
  if ((v40 & 0x40000000) != 0 && ((v51 & 0x20) != 0 || (v51 & 0x10) == 0))
  {
    unint64_t v54 = v50;
    v50 &= 0xFFFFFFu;
    unsigned int v52 = 0;
    unsigned int v52 = _dispatch_thread_getspecific(4uLL);
    uint64_t v53 = v52;
    unint64_t v49 = v52 & 0xFFFFFF;
    if ((v52 & 0xFFFFFF) != 0 && v49 < v50) {
      uint64_t v48 = v49;
    }
  }
  uint64_t v38 = v48;
  if (v48) {
    uint64_t v33 = v37;
  }
  else {
    uint64_t v33 = 0;
  }
  uint64_t v58 = v33;
  uint64_t v57 = v35;
  uint64_t v56 = 0;
  uint64_t v103 = v33;
  BOOL v116 = v33 != -1;
  uint64_t v115 = 2395;
  if (v33 == -1) {
    _dispatch_abort(v115, v116, v13, v14, v15, v16, v17, v18);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v114 = v103;
    uint64_t v113 = 4261412863;
    uint64_t v112 = 0;
    v103 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v102 = 0;
    BOOL v105 = 0;
    BOOL v105 = _dispatch_thread_getspecific(4uLL);
    unint64_t v102 = (unint64_t)v105;
    uint64_t v101 = 0x1000000;
    uint64_t v100 = 2281701376;
    if ((v105 & 0x1000000) != 0)
    {
      if (v103)
      {
        uint64_t v32 = v103;
      }
      else
      {
        unint64_t v111 = v102;
        uint64_t v110 = v101;
        uint64_t v109 = 0;
        uint64_t v32 = v102 & (~v101 | 0xFFFFFF);
      }
      uint64_t v104 = v32;
    }
    else
    {
      unint64_t v108 = v102;
      uint64_t v107 = v100;
      uint64_t v106 = 0;
      v102 &= ~v100 | 0xFFFFFF;
      if (v103 == v102) {
        uint64_t v104 = 0;
      }
      else {
        uint64_t v104 = v103;
      }
    }
  }
  else
  {
    uint64_t v104 = 0;
  }
  uint64_t v58 = v104;
  if (!v104)
  {
    if (v57 == -1)
    {
      uint64_t v59 = -1;
      goto LABEL_43;
    }
    int v31 = (void *)v57;
    if (v31 == _dispatch_thread_getspecific(0x1CuLL))
    {
      BOOL v55 = (v56 & 4) != 0;
      if ((v56 & 2) != 0)
      {
        if (v55 && v57)
        {
          object = (void *)v57;
          os_release((void *)v57);
        }
        uint64_t v57 = -1;
      }
      else if (!v55 && v57)
      {
        signed int v61 = (void *)v57;
        os_retain((void *)v57);
      }
      uint64_t v59 = v57;
      goto LABEL_43;
    }
  }
  uint64_t v59 = _dispatch_set_priority_and_voucher_slow(v58, (_DWORD *)v57, v56);
LABEL_43:
  uint64_t v36 = v59;
  uint64_t v81 = v47;
  uint64_t v80 = v46;
  int v79 = 0;
  int v78 = 0;
  uint64_t v135 = v47;
  uint64_t v134 = v46;
  uint64_t v19 = *(uint64_t (**)(uint64_t))(v46 + 64);
  uint64_t v68 = *(void *)(v46 + 72);
  signed int v67 = v19;
  unsigned int v66 = 0;
  if ((char *)v19 == (char *)_dispatch_call_block_and_release && v68)
  {
    uint64_t v29 = _Block_get_invoke_fn(v68);
    int v30 = 0;
    if (v29) {
      int v30 = (uint64_t (*)(uint64_t))v29;
    }
    int v28 = v30;
  }
  else
  {
    int v28 = v67;
  }
  unsigned int v66 = v28;
  uint64_t v118 = v68;
  uint64_t v117 = v28;
  int v65 = 0;
  int v64 = 0;
  int v63 = 0;
  int v62 = 0;
  _dispatch_client_callout(v68, v67);
  uint64_t v120 = v68;
  unint64_t v119 = v66;
  uint64_t v70 = v38;
  uint64_t v69 = v36;
  if (v38 == -1) {
    uint64_t v70 = 0;
  }
  uint64_t v74 = v70;
  uint64_t v73 = v69;
  uint64_t v72 = 6;
  uint64_t v86 = v70;
  BOOL v99 = v70 != -1;
  uint64_t v98 = 2395;
  if (v70 == -1) {
    _dispatch_abort(v98, v99, v20, v21, v22, v23, v24, v25);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v97 = v86;
    uint64_t v96 = 4261412863;
    uint64_t v95 = 0;
    v86 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v85 = 0;
    uint64_t v88 = 0;
    uint64_t v88 = _dispatch_thread_getspecific(4uLL);
    unint64_t v85 = (unint64_t)v88;
    uint64_t v84 = 0x1000000;
    uint64_t v83 = 2281701376;
    if ((v88 & 0x1000000) != 0)
    {
      if (v86)
      {
        uint64_t v27 = v86;
      }
      else
      {
        unint64_t v94 = v85;
        uint64_t v93 = v84;
        uint64_t v92 = 0;
        uint64_t v27 = v85 & (~v84 | 0xFFFFFF);
      }
      uint64_t v87 = v27;
    }
    else
    {
      unint64_t v91 = v85;
      uint64_t v90 = v83;
      uint64_t v89 = 0;
      v85 &= ~v83 | 0xFFFFFF;
      if (v86 == v85) {
        uint64_t v87 = 0;
      }
      else {
        uint64_t v87 = v86;
      }
    }
  }
  else
  {
    uint64_t v87 = 0;
  }
  uint64_t v74 = v87;
  if (v87) {
    goto LABEL_76;
  }
  if (v73 == -1)
  {
    uint64_t v75 = -1;
    goto LABEL_77;
  }
  int v26 = (void *)v73;
  if (v26 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_76:
    uint64_t v75 = _dispatch_set_priority_and_voucher_slow(v74, (_DWORD *)v73, v72);
  }
  else
  {
    BOOL v71 = (v72 & 4) != 0;
    if ((v72 & 2) != 0)
    {
      if (v71 && v73)
      {
        uint64_t v76 = (void *)v73;
        os_release((void *)v73);
      }
      uint64_t v73 = -1;
    }
    else if (!v71 && v73)
    {
      uint64_t v77 = (void *)v73;
      os_retain((void *)v73);
    }
    uint64_t v75 = v73;
  }
LABEL_77:
  uint64_t v123 = &v39;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v39, v21, v22, v23, v24, v25);
  if (v41) {
    _dispatch_autorelease_pool_pop(v41);
  }
  uint64_t v82 = v46;
  uint64_t v136 = v46;
  int v141 = 772079660;
  uint64_t v140 = v46;
  uint64_t v139 = 0;
  uint64_t v138 = 0;
  uint64_t v137 = 0;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v142 = v82;
  uint64_t v133 = v42;
  _dispatch_thread_setspecific(27, v42);
  _dispatch_sync_complete_recurse(v47, 0, v44);
}

void _dispatch_queue_specific_head_dispose(void *a1)
{
  uint64_t v7 = a1;
  uint64_t v6 = (uint64_t *)&off_F0600;
  uint64_t i = 0;
  uint64_t v4 = 0;
  int v2 = 0;
  uint64_t v3 = (void **)&v2;
  if (a1[1])
  {
    *uint64_t v3 = (void *)v7[1];
    *(void *)(v7[1] + 32) = v3;
    uint64_t v3 = (void **)v7[2];
    v7[1] = 0;
    v7[2] = v7 + 1;
  }
  for (uint64_t i = v2; ; uint64_t i = v4)
  {
    char v1 = 0;
    if (i)
    {
      uint64_t v4 = (void *)i[3];
      char v1 = 1;
    }
    if ((v1 & 1) == 0) {
      break;
    }
    if (i[2])
    {
      i[3] = 0;
      i[4] = v7[2];
      *(void *)v7[2] = i;
      v7[2] = i + 3;
    }
    else
    {
      free(i);
    }
  }
  if (v7[1]) {
    _dispatch_barrier_async_detached_f(v6, (uint64_t)v7, (uint64_t)_dispatch_queue_specific_head_dispose_slow);
  }
  else {
    free(v7);
  }
}

void _dispatch_queue_specific_head_dispose_slow(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0;
  for (uint64_t i = (void *)a1[1]; ; uint64_t i = v10)
  {
    char v9 = 0;
    if (i)
    {
      uint64_t v10 = (void *)i[3];
      char v9 = 1;
    }
    if ((v9 & 1) == 0) {
      break;
    }
    uint64_t v8 = 0;
    if (i[2]) {
      uint64_t v8 = i[2];
    }
    if (!v8) {
      _dispatch_abort(2313, 0, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v14 = i[1];
    uint64_t v13 = (void (*)(void (**)(void)))i[2];
    if (v13 == _dispatch_call_block_and_release)
    {
      if (v14) {
        _Block_get_invoke_fn(v14);
      }
    }
    _dispatch_client_callout(v14, (uint64_t (*)(uint64_t))v13);
    free(i);
  }
  free(a1);
}

uint64_t _dispatch_non_barrier_waiter_redirect_or_wake(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(void *)a2 & 2) != 0) {
    _dispatch_abort(1211, (*(void *)a2 & 2) == 0, a3, a4, a5, a6, a7, a8);
  }
  while (1)
  {
    uint64_t v13 = a1[7];
    if (*(unsigned __int8 *)(a2 + 105) < ((v13 & 0x700000000uLL) >> 32)) {
      *(unsigned char *)(a2 + 105) = (v13 & 0x700000000uLL) >> 32;
    }
    if ((*(void *)a2 & 0x80) != 0)
    {
      if ((*((_DWORD *)a1 + 21) & 0xFFF) != 0)
      {
        unsigned int v18 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
        unint64_t v17 = *((unsigned __int8 *)a1 + 84);
        if (v18) {
          unint64_t v17 = *((unsigned __int8 *)a1 + 84) | (unint64_t)(1 << (v18 + 7));
        }
        if (v17 > (*(void *)(a2 + 8) & 0xFFFFFFuLL)) {
          *(void *)(a2 + 8) = v17 | 0x10000000;
        }
      }
      if ((*(unsigned char *)(a2 + 106) & 3) == 0) {
        *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xFC | ((a1[10] & 0x30000u) / 0x10000) & 3;
      }
    }
    if ((v13 & 0x3000000000) != 0) {
      break;
    }
    uint64_t v12 = (uint64_t *)a1[3];
    if (*((_WORD *)v12 + 40) == 1)
    {
      *(void *)a2 |= 2uLL;
LABEL_28:
      uint64_t v11 = 0;
      if (*v12) {
        uint64_t v11 = *v12;
      }
      return (*(uint64_t (**)(uint64_t *, uint64_t, void))(v11 + 72))(v12, a2, 0);
    }
    *(void *)a2 &= ~2uLL;
    if (v12[6])
    {
      char v16 = 0;
    }
    else
    {
      for (unint64_t i = v12[7]; ; unint64_t i = v9)
      {
        if (i >= 0x40000000000000 || (i & 0x8000000000) != 0 || (i & 0x10000000000) != 0)
        {
          char v16 = 0;
          goto LABEL_26;
        }
        unint64_t v8 = i;
        unint64_t v9 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v12 + 7), &v9, i + 0x20000000000, memory_order_relaxed, memory_order_relaxed);
        if (v9 == v8) {
          break;
        }
      }
      char v16 = 1;
    }
LABEL_26:
    if ((v16 & 1) == 0) {
      goto LABEL_28;
    }
    a1 = v12;
  }
  if ((*(void *)a2 & 0x80) != 0) {
    *(void *)(a2 + 56) = a1;
  }
  return _dispatch_waiter_wake_wlh_anon(a2);
}

uint64_t _dispatch_waiter_wake_wlh_anon(uint64_t result)
{
  uint64_t v1 = result;
  if (*(unsigned __int8 *)(result + 105) > (int)*(unsigned __int8 *)(result + 104)
    && (_dispatch_set_qos_class_enabled & 1) != 0)
  {
    uint64_t result = _pthread_workqueue_override_start_direct();
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v1 + 96), 1u, memory_order_release)) {
    return _dispatch_thread_event_signal_slow();
  }
  return result;
}

void _dispatch_barrier_waiter_redirect_or_wake(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v18 = a3;
  uint64_t v13 = -4;
  if (*(void *)(a2 + 48) == -4 && *(unsigned __int8 *)(a2 + 105) < ((a4 & 0x700000000) >> 32)) {
    *(unsigned char *)(a2 + 105) = (a4 & 0x700000000) >> 32;
  }
  if ((a4 & 0x2000000000) != 0)
  {
    uint64_t v13 = a1;
  }
  else
  {
    BOOL v11 = 0;
    if ((a4 & 0x1000000000) != 0) {
      BOOL v11 = (a4 & 0x800000000) != 0;
    }
    if (v11)
    {
      unsigned int v20 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(a4) & 7u) > (v20 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25, v20 & 0xFFF0FFFF | ((BYTE4(a4) & 7) << 16));
      }
    }
  }
  if (v18)
  {
    if ((a4 & 0x2000000000) == 0 || (a5 & 1) == 0)
    {
      _dispatch_release_2_no_dispose(a1);
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if ((a4 & 0x2000000000) != 0 && (a4 & 1) != 0 && (a5 & 1) == 0) {
LABEL_18:
  }
    _dispatch_release_no_dispose(a1);
LABEL_19:
  if ((a4 & 0x3000000000) != 0)
  {
    if ((*(void *)a2 & 0x80) != 0) {
      *(void *)(a2 + 56) = a1;
    }
    _dispatch_waiter_wake(a2, v13, a4, a5);
  }
  else
  {
    uint64_t v12 = *(void *)(a1 + 24);
    if ((*(void *)a2 & 0x80) != 0)
    {
      if ((*(_DWORD *)(a1 + 84) & 0xFFF) != 0)
      {
        unsigned int v24 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
        unint64_t v23 = *(unsigned __int8 *)(a1 + 84);
        if (v24) {
          unint64_t v23 = *(unsigned __int8 *)(a1 + 84) | (unint64_t)(1 << (v24 + 7));
        }
        if (v23 > (*(void *)(a2 + 8) & 0xFFFFFFuLL)) {
          *(void *)(a2 + 8) = v23 | 0x10000000;
        }
      }
      if ((*(unsigned char *)(a2 + 106) & 3) == 0) {
        *(unsigned char *)(a2 + 106) = *(unsigned char *)(a2 + 106) & 0xFC | ((*(_DWORD *)(a1 + 80) & 0x30000u) / 0x10000) & 3;
      }
    }
    if (*(_WORD *)(v12 + 80) == 1)
    {
      *(void *)a2 |= 2uLL;
    }
    else
    {
      *(void *)a2 &= ~2uLL;
      if (*(void *)(v12 + 48))
      {
        char v22 = 0;
      }
      else
      {
        for (unint64_t i = *(void *)(v12 + 56); ; unint64_t i = v9)
        {
          if (i >= 0x40000000000000 || (i & 0x8000000000) != 0 || (i & 0x10000000000) != 0)
          {
            char v22 = 0;
            goto LABEL_40;
          }
          unint64_t v8 = i;
          unint64_t v9 = i;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v12 + 56), &v9, i + 0x20000000000, memory_order_relaxed, memory_order_relaxed);
          if (v9 == v8) {
            break;
          }
        }
        char v22 = 1;
      }
LABEL_40:
      if (v22)
      {
        _dispatch_non_barrier_waiter_redirect_or_wake((uint64_t *)v12, a2, a3, a4, a5, a6, a7, a8);
        return;
      }
    }
    *(unsigned char *)(a2 + 106) &= ~0x80u;
    uint64_t v10 = 0;
    if (*(void *)v12) {
      uint64_t v10 = *(void *)v12;
    }
    (*(void (**)(uint64_t, uint64_t, unint64_t))(v10 + 72))(v12, a2, (a4 & 0x700000000) >> 32);
  }
}

uint64_t _dispatch_release_no_dispose(uint64_t result)
{
  signed int v1 = *(_DWORD *)(result + 8);
  if (v1 != 0x7FFFFFFF) {
    signed int v1 = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 8), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v1 < 1)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
    __break(1u);
    JUMPOUT(0x4E1C0);
  }
  return result;
}

uint64_t _dispatch_release_2_no_dispose(uint64_t result)
{
  signed int v1 = *(_DWORD *)(result + 8);
  if (v1 != 0x7FFFFFFF) {
    signed int v1 = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 8), 0xFFFFFFFE, memory_order_release) - 2;
  }
  if (v1 < 1)
  {
    qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
    __break(1u);
    JUMPOUT(0x4E2F8);
  }
  return result;
}

void _dispatch_waiter_wake(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 48);
  if ((a3 & 0x2000000000) != 0 && *(char *)(a1 + 106) >= 0 || (a4 & 0x2000000000) != 0 || v4 != -4) {
    _dispatch_event_loop_wake_owner(a1, a2, a3, a4);
  }
  if (v4 == -4) {
    _dispatch_waiter_wake_wlh_anon(a1);
  }
}

uint64_t _dispatch_base_lane_is_wlh(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_dispatch_kevent_workqueue_enabled ^ 1))
  {
    char v13 = 0;
  }
  else
  {
    uint64_t v12 = 0;
    if (*a1) {
      uint64_t v12 = *a1;
    }
    if (*(void *)(v12 + 16) == 133137)
    {
      char v13 = 1;
    }
    else
    {
      uint64_t v11 = 0;
      if (*a1) {
        uint64_t v11 = *a1;
      }
      if (*(unsigned char *)(v11 + 16) == 19)
      {
        if ((*(unsigned char *)(a1[11] + 29) & 0x20) == 0)
        {
          char v13 = 0;
          return v13 & 1;
        }
        if ((*(unsigned char *)(a1[11] + 29) & 1) == 0) {
          _dispatch_abort(2510, *(unsigned char *)(a1[11] + 29) & 1, a3, a4, a5, a6, a7, a8);
        }
      }
      char v10 = 0;
      if (*((_WORD *)a1 + 40) == 1)
      {
        BOOL v9 = 0;
        if (a2 >= (unint64_t)&_dispatch_root_queues) {
          BOOL v9 = a2 < (unint64_t)&unk_F0A80;
        }
        char v10 = v9;
      }
      char v13 = v10;
    }
  }
  return v13 & 1;
}

uint64_t _dispatch_lane_concurrent_drain(uint64_t *a1, uint64_t a2, int a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  int v42 = a3;
  uint64_t v41 = a4;
  char v40 = 0;
  uint64_t v39 = 0;
  uint64_t v39 = a1[3];
  long long v38 = 0uLL;
  uint64_t v34 = *a4;
  if (!a1[6]) {
    return 0;
  }
  int v156 = v44;
  uint64_t v155 = &v38;
  unsigned int v160 = &v38;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v38, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v156, 21, (uint64_t)v155, v8, v9, v10, v11);
  if ((v40 & 1) != 0 || (uint64_t v46 = v34, (v34 & 0x40000000000000) != 0)) {
    uint64_t v35 = 0x40000000000000;
  }
  else {
    uint64_t v35 = v34 & 0x3FFE0000000000;
  }
  uint64_t v89 = v44;
  uint64_t v88 = (unint64_t *)(v44 + 13);
  uint64_t v87 = 0;
  uint64_t v86 = 0;
  uint64_t v85 = v44[13];
  uint64_t v86 = v85;
  uint64_t v84 = v85;
  uint64_t v87 = v85;
  if (!v85) {
    uint64_t v87 = _dispatch_wait_for_enqueuer(v88);
  }
  uint64_t v83 = v87;
  uint64_t v37 = (void *)v87;
  while (1)
  {
    uint64_t v47 = v44[7];
    if ((v47 & 0xFF80000000000000) != 0 || v39 != v44[3]) {
      break;
    }
    if (v40) {
      goto LABEL_37;
    }
    int v62 = v37;
    int v61 = 0;
    unint64_t v152 = v37;
    if (*v37 > 0xFFFuLL)
    {
      uint64_t v32 = 0;
      if (*v62) {
        uint64_t v32 = *v62;
      }
      if ((*(void *)(v32 + 16) & 0xF0) == 0x10)
      {
        int v60 = 0;
        int v59 = *((_DWORD *)v62 + 20);
        int v60 = v59;
        int v58 = v59;
        int v61 = v59;
        BOOL v63 = (v59 & 0x80000) != 0;
      }
      else
      {
        BOOL v63 = 0;
      }
    }
    else
    {
      BOOL v63 = (*(_DWORD *)v62 & 2) != 0;
    }
    if (v63)
    {
LABEL_37:
      if ((v40 & 1) == 0 && v35 != 0x40000000000000)
      {
        v172 = v44;
        uint64_t v171 = v35;
        uint64_t v170 = 0;
        unint64_t v169 = 0;
        unint64_t v168 = 0;
        unint64_t v168 = ((unint64_t)(*((unsigned __int16 *)v44 + 40) - 1) << 41) | 0x10000000000;
        BOOL v167 = 0;
        BOOL v166 = (atomic_ullong *)(v44 + 7);
        uint64_t v170 = v44[7];
        do
        {
          unint64_t v169 = v170 - v171;
          uint64_t v174 = v170;
          if ((v170 & 0x10000000000) == 0) {
            v169 += v168;
          }
          unint64_t v173 = v169;
          if (!(v169 >> 53))
          {
            v169 += 0x20000000000;
            v169 += 0x40000000000000;
            v169 -= 0x10000000000;
          }
          v169 &= ~0x8000000000uLL;
          unint64_t v165 = v169;
          uint64_t v19 = v170;
          uint64_t v20 = v170;
          atomic_compare_exchange_strong_explicit(v166, (unint64_t *)&v20, v169, memory_order_acquire, memory_order_acquire);
          if (v20 != v19) {
            uint64_t v170 = v20;
          }
          BOOL v164 = v20 == v19;
          BOOL v167 = v20 == v19;
        }
        while (v20 != v19);
        BOOL v163 = v167;
        if ((v169 & 0x40000000000000) == 0) {
          goto LABEL_122;
        }
        uint64_t v35 = 0x40000000000000;
      }
      int v175 = v37;
      int v177 = v37;
      if (*v37 >= 0x1000uLL) {
        char v176 = 0;
      }
      else {
        char v176 = *v175 & 1;
      }
      if (v176 == 1 && (v42 & 0x80000) == 0)
      {
        *(void *)(v43 + 8) = v37;
        if ((v42 & 8) != 0)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Deferred continuation on source, mach channel or mgr";
          __break(1u);
          JUMPOUT(0x4F964);
        }
        int v157 = &v38;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v38, v13, v14, v15, v16, v17);
        return v44[3];
      }
      unint64_t v119 = v44;
      uint64_t v118 = v37;
      uint64_t v117 = v37;
      uint64_t v116 = 0;
      uint64_t v115 = 0;
      uint64_t v114 = 0;
      uint64_t v113 = 0;
      uint64_t v112 = v37[2];
      uint64_t v113 = v112;
      uint64_t v111 = v112;
      uint64_t v116 = v112;
      uint64_t v110 = v112;
      uint64_t v109 = v112;
      v44[13] = v112;
      uint64_t v108 = v110;
      if (!v116)
      {
        uint64_t v105 = 0;
        uint64_t v106 = 0;
        uint64_t v107 = v119 + 6;
        BOOL v104 = 0;
        uint64_t v103 = (atomic_ullong *)(v119 + 6);
        uint64_t v114 = v119[6];
        while (1)
        {
          uint64_t v151 = v114;
          if (v117 != (void *)(v114 & 0xFFFFFFFFFFFFFFF8)) {
            break;
          }
          uint64_t v115 = 0;
          uint64_t v93 = 0;
          uint64_t v21 = v114;
          uint64_t v22 = v114;
          atomic_compare_exchange_strong_explicit(v103, (unint64_t *)&v22, 0, memory_order_release, memory_order_relaxed);
          if (v22 != v21) {
            uint64_t v114 = v22;
          }
          BOOL v92 = v22 == v21;
          BOOL v104 = v22 == v21;
          if (v22 == v21) {
            goto LABEL_64;
          }
        }
        unint64_t v102 = v117;
        uint64_t v101 = 0;
        uint64_t v100 = 0;
        uint64_t v99 = v117[2];
        uint64_t v100 = v99;
        uint64_t v98 = v99;
        uint64_t v101 = v99;
        if (!v99) {
          uint64_t v101 = _dispatch_wait_for_enqueuer(v102 + 2);
        }
        uint64_t v97 = v101;
        uint64_t v116 = v101;
        uint64_t v96 = v101;
        uint64_t v95 = v101;
        v119[13] = v101;
        uint64_t v94 = v96;
LABEL_64:
        BOOL v91 = v104;
      }
      uint64_t v90 = v116;
      uint64_t v36 = (void *)v116;
LABEL_103:
      _dispatch_continuation_pop_inline(v37, v43, v42, (uint64_t)v44);
      goto LABEL_10;
    }
    if (v35 == 0x40000000000000)
    {
      atomic_fetch_xor_explicit((atomic_ullong *volatile)(v44 + 7), 0x40000000000000uLL, memory_order_release);
      uint64_t v35 = (unint64_t)*((unsigned __int16 *)v44 + 40) << 41;
    }
    else if (!v35)
    {
      unint64_t v54 = v37;
      unsigned int v154 = v37;
      if (*v37 < 0x1000uLL && (*v54 & 0x81) != 0)
      {
        uint64_t v188 = v44;
        uint64_t v186 = 0x20000000000;
        uint64_t v185 = 0x20000000000;
        uint64_t v187 = 0x20000000000;
        unint64_t v183 = 0;
        uint64_t v181 = 0x20000000000;
        uint64_t v180 = 0x20000000000;
        uint64_t v182 = 0x20000000000;
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 7), 0x20000000000uLL, memory_order_relaxed);
        unint64_t v183 = add_explicit;
        unint64_t v178 = add_explicit;
        unint64_t v184 = add_explicit + v187;
      }
      else
      {
        BOOL v71 = v44;
        unint64_t v70 = 0;
        unint64_t v69 = 0;
        BOOL v68 = 0;
        signed int v67 = (atomic_ullong *)(v44 + 7);
        unint64_t v70 = v44[7];
        do
        {
          unint64_t v73 = v70;
          char v31 = 1;
          if (!(v70 >> 53))
          {
            unint64_t v75 = v70;
            char v31 = 1;
            if ((v70 & 0x8000000000) == 0)
            {
              unint64_t v74 = v70;
              char v31 = BYTE5(v70) & 1;
            }
          }
          if (v31)
          {
            BOOL v72 = 0;
            goto LABEL_84;
          }
          unint64_t v69 = v70 + 0x20000000000;
          unint64_t v66 = v70 + 0x20000000000;
          unint64_t v23 = v70;
          unint64_t v24 = v70;
          atomic_compare_exchange_strong_explicit(v67, &v24, v70 + 0x20000000000, memory_order_acquire, memory_order_acquire);
          if (v24 != v23) {
            unint64_t v70 = v24;
          }
          BOOL v65 = v24 == v23;
          BOOL v68 = v24 == v23;
        }
        while (v24 != v23);
        BOOL v64 = v68;
        BOOL v72 = v68;
LABEL_84:
        if (!v72)
        {
LABEL_122:
          *v41 &= 0x4000000001uLL;
          int v158 = &v38;
          _dispatch_thread_setspecific_packed_pair(20, 21, &v38, v13, v14, v15, v16, v17);
          return -1;
        }
      }
      uint64_t v35 = 0x20000000000;
    }
    char v149 = v44;
    unint64_t v148 = v37;
    BOOL v147 = v37;
    uint64_t v146 = 0;
    uint64_t v145 = 0;
    uint64_t v144 = 0;
    uint64_t v143 = 0;
    uint64_t v142 = v37[2];
    uint64_t v143 = v142;
    uint64_t v141 = v142;
    uint64_t v146 = v142;
    uint64_t v140 = v142;
    uint64_t v139 = v142;
    v44[13] = v142;
    uint64_t v138 = v140;
    if (!v146)
    {
      uint64_t v135 = 0;
      uint64_t v136 = 0;
      uint64_t v137 = v149 + 6;
      BOOL v134 = 0;
      uint64_t v133 = (atomic_ullong *)(v149 + 6);
      uint64_t v144 = v149[6];
      while (1)
      {
        uint64_t v150 = v144;
        if (v147 != (void *)(v144 & 0xFFFFFFFFFFFFFFF8)) {
          break;
        }
        uint64_t v145 = 0;
        uint64_t v123 = 0;
        uint64_t v25 = v144;
        uint64_t v26 = v144;
        atomic_compare_exchange_strong_explicit(v133, (unint64_t *)&v26, 0, memory_order_release, memory_order_relaxed);
        if (v26 != v25) {
          uint64_t v144 = v26;
        }
        BOOL v122 = v26 == v25;
        BOOL v134 = v26 == v25;
        if (v26 == v25) {
          goto LABEL_95;
        }
      }
      uint64_t v132 = v147;
      uint64_t v131 = 0;
      uint64_t v130 = 0;
      uint64_t v129 = v147[2];
      uint64_t v130 = v129;
      uint64_t v128 = v129;
      uint64_t v131 = v129;
      if (!v129) {
        uint64_t v131 = _dispatch_wait_for_enqueuer(v132 + 2);
      }
      uint64_t v127 = v131;
      uint64_t v146 = v131;
      uint64_t v126 = v131;
      uint64_t v125 = v131;
      v149[13] = v131;
      uint64_t v124 = v126;
LABEL_95:
      BOOL v121 = v134;
    }
    uint64_t v120 = v146;
    uint64_t v36 = (void *)v146;
    uint64_t v56 = v37;
    unsigned int v153 = v37;
    if (*v37 < 0x1000uLL && (*v56 & 0x81) != 0)
    {
      v35 -= 0x20000000000;
      _dispatch_non_barrier_waiter_redirect_or_wake(v44, (uint64_t)v37, v12, v13, v14, v15, v16, v17);
    }
    else
    {
      if ((v42 & 0x20000) == 0) {
        goto LABEL_103;
      }
      v35 -= 0x20000000000;
      unint64_t v50 = v44;
      unint64_t v51 = (unint64_t)*((unsigned int *)v44 + 15) << 32;
      v51 &= 0x700000000uLL;
      _dispatch_continuation_redirect_push((uint64_t)v44, v37, HIDWORD(v51));
    }
LABEL_10:
    BOOL v18 = *(void *)(v43 + 8) == 0;
    BOOL v49 = *(void *)(v43 + 8) == 0;
    uint64_t v48 = 3803;
    if (!v18) {
      _dispatch_abort(v48, v49, v27, v13, v14, v15, v16, v17);
    }
    uint64_t v37 = v36;
    if (!v36)
    {
      if (!v44[6]) {
        break;
      }
      uint64_t v82 = v44;
      uint64_t v81 = (unint64_t *)(v44 + 13);
      uint64_t v80 = 0;
      uint64_t v79 = 0;
      uint64_t v78 = v44[13];
      uint64_t v79 = v78;
      uint64_t v77 = v78;
      uint64_t v80 = v78;
      if (!v78) {
        uint64_t v80 = _dispatch_wait_for_enqueuer(v81);
      }
      uint64_t v76 = v80;
      uint64_t v37 = (void *)v80;
    }
    if (_dispatch_thread_getspecific(5uLL)) {
      _dispatch_return_to_kernel();
    }
    if ((v40 & 1) == (*((_WORD *)v44 + 40) == 1))
    {
      char v33 = 0;
      if ((v42 & 0x4000000) == 0)
      {
        uint64_t v162 = v43;
        int v161 = 0;
        int v161 = _dispatch_thread_getspecific(0x78uLL);
        char v33 = v161 & 1;
      }
      if ((v33 & 1) == 0)
      {
        if ((v42 & 0x100000) == 0) {
          continue;
        }
        unsigned int v52 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
        unint64_t v53 = (unint64_t)v52[15] << 32;
        v53 &= 0x700000000uLL;
        if (HIDWORD(v53) <= *((unsigned __int8 *)v52 + 100)) {
          continue;
        }
      }
    }
    break;
  }
  if (v35 == 0x40000000000000) {
    uint64_t v35 = ((unint64_t)*((unsigned __int16 *)v44 + 40) << 41) + 0x40000000000000;
  }
  if (v37)
  {
    uint64_t v194 = v44;
    uint64_t v193 = v35;
    unint64_t v192 = v37;
    unsigned __int16 v191 = 0;
    unsigned __int16 v191 = *((_WORD *)v44 + 40);
    unint64_t v190 = 0;
    if (v191 >= 2u)
    {
      unint64_t v189 = v192;
      char v199 = v192;
      int v198 = 0;
      uint64_t v201 = v192;
      if (*v192 > 0xFFFuLL)
      {
        uint64_t v30 = 0;
        if (*v199) {
          uint64_t v30 = *v199;
        }
        if ((*(void *)(v30 + 16) & 0xF0) == 0x10)
        {
          int v197 = 0;
          int v196 = *((_DWORD *)v199 + 20);
          int v197 = v196;
          int v195 = v196;
          int v198 = v196;
          BOOL v200 = (v196 & 0x80000) != 0;
        }
        else
        {
          BOOL v200 = 0;
        }
      }
      else
      {
        BOOL v200 = (*(_DWORD *)v199 & 2) != 0;
      }
      if (v200)
      {
        unint64_t v190 = ((unint64_t)(v191 - 1) << 41) + 0x10000000000;
        v193 -= v190;
      }
    }
    uint64_t v35 = v193;
  }
  *v41 &= 0x4000000001uLL;
  *v41 |= v35;
  unsigned int v159 = &v38;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v38, v13, v14, v15, v16, v17);
  if (v37) {
    return v44[3];
  }
  else {
    return 0;
  }
}

void _dispatch_workloop_bound_thread_init_once(uint64_t a1)
{
  uint64_t v10 = a1;
  int v9 = 0;
  size_t v8 = 4;
  int v7 = sysctlbyname("kern.kern_event.thread_bound_kqwl_support_enabled", &v9, &v8, 0, 0);
  uint64_t v12 = v7;
  uint64_t v11 = 4220;
  if (v7) {
    _dispatch_bug(v11, v12, v1, v2, v3, v4, v5, v6);
  }
  if (v9) {
    _dispatch_thread_bound_kqwl_enabled = 1;
  }
}

void _dispatch_workloop_activate_simulator_fallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (dispatch_object_s *)dispatch_pthread_root_queue_create("com.apple.libdispatch.workloop_fallback", 0, a2, 0, a5, a6, a7, a8);
  *(void *)(a1 + 24) = v10;
  _dispatch_retain((uint64_t)v10);
  dispatch_release(v10);
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v9)
  {
    uint64_t v8 = i;
    uint64_t v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v9, i & 0xFFFFFFCFFFFFFFFFLL | 0x1000000000, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
}

uint64_t _dispatch_workloop_activate_tg_unsupported_fallback(uint64_t a1)
{
  uint64_t v9 = *(const sched_param **)(a1 + 200);
  memset(&__b, 0, sizeof(__b));
  pthread_attr_init(&__b);
  if (v9->sched_priority) {
    pthread_attr_setschedparam(&__b, v9 + 1);
  }
  if ((v9->sched_priority & 2) != 0) {
    pthread_attr_setschedpolicy(&__b, v9[2].sched_priority);
  }
  if ((v9->sched_priority & 4) != 0) {
    pthread_attr_setcpupercent_np();
  }
  int v8 = _pthread_workloop_create();
  if (v8)
  {
    if (v8 != 45) {
      _dispatch_abort(4396, v8, v1, v2, v3, v4, v5, v6);
    }
    _dispatch_workloop_activate_simulator_fallback(a1, (uint64_t)&__b, v1, v2, v3, v4, v5, v6);
  }
  else
  {
    v9->sched_priority |= 0x10u;
  }
  return pthread_attr_destroy(&__b);
}

uint64_t _dispatch_retain_n_unsafe(uint64_t result, unsigned int a2)
{
  return result;
}

void _dispatch_queue_wakeup_with_override_slow(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v14 = (a2 & 0x700000000uLL) >> 32;
  unint64_t v13 = *(void *)(a1 + 24);
  if ((a2 & 0x1000000000) != 0)
  {
    BOOL v11 = 0;
    if (v13 >= (unint64_t)&_dispatch_root_queues) {
      BOOL v11 = v13 < (unint64_t)&unk_F0A80;
    }
    if (!v11) {
      goto LABEL_77;
    }
    if ((a2 & 0xFFFFFFFC) != 0) {
      int v18 = a2 | 3;
    }
    else {
      int v18 = 0;
    }
    if (v18)
    {
      if (_dispatch_set_qos_class_enabled) {
        _pthread_workqueue_override_start_direct_check_owner();
      }
      goto LABEL_77;
    }
    char v12 = 0;
  }
  else if ((*(_DWORD *)(a1 + 80) & 0x400000) != 0)
  {
    uint64_t v20 = a1;
    uint64_t v19 = a2 & 0x700000000;
    int v42 = (atomic_uint *)(a1 + 100);
    uint64_t v41 = &v19;
    unsigned int v40 = 0;
    unsigned int v43 = _dispatch_thread_getspecific(3uLL);
    unsigned int v40 = v43 & 0xFFFFFFFC;
    int v39 = 0;
    unsigned int v38 = 0;
    BOOL v37 = 0;
    uint64_t v36 = v42;
    int v39 = *(_DWORD *)v42;
    do
    {
      int v45 = v39;
      if ((v39 & 0xFFFFFFFC) != 0) {
        unsigned int v38 = v39 | 2;
      }
      else {
        unsigned int v38 = v40;
      }
      unsigned int v35 = v38;
      int v3 = v39;
      int v4 = v39;
      atomic_compare_exchange_strong_explicit(v36, (unsigned int *)&v4, v38, memory_order_acquire, memory_order_acquire);
      if (v4 != v3) {
        int v39 = v4;
      }
      BOOL v34 = v4 == v3;
      BOOL v37 = v4 == v3;
    }
    while (v4 != v3);
    BOOL v33 = v37;
    if (v41)
    {
      unsigned int v46 = v38;
      if ((v38 & 0xFFFFFFFC) != 0) {
        int v47 = v46 | 3;
      }
      else {
        int v47 = 0;
      }
      *(_DWORD *)uint64_t v41 = v47;
    }
    int v44 = v39;
    if ((v39 & 0xFFFFFFFC) != 0)
    {
      int v23 = HIDWORD(v19);
      int v24 = v19;
      uint64_t v22 = v20 + 100;
      if (_dispatch_set_qos_class_enabled)
      {
        int v27 = v23;
        uint64_t v26 = 0;
        if (v23) {
          uint64_t v26 = 1 << (v27 + 7);
        }
        int v25 = _pthread_workqueue_override_start_direct_check_owner();
      }
      else
      {
        int v25 = 0;
      }
      char v21 = 0;
    }
    else
    {
      char v21 = 1;
    }
    if ((v21 & 1) == 0)
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      goto LABEL_77;
    }
    char v12 = 1;
    unint64_t v13 = *(void *)(a1 + 24);
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
  }
  else
  {
    char v12 = 0;
  }
LABEL_39:
  uint64_t v10 = 0;
  if (*(void *)v13) {
    uint64_t v10 = *(void *)v13;
  }
  if ((*(void *)(v10 + 16) & 0x10000) != 0)
  {
    if (v14 > (*(_DWORD *)(v13 + 84) & 0xF00u) >> 8) {
      _dispatch_root_queue_push_override_stealer(v13, a1, v14);
    }
  }
  else
  {
    uint64_t v9 = 0;
    if (*(void *)v13) {
      uint64_t v9 = *(void *)v13;
    }
    if (*(unsigned char *)(v9 + 16) == 18)
    {
      _dispatch_workloop_push_stealer(v13, a1, v14);
    }
    else
    {
      unsigned int v17 = (((unint64_t)*(unsigned int *)(v13 + 60) << 32) & 0x700000000) >> 32;
      BOOL v8 = 1;
      if (v17) {
        BOOL v8 = v17 < v14;
      }
      if (v8)
      {
        uint64_t v7 = 0;
        if (*(void *)v13) {
          uint64_t v7 = *(void *)v13;
        }
        (*(void (**)(unint64_t, void, void))(v7 + 64))(v13, v14, 0);
      }
    }
  }
  if (((v12 ^ 1) & 1) == 0)
  {
    while (1)
    {
      uint64_t v28 = a1;
      uint64_t v55 = a1 + 100;
      unsigned int v54 = 0;
      unsigned int v53 = 0;
      BOOL v52 = 0;
      unint64_t v51 = (atomic_uint *)(a1 + 100);
      unsigned int v54 = *(_DWORD *)(a1 + 100);
      do
      {
        if ((v54 & 2) != 0) {
          unsigned int v53 = v54 ^ 2;
        }
        else {
          unsigned int v53 = 0;
        }
        unsigned int v50 = v53;
        unsigned int v5 = v54;
        unsigned int v6 = v54;
        atomic_compare_exchange_strong_explicit(v51, &v6, v53, memory_order_release, memory_order_relaxed);
        if (v6 != v5) {
          unsigned int v54 = v6;
        }
        BOOL v49 = v6 == v5;
        BOOL v52 = v6 == v5;
      }
      while (v6 != v5);
      BOOL v48 = v52;
      if (v53)
      {
        __dmb(9u);
        char v56 = 0;
      }
      else
      {
        unsigned int v57 = v54;
        if (v54) {
          _dispatch_unfair_lock_unlock_slow(v55, v54);
        }
        char v56 = 1;
      }
      if (v56)
      {
        char v29 = 1;
      }
      else
      {
        unsigned int v31 = 1;
        unsigned int v30 = 0;
        unsigned int v30 = _dispatch_thread_getspecific(0x19uLL);
        int v32 = v30 & 0xF0000;
        if (v31 > (v30 & 0xF0000) >> 16)
        {
          v30 &= 0xFFF0FFFF;
          v30 |= v31 << 16;
          _dispatch_thread_setspecific(25, v30);
        }
        char v29 = 0;
      }
      if (((v29 ^ 1) & 1) == 0) {
        break;
      }
      if ((((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32 > v14)
      {
        unsigned int v14 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32;
        goto LABEL_39;
      }
    }
  }
LABEL_77:
  if (a3) {
    _dispatch_release_2_tailcall(a1);
  }
}

void _dispatch_root_queue_push_override_stealer(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char v10 = 0;
  if ((*(unsigned char *)(a1 + 87) & 0x80) != 0)
  {
    char v10 = 2;
  }
  else if ((*(unsigned char *)(a1 + 87) & 8) != 0)
  {
    char v10 = 4;
  }
  BOOL v8 = 1;
  if (a3) {
    BOOL v8 = a3 > 6;
  }
  if (v8)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_F42C0 = a3;
    __break(1u);
    JUMPOUT(0x50AA8);
  }
  int v16 = 0;
  if ((v10 & 2) != 0)
  {
    int v16 = 1;
  }
  else if ((v10 & 4) != 0)
  {
    int v16 = 2;
  }
  uint64_t v9 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * a3 + v16 - 3)];
  unsigned int v14 = (uint64_t (**)())_dispatch_thread_getspecific(0x16uLL);
  if (v14)
  {
    _dispatch_thread_setspecific(22, (uint64_t)v14[2]);
    unint64_t v13 = v14;
  }
  else
  {
    unint64_t v13 = (uint64_t (**)())_dispatch_continuation_alloc_from_heap();
  }
  void *v13 = (uint64_t (*)())&unk_ECDA8;
  _dispatch_retain_2(a2);
  v13[4] = 0;
  v13[5] = (uint64_t (*)())v13;
  v13[7] = (uint64_t (*)())a1;
  v13[6] = (uint64_t (*)())a2;
  v13[1] = (uint64_t (*)())-1;
  v13[3] = (uint64_t (*)())-1;
  v13[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(v9 + 6));
  unint64_t v15 = atomic_exchange_explicit((atomic_ullong *volatile)(v9 + 6), (unint64_t)v13, memory_order_release);
  if (v15) {
    *(void *)(v15 + 16) = v13;
  }
  else {
    v9[13] = v13;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v15) {
    _dispatch_root_queue_poke_and_wakeup((uint64_t)v9, 1, 0, v3, v4, v5, v6, v7);
  }
}

void _dispatch_workloop_push_stealer(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char v12 = _dispatch_thread_getspecific(0x16uLL);
  if (v12)
  {
    _dispatch_thread_setspecific(22, v12[2]);
    BOOL v11 = v12;
  }
  else
  {
    BOOL v11 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  void *v11 = &unk_ECD70;
  _dispatch_retain_2(a2);
  v11[4] = 0;
  v11[5] = v11;
  v11[7] = 0;
  v11[6] = a2;
  v11[1] = -1;
  v11[3] = -1;
  _dispatch_workloop_push(a1, v11, a3, v3, v4, v5, v6, v7);
}

void _dispatch_lane_drain_non_barriers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v26 = a3;
  uint64_t v25 = *(unsigned __int16 *)(a1 + 80);
  atomic_fetch_and_explicit((atomic_ullong *volatile)(a1 + 56), 0xFFBFFFFFFFFFFFFFLL, memory_order_release);
  while (v25)
  {
    --v25;
LABEL_19:
    uint64_t v36 = *(void *)(a2 + 16);
    *(void *)(a1 + 104) = v36;
    if (!v36)
    {
      for (uint64_t i = *(void *)(a1 + 48); a2 == (i & 0xFFFFFFFFFFFFFFF8); uint64_t i = v11)
      {
        uint64_t v10 = i;
        uint64_t v11 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t *)&v11, 0, memory_order_release, memory_order_relaxed);
        if (v11 == v10) {
          goto LABEL_27;
        }
      }
      uint64_t v34 = *(void *)(a2 + 16);
      if (!v34) {
        uint64_t v34 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16));
      }
      uint64_t v36 = v34;
      *(void *)(a1 + 104) = v34;
    }
LABEL_27:
    uint64_t v24 = v36;
    if (*(void *)a2 <= 0xFFFuLL && (*(void *)a2 & 0x81) != 0) {
      _dispatch_non_barrier_waiter_redirect_or_wake((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      _dispatch_continuation_redirect_push(a1, (void *)a2, (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32);
    }
LABEL_33:
    a2 = v24;
    BOOL v18 = 0;
    if (v24)
    {
      if (*(void *)v24 > 0xFFFuLL)
      {
        uint64_t v17 = 0;
        if (*(void *)v24) {
          uint64_t v17 = *(void *)v24;
        }
        BOOL v31 = (*(void *)(v17 + 16) & 0xF0) == 0x10 && (*(_DWORD *)(v24 + 80) & 0x80000) != 0;
      }
      else
      {
        BOOL v31 = (*(void *)v24 & 2) != 0;
      }
      BOOL v18 = !v31;
    }
    if (!v18) {
      goto LABEL_43;
    }
  }
  if (*(void *)a2 <= 0xFFFuLL && (*(void *)a2 & 0x81) != 0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 56), 0x20000000000uLL, memory_order_relaxed);
    goto LABEL_19;
  }
  for (unint64_t j = *(void *)(a1 + 56); ; unint64_t j = v9)
  {
    BOOL v19 = 1;
    if (j < 0x20000000000000)
    {
      BOOL v19 = 1;
      if ((j & 0x8000000000) == 0) {
        BOOL v19 = (j & 0x10000000000) != 0;
      }
    }
    if (v19)
    {
      char v33 = 0;
      goto LABEL_18;
    }
    unint64_t v8 = j;
    unint64_t v9 = j;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), &v9, j + 0x20000000000, memory_order_acquire, memory_order_acquire);
    if (v9 == v8) {
      break;
    }
  }
  char v33 = 1;
LABEL_18:
  if (v33) {
    goto LABEL_19;
  }
LABEL_43:
  unint64_t v21 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v20 = v25 << 41;
  if (a2)
  {
    uint64_t v43 = v25 << 41;
    unsigned __int16 v42 = *(_WORD *)(a1 + 80);
    if (v42 > 1u)
    {
      if (*(void *)a2 > 0xFFFuLL)
      {
        uint64_t v16 = 0;
        if (*(void *)a2) {
          uint64_t v16 = *(void *)a2;
        }
        BOOL v44 = (*(void *)(v16 + 16) & 0xF0) == 0x10 && (*(_DWORD *)(a2 + 80) & 0x80000) != 0;
      }
      else
      {
        BOOL v44 = (*(void *)a2 & 2) != 0;
      }
      if (v44) {
        uint64_t v43 = v20 - (((uint64_t)(v42 - 1) << 41) + 0x10000000000);
      }
    }
    uint64_t v20 = v43;
  }
  for (uint64_t k = *(void *)(a1 + 56); ; uint64_t k = v13)
  {
    unint64_t v22 = (k - v20) & 0xFFFFFF7700000001;
    if (a2)
    {
      unint64_t v39 = v22 | 0x8000000000;
      uint64_t v37 = v22 | 0x8000000000;
      unint64_t v38 = ((k - v20) & 0x10000000000) != 0
          ? v37 + 0x40010000000000
          : v37 + ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000;
      if ((v38 & 0x3FFE0000000000) == 0x20000000000000)
      {
        unint64_t v39 = v38 & 0xFFFFFF7FFFFFFFFFLL | v21;
      }
      else if ((k & 0x8000000000) != 0)
      {
        unint64_t v39 = (k - v20) & 0xFFFFFF7700000000 | 0x8000000001;
      }
      unint64_t v22 = v39;
    }
    else if ((k & 0x8000000000) != 0)
    {
      atomic_fetch_xor_explicit((atomic_ullong *volatile)(a1 + 56), 0x8000000000uLL, memory_order_acquire);
      uint64_t v24 = *(void *)(a1 + 104);
      goto LABEL_33;
    }
    uint64_t v12 = k;
    uint64_t v13 = k;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v13, v22, memory_order_relaxed, memory_order_relaxed);
    if (v13 == v12) {
      break;
    }
  }
  uint64_t v40 = k - v20;
  BOOL v15 = 0;
  if (((k - v20) & 0x1000000000) != 0) {
    BOOL v15 = ((k - v20) & 0x800000000) != 0;
  }
  if (v15)
  {
    unsigned int v41 = _dispatch_thread_getspecific(0x19uLL);
    if ((((unint64_t)(k - v20) >> 32) & 7) > (v41 & 0xF0000) >> 16) {
      _dispatch_thread_setspecific(25, v41 & 0xFFF0FFFF | ((((unint64_t)(k - v20) >> 32) & 7) << 16));
    }
  }
  if (((v40 ^ v22) & 0x40000000000000) != 0)
  {
    _dispatch_lane_barrier_complete(a1, 0, v26);
  }
  else if ((v40 ^ v22))
  {
    if ((v26 & 1) == 0) {
      _dispatch_retain_2(a1);
    }
    if ((v22 & 0x2000000000) != 0) {
      _dispatch_abort(1002, (v22 & 0x2000000000) == 0, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v14 = 0;
    if (**(void **)(a1 + 24)) {
      uint64_t v14 = **(void **)(a1 + 24);
    }
    (*(void (**)(void, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(v14 + 72))(*(void *)(a1 + 24), a1, (v22 & 0x700000000) >> 32, a4, a5, a6);
  }
  else if (v26)
  {
    _dispatch_release_2_tailcall(a1);
  }
}

uint64_t _dispatch_channel_invoke_cancel_check(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v5 = 1;
  if (((*(_WORD *)(a1 + 116) >> 3) & 1) == 0 && (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    uint64_t v4 = 0;
    if ((*(_DWORD *)(a2 + 32) & 0x1000000) != 0) {
      uint64_t v4 = _dispatch_autorelease_pool_push();
    }
    char v5 = (*(uint64_t (**)(uint64_t, void))(a3 + 24))(a1, *(void *)(a1 + 32)) & 1;
    if (v4) {
      _dispatch_autorelease_pool_pop(v4);
    }
    if (v5)
    {
      *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFF7 | 8;
      _dispatch_release_no_dispose(a1);
    }
    else
    {
      *(void *)(a2 + 40) = -1;
    }
  }
  return v5 & 1;
}

uint64_t _dispatch_mgr_sched_qos2prio(unsigned int a1)
{
  if (a1 == 5)
  {
    return 4;
  }
  else
  {
    if (a1 <= 9)
    {
      uint64_t v2 = a1 - 9;
      char v1 = 0;
    }
    else
    {
      uint64_t v2 = a1 - 9;
      char v1 = 1;
    }
    if ((v1 & 1) == 0)
    {
      switch(v2)
      {
        case 0:
          return 4;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
        case 11:
        case 13:
        case 14:
        case 15:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
          break;
        case 8:
          return 20;
        case 12:
          return 31;
        case 16:
          return 37;
        case 24:
          return 47;
        default:
          JUMPOUT(0);
      }
    }
    return 0;
  }
}

void _dispatch_mgr_priority_apply()
{
  sched_param v7 = 0;
  do
  {
    v7.sched_priority = _dispatch_mgr_sched;
    if (_dispatch_mgr_sched > dword_F4578)
    {
      int v6 = pthread_setschedparam((pthread_t)qword_F4580, dword_F457C, &v7);
      uint64_t v9 = v6;
      uint64_t v8 = 6239;
      if (v6) {
        _dispatch_bug(v8, v9, v0, v1, v2, v3, v4, v5);
      }
    }
  }
  while (_dispatch_mgr_sched > v7.sched_priority);
}

void _dispatch_mgr_queue_drain()
{
  int v24 = 0x40000;
  memset(v23, 0, sizeof(v23));
  unint64_t v22 = (uint64_t *)&_dispatch_mgr_q;
  uint64_t v21 = 0x40020000000000;
  if (qword_F0130)
  {
    int v26 = 15;
    unsigned int v25 = _dispatch_thread_getspecific(0x19uLL);
    int v27 = v25 & 0xF0000;
    if ((v25 & 0xF0000) >> 16 < 0xF)
    {
      unsigned int v25 = v25 & 0xFFF0FFFF | (v26 << 16);
      _dispatch_thread_setspecific(25, v25);
    }
    if (_dispatch_lane_serial_drain(v22, (uint64_t)v23, 0x40000, &v21, v0, v1, v2, v3))
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Interrupted drain on manager queue";
      __break(1u);
      JUMPOUT(0x527BCLL);
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: mgr queue clear", v4, v5, v6, v7, v8, v9, v10, 6387);
    uint64_t v33 = 0;
    int v32 = 0;
    uint64_t v36 = 0;
    unsigned int v35 = 0;
    unsigned int v35 = _dispatch_thread_getspecific(0x1CuLL);
    BOOL v44 = v35;
    uint64_t v43 = v36;
    if (v35 == (unsigned char *)v36)
    {
      int v45 = -1;
    }
    else
    {
      if (v44)
      {
        int v42 = 0;
        int v41 = 0;
      }
      _dispatch_thread_setspecific(28, v43);
      if (v43)
      {
        int v40 = 0;
        int v39 = 0;
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v11, v12, v13, v14, v15, v16, v17, 400);
      int v38 = 0;
      if (v43) {
        int v20 = *(_DWORD *)(v43 + 32);
      }
      else {
        int v20 = 0;
      }
      int v38 = v20;
      int v37 = 0;
      if (v44) {
        int v19 = *((_DWORD *)v44 + 8);
      }
      else {
        int v19 = 0;
      }
      int v37 = v19;
      if (v38 == v19) {
        int v18 = -1;
      }
      else {
        int v18 = v38;
      }
      int v45 = v18;
    }
    int v46 = v45;
    if (v45 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0, v46);
    }
    int v32 = v35;
    if (v35)
    {
      uint64_t v34 = v32;
      os_release(v32);
    }
    unsigned int v29 = 0;
    unsigned int v29 = _dispatch_thread_getspecific(0x19uLL);
    int v31 = v29 & 0xF0000;
    unsigned int v28 = (v29 & 0xF0000) >> 16;
    if ((v29 & 0xF0000) >> 16)
    {
      v29 &= 0xFFF0FFFF;
      _dispatch_thread_setspecific(25, v29);
      BOOL v30 = v28 != 15;
    }
    else
    {
      BOOL v30 = 0;
    }
  }
  if ((_dispatch_kevent_workqueue_enabled & 1) == 0) {
    _dispatch_force_cache_cleanup();
  }
}

void _dispatch_force_cache_cleanup()
{
  uint64_t v0 = _dispatch_thread_getspecific(0x16uLL);
  if (v0)
  {
    _dispatch_thread_setspecific(22, 0);
    _dispatch_cache_cleanup(v0);
  }
}

uint64_t *_dispatch_mgr_root_queue_init()
{
  uint64_t v33 = &_dispatch_mgr_sched_pred;
  int v32 = 0;
  dispatch_function_t v31 = (dispatch_function_t)_dispatch_mgr_sched_init;
  if (_dispatch_mgr_sched_pred != -1) {
    dispatch_once_f(v33, v32, v31);
  }
  int v24 = off_F00A0;
  __attr = (pthread_attr_t *)off_F00A0;
  sched_param v22 = 0;
  int v21 = pthread_attr_setdetachstate((pthread_attr_t *)off_F00A0, 2);
  uint64_t v30 = v21;
  uint64_t v29 = 6200;
  if (v21) {
    _dispatch_bug(v29, v30, v0, v1, v2, v3, v4, v5);
  }
  if (dword_F4574)
  {
    if (_dispatch_set_qos_class_enabled)
    {
      int v20 = pthread_attr_set_qos_class_np(__attr, (qos_class_t)dword_F4574, 0);
      uint64_t v28 = v20;
      uint64_t v27 = 6209;
      if (v20) {
        _dispatch_bug(v27, v28, v6, v7, v8, v9, v10, v11);
      }
    }
  }
  v22.sched_priority = _dispatch_mgr_sched;
  if (_dispatch_mgr_sched > dword_F4578)
  {
    int v19 = pthread_attr_setschedparam(__attr, &v22);
    uint64_t v26 = v19;
    uint64_t v25 = 6215;
    if (v19) {
      _dispatch_bug(v25, v26, v12, v13, v14, v15, v16, v17);
    }
  }
  return &qword_F4580;
}

uint64_t _dispatch_worker_thread(uint64_t a1)
{
  uint64_t v25 = *(void *)(a1 + 32);
  signed int v24 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 112), 0xFFFFFFFF, memory_order_acquire) - 1;
  if (v24 < 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Pending thread request underflow";
    qword_F42C0 = v24;
    __break(1u);
    JUMPOUT(0x52E3CLL);
  }
  if (*(void *)(v25 + 144)) {
    _dispatch_thread_setspecific(24, v25 + 144);
  }
  if (*(void *)(a1 + 72)) {
    pthread_setname_np(*(const char **)(a1 + 72));
  }
  if (*(void *)(v25 + 64)) {
    (*(void (**)(void))(*(void *)(v25 + 64) + 16))();
  }
  _dispatch_sigmask();
  int v23 = _dispatch_thread_getspecific(4uLL);
  unsigned int v21 = *(_DWORD *)(a1 + 84);
  if ((v21 & 0x46000FFF) == 0)
  {
    unsigned int v22 = v21 & 0x80000000;
    BOOL v20 = 0;
    if ((BYTE3(v23) & 0x22) == 0) {
      BOOL v20 = (BYTE1(v23) & 0x3F) != 0;
    }
    if (v20)
    {
      if ((v23 & 0x20000000) != 0) {
        _dispatch_abort(458, (v23 & 0x20000000) == 0, v1, v2, v3, v4, v5, v6);
      }
      unsigned int v7 = (v23 & 0x3FFF00) >> 8;
      unsigned int v8 = __clz(__rbit32(v7));
      if (v7) {
        unsigned int v9 = v8 + 1;
      }
      else {
        unsigned int v9 = 0;
      }
      unsigned int v21 = v22 | v23 & 0x8E0000FF | (v9 << 8);
    }
    else
    {
      unsigned int v21 = v22 | 0xF0000;
    }
  }
  do
  {
    _dispatch_root_queue_drain(a1, v21, 0x20000);
    unint64_t v27 = (unint64_t)v23;
    if (v23 == (void *)-1) {
      unint64_t v27 = 0;
    }
    if (v27 == -1) {
      _dispatch_abort(2395, 0, v10, v11, v12, v13, v14, v15);
    }
    if (_dispatch_set_qos_class_enabled)
    {
      unint64_t v28 = v27 & 0xFFFFFFFF02FFFFFFLL;
      unint64_t v16 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      if ((v16 & 0x1000000) != 0)
      {
        if (v28) {
          unint64_t v19 = v27 & 0xFFFFFFFF02FFFFFFLL;
        }
        else {
          unint64_t v19 = v16 & 0xFFFFFFFFFEFFFFFFLL;
        }
        unint64_t v29 = v19;
      }
      else if (v28 == (v16 & 0xFFFFFFFF77FFFFFFLL))
      {
        unint64_t v29 = 0;
      }
      else
      {
        unint64_t v29 = v27 & 0xFFFFFFFF02FFFFFFLL;
      }
    }
    else
    {
      unint64_t v29 = 0;
    }
    if (v29 || _dispatch_thread_getspecific(0x1CuLL)) {
      _dispatch_set_priority_and_voucher_slow(v29, 0, 6);
    }
    dispatch_time_t v17 = dispatch_time(0, 5000000000);
  }
  while (!dispatch_semaphore_wait((dispatch_semaphore_t)(v25 + 72), v17));
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 100), 1u, memory_order_release);
  _dispatch_root_queue_poke(a1);
  _dispatch_release(a1);
  return 0;
}

uint64_t _dispatch_root_queue_drain(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v47 = a1;
  unsigned int v46 = a2;
  int v45 = a3;
  BOOL v44 = _dispatch_thread_getspecific(0x14uLL);
  if (v44)
  {
    uint64_t v43 = v44;
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread recycling";
    qword_F42C0 = (uint64_t)v44;
    __break(1u);
    JUMPOUT(0x534F0);
  }
  uint64_t v42 = v47;
  uint64_t v48 = v47;
  _dispatch_thread_setspecific(20, v47);
  unsigned int v55 = v46;
  BOOL v9 = _dispatch_thread_getspecific(0x19uLL) == 0;
  BOOL v57 = v9;
  uint64_t v56 = 2319;
  if (!v9) {
    _dispatch_abort(v56, v57, v3, v4, v5, v6, v7, v8);
  }
  _dispatch_thread_setspecific(25, v55);
  unint64_t v62 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  unint64_t v60 = v62 & 0xFFFFFFFFFFFFFFFELL;
  if ((v62 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    char v61 = 0;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v10, v11, v12, v13, v14, v15, v16, 825);
    unint64_t v64 = v60;
    if (v60)
    {
      if (v64 != -4)
      {
        unint64_t v63 = v64;
        uint64_t v77 = (void *)v64;
        int v74 = 1;
        int v73 = 1;
        int v75 = 1;
        int v69 = 1;
        int v68 = 1;
        int v70 = 1;
        unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v64 + 96), 0xFFFFFFFF, memory_order_relaxed);
        unsigned int v71 = add_explicit;
        unsigned int v66 = add_explicit;
        unsigned int v72 = add_explicit - 1;
        int v76 = add_explicit - 1;
        if (((add_explicit - 1) & 0x80000000) != 0)
        {
          if (v76 <= -2)
          {
            qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x536E0);
          }
          v77[7] = 0xDEAD000000000000;
          BOOL v65 = v77;
          _dispatch_object_dealloc(v77);
        }
      }
    }
    _dispatch_thread_setspecific(27, -4);
    char v61 = 1;
  }
  if ((v61 & 1) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
    __break(1u);
    JUMPOUT(0x53750);
  }
  int v41 = 0;
  BOOL v40 = 0;
  memset(v39, 0, sizeof(v39));
  _dispatch_last_resort_autorelease_pool_push((uint64_t)v39);
  while (1)
  {
    int v41 = (void *)_dispatch_root_queue_drain_one(v47, v17, v18, v19, v20, v21, v22, v23);
    if (!v41) {
      break;
    }
    if (v40 && (_dispatch_set_qos_class_enabled & 1) != 0) {
      _pthread_workqueue_override_reset();
    }
    _dispatch_continuation_pop_inline(v41, (uint64_t)v39, v45, v47);
    unsigned int v52 = 0;
    unsigned int v52 = _dispatch_thread_getspecific(0x19uLL);
    int v54 = v52 & 0xF0000;
    unsigned int v51 = (v52 & 0xF0000) >> 16;
    if ((v52 & 0xF0000) >> 16)
    {
      v52 &= 0xFFF0FFFF;
      _dispatch_thread_setspecific(25, v52);
      BOOL v53 = v51 != 15;
    }
    else
    {
      BOOL v53 = 0;
    }
    BOOL v40 = v53;
    unsigned int v50 = v39;
    BOOL v49 = 0;
    BOOL v49 = _dispatch_thread_getspecific(0x78uLL);
    if (v49) {
      break;
    }
    _dispatch_thread_setspecific(120, 0);
  }
  _dispatch_last_resort_autorelease_pool_pop((uint64_t)v39);
  BOOL v30 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4;
  BOOL v59 = v30;
  uint64_t v58 = 871;
  if (!v30) {
    _dispatch_abort(v58, v59, v24, v25, v26, v27, v28, v29);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\twlh[anon]: clear current", v31, v32, v33, v34, v35, v36, v37, 872);
  _dispatch_thread_setspecific(27, 0);
  _dispatch_thread_setspecific(5, 0);
  _dispatch_thread_setspecific(25, 0);
  return _dispatch_thread_setspecific(20, 0);
}

uint64_t _dispatch_root_queue_drain_one(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    uint64_t v13 = __swp(0xFFFFFFFF, (unsigned int *)(a1 + 104));
    if (v13) {
      break;
    }
    uint64_t v8 = -1;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 104), (unint64_t *)&v8, 0, memory_order_relaxed, memory_order_relaxed);
    if (v8 == -1
      && (!*(void *)(a1 + 48)
       || !__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(a1, _dispatch_root_queue_head_tail_quiesced, a3, a4, a5, a6, a7, a8)))
    {
      return 0;
    }
  }
  uint64_t v12 = *(void *)(v13 + 16);
  if (v12) {
    goto LABEL_11;
  }
  *(void *)(a1 + 104) = 0;
  uint64_t v9 = v13;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 48), (unint64_t *)&v9, 0, memory_order_release, memory_order_relaxed);
  if (v9 != v13)
  {
    uint64_t v11 = *(void *)(v13 + 16);
    if (!v11) {
      uint64_t v11 = _dispatch_wait_for_enqueuer((unint64_t *)(v13 + 16));
    }
    uint64_t v12 = v11;
LABEL_11:
    *(void *)(a1 + 104) = v12;
    _dispatch_root_queue_poke(a1, 1u, 0, a4, a5, a6, a7, a8);
  }
  return v13;
}

BOOL __DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_msg_timeout_t v21 = 500;
  int v20 = 1;
  char v19 = 0;
  while (1)
  {
    BOOL v18 = 0;
    int v17 = 79;
    do
    {
      if (!v17--) {
        break;
      }
      __yield();
      int v20 = a2(a1);
      BOOL v18 = v20 != 0;
    }
    while (!v20);
    if (v18) {
      break;
    }
    if ((v19 & 1) == 0)
    {
      atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 112), 1u, memory_order_release);
      char v19 = 1;
    }
    thread_switch(0, 3, v21);
    int v20 = a2(a1);
    if (v20) {
      break;
    }
    v21 *= 2;
    if (v21 >= 0x186A0)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tcontention on global queue: %p", v9, v10, v11, v12, v13, v14, v15, 7076);
      break;
    }
  }
  if (v19)
  {
    atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 112), 0xFFFFFFFF, memory_order_acquire);
    if (*(void *)(a1 + 48)) {
      int v20 = 1;
    }
  }
  if (!v20) {
    _dispatch_root_queue_poke(a1, 1u, 0, a4, a5, a6, a7, a8);
  }
  return v20 == 1;
}

uint64_t _dispatch_root_queue_head_tail_quiesced(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if ((*(void *)(a1 + 104) == 0) == (v2 == 0))
  {
    if (v2) {
      return 1;
    }
    else {
      return 2;
    }
  }
  else
  {
    return 0;
  }
}

BOOL _dispatch_root_queue_mediator_is_gone(uint64_t a1)
{
  return *(void *)(a1 + 104) != -1;
}

void _dispatch_root_queue_init_pthread_pool(uint64_t a1, int a2, int a3)
{
  uint64_t v28 = *(void *)(a1 + 32);
  int v27 = 32;
  if (a3 >= 0) {
    int v27 = MEMORY[0xFFFFFC034];
  }
  if (a2 && a2 < v27) {
    int v27 = a2;
  }
  *(_DWORD *)(a1 + 100) = v27;
  if ((unsigned __int16)(a3 & 0xF00) >> 8) {
    unsigned int v23 = (unsigned __int16)(a3 & 0xF00) >> 8;
  }
  else {
    unsigned int v23 = (unsigned __int16)(a3 & 0xF000) >> 12;
  }
  if (v23 <= 1)
  {
    uint64_t v4 = v23 - 1;
    char v3 = 0;
  }
  else
  {
    uint64_t v4 = v23 - 1;
    char v3 = 1;
  }
  if (v3)
  {
    qos_class_t v29 = QOS_CLASS_UNSPECIFIED;
  }
  else
  {
    switch(v4)
    {
      case 0:
        qos_class_t v29 = 5;
        break;
      case 1:
        qos_class_t v29 = QOS_CLASS_BACKGROUND;
        break;
      case 2:
        qos_class_t v29 = QOS_CLASS_UTILITY;
        break;
      case 3:
        qos_class_t v29 = QOS_CLASS_DEFAULT;
        break;
      case 4:
        qos_class_t v29 = QOS_CLASS_USER_INITIATED;
        break;
      case 5:
        qos_class_t v29 = QOS_CLASS_USER_INTERACTIVE;
        break;
      default:
        JUMPOUT(0);
    }
  }
  if (v29)
  {
    int v26 = pthread_attr_init((pthread_attr_t *)v28);
    if (v26) {
      _dispatch_bug(7428, v26, v5, v6, v7, v8, v9, v10);
    }
    int v25 = pthread_attr_setdetachstate((pthread_attr_t *)v28, 2);
    if (v25) {
      _dispatch_bug(7430, v25, v11, v12, v13, v14, v15, v16);
    }
    int v24 = pthread_attr_set_qos_class_np((pthread_attr_t *)v28, v29, 0);
    if (v24) {
      _dispatch_bug(7434, v24, v17, v18, v19, v20, v21, v22);
    }
  }
  *(void *)(v28 + 72) = _OS_dispatch_semaphore_vtable;
  *(_DWORD *)(v28 + 136) = 0;
  if (!*(_DWORD *)(v28 + 136)) {
    _dispatch_sema4_create_slow((atomic_uint *)(v28 + 136), 2);
  }
}

void _dispatch_mgr_priority_raise(pthread_attr_t *a1)
{
  int v26 = a1;
  uint64_t v36 = &_dispatch_mgr_sched_pred;
  uint64_t v35 = 0;
  dispatch_function_t v34 = (dispatch_function_t)_dispatch_mgr_sched_init;
  if (_dispatch_mgr_sched_pred != -1) {
    dispatch_once_f(v36, v35, v34);
  }
  sched_param v25 = 0;
  int v24 = pthread_attr_getschedparam(v26, &v25);
  uint64_t v30 = v24;
  uint64_t v29 = 6293;
  if (v24) {
    _dispatch_bug(v29, v30, v1, v2, v3, v4, v5, v6);
  }
  int v23 = v24;
  qos_class_t i = QOS_CLASS_UNSPECIFIED;
  qos_class_t __qos_class = QOS_CLASS_UNSPECIFIED;
  pthread_attr_get_qos_class_np(v26, &__qos_class, 0);
  if (__qos_class)
  {
    v25.signed int sched_priority = _dispatch_mgr_sched_qos2prio(__qos_class);
    for (qos_class_t i = dword_F4574; i < __qos_class; qos_class_t i = v8)
    {
      qos_class_t v7 = i;
      qos_class_t v8 = i;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&dword_F4574, (unsigned int *)&v8, __qos_class, memory_order_relaxed, memory_order_relaxed);
      if (v8 == v7) {
        break;
      }
    }
  }
  signed int sched_priority = v25.sched_priority;
  for (int j = _dispatch_mgr_sched; j < sched_priority; int j = v10)
  {
    int v9 = j;
    int v10 = j;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&_dispatch_mgr_sched, (unsigned int *)&v10, sched_priority, memory_order_relaxed, memory_order_relaxed);
    if (v10 == v9)
    {
      uint64_t v33 = &_dispatch_root_queues_pred;
      uint64_t v32 = 0;
      dispatch_function_t v31 = (dispatch_function_t)_dispatch_root_queues_init_once;
      if (_dispatch_root_queues_pred != -1) {
        dispatch_once_f(v33, v32, v31);
      }
      if (_dispatch_kevent_workqueue_enabled)
      {
        uint64_t v18 = 0;
        if (sched_priority <= dword_F4578)
        {
          if (__qos_class) {
            uint64_t v18 = _pthread_qos_class_encode();
          }
        }
        else
        {
          uint64_t v18 = sched_priority | 0x20000000;
        }
        if (v18)
        {
          int v17 = _pthread_workqueue_set_event_manager_priority();
          uint64_t v28 = v17;
          uint64_t v27 = 6325;
          if (v17) {
            _dispatch_bug(v27, v28, v11, v12, v13, v14, v15, v16);
          }
        }
      }
      else if (qword_F4580)
      {
        _dispatch_mgr_priority_apply();
      }
      return;
    }
  }
}

void _dispatch_runloop_queue_class_poke(uint64_t a1)
{
  unsigned int v10 = *(void *)(a1 + 32);
  BOOL v8 = 0;
  if (v10) {
    BOOL v8 = v10 != -1;
  }
  if (v8)
  {
    int v9 = _dispatch_send_wakeup_runloop_thread(v10, 0);
    if (v9 != 16 && v9 != 268435460 && v9 != 268435459)
    {
      if (v9) {
        _dispatch_bug(7895, v9, v1, v2, v3, v4, v5, v6);
      }
    }
  }
}

uint64_t _dispatch_main_queue_update_priority_from_thread()
{
  uint64_t v13 = qword_F0038[0];
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(4uLL);
  if ((result & 0x20000000) != 0) {
    _dispatch_abort(458, (result & 0x20000000) == 0, v1, v2, v3, v4, v5, v6);
  }
  unsigned int v7 = (result & 0x3FFF00) >> 8;
  unsigned int v8 = __clz(__rbit32(v7));
  if (v7) {
    unsigned int v9 = v8 + 1;
  }
  else {
    unsigned int v9 = 0;
  }
  unsigned int v12 = ((result | (v9 << 8)) & 0xF00) >> 8;
  unsigned int v11 = (v13 & 0x700000000uLL) >> 32;
  unsigned int v10 = (unsigned __int16)(dword_F0054 & 0xF00) >> 8;
  dword_F0054 = result | (v9 << 8);
  if (v10 < v11 && !v12)
  {
    if ((_dispatch_set_qos_class_enabled & 1) == 0) {
      return result;
    }
    return _pthread_qos_override_end_direct();
  }
  if (v10 >= v11 || v11 > v12)
  {
    if (v12 < v11 && v11 <= v10 && (_dispatch_set_qos_class_enabled & 1) != 0) {
      return _pthread_qos_override_start_direct();
    }
  }
  else if (_dispatch_set_qos_class_enabled)
  {
    return _pthread_qos_override_end_direct();
  }
  return result;
}

uint64_t _dispatch_root_queues_init_once(uint64_t a1)
{
  uint64_t v10 = a1;
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  int v9 = _pthread_workqueue_supported();
  int v8 = 45;
  if ((v9 & 0x10) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: QoS Maintenance support required";
    qword_F42C0 = v9;
    __break(1u);
    JUMPOUT(0x54FB0);
  }
  long long v4 = 0x200000000uLL;
  long long v5 = 0uLL;
  uint64_t v6 = 64;
  uint64_t v7 = 72;
  if (_dispatch_kevent_workqueue_enabled)
  {
    if ((v9 & 0x80) != 0)
    {
      *((void *)&v5 + 1) = _dispatch_worker_thread2;
      *((void *)&v4 + 1) = _dispatch_kevent_worker_thread;
      *(void *)&long long v5 = _dispatch_workloop_worker_thread;
      uint64_t result = pthread_workqueue_setup();
      int v8 = result;
    }
    else
    {
      if ((v9 & 0x40) == 0)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Missing Kevent WORKQ support";
        qword_F42C0 = v9;
        __break(1u);
        JUMPOUT(0x55128);
      }
      *((void *)&v5 + 1) = _dispatch_worker_thread2;
      *((void *)&v4 + 1) = _dispatch_kevent_worker_thread;
      uint64_t result = pthread_workqueue_setup();
      int v8 = result;
    }
  }
  else
  {
    *((void *)&v5 + 1) = _dispatch_worker_thread2;
    uint64_t result = pthread_workqueue_setup();
    int v8 = result;
  }
  if (v8)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Root queue initialization failed";
    qword_F42C0 = v9 | (v8 << 16);
    __break(1u);
    JUMPOUT(0x55190);
  }
  if ((_dispatch_mode & 4) != 0)
  {
    int v3 = -1;
    uint64_t result = sysctlbyname("kern.wq_limit_cooperative_threads", 0, 0, &v3, 4uLL);
    int v8 = result;
    if (result)
    {
      uint64_t v11 = 1;
      uint64_t v12 = 1;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      uint64_t v2 = **(int **)(StatusReg + 8);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unable to limit cooperative pool size";
      qword_F42C0 = v2;
      __break(1u);
      JUMPOUT(0x55250);
    }
  }
  return result;
}

uint64_t _dispatch_worker_thread2(uint64_t a1)
{
  _dispatch_thread_setspecific(120, 0);
  BOOL v23 = (int)a1 < 0;
  BOOL v22 = (a1 & 0x8000000) != 0;
  unint64_t v25 = a1 & 0xFFFFFFFF88FFFFFFLL;
  _dispatch_thread_setspecific(4, v25);
  int v20 = 0;
  if (v22)
  {
    char v19 = 4;
    int v20 = 0x200000;
  }
  else
  {
    if (v23) {
      char v7 = 2;
    }
    else {
      char v7 = 0;
    }
    char v19 = v7;
  }
  unint64_t v26 = (v25 & 0x3FFF00) >> 8;
  unsigned int v8 = __clz(__rbit32(v26));
  if (v26) {
    unsigned int v9 = v8 + 1;
  }
  else {
    unsigned int v9 = 0;
  }
  BOOL v18 = 1;
  if (v9) {
    BOOL v18 = v9 > 6;
  }
  if (v18)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_F42C0 = v9;
    __break(1u);
    JUMPOUT(0x55434);
  }
  int v27 = 0;
  if ((v19 & 2) != 0)
  {
    int v27 = 1;
  }
  else if ((v19 & 4) != 0)
  {
    int v27 = 2;
  }
  uint64_t v21 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v9 + v27 - 3)];
  if ((int)(atomic_fetch_add_explicit((atomic_uint *volatile)(v21 + 14), 0xFFFFFFFF, memory_order_acquire) - 1) < 0) {
    _dispatch_abort(7396, 0, v1, v2, v3, v4, v5, v6);
  }
  _dispatch_root_queue_drain((uint64_t)v21, *((_DWORD *)v21 + 21), v20 | 0x30000);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v10, v11, v12, v13, v14, v15, v16, 7400);
  if (_dispatch_set_qos_class_enabled)
  {
    unint64_t v28 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v28 & 0x1000000) != 0) {
      unint64_t v29 = v28 & 0xFFFFFFFFFEFFFFFFLL;
    }
    else {
      unint64_t v29 = 0;
    }
  }
  else
  {
    unint64_t v29 = 0;
  }
  if (v29 || _dispatch_thread_getspecific(0x1CuLL)) {
    _dispatch_set_priority_and_voucher_slow(v29, 0, 14);
  }
  return _dispatch_thread_setspecific(120, 0);
}

void _dispatch_kevent_worker_thread(uint64_t *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v95 = 0;
  if (a1) {
    BOOL v95 = a2 != 0;
  }
  if (v95)
  {
    if (*a2 && *a1)
    {
      unint64_t v98 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL) & 0xFFFFFFFFFFFFFFFELL;
      if (v98 == -4)
      {
        char v99 = 0;
      }
      else
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v8, v9, v10, v11, v12, v13, v14, 825);
        if (v98)
        {
          signed int v100 = atomic_fetch_add_explicit((atomic_uint *volatile)(v98 + 96), 0xFFFFFFFF, memory_order_relaxed) - 1;
          if (v100 < 0)
          {
            if (v100 <= -2)
            {
              qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
              __break(1u);
              JUMPOUT(0x55B80);
            }
            *(void *)(v98 + 56) = 0xDEAD000000000000;
            _dispatch_object_dealloc((void *)v98);
          }
        }
        _dispatch_thread_setspecific(27, -4);
        char v99 = 1;
      }
      if ((v99 & 1) == 0)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
        __break(1u);
        JUMPOUT(0x55BF0);
      }
      uint64_t v15 = *a1;
      uint64_t v113 = -4;
      uint64_t v112 = v15;
      uint64_t v111 = a2;
      _dispatch_thread_setspecific(120, 0);
      long long v110 = 0u;
      uint64_t v108 = 0;
      uint64_t v106 = 0;
      uint64_t v107 = 0;
      uint64_t v109 = -4;
      *(void *)&long long v110 = v112;
      DWORD2(v110) = 0;
      WORD6(v110) = 0;
      char v105 = 0;
      char v104 = _dispatch_wlh_uses_bound_thread((uint64_t *)0xFFFFFFFFFFFFFFFCLL);
      memset(&token_out, 0, sizeof(token_out));
      wg = 0;
      if (v104)
      {
        _dispatch_wlh_uses_bound_thread_setup(v113);
      }
      else
      {
        wg = (os_workgroup_s *)_dispatch_wlh_get_workgroup((uint64_t *)v113);
        if (wg)
        {
          int v101 = os_workgroup_join(wg, &token_out);
          if (v101 == 22)
          {
            _dispatch_thread_getspecific(0);
            _dispatch_log("%u\t%p\twlh[%p]: Failed to join cancelled workgroup %p", v22, v23, v24, v25, v26, v27, v28, 6679);
            wg = 0;
          }
          else if (v101)
          {
            qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_workloop os_workgroup_join failed";
            qword_F42C0 = v101;
            __break(1u);
            JUMPOUT(0x55DA4);
          }
        }
      }
      uint64_t v139 = &v106;
      uint64_t v149 = v109;
      uint64_t v148 = 6518;
      if (!v109) {
        _dispatch_abort(v148, 0, v16, v17, v18, v19, v20, v21);
      }
      unint64_t v138 = 0;
      uint64_t v141 = 0;
      uint64_t v141 = (uint64_t)_dispatch_thread_getspecific(4uLL);
      unint64_t v138 = v141;
      if ((v141 & 0x2000000) != 0)
      {
        if ((v138 & 0x20000000) != 0)
        {
          uint64_t v171 = v138;
          unint64_t v138 = (unint64_t)BYTE3(v138) << 24;
        }
        uint64_t v144 = v138;
        uint64_t v143 = 0x1000000;
        uint64_t v142 = 0;
        v138 &= ~0x1000000uLL;
        _dispatch_thread_setspecific(4, v138);
        unsigned int v172 = 0x2000000;
        BOOL v42 = _dispatch_thread_getspecific(0x19uLL) == 0;
        BOOL v174 = v42;
        uint64_t v173 = 2331;
        if (!v42) {
          _dispatch_abort(v173, v174, v36, v37, v38, v39, v40, v41);
        }
        v172 |= 0xF0000u;
        _dispatch_thread_setspecific(25, v172);
        uint64_t v137 = &_dispatch_mgr_q;
        uint64_t v150 = &_dispatch_mgr_q;
        _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_mgr_q);
        unsigned int v160 = &_dispatch_mgr_q;
        unint64_t v159 = 0;
        unint64_t v158 = 0;
        uint64_t v157 = 0;
        unsigned int v163 = _dispatch_thread_getspecific(3uLL);
        uint64_t v157 = v163 & 0xFFFFFFFC | 0x40020000000000;
        BOOL v156 = 0;
        uint64_t v155 = (atomic_ullong *)(v160 + 7);
        unint64_t v159 = (unint64_t)v160[7];
        do
        {
          unint64_t v158 = v159;
          unint64_t v162 = v159;
          BOOL v94 = 1;
          if (!(v159 >> 53))
          {
            unint64_t v161 = v159;
            int v164 = v159;
            BOOL v94 = (v159 & 0xFFFFFFFC) != 0;
          }
          if (v94)
          {
            unint64_t v154 = v159;
            qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
            qword_F42C0 = v159;
            __break(1u);
            JUMPOUT(0x560ECLL);
          }
          v158 &= 0x7700000001uLL;
          v158 |= v157;
          unint64_t v153 = v158;
          unint64_t v43 = v159;
          unint64_t v44 = v159;
          atomic_compare_exchange_strong_explicit(v155, &v44, v158, memory_order_acquire, memory_order_acquire);
          if (v44 != v43) {
            unint64_t v159 = v44;
          }
          BOOL v152 = v44 == v43;
          BOOL v156 = v44 == v43;
        }
        while (v44 != v43);
        BOOL v151 = v156;
        char v140 = 1;
      }
      else
      {
        uint64_t v147 = v138;
        uint64_t v146 = 2013265919;
        uint64_t v145 = 0;
        v138 &= 0xFFFFFFFF88FFFFFFLL;
        if (v139[3] == -4) {
          v138 |= 0x1000000uLL;
        }
        _dispatch_thread_setspecific(4, v138);
        if (v139[3] == -4)
        {
          *((unsigned char *)v139 + 44) = 1;
        }
        else
        {
          _dispatch_thread_getspecific(0);
          _dispatch_log("%u\t%p\twlh[%p]: handling events", v29, v30, v31, v32, v33, v34, v35, 6538);
        }
        char v140 = 0;
      }
      char v105 = v140;
      if (v140)
      {
        uint64_t v46 = (int)*v111;
        int v130 = 1;
        uint64_t v129 = &_dispatch_mgr_q;
        uint64_t v128 = v46;
        uint64_t v109 = -4;
      }
      else
      {
        if (v113 == -4) {
          uint64_t v93 = 0;
        }
        else {
          uint64_t v93 = v113;
        }
        uint64_t v45 = (int)*v111;
        int v133 = 1;
        uint64_t v132 = v93;
        uint64_t v131 = v45;
      }
      uint64_t v136 = &v106;
      _dispatch_thread_setspecific(29, (uint64_t)&v106);
      _dispatch_event_loop_merge(v112, *v111);
      if (v105)
      {
        int v127 = 2;
        uint64_t v126 = &_dispatch_mgr_q;
        uint64_t v125 = 0;
        _dispatch_mgr_queue_drain();
        if (byte_F432E) {
          _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v47, v48, v49, v50, v51, v52);
        }
        BOOL v166 = 0;
        uint64_t v182 = &_dispatch_mgr_q;
        unint64_t v180 = 0;
        BOOL v179 = 0;
        unint64_t v178 = (atomic_ullong *)&qword_F0138;
        uint64_t v181 = qword_F0138;
        do
        {
          unint64_t v180 = (v181 - 0x40020000000000) & 0xFFFFFFF000000001;
          unint64_t v177 = v180;
          uint64_t v53 = v181;
          uint64_t v54 = v181;
          atomic_compare_exchange_strong_explicit(v178, (unint64_t *)&v54, v180, memory_order_release, memory_order_relaxed);
          if (v54 != v53) {
            uint64_t v181 = v54;
          }
          BOOL v176 = v54 == v53;
          BOOL v179 = v54 == v53;
        }
        while (v54 != v53);
        BOOL v175 = v179;
        uint64_t v183 = v181;
        BOOL v166 = (v181 & 0x8000000000) != 0;
        _dispatch_thread_setspecific(25, 0);
        uint64_t v165 = 0;
        uint64_t v170 = 0;
        _dispatch_thread_setspecific(20, 0);
        if (v166)
        {
          int v169 = 3;
          unint64_t v168 = &_dispatch_mgr_q;
          uint64_t v167 = 1;
          _dispatch_event_loop_poke(-8, 0, 0, v55, v56, v57, v58, v59);
        }
      }
      else if (v107)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\twlh[%p]: draining deferred item %p", v60, v61, v62, v63, v64, v65, v66, 6708);
        if (v109 == -4)
        {
          BOOL v115 = WORD4(v110) == 0;
          uint64_t v114 = 6710;
          if (WORD4(v110)) {
            _dispatch_abort(v114, v115, v67, v68, v69, v70, v71, v72);
          }
          uint64_t v135 = 0;
          _dispatch_thread_setspecific(29, 0);
          int v124 = 2;
          uint64_t v123 = v106;
          uint64_t v122 = 0;
          _dispatch_root_queue_drain_deferred_item(&v106);
        }
        else
        {
          int v121 = 2;
          uint64_t v120 = v113;
          uint64_t v119 = 0;
          _dispatch_root_queue_drain_deferred_wlh(&v106);
        }
      }
      if ((v104 & 1) == 0 && wg) {
        os_workgroup_leave(wg, &token_out);
      }
      uint64_t v134 = 0;
      _dispatch_thread_setspecific(29, 0);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\treturning %d deferred kevents", v73, v74, v75, v76, v77, v78, v79, 6735);
      _dispatch_thread_setspecific(5, 0);
      _dispatch_thread_setspecific(120, 0);
      *uint64_t v111 = WORD4(v110);
      int v118 = 4;
      uint64_t v117 = 0;
      uint64_t v116 = 0;
      if (_dispatch_thread_getspecific(0x1BuLL) != (void *)-4) {
        _dispatch_abort(871, 0, v80, v81, v82, v83, v84, v85);
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\twlh[anon]: clear current", v86, v87, v88, v89, v90, v91, v92, 872);
      _dispatch_thread_setspecific(27, 0);
      _dispatch_thread_setspecific(5, 0);
    }
  }
  else
  {
    _dispatch_bug(6755, v95, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_workloop_worker_thread(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v102 = 0;
  if (a1)
  {
    BOOL v102 = 0;
    if (a2) {
      BOOL v102 = a3 != 0;
    }
  }
  if (v102)
  {
    BOOL v104 = *a1 != 0;
    if (!*a1) {
      _dispatch_bug(6777, *a1 != 0, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
    if (v104)
    {
      if (*a3 && *a2)
      {
        uint64_t v103 = *a1;
        unint64_t v192 = *a1;
        unint64_t v195 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
        unint64_t v191 = v195 & 0xFFFFFFFFFFFFFFFELL;
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\twlh[%p]: adopt current (releasing %p)", v8, v9, v10, v11, v12, v13, v14, 845);
        if ((v195 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
          __break(1u);
          JUMPOUT(0x56858);
        }
        if (v191 != (void)v192)
        {
          uint64_t v194 = (uint64_t)v192;
          uint64_t v193 = 850;
          if (!v192) {
            _dispatch_abort(v193, 0, v15, v16, v17, v18, v19, v20);
          }
          unint64_t v197 = v191;
          if (v191)
          {
            unint64_t v196 = v197;
            unsigned int v210 = (void *)v197;
            int v207 = 1;
            int v206 = 1;
            int v208 = 1;
            int v202 = 1;
            int v201 = 1;
            int v203 = 1;
            unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v197 + 96), 0xFFFFFFFF, memory_order_relaxed);
            unsigned int v204 = add_explicit;
            unsigned int v199 = add_explicit;
            unsigned int v205 = add_explicit - 1;
            int v209 = add_explicit - 1;
            if (((add_explicit - 1) & 0x80000000) != 0)
            {
              if (v209 <= -2)
              {
                qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
                __break(1u);
                JUMPOUT(0x56994);
              }
              v210[7] = 0xDEAD000000000000;
              int v198 = v210;
              _dispatch_object_dealloc(v210);
            }
          }
          uint64_t v217 = (uint64_t)v192;
          if (v192)
          {
            if (v217 != -4)
            {
              uint64_t v216 = v217;
              uint64_t v229 = v217;
              int v226 = 1;
              int v225 = 1;
              int v227 = 1;
              int v221 = 1;
              int v220 = 1;
              int v222 = 1;
              unsigned int v219 = atomic_fetch_add_explicit((atomic_uint *volatile)(v217 + 96), 1u, memory_order_relaxed);
              unsigned int v223 = v219;
              unsigned int v218 = v219;
              unsigned int v224 = v219 + 1;
              unsigned int v228 = v219 + 1;
              if ((int)(v219 + 1) <= 0)
              {
                qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
                __break(1u);
                JUMPOUT(0x56AA4);
              }
            }
          }
        }
        _dispatch_thread_setspecific(27, (uint64_t)v192);
        uint64_t v21 = *a2;
        uint64_t v120 = v103;
        uint64_t v119 = v21;
        int v118 = a3;
        _dispatch_thread_setspecific(120, 0);
        long long v117 = 0u;
        uint64_t v115 = 0;
        uint64_t v113 = 0;
        uint64_t v114 = 0;
        uint64_t v116 = (uint64_t)v103;
        *(void *)&long long v117 = v119;
        DWORD2(v117) = 0;
        WORD6(v117) = 0;
        char v112 = 0;
        char v111 = _dispatch_wlh_uses_bound_thread(v103);
        memset(&token_out, 0, sizeof(token_out));
        wg = 0;
        if (v111)
        {
          _dispatch_wlh_uses_bound_thread_setup((uint64_t)v120);
        }
        else
        {
          wg = (os_workgroup_s *)_dispatch_wlh_get_workgroup(v120);
          if (wg)
          {
            int v108 = os_workgroup_join(wg, &token_out);
            if (v108 == 22)
            {
              _dispatch_thread_getspecific(0);
              _dispatch_log("%u\t%p\twlh[%p]: Failed to join cancelled workgroup %p", v28, v29, v30, v31, v32, v33, v34, 6679);
              wg = 0;
            }
            else if (v108)
            {
              qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_workloop os_workgroup_join failed";
              qword_F42C0 = v108;
              __break(1u);
              JUMPOUT(0x56C6CLL);
            }
          }
        }
        uint64_t v146 = &v113;
        uint64_t v156 = v116;
        uint64_t v155 = 6518;
        if (!v116) {
          _dispatch_abort(v155, 0, v22, v23, v24, v25, v26, v27);
        }
        unint64_t v145 = 0;
        uint64_t v148 = 0;
        uint64_t v148 = (uint64_t)_dispatch_thread_getspecific(4uLL);
        unint64_t v145 = v148;
        if ((v148 & 0x2000000) != 0)
        {
          if ((v145 & 0x20000000) != 0)
          {
            uint64_t v178 = v145;
            unint64_t v145 = (unint64_t)BYTE3(v145) << 24;
          }
          uint64_t v151 = v145;
          uint64_t v150 = 0x1000000;
          uint64_t v149 = 0;
          v145 &= ~0x1000000uLL;
          _dispatch_thread_setspecific(4, v145);
          unsigned int v179 = 0x2000000;
          BOOL v48 = _dispatch_thread_getspecific(0x19uLL) == 0;
          BOOL v181 = v48;
          uint64_t v180 = 2331;
          if (!v48) {
            _dispatch_abort(v180, v181, v42, v43, v44, v45, v46, v47);
          }
          v179 |= 0xF0000u;
          _dispatch_thread_setspecific(25, v179);
          uint64_t v144 = &_dispatch_mgr_q;
          uint64_t v157 = &_dispatch_mgr_q;
          _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_mgr_q);
          uint64_t v167 = &_dispatch_mgr_q;
          unint64_t v166 = 0;
          unint64_t v165 = 0;
          uint64_t v164 = 0;
          unsigned int v170 = _dispatch_thread_getspecific(3uLL);
          uint64_t v164 = v170 & 0xFFFFFFFC | 0x40020000000000;
          BOOL v163 = 0;
          unint64_t v162 = (atomic_ullong *)(v167 + 7);
          unint64_t v166 = (unint64_t)v167[7];
          do
          {
            unint64_t v165 = v166;
            unint64_t v169 = v166;
            BOOL v101 = 1;
            if (!(v166 >> 53))
            {
              unint64_t v168 = v166;
              int v171 = v166;
              BOOL v101 = (v166 & 0xFFFFFFFC) != 0;
            }
            if (v101)
            {
              unint64_t v161 = v166;
              qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
              qword_F42C0 = v166;
              __break(1u);
              JUMPOUT(0x56FB4);
            }
            v165 &= 0x7700000001uLL;
            v165 |= v164;
            unint64_t v160 = v165;
            unint64_t v49 = v166;
            unint64_t v50 = v166;
            atomic_compare_exchange_strong_explicit(v162, &v50, v165, memory_order_acquire, memory_order_acquire);
            if (v50 != v49) {
              unint64_t v166 = v50;
            }
            BOOL v159 = v50 == v49;
            BOOL v163 = v50 == v49;
          }
          while (v50 != v49);
          BOOL v158 = v163;
          char v147 = 1;
        }
        else
        {
          uint64_t v154 = v145;
          uint64_t v153 = 2013265919;
          uint64_t v152 = 0;
          v145 &= 0xFFFFFFFF88FFFFFFLL;
          if (v146[3] == -4) {
            v145 |= 0x1000000uLL;
          }
          _dispatch_thread_setspecific(4, v145);
          if (v146[3] == -4)
          {
            *((unsigned char *)v146 + 44) = 1;
          }
          else
          {
            _dispatch_thread_getspecific(0);
            _dispatch_log("%u\t%p\twlh[%p]: handling events", v35, v36, v37, v38, v39, v40, v41, 6538);
          }
          char v147 = 0;
        }
        char v112 = v147;
        if (v147)
        {
          uint64_t v52 = (int)*v118;
          int v137 = 1;
          uint64_t v136 = &_dispatch_mgr_q;
          uint64_t v135 = v52;
          uint64_t v116 = -4;
        }
        else
        {
          if (v120 == (uint64_t *)-4) {
            signed int v100 = 0;
          }
          else {
            signed int v100 = v120;
          }
          uint64_t v51 = (int)*v118;
          int v140 = 1;
          uint64_t v139 = v100;
          uint64_t v138 = v51;
        }
        uint64_t v143 = &v113;
        _dispatch_thread_setspecific(29, (uint64_t)&v113);
        _dispatch_event_loop_merge(v119, *v118);
        if (v112)
        {
          int v134 = 2;
          int v133 = &_dispatch_mgr_q;
          uint64_t v132 = 0;
          _dispatch_mgr_queue_drain();
          if (byte_F432E) {
            _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v53, v54, v55, v56, v57, v58);
          }
          BOOL v173 = 0;
          unint64_t v189 = &_dispatch_mgr_q;
          unint64_t v187 = 0;
          BOOL v186 = 0;
          uint64_t v185 = (atomic_ullong *)&qword_F0138;
          uint64_t v188 = qword_F0138;
          do
          {
            unint64_t v187 = (v188 - 0x40020000000000) & 0xFFFFFFF000000001;
            unint64_t v184 = v187;
            uint64_t v59 = v188;
            uint64_t v60 = v188;
            atomic_compare_exchange_strong_explicit(v185, (unint64_t *)&v60, v187, memory_order_release, memory_order_relaxed);
            if (v60 != v59) {
              uint64_t v188 = v60;
            }
            BOOL v183 = v60 == v59;
            BOOL v186 = v60 == v59;
          }
          while (v60 != v59);
          BOOL v182 = v186;
          uint64_t v190 = v188;
          BOOL v173 = (v188 & 0x8000000000) != 0;
          _dispatch_thread_setspecific(25, 0);
          uint64_t v172 = 0;
          uint64_t v177 = 0;
          _dispatch_thread_setspecific(20, 0);
          if (v173)
          {
            int v176 = 3;
            BOOL v175 = &_dispatch_mgr_q;
            uint64_t v174 = 1;
            _dispatch_event_loop_poke(-8, 0, 0, v61, v62, v63, v64, v65);
          }
        }
        else if (v114)
        {
          _dispatch_thread_getspecific(0);
          _dispatch_log("%u\t%p\twlh[%p]: draining deferred item %p", v66, v67, v68, v69, v70, v71, v72, 6708);
          if (v116 == -4)
          {
            BOOL v122 = WORD4(v117) == 0;
            uint64_t v121 = 6710;
            if (WORD4(v117)) {
              _dispatch_abort(v121, v122, v73, v74, v75, v76, v77, v78);
            }
            uint64_t v142 = 0;
            _dispatch_thread_setspecific(29, 0);
            int v131 = 2;
            uint64_t v130 = v113;
            uint64_t v129 = 0;
            _dispatch_root_queue_drain_deferred_item(&v113);
          }
          else
          {
            int v128 = 2;
            int v127 = v120;
            uint64_t v126 = 0;
            _dispatch_root_queue_drain_deferred_wlh(&v113);
          }
        }
        if ((v111 & 1) == 0 && wg) {
          os_workgroup_leave(wg, &token_out);
        }
        uint64_t v141 = 0;
        _dispatch_thread_setspecific(29, 0);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\treturning %d deferred kevents", v79, v80, v81, v82, v83, v84, v85, 6735);
        _dispatch_thread_setspecific(5, 0);
        _dispatch_thread_setspecific(120, 0);
        *int v118 = WORD4(v117);
        int v125 = 4;
        uint64_t v124 = 0;
        uint64_t v123 = 0;
        unsigned int v211 = v103;
        BOOL v215 = (uint64_t *)((char *)v103 + 4) != 0;
        uint64_t v214 = 861;
        if (v103 == (uint64_t *)-4) {
          _dispatch_abort(v214, v215, v86, v87, v88, v89, v90, v91);
        }
        char v99 = v211;
        BOOL v98 = v99 == _dispatch_thread_getspecific(0x1BuLL);
        BOOL v213 = v98;
        uint64_t v212 = 862;
        if (!v98) {
          _dispatch_abort(v212, v213, v92, v93, v94, v95, v96, v97);
        }
        _dispatch_thread_setspecific(27, (unint64_t)v211 | 1);
      }
    }
    else
    {
      _dispatch_kevent_worker_thread(a2, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
  }
  else
  {
    _dispatch_bug(6774, v102, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

uint64_t _dispatch_wlh_uses_bound_thread(uint64_t *a1)
{
  if (a1 == (uint64_t *)-4) {
    goto LABEL_7;
  }
  uint64_t v2 = 0;
  if (*a1) {
    uint64_t v2 = *a1;
  }
  if (*(void *)(v2 + 16) == 131090 && _dispatch_workloop_uses_bound_thread((uint64_t)a1)) {
    char v3 = 1;
  }
  else {
LABEL_7:
  }
    char v3 = 0;
  return v3 & 1;
}

uint64_t _dispatch_wlh_uses_bound_thread_setup(uint64_t result)
{
  uint64_t v2 = result;
  if (*(void *)(result + 72))
  {
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x7CuLL);
    if (!result)
    {
      pthread_setname_np(*(const char **)(v2 + 72));
      uint64_t result = _dispatch_thread_setspecific(124, 1);
    }
  }
  if (*(void *)(v2 + 200) && *(void *)(*(void *)(v2 + 200) + 32))
  {
    uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x73uLL);
    if (!result)
    {
      uint64_t v1 = _dispatch_calloc();
      _os_workgroup_join_update_wg(*(void *)(*(void *)(v2 + 200) + 32), v1);
      return _dispatch_thread_setspecific(115, v1);
    }
  }
  return result;
}

uint64_t _dispatch_wlh_get_workgroup(uint64_t *a1)
{
  uint64_t v3 = 0;
  if (a1 != (uint64_t *)-4)
  {
    uint64_t v2 = 0;
    if (*a1) {
      uint64_t v2 = *a1;
    }
    if (*(void *)(v2 + 16) == 131090 && a1[25]) {
      return *(void *)(a1[25] + 32);
    }
  }
  return v3;
}

void _dispatch_root_queue_drain_deferred_item(uint64_t *a1)
{
  uint64_t v19 = a1;
  uint64_t v18 = 0;
  uint64_t v18 = *a1;
  uint64_t v17 = v18;
  uint64_t v33 = v18;
  _dispatch_thread_setspecific(20, v18);
  int v31 = 2;
  uint64_t v30 = 0;
  uint64_t v29 = 0;
  memset(v16, 0, sizeof(v16));
  _dispatch_last_resort_autorelease_pool_push((uint64_t)v16);
  unsigned int v51 = *(_DWORD *)(v18 + 84);
  BOOL v53 = _dispatch_thread_getspecific(0x19uLL) == 0;
  uint64_t v52 = 2319;
  if (!v53) {
    _dispatch_abort(v52, 0, v1, v2, v3, v4, v5, v6);
  }
  _dispatch_thread_setspecific(25, v51);
  _dispatch_continuation_pop_inline((void *)v19[1], (uint64_t)v16, 196608, v18);
  _dispatch_last_resort_autorelease_pool_pop((uint64_t)v16);
  _dispatch_thread_setspecific(25, 0);
  uint64_t v32 = 0;
  _dispatch_thread_setspecific(20, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v7, v8, v9, v10, v11, v12, v13, 7301);
  uint64_t v21 = 0;
  uint64_t v20 = 14;
  uint64_t v25 = 0;
  uint64_t v24 = 0;
  uint64_t v23 = 14;
  uint64_t v37 = 0;
  uint64_t v50 = 1;
  uint64_t v49 = 2395;
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v48 = v37;
    uint64_t v47 = 4261412863;
    uint64_t v46 = 0;
    v37 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v36 = 0;
    uint64_t v39 = 0;
    uint64_t v39 = _dispatch_thread_getspecific(4uLL);
    unint64_t v36 = (unint64_t)v39;
    uint64_t v35 = 0x1000000;
    uint64_t v34 = 2281701376;
    if ((v39 & 0x1000000) != 0)
    {
      if (v37)
      {
        uint64_t v15 = v37;
      }
      else
      {
        unint64_t v45 = v36;
        uint64_t v44 = v35;
        uint64_t v43 = 0;
        uint64_t v15 = v36 & (~v35 | 0xFFFFFF);
      }
      uint64_t v38 = v15;
    }
    else
    {
      unint64_t v42 = v36;
      uint64_t v41 = v34;
      uint64_t v40 = 0;
      v36 &= ~v34 | 0xFFFFFF;
      if (v37 == v36) {
        uint64_t v38 = 0;
      }
      else {
        uint64_t v38 = v37;
      }
    }
  }
  else
  {
    uint64_t v38 = 0;
  }
  uint64_t v25 = v38;
  if (v38) {
    goto LABEL_26;
  }
  if (v24 == -1)
  {
    uint64_t v26 = -1;
    return;
  }
  uint64_t v14 = (void *)v24;
  if (v14 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_26:
    _dispatch_set_priority_and_voucher_slow(v25, (_DWORD *)v24, v23);
  }
  else
  {
    BOOL v22 = (v23 & 4) != 0;
    if ((v23 & 2) != 0)
    {
      if (v22)
      {
        if (v24)
        {
          object = (void *)v24;
          os_release((void *)v24);
        }
      }
      uint64_t v24 = -1;
    }
    else if (!v22 && v24)
    {
      uint64_t v28 = (void *)v24;
      os_retain((void *)v24);
    }
    uint64_t v26 = v24;
  }
}

void _dispatch_root_queue_drain_deferred_wlh(uint64_t *a1)
{
  uint64_t v46 = a1;
  uint64_t v45 = 0;
  uint64_t v45 = *a1;
  uint64_t v44 = 0;
  uint64_t v44 = (void *)a1[1];
  uint64_t v43 = v45;
  uint64_t v78 = v45;
  _dispatch_thread_setspecific(20, v45);
  memset(v42, 0, sizeof(v42));
  unsigned int v41 = 196610;
  unint64_t v40 = 0;
  unsigned int v102 = *(_DWORD *)(v45 + 84);
  BOOL v7 = _dispatch_thread_getspecific(0x19uLL) == 0;
  BOOL v104 = v7;
  uint64_t v103 = 2331;
  if (!v7) {
    _dispatch_abort(v103, v104, v1, v2, v3, v4, v5, v6);
  }
  v102 |= 0xF0000u;
  _dispatch_thread_setspecific(25, v102);
  *((unsigned char *)v46 + 45) |= 4u;
  while (1)
  {
    uint64_t v72 = *((unsigned char *)v46 + 45) & 1;
    uint64_t v71 = 7189;
    if (!v72) {
      _dispatch_abort(v71, 0, v8, v9, v10, v11, v12, v13);
    }
    uint64_t v76 = v45;
    uint64_t v75 = v44;
    int v74 = 0;
    int v73 = 0;
    uint64_t v101 = v45;
    signed int v100 = v44;
    uint64_t v115 = v44;
    uint64_t v114 = &v40;
    uint64_t v113 = 0;
    unint64_t v112 = 0;
    uint64_t v111 = 0;
    unsigned int v122 = _dispatch_thread_getspecific(3uLL);
    uint64_t v111 = v122 & 0xFFFFFFFC | 0x60000000000000;
    BOOL v110 = 0;
    uint64_t v109 = (atomic_ullong *)(v115 + 7);
    uint64_t v113 = v115[7];
    do
    {
      unint64_t v112 = v113;
      uint64_t v118 = v113;
      if ((v113 & 0xFF80000000000000) != 0)
      {
        v112 &= ~1uLL;
      }
      else
      {
        uint64_t v120 = v113;
        int v124 = v113;
        if ((v113 & 0xFFFFFFFC) != 0)
        {
          uint64_t v123 = v113;
          if ((v113 & 2) == 0) {
            break;
          }
          v112 |= 0x800000000uLL;
        }
        else
        {
          v112 &= 0x7700000001uLL;
          v112 |= v111;
        }
      }
      unint64_t v108 = v112;
      uint64_t v20 = v113;
      uint64_t v21 = v113;
      atomic_compare_exchange_strong_explicit(v109, (unint64_t *)&v21, v112, memory_order_acquire, memory_order_acquire);
      if (v21 != v20) {
        uint64_t v113 = v21;
      }
      BOOL v107 = v21 == v20;
      BOOL v110 = v21 == v20;
    }
    while (v21 != v20);
    BOOL v106 = v110;
    uint64_t v116 = v113;
    LOBYTE(v39) = 1;
    if ((v113 & 0x2000000000) != 0)
    {
      uint64_t v126 = v113;
      LOBYTE(v39) = 1;
      if (v113)
      {
        uint64_t v121 = v113;
        int v39 = (BYTE4(v113) >> 6) & 1;
      }
    }
    if (v39)
    {
      uint64_t v105 = v113;
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid wlh state";
      qword_F42C0 = v113;
      __break(1u);
      JUMPOUT(0x58400);
    }
    if (v114) {
      *uint64_t v114 = v112;
    }
    uint64_t v117 = v113;
    BOOL v38 = 0;
    if ((v113 & 0xFF80000000000000) == 0)
    {
      uint64_t v119 = v113;
      int v125 = v113;
      BOOL v38 = (v113 & 0xFFFFFFFC) == 0;
    }
    if (!v38) {
      break;
    }
    uint64_t v37 = 0;
    if (*v44) {
      uint64_t v37 = *v44;
    }
    (*(void (**)(void *, _OWORD *, void))(v37 + 48))(v44, v42, v41);
    if ((*((unsigned char *)v46 + 45) & 1) == 0) {
      goto LABEL_44;
    }
    unint64_t v40 = v44[7];
    unint64_t v60 = v40;
    if (((BYTE4(v40) >> 5) & 1) == 0) {
      goto LABEL_44;
    }
    unint64_t v99 = v40;
    if ((v40 & 1) == 0) {
      goto LABEL_43;
    }
    _dispatch_retain((uint64_t)v44);
    uint64_t v59 = v44[3];
    uint64_t v58 = v44;
    int v57 = 0;
    int v56 = 0;
    uint64_t v97 = v59;
    uint64_t v96 = v44;
  }
  unint64_t v61 = v40;
  if ((v40 & 0xFF80000000000000) != 0)
  {
    unint64_t v64 = v40;
    BOOL v70 = (v40 & 0x4000000001) == 0;
    uint64_t v69 = 7253;
    if ((v40 & 0x4000000001) != 0) {
      _dispatch_abort(v69, v70, v14, v15, v16, v17, v18, v19);
    }
    _dispatch_release_2_no_dispose((uint64_t)v44);
  }
  else
  {
    unint64_t v63 = v40;
    BOOL v68 = (v40 & 0x4000000001) != 0;
    uint64_t v67 = 7256;
    if ((v40 & 0x4000000001) == 0) {
      _dispatch_abort(v67, v68, v14, v15, v16, v17, v18, v19);
    }
    unint64_t v62 = v40;
    int v98 = v40;
    BOOL v66 = (v40 & 0xFFFFFFFC) != 0;
    uint64_t v65 = 7257;
    if ((v40 & 0xFFFFFFFC) == 0) {
      _dispatch_abort(v65, v66, v14, v15, v16, v17, v18, v19);
    }
    _dispatch_release_no_dispose((uint64_t)v44);
  }
LABEL_43:
  _dispatch_event_loop_leave_deferred((uint64_t)v46, v40, v22, v23, v24, v25, v26, v27);
LABEL_44:
  _dispatch_thread_setspecific(25, 0);
  uint64_t v77 = 0;
  _dispatch_thread_setspecific(20, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v28, v29, v30, v31, v32, v33, v34, 7270);
  uint64_t v48 = 0;
  uint64_t v47 = 14;
  uint64_t v52 = 0;
  uint64_t v51 = 0;
  uint64_t v50 = 14;
  uint64_t v82 = 0;
  uint64_t v95 = 1;
  uint64_t v94 = 2395;
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v93 = v82;
    uint64_t v92 = 4261412863;
    uint64_t v91 = 0;
    v82 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v81 = 0;
    uint64_t v84 = 0;
    uint64_t v84 = _dispatch_thread_getspecific(4uLL);
    unint64_t v81 = (unint64_t)v84;
    uint64_t v80 = 0x1000000;
    uint64_t v79 = 2281701376;
    if ((v84 & 0x1000000) != 0)
    {
      if (v82)
      {
        uint64_t v36 = v82;
      }
      else
      {
        unint64_t v90 = v81;
        uint64_t v89 = v80;
        uint64_t v88 = 0;
        uint64_t v36 = v81 & (~v80 | 0xFFFFFF);
      }
      uint64_t v83 = v36;
    }
    else
    {
      unint64_t v87 = v81;
      uint64_t v86 = v79;
      uint64_t v85 = 0;
      v81 &= ~v79 | 0xFFFFFF;
      if (v82 == v81) {
        uint64_t v83 = 0;
      }
      else {
        uint64_t v83 = v82;
      }
    }
  }
  else
  {
    uint64_t v83 = 0;
  }
  uint64_t v52 = v83;
  if (v83) {
    goto LABEL_67;
  }
  if (v51 == -1)
  {
    uint64_t v53 = -1;
    return;
  }
  uint64_t v35 = (void *)v51;
  if (v35 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_67:
    uint64_t v53 = _dispatch_set_priority_and_voucher_slow(v52, (_DWORD *)v51, v50);
  }
  else
  {
    BOOL v49 = (v50 & 4) != 0;
    if ((v50 & 2) != 0)
    {
      if (v49 && v51)
      {
        object = (void *)v51;
        os_release((void *)v51);
      }
      uint64_t v51 = -1;
    }
    else if (!v49 && v51)
    {
      uint64_t v55 = (void *)v51;
      os_retain((void *)v51);
    }
    uint64_t v53 = v51;
  }
}

void _dispatch_queue_cleanup2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = &_dispatch_main_q;
  unint64_t v18 = 0;
  BOOL v17 = 0;
  uint64_t v16 = (atomic_ullong *)qword_F0038;
  uint64_t v19 = qword_F0038[0];
  do
  {
    unint64_t v18 = (v19 & 0xFFFFFF7FFFFFFFFFLL) + 0x40020000000000;
    unint64_t v15 = v18;
    uint64_t v8 = v19;
    uint64_t v9 = v19;
    atomic_compare_exchange_strong_explicit(v16, (unint64_t *)&v9, v18, memory_order_acquire, memory_order_acquire);
    if (v9 != v8) {
      uint64_t v19 = v9;
    }
    BOOL v14 = v9 == v8;
    BOOL v17 = v9 == v8;
  }
  while (v9 != v8);
  BOOL v13 = v17;
  v12[2] = (pthread_t)v20;
  uint64_t v32 = v20;
  int v31 = 0x40000;
  int v29 = -262145;
  int v28 = -262145;
  int v30 = -262145;
  int v24 = -262145;
  int v23 = -262145;
  int v25 = -262145;
  unsigned int v22 = atomic_fetch_and_explicit((atomic_uint *volatile)((char *)v20 + 80), 0xFFFBFFFF, memory_order_relaxed);
  unsigned int v26 = v22;
  unsigned int v21 = v22;
  unsigned int v27 = v22 & 0xFFFBFFFF;
  v12[1] = (pthread_t)v20;
  _dispatch_lane_barrier_complete((uint64_t)v20, 0, 0, a4, a5, a6, a7, a8);
  if (_dispatch_program_is_probably_callback_driven)
  {
    memset(&v36, 0, sizeof(v36));
    pthread_attr_init(&v36);
    pthread_attr_setdetachstate(&v36, 2);
    v12[0] = 0;
    uint64_t v10 = 0;
    if (_dispatch_sig_thread) {
      uint64_t v10 = (void *(__cdecl *)(void *))_dispatch_sig_thread;
    }
    int v11 = pthread_create(v12, &v36, v10, 0);
    if (v11)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to create signal thread";
      qword_F42C0 = v11;
      __break(1u);
      JUMPOUT(0x590B4);
    }
    pthread_attr_destroy(&v36);
    sleep_NOCANCEL();
  }
  uint64_t v35 = &_dispatch_main_q_handle_pred;
  uint64_t v34 = v20;
  dispatch_function_t v33 = (dispatch_function_t)_dispatch_runloop_queue_handle_init;
  if (_dispatch_main_q_handle_pred != -1) {
    dispatch_once_f(v35, v34, v33);
  }
  _dispatch_runloop_queue_handle_dispose((mach_port_context_t)v20);
}

void _dispatch_sig_thread()
{
  uint64_t v0 = pthread_self();
  pthread_get_stackaddr_np(v0);
  __memset_chk();
  _dispatch_sigsuspend();
}

void _dispatch_sigsuspend()
{
  while (1)
    sigsuspend_NOCANCEL();
}

void _dispatch_apply_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = a1;
  uint64_t v19 = 0;
  int i = 0;
  int v14 = 1;
  int v13 = 1;
  int v15 = 1;
  unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 52), 1u, memory_order_relaxed);
  unsigned int v16 = add_explicit;
  unsigned int v11 = add_explicit;
  unsigned int v17 = add_explicit;
  BOOL v8 = add_explicit < *(_DWORD *)(a1 + 48);
  BOOL v22 = v8;
  uint64_t v21 = 210;
  if (!v8) {
    _dispatch_abort(v21, v22, a3, a4, a5, a6, a7, a8);
  }
  v10[0] = v20;
  v10[1] = v19;
  v10[2] = v17;
  _dispatch_apply_set_attr_behavior(*(void *)(v20 + 56));
  int v28 = (dispatch_once_t *)(*(void *)(v20 + 32) + 8 * v17);
  unsigned int v27 = v10;
  dispatch_function_t v26 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v28 != -1) {
    dispatch_once_f(v28, v27, v26);
  }
  _dispatch_apply_clear_attr_behavior(*(void *)(v20 + 56));
  if ((v19 & 2) != 0)
  {
    for (int i = 0; i < *(_DWORD *)(v20 + 48); ++i)
    {
      if (i != v17)
      {
        int v25 = (dispatch_once_t *)(*(void *)(v20 + 32) + 8 * i);
        int v24 = 0;
        int v23 = _dispatch_no_op;
        if (*v25 != -1) {
          dispatch_once_f(v25, v24, (dispatch_function_t)v23);
        }
      }
    }
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v20 + 44), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v29 = v20;
    if (*(void *)(v20 + 32)) {
      free(*(void **)(v29 + 32));
    }
    if (*(void *)(v29 + 56))
    {
      dispatch_apply_attr_destroy();
      free(*(void **)(v29 + 56));
    }
    uint64_t v30 = v29;
    int v31 = (void *)v29;
    uint64_t v34 = v29;
    dispatch_function_t v33 = 0;
    dispatch_function_t v33 = _dispatch_thread_getspecific(0x16uLL);
    int v32 = 0;
    if (v33) {
      int v9 = v33[2] + 1;
    }
    else {
      int v9 = 1;
    }
    int v32 = v9;
    if (v9 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v34 + 16) = v33;
      *(_DWORD *)(v34 + 8) = v32;
      _dispatch_thread_setspecific(22, v34);
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v35 = (void *)v34;
    }
    int v31 = v35;
    if (v35) {
      _dispatch_continuation_free_to_cache_limit(v31);
    }
  }
}

void _dispatch_apply_redirect_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = a1;
  uint64_t v19 = 1;
  int i = 0;
  int v14 = 1;
  int v13 = 1;
  int v15 = 1;
  unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 52), 1u, memory_order_relaxed);
  unsigned int v16 = add_explicit;
  unsigned int v11 = add_explicit;
  unsigned int v17 = add_explicit;
  BOOL v8 = add_explicit < *(_DWORD *)(a1 + 48);
  BOOL v22 = v8;
  uint64_t v21 = 210;
  if (!v8) {
    _dispatch_abort(v21, v22, a3, a4, a5, a6, a7, a8);
  }
  v10[0] = v20;
  v10[1] = v19;
  v10[2] = v17;
  _dispatch_apply_set_attr_behavior(*(void *)(v20 + 56));
  int v28 = (dispatch_once_t *)(*(void *)(v20 + 32) + 8 * v17);
  unsigned int v27 = v10;
  dispatch_function_t v26 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v28 != -1) {
    dispatch_once_f(v28, v27, v26);
  }
  _dispatch_apply_clear_attr_behavior(*(void *)(v20 + 56));
  if ((v19 & 2) != 0)
  {
    for (int i = 0; i < *(_DWORD *)(v20 + 48); ++i)
    {
      if (i != v17)
      {
        int v25 = (dispatch_once_t *)(*(void *)(v20 + 32) + 8 * i);
        int v24 = 0;
        int v23 = _dispatch_no_op;
        if (*v25 != -1) {
          dispatch_once_f(v25, v24, (dispatch_function_t)v23);
        }
      }
    }
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v20 + 44), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v29 = v20;
    if (*(void *)(v20 + 32)) {
      free(*(void **)(v29 + 32));
    }
    if (*(void *)(v29 + 56))
    {
      dispatch_apply_attr_destroy();
      free(*(void **)(v29 + 56));
    }
    uint64_t v30 = v29;
    int v31 = (void *)v29;
    uint64_t v34 = v29;
    dispatch_function_t v33 = 0;
    dispatch_function_t v33 = _dispatch_thread_getspecific(0x16uLL);
    int v32 = 0;
    if (v33) {
      int v9 = v33[2] + 1;
    }
    else {
      int v9 = 1;
    }
    int v32 = v9;
    if (v9 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v34 + 16) = v33;
      *(_DWORD *)(v34 + 8) = v32;
      _dispatch_thread_setspecific(22, v34);
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v35 = (void *)v34;
    }
    int v31 = v35;
    if (v35) {
      _dispatch_continuation_free_to_cache_limit(v31);
    }
  }
}

void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
  uint64_t v4 = 0;
  if (work) {
    uint64_t v4 = work;
  }
  _dispatch_apply_with_attr_f(iterations, 0, queue, (uint64_t)context, (uint64_t)v4, 1);
}

void _dispatch_apply_with_attr_f(unint64_t a1, uint64_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v96 = a1;
  uint64_t v95 = a2;
  uint64_t v94 = a3;
  uint64_t v93 = a4;
  uint64_t v92 = a5;
  uint64_t v91 = a6;
  if (a1)
  {
    if (v95 && !_dispatch_attr_is_initialized(v95))
    {
      uint64_t v90 = v95;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_F42C0 = v95;
      __break(1u);
      JUMPOUT(0x59BBCLL);
    }
    uint64_t v89 = 0;
    int v98 = "apply";
    for (int i = _dispatch_thread_getspecific(0x17uLL); i; int i = (void *)*i)
    {
      if (i[1] == (void)v98)
      {
        unint64_t v99 = i;
        goto LABEL_11;
      }
    }
    unint64_t v99 = 0;
LABEL_11:
    uint64_t v89 = v99;
    unint64_t v88 = 0;
    if (v99) {
      unint64_t v74 = v89[2];
    }
    else {
      unint64_t v74 = 0;
    }
    unint64_t v88 = v74;
    unint64_t v87 = (dispatch_queue_s *)_dispatch_thread_getspecific(0x14uLL);
    dispatch_queue_t queue = 0;
    if (v94)
    {
      dispatch_queue_t queue = v94;
    }
    else
    {
      unint64_t v108 = (unint64_t)v87;
      unint64_t v107 = 0;
      if (v87)
      {
        while (*(void *)(v108 + 24))
        {
          unint64_t v107 = *(void *)(v108 + 24);
          unint64_t v131 = v108;
          BOOL v73 = 1;
          if (*(void *)(v108 + 24) != (void)&_dispatch_custom_workloop_root_queue) {
            BOOL v73 = *(void *)(v131 + 24) == (void)&_dispatch_custom_workloop_overcommit_root_queue;
          }
          if (v73)
          {
            unint64_t v106 = v108;
            unint64_t v152 = v108;
            unint64_t v153 = v108;
            unint64_t v105 = v108;
            uint64_t v109 = (dispatch_queue_s *)v108;
            goto LABEL_38;
          }
          unint64_t v108 = v107;
        }
      }
      if (!v108) {
        goto LABEL_27;
      }
      unint64_t v104 = v108;
      unint64_t v246 = v108;
      BOOL v72 = 0;
      if (v108 >= (unint64_t)&_dispatch_root_queues) {
        BOOL v72 = v246 < (unint64_t)&unk_F0A80;
      }
      if (v72)
      {
LABEL_27:
        int v128 = _dispatch_thread_getspecific(4uLL);
        uint64_t v101 = v128;
        int v100 = 0;
        unint64_t v126 = (unint64_t)(v128 & 0x3FFF00) >> 8;
        unsigned int v6 = (v128 & 0x3FFF00) >> 8;
        unsigned int v7 = __clz(__rbit32(v6));
        if (v6) {
          unsigned int v8 = v7 + 1;
        }
        else {
          unsigned int v8 = 0;
        }
        int v100 = v8;
        if (v8) {
          int v71 = v100;
        }
        else {
          int v71 = 4;
        }
        unsigned int v250 = v71;
        uint64_t v249 = 0;
        BOOL v70 = 1;
        if (v71) {
          BOOL v70 = v250 > 6;
        }
        if (v70)
        {
          uint64_t v248 = v250;
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
          qword_F42C0 = v250;
          __break(1u);
          JUMPOUT(0x59F18);
        }
        int v247 = 0;
        uint64_t v109 = (dispatch_queue_s *)&(&_dispatch_root_queues)[16 * (unint64_t)(3 * v250 - 3)];
      }
      else
      {
        unint64_t v103 = v108;
        unint64_t v154 = v108;
        unint64_t v155 = v108;
        unint64_t v102 = v108;
        uint64_t v109 = (dispatch_queue_s *)v108;
      }
LABEL_38:
      dispatch_queue_t queue = v109;
    }
    unsigned int v85 = 0;
    unsigned int v110 = *((_DWORD *)queue + 21) & 0xF00;
    if (v110 >> 8)
    {
      unsigned int v69 = v110 >> 8;
    }
    else
    {
      unsigned int v111 = *((_DWORD *)queue + 21) & 0xF000;
      unsigned int v69 = v111 >> 12;
    }
    unsigned int v85 = v69;
    if (*((void *)queue + 3))
    {
      uint64_t v129 = _dispatch_thread_getspecific(4uLL);
      unint64_t v127 = (unint64_t)(v129 & 0x3FFF00) >> 8;
      unsigned int v9 = (v129 & 0x3FFF00) >> 8;
      unsigned int v10 = __clz(__rbit32(v9));
      if (v9) {
        unsigned int v11 = v10 + 1;
      }
      else {
        unsigned int v11 = 0;
      }
      unsigned int v85 = v11;
    }
    unint64_t v84 = 0;
    uint64_t v121 = v95;
    unint64_t v120 = v88;
    unsigned int v119 = v85;
    char v118 = 1;
    if (v95 && !_dispatch_attr_is_initialized(v121))
    {
      uint64_t v117 = v121;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_F42C0 = v121;
      __break(1u);
      JUMPOUT(0x5A0FCLL);
    }
    unint64_t v116 = 0;
    if (v121)
    {
      if (v120)
      {
        unint64_t v116 = 1;
      }
      else
      {
        uint64_t v114 = 2;
        unint64_t v113 = 0;
        unsigned int v260 = v119;
        uint64_t v259 = 2;
        unsigned int v258 = 0;
        int v257 = 0;
        if (v119)
        {
          unsigned int v265 = v260;
          switch(v260)
          {
            case 1u:
              int v266 = 5;
              break;
            case 2u:
              int v266 = 9;
              break;
            case 3u:
              int v266 = 17;
              break;
            case 4u:
              int v266 = 21;
              break;
            case 5u:
              int v266 = 25;
              break;
            case 6u:
              int v266 = 33;
              break;
            default:
              int v266 = 0;
              break;
          }
          int v257 = pthread_qos_max_parallelism();
        }
        if (v257 < 1)
        {
          int v272 = 0;
          uint64_t v271 = 0xFFFFFC036;
          unsigned int v258 = MEMORY[0xFFFFFC036];
        }
        else
        {
          unsigned int v258 = v257;
        }
        int v270 = 2;
        uint64_t v269 = 0xFFFFFC034;
        unsigned int v256 = MEMORY[0xFFFFFC034];
        if (MEMORY[0xFFFFFC034] < v258) {
          unsigned int v258 = v256;
        }
        unint64_t v113 = v258;
        unint64_t v112 = 0;
        uint64_t v264 = v121;
        unsigned int v263 = v119;
        unint64_t v262 = -1;
        if (*(void *)(v121 + 8))
        {
          int v261 = 0;
          unsigned int v279 = v263;
          int v278 = 0;
          int v277 = 0;
          unsigned int v280 = v263;
          switch(v263)
          {
            case 1u:
              int v281 = 5;
              break;
            case 2u:
              int v281 = 9;
              break;
            case 3u:
              int v281 = 17;
              break;
            case 4u:
              int v281 = 21;
              break;
            case 5u:
              int v281 = 25;
              break;
            case 6u:
              int v281 = 33;
              break;
            default:
              int v281 = 0;
              break;
          }
          int v277 = pthread_qos_max_parallelism();
          if (v277 >= 1) {
            int v278 = v277;
          }
          int v261 = v278;
          if (v278) {
            unint64_t v262 = (v261 * *(_DWORD *)(v264 + 8));
          }
          else {
            unint64_t v262 = 0;
          }
        }
        unint64_t v112 = v262;
        if (v113 >= v262) {
          unint64_t v67 = v112;
        }
        else {
          unint64_t v67 = v113;
        }
        unint64_t v116 = v67;
      }
    }
    else
    {
      uint64_t v115 = 2;
      unsigned int v255 = v119;
      uint64_t v254 = 2;
      unsigned int v253 = 0;
      int v252 = 0;
      if (v119)
      {
        unsigned int v267 = v255;
        switch(v255)
        {
          case 1u:
            int v268 = 5;
            break;
          case 2u:
            int v268 = 9;
            break;
          case 3u:
            int v268 = 17;
            break;
          case 4u:
            int v268 = 21;
            break;
          case 5u:
            int v268 = 25;
            break;
          case 6u:
            int v268 = 33;
            break;
          default:
            int v268 = 0;
            break;
        }
        int v252 = pthread_qos_max_parallelism();
      }
      if (v252 < 1)
      {
        int v276 = 0;
        uint64_t v275 = 0xFFFFFC036;
        unsigned int v253 = MEMORY[0xFFFFFC036];
      }
      else
      {
        unsigned int v253 = v252;
      }
      int v274 = 2;
      uint64_t v273 = 0xFFFFFC034;
      unsigned int v251 = MEMORY[0xFFFFFC034];
      if (MEMORY[0xFFFFFC034] < v253) {
        unsigned int v253 = v251;
      }
      unint64_t v116 = v253;
      if (v120)
      {
        if (v120 >= v116) {
          uint64_t v68 = 1;
        }
        else {
          uint64_t v68 = v116 / v120;
        }
        unint64_t v116 = v68;
      }
    }
    unint64_t v84 = v116;
    if (!v116)
    {
      uint64_t v83 = v95;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: attribute's properties are invalid or meaningless on this system";
      qword_F42C0 = v95;
      __break(1u);
      JUMPOUT(0x5ACD8);
    }
    uint64_t v82 = 0;
    if (v95)
    {
      uint64_t v82 = 0xFFFFLL;
    }
    else if (v88)
    {
      if (v88 > 0xFFFE || v96 > 0xFFFE) {
        uint64_t v66 = 0xFFFFLL;
      }
      else {
        uint64_t v66 = v88 * v96;
      }
      uint64_t v82 = v66;
    }
    else
    {
      uint64_t v82 = v96;
    }
    if (v96 < v84) {
      unint64_t v84 = v96;
    }
    long long v81 = 0u;
    long long v80 = 0u;
    memset(v79, 0, sizeof(v79));
    uint64_t v65 = 0;
    if (v92) {
      uint64_t v65 = v92;
    }
    uint64_t v64 = 0;
    if (v65) {
      uint64_t v64 = v65;
    }
    *(void *)&long long v80 = v64;
    *((void *)&v80 + 1) = v93;
    *(void *)&long long v81 = v91;
    *((void *)&v81 + 1) = queue;
    context = 0;
    uint64_t v130 = 0;
    unint64_t v160 = 0;
    unint64_t v162 = _dispatch_thread_getspecific(0x16uLL);
    if (v162) {
      _dispatch_thread_setspecific(22, v162[2]);
    }
    unint64_t v160 = v162;
    if (v162) {
      unint64_t v161 = v160;
    }
    else {
      unint64_t v161 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    uint64_t v130 = v161;
    context = v161;
    v161[1] = 0;
    *((void *)context + 2) = v96;
    *((void *)context + 3) = v82;
    *((_DWORD *)context + 11) = v84;
    *((_DWORD *)context + 13) = 0;
    _dispatch_apply_da_copy_attr((uint64_t)context, v95);
    *((void *)context + 4) = 0;
    *(void *)context = v79;
    *((_DWORD *)context + 1pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
    dispatch_queue_t v132 = queue;
    BOOL v63 = 1;
    if (*((void *)queue + 3) != (void)&_dispatch_custom_workloop_root_queue) {
      BOOL v63 = *((void *)v132 + 3) == (void)&_dispatch_custom_workloop_overcommit_root_queue;
    }
    if (v63)
    {
      uint64_t v77 = 0;
      uint64_t v76 = 0;
      uint64_t v133 = *((void *)queue + 7);
      int v164 = v133;
      int v62 = v133;
      if (((v62 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0) {
        dispatch_async_and_wait_f(queue, context, (dispatch_function_t)_dispatch_apply_serial);
      }
      else {
        _dispatch_apply_serial((uint64_t)context);
      }
      return;
    }
    BOOL v61 = 1;
    if (*((_WORD *)queue + 40) != 1) {
      BOOL v61 = v84 < 2;
    }
    if (v61)
    {
LABEL_139:
      dispatch_sync_f(queue, context, (dispatch_function_t)_dispatch_apply_serial);
      return;
    }
    if (*((void *)queue + 3))
    {
      if (queue != v87)
      {
        dispatch_sync_f(queue, context, (dispatch_function_t)_dispatch_apply_redirect);
        return;
      }
      goto LABEL_139;
    }
    long long v75 = 0uLL;
    dispatch_queue_t v123 = queue;
    unsigned int v122 = &v75;
    int v125 = &v75;
    _dispatch_thread_getspecific_packed_pair(20, 21, &v75, v12, v13, v14, v15, v16);
    _dispatch_thread_setspecific_pair(20, (uint64_t)v123, 21, (uint64_t)v122, v17, v18, v19, v20);
    dispatch_queue_t v156 = queue;
    dispatch_queue_t v157 = queue;
    dispatch_queue_t v148 = queue;
    char v147 = context;
    uint64_t v146 = _dispatch_apply_invoke;
    int j = 0;
    uint64_t v144 = 0;
    unint64_t v143 = 0;
    unint64_t v142 = 0;
    uint64_t v151 = 0;
    uint64_t v151 = _dispatch_thread_getspecific(4uLL);
    unint64_t v142 = (unint64_t)v151;
    int v141 = 0;
    int v141 = v147[11] - 1;
    uint64_t v150 = v141;
    uint64_t v149 = 336;
    if (!v141) {
      _dispatch_abort(v149, v150, v21, v22, v23, v24, v25, v26);
    }
    for (int j = 0; j < v141; ++j)
    {
      int v140 = 0;
      BOOL v158 = 0;
      BOOL v163 = 0;
      BOOL v163 = _dispatch_thread_getspecific(0x16uLL);
      if (v163) {
        _dispatch_thread_setspecific(22, v163[2]);
      }
      BOOL v158 = v163;
      if (v163) {
        BOOL v159 = v158;
      }
      else {
        BOOL v159 = (void *)_dispatch_continuation_alloc_from_heap();
      }
      int v140 = v159;
      uint64_t v139 = 4;
      dispatch_queue_t v138 = v148;
      dispatch_queue_t v171 = v148;
      unsigned int v170 = v159;
      unint64_t v169 = v147;
      unint64_t v168 = v146;
      uint64_t v167 = 0x40000000;
      uint64_t v166 = 4;
      uint64_t v165 = 0;
      void *v159 = 260;
      v170[4] = v168;
      v170[5] = v169;
      if ((v167 & 0x40000000) == 0)
      {
        unint64_t v222 = 0;
        int v221 = 1;
        unsigned int v224 = 0;
        unsigned int v224 = _dispatch_thread_getspecific(4uLL);
        int v225 = v224;
        unint64_t v222 = v224 & 0xFFFFFF;
        if ((v221 & 2) != 0 || (int v229 = 5, v228 = 4096, v222 <= 0x10FF))
        {
          uint64_t v223 = v222;
        }
        else
        {
          int v227 = 5;
          uint64_t v226 = 4096;
          uint64_t v223 = 4351;
        }
        uint64_t v165 = v223;
      }
      int v209 = v170;
      uint64_t v208 = v167;
      int v207 = 0;
      BOOL v211 = (int)v167 >= 0;
      uint64_t v210 = 583;
      if ((int)v167 < 0) {
        _dispatch_abort(v210, v211, v27, v28, v29, v30, v31, v32);
      }
      if ((v208 & 0x40) == 0)
      {
        uint64_t v230 = 0;
        uint64_t v230 = _dispatch_thread_getspecific(0x1CuLL);
        if (v230)
        {
          object = v230;
          os_retain(v230);
        }
        int v207 = v230;
      }
      v209[3] = v207;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v33, v34, v35, v36, v37, v38, v39, 589);
      uint64_t v40 = v209[3];
      int v234 = 771817476;
      uint64_t v233 = v40;
      uint64_t v232 = v209;
      if (v40 != -1)
      {
        unsigned int v231 = 0;
        unsigned int v60 = v233 ? *(_DWORD *)(v233 + 32) : 0;
        unsigned int v231 = v60;
        int v240 = v234;
        uint64_t v239 = v60;
        v238 = v232;
        uint64_t v237 = 0;
        uint64_t v236 = 0;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
      }
      dispatch_queue_t v220 = v171;
      unsigned int v219 = v170;
      unint64_t v218 = v165;
      uint64_t v217 = v167;
      unsigned int v216 = 0;
      dispatch_queue_t v215 = v171;
      if (v165)
      {
        BOOL v214 = (v217 & 0x20) != 0;
        BOOL v213 = 0;
        BOOL v213 = (*((_DWORD *)v215 + 21) & 0x40000000) != 0;
        BOOL v212 = 0;
        BOOL v212 = (*((_DWORD *)v215 + 21) & 0xFFF) != 0;
        if ((v217 & 0x20) != 0)
        {
          v218 |= 0x10000000uLL;
          unint64_t v241 = v218 >> 8;
          unsigned int v41 = v218 >> 8;
          unsigned int v42 = __clz(__rbit32(v41));
          if (v41) {
            unsigned int v43 = v42 + 1;
          }
          else {
            unsigned int v43 = 0;
          }
          unsigned int v216 = v43;
        }
        else if (v213 || !v212)
        {
          unint64_t v242 = v218 >> 8;
          unsigned int v44 = v218 >> 8;
          unsigned int v45 = __clz(__rbit32(v44));
          if (v44) {
            unsigned int v46 = v45 + 1;
          }
          else {
            unsigned int v46 = 0;
          }
          unsigned int v216 = v46;
        }
        else
        {
          unint64_t v218 = 0;
        }
      }
      v219[1] = v218;
      v140[1] = v142 | 0x10000000;
      v140[2] = v144;
      uint64_t v144 = v140;
      if (!v143) {
        unint64_t v143 = (unint64_t)v140;
      }
    }
    v147[12] = v147[11];
    *((void *)v147 + 4) = _dispatch_calloc();
    int v137 = v144;
    unint64_t v136 = v143;
    uint64_t v180 = v144;
    unint64_t v179 = v143;
    dispatch_queue_t v178 = v148;
    int v177 = 0;
    int v176 = 0;
    if (MEMORY[0xFFFFFC100])
    {
      BOOL v175 = v180;
      do
      {
        int v174 = 0;
        int v173 = 0;
        BOOL v59 = 0;
        if (v175 != (void *)v179)
        {
          BOOL v175 = (void *)v175[2];
          BOOL v59 = v175 != 0;
        }
      }
      while (v59);
    }
    dispatch_queue_t v172 = v178;
    dispatch_queue_t v245 = v178;
    v244 = v180;
    unint64_t v243 = v179;
    uint64_t v135 = v144;
    unint64_t v134 = v143;
    int v206 = v144;
    unint64_t v205 = v143;
    dispatch_queue_t v204 = v148;
    signed int v203 = v141;
    int v202 = v144;
    unint64_t v201 = v143;
    unint64_t v200 = 0;
    unint64_t v199 = v143;
    uint64_t v198 = 0;
    uint64_t v197 = 0;
    *(void *)(v143 + 16) = 0;
    uint64_t v196 = v198;
    _dispatch_thread_setspecific(122, (uint64_t)v204 + 48);
    unint64_t v194 = 0;
    unint64_t v192 = v199;
    unint64_t v191 = v199;
    unint64_t v193 = v199;
    unint64_t v190 = atomic_exchange_explicit((atomic_ullong *volatile)((char *)v204 + 48), v199, memory_order_release);
    unint64_t v194 = v190;
    unint64_t v189 = v190;
    unint64_t v195 = v190;
    unint64_t v200 = v190;
    unint64_t v188 = v190;
    if (v190)
    {
      unint64_t v187 = v202;
      BOOL v186 = v202;
      *(void *)(v188 + 16) = v202;
      uint64_t v185 = v187;
    }
    else
    {
      unint64_t v184 = v202;
      BOOL v183 = v202;
      *((void *)v204 + 13) = v202;
      BOOL v182 = v184;
    }
    _dispatch_thread_setspecific(122, 0);
    BOOL v181 = v200 == 0;
    if (!v200) {
      _dispatch_root_queue_poke_and_wakeup((uint64_t)v204, v203, 0, v49, v50, v51, v52, v53);
    }
    _dispatch_apply_invoke_and_wait((uint64_t)v147, v47, v48, v49, v50, v51, v52, v53);
    int v124 = &v75;
    _dispatch_thread_setspecific_packed_pair(20, 21, &v75, v54, v55, v56, v57, v58);
  }
}

void dispatch_apply_with_attr_f(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = 0;
  if (a4) {
    uint64_t v4 = a4;
  }
  _dispatch_apply_with_attr_f(a1, a2, 0, a3, v4, 2);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  unsigned int v6 = _dispatch_Block_copy(block);
  uint64_t v4 = _Block_get_invoke_fn((uint64_t)v6);
  uint64_t v5 = 0;
  if (v4) {
    uint64_t v5 = (void (__cdecl *)(void *, size_t))v4;
  }
  woruint64_t k = 0;
  if (v5) {
    woruint64_t k = v5;
  }
  dispatch_apply_f(iterations, queue, v6, work);
  _Block_release(v6);
}

void dispatch_apply_with_attr(unint64_t a1, uint64_t a2, const void *a3)
{
  unsigned int v6 = _dispatch_Block_copy(a3);
  uint64_t v4 = _Block_get_invoke_fn((uint64_t)v6);
  uint64_t v5 = 0;
  if (v4) {
    uint64_t v5 = v4;
  }
  uint64_t v3 = 0;
  if (v5) {
    uint64_t v3 = v5;
  }
  dispatch_apply_with_attr_f(a1, a2, (uint64_t)v6, v3);
  _Block_release(v6);
}

uint64_t dispatch_apply_attr_init(uint64_t a1)
{
  uint64_t result = __memset_chk();
  *(_DWORD *)a1 = -1592086528;
  *(void *)(a1 + 16) = ~a1;
  return result;
}

uint64_t dispatch_apply_attr_destroy()
{
  return __memset_chk();
}

BOOL dispatch_apply_attr_set_parallelism(BOOL result, uint64_t a2, unint64_t a3)
{
  if (a2 == -1) {
    return dispatch_apply_attr_set_per_cluster_parallelism(result, a3);
  }
  if (a2 != 1)
  {
    if (a2 != 2)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unknown entity";
      qword_F42C0 = a2;
      __break(1u);
      JUMPOUT(0x5C338);
    }
    return dispatch_apply_attr_set_per_cluster_parallelism(result, a3);
  }
  if (a3 != 1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid threads_per_entity value for CPU entity";
    qword_F42C0 = a3;
    __break(1u);
    JUMPOUT(0x5C2E0);
  }
  return result;
}

BOOL dispatch_apply_attr_set_per_cluster_parallelism(BOOL result, unint64_t a2)
{
  uint64_t v3 = result;
  if (!a2)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: 0 is an invalid threads_per_cluster value";
    qword_F42C0 = 0;
    __break(1u);
    JUMPOUT(0x5C3ACLL);
  }
  if (a2 >= 2)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid threads_per_cluster value, only acceptable value is 1";
    qword_F42C0 = a2;
    __break(1u);
    JUMPOUT(0x5C400);
  }
  if (result)
  {
    uint64_t result = _dispatch_attr_is_initialized(result);
    if (!result)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_F42C0 = v3;
      __break(1u);
      JUMPOUT(0x5C460);
    }
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

unint64_t dispatch_apply_attr_query(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (int i = _dispatch_thread_getspecific(0x17uLL); i; int i = (void *)*i)
  {
    if (i[1] == (void)"apply")
    {
      uint64_t v21 = i;
      goto LABEL_7;
    }
  }
  uint64_t v21 = 0;
LABEL_7:
  if (v21) {
    unint64_t v15 = v21[2];
  }
  else {
    unint64_t v15 = 0;
  }
  uint64_t v22 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  if (v22)
  {
    while (v22[3])
    {
      BOOL v14 = 1;
      if (v22[3] != (uint64_t (**)())&_dispatch_custom_workloop_root_queue) {
        BOOL v14 = v22[3] == (uint64_t (**)())&_dispatch_custom_workloop_overcommit_root_queue;
      }
      if (v14)
      {
        uint64_t v23 = v22;
        goto LABEL_31;
      }
      uint64_t v22 = (uint64_t (***)())v22[3];
    }
  }
  if (!v22) {
    goto LABEL_22;
  }
  BOOL v13 = 0;
  if (v22 >= &_dispatch_root_queues) {
    BOOL v13 = v22 < &qword_F0A80;
  }
  if (v13)
  {
LABEL_22:
    unint64_t v28 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
    unsigned int v3 = __clz(__rbit32(v28));
    if (v28) {
      unsigned int v4 = v3 + 1;
    }
    else {
      unsigned int v4 = 0;
    }
    if (v4) {
      unsigned int v12 = v4;
    }
    else {
      unsigned int v12 = 4;
    }
    if (v12 > 6)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
      qword_F42C0 = v12;
      __break(1u);
      JUMPOUT(0x5C824);
    }
    uint64_t v23 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v12 - 3)];
  }
  else
  {
    uint64_t v23 = v22;
  }
LABEL_31:
  unsigned int v24 = *((_DWORD *)v23 + 21) & 0xF00;
  if (v24 >> 8) {
    unsigned int v11 = v24 >> 8;
  }
  else {
    unsigned int v11 = (*((_DWORD *)v23 + 21) & 0xF000u) >> 12;
  }
  switch(a2)
  {
    case 0:
      return dispatch_apply_attr_query(a1, 1, a3) != 0;
    case 1:
      if (a3)
      {
        if (a1 && !_dispatch_attr_is_initialized(a1))
        {
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
          qword_F42C0 = a1;
          __break(1u);
          JUMPOUT(0x5D754);
        }
        if (a1)
        {
          if (v15)
          {
            return 1;
          }
          else
          {
            int v35 = 0;
            if (v11) {
              int v35 = pthread_qos_max_parallelism();
            }
            if (v35 < 1) {
              unsigned int v36 = MEMORY[0xFFFFFC036];
            }
            else {
              unsigned int v36 = v35;
            }
            if (MEMORY[0xFFFFFC034] < v36) {
              unsigned int v36 = MEMORY[0xFFFFFC034];
            }
            unint64_t v42 = -1;
            if (*(void *)(a1 + 8))
            {
              int v47 = 0;
              int v46 = pthread_qos_max_parallelism();
              if (v46 >= 1) {
                int v47 = v46;
              }
              if (v47) {
                unint64_t v42 = (v47 * *(_DWORD *)(a1 + 8));
              }
              else {
                unint64_t v42 = 0;
              }
            }
            if (v36 >= v42) {
              return v42;
            }
            else {
              return v36;
            }
          }
        }
        else
        {
          int v33 = 0;
          if (v11) {
            int v33 = pthread_qos_max_parallelism();
          }
          if (v33 < 1) {
            unsigned int v34 = MEMORY[0xFFFFFC036];
          }
          else {
            unsigned int v34 = v33;
          }
          if (MEMORY[0xFFFFFC034] < v34) {
            unsigned int v34 = MEMORY[0xFFFFFC034];
          }
          uint64_t v26 = v34;
          if (v15)
          {
            if (v15 >= v34) {
              return 1;
            }
            else {
              return v34 / v15;
            }
          }
        }
        return v26;
      }
      else
      {
        if (a1 && !_dispatch_attr_is_initialized(a1))
        {
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
          qword_F42C0 = a1;
          __break(1u);
          JUMPOUT(0x5E4A4);
        }
        if (a1)
        {
          int v39 = pthread_qos_max_parallelism();
          if (v39 < 1) {
            unsigned int v40 = MEMORY[0xFFFFFC036];
          }
          else {
            unsigned int v40 = v39;
          }
          unint64_t v43 = -1;
          if (*(void *)(a1 + 8))
          {
            int v45 = 0;
            int v44 = pthread_qos_max_parallelism();
            if (v44 >= 1) {
              int v45 = v44;
            }
            if (v45) {
              unint64_t v43 = (v45 * *(_DWORD *)(a1 + 8));
            }
            else {
              unint64_t v43 = 0;
            }
          }
          if (v40 >= v43) {
            return v43;
          }
          else {
            return v40;
          }
        }
        else
        {
          int v37 = pthread_qos_max_parallelism();
          if (v37 < 1) {
            return MEMORY[0xFFFFFC036];
          }
          else {
            return v37;
          }
        }
      }
    case 2:
      if (a1 && !_dispatch_attr_is_initialized(a1))
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
        qword_F42C0 = a1;
        __break(1u);
        JUMPOUT(0x5C9F8);
      }
      if (a1)
      {
        if (v15)
        {
          return 1;
        }
        else
        {
          int v31 = 0;
          if (v11) {
            int v31 = pthread_qos_max_parallelism();
          }
          if (v31 < 1) {
            unsigned int v32 = MEMORY[0xFFFFFC036];
          }
          else {
            unsigned int v32 = v31;
          }
          if (MEMORY[0xFFFFFC034] < v32) {
            unsigned int v32 = MEMORY[0xFFFFFC034];
          }
          unint64_t v41 = -1;
          if (*(void *)(a1 + 8))
          {
            int v49 = 0;
            int v48 = pthread_qos_max_parallelism();
            if (v48 >= 1) {
              int v49 = v48;
            }
            if (v49) {
              unint64_t v41 = (v49 * *(_DWORD *)(a1 + 8));
            }
            else {
              unint64_t v41 = 0;
            }
          }
          if (v32 >= v41) {
            return v41;
          }
          else {
            return v32;
          }
        }
      }
      else
      {
        int v29 = 0;
        if (v11) {
          int v29 = pthread_qos_max_parallelism();
        }
        if (v29 < 1) {
          unsigned int v30 = MEMORY[0xFFFFFC036];
        }
        else {
          unsigned int v30 = v29;
        }
        if (MEMORY[0xFFFFFC034] < v30) {
          unsigned int v30 = MEMORY[0xFFFFFC034];
        }
        uint64_t v27 = v30;
        if (v15)
        {
          if (v15 >= v30) {
            return 1;
          }
          else {
            return v30 / v15;
          }
        }
      }
      return v27;
  }
  return v19;
}

uint64_t _dispatch_apply_set_attr_behavior(uint64_t result)
{
  if (result)
  {
    if (*(void *)(result + 8))
    {
      uint64_t result = __bsdthread_ctl();
      if (result)
      {
        uint64_t result = (uint64_t)__error();
        if (*(_DWORD *)result != 45)
        {
          __break(1u);
          JUMPOUT(0x5F30CLL);
        }
      }
    }
  }
  return result;
}

void *_dispatch_apply_invoke3(void *result)
{
  int v49 = result;
  int v48 = result;
  uint64_t v47 = 0;
  uint64_t v47 = *result;
  unint64_t v46 = 0;
  unint64_t v46 = *(void *)(v47 + 16);
  uint64_t v44 = 0;
  uint64_t v41 = 1;
  uint64_t v40 = 1;
  uint64_t v42 = 1;
  unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
  unint64_t v43 = add_explicit;
  unint64_t v38 = add_explicit;
  unint64_t v45 = add_explicit;
  if (add_explicit < v46)
  {
    int v37 = 0;
    int v37 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v47 + 32);
    uint64_t v36 = 0;
    uint64_t v36 = *(void *)(*(void *)v47 + 40);
    uint64_t v35 = 0;
    uint64_t v35 = *(void *)(*(void *)v47 + 48);
    uint64_t v34 = 0;
    v33[0] = 0;
    v33[1] = "apply";
    uint64_t v34 = *(void *)(v47 + 24);
    uint64_t v50 = v33;
    v33[0] = _dispatch_thread_getspecific(0x17uLL);
    _dispatch_thread_setspecific(23, (uint64_t)v50);
    long long v32 = 0uLL;
    unsigned int v31 = 0;
    if (v48[1])
    {
      uint64_t v52 = *(void *)(*(void *)v47 + 56);
      uint64_t v30 = v52;
      uint64_t v51 = &v32;
      uint64_t v83 = &v32;
      _dispatch_thread_getspecific_packed_pair(20, 21, &v32, v1, v2, v3, v4, v5);
      _dispatch_thread_setspecific_pair(20, v52, 21, (uint64_t)v51, v6, v7, v8, v9);
      int v55 = *(_DWORD *)(v30 + 84);
      unsigned int v54 = 0;
      unsigned int v54 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v53 = v54;
      if (v54)
      {
        if ((v55 & 0xFFF) != 0)
        {
          v53 &= 0x880F0000;
          if ((v54 & 0xFFF) > (v55 & 0xFFFu)) {
            int v27 = v54 & 0xFFF;
          }
          else {
            int v27 = v55 & 0xFFF;
          }
          v53 |= v27;
          unsigned int v59 = v55 & 0xF000;
          unsigned int v57 = v53 & 0xF00;
          if (v59 >> 12 > v57 >> 8) {
            v55 &= 0x4400F000u;
          }
          else {
            v55 &= 0x40000000u;
          }
          v53 |= v55;
        }
        else
        {
          if ((v53 & 0xFFF) != 0) {
            v53 |= 0x40000000u;
          }
          unsigned int v58 = v55 & 0xF000;
          unsigned int v56 = v53 & 0xF00;
          if (v58 >> 12 > v56 >> 8)
          {
            v53 &= 0xFFFF0FFF;
            v53 |= v55 & 0x400F000;
          }
        }
      }
      else
      {
        unsigned int v53 = v55 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v53);
      unsigned int v31 = v54;
    }
    int v29 = *(_DWORD *)(v47 + 40);
    do
    {
      uint64_t v28 = 0;
      if ((v29 & 0x1000000) != 0) {
        uint64_t v28 = _dispatch_autorelease_pool_push();
      }
      if (v35)
      {
        uint64_t v26 = 0;
        if (v37) {
          uint64_t v26 = v37;
        }
        uint64_t v67 = v36;
        unint64_t v66 = v45;
        uint64_t v65 = v26;
        uint64_t v64 = 0;
        uint64_t v25 = 0;
        if (v26) {
          uint64_t v25 = v26;
        }
        uint64_t v64 = v25;
        uint64_t v87 = v67;
        uint64_t v86 = v25;
        int v63 = 0;
        int v62 = 0;
        int v61 = 0;
        int v60 = 0;
        _dispatch_client_callout2(v67, v66, v65);
        uint64_t v91 = v67;
        uint64_t v90 = v64;
      }
      else
      {
        if ((v35 & 2) == 0)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: apply continuation has invalid flags";
          qword_F42C0 = v35;
          __break(1u);
          JUMPOUT(0x5FC00);
        }
        uint64_t v23 = *((unsigned int *)v48 + 4);
        unsigned int v24 = 0;
        if (v37) {
          unsigned int v24 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v37;
        }
        uint64_t v76 = v36;
        unint64_t v75 = v45;
        uint64_t v74 = v23;
        BOOL v73 = v24;
        BOOL v72 = 0;
        uint64_t v22 = 0;
        if (v24) {
          uint64_t v22 = v24;
        }
        BOOL v72 = v22;
        uint64_t v85 = v76;
        unint64_t v84 = v22;
        int v71 = 0;
        int v70 = 0;
        int v69 = 0;
        int v68 = 0;
        _dispatch_client_callout3_a(v76, v75, v74, v73);
        uint64_t v89 = v76;
        unint64_t v88 = v72;
      }
      ++v44;
      unint64_t v45 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 8), 1uLL, memory_order_relaxed);
      if (v28) {
        _dispatch_autorelease_pool_pop(v28);
      }
    }
    while (v45 < v46);
    if (v48[1])
    {
      unsigned int v78 = v31;
      unsigned int v77 = 0;
      unsigned int v77 = _dispatch_thread_getspecific(0x19uLL);
      v78 &= 0xFFF0FFFF;
      v78 |= v77 & 0xF0000;
      _dispatch_thread_setspecific(25, v78);
      uint64_t v79 = &v32;
      _dispatch_thread_setspecific_packed_pair(20, 21, &v32, v10, v11, v12, v13, v14);
    }
    long long v80 = v33;
    BOOL v21 = _dispatch_thread_getspecific(0x17uLL) == v33;
    BOOL v82 = v21;
    uint64_t v81 = 449;
    if (!v21) {
      _dispatch_abort(v81, v82, v15, v16, v17, v18, v19, v20);
    }
    return (void *)_dispatch_thread_setspecific(23, *v80);
  }
  return result;
}

uint64_t _dispatch_apply_clear_attr_behavior(uint64_t result)
{
  if (result)
  {
    if (*(void *)(result + 8))
    {
      uint64_t result = __bsdthread_ctl();
      if (result)
      {
        __break(1u);
        JUMPOUT(0x5FE2CLL);
      }
    }
  }
  return result;
}

BOOL _dispatch_attr_is_initialized(uint64_t a1)
{
  BOOL v2 = 0;
  if (*(_DWORD *)a1 == -1592086528) {
    return ~*(void *)(a1 + 16) == a1;
  }
  return v2;
}

uint64_t _dispatch_apply_da_copy_attr(uint64_t result, uint64_t a2)
{
  uint64_t v4 = result;
  if (a2)
  {
    uint64_t v2 = _dispatch_calloc();
    uint64_t result = dispatch_apply_attr_init(v2);
    *(void *)(v2 + 8) = *(void *)(a2 + 8);
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    *(void *)(v4 + 56) = v2;
  }
  else
  {
    *(void *)(result + 56) = 0;
  }
  return result;
}

void *_dispatch_apply_serial(uint64_t a1)
{
  uint64_t v10 = *(void **)a1;
  unint64_t v9 = *(void *)(a1 + 16);
  unint64_t v8 = 0;
  uint64_t v14 = *(void *)(*(void *)a1 + 56);
  int v13 = 0;
  while (1)
  {
    BOOL v6 = 0;
    if (v14) {
      BOOL v6 = v13 == 0;
    }
    if (!v6) {
      break;
    }
    int v13 = (*(_DWORD *)(v14 + 80) & 0x30000) << 8;
    uint64_t v14 = *(void *)(v14 + 24);
  }
  do
  {
    uint64_t v7 = 0;
    if ((v13 & 0x1000000) != 0) {
      uint64_t v7 = _dispatch_autorelease_pool_push();
    }
    if (v10[6])
    {
      uint64_t v5 = 0;
      if (v10[4]) {
        uint64_t v5 = (uint64_t (*)(uint64_t, uint64_t))v10[4];
      }
      _dispatch_client_callout2(v10[5], v8, v5);
    }
    else
    {
      if ((v10[6] & 2) == 0)
      {
        uint64_t v1 = v10[6];
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: apply continuation has invalid flags";
        qword_F42C0 = v1;
        __break(1u);
        JUMPOUT(0x60580);
      }
      uint64_t v4 = 0;
      if (v10[4]) {
        uint64_t v4 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v10[4];
      }
      _dispatch_client_callout3_a(v10[5], v8, 0, v4);
    }
    if (v7) {
      _dispatch_autorelease_pool_pop(v7);
    }
    ++v8;
  }
  while (v8 < v9);
  if (*(void *)(a1 + 32)) {
    free(*(void **)(a1 + 32));
  }
  if (*(void *)(a1 + 56))
  {
    dispatch_apply_attr_destroy();
    free(*(void **)(a1 + 56));
  }
  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  if (result) {
    int v3 = *((_DWORD *)result + 2) + 1;
  }
  else {
    int v3 = 1;
  }
  if (v3 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 8) = v3;
    uint64_t result = (void *)_dispatch_thread_setspecific(22, a1);
    uint64_t v12 = 0;
  }
  else
  {
    uint64_t v12 = (void *)a1;
  }
  if (v12) {
    return _dispatch_continuation_free_to_cache_limit(v12);
  }
  return result;
}

void _dispatch_apply_redirect(uint64_t a1)
{
  int v27 = *(_DWORD *)(a1 + 44) - 1;
  uint64_t v26 = *(void *)(*(void *)a1 + 56);
  uint64_t v25 = v26;
  do
  {
    if (*(_WORD *)(v25 + 80) == 1)
    {
      int v38 = 0;
    }
    else
    {
      for (uint64_t i = *(void *)(v25 + 56); ; uint64_t i = v2)
      {
        if ((i & 0x20000000000000) != 0) {
          int v41 = 0;
        }
        else {
          int v41 = 4096 - ((i & 0x3FFE0000000000uLL) >> 41);
        }
        int v36 = v41;
        if (!v41)
        {
          int v38 = 0;
          goto LABEL_15;
        }
        if (v41 > v27) {
          int v36 = v27;
        }
        uint64_t v1 = i;
        uint64_t v2 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v25 + 56), (unint64_t *)&v2, i + ((uint64_t)v36 << 41), memory_order_relaxed, memory_order_relaxed);
        if (v2 == v1) {
          break;
        }
      }
      int v38 = v36;
    }
LABEL_15:
    if (v27 > v38)
    {
      int v24 = v27 - v38;
      for (uint64_t j = v26; j != v25; uint64_t j = *(void *)(j + 24))
        atomic_fetch_add_explicit((atomic_ullong *volatile)(j + 56), 0xFFFFFE0000000000 * (v27 - v38), memory_order_relaxed);
      int v27 = v38;
      if (!v38)
      {
        _dispatch_apply_serial(a1);
        return;
      }
      *(_DWORD *)(a1 + 44) -= v24;
    }
    if (!*(_DWORD *)(a1 + 40)) {
      *(_DWORD *)(a1 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = (*(_DWORD *)(v25 + 80) & 0x30000) << 8;
    }
    uint64_t v25 = *(void *)(v25 + 24);
  }
  while (*(void *)(v25 + 24));
  long long v32 = 0;
  unint64_t v31 = 0;
  unint64_t v30 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  signed int v29 = *(_DWORD *)(a1 + 44) - 1;
  if (*(_DWORD *)(a1 + 44) == 1) {
    _dispatch_abort(336, v29, v3, v4, v5, v6, v7, v8);
  }
  for (signed int k = 0; k < v29; ++k)
  {
    uint64_t v35 = _dispatch_thread_getspecific(0x16uLL);
    if (v35)
    {
      _dispatch_thread_setspecific(22, v35[2]);
      uint64_t v34 = v35;
    }
    else
    {
      uint64_t v34 = (void *)_dispatch_continuation_alloc_from_heap();
    }
    *uint64_t v34 = 260;
    v34[4] = _dispatch_apply_redirect_invoke;
    v34[5] = a1;
    uint64_t v44 = _dispatch_thread_getspecific(0x1CuLL);
    if (v44) {
      os_retain(v44);
    }
    v34[3] = v44;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v9, v10, v11, v12, v13, v14, v15, 589);
    if (v34[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    v34[1] = 0;
    v34[1] = v30 | 0x10000000;
    v34[2] = v32;
    long long v32 = v34;
    if (!v31) {
      unint64_t v31 = (unint64_t)v34;
    }
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
  *(void *)(a1 + 32) = _dispatch_calloc();
  if (MEMORY[0xFFFFFC100])
  {
    uint64_t v42 = v32;
    do
    {
      BOOL v23 = 0;
      if (v42 != (void *)v31)
      {
        uint64_t v42 = (void *)v42[2];
        BOOL v23 = v42 != 0;
      }
    }
    while (v23);
  }
  *(void *)(v31 + 16) = 0;
  _dispatch_thread_setspecific(122, v25 + 48);
  unint64_t v43 = atomic_exchange_explicit((atomic_ullong *volatile)(v25 + 48), v31, memory_order_release);
  if (v43) {
    *(void *)(v43 + 16) = v32;
  }
  else {
    *(void *)(v25 + 104) = v32;
  }
  _dispatch_thread_setspecific(122, 0);
  if (!v43) {
    _dispatch_root_queue_poke_and_wakeup(v25, v29, 0, v18, v19, v20, v21, v22);
  }
  _dispatch_apply_invoke_and_wait(a1, v16, v17, v18, v19, v20, v21, v22);
  for (uint64_t m = v26; m != v25; uint64_t m = *(void *)(m + 24))
    atomic_fetch_add_explicit((atomic_ullong *volatile)(m + 56), 0xFFFFFE0000000000 * v27, memory_order_relaxed);
}

void _dispatch_apply_invoke_and_wait(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = a1;
  uint64_t v19 = 2;
  int i = 0;
  int v14 = 1;
  int v13 = 1;
  int v15 = 1;
  unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 52), 1u, memory_order_relaxed);
  unsigned int v16 = add_explicit;
  unsigned int v11 = add_explicit;
  unsigned int v17 = add_explicit;
  BOOL v8 = add_explicit < *(_DWORD *)(a1 + 48);
  BOOL v22 = v8;
  uint64_t v21 = 210;
  if (!v8) {
    _dispatch_abort(v21, v22, a3, a4, a5, a6, a7, a8);
  }
  v10[0] = v20;
  v10[1] = v19;
  v10[2] = v17;
  _dispatch_apply_set_attr_behavior(*(void *)(v20 + 56));
  uint64_t v28 = (dispatch_once_t *)(*(void *)(v20 + 32) + 8 * v17);
  int v27 = v10;
  dispatch_function_t v26 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v28 != -1) {
    dispatch_once_f(v28, v27, v26);
  }
  _dispatch_apply_clear_attr_behavior(*(void *)(v20 + 56));
  if ((v19 & 2) != 0)
  {
    for (int i = 0; i < *(_DWORD *)(v20 + 48); ++i)
    {
      if (i != v17)
      {
        uint64_t v25 = (dispatch_once_t *)(*(void *)(v20 + 32) + 8 * i);
        int v24 = 0;
        BOOL v23 = _dispatch_no_op;
        if (*v25 != -1) {
          dispatch_once_f(v25, v24, (dispatch_function_t)v23);
        }
      }
    }
  }
  if (atomic_fetch_add_explicit((atomic_uint *volatile)(v20 + 44), 0xFFFFFFFF, memory_order_relaxed) == 1)
  {
    uint64_t v29 = v20;
    if (*(void *)(v20 + 32)) {
      free(*(void **)(v29 + 32));
    }
    if (*(void *)(v29 + 56))
    {
      dispatch_apply_attr_destroy();
      free(*(void **)(v29 + 56));
    }
    uint64_t v30 = v29;
    unint64_t v31 = (void *)v29;
    uint64_t v34 = v29;
    int v33 = 0;
    int v33 = _dispatch_thread_getspecific(0x16uLL);
    int v32 = 0;
    if (v33) {
      int v9 = v33[2] + 1;
    }
    else {
      int v9 = 1;
    }
    int v32 = v9;
    if (v9 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v34 + 16) = v33;
      *(_DWORD *)(v34 + 8) = v32;
      _dispatch_thread_setspecific(22, v34);
      uint64_t v35 = 0;
    }
    else
    {
      uint64_t v35 = (void *)v34;
    }
    unint64_t v31 = v35;
    if (v35) {
      _dispatch_continuation_free_to_cache_limit(v31);
    }
  }
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  uint64_t v24 = (*((uint64_t (**)(dispatch_source_type_t, uintptr_t, uintptr_t))type + 4))(type, handle, mask);
  if (!v24) {
    return 0;
  }
  unint64_t v23 = (unint64_t)_dispatch_object_alloc((uint64_t)_OS_dispatch_source_vtable, 0x78uLL, v4, v5, v6, v7, v8, v9);
  uint64_t v22 = 0;
  if (*(void *)v24) {
    uint64_t v22 = *(void *)v24;
  }
  if ((*(unsigned __int8 *)(v22 + 10) >> 1)) {
    int v14 = 0x4000000;
  }
  else {
    int v14 = 0x400000;
  }
  _dispatch_queue_init((uint64_t *)v23, v14, 1, 0x180000000000000, v10, v11, v12, v13);
  *(void *)(v23 + 72) = "source";
  *(void *)(v23 + 88) = v24;
  *(void *)(v24 + 8) = ~v23;
  if (queue)
  {
    if ((*((unsigned char *)queue + 87) & 8) != 0 && (*(unsigned char *)(v24 + 29) & 2) == 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target source to the cooperative root queue - not implemented";
      qword_F42C0 = v23;
      __break(1u);
      JUMPOUT(0x62004);
    }
    _dispatch_retain((uint64_t)queue);
  }
  else
  {
    dispatch_queue_t queue = (dispatch_queue_t)&off_F0680;
  }
  *(void *)(v23 + 24) = queue;
  if ((*(unsigned char *)(v24 + 29) & 2) != 0 && (*(unsigned char *)(v24 + 30) & 0x10) != 0) {
    dispatch_source_set_timer((dispatch_source_t)v23, 0, handle, 0xFFFFFFFFFFFFFFFFLL);
  }
  _dispatch_object_debug((uint64_t *)v23, "%s", v15, v16, v17, v18, v19, v20, (char)"dispatch_source_create");
  return (dispatch_source_t)v23;
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  uint64_t v7 = *((void *)source + 11);
  if ((*(unsigned char *)(v7 + 29) & 2) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Attempt to set timer on a non-timer source";
    qword_F42C0 = (uint64_t)source;
    __break(1u);
    JUMPOUT(0x62130);
  }
  if ((*(unsigned char *)(v7 + 30) & 0x10) != 0) {
    uint64_t v5 = (_DWORD *)_dispatch_interval_config_create(start, interval, leeway, v7);
  }
  else {
    uint64_t v5 = (_DWORD *)_dispatch_timer_config_create(start, interval, leeway, v7);
  }
  if (_dispatch_timer_flags_to_clock(*(unsigned char *)(v7 + 30)) != v5[6] && *(char *)(v7 + 28) == -20)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Attempting to modify timer clock";
    __break(1u);
    JUMPOUT(0x621D8);
  }
  uint64_t v6 = (void *)atomic_exchange_explicit((atomic_ullong *volatile)(v7 + 104), (unint64_t)v5, memory_order_release);
  if (v6) {
    free(v6);
  }
  uint64_t v4 = 0;
  if (*(void *)source) {
    uint64_t v4 = *(void *)source;
  }
  (*(void (**)(dispatch_source_t, void, uint64_t))(v4 + 64))(source, 0, 2);
}

BOOL _dispatch_source_is_timer(uint64_t a1)
{
  return (*(unsigned char *)(*(void *)(a1 + 88) + 29) & 2) != 0;
}

void _dispatch_source_dispose(uint64_t *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_dispose");
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v12 = __swp(0, (unsigned int *)(a1[11] + 56));
  if (v12) {
    _dispatch_source_handler_dispose(v12);
  }
  uint64_t v11 = __swp(0, (unsigned int *)(a1[11] + 40));
  if (v11) {
    _dispatch_source_handler_dispose(v11);
  }
  uint64_t v10 = __swp(0, (unsigned int *)(a1[11] + 48));
  if (v10) {
    _dispatch_source_handler_dispose(v10);
  }
  _dispatch_unote_dispose(a1[11]);
  a1[11] = 0;
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

uint64_t _dispatch_source_xref_dispose(uint64_t *a1)
{
  unsigned int v4 = *((_DWORD *)a1 + 20);
  BOOL v3 = 0;
  if ((v4 & 0x4000000) != 0)
  {
    BOOL v3 = 0;
    if ((v4 & 0x10000000) == 0) {
      BOOL v3 = *(void *)(a1[11] + 48) != 0;
    }
  }
  if (v3)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a source that has not been cancelled, but has a mand"
                           "atory cancel handler";
    qword_F42C0 = v4;
    __break(1u);
    JUMPOUT(0x62D14);
  }
  uint64_t v2 = 0;
  if (*a1) {
    uint64_t v2 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void, uint64_t))(v2 + 64))(a1, 0, 2);
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return (*((_DWORD *)source + 20) & 0x10000000) != 0;
}

uintptr_t dispatch_source_get_mask(dispatch_source_t source)
{
  uint64_t v2 = *((void *)source + 11);
  if ((*((_DWORD *)source + 20) & 0x10000000) != 0) {
    return 0;
  }
  if ((*(unsigned char *)(v2 + 29) & 0x10) != 0) {
    return 0x80000000;
  }
  if ((*(unsigned char *)(v2 + 29) & 2) != 0) {
    return *(unsigned __int8 *)(v2 + 30);
  }
  return *(unsigned int *)(v2 + 32);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  uint64_t v3 = *((void *)source + 11);
  if (*(char *)(v3 + 28) != -20) {
    return *(unsigned int *)(v3 + 24);
  }
  int v2 = _dispatch_timer_flags_to_clock(*(unsigned char *)(v3 + 30));
  if (!v2) {
    return 1;
  }
  if (v2 == 1) {
    return 2;
  }
  if (v2 != 2) {
    return *(unsigned int *)(v3 + 24);
  }
  return 3;
}

uint64_t _dispatch_timer_flags_to_clock(char a1)
{
  return (a1 & 0xC) >> 2;
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  uint64_t v3 = *((void *)source + 11);
  if ((*(unsigned char *)(v3 + 29) & 0x10) != 0) {
    return 0x80000000;
  }
  if ((*(unsigned char *)(v3 + 29) & 4) != 0) {
    return *(void *)(v3 + 64);
  }
  else {
    return *(void *)(v3 + 64);
  }
}

uint64_t dispatch_source_get_extended_data(uint64_t a1, uintptr_t *a2, unint64_t a3)
{
  uint64_t v8 = *(void *)(a1 + 88);
  if (a3 >= 0x10) {
    uint64_t v4 = 16;
  }
  else {
    uint64_t v4 = a3;
  }
  if (a3)
  {
    uintptr_t v6 = 0;
    if ((*(unsigned char *)(v8 + 29) & 4) != 0)
    {
      unint64_t v5 = *(void *)(v8 + 64);
      uintptr_t data = v5;
      uintptr_t v6 = HIDWORD(v5);
    }
    else
    {
      uintptr_t data = dispatch_source_get_data((dispatch_source_t)a1);
    }
    if (a3 >= 8) {
      *a2 = data;
    }
    if (a3 >= 0x10) {
      a2[1] = v6;
    }
    if (a3 > 0x10) {
      __memset_chk();
    }
  }
  return v4;
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
  uint64_t v5 = *((void *)source + 11);
  if ((*((_DWORD *)source + 20) & 0x10800000) == 0)
  {
    int v4 = *(char *)(v5 + 28);
    switch(v4)
    {
      case -23:
        *(void *)(v5 + 72) = value;
        break;
      case -22:
        atomic_fetch_or_explicit((atomic_ullong *volatile)(v5 + 72), value, memory_order_relaxed);
        break;
      case -21:
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 72), value, memory_order_relaxed);
        break;
      default:
        uint64_t v2 = *(char *)(v5 + 28);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid source type";
        qword_F42C0 = v2;
        __break(1u);
        JUMPOUT(0x633DCLL);
    }
    uint64_t v3 = 0;
    if (*(void *)source) {
      uint64_t v3 = *(void *)source;
    }
    (*(void (**)(dispatch_source_t, void, uint64_t))(v3 + 64))(source, 0, 2);
  }
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void _dispatch_source_set_handler(unint64_t a1, const void *a2, uint64_t a3, char a4)
{
  char v39 = a4 & 1;
  uint64_t v52 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v52)
  {
    _dispatch_thread_setspecific(22, v52[2]);
    int v49 = v52;
  }
  else
  {
    int v49 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  if (a2)
  {
    uint64_t v38 = 0;
    if (a3) {
      uint64_t v38 = 4;
    }
    if (v39)
    {
      uint64_t v51 = _dispatch_Block_copy(a2);
      uint64_t v32 = _Block_get_invoke_fn((uint64_t)a2);
      int v33 = 0;
      if (v32) {
        int v33 = (uint64_t (*)())v32;
      }
      if (v33 == _dispatch_block_special_invoke)
      {
        *int v49 = v38 | 0x110;
        v49[5] = (uint64_t)v51;
        _dispatch_continuation_init_slow(v49, a1, 1073741888);
      }
      else
      {
        uint64_t v30 = _Block_get_invoke_fn((uint64_t)a2);
        unint64_t v31 = 0;
        if (v30) {
          unint64_t v31 = (void (*)(void (**)(void)))v30;
        }
        uint64_t v50 = v31;
        if ((v38 & 4) != 0) {
          uint64_t v50 = _dispatch_call_block_and_release;
        }
        *int v49 = v38 | 0x110;
        v49[4] = (uint64_t)v50;
        v49[5] = (uint64_t)v51;
        v49[3] = 0;
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 589);
        if (v49[3] != -1 && MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
        v49[1] = 0;
      }
    }
    else
    {
      uint64_t v29 = *(void *)(a1 + 32);
      *int v49 = v38 | 0x140;
      v49[4] = (uint64_t)a2;
      v49[5] = v29;
      v49[3] = 0;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v18, v19, v20, v21, v22, v23, v24, 589);
      if (v49[3] != -1 && MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      v49[1] = 0;
    }
  }
  else
  {
    *int v49 = 256;
    v49[4] = 0;
  }
  for (uint64_t i = *(void *)(a1 + 56); ; uint64_t i = v26)
  {
    if ((~i & 0x180000000000000) != 0)
    {
      char v44 = 0;
      goto LABEL_35;
    }
    uint64_t v25 = i;
    uint64_t v26 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 56), (unint64_t *)&v26, i + 0x400000000000000, memory_order_relaxed, memory_order_relaxed);
    if (v26 == v25) {
      break;
    }
  }
  LOBYTE(v28) = 1;
  if ((i & 0xFF80000000000000) != 0) {
    int v28 = (HIBYTE(i) >> 1) & 1;
  }
  if (v28)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many calls to dispatch_suspend() prior to calling dispatch_"
                           "set_target_queue() or dispatch_set_*_handler()";
    __break(1u);
    JUMPOUT(0x6426CLL);
  }
  char v44 = 1;
LABEL_35:
  if (v44 == 1)
  {
    unint64_t v45 = (unint64_t)v49;
    if (v49[4])
    {
      if ((*(unsigned char *)v49 & 0x40) != 0) {
        v49[5] = *(void *)(a1 + 32);
      }
    }
    else
    {
      uint64_t v47 = _dispatch_thread_getspecific(0x16uLL);
      if (v47) {
        int v27 = v47[2] + 1;
      }
      else {
        int v27 = 1;
      }
      if (v27 <= _dispatch_continuation_cache_limit)
      {
        v49[2] = (uint64_t)v47;
        *((_DWORD *)v49 + 2) = v27;
        _dispatch_thread_setspecific(22, (uint64_t)v49);
        int v48 = 0;
      }
      else
      {
        int v48 = v49;
      }
      if (v48) {
        _dispatch_continuation_free_to_cache_limit(v48);
      }
      unint64_t v45 = 0;
    }
    uint64_t v46 = atomic_exchange_explicit((atomic_ullong *volatile)(*(void *)(a1 + 88) + 8 * a3 + 40), v45, memory_order_release);
    if (v46) {
      _dispatch_source_handler_dispose(v46);
    }
    _dispatch_lane_resume(a1, 0);
  }
  else
  {
    int v34 = *(_DWORD *)(a1 + 80);
    if ((HIBYTE(v34) >> 2))
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change a handler of this source after it has been activated";
      qword_F42C0 = a3;
      __break(1u);
      JUMPOUT(0x644E0);
    }
    if ((v34 & 0x10000000) == 0)
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      if (a3 == 2)
      {
        _dispatch_bug_deprecated((uint64_t)"Setting registration handler after the source has been activated", v4, v5, v6, v7, v8, v9, v10);
      }
      else if (!a2)
      {
        _dispatch_bug_deprecated((uint64_t)"Clearing handler after the source has been activated", v4, v5, v6, v7, v8, v9, v10);
      }
    }
    v49[6] = a3;
    _dispatch_barrier_trysync_or_async_f(a1, v49, _dispatch_source_set_handler_slow, 0);
  }
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  dispatch_function_t v2 = 0;
  if (handler) {
    dispatch_function_t v2 = handler;
  }
  _dispatch_source_set_handler((unint64_t)source, v2, 0, 0);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_mandatory_cancel_handler(uint64_t a1, void *a2)
{
  for (int i = *(_DWORD *)(a1 + 80); (i & 0xFBBFFFFF | 0x4000000) != i; int i = v3)
  {
    int v2 = i;
    int v3 = i;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), (unsigned int *)&v3, i & 0xFBBFFFFF | 0x4000000, memory_order_relaxed, memory_order_relaxed);
    if (v3 == v2) {
      break;
    }
  }
  dispatch_source_set_cancel_handler((dispatch_source_t)a1, a2);
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  dispatch_function_t v2 = 0;
  if (handler) {
    dispatch_function_t v2 = handler;
  }
  _dispatch_source_set_handler((unint64_t)source, v2, 1, 0);
}

void dispatch_source_set_mandatory_cancel_handler_f(uint64_t a1, void (__cdecl *a2)(void *))
{
  for (int i = *(_DWORD *)(a1 + 80); (i & 0xFBBFFFFF | 0x4000000) != i; int i = v3)
  {
    int v2 = i;
    int v3 = i;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), (unsigned int *)&v3, i & 0xFBBFFFFF | 0x4000000, memory_order_relaxed, memory_order_relaxed);
    if (v3 == v2) {
      break;
    }
  }
  dispatch_source_set_cancel_handler_f((dispatch_source_t)a1, a2);
}

void dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_registration_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  dispatch_function_t v2 = 0;
  if (handler) {
    dispatch_function_t v2 = handler;
  }
  _dispatch_source_set_handler((unint64_t)source, v2, 2, 0);
}

BOOL _dispatch_source_will_reenable_kevent_4NW(uint64_t a1)
{
  int v3 = *(void *)(a1 + 56);
  if (((v3 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_source_will_reenable_kevent_4NW not called from withi"
                           "n the event handler";
    __break(1u);
    JUMPOUT(0x64B38);
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 88) + 16);
  BOOL v2 = 0;
  if (v5)
  {
    BOOL v2 = 0;
    if ((v5 & 1) == 0) {
      return (v5 & 2) == 0;
    }
  }
  return v2;
}

void _dispatch_source_activate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a1;
  uint64_t v23 = 0;
  uint64_t v22 = 0;
  uint64_t v22 = *(void *)(a1 + 88);
  unsigned int v21 = 0;
  uint64_t v20 = 0;
  uint64_t v28 = a1;
  int v27 = 0;
  int v26 = *(_DWORD *)(a1 + 80);
  int v27 = v26;
  int v25 = v26;
  if ((HIBYTE(v26) >> 4))
  {
    *(_WORD *)(v24 + 116) |= 1u;
    _dispatch_source_refs_finalize_unregistration(v24, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    uint64_t v33 = v22;
    uint64_t v32 = 0;
    unint64_t v31 = 0;
    uint64_t v30 = *(uint64_t **)(v22 + 40);
    unint64_t v31 = v30;
    uint64_t v29 = v30;
    uint64_t v23 = v30;
    if (v30)
    {
      uint64_t v38 = v23;
      int v37 = 0;
      unint64_t v66 = v23;
      if ((unint64_t)*v23 > 0xFFF)
      {
        uint64_t v18 = 0;
        if (*v38) {
          uint64_t v18 = *v38;
        }
        if ((*(void *)(v18 + 16) & 0xF0) == 0x10)
        {
          int v36 = 0;
          int v35 = *((_DWORD *)v38 + 20);
          int v36 = v35;
          int v34 = v35;
          int v37 = v35;
          BOOL v39 = (v35 & 0x80000) != 0;
        }
        else
        {
          BOOL v39 = 0;
        }
      }
      else
      {
        BOOL v39 = (*(_DWORD *)v38 & 2) != 0;
      }
      if (v39)
      {
        uint64_t v51 = v24;
        int v50 = 0x80000;
        int v48 = 0x80000;
        int v47 = 0x80000;
        int v49 = 0x80000;
        int v43 = 0x80000;
        int v42 = 0x80000;
        int v44 = 0x80000;
        unsigned int v41 = atomic_fetch_or_explicit((atomic_uint *volatile)(v24 + 80), 0x80000u, memory_order_relaxed);
        unsigned int v45 = v41;
        unsigned int v40 = v41;
        int v46 = v41 | 0x80000;
      }
      if ((*((unsigned char *)v23 + 11) & 0x10) != 0) {
        goto LABEL_17;
      }
      int v52 = *(_DWORD *)(v24 + 84);
      BOOL v17 = 0;
      if ((v52 & 0x20000000) == 0) {
        BOOL v17 = (v52 & 0x44000FFF) != 0;
      }
      if (!v17)
      {
LABEL_17:
        uint64_t v55 = v23[1];
        char v54 = 0;
        BOOL v65 = (v55 & 0x20000000) == 0;
        uint64_t v64 = 458;
        if ((v55 & 0x20000000) != 0) {
          _dispatch_abort(v64, v65, a3, a4, a5, a6, a7, a8);
        }
        int v53 = v55;
        unint64_t v63 = (unint64_t)(v55 & 0x3FFF00) >> 8;
        unsigned int v8 = (v55 & 0x3FFF00) >> 8;
        unsigned int v9 = __clz(__rbit32(v8));
        if (v8) {
          unsigned int v10 = v9 + 1;
        }
        else {
          unsigned int v10 = 0;
        }
        v53 |= v10 << 8;
        *(_DWORD *)(v24 + 84) = v53;
      }
      if ((*(unsigned char *)v23 & 0x40) != 0) {
        v23[5] = *(void *)(v24 + 32);
      }
    }
    else
    {
      _dispatch_bug_deprecated((uint64_t)"dispatch source activated with no event handler set", a2, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_lane_activate(v24);
    if (((*(unsigned char *)(v22 + 29) & 1) != 0 || (*(unsigned char *)(v22 + 29) & 2) != 0) && (*(unsigned char *)(v24 + 116) & 1) == 0)
    {
      unsigned int v21 = _dispatch_queue_compute_priority_and_wlh(v24, (uint64_t *)&v20);
      if (v21)
      {
        unsigned int v56 = v20;
        if (v20 && v56 != (void *)-4)
        {
          uint64_t v16 = 0;
          if (*v56) {
            uint64_t v16 = *v56;
          }
          if (*(unsigned char *)(v16 + 16) == 18) {
            unsigned int v57 = v56;
          }
          else {
            unsigned int v57 = 0;
          }
        }
        else
        {
          unsigned int v57 = 0;
        }
        uint64_t v19 = v57;
        if (v57 && *(char *)(v22 + 28) == -20 && *(_DWORD *)(v22 + 24) <= 5u)
        {
          if (!v57[6]) {
            v19[6] = _dispatch_calloc();
          }
          *(unsigned char *)(v22 + 29) |= 1u;
          uint64_t v59 = (uint64_t)v20;
          if (v20)
          {
            if (v59 != -4)
            {
              uint64_t v58 = v59;
              uint64_t v78 = v59;
              unsigned int v77 = 0;
              int v75 = 1;
              int v74 = 1;
              int v76 = 1;
              unsigned int v72 = 0;
              int v70 = 1;
              int v69 = 1;
              int v71 = 1;
              unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v59 + 96), 1u, memory_order_relaxed);
              unsigned int v72 = add_explicit;
              unsigned int v67 = add_explicit;
              unsigned int v73 = add_explicit + v76;
              unsigned int v77 = add_explicit + v76;
              if ((int)(add_explicit + v76) <= 0)
              {
                qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
                __break(1u);
                JUMPOUT(0x65260);
              }
            }
          }
          uint64_t v62 = v22;
          uint64_t v61 = (uint64_t)v20;
          uint64_t v60 = 0;
          uint64_t v83 = v22;
          uint64_t v82 = (uint64_t)v20;
          uint64_t v81 = (uint64_t)v20;
          uint64_t v80 = (uint64_t)v20;
          *(void *)(v22 + 16) = v20;
          uint64_t v79 = v81;
        }
        _dispatch_source_install(v24, (uint64_t)v20, v21, v11, v12, v13, v14, v15);
      }
    }
  }
}

void _dispatch_source_refs_finalize_unregistration(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (unsigned int i = *(_DWORD *)(a1 + 80); ; unsigned int i = v9)
  {
    if ((i & 0x1FFFFFFF | 0x80000000) == i)
    {
      unsigned int v12 = i;
      goto LABEL_7;
    }
    unsigned int v8 = i;
    unsigned int v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), &v9, i & 0x1FFFFFFF | 0x80000000, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  unsigned int v12 = i;
LABEL_7:
  if ((v12 & 0x80000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Source finalized twice";
    qword_F42C0 = v12;
    __break(1u);
    JUMPOUT(0x65468);
  }
  if ((v12 & 0x20000000) != 0) {
    _dispatch_wake_by_address();
  }
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_refs_finalize_unregistration");
  _dispatch_release_tailcall(a1);
}

void _dispatch_source_install(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v21 = a3;
  uint64_t v20 = *(void *)(a1 + 88);
  if (*(_WORD *)(a1 + 116)) {
    _dispatch_abort(660, (*(_WORD *)(a1 + 116) & 1) == 0, a3, a4, a5, a6, a7, a8);
  }
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFE | 1;
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_install");
  if ((_dispatch_unote_register(v20, a2, v21, v8, v9, v10, v11, v12) ^ 1)) {
    _dispatch_source_refs_finalize_unregistration(a1, v13, v14, v15, v16, v17, v18, v19);
  }
}

void _dispatch_source_invoke(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = a1;
  uint64_t v60 = a2;
  unsigned int v59 = a3;
  int v58 = 8;
  unsigned int v57 = _dispatch_source_invoke2;
  uint64_t v56 = a1;
  v55[8] = 0;
  *(void *)uint64_t v55 = (a3 & 1) == 0;
  uint64_t v54 = 0;
  if ((a3 & 3) == 0)
  {
    *(void *)(v56 + 16) = -1985229329;
    int v53 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v52 = v56;
    int v71 = v53;
    uint64_t v70 = v56;
    int v69 = 0;
    int v68 = 0;
    dispatch_queue_t v138 = v53;
    uint64_t v137 = v56;
  }
  v59 |= v58;
  if ((v59 & 2) != 0)
  {
    uint64_t v54 = 0x40020000000001;
  }
  else
  {
    uint64_t v85 = v56;
    unsigned int v84 = v59;
    uint64_t v83 = 0;
    uint64_t v83 = (uint64_t)(*(unsigned __int16 *)(v56 + 80) - 1) << 41;
    unsigned int v188 = _dispatch_thread_getspecific(3uLL);
    uint64_t v82 = v188 & 0xFFFFFFFC | 0x20000000000000;
    unint64_t v80 = 0;
    unint64_t v79 = 0;
    uint64_t v78 = 0;
    unint64_t v81 = 0xFFE00000FFFFFFFCLL;
    if (v59)
    {
      v81 |= 0x4000000000uLL;
      uint64_t v78 = 0;
    }
    else if ((v84 & 0x40000) != 0)
    {
      uint64_t v78 = 0x4000000000;
    }
    else
    {
      v81 |= 0x4000000000uLL;
      uint64_t v78 = 1;
    }
    BOOL v90 = (v84 & 2) == 0;
    uint64_t v89 = 1323;
    if ((v84 & 2) != 0) {
      _dispatch_abort(v89, v90, v8, v9, v10, v11, v12, v13);
    }
    unsigned int v77 = 0;
    unsigned int v142 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v148 = v142 & 0xF00;
    unsigned int v141 = v148 >> 8;
    unsigned int v151 = v142 & 0xF000;
    unsigned int v140 = v151 >> 12;
    int v154 = v142 & 0xF0000;
    unsigned int v139 = (v142 & 0xF0000) >> 16;
    if (v148 >> 8 <= v151 >> 12) {
      unsigned int v44 = v140;
    }
    else {
      unsigned int v44 = v141;
    }
    if (v44 <= v139)
    {
      unsigned int v42 = v139;
    }
    else
    {
      if (v141 <= v140) {
        unsigned int v43 = v140;
      }
      else {
        unsigned int v43 = v141;
      }
      unsigned int v42 = v43;
    }
    unsigned int v77 = v42;
LABEL_22:
    BOOL v76 = 0;
    int v75 = (atomic_ullong *)(v85 + 56);
    unint64_t v80 = *(void *)(v85 + 56);
    do
    {
      unint64_t v79 = v80;
      if ((v80 & v81) != 0)
      {
        if (!v78) {
          break;
        }
        v79 ^= v78;
      }
      else
      {
        unint64_t v144 = v80;
        unsigned int v143 = v77;
        unint64_t v155 = v80;
        BOOL v41 = 0;
        if ((v80 & 0x1000000000) != 0)
        {
          uint64_t v157 = v144 & 0x700000000;
          BOOL v41 = v143 < (v144 & 0x700000000) >> 32;
        }
        if (v41)
        {
          unint64_t v146 = v80;
          uint64_t v156 = v80 & 0x700000000;
          unsigned int v145 = (v80 & 0x700000000) >> 32;
          unsigned int v160 = _dispatch_thread_getspecific(3uLL);
          unsigned int v159 = v145;
          if (_dispatch_set_qos_class_enabled)
          {
            unsigned int v162 = v159;
            uint64_t v161 = 0;
            if (v159) {
              uint64_t v161 = 1 << (v162 + 7);
            }
            _pthread_workqueue_override_start_direct();
          }
          unsigned int v164 = v145;
          unsigned int v163 = _dispatch_thread_getspecific(0x19uLL);
          int v165 = v163 & 0xF0000;
          if (v145 > (v163 & 0xF0000) >> 16)
          {
            unsigned int v163 = v163 & 0xFFF0FFFF | (v164 << 16);
            _dispatch_thread_setspecific(25, v163);
          }
          unsigned int v77 = v145;
          goto LABEL_22;
        }
        unint64_t v79 = v79 & 0x7700000001 | v82;
        unint64_t v147 = v80;
        if ((v80 & 0x10000000000) != 0 || v80 + v83 < 0x20000000000000) {
          v79 |= 0x40000000000000uLL;
        }
      }
      unint64_t v74 = v79;
      unint64_t v16 = v80;
      unint64_t v17 = v80;
      atomic_compare_exchange_strong_explicit(v75, &v17, v79, memory_order_acquire, memory_order_acquire);
      if (v17 != v16) {
        unint64_t v80 = v17;
      }
      BOOL v73 = v17 == v16;
      BOOL v76 = v17 == v16;
    }
    while (v17 != v16);
    BOOL v72 = v76;
    BOOL v88 = (v80 & v78) == v78;
    uint64_t v87 = 1356;
    if ((v80 & v78) != v78) {
      _dispatch_abort(v87, v88, v14, v15, a5, a6, a7, a8);
    }
    if ((v80 & v81) != 0)
    {
      uint64_t v86 = 0;
    }
    else
    {
      v79 &= v78 | 0x60000000000000;
      v80 &= 0x3FFE0000000000uLL;
      uint64_t v86 = v79 - v80;
    }
    uint64_t v54 = v86;
  }
  if (v54)
  {
    unsigned int v51 = 0;
    if ((v59 & 0x40000) != 0)
    {
      unsigned int v51 = 0;
    }
    else
    {
      int v93 = *(_DWORD *)(v56 + 84);
      unsigned int v92 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v91 = v92;
      if (v92)
      {
        if ((v93 & 0xFFF) != 0)
        {
          v91 &= 0x880F0000;
          if ((v92 & 0xFFF) <= (v93 & 0xFFFu)) {
            int v40 = v93 & 0xFFF;
          }
          else {
            int v40 = v92 & 0xFFF;
          }
          v91 |= v40;
          unsigned int v152 = v93 & 0xF000;
          unsigned int v149 = v91 & 0xF00;
          if (v152 >> 12 <= v149 >> 8) {
            v93 &= 0x40000000u;
          }
          else {
            v93 &= 0x4400F000u;
          }
          v91 |= v93;
        }
        else
        {
          if ((v91 & 0xFFF) != 0) {
            v91 |= 0x40000000u;
          }
          unsigned int v153 = v93 & 0xF000;
          unsigned int v150 = v91 & 0xF00;
          if (v153 >> 12 > v150 >> 8) {
            unsigned int v91 = v91 & 0xFFFF0FFF | v93 & 0x400F000;
          }
        }
      }
      else
      {
        unsigned int v91 = v93 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v91);
      unsigned int v51 = v92;
    }
    if ((v59 & 0x100000) != 0)
    {
      uint64_t v65 = v61;
      int v64 = 0;
      int v63 = *(_DWORD *)(v61 + 80);
      int v64 = v63;
      int v62 = v63;
      if ((v63 & 0x400000) != 0)
      {
        uint64_t v105 = v61;
        int v104 = 0x400000;
        int v102 = -4194305;
        int v101 = -4194305;
        int v103 = -4194305;
        int v97 = -4194305;
        int v96 = -4194305;
        int v98 = -4194305;
        unsigned int v95 = atomic_fetch_and_explicit((atomic_uint *volatile)(v61 + 80), 0xFFBFFFFF, memory_order_relaxed);
        unsigned int v99 = v95;
        unsigned int v94 = v95;
        unsigned int v100 = v95 & 0xFFBFFFFF;
      }
    }
    uint64_t v50 = v56;
    uint64_t v108 = v56;
    unsigned int v107 = v59;
    int v106 = 0;
    uint64_t v170 = v56;
    uint64_t v169 = 256;
    uint64_t v176 = 1;
    uint64_t v175 = 730;
    int v168 = 0;
    uint64_t v174 = v56;
    int v173 = 0;
    int v172 = *(_DWORD *)(v56 + 80);
    int v173 = v172;
    int v171 = v172;
    int v168 = v172 & 0x30000;
    int v106 = (v172 & 0x30000) << 8;
    if (v106) {
      unsigned int v107 = v107 & 0xFCFFFFFF | v106;
    }
    unsigned int v59 = v107;
    do
    {
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v60);
      }
      uint64_t v49 = v56;
      *(void *)&v55[1] = v57(v56, v60, v59, &v54);
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
      {
        long long v48 = 0uLL;
        uint64_t v110 = v56;
        uint64_t v109 = &v48;
        int v177 = &v48;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v48, v19, a5, a6, a7, a8);
        _dispatch_thread_setspecific_pair(20, v110, 21, (uint64_t)v109, v20, v21, v22, v23);
        _dispatch_last_resort_autorelease_pool_pop(v60);
        unsigned int v111 = &v48;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v48, v24, v25, v26, v27, v28);
      }
      BOOL v67 = *(void *)&v55[1] != 1;
      uint64_t v66 = 2018;
      if (*(void *)&v55[1] == 1) {
        _dispatch_abort(v66, v67, v18, v19, a5, a6, a7, a8);
      }
      BOOL v39 = 0;
      if (*(void *)&v55[1]) {
        BOOL v39 = *(void *)&v55[1] != -1;
      }
      if (v39) {
        break;
      }
      uint64_t v131 = v56;
      uint64_t v130 = v54;
      BOOL v129 = *(void *)&v55[1] == 0;
      uint64_t v128 = 0;
      unint64_t v127 = 0;
      BOOL v126 = 0;
      int v125 = (atomic_ullong *)(v56 + 56);
      uint64_t v128 = *(void *)(v56 + 56);
      do
      {
        unint64_t v127 = (v128 - v130) & 0xFFFFFFF700000001;
        uint64_t v133 = v128;
        if ((v128 & 0xFF80000000000000) == 0)
        {
          uint64_t v178 = v128;
          if ((v128 & 0x8000000000) != 0)
          {
            uint64_t v123 = 0x8000000000;
            uint64_t v122 = 0x8000000000;
            uint64_t v124 = 0x8000000000;
            unint64_t v120 = 0;
            uint64_t v118 = 0x8000000000;
            uint64_t v117 = 0x8000000000;
            uint64_t v119 = 0x8000000000;
            xor_unint64_t explicit = atomic_fetch_xor_explicit((atomic_ullong *volatile)(v131 + 56), 0x8000000000uLL, memory_order_acquire);
            unint64_t v120 = xor_explicit;
            unint64_t v115 = xor_explicit;
            unint64_t v121 = xor_explicit ^ v124;
            char v132 = 0;
            goto LABEL_101;
          }
          if (v129) {
            v127 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v127 |= 0x8000000000uLL;
          }
        }
        unint64_t v114 = v127;
        uint64_t v29 = v128;
        uint64_t v30 = v128;
        atomic_compare_exchange_strong_explicit(v125, (unint64_t *)&v30, v127, memory_order_release, memory_order_relaxed);
        if (v30 != v29) {
          uint64_t v128 = v30;
        }
        BOOL v113 = v30 == v29;
        BOOL v126 = v30 == v29;
      }
      while (v30 != v29);
      BOOL v112 = v126;
      uint64_t v179 = v128;
      uint64_t v180 = v128;
      BOOL v38 = 0;
      if ((v128 & 0x1000000000) != 0) {
        BOOL v38 = (v179 & 0x800000000) != 0;
      }
      if (v38)
      {
        uint64_t v158 = v128 & 0x700000000;
        uint64_t v166 = v128 & 0x700000000;
        LODWORD(v166) = _dispatch_thread_getspecific(0x19uLL);
        int v167 = v166 & 0xF0000;
        if (HIDWORD(v166) > (v166 & 0xF0000) >> 16)
        {
          LODWORD(v166) = v166 & 0xFFF0FFFF;
          LODWORD(v166) = v166 | (HIDWORD(v166) << 16);
          _dispatch_thread_setspecific(25, v166);
        }
      }
      char v132 = 1;
LABEL_101:
      if (v132)
      {
        uint64_t v54 = 0;
        *(void *)&v55[1] = 0;
        break;
      }
      *(void *)&v55[1] = _dispatch_thread_getspecific(0x14uLL);
      uint64_t v37 = 0;
      if (**(void **)&v55[1]) {
        uint64_t v37 = **(void **)&v55[1];
      }
    }
    while ((*(void *)(v37 + 16) & 0x10000) != 0 || (v55[0] & 1) == 0);
    if ((v59 & 0x40000) == 0)
    {
      unsigned int v135 = v51;
      unsigned int v134 = 0;
      unsigned int v134 = _dispatch_thread_getspecific(0x19uLL);
      v135 &= 0xFFF0FFFF;
      v135 |= v134 & 0xF0000;
      _dispatch_thread_setspecific(25, v135);
    }
  }
  if (v55[0])
  {
    uint64_t v136 = v56;
    uint64_t v181 = v56;
    int v186 = 772079660;
    uint64_t v185 = v56;
    uint64_t v184 = 0;
    uint64_t v183 = 0;
    uint64_t v182 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v187 = v136;
  }
  if (*(void *)&v55[1]) {
    _dispatch_queue_invoke_finish(v56, v60, *(uint64_t (****)())&v55[1], v54, a5, a6, a7, a8);
  }
  else {
    _dispatch_release_2_tailcall(v56);
  }
  if ((a3 & 0x100000) != 0)
  {
    int v46 = _dispatch_thread_getspecific(0x1BuLL);
    uint64_t v45 = v46[6];
    if (v45)
    {
      if (*(unsigned char *)(v45 + 6)) {
        _dispatch_event_loop_drain_timers(v46[6], 6u, v31, v32, v33, v34, v35, v36);
      }
    }
  }
}

uint64_t _dispatch_source_invoke2(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  uint64_t v32 = 0;
  uint64_t v31 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  uint64_t v30 = *(void *)(a1 + 88);
  BOOL v24 = 0;
  if ((a3 & 0x40000) == 0)
  {
    unsigned int v44 = _dispatch_thread_getspecific(0x1DuLL);
    if (v44) {
      uint64_t v45 = v44[3];
    }
    else {
      uint64_t v45 = -4;
    }
    unint64_t v42 = *(void *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL;
    BOOL v23 = 0;
    if (v42)
    {
      BOOL v23 = 0;
      if (v42 != -4) {
        BOOL v23 = v42 != v45;
      }
    }
    BOOL v24 = v23;
  }
  if (v24) {
    _dispatch_source_handle_wlh_change(a1, v4, v5, v6, v7, v8, v9, v10);
  }
  if (*(void *)(a1 + 48))
  {
    int v35 = a3 | 0x4000000;
    uint64_t v32 = _dispatch_lane_serial_drain((uint64_t *)a1, a2, v35, a4, v7, v8, v9, v10);
    a3 = v35 & 0xFBFFFFFF;
  }
  uint64_t v28 = &_dispatch_mgr_q;
  BOOL v27 = 0;
  if (*(unsigned char *)(v30 + 29)) {
    uint64_t v28 = *(uint64_t (****)())(a1 + 24);
  }
  if ((*(_WORD *)(a1 + 116) & 1) == 0)
  {
    if (v31 != v28) {
      return (uint64_t)v28;
    }
    unsigned int v26 = 0x2000000;
    if ((a3 & 0x10000) != 0) {
      unsigned int v26 = _dispatch_thread_getspecific(0x19uLL);
    }
    unsigned int v43 = _dispatch_thread_getspecific(0x1DuLL);
    if (v43) {
      _dispatch_source_install(a1, v43[3], v26, v11, v12, v13, v14, v15);
    }
    else {
      _dispatch_source_install(a1, -4, v26, v11, v12, v13, v14, v15);
    }
  }
  if ((*(void *)(a1 + 56) & 0xFF80000000000000) != 0) {
    return *(void *)(a1 + 24);
  }
  BOOL v22 = 0;
  if ((*(unsigned char *)(v30 + 29) & 2) != 0) {
    BOOL v22 = *(void *)(v30 + 104) != 0;
  }
  if (v22 && (*(_DWORD *)(a1 + 80) & 0x10800000) == 0)
  {
    if (v31 != v28) {
      return (uint64_t)v28;
    }
    _dispatch_timer_unote_configure(*(void *)(a1 + 88));
  }
  if (*(void *)(v30 + 56))
  {
    if (v31 != *(uint64_t (****)())(a1 + 24)) {
      return *(void *)(a1 + 24);
    }
    _dispatch_source_registration_callout(a1, (uint64_t)v31, a3);
  }
  if ((*(void *)(v30 + 16) & 2) != 0) {
    _dispatch_source_refs_unregister(a1, 5u, v5, v6, v7, v8, v9, v10);
  }
  int v29 = *(_DWORD *)(a1 + 80);
  if ((v29 & 0x10800000) == 0 && *(void *)(v30 + 72))
  {
    if (v31 != *(uint64_t (****)())(a1 + 24)) {
      return *(void *)(a1 + 24);
    }
    _dispatch_source_latch_and_call(a1, (uint64_t)v31, a3, v6, v7, v8, v9, v10);
    int v29 = *(_DWORD *)(a1 + 80);
    if ((v29 & 0x90000000) == 0)
    {
      BOOL v21 = 1;
      if (!v31[3]) {
        BOOL v21 = *((_DWORD *)v31 + 21) >= 0;
      }
      BOOL v27 = v21;
    }
    *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFD | 2;
  }
  if ((v29 & 0x10800000) == 0 || v29 < 0) {
    goto LABEL_61;
  }
  if ((*(unsigned char *)(v30 + 29) & 2) == 0 || (*(void *)(v30 + 16)) && v31 != v28) {
    return (uint64_t)v28;
  }
  unsigned int v25 = 1;
  if ((v29 & 0x40000000) == 0) {
    unsigned int v25 = 3;
  }
  _dispatch_source_refs_unregister(a1, v25, v5, v6, v7, v8, v9, v10);
  int v29 = *(_DWORD *)(a1 + 80);
  if (v29 < 0)
  {
LABEL_61:
    if ((v29 & 0x10800000) != 0 && v29 < 0)
    {
      if (v31 != *(uint64_t (****)())(a1 + 24)
        && (*(void *)(v30 + 40) || *(void *)(v30 + 48) || *(void *)(v30 + 56)))
      {
        uint64_t v32 = *(void *)(a1 + 24);
      }
      else
      {
        _dispatch_source_cancel_callout(a1, (uint64_t)v31, a3);
        int v29 = *(_DWORD *)(a1 + 80);
      }
      BOOL v27 = 0;
    }
    if ((v29 & 0x10800000) == 0)
    {
      if ((*(unsigned char *)(v30 + 29) & 2) != 0)
      {
        if (*(void *)(v30 + 104))
        {
          BOOL v39 = 1;
        }
        else
        {
          uint64_t v40 = *(void *)(v30 + 16);
          BOOL v18 = 0;
          if (v40)
          {
            BOOL v18 = 0;
            if ((v40 & 1) == 0) {
              BOOL v18 = (v40 & 2) == 0;
            }
          }
          BOOL v39 = v18 && *(void *)(v30 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
        }
      }
      else
      {
        uint64_t v41 = *(void *)(v30 + 16);
        BOOL v19 = 0;
        if (v41)
        {
          BOOL v19 = 0;
          if ((v41 & 1) == 0) {
            BOOL v19 = (v41 & 2) == 0;
          }
        }
        BOOL v39 = v19;
      }
      if (v39)
      {
        if (v31 != v28) {
          return (uint64_t)v28;
        }
        if ((*(void *)(a1 + 56) & 0xFF80000000000000) != 0) {
          return *(void *)(a1 + 24);
        }
        if ((*(unsigned char *)(v30 + 29) & 1) != 0 && (*(void *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL) == 0xFFFFFFFFFFFFFFFCLL)
        {
          if ((*(_WORD *)(a1 + 116) >> 1))
          {
            *(_WORD *)(a1 + 116) &= ~2u;
            _dispatch_unote_resume(v30, v4, v5, v6, v7, v8, v9, v10);
          }
          if (v27) {
            return *(void *)(a1 + 24);
          }
        }
        else
        {
          _dispatch_unote_resume(v30, v4, v5, v6, v7, v8, v9, v10);
          if (!v27)
          {
            int v46 = _dispatch_thread_getspecific(0x1DuLL);
            BOOL v17 = 0;
            if (_dispatch_thread_getspecific(5uLL))
            {
              BOOL v17 = 0;
              if (v46)
              {
                BOOL v17 = 0;
                if (v46[3] != -4) {
                  BOOL v17 = (*(void *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL) == v46[3];
                }
              }
            }
            if (v17) {
              _dispatch_event_loop_drain(1u);
            }
          }
        }
      }
    }
    return v32;
  }
  if (v32) {
    return v32;
  }
  else {
    return -1;
  }
}

void _dispatch_source_wakeup(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(a1 + 88);
  uint64_t v12 = &_dispatch_mgr_q;
  *(_DWORD *)&v11[8] = 0;
  *(void *)uint64_t v11 = *(unsigned int *)(a1 + 80);
  if (*(unsigned char *)(v13 + 29)) {
    uint64_t v12 = (uint64_t (***)())(&def_131C + 1);
  }
  if (*(_WORD *)(a1 + 116))
  {
    if ((*(_DWORD *)v11 & 0x10800000) != 0) {
      goto LABEL_55;
    }
    BOOL v10 = 0;
    if ((*(unsigned char *)(v13 + 29) & 2) != 0) {
      BOOL v10 = *(void *)(v13 + 104) != 0;
    }
    if (!v10)
    {
LABEL_55:
      if (*(void *)(v13 + 56))
      {
        *(void *)&v11[4] = 1;
      }
      else if ((*(void *)(v13 + 16) & 2) != 0)
      {
        *(void *)&v11[4] = 1;
      }
      else if ((*(_DWORD *)v11 & 0x10800000) != 0 || !*(void *)(v13 + 72))
      {
        if ((*(_DWORD *)v11 & 0x10800000) != 0 && *(int *)v11 >= 0)
        {
          if (*(unsigned char *)(v13 + 29) & 2) == 0 || (*(void *)(v13 + 16))
          {
            if ((*(_DWORD *)v11 & 0x40000000) == 0 || (a3 & 0x10) != 0) {
              *(void *)&v11[4] = v12;
            }
          }
          else
          {
            *(void *)&v11[4] = 1;
          }
        }
        else if ((*(_DWORD *)v11 & 0x10800000) != 0 {
               && *(int *)v11 < 0
        }
               && (*(void *)(v13 + 40) || *(void *)(v13 + 48) || *(void *)(v13 + 56)))
        {
          *(void *)&v11[4] = 1;
        }
        else if ((*(_DWORD *)v11 & 0x10800000) == 0)
        {
          if ((*(unsigned char *)(v13 + 29) & 2) != 0)
          {
            if (*(void *)(v13 + 104))
            {
              BOOL v14 = 1;
            }
            else
            {
              uint64_t v15 = *(void *)(v13 + 16);
              BOOL v8 = 0;
              if (v15)
              {
                BOOL v8 = 0;
                if ((v15 & 1) == 0) {
                  BOOL v8 = (v15 & 2) == 0;
                }
              }
              BOOL v14 = v8 && *(void *)(v13 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
            }
          }
          else
          {
            uint64_t v16 = *(void *)(v13 + 16);
            BOOL v9 = 0;
            if (v16)
            {
              BOOL v9 = 0;
              if ((v16 & 1) == 0) {
                BOOL v9 = (v16 & 2) == 0;
              }
            }
            BOOL v14 = v9;
          }
          if (v14) {
            *(void *)&v11[4] = v12;
          }
        }
      }
      else
      {
        *(void *)&v11[4] = 1;
      }
    }
    else
    {
      *(void *)&v11[4] = v12;
    }
  }
  else
  {
    *(void *)&v11[4] = v12;
  }
  if (!*(void *)&v11[4]) {
    *(void *)&v11[4] = *(void *)(a1 + 48) != 0;
  }
  if (*(void *)&v11[4] == 1 && *(uint64_t (****)())(a1 + 24) == &_dispatch_mgr_q) {
    *(void *)&v11[4] = &_dispatch_mgr_q;
  }
  _dispatch_queue_wakeup(a1, a2, a3, *(uint64_t *)&v11[4], a5, a6, a7, a8);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  _dispatch_object_debug((uint64_t *)source, "%s", v1, v2, v3, v4, v5, v6, (char)"dispatch_source_cancel");
  _dispatch_retain_2((uint64_t)source);
  if ((atomic_fetch_or_explicit((atomic_uint *volatile)((char *)source + 80), 0x10000000u, memory_order_relaxed) & 0x10000000) != 0)
  {
    _dispatch_release_2_tailcall((uint64_t)source);
  }
  else
  {
    uint64_t v7 = 0;
    if (*(void *)source) {
      uint64_t v7 = *(void *)source;
    }
    (*(void (**)(dispatch_source_t, void, uint64_t))(v7 + 64))(source, 0, 3);
  }
}

void dispatch_source_cancel_and_wait(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v35 = *(void *)(a1 + 88);
  if (*(void *)(v35 + 48))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Source has a cancel handler";
    qword_F42C0 = a1;
    __break(1u);
    JUMPOUT(0x684E4);
  }
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_source_cancel_and_wait");
  for (int i = *(_DWORD *)(a1 + 80); ; int i = v9)
  {
    unsigned int v36 = i | 0x10000000;
    if ((i & 0x20000000) != 0) {
      break;
    }
    if ((i & 0x80000000) == 0
      && ((i & 0x40000000) != 0 || (*(unsigned char *)(v35 + 29) & 2) != 0 || (*(unsigned char *)(v35 + 29) & 1) == 0))
    {
      unsigned int v36 = i | 0x30000000;
    }
    int v8 = i;
    int v9 = i;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), (unsigned int *)&v9, v36, memory_order_relaxed, memory_order_relaxed);
    if (v9 == v8) {
      break;
    }
  }
  if ((i & 0x800000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Dispatch source used after last release";
    qword_F42C0 = a1;
    __break(1u);
    JUMPOUT(0x6866CLL);
  }
  if ((i & 0x80000000) == 0)
  {
    if ((v36 & 0x20000000) == 0)
    {
      unint64_t v34 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000000;
      for (unint64_t j = *(void *)(a1 + 56); ; unint64_t j = v17)
      {
        BOOL v29 = 0;
        if (!(j >> 53)) {
          BOOL v29 = (j & 0xFFFFFFFC) == 0;
        }
        if (v29)
        {
          unint64_t v32 = j & 0x7700000001 | v34;
        }
        else
        {
          if ((i & 0x10000000) != 0) {
            break;
          }
          unint64_t v32 = j | 0x8000000000;
        }
        unint64_t v16 = j;
        unint64_t v17 = j;
        atomic_compare_exchange_strong((atomic_ullong *volatile)(a1 + 56), &v17, v32);
        if (v17 == v16) {
          break;
        }
      }
      if ((j & 0xFF80000000000000) != 0)
      {
        if (j >> 58)
        {
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Source is suspended";
          qword_F42C0 = a1;
          __break(1u);
          JUMPOUT(0x68880);
        }
        dispatch_activate((dispatch_object_t)a1);
        return;
      }
      BOOL v28 = 0;
      if (!(j >> 53)) {
        BOOL v28 = (j & 0xFFFFFFFC) == 0;
      }
      if (v28)
      {
        if (!(HIBYTE(*(_DWORD *)(a1 + 80)) >> 7)) {
          _dispatch_source_refs_unregister(a1, 3u, v10, v11, v12, v13, v14, v15);
        }
        if (HIBYTE(*(_DWORD *)(a1 + 80)) >> 7) {
          _dispatch_source_cancel_callout(a1, 0, 0);
        }
        uint64_t v27 = 0;
        if (*(void *)a1) {
          uint64_t v27 = *(void *)a1;
        }
        (*(void (**)(uint64_t, void, uint64_t))(v27 + 64))(a1, 0, 20);
LABEL_47:
        unsigned int v31 = *(_DWORD *)(a1 + 80);
        while (1)
        {
          while (1)
          {
            if (HIBYTE(v31) >> 7) {
              return;
            }
            if (((HIBYTE(v31) >> 5) & 1) == 0) {
              break;
            }
LABEL_54:
            _dispatch_wait_on_address(a1 + 80, v31, -1, 0, v18, v19, v20, v21);
            unsigned int v31 = *(_DWORD *)(a1 + 80);
          }
          unsigned int v30 = v31;
          unsigned int v24 = v31;
          unsigned int v25 = v31;
          atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), &v25, v31 | 0x20000000, memory_order_relaxed, memory_order_relaxed);
          if (v25 != v24) {
            unsigned int v30 = v25;
          }
          unsigned int v31 = v30;
          if (v25 == v24)
          {
            unsigned int v31 = v30 | 0x20000000;
            goto LABEL_54;
          }
        }
      }
      if (((j ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_source_cancel_and_wait called from a source handler";
        qword_F42C0 = a1;
        __break(1u);
        JUMPOUT(0x68A8CLL);
      }
    }
    unint64_t v39 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
    unsigned int v22 = __clz(__rbit32(v39));
    if (v39) {
      unsigned int v23 = v22 + 1;
    }
    else {
      unsigned int v23 = 0;
    }
    uint64_t v26 = 0;
    if (*(void *)a1) {
      uint64_t v26 = *(void *)a1;
    }
    (*(void (**)(uint64_t, void, uint64_t))(v26 + 64))(a1, v23, 2);
    dispatch_activate((dispatch_object_t)a1);
    goto LABEL_47;
  }
}

void _dispatch_source_refs_unregister(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_refs_unregister");
  if (_dispatch_unote_unregister(*(void *)(a1 + 88), a2, v8, v9, v10, v11, v12, v13))
  {
    _dispatch_source_refs_finalize_unregistration(a1, v14, v15, v16, v17, v18, v19, v20);
  }
  else
  {
    for (int i = *(_DWORD *)(a1 + 80); (i & 0xC0000000) == 0; int i = v22)
    {
      int v21 = i;
      int v22 = i;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), (unsigned int *)&v22, i | 0x40000000, memory_order_relaxed, memory_order_relaxed);
      if (v22 == v21) {
        break;
      }
    }
  }
}

void _dispatch_source_cancel_callout(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v3 = 0;
  if ((a3 & 0x1000000) != 0) {
    uint64_t v3 = _dispatch_autorelease_pool_push();
  }
  uint64_t v4 = __swp(0, (unsigned int *)(v5 + 48));
  *(void *)(v5 + 72) = 0;
  *(void *)(v5 + 64) = 0;
  uint64_t v10 = __swp(0, (unsigned int *)(v5 + 40));
  if (v10) {
    _dispatch_source_handler_dispose(v10);
  }
  uint64_t v9 = __swp(0, (unsigned int *)(v5 + 56));
  if (v9) {
    _dispatch_source_handler_dispose(v9);
  }
  if (v4)
  {
    if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
    {
      if ((*(void *)v4 & 0x40) != 0) {
        *(void *)(v4 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(a1 + 32);
      }
      _dispatch_continuation_pop((void *)v4, 0, a3 & 0xFEFFFFFF, a2);
    }
    else
    {
      _dispatch_source_handler_dispose(v4);
    }
  }
  if (v3) {
    _dispatch_autorelease_pool_pop(v3);
  }
}

uint64_t _dispatch_source_merge_evt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v28 = BYTE1(a2);
  int v27 = a4;
  uint64_t v26 = ~*(void *)(a1 + 8);
  if ((a2 & 0x100) == 0 && !*(void *)(a1 + 16) && (*(unsigned char *)(a1 + 29) & 2) == 0) {
    _dispatch_source_refs_finalize_unregistration(v26, a2, a3, a4, a5, a6, a7, a8);
  }
  if ((v28 >> 1))
  {
    if ((*(_DWORD *)(v26 + 80) & 0x4000000) != 0)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 24);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports or f"
                             "ile descriptors)";
      qword_F42C0 = v8;
      __break(1u);
      JUMPOUT(0x69288);
    }
    _dispatch_bug_kevent_vanished(a1, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 72) = 0;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkevent-source[%p]: merged kevent[%p]", v9, v10, v11, v12, v13, v14, v15, 1201);
  _dispatch_object_debug((uint64_t *)v26, "%s", v16, v17, v18, v19, v20, v21, (char)"_dispatch_source_merge_evt");
  uint64_t v25 = 0;
  if (*(void *)v26) {
    uint64_t v25 = *(void *)v26;
  }
  unint64_t v30 = (unint64_t)(v27 & 0x3FFF00) >> 8;
  unsigned int v22 = __clz(__rbit32(v30));
  if (v30) {
    uint64_t v23 = v22 + 1;
  }
  else {
    uint64_t v23 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v25 + 64))(v26, v23, 51);
}

uint64_t _dispatch_interval_config_create(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v9 = (*(unsigned char *)(a4 + 30) & 0x20) != 0;
  uint64_t v8 = _dispatch_calloc();
  *(_DWORD *)(v8 + 24) = 0;
  if (a1 == -1)
  {
    *(void *)uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    *(void *)(v8 + 16) = 0x7FFFFFFFFFFFFFFFLL;
    *(void *)(v8 + 8) = 0x7FFFFFFFFFFFFFFFLL;
    return v8;
  }
  else
  {
    if (a1)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Start value is not DISPATCH_TIME_NOW or DISPATCH_TIME_FOREVER";
      __break(1u);
      JUMPOUT(0x694B8);
    }
    if (!a2)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Setting interval to 0";
      __break(1u);
      JUMPOUT(0x694F0);
    }
    unint64_t v4 = 1892160075;
    if (!v9) {
      unint64_t v4 = 31536000000;
    }
    if (a2 > v4)
    {
      unint64_t v13 = 31536000000000000;
    }
    else
    {
      uint64_t v5 = 1000000;
      if (v9) {
        uint64_t v5 = 16666666;
      }
      unint64_t v13 = a2 * v5;
    }
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v18 = _dispatch_host_time_nano2mach(v13);
    }
    else if (v13)
    {
      if (v13 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v13 >= 0x5555555555555555)
        {
          unint64_t v18 = 3 * (v13 / 0x7D);
        }
        else
        {
          uint64_t v6 = (3 * v13 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
          unint64_t v18 = (v6 + ((3 * v13 - v6) >> 1)) >> 6;
        }
      }
      else
      {
        unint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v18 = 0;
    }
    uint64_t v15 = (_dispatch_uptime() + v18) / v18 * v18;
    if (a3 > 0x3E8)
    {
      if (a3 != -1)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Passing an invalid leeway";
        __break(1u);
        JUMPOUT(0x696F8);
      }
      if (v9)
      {
        if (_dispatch_host_time_nano2mach) {
          unint64_t v17 = _dispatch_host_time_nano2mach(16666666);
        }
        else {
          unint64_t v17 = (unint64_t)(((0x2FAF07E * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64)
        }
                                 + ((unint64_t)(49999998
                                                     - ((0x2FAF07E * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64)) >> 1)) >> 6;
        unint64_t v11 = v17;
      }
      else
      {
        unint64_t v11 = v18 >> 1;
      }
    }
    else
    {
      unint64_t v11 = v18 * a3 / 0x3E8;
    }
    *(_DWORD *)(v8 + 24) = 0;
    *(void *)uint64_t v8 = v15;
    *(void *)(v8 + 8) = v15 + v11;
    *(void *)(v8 + 16) = v18;
    return v8;
  }
}

uint64_t _dispatch_timer_config_create(uint64_t a1, unint64_t a2, int64_t a3, uint64_t a4)
{
  uint64_t v19 = a1;
  unint64_t v18 = a2;
  int64_t v17 = a3;
  uint64_t v16 = a4;
  uint64_t v15 = _dispatch_calloc();
  if (v18)
  {
    if ((v18 & 0x8000000000000000) != 0) {
      unint64_t v18 = 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  else
  {
    if (v19 != -1) {
      _dispatch_bug_deprecated((uint64_t)"Setting timer interval to 0 requests a 1ns timer, did you mean FOREVER (a one-shot timer)?", v4, v5, v6, v7, v8, v9, v10);
    }
    unint64_t v18 = 1;
  }
  if (v17 < 0) {
    int64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
  }
  int v14 = 0;
  uint64_t v13 = 0;
  if (v19 == -1)
  {
    uint64_t v13 = 0x7FFFFFFFFFFFFFFFLL;
    int v14 = _dispatch_timer_flags_to_clock(*(unsigned char *)(v16 + 30));
  }
  else
  {
    uint64_t v28 = v19;
    char v27 = 1;
    uint64_t v26 = &v14;
    uint64_t v25 = &v13;
    unint64_t v24 = 0;
    if (v19 == 0x8000000000000000)
    {
      *uint64_t v26 = 1;
      *uint64_t v25 = _dispatch_monotonic_time();
    }
    else if (v19 == -2)
    {
      *uint64_t v26 = 2;
      *uint64_t v25 = _dispatch_get_nanoseconds();
    }
    else if (v19)
    {
      if (v28 >= 0)
      {
        *uint64_t v26 = 0;
        unint64_t v24 = v28;
      }
      else if ((v28 & 0x4000000000000000) != 0)
      {
        *uint64_t v26 = 2;
        unint64_t v24 = -v28;
      }
      else
      {
        *uint64_t v26 = 1;
        unint64_t v24 = v28 & 0x7FFFFFFFFFFFFFFFLL;
      }
      if (v24 <= 0x3FFFFFFFFFFFFFFFLL) {
        uint64_t v12 = v24;
      }
      else {
        uint64_t v12 = -1;
      }
      *uint64_t v25 = v12;
    }
    else
    {
      *uint64_t v26 = 0;
      *uint64_t v25 = _dispatch_uptime();
    }
  }
  if (v14 != 2)
  {
    unint64_t v22 = v18;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v23 = _dispatch_host_time_nano2mach(v22);
    }
    else if (v22)
    {
      if (v22 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v22 < 0x5555555555555555) {
          unint64_t v23 = 3 * v22 / 0x7D;
        }
        else {
          unint64_t v23 = 3 * (v22 / 0x7D);
        }
      }
      else
      {
        unint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v23 = 0;
    }
    unint64_t v18 = v23;
    if (!v23) {
      unint64_t v18 = 1;
    }
    unint64_t v20 = v17;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v21 = _dispatch_host_time_nano2mach(v20);
    }
    else if (v20)
    {
      if (v20 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v20 < 0x5555555555555555) {
          unint64_t v21 = 3 * v20 / 0x7D;
        }
        else {
          unint64_t v21 = 3 * (v20 / 0x7D);
        }
      }
      else
      {
        unint64_t v21 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v21 = 0;
    }
    int64_t v17 = v21;
  }
  if (v18 < 0x7FFFFFFFFFFFFFFFLL && v17 > v18 / 2) {
    int64_t v17 = v18 / 2;
  }
  *(_DWORD *)(v15 + 24) = v14;
  *(void *)uint64_t v15 = v13;
  *(void *)(v15 + 16) = v18;
  if ((unint64_t)(v13 + v17) >= 0x7FFFFFFFFFFFFFFFLL) {
    *(void *)(v15 + 8) = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    *(void *)(v15 + 8) = v13 + v17;
  }
  return v15;
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  dispatch_function_t v33 = 0;
  if (work) {
    dispatch_function_t v33 = work;
  }
  dispatch_time_t v51 = when;
  dispatch_queue_t queuea = queue;
  uint64_t v49 = context;
  blocsigned int k = v33;
  char v47 = 0;
  uint64_t v46 = 0;
  dispatch_source_t v45 = 0;
  unint64_t v44 = 0;
  unint64_t v43 = 0;
  if (when == -1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_after called with 'when' == infinity";
    __break(1u);
    JUMPOUT(0x69EA8);
  }
  unint64_t v43 = _dispatch_timeout(v51, (uint64_t)queue, (uint64_t)context, (uint64_t)work, v4, v5, v6, v7);
  if (v43)
  {
    unint64_t v44 = _dispatch_after_leeway(v43);
    if (v44 <= 0xF423F) {
      unint64_t v44 = 1000000;
    }
    if (v44 >= 0xDF8475801) {
      unint64_t v44 = 60000000000;
    }
    dispatch_source_t v45 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_after, 0, 0, queuea);
    uint64_t v46 = *((void *)v45 + 11);
    unint64_t v42 = 0;
    unint64_t v52 = 0;
    uint64_t v61 = _dispatch_thread_getspecific(0x16uLL);
    if (v61) {
      _dispatch_thread_setspecific(22, v61[2]);
    }
    unint64_t v52 = (unint64_t)v61;
    if (v61) {
      unint64_t v53 = v52;
    }
    else {
      unint64_t v53 = _dispatch_continuation_alloc_from_heap();
    }
    unint64_t v42 = (void *)v53;
    dispatch_queue_t v41 = queuea;
    dispatch_block_t v31 = 0;
    if (block) {
      dispatch_block_t v31 = block;
    }
    dispatch_queue_t v60 = v41;
    unsigned int v59 = v42;
    int v58 = v49;
    dispatch_block_t v57 = v31;
    uint64_t v56 = 0;
    uint64_t v55 = 0;
    uint64_t v54 = 0;
    void *v42 = 256;
    v59[4] = v57;
    v59[5] = v58;
    if ((v56 & 0x40000000) == 0)
    {
      int v76 = 1;
      unint64_t v79 = _dispatch_thread_getspecific(4uLL);
      unint64_t v80 = v79;
      unint64_t v77 = v79 & 0xFFFFFF;
      int v84 = 5;
      uint64_t v83 = 4096;
      if (v77 <= 0x10FF)
      {
        uint64_t v78 = v77;
      }
      else
      {
        int v82 = 5;
        uint64_t v81 = 4096;
        uint64_t v78 = 4351;
      }
      uint64_t v54 = v78;
    }
    int v64 = v59;
    uint64_t v63 = v56;
    int v62 = 0;
    BOOL v66 = (int)v56 >= 0;
    uint64_t v65 = 583;
    if ((int)v56 < 0) {
      _dispatch_abort(v65, v66, v8, v9, v10, v11, v12, v13);
    }
    if ((v63 & 0x40) == 0)
    {
      uint64_t v85 = _dispatch_thread_getspecific(0x1CuLL);
      if (v85)
      {
        unsigned int v95 = v85;
        os_retain(v85);
      }
      int v62 = v85;
    }
    v64[3] = v62;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v14, v15, v16, v17, v18, v19, v20, 589);
    uint64_t v21 = v64[3];
    int v89 = 771817476;
    uint64_t v88 = v21;
    uint64_t v87 = v64;
    if (v21 != -1)
    {
      unsigned int v86 = 0;
      unsigned int v30 = v88 ? *(_DWORD *)(v88 + 32) : 0;
      unsigned int v86 = v30;
      int v94 = v89;
      uint64_t v93 = v30;
      unsigned int v92 = v87;
      uint64_t v91 = 0;
      uint64_t v90 = 0;
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
    }
    dispatch_queue_t v75 = v60;
    unint64_t v74 = v59;
    unint64_t v73 = v54;
    uint64_t v72 = v56;
    unsigned int v71 = 0;
    dispatch_queue_t v70 = v60;
    if (v54)
    {
      BOOL v69 = (v72 & 0x20) != 0;
      BOOL v68 = 0;
      BOOL v68 = (*((_DWORD *)v70 + 21) & 0x40000000) != 0;
      BOOL v67 = 0;
      BOOL v67 = (*((_DWORD *)v70 + 21) & 0xFFF) != 0;
      if ((v72 & 0x20) != 0)
      {
        v73 |= 0x10000000uLL;
        unint64_t v96 = v73 >> 8;
        unsigned int v22 = v73 >> 8;
        unsigned int v23 = __clz(__rbit32(v22));
        if (v22) {
          unsigned int v24 = v23 + 1;
        }
        else {
          unsigned int v24 = 0;
        }
        unsigned int v71 = v24;
      }
      else if (v68 || !v67)
      {
        unint64_t v97 = v73 >> 8;
        unsigned int v25 = v73 >> 8;
        unsigned int v26 = __clz(__rbit32(v25));
        if (v25) {
          unsigned int v27 = v26 + 1;
        }
        else {
          unsigned int v27 = 0;
        }
        unsigned int v71 = v27;
      }
      else
      {
        unint64_t v73 = 0;
      }
    }
    v74[1] = v73;
    v42[6] = v45;
    dispatch_queue_t v40 = queuea;
    unint64_t v39 = v42;
    dispatch_queue_t v108 = queuea;
    unsigned int v107 = v42;
    int v106 = 0;
    int v105 = 0;
    dispatch_queue_t v110 = queuea;
    uint64_t v109 = v42;
    BOOL v38 = v42;
    uint64_t v37 = v42;
    *(void *)(v46 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v42;
    unsigned int v36 = v38;
    int v35 = 0;
    uint64_t v34 = 0;
    dispatch_time_t v104 = v51;
    char v103 = 0;
    int v102 = &v35;
    int v101 = &v34;
    unint64_t v100 = 0;
    if ((v51 & 0x8000000000000000) != 0)
    {
      if ((v104 & 0x4000000000000000) != 0)
      {
        *int v102 = 2;
        unint64_t v100 = -(uint64_t)v104;
      }
      else
      {
        *int v102 = 1;
        unint64_t v100 = v104 & 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      *int v102 = 0;
      unint64_t v100 = v104;
    }
    if (v100 >> 62) {
      uint64_t v29 = -1;
    }
    else {
      uint64_t v29 = v100;
    }
    *int v101 = v29;
    if (v35 != 2)
    {
      unint64_t v98 = v44;
      if (_dispatch_host_time_nano2mach)
      {
        unint64_t v99 = _dispatch_host_time_nano2mach(v98);
      }
      else if (v98)
      {
        if (v98 < 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v98 >= 0x5555555555555555)
          {
            unint64_t v99 = 3 * (v98 / 0x7D);
          }
          else
          {
            uint64_t v28 = (3 * v98 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
            unint64_t v99 = (v28 + ((3 * v98 - v28) >> 1)) >> 6;
          }
        }
        else
        {
          unint64_t v99 = 0x7FFFFFFFFFFFFFFFLL;
        }
      }
      else
      {
        unint64_t v99 = 0;
      }
      unint64_t v44 = v99;
    }
    *(unsigned char *)(v46 + 30) |= _dispatch_timer_flags_from_clock(v35);
    *(void *)(v46 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v34;
    *(void *)(v46 + 96) = -1;
    *(void *)(v46 + 88) = v34 + v44;
    dispatch_activate(v45);
  }
  else
  {
    worka = 0;
    if (block) {
      worka = (void (__cdecl *)(void *))block;
    }
    dispatch_channel_async_f(queuea, v49, worka);
  }
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  dispatch_time_t v52 = when;
  dispatch_queue_t queuea = queue;
  uint64_t v50 = 0;
  dispatch_block_t blocka = block;
  char v48 = 1;
  uint64_t v47 = 0;
  dispatch_source_t v46 = 0;
  unint64_t v45 = 0;
  unint64_t v44 = 0;
  if (when == -1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_after called with 'when' == infinity";
    __break(1u);
    JUMPOUT(0x6B2FCLL);
  }
  unint64_t v44 = _dispatch_timeout(v52, (uint64_t)queue, (uint64_t)block, v3, v4, v5, v6, v7);
  if (v44)
  {
    unint64_t v45 = _dispatch_after_leeway(v44);
    if (v45 <= 0xF423F) {
      unint64_t v45 = 1000000;
    }
    if (v45 >= 0xDF8475801) {
      unint64_t v45 = 60000000000;
    }
    dispatch_source_t v46 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_after, 0, 0, queuea);
    uint64_t v47 = *((void *)v46 + 11);
    unint64_t v43 = 0;
    unint64_t v53 = 0;
    dispatch_queue_t v70 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
    if (v70) {
      _dispatch_thread_setspecific(22, v70[2]);
    }
    unint64_t v53 = v70;
    if (v70) {
      uint64_t v54 = v53;
    }
    else {
      uint64_t v54 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
    }
    unint64_t v43 = v54;
    dispatch_queue_t v42 = queuea;
    dispatch_queue_t v61 = queuea;
    dispatch_queue_t v60 = v54;
    dispatch_block_t v59 = blocka;
    uint64_t v58 = 0;
    uint64_t v56 = _dispatch_Block_copy(blocka);
    uint64_t v57 = 272;
    dispatch_block_t v71 = blocka;
    uint64_t v33 = _Block_get_invoke_fn((uint64_t)blocka);
    uint64_t v34 = 0;
    if (v33) {
      uint64_t v34 = (uint64_t (*)())v33;
    }
    if (v34 == _dispatch_block_special_invoke)
    {
      *dispatch_queue_t v60 = v57;
      v60[5] = (uint64_t)v56;
      int inited = _dispatch_continuation_init_slow(v60, (unint64_t)v61, v58);
    }
    else
    {
      uint64_t v55 = 0;
      uint64_t v31 = _Block_get_invoke_fn((uint64_t)v59);
      uint64_t v32 = 0;
      if (v31) {
        uint64_t v32 = v31;
      }
      uint64_t v55 = v32;
      dispatch_queue_t v69 = v61;
      BOOL v68 = v60;
      uint64_t v67 = (uint64_t)v56;
      uint64_t v66 = v32;
      uint64_t v65 = v58;
      uint64_t v64 = v57;
      uint64_t v63 = 0;
      *dispatch_queue_t v60 = v57 | 0x100;
      v68[4] = v66;
      v68[5] = v67;
      if ((v65 & 0x40000000) == 0)
      {
        int v86 = 1;
        int v89 = _dispatch_thread_getspecific(4uLL);
        uint64_t v90 = v89;
        unint64_t v87 = v89 & 0xFFFFFF;
        int v94 = 5;
        uint64_t v93 = 4096;
        if (v87 <= 0x10FF)
        {
          uint64_t v88 = v87;
        }
        else
        {
          int v92 = 5;
          uint64_t v91 = 4096;
          uint64_t v88 = 4351;
        }
        uint64_t v63 = v88;
      }
      unint64_t v74 = v68;
      uint64_t v73 = v65;
      uint64_t v72 = 0;
      BOOL v76 = (int)v65 >= 0;
      uint64_t v75 = 583;
      if ((int)v65 < 0) {
        _dispatch_abort(v75, v76, v8, v9, v10, v11, v12, v13);
      }
      if ((v73 & 0x40) == 0)
      {
        unsigned int v95 = _dispatch_thread_getspecific(0x1CuLL);
        if (v95)
        {
          object = v95;
          os_retain(v95);
        }
        uint64_t v72 = (uint64_t)v95;
      }
      v74[3] = v72;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v14, v15, v16, v17, v18, v19, v20, 589);
      uint64_t v21 = v74[3];
      int v99 = 771817476;
      uint64_t v98 = v21;
      unint64_t v97 = v74;
      if (v21 != -1)
      {
        unsigned int v96 = 0;
        unsigned int v30 = v98 ? *(_DWORD *)(v98 + 32) : 0;
        unsigned int v96 = v30;
        int v104 = v99;
        uint64_t v103 = v30;
        int v102 = v97;
        uint64_t v101 = 0;
        uint64_t v100 = 0;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
      }
      dispatch_queue_t v85 = v69;
      int v84 = v68;
      unint64_t v83 = v63;
      uint64_t v82 = v65;
      unsigned int v81 = 0;
      dispatch_queue_t v80 = v69;
      if (v63)
      {
        BOOL v79 = (v82 & 0x20) != 0;
        BOOL v78 = 0;
        BOOL v78 = (*((_DWORD *)v80 + 21) & 0x40000000) != 0;
        BOOL v77 = 0;
        BOOL v77 = (*((_DWORD *)v80 + 21) & 0xFFF) != 0;
        if ((v82 & 0x20) != 0)
        {
          v83 |= 0x10000000uLL;
          unint64_t v106 = v83 >> 8;
          unsigned int v22 = v83 >> 8;
          unsigned int v23 = __clz(__rbit32(v22));
          if (v22) {
            unsigned int v24 = v23 + 1;
          }
          else {
            unsigned int v24 = 0;
          }
          unsigned int v81 = v24;
        }
        else if (v78 || !v77)
        {
          unint64_t v107 = v83 >> 8;
          unsigned int v25 = v83 >> 8;
          unsigned int v26 = __clz(__rbit32(v25));
          if (v25) {
            unsigned int v27 = v26 + 1;
          }
          else {
            unsigned int v27 = 0;
          }
          unsigned int v81 = v27;
        }
        else
        {
          unint64_t v83 = 0;
        }
      }
      v84[1] = v83;
      int inited = v81;
    }
    v43[6] = (uint64_t)v46;
    dispatch_queue_t v41 = queuea;
    dispatch_queue_t v40 = v43;
    dispatch_queue_t v118 = queuea;
    uint64_t v117 = v43;
    int v116 = 0;
    int v115 = 0;
    dispatch_queue_t v120 = queuea;
    uint64_t v119 = v43;
    unint64_t v39 = v43;
    BOOL v38 = v43;
    *(void *)(v47 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v43;
    uint64_t v37 = v39;
    int v36 = 0;
    uint64_t v35 = 0;
    dispatch_time_t v114 = v52;
    char v113 = 0;
    BOOL v112 = &v36;
    unsigned int v111 = &v35;
    unint64_t v110 = 0;
    if ((v52 & 0x8000000000000000) != 0)
    {
      if ((v114 & 0x4000000000000000) != 0)
      {
        *BOOL v112 = 2;
        unint64_t v110 = -(uint64_t)v114;
      }
      else
      {
        *BOOL v112 = 1;
        unint64_t v110 = v114 & 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      *BOOL v112 = 0;
      unint64_t v110 = v114;
    }
    if (v110 >> 62) {
      uint64_t v29 = -1;
    }
    else {
      uint64_t v29 = v110;
    }
    *unsigned int v111 = v29;
    if (v36 != 2)
    {
      unint64_t v108 = v45;
      if (_dispatch_host_time_nano2mach)
      {
        unint64_t v109 = _dispatch_host_time_nano2mach(v108);
      }
      else if (v108)
      {
        if (v108 < 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v108 >= 0x5555555555555555)
          {
            unint64_t v109 = 3 * (v108 / 0x7D);
          }
          else
          {
            uint64_t v28 = (3 * v108 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
            unint64_t v109 = (v28 + ((3 * v108 - v28) >> 1)) >> 6;
          }
        }
        else
        {
          unint64_t v109 = 0x7FFFFFFFFFFFFFFFLL;
        }
      }
      else
      {
        unint64_t v109 = 0;
      }
      unint64_t v45 = v109;
    }
    *(unsigned char *)(v47 + 30) |= _dispatch_timer_flags_from_clock(v36);
    *(void *)(v47 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v35;
    *(void *)(v47 + 96) = -1;
    *(void *)(v47 + 88) = v35 + v45;
    dispatch_activate(v46);
  }
  else
  {
    dispatch_channel_async(queuea, blocka);
  }
}

void *_dispatch_source_handler_dispose(uint64_t a1)
{
  if ((*(void *)a1 & 0x10) != 0) {
    _Block_release(*(const void **)(a1 + 40));
  }
  if (*(void *)(a1 + 24))
  {
    os_release(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = -1;
  }
  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  if (result) {
    int v2 = *((_DWORD *)result + 2) + 1;
  }
  else {
    int v2 = 1;
  }
  if (v2 <= _dispatch_continuation_cache_limit)
  {
    *(void *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 8) = v2;
    uint64_t result = (void *)_dispatch_thread_setspecific(22, a1);
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v4 = (void *)a1;
  }
  if (v4) {
    return _dispatch_continuation_free_to_cache_limit(v4);
  }
  return result;
}

void *_dispatch_source_set_handler_slow(uint64_t a1)
{
  uint64_t result = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v11 = result;
  uint64_t v9 = 0;
  if (*result) {
    uint64_t v9 = *result;
  }
  if (*(void *)(v9 + 16) != 275) {
    _dispatch_abort(323, *(void *)(v9 + 16) == 275, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v10 = *(void *)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  unint64_t v13 = a1;
  if (*(void *)(a1 + 32))
  {
    if ((*(void *)a1 & 0x40) != 0) {
      *(void *)(a1 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = result[4];
    }
  }
  else
  {
    uint64_t result = _dispatch_thread_getspecific(0x16uLL);
    if (result) {
      int v8 = *((_DWORD *)result + 2) + 1;
    }
    else {
      int v8 = 1;
    }
    if (v8 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(a1 + 16) = result;
      *(_DWORD *)(a1 + 8) = v8;
      uint64_t result = (void *)_dispatch_thread_setspecific(22, a1);
      uint64_t v15 = 0;
    }
    else
    {
      uint64_t v15 = (void *)a1;
    }
    if (v15) {
      uint64_t result = _dispatch_continuation_free_to_cache_limit(v15);
    }
    unint64_t v13 = 0;
  }
  uint64_t v14 = atomic_exchange_explicit((atomic_ullong *volatile)(v11[11] + 40 + 8 * v10), v13, memory_order_release);
  if (v14) {
    return _dispatch_source_handler_dispose(v14);
  }
  return result;
}

void _dispatch_source_handle_wlh_change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 80), 0x8000000u, memory_order_relaxed);
  if ((v8 & 0x400000) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after source was activated";
    __break(1u);
    JUMPOUT(0x6CBBCLL);
  }
  if ((v8 & 0x8000000) == 0) {
    _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy after source was activated", a2, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_source_registration_callout(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4 = __swp(0, (unsigned int *)(*(void *)(a1 + 88) + 56));
  if ((*(_DWORD *)(a1 + 80) & 0x10800000) != 0)
  {
    uint64_t v3 = 0;
    if ((a3 & 0x1000000) != 0) {
      uint64_t v3 = _dispatch_autorelease_pool_push();
    }
    _dispatch_source_handler_dispose(v4);
    if (v3) {
      _dispatch_autorelease_pool_pop(v3);
    }
  }
  else
  {
    if ((*(void *)v4 & 0x40) != 0) {
      *(void *)(v4 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(a1 + 32);
    }
    _dispatch_continuation_pop((void *)v4, 0, a3, a2);
  }
}

void _dispatch_source_latch_and_call(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v16 = a3;
  uint64_t v15 = *(unsigned int **)(a1 + 88);
  uint64_t v14 = (void *)*((void *)v15 + 5);
  unint64_t v13 = __swp(0, v15 + 18);
  uint64_t v11 = 0;
  if (*(void *)v15) {
    uint64_t v11 = *(void *)v15;
  }
  int v10 = *(unsigned __int8 *)(v11 + 9);
  if (v10 == 3)
  {
    *((void *)v15 + 8) = ~v13;
  }
  else if (v10 == 5)
  {
    if (v13)
    {
      unint64_t v20 = v13 >> 1;
      uint64_t v21 = *(void *)(a1 + 88);
      if (*(void *)(v21 + 80) < 0x7FFFFFFFFFFFFFFFuLL)
      {
        unsigned int v9 = *(_DWORD *)(v21 + 24) / 3u;
        if (v9) {
          uint64_t v22 = v9 == 1 ? _dispatch_monotonic_time() : _dispatch_get_nanoseconds();
        }
        else {
          uint64_t v22 = _dispatch_uptime();
        }
        if (v22 >= *(void *)(v21 + 80))
        {
          uint64_t v24 = (v22 - *(void *)(v21 + 80)) / *(void *)(v21 + 96) + 1;
          if (v24 + v20 > 0x7FFFFFFFFFFFFFFFLL) {
            uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL - v20;
          }
          if (*(void *)(v21 + 96) >= 0x7FFFFFFFFFFFFFFFuLL)
          {
            *(void *)(v21 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
            *(void *)(v21 + 88) = -1;
          }
          else
          {
            uint64_t v23 = v24 * *(void *)(v21 + 96);
            *(void *)(v21 + 80) += v23;
            *(void *)(v21 + 88) += v23;
          }
          v20 += v24;
        }
      }
      *((void *)v15 + 8) = v20;
    }
    else
    {
      *((void *)v15 + 8) = v13 >> 1;
    }
  }
  else
  {
    if (!v13 && *((char *)v15 + 28) == -23) {
      return;
    }
    *((void *)v15 + 8) = v13;
  }
  if (v14)
  {
    if (v13)
    {
      if (*((char *)v15 + 28) == -14)
      {
        _dispatch_continuation_get_function_symbol((uint64_t)v14);
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
      }
      _dispatch_continuation_pop(v14, 0, v16, a2);
      if (*((char *)v15 + 28) == -14 && MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      if ((*((unsigned char *)v15 + 29) & 2) != 0)
      {
        if (v13)
        {
          BOOL v8 = 0;
          if ((*((unsigned char *)v15 + 29) & 2) != 0) {
            BOOL v8 = *((void *)v15 + 13) != 0;
          }
          if (v8) {
            _dispatch_timer_unote_configure(*(void *)(a1 + 88));
          }
        }
        if ((*((unsigned char *)v15 + 30) & 0x40) != 0)
        {
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace();
          }
          uint64_t v12 = 0;
          if ((v16 & 0x1000000) != 0) {
            uint64_t v12 = _dispatch_autorelease_pool_push();
          }
          uint64_t v19 = __swp(0, v15 + 10);
          if (v19) {
            _dispatch_source_handler_dispose(v19);
          }
          if (v12) {
            _dispatch_autorelease_pool_pop(v12);
          }
          dispatch_release((dispatch_object_t)a1);
        }
      }
    }
    else
    {
      _dispatch_bug(586, v13 != 0, a3, a4, a5, a6, a7, a8);
    }
  }
  else if (MEMORY[0xFFFFFC100])
  {
    kdebug_trace();
  }
}

uint64_t _dispatch_monotonic_time()
{
  return mach_continuous_time();
}

__uint64_t _dispatch_get_nanoseconds()
{
  return clock_gettime_nsec_np(_CLOCK_REALTIME);
}

uint64_t _dispatch_trace_timer_function(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 40);
  if (v3) {
    return *(void *)(v3 + 32);
  }
  else {
    return 0;
  }
}

unint64_t _dispatch_after_leeway(unint64_t a1)
{
  unsigned int v1 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
  unsigned int v2 = __clz(__rbit32(v1));
  if (v1) {
    unsigned int v3 = v2 + 1;
  }
  else {
    unsigned int v3 = 0;
  }
  if (v3 <= 3) {
    return a1 / 0xA;
  }
  if (v3 == 5 || v3 == 4) {
    return a1 / 0xF;
  }
  else {
    return a1 / 0x14;
  }
}

uint64_t _dispatch_timer_flags_from_clock(char a1)
{
  return (4 * a1);
}

uint64_t _dispatch_wait_for_enqueuer(unint64_t *a1)
{
  int v4 = 10;
  while (1)
  {
    int v1 = v4--;
    if (v1 <= 0) {
      break;
    }
    unint64_t v2 = __ldxr(a1);
    if (v2)
    {
      __clrex();
      return v2;
    }
    __wfe();
  }
  return __DISPATCH_WAIT_FOR_ENQUEUER__((uint64_t)a1);
}

uint64_t __DISPATCH_WAIT_FOR_ENQUEUER__(uint64_t a1)
{
  int v2 = 0;
  while (!*(void *)a1)
  {
    ++v2;
    _pthread_yield_to_enqueuer_4dispatch();
  }
  return *(void *)a1;
}

void *dispatch_mach_hooks_install_4libxpc(void *result)
{
  if (*result <= 2uLL)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to install hooks with unsupported version";
    qword_F42C0 = (uint64_t)result;
    __break(1u);
    JUMPOUT(0x6DDE4);
  }
  int v1 = &_dispatch_mach_xpc_hooks_default;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)&_dispatch_mach_xpc_hooks, (unint64_t *)&v1, (unint64_t)result, memory_order_relaxed, memory_order_relaxed);
  if (v1 != &_dispatch_mach_xpc_hooks_default)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_hooks_install_4libxpc called twice";
    qword_F42C0 = (uint64_t)_dispatch_mach_xpc_hooks;
    __break(1u);
    JUMPOUT(0x6DED4);
  }
  return result;
}

void _dispatch_mach_hooks_install_default()
{
  _dispatch_mach_xpc_hooks = &_dispatch_mach_xpc_hooks_default;
}

uint64_t *dispatch_mach_create(uint64_t a1, uint64_t (***a2)(), const void *a3)
{
  int v10 = _dispatch_Block_copy(a3);
  uint64_t v11 = _Block_get_invoke_fn((uint64_t)v10);
  uint64_t v12 = 0;
  if (v11) {
    uint64_t v12 = v11;
  }
  uint64_t v7 = 0;
  if (v12) {
    uint64_t v7 = v12;
  }
  return _dispatch_mach_create(a1, a2, (uint64_t)v10, v7, 1, v3, v4, v5);
}

uint64_t *_dispatch_mach_create(uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v29 = a5;
  unsigned int v27 = _dispatch_object_alloc((uint64_t)_OS_dispatch_mach_vtable, 0x88uLL, a3, a4, a5, a6, a7, a8);
  _dispatch_queue_init(v27, 0x400000, 1, 0x180000000000000, v8, v9, v10, v11);
  v27[9] = a1;
  *((_WORD *)v27 + 58) = *((_WORD *)v27 + 58) & 0xFFEF | (8 * (v29 & 2));
  *((_WORD *)v27 + 58) = *((_WORD *)v27 + 58) & 0xFF7F | (32 * (v29 & 4));
  uint64_t v28 = off_ED3F0((uint64_t)&_dispatch_mach_type_recv, 0, 0);
  if ((*(unsigned char *)(v28 + 29) & 1) == 0) {
    _dispatch_abort(131, 0, v12, v13, v14, v15, v16, v17);
  }
  *(void *)(v28 + 8) = ~(unint64_t)v27;
  uint64_t v25 = 0;
  if (a4) {
    uint64_t v25 = a4;
  }
  *(void *)(v28 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v25;
  *(void *)(v28 + 48) = a3;
  *(unsigned char *)(v28 + 29) = *(unsigned char *)(v28 + 29) & 0xBF | ((v29 & 1) << 6);
  if ((*((_WORD *)v27 + 58) & 0x80) != 0) {
    *(_DWORD *)(v28 + 32) |= 0x200u;
  }
  v27[11] = v28;
  uint64_t v26 = off_ED330((uint64_t)&_dispatch_mach_type_send, 0, 9);
  *(void *)(v26 + 8) = ~(unint64_t)v27;
  v27[15] = v26;
  if (a2)
  {
    if ((*((unsigned char *)a2 + 87) & 8) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target object to cooperative root queue - not implemented";
      qword_F42C0 = (uint64_t)a2;
      __break(1u);
      JUMPOUT(0x6E2DCLL);
    }
    _dispatch_retain((uint64_t)a2);
  }
  else
  {
    a2 = &off_F0680;
  }
  v27[3] = (uint64_t)a2;
  _dispatch_object_debug(v27, "%s", v18, v19, v20, v21, v22, v23, (char)"_dispatch_mach_create");
  return v27;
}

uint64_t *dispatch_mach_create_f(uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_mach_create(a1, a2, a3, a4, 0, a6, a7, a8);
}

uint64_t *dispatch_mach_create_4libxpc(uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_mach_create(a1, a2, a3, a4, 6, a6, a7, a8);
}

void _dispatch_mach_dispose(uint64_t *a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  a1[11] = 0;
  _dispatch_unote_dispose(a1[15]);
  a1[15] = 0;
  if (a1[16])
  {
    _dispatch_unote_dispose(a1[16]);
    a1[16] = 0;
  }
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

uint64_t dispatch_mach_request_no_senders(uint64_t result)
{
  *(_WORD *)(result + 116) |= 0x20u;
  uint64_t v1 = *(void *)(result + 56);
  if ((~v1 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0x6E544);
  }
  return result;
}

uint64_t dispatch_mach_notify_no_senders(uint64_t result, char a2)
{
  *(_WORD *)(result + 116) |= 0x20u;
  *(_WORD *)(result + 116) = *(_WORD *)(result + 116) & 0xFFBF | ((a2 & 1) << 6);
  uint64_t v2 = *(void *)(result + 56);
  if ((~v2 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v2;
    __break(1u);
    JUMPOUT(0x6E620);
  }
  return result;
}

uint64_t dispatch_mach_set_flags(uint64_t result, char a2)
{
  *(_WORD *)(result + 116) = *(_WORD *)(result + 116) & 0xFF7F | ((a2 & 1) << 7);
  uint64_t v2 = *(void *)(result + 56);
  if ((~v2 & 0x180000000000000) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_F42C0 = v2;
    __break(1u);
    JUMPOUT(0x6E6ECLL);
  }
  return result;
}

void dispatch_mach_connect(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (a2 && a2 != -1) {
    *(_DWORD *)(*(void *)(a1 + 88) + 24) = a2;
  }
  *(_DWORD *)(v9 + 92) = a3;
  if (a3 && a3 != -1)
  {
    if (a4)
    {
      dispatch_retain((dispatch_object_t)a4);
      *(_DWORD *)(a4 + 48) = _dispatch_mach_checkin_options();
      *(_DWORD *)(v9 + 96) = _dispatch_mach_msg_get_remote_port(a4);
    }
    *(void *)(v9 + 48) = a4;
  }
  if ((*(_WORD *)(a1 + 116) & 0x20) != 0 && !*(void *)(v9 + 48)) {
    _dispatch_mach_arm_no_senders(a1, 0);
  }
  unsigned int v8 = atomic_fetch_and_explicit((atomic_uint *volatile)(v9 + 88), 0x7FFFFFFFu, memory_order_relaxed);
  if (!(HIBYTE(v8) >> 7))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel already connected";
    qword_F42C0 = v8;
    __break(1u);
    JUMPOUT(0x6E8BCLL);
  }
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_mach_connect");
  dispatch_activate((dispatch_object_t)a1);
}

uint64_t _dispatch_mach_checkin_options()
{
  return 0x40000;
}

uint64_t _dispatch_mach_msg_get_remote_port(uint64_t a1)
{
  return *(unsigned int *)(_dispatch_mach_msg_get_msg(a1) + 8);
}

void _dispatch_mach_arm_no_senders(uint64_t a1, char a2)
{
  kern_return_t v14;
  kern_return_t v15;
  mach_port_t previous;
  mach_port_name_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  uint64_t v19 = a1;
  uint64_t v18 = a2;
  uint64_t v17 = 0;
  uint64_t v17 = *(_DWORD *)(*(void *)(a1 + 88) + 24);
  previous = 0;
  if (v17 && v17 != -1)
  {
    uint64_t v14 = mach_port_request_notification(mach_task_self_, v17, 70, ((*(unsigned __int16 *)(v19 + 116) >> 6) & 1) == 0, v17, 0x15u, &previous);
    if (v14 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x6EA5CLL);
    }
    uint64_t v23 = v14;
    uint64_t v22 = 252;
    if (v14) {
      _dispatch_bug(v22, v23, v2, v3, v4, v5, v6, v7);
    }
  }
  if (previous)
  {
    if ((v18 & 1) == 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Mach port notification collision";
      qword_F42C0 = previous;
      __break(1u);
      JUMPOUT(0x6EB00);
    }
    uint64_t v15 = mach_port_deallocate(mach_task_self_, previous);
    if (v15 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x6EB6CLL);
    }
    uint64_t v21 = v15;
    uint64_t v20 = 260;
    if (v15) {
      _dispatch_bug(v20, v21, v8, v9, v10, v11, v12, v13);
    }
  }
}

void _dispatch_mach_merge_msg(uint64_t a1, unsigned int a2, mach_msg_header_t *a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  if ((a2 & 0x200) != 0)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 24);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
    qword_F42C0 = v7;
    __break(1u);
    JUMPOUT(0x6EC44);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: received msg id 0x%x, reply on 0x%08x", v8, v9, v10, v11, v12, v13, v14, 676);
  uint64_t v42 = ~*(void *)(a1 + 8);
  if ((HIBYTE(*(_DWORD *)(79 - *(void *)(a1 + 8))) >> 4))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v17, v18, v19, v20, v21, v22, v23, 681);
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0) {
      free(a3);
    }
  }
  else if (a3->msgh_id == 70 && (*(_WORD *)(115 - *(void *)(a1 + 8)) & 0x20) != 0)
  {
    BOOL is_kernel = _dispatch_mach_msg_sender_is_kernel((uint64_t)a3);
    if (is_kernel)
    {
      dispatch_time_t v51 = _dispatch_thread_getspecific(0x16uLL);
      if (v51)
      {
        _dispatch_thread_setspecific(22, v51[2]);
        uint64_t v50 = v51;
      }
      else
      {
        uint64_t v50 = (void *)_dispatch_continuation_alloc_from_heap();
      }
      *uint64_t v50 = 260;
      v50[4] = _dispatch_mach_no_senders_invoke;
      v50[5] = v42;
      v50[3] = 0;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v30, v31, v32, v33, v34, v35, v36, 589);
      if (v50[3] != -1 && MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
      v50[1] = 0;
      uint64_t v39 = 0;
      if (*(void *)v42) {
        uint64_t v39 = *(void *)v42;
      }
      (*(void (**)(uint64_t, void *, void))(v39 + 72))(v42, v50, 0);
    }
    else
    {
      _dispatch_bug(687, is_kernel, v24, v25, v26, v27, v28, v29);
    }
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0) {
      free(a3);
    }
  }
  else
  {
    recv = (dispatch_object_s *)_dispatch_mach_msg_create_recv(a3, a4, a5, 0, a2, a6, v15, v16);
    _dispatch_mach_handle_or_push_received_msg(v42, recv, a7);
  }
  BOOL v38 = 1;
  if ((*(void *)(a1 + 16) & 2) == 0) {
    BOOL v38 = (((unint64_t)*(unsigned int *)(v42 + 60) << 32) & 0x180000000000000) == 0x80000000000000;
  }
  if (v38)
  {
    uint64_t v37 = 0;
    if (*(void *)v42) {
      uint64_t v37 = *(void *)v42;
    }
    (*(void (**)(uint64_t, void, uint64_t))(v37 + 64))(v42, 0, 51);
  }
  else
  {
    _dispatch_release_2_tailcall(v42);
  }
}

uint64_t _dispatch_mach_no_senders_invoke(uint64_t result)
{
  if ((*(_DWORD *)(result + 80) & 0x10000000) == 0)
  {
    uint64_t v2 = *(void *)(result + 88);
    uint64_t v1 = 0;
    if (*(void *)(v2 + 40)) {
      uint64_t v1 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v2 + 40);
    }
    return _dispatch_client_callout4(*(void *)(v2 + 48), 13, 0, 0, v1);
  }
  return result;
}

void *_dispatch_mach_msg_create_recv(_DWORD *a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v33 = a5;
  int v31 = a6;
  if (a4)
  {
    unsigned int v39 = (*a1 & 0x1F0000u) >> 16;
    mach_port_name_t v38 = a1[4];
    if ((v39 == 19 || v39 == 17) && v38)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v8, v9, v10, v11, v12, v13, v14, 520);
      if (v39 == 17) {
        _voucher_dealloc_mach_voucher(v38);
      }
      a1[4] = 0;
      *a1 &= 0xFFE0FFFF;
    }
    uint64_t v32 = *(unsigned int *)(a4 + 40);
    uint64_t v29 = *(void **)(a4 + 56);
    *(void *)(a4 + 56) = 0;
  }
  else
  {
    uint64_t v29 = _voucher_create_with_mach_msgv(a1, a3, (uint64_t)a3, 0, a5, a6, a7, a8);
    if ((v31 & 0xFFFFFFu) <= 0x10FFuLL) {
      uint64_t v37 = v31 & 0xFFFFFF;
    }
    else {
      uint64_t v37 = 4351;
    }
    uint64_t v32 = v37;
  }
  uint64_t v30 = dispatch_mach_msg_create((uint64_t)a1, a2, (v33 & 0x10000) != 0, 0, a5, a6, a7, a8);
  if ((v33 & 0x10000) == 0 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  v30[8] = v29;
  v30[7] = v32;
  if (a4) {
    uint64_t v28 = *(void *)(a4 + 48);
  }
  else {
    uint64_t v28 = 0;
  }
  v30[4] = v28;
  _dispatch_mach_msg_set_reason((uint64_t)v30, 0, 2, v15, v16, v17, v18, v19);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] create", v20, v21, v22, v23, v24, v25, v26, 646);
  if (v30[8] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  return v30;
}

void _dispatch_mach_handle_or_push_received_msg(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  uint64_t v13 = a3;
  unsigned int v12 = 0;
  uint64_t reason = _dispatch_mach_msg_get_reason((uint64_t)a2, (int *)&v12);
  if (reason != 2
    && ((*(_WORD *)(v15 + 116) >> 4) & 1) != 0
    && ((*(uint64_t (**)(void, uint64_t, dispatch_object_s *, void))((char *)&dword_8
                                                                                + (void)_dispatch_mach_xpc_hooks))(*(void *)(*(void *)(v15 + 88) + 48), reason, v14, v12) & 1) != 0)
  {
    *((void *)v14 + 2) = -1985229329;
    dispatch_release(v14);
  }
  else
  {
    uint64_t v19 = v15;
    uint64_t v18 = v14;
    int v17 = 0;
    int v16 = 0;
    uint64_t v23 = v15;
    uint64_t v22 = v14;
    unint64_t v20 = v13 & 0x3FFF00;
    v20 >>= 8;
    unsigned int v8 = __clz(__rbit32(v20));
    if (v20) {
      unsigned int v9 = v8 + 1;
    }
    else {
      unsigned int v9 = 0;
    }
    unsigned int v10 = v9;
    if (!v9)
    {
      unsigned int v21 = *(_DWORD *)(v15 + 84);
      v21 &= 0xF00u;
      unsigned int v10 = v21 >> 8;
    }
    _dispatch_lane_push(v15, v14, v10, v3, v4, v5, v6, v7);
  }
}

void _dispatch_mach_reply_merge_msg(uint64_t a1, unsigned int a2, mach_msg_header_t *a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v40 = ~*(void *)(a1 + 8);
  BOOL v39 = (*(_DWORD *)(79 - *(void *)(a1 + 8)) & 0x10000000) != 0;
  recv = 0;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: received msg id 0x%x, reply on 0x%08x", v7, v8, v9, v10, v11, v12, v13, 737);
  if (!v39) {
    recv = (dispatch_object_s *)_dispatch_mach_msg_create_recv(a3, a4, a5, a1, a2, a6, v14, v15);
  }
  if (recv)
  {
    uint64_t v37 = 0;
    if (((*(_WORD *)(v40 + 116) >> 4) & 1) != 0 && *((void *)recv + 4))
    {
      uint64_t v48 = (*(uint64_t (**)(void))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(*((void *)recv + 4));
      if (!v48) {
        uint64_t v48 = v40;
      }
      uint64_t v37 = (uint64_t *)v48;
    }
    if (v37)
    {
      uint64_t v49 = _dispatch_mach_msg_async_reply_wrap((uint64_t)recv, v40);
      uint64_t v35 = 0;
      if (*v37) {
        uint64_t v35 = *v37;
      }
      unsigned int v19 = (*((void *)recv + 7) & 0x3FFF00uLL) >> 8;
      unsigned int v20 = __clz(__rbit32(v19));
      if (v19) {
        uint64_t v21 = v20 + 1;
      }
      else {
        uint64_t v21 = 0;
      }
      (*(void (**)(uint64_t *, void *, uint64_t, uint64_t, uint64_t, uint64_t))(v35 + 72))(v37, v49, v21, v16, v17, v18);
    }
    else
    {
      _dispatch_mach_handle_or_push_received_msg(v40, recv, a7);
    }
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v28, v29, v30, v31, v32, v33, v34, 755);
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0) {
      free(a3);
    }
  }
  char v36 = 101;
  if (v39) {
    char v36 = 117;
  }
  if ((*(void *)(a1 + 16) & 2) == 0) {
    _dispatch_abort(765, (*(void *)(a1 + 16) & 2) != 0, v22, v23, v24, v25, v26, v27);
  }
  _dispatch_mach_reply_unregister(v40, a1, v36);
}

void _dispatch_mach_reply_unregister(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v41 = 0;
  if (*(void *)a2) {
    uint64_t v41 = *(void *)a2;
  }
  uint64_t v46 = *(void *)(a1 + 120);
  BOOL v45 = (a3 & 0x10) != 0;
  char v44 = 0;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistering for%s reply%s, ctxt %p", v3, v4, v5, v6, v7, v8, v9, 355);
  if ((a3 & 0x20) != 0)
  {
    unsigned int v52 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    int v23 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v46 + 40), (unsigned int *)&v23, v52, memory_order_acquire, memory_order_acquire);
    if (v23) {
      _dispatch_unfair_lock_lock_slow((atomic_uint *)(v46 + 40));
    }
    _dispatch_mach_reply_list_remove_locked(a2, v16, v17, v18, v19, v20, v21, v22);
    if (!*(void *)(v46 + 56) && *(_DWORD *)(v46 + 88)) {
      char v44 = 1;
    }
    unsigned int v53 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    unsigned int v54 = atomic_exchange_explicit((atomic_uint *volatile)(v46 + 40), 0, memory_order_release);
    if (v54 != v53) {
      _dispatch_unfair_lock_unlock_slow(v46 + 40, v54);
    }
  }
  if (!*(void *)(a2 + 16) || (_dispatch_unote_unregister(a2, a3 & 0xF, v10, v11, v12, v13, v14, v15) & 1) != 0)
  {
    reply_disconnected = 0;
    uint64_t v42 = 0;
    if (v45)
    {
      if (((*(_WORD *)(a1 + 116) >> 4) & 1) != 0 && *(void *)(a2 + 48))
      {
        uint64_t v50 = (*(uint64_t (**)(void))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(*(void *)(a2 + 48));
        if (!v50) {
          uint64_t v50 = a1;
        }
        uint64_t v42 = (uint64_t *)v50;
      }
      if (v42) {
        uint64_t v26 = 12;
      }
      else {
        uint64_t v26 = 7;
      }
      reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected(0, a2, v26, v11, v12, v13, v14, v15);
      if (*(void *)(a2 + 56)) {
        _dispatch_abort(387, *(void *)(a2 + 56) == 0, v27, v28, v29, v30, v31, v32);
      }
    }
    else if (*(void *)(a2 + 56))
    {
      os_release(*(void **)(a2 + 56));
      *(void *)(a2 + 56) = 0;
    }
    if (v41 != -2) {
      _dispatch_unote_dispose(a2);
    }
    if (reply_disconnected)
    {
      if (v42)
      {
        dispatch_time_t v51 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, a1);
        uint64_t v40 = 0;
        if (*v42) {
          uint64_t v40 = *v42;
        }
        unsigned int v36 = (*((void *)reply_disconnected + 7) & 0x3FFF00uLL) >> 8;
        unsigned int v37 = __clz(__rbit32(v36));
        if (v36) {
          uint64_t v38 = v37 + 1;
        }
        else {
          uint64_t v38 = 0;
        }
        (*(void (**)(uint64_t *, void *, uint64_t, uint64_t, uint64_t, uint64_t))(v40 + 72))(v42, v51, v38, v33, v34, v35);
      }
      else
      {
        _dispatch_mach_handle_or_push_received_msg(a1, reply_disconnected, 0);
      }
    }
    if ((a3 & 0x40) != 0)
    {
      if (v44)
      {
        uint64_t v39 = 0;
        if (*(void *)a1) {
          uint64_t v39 = *(void *)a1;
        }
        (*(void (**)(uint64_t, void, uint64_t))(v39 + 64))(a1, 0, 3);
      }
      else
      {
        _dispatch_release_2_tailcall(a1);
      }
    }
  }
  else
  {
    if (v41 == -2) {
      _dispatch_abort(368, 0, v24, v11, v12, v13, v14, v15);
    }
    if (a3 < 0)
    {
      uint64_t v25 = *(void *)(v46 + 56);
      *(void *)(a2 + 64) = v25;
      if (v25) {
        *(void *)(*(void *)(v46 + 56) + 72) = a2 + 64;
      }
      *(void *)(v46 + 56) = a2;
      *(void *)(a2 + 72) = v46 + 56;
    }
  }
}

uint64_t _dispatch_mach_send_barrier_drain_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v47 = a1;
  uint64_t v46 = a2;
  int v45 = a3;
  unint64_t v43 = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v48 = v43;
  uint64_t v49 = v43;
  uint64_t v42 = v43;
  uint64_t v44 = (uint64_t)v43;
  uint64_t v41 = 516;
  long long v40 = 0uLL;
  uint64_t v50 = &v40;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v40, 0x15uLL, (pthread_key_t *)&v40 + 1, v3, v4, v5, v6);
  BOOL v77 = (_OWORD *)*((void *)v50 + 1);
  _dispatch_thread_setspecific_packed_pair(20, 21, v77, v7, v8, v9, v10, v11);
  uint64_t v39 = v47;
  __int16 v37 = v41;
  uint64_t v54 = v47;
  uint64_t v53 = v41;
  unsigned int v52 = 0;
  unsigned int v52 = *(_DWORD **)(v47 + 24);
  uint64_t v51 = v41 & 4;
  uint64_t v56 = 1;
  uint64_t v55 = 600;
  if ((v41 & 4) != 0) {
    *(void *)(v54 + 24) = -1;
  }
  if (v52 != (_DWORD *)-1)
  {
    int v70 = 771817480;
    dispatch_queue_t v69 = v52;
    uint64_t v68 = v54;
    unsigned int v67 = 0;
    if (v52) {
      unsigned int v36 = v69[8];
    }
    else {
      unsigned int v36 = 0;
    }
    unsigned int v67 = v36;
    int v75 = v70;
    uint64_t v74 = v36;
    uint64_t v73 = v68;
    uint64_t v72 = 0;
    uint64_t v71 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v18, v19, v20, v21, v22, v23, v24, 607);
  }
  unint64_t v81 = *(void *)(v54 + 8);
  uint64_t v80 = (uint64_t)v52;
  uint64_t v79 = v51 | 2;
  uint64_t v78 = 0;
  if (v81 != -1)
  {
    unint64_t v88 = v81;
    uint64_t v87 = v79;
    unsigned int v86 = 0;
    unsigned int v86 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v85 = 0;
    unsigned int v101 = v86;
    unsigned int v104 = v86 & 0xF00;
    unsigned int v100 = v104 >> 8;
    uint64_t v99 = v86;
    if (v104 >> 8) {
      v99 |= 1 << (v100 + 7);
    }
    uint64_t v85 = v99;
    uint64_t v102 = v99;
    unint64_t v84 = v99 & 0xFFFFFF00;
    BOOL v83 = 0;
    BOOL v35 = 1;
    if ((v87 & 1) == 0) {
      BOOL v35 = (v88 & 0x10000000) != 0;
    }
    BOOL v83 = v35;
    unint64_t v90 = v88;
    v88 &= 0xFFFFFFu;
    if (v88)
    {
      if (v88 >= v84)
      {
        if (v83 || (v86 & 0x44000000) != 0) {
          uint64_t v89 = v88;
        }
        else {
          uint64_t v89 = v85;
        }
      }
      else
      {
        uint64_t v89 = v85;
      }
    }
    else
    {
      unsigned int v103 = v86 & 0xF000;
      unsigned int v82 = v103 >> 12;
      if (v103 >> 12)
      {
        unsigned int v92 = v82;
        uint64_t v91 = 1 << (v82 + 7);
        uint64_t v34 = v91 | 0xFF;
      }
      else
      {
        uint64_t v34 = v85;
      }
      uint64_t v89 = v34;
    }
    uint64_t v78 = v89;
  }
  uint64_t v96 = v78;
  uint64_t v95 = v80;
  uint64_t v94 = v79;
  uint64_t v108 = v78;
  BOOL v111 = v78 != -1;
  uint64_t v110 = 2395;
  if (v78 == -1) {
    _dispatch_abort(v110, v111, v12, v13, v14, v15, v16, v17);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v122 = v108;
    uint64_t v121 = 4261412863;
    uint64_t v120 = 0;
    v108 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v107 = 0;
    BOOL v112 = 0;
    BOOL v112 = _dispatch_thread_getspecific(4uLL);
    unint64_t v107 = (unint64_t)v112;
    uint64_t v106 = 0x1000000;
    uint64_t v105 = 2281701376;
    if ((v112 & 0x1000000) != 0)
    {
      if (v108)
      {
        uint64_t v33 = v108;
      }
      else
      {
        unint64_t v116 = v107;
        uint64_t v115 = v106;
        uint64_t v114 = 0;
        uint64_t v33 = v107 & (~v106 | 0xFFFFFF);
      }
      uint64_t v109 = v33;
    }
    else
    {
      unint64_t v119 = v107;
      uint64_t v118 = v105;
      uint64_t v117 = 0;
      v107 &= ~v105 | 0xFFFFFF;
      if (v108 == v107) {
        uint64_t v109 = 0;
      }
      else {
        uint64_t v109 = v108;
      }
    }
  }
  else
  {
    uint64_t v109 = 0;
  }
  uint64_t v96 = v109;
  if (v109) {
    goto LABEL_52;
  }
  if (v95 == -1)
  {
    uint64_t v97 = -1;
    goto LABEL_53;
  }
  uint64_t v32 = (void *)v95;
  if (v32 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_52:
    uint64_t v97 = _dispatch_set_priority_and_voucher_slow(v96, (_DWORD *)v95, v94);
  }
  else
  {
    BOOL v93 = (v94 & 4) != 0;
    if ((v94 & 2) != 0)
    {
      if (v93 && v95)
      {
        uint64_t v113 = v95;
        os_release((void *)v95);
      }
      uint64_t v95 = -1;
    }
    else if (!v93 && v95)
    {
      object = (void *)v95;
      os_retain((void *)v95);
    }
    uint64_t v97 = v95;
  }
LABEL_53:
  if ((v37 & 0x200) == 0)
  {
    uint64_t v60 = v44;
    uint64_t v59 = v47;
    int v58 = 0;
    int v57 = 0;
    uint64_t v124 = v44;
    uint64_t v123 = v47;
  }
  if ((v37 & 4) != 0)
  {
    uint64_t v63 = v39;
    int v62 = 0;
    int v62 = _dispatch_thread_getspecific(0x16uLL);
    int v61 = 0;
    if (v62) {
      int v31 = v62[2] + 1;
    }
    else {
      int v31 = 1;
    }
    int v61 = v31;
    if (v31 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v63 + 16) = v62;
      *(_DWORD *)(v63 + 8) = v61;
      _dispatch_thread_setspecific(22, v63);
      uint64_t v64 = 0;
    }
    else
    {
      uint64_t v64 = v63;
    }
    uint64_t v38 = (void *)v64;
  }
  else
  {
    uint64_t v38 = 0;
  }
  _dispatch_mach_send_invoke(v44, v45, 6u);
  if ((v37 & 0x200) == 0)
  {
    uint64_t v65 = v39;
    uint64_t v125 = v39;
    int v130 = 772079660;
    uint64_t v129 = v39;
    uint64_t v128 = 0;
    uint64_t v127 = 0;
    uint64_t v126 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v131 = v65;
  }
  if (v38) {
    _dispatch_continuation_free_to_cache_limit(v38);
  }
  uint64_t v66 = &v40;
  BOOL v76 = &v40;
  return _dispatch_thread_setspecific_packed_pair(20, 21, &v40, v25, v26, v27, v28, v29);
}

uint64_t _dispatch_mach_send_invoke(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v20 = *(void *)(a1 + 120);
  unsigned int v19 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v16 = 0xFFFFFFFFLL;
  uint64_t v15 = 0;
  if ((a3 & 2) != 0)
  {
    uint64_t v16 = 0x10FFFFFFFFLL;
    uint64_t v15 = 0x1000000000;
  }
  else if ((a3 & 4) == 0)
  {
    uint64_t v16 = 0x10FFFFFFFFLL;
  }
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
  unsigned int v24 = (unsigned __int16)(result & 0xF000) >> 12;
  if ((unsigned __int16)(result & 0xF00) >> 8 <= v24) {
    unsigned int v13 = (unsigned __int16)(result & 0xF000) >> 12;
  }
  else {
    unsigned int v13 = (unsigned __int16)(result & 0xF00) >> 8;
  }
  if (v13 <= (result & 0xF0000) >> 16)
  {
    unsigned int v11 = (result & 0xF0000) >> 16;
  }
  else
  {
    if ((unsigned __int16)(result & 0xF00) >> 8 <= v24) {
      int v12 = (unsigned __int16)(result & 0xF000) >> 12;
    }
    else {
      int v12 = (unsigned __int16)(result & 0xF00) >> 8;
    }
    unsigned int v11 = v12;
  }
  int v14 = v11;
LABEL_15:
  for (uint64_t i = *(void *)(v20 + 64); ; uint64_t i = v10)
  {
    if ((i & v16) == v15)
    {
      if (v14 < (i & 0x700000000uLL) >> 32)
      {
        unsigned int v25 = (i & 0x700000000uLL) >> 32;
        _dispatch_thread_getspecific(3uLL);
        if (_dispatch_set_qos_class_enabled) {
          _pthread_workqueue_override_start_direct();
        }
        uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
        if (v25 > (result & 0xF0000) >> 16) {
          uint64_t result = _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | (v25 << 16));
        }
        int v14 = (i & 0x700000000uLL) >> 32;
        goto LABEL_15;
      }
      unint64_t v17 = (i | v19) & 0xFFFFFFC7FFFFFFFFLL;
    }
    else
    {
      if ((a3 & 1) == 0) {
        break;
      }
      unint64_t v17 = i | 0x2000000000;
    }
    uint64_t v9 = i;
    uint64_t v10 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v20 + 64), (unint64_t *)&v10, v17, memory_order_acquire, memory_order_acquire);
    if (v10 == v9) {
      break;
    }
  }
  if ((i & v16) == v15) {
    return _dispatch_mach_send_drain(a1, a2, a3, v4, v5, v6, v7, v8);
  }
  return result;
}

void _dispatch_mach_notification_merge_evt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = ~*(void *)(a1 + 8);
  if ((a3 & *(_DWORD *)(a1 + 32)) != 0) {
    _dispatch_mach_send_invoke(v3, 0x40000, 1u);
  }
  _dispatch_release_2_tailcall(v3);
}

uint64_t dispatch_mach_send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_WORD)a3) {
    _dispatch_abort(1906, (unsigned __int16)a3, a3, a4, a5, a6, a7, a8);
  }
  uint64_t result = _dispatch_mach_send_msg(a1, a2, 0, a3 & 0xFFFF0000);
  if (result) {
    _dispatch_abort(1909, !(result & 1), v9, v10, v11, v12, v13, v14);
  }
  return result;
}

uint64_t _dispatch_mach_send_msg(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v46 = *(void *)(a1 + 120);
  if (*(void *)(a2 + 16) != -1985229329)
  {
    uint64_t v4 = *(void *)(a2 + 16);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Message already enqueued";
    qword_F42C0 = v4;
    __break(1u);
    JUMPOUT(0x72C0CLL);
  }
  if ((*(_WORD *)(a1 + 116) & 0x10) != 0 && (a4 & 4) == 0 && _dispatch_mach_msg_get_reply_port(a2))
  {
    uint64_t v55 = (*(uint64_t (**)(void))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(*(void *)(a2 + 32));
    if (!v55) {
      uint64_t v55 = a1;
    }
    if (!v55) {
      _dispatch_abort(1830, 0, v5, v6, v7, v8, v9, v10);
    }
  }
  if ((a4 & 0x40000) != 0)
  {
    *(void *)(a2 + 56) = 0;
  }
  else
  {
    char v52 = 1;
    if ((a4 & 4) != 0) {
      char v52 = 3;
    }
    unint64_t v56 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if ((v52 & 2) != 0 || v56 <= 0x10FF) {
      uint64_t v57 = v56;
    }
    else {
      uint64_t v57 = 4351;
    }
    *(void *)(a2 + 56) = v57;
  }
  int v58 = _dispatch_thread_getspecific(0x1CuLL);
  if (v58) {
    os_retain(v58);
  }
  *(void *)(a2 + 64) = v58;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] set", v11, v12, v13, v14, v15, v16, v17, 1847);
  int v53 = a4 | _dispatch_mach_send_options();
  *(_DWORD *)(a2 + 48) = v53;
  dispatch_retain((dispatch_object_t)a2);
  unint64_t v51 = (*(void *)(a2 + 56) & 0x3FFF00uLL) >> 8;
  unsigned int v18 = __clz(__rbit32(v51));
  if (v51) {
    unsigned int v19 = v18 + 1;
  }
  else {
    unsigned int v19 = 0;
  }
  unsigned int v45 = v19;
  msg = (_DWORD *)_dispatch_mach_msg_get_msg(a2);
  *(_DWORD *)(a2 + 52) = _dispatch_mach_msg_get_reply_port(a2);
  int v41 = 0;
  if (v53) {
    int v41 = 8;
  }
  if ((*msg & 0x1F) != 0x12
    || *(_DWORD *)(a2 + 52)
    || *(_DWORD *)(v46 + 88)
    || (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    if (*(void *)(a2 + 64) != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v40 = a2;
    if (a3) {
      unint64_t v40 = a3;
    }
    char v42 = _dispatch_mach_send_push_and_trydrain(a1, v40, v45, v41);
  }
  else
  {
    if (a3) {
      _dispatch_abort(1879, a3 == 0, v20, v21, v22, v23, v24, v25);
    }
    unsigned int v43 = _dispatch_mach_msg_send(a1, (void *)a2, 0, 0, v41);
    if (!v43) {
      _dispatch_abort(1881, v43, v26, v27, v28, v29, v30, v31);
    }
    char v42 = (v43 & 2) != 0;
  }
  if (v42)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] clear", v32, v33, v34, v35, v36, v37, v38, 1892);
    if (*(void *)(a2 + 64)) {
      os_release(*(void **)(a2 + 64));
    }
    *(void *)(a2 + 64) = 0;
    *(void *)(a2 + 16) = -1985229329;
    dispatch_release((dispatch_object_t)a2);
  }
  return v42 & 1;
}

uint64_t dispatch_mach_send_with_result(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  int v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = (void *)a5;
  uint64_t v12 = (_DWORD *)a6;
  if (a4)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_F42C0 = v14;
    __break(1u);
    JUMPOUT(0x732D4);
  }
  uint64_t v19 = (unsigned __int16)v15;
  uint64_t v18 = 1921;
  if ((_WORD)v15) {
    _dispatch_abort(v18, v19, a3, 0, a5, a6, a7, a8);
  }
  int v15 = (HIWORD(v15) << 16) | 1;
  uint64_t result = _dispatch_mach_send_msg(v17, v16, 0, v15);
  char v11 = result;
  uint64_t v10 = 10;
  int v9 = 0;
  if (result)
  {
    uint64_t result = _dispatch_mach_msg_get_reason(v16, &v9);
    uint64_t v10 = result;
  }
  void *v13 = v10;
  *uint64_t v12 = v9;
  return result;
}

uint64_t _dispatch_mach_msg_get_reason(uint64_t a1, int *a2)
{
  int v4 = *(_DWORD *)(a1 + 48);
  if ((v4 & 0xFC000000) == 0xF8000000 && ((v4 >> 14) & 0xFFF) == 0x3E0)
  {
    *a2 = 0;
    return v4 & 0x3FFF;
  }
  else
  {
    *a2 = v4;
    uint64_t v2 = 4;
    if (!v4) {
      return 3;
    }
    return v2;
  }
}

uint64_t dispatch_mach_send_and_wait_for_reply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  int v17 = a3;
  unsigned __int8 v16 = 0;
  uint64_t v23 = (unsigned __int16)a3;
  uint64_t v22 = 1994;
  if ((_WORD)a3) {
    _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
  }
  v17 &= 0xFFFF0000;
  uint64_t v15 = _dispatch_mach_send_and_wait_for_reply(v19, v18, v17, &v16);
  uint64_t v21 = (v16 ^ 1) & 1;
  uint64_t v20 = 1998;
  if (((v16 ^ 1) & 1) == 0) {
    _dispatch_abort(v20, v21, v8, v9, v10, v11, v12, v13);
  }
  return v15;
}

uint64_t _dispatch_mach_send_and_wait_for_reply(uint64_t a1, uint64_t a2, int a3, unsigned char *a4)
{
  uint64_t v94 = a1;
  uint64_t v93 = a2;
  int v92 = a3;
  uint64_t v91 = a4;
  uint64_t v79 = 0;
  long long v78 = 0u;
  uint64_t v90 = 0;
  long long v89 = 0u;
  long long v88 = 0u;
  memset(v87, 0, sizeof(v87));
  uint64_t v80 = v87;
  *(void *)&v87[0] = -2;
  *(void *)&long long v88 = *(void *)(a2 + 32);
  LODWORD(v9pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = _dispatch_thread_getspecific(3uLL);
  unsigned int v86 = v87;
  mach_port_name_t v85 = 0;
  uint64_t v83 = v93;
  int reply_port = _dispatch_mach_msg_get_reply_port(v93);
  if (!reply_port)
  {
    int reply_port = _dispatch_get_thread_reply_port();
    msg = (_DWORD *)_dispatch_mach_msg_get_msg(v93);
    BOOL v10 = ((*msg >> 8) & 0x1F) == 21;
    BOOL v96 = ((*msg >> 8) & 0x1F) == 21;
    uint64_t v95 = 1956;
    if (!v10) {
      _dispatch_abort(v95, v96, v4, v5, v6, v7, v8, v9);
    }
    msg[3] = reply_port;
    v86[30] = 1;
  }
  v92 |= 4u;
  uint64_t v77 = 1;
  unsigned int v86 = (unsigned char *)_dispatch_calloc();
  __copy_assignment_8_8_S_pa2_27361_0_tv64w64_tv128w64_tv192w32_tv224w8_tv232w1_tv233w1_tv234w1_tv235w1_tv236w1_tv237w1_tv238w1_tv239w1_tv240w8_tv248w8_tv256w32_tv288w32_tv320w32_tv384w64_tv448w64_tv512w128_tv640w32((uint64_t)v86, (uint64_t)v87);
  v81[0] = 1;
  v81[1] = -1;
  v81[2] = 0;
  v81[3] = -1;
  v81[4] = 0;
  v81[5] = 0;
  v81[6] = v93;
  v81[7] = v86;
  char v11 = _dispatch_mach_send_msg(v94, v93, (unint64_t)v81, v92);
  unsigned char *v91 = v11;
  if (v86[30])
  {
    _dispatch_clear_thread_reply_port(reply_port);
    mach_port_name_t v85 = *(_DWORD *)(*(void *)(v94 + 120) + 92);
  }
  int v75 = &v60;
  uint64_t v115 = v94;
  uint64_t v114 = v86;
  mach_port_name_t v113 = reply_port;
  mach_port_name_t v112 = v85;
  BOOL v76 = 0;
  if (reply_port) {
    BOOL v76 = v113 != -1;
  }
  if (!v76)
  {
    uint64_t v111 = v113;
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid reply port";
    qword_F42C0 = v113;
    __break(1u);
    JUMPOUT(0x737E0);
  }
  uint64_t v73 = 0;
  uint64_t v110 = 0;
  uint64_t v110 = v114[6];
  uint64_t v109 = 0;
  uint64_t v108 = 0;
  *(_DWORD *)&v107[8] = 0;
  mach_msg_size_t v106 = 0;
  mach_error_t v105 = 0;
  unsigned int v104 = 0;
  mach_port_name_t v103 = 0;
  uint64_t v74 = &vm_page_mask;
  *(void *)unint64_t v107 = (vm_page_mask + 0x4000) & ~vm_page_mask;
  uint64_t v72 = (mach_msg_header_t *)((char *)&v60 - ((*(unsigned int *)v107 + 15) & 0x1FFFFFFF0));
  bzero(v72, *(unsigned int *)v107);
  uint64_t v109 = v72;
  uint64_t v121 = v72;
  uint64_t v120 = *(unsigned int *)v107;
  uint64_t i = v73;
  for (uint64_t i = (unsigned char *)(((unint64_t)v72 + vm_page_size) & ~*(_DWORD *)v74); i < (unsigned char *)v121 + v120; i += vm_page_size)
    *uint64_t i = 0;
  unsigned int v104 = 117440526;
  if (v112 && v112 != -1)
  {
    mach_port_name_t v103 = v112;
    v104 |= 0x4000u;
  }
  if ((*(_WORD *)(v115 + 116) & 0x80) != 0) {
    v104 |= 0x200u;
  }
  while (1)
  {
    pthread_key_t v66 = 0;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: MACH_RCV_MSG %s", v12, v13, v14, v15, v16, v17, v18, 815);
    mach_error_t v105 = mach_msg(v109, v104, 0, *(mach_msg_size_t *)v107, v113, 0, v103);
    *(void *)&v107[4] = v109;
    int v70 = _dispatch_thread_getspecific(v66);
    uint64_t v69 = v113;
    uint64_t v68 = *(unsigned int *)v107;
    uint64_t v67 = v104;
    mach_error_string(v105);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: MACH_RCV_MSG (size %u, opts 0x%x) returned: %s - 0x%x", v19, v20, v21, v22, v23, v24, v25, 822);
    mach_error_t v71 = v105;
    if (!v105) {
      break;
    }
    if (v71 == 268451842) {
      goto LABEL_34;
    }
    if (v71 != 268451844)
    {
      if (v71 != 268451846 && v71 != 268451849)
      {
        uint64_t v98 = v105;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from mach_msg_receive";
        qword_F42C0 = v105;
        __break(1u);
        JUMPOUT(0x73DF0);
      }
LABEL_34:
      uint64_t v65 = _dispatch_thread_getspecific(0);
      uint64_t v63 = v110;
      uint64_t v64 = v113;
      mach_error_string(v105);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: sync reply port destroyed, ctxt %p: %s - 0x%x", v39, v40, v41, v42, v43, v44, v45, 849);
      if (*((unsigned char *)v114 + 30)) {
        _dispatch_destruct_reply_port();
      }
LABEL_52:
      free(v108);
      uint64_t v116 = 0;
      goto LABEL_53;
    }
    if (v109->msgh_size >= 0xFFFFFFBC)
    {
      uint64_t msgh_size = 0;
      uint64_t msgh_size = v109->msgh_size;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Overlarge message";
      qword_F42C0 = msgh_size;
      __break(1u);
      JUMPOUT(0x73B4CLL);
    }
    if ((v104 & 4) == 0)
    {
      _dispatch_log("BUG in libdispatch client: dispatch_mach_send_and_wait_for_reply: dropped message too large to fit in memory: id = 0x%x, size = %u", v26, v27, v28, v29, v30, v31, v32, v109->msgh_id);
      goto LABEL_41;
    }
    mach_msg_size_t v106 = v109->msgh_size + 68;
    uint64_t v108 = (mach_msg_header_t *)malloc_type_malloc();
    unsigned int v101 = v108;
    uint64_t v118 = v108;
    uint64_t v117 = 831;
    if (!v108) {
      _dispatch_bug(v117, 0, v33, v34, v35, v36, v37, v38);
    }
    unsigned int v100 = v101;
    if (v101)
    {
      uint64_t v109 = v108;
      *(_DWORD *)unint64_t v107 = v106;
    }
    v104 |= 0x100u;
    v104 &= ~4u;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: received msg id 0x%x, size = %u, reply on 0x%08x", v46, v47, v48, v49, v50, v51, v52, 861);
  *(_DWORD *)unint64_t v107 = v109->msgh_size + 68;
  if (v108)
  {
    if (*(_DWORD *)v107 < v106)
    {
      uint64_t v99 = 0;
      uint64_t v99 = (mach_msg_header_t *)malloc_type_realloc();
      if (v99)
      {
        uint64_t v108 = v99;
        uint64_t v109 = v99;
      }
    }
  }
LABEL_41:
  _dispatch_mach_msg_reply_received(v115, (uint64_t)v114, v109->msgh_local_port);
  v109->msgh_local_port = 0;
  int v57 = *(_DWORD *)(v115 + 80);
  BOOL v62 = 1;
  if ((v57 & 0x10000000) == 0) {
    BOOL v62 = v105 != 0;
  }
  if (v62)
  {
    if (!v105) {
      mach_msg_destroy(v109);
    }
    goto LABEL_52;
  }
  *(_DWORD *)&v97[8] = 0;
  *(void *)uint64_t v97 = v108 != 0;
  *(void *)&v97[4] = dispatch_mach_msg_create((uint64_t)v109, *(unsigned int *)v107, *(uint64_t *)v97, 0, v53, v54, v55, v56);
  if (!v108 || v109 != *(mach_msg_header_t **)&v107[4])
  {
    uint64_t v61 = *(void *)&v107[4];
    uint64_t v58 = _dispatch_mach_msg_get_msg(*(uint64_t *)&v97[4]);
    int v126 = 771948548;
    uint64_t v125 = v61;
    uint64_t v124 = v58;
    uint64_t v123 = 0;
    uint64_t v122 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
  }
  *(void *)(*(void *)&v97[4] + 32) = v110;
  uint64_t v116 = *(void *)&v97[4];
LABEL_53:
  uint64_t v93 = v116;
  free(v86);
  return v93;
}

uint64_t dispatch_mach_send_with_result_and_wait_for_reply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = a1;
  uint64_t v17 = a2;
  int v16 = a3;
  uint64_t v15 = a4;
  uint64_t v14 = (void *)a5;
  uint64_t v13 = (_DWORD *)a6;
  if (a4)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_F42C0 = v15;
    __break(1u);
    JUMPOUT(0x7402CLL);
  }
  char v12 = 0;
  uint64_t v11 = 0;
  uint64_t v20 = (unsigned __int16)v16;
  uint64_t v19 = 2014;
  if ((_WORD)v16) {
    _dispatch_abort(v19, v20, a3, 0, a5, a6, a7, a8);
  }
  int v16 = HIWORD(v16) << 16;
  v16 |= 1u;
  uint64_t v11 = _dispatch_mach_send_and_wait_for_reply(v18, v17, v16, &v12);
  uint64_t reason = 10;
  int v9 = 0;
  if (v12) {
    uint64_t reason = _dispatch_mach_msg_get_reason(v17, &v9);
  }
  *uint64_t v14 = reason;
  _DWORD *v13 = v9;
  return v11;
}

uint64_t dispatch_mach_send_with_result_and_async_reply_4libxpc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  int v17 = a3;
  uint64_t v16 = a4;
  uint64_t v15 = (void *)a5;
  uint64_t v14 = (_DWORD *)a6;
  if (a4)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_F42C0 = v16;
    __break(1u);
    JUMPOUT(0x74170);
  }
  if ((*(_WORD *)(v19 + 116) & 0x10) == 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_send_with_result_and_wait_for_reply is XPC only";
    __break(1u);
    JUMPOUT(0x741ACLL);
  }
  uint64_t v21 = (unsigned __int16)v17;
  uint64_t v20 = 2044;
  if ((_WORD)v17) {
    _dispatch_abort(v20, v21, a3, 0, a5, a6, a7, a8);
  }
  int v17 = (HIWORD(v17) << 16) | 1;
  uint64_t v12 = v18;
  if (!_dispatch_mach_msg_get_reply_port(v18))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Reply port needed for async send with reply";
    __break(1u);
    JUMPOUT(0x74240);
  }
  uint64_t result = _dispatch_mach_send_msg(v19, v18, 0, v17);
  char v11 = result;
  uint64_t v10 = 10;
  int v9 = 0;
  if (result)
  {
    uint64_t result = _dispatch_mach_msg_get_reason(v18, &v9);
    uint64_t v10 = result;
  }
  *uint64_t v15 = v10;
  *uint64_t v14 = v9;
  return result;
}

uint64_t _dispatch_mach_msg_get_reply_port(uint64_t a1)
{
  msg = (_DWORD *)_dispatch_mach_msg_get_msg(a1);
  int v2 = msg[3];
  if (v2 && v2 != -1 && (*msg & 0x1F00u) >> 8 == 21) {
    return msg[3];
  }
  else {
    return 0;
  }
}

void dispatch_mach_reconnect(uint64_t a1, unsigned int a2, dispatch_object_s *a3)
{
  uint64_t v5 = (uint64_t)a3;
  uint64_t v4 = *(void *)(a1 + 120);
  atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 88), 1u, memory_order_relaxed);
  if (a2 && a2 != -1 && a3)
  {
    dispatch_retain(a3);
    *(_DWORD *)(v5 + 48) = _dispatch_mach_checkin_options();
    *(_DWORD *)(v4 + 96) = _dispatch_mach_msg_get_remote_port(v5);
  }
  else
  {
    if (a3 != (dispatch_object_s *)-1) {
      uint64_t v5 = 0;
    }
    *(_DWORD *)(v4 + 96) = 0;
  }
  int v9 = _dispatch_thread_getspecific(0x16uLL);
  if (v9)
  {
    _dispatch_thread_setspecific(22, v9[2]);
    unint64_t v8 = (unint64_t)v9;
  }
  else
  {
    unint64_t v8 = _dispatch_continuation_alloc_from_heap();
  }
  *(void *)unint64_t v8 = 260;
  uint64_t v3 = 0;
  if (_dispatch_mach_reconnect_invoke) {
    uint64_t v3 = _dispatch_mach_reconnect_invoke;
  }
  *(void *)(v8 + 32) = v3;
  *(void *)(v8 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v8;
  *(void *)(v8 + 48) = v5;
  *(void *)(v8 + 56) = a2;
  *(void *)(v8 + 24) = -1;
  *(void *)(v8 + 8) = -1;
  _dispatch_mach_send_push(a1, (void **)v8, 0);
}

BOOL _dispatch_mach_reconnect_invoke(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v42 = a2;
  uint64_t v41 = a1;
  uint64_t v40 = a1;
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_reconnect_invoke");
  uint64_t v39 = 0;
  uint64_t v39 = v41[15];
  uint64_t v38 = v39;
  uint64_t v50 = v39;
  uint64_t v49 = 0;
  uint64_t v48 = *(void *)(v39 + 16);
  uint64_t v49 = v48;
  uint64_t v47 = v48;
  uint64_t v51 = v48;
  if (v48)
  {
    uint64_t v82 = (uint64_t)v41;
    int v81 = 5;
    dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
    uint64_t v80 = v41[15];
    _dispatch_unote_unregister(v80, 5, v13, v14, v15, v16, v17, v18);
    *(_DWORD *)(v41[15] + 24) = 0;
  }
  if (*(_DWORD *)(v39 + 92) && *(_DWORD *)(v39 + 92) != -1)
  {
    _dispatch_mach_msg_disconnected((uint64_t)v41, 0, *(_DWORD *)(v39 + 92), v8, v9, v10, v11, v12);
    *(_DWORD *)(v39 + 92) = 0;
  }
  if (*(void *)(v39 + 48))
  {
    uint64_t v37 = *(dispatch_object_s **)(v39 + 48);
    _dispatch_mach_msg_not_sent((uint64_t)v41, v37, 0);
    *(void *)(v39 + 48) = 0;
  }
  *((_WORD *)v41 + 59) &= ~1u;
  uint64_t i = 0;
  uint64_t v35 = 0;
  uint64_t v34 = 0;
  char v32 = -112;
  uint64_t v46 = (uint64_t)v41;
  int v45 = 0;
  int v44 = *((_DWORD *)v41 + 20);
  int v45 = v44;
  int v43 = v44;
  if ((v44 & 0x40000000) == 0) {
    char v32 = -110;
  }
  uint64_t v65 = (atomic_uint *)(v39 + 40);
  unsigned int v67 = _dispatch_thread_getspecific(3uLL);
  unsigned int v64 = v67 & 0xFFFFFFFC;
  int v63 = 0;
  BOOL v62 = 0;
  unsigned int v60 = v67 & 0xFFFFFFFC;
  unsigned int v59 = v67 & 0xFFFFFFFC;
  unsigned int v61 = v67 & 0xFFFFFFFC;
  int v19 = 0;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v39 + 40), (unsigned int *)&v19, v67 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
  if (v19) {
    int v63 = v19;
  }
  BOOL v58 = v19 == 0;
  BOOL v62 = v19 == 0;
  BOOL v57 = v62;
  if (v19) {
    _dispatch_unfair_lock_lock_slow(v65);
  }
  uint64_t v30 = v34;
  uint64_t v34 = *(void *)(v39 + 56);
  *(void *)(v39 + 56) = v30;
  if (v34) {
    *(void *)(v34 + 72) = &v34;
  }
  uint64_t v31 = *(void *)(v39 + 56);
  if (v31) {
    *(void *)(v31 + 72) = v39 + 56;
  }
  for (uint64_t i = v34; ; uint64_t i = v35)
  {
    char v27 = 0;
    if (i)
    {
      uint64_t v35 = *(void *)(i + 64);
      char v27 = 1;
    }
    if ((v27 & 1) == 0) {
      break;
    }
    *(void *)(i + 72) = 0;
    _dispatch_mach_reply_unregister((uint64_t)v41, i, v32);
  }
  BOOL v33 = *(void *)(v39 + 56) == 0;
  uint64_t v66 = v39 + 40;
  BOOL v76 = (atomic_uint *)(v39 + 40);
  unsigned int v75 = 0;
  unsigned int v74 = 0;
  unsigned int v78 = _dispatch_thread_getspecific(3uLL);
  unsigned int v74 = v78 & 0xFFFFFFFC;
  unsigned int v73 = 0;
  int v71 = 0;
  int v70 = 0;
  int v72 = 0;
  unsigned int v69 = atomic_exchange_explicit(v76, 0, memory_order_release);
  unsigned int v73 = v69;
  unsigned int v68 = v69;
  unsigned int v75 = v69;
  if (v69 == v74)
  {
    BOOL v77 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)v76, v75);
    unsigned int v79 = v75;
    BOOL v77 = (v75 & 2) != 0;
  }
  if (v33)
  {
    int v29 = v42[7];
    uint64_t v28 = (dispatch_object_s *)v42[6];
    uint64_t v52 = v42;
    uint64_t v55 = v42;
    uint64_t v54 = 0;
    uint64_t v54 = _dispatch_thread_getspecific(0x16uLL);
    int v53 = 0;
    if (v54) {
      int v26 = v54[2] + 1;
    }
    else {
      int v26 = 1;
    }
    int v53 = v26;
    if (v26 <= _dispatch_continuation_cache_limit)
    {
      v55[2] = v54;
      *((_DWORD *)v55 + 2) = v53;
      _dispatch_thread_setspecific(22, (uint64_t)v55);
      uint64_t v56 = 0;
    }
    else
    {
      uint64_t v56 = v55;
    }
    uint64_t v52 = v56;
    if (v56) {
      _dispatch_continuation_free_to_cache_limit(v52);
    }
    if (v28 == (dispatch_object_s *)-1)
    {
      *((_WORD *)v41 + 59) = *((_WORD *)v41 + 59) & 0xFFFD | 2;
      uint64_t v28 = 0;
    }
    if ((*((_WORD *)v41 + 59) >> 1))
    {
      if (v29 && v29 != -1) {
        _dispatch_mach_msg_disconnected((uint64_t)v41, 0, v29, v20, v21, v22, v23, v24);
      }
      if (v28) {
        _dispatch_mach_msg_not_sent((uint64_t)v41, v28, 0);
      }
    }
    else
    {
      *(_DWORD *)(v39 + 92) = v29;
      *(void *)(v39 + 48) = v28;
    }
    atomic_fetch_add_explicit((atomic_uint *volatile)(v39 + 88), 0xFFFFFFFF, memory_order_relaxed);
  }
  return v33;
}

void _dispatch_mach_send_push(uint64_t a1, void **a2, unsigned int a3)
{
  uint64_t v17 = *(void *)(a1 + 120);
  uint64_t v14 = 0;
  LODWORD(v12) = 0;
  BOOL v11 = 0;
  if ((unint64_t)*a2 > 0xFFF)
  {
    uint64_t v10 = 0;
    if (*a2) {
      uint64_t v10 = *a2;
    }
    BOOL v11 = v10 == &unk_ECCC8;
  }
  a2[2] = 0;
  _dispatch_thread_setspecific(122, v17 + 72);
  unint64_t v13 = atomic_exchange_explicit((atomic_ullong *volatile)(v17 + 72), (unint64_t)a2, memory_order_release);
  if (v13) {
    unsigned int v3 = 2;
  }
  else {
    unsigned int v3 = 4;
  }
  _dispatch_retain_n_unsafe(a1, v3);
  if (v13) {
    *(void *)(v13 + 16) = a2;
  }
  else {
    *(void *)(v17 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = a2;
  }
  _dispatch_thread_setspecific(122, 0);
  if (v13)
  {
    for (unint64_t i = *(void *)(v17 + 64); ; unint64_t i = v7)
    {
      unint64_t v22 = i;
      if ((i & 0x700000000) < (unint64_t)a3 << 32) {
        unint64_t v22 = i & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      }
      unint64_t v15 = v22;
      if (i == v22) {
        break;
      }
      unint64_t v6 = i;
      unint64_t v7 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v17 + 64), &v7, v22, memory_order_relaxed, memory_order_relaxed);
      if (v7 == v6) {
        break;
      }
    }
  }
  else
  {
    uint64_t v14 = 0xA000000000;
    uint64_t v12 = 2;
    if (v11) {
      uint64_t v14 = 0xB000000000;
    }
    for (unint64_t i = *(void *)(v17 + 64); ; unint64_t i = v5)
    {
      unint64_t v23 = i;
      if ((i & 0x700000000) < (unint64_t)a3 << 32) {
        unint64_t v23 = i & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      }
      unint64_t v15 = v23 | v14;
      unint64_t v4 = i;
      unint64_t v5 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v17 + 64), &v5, v23 | v14, memory_order_release, memory_order_relaxed);
      if (v5 == v4) {
        break;
      }
    }
    if (((i ^ v15) & 0x8000000000) == 0) {
      _dispatch_release_2_no_dispose(a1);
    }
  }
  unsigned int v19 = (v15 & 0x700000000) >> 32;
  if ((i & 0xFFFFFFFC) != 0) {
    int v24 = i | 3;
  }
  else {
    int v24 = 0;
  }
  if (v24)
  {
    if (i & 0x700000000) < (unint64_t)v19 << 32 && (_dispatch_set_qos_class_enabled) {
      _pthread_workqueue_override_start_direct_check_owner();
    }
    goto LABEL_47;
  }
  if ((v14 & 0x1000000000) != 0)
  {
    _dispatch_mach_push_send_barrier_drain(a1, v19);
LABEL_47:
    _dispatch_release_2_tailcall(a1);
    return;
  }
  if (v12 || *(_DWORD *)(v17 + 88) || (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    uint64_t v9 = 0;
    if (*(void *)a1) {
      uint64_t v9 = *(void *)a1;
    }
    (*(void (**)(uint64_t, void, void))(v9 + 64))(a1, v19, v12 | 1);
  }
  else
  {
    if ((i & 0x1000000000) == 0) {
      goto LABEL_47;
    }
    uint64_t v8 = 0;
    if (*(void *)a1) {
      uint64_t v8 = *(void *)a1;
    }
    (*(void (**)(uint64_t, void, uint64_t))(v8 + 64))(a1, v19, 1);
  }
}

uint64_t dispatch_mach_get_checkin_port(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0) {
    return -1;
  }
  else {
    return *(unsigned int *)(*(void *)(a1 + 120) + 96);
  }
}

BOOL dispatch_mach_can_handoff_4libxpc()
{
  for (unint64_t i = (char *)_dispatch_thread_getspecific(0x17uLL); i; unint64_t i = *(char **)i)
  {
    if (*((char **)i + 1) == "mach_msg")
    {
      unsigned int v3 = i;
      goto LABEL_7;
    }
  }
  unsigned int v3 = 0;
LABEL_7:
  BOOL v1 = 0;
  if (v3)
  {
    BOOL v1 = 0;
    if (*((void *)v3 + 2)) {
      return *(void *)(*((void *)v3 + 2) + 56) == 0;
    }
  }
  return v1;
}

void dispatch_mach_handoff_reply_f(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  unint64_t v15 = _dispatch_mach_handoff_context(a2);
  uint64_t v14 = (void *)v15[2];
  _dispatch_mach_handoff_set_wlh((uint64_t)v14, a1);
  _dispatch_retain(a1);
  v15[3] = a1;
  *uint64_t v14 = 260;
  v14[4] = a4;
  v14[5] = a3;
  unint64_t v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v21 <= 0x10FF) {
    unint64_t v22 = v21;
  }
  else {
    unint64_t v22 = 4351;
  }
  unint64_t v23 = _dispatch_thread_getspecific(0x1CuLL);
  if (v23) {
    os_retain(v23);
  }
  v14[3] = v23;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  if (v14[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  unint64_t v20 = v22;
  unsigned int v19 = 0;
  if (v22)
  {
    if ((*(_DWORD *)(a1 + 84) & 0x40000000) != 0 || (*(_DWORD *)(a1 + 84) & 0xFFF) == 0)
    {
      unsigned int v11 = v22 >> 8;
      unsigned int v12 = __clz(__rbit32(v11));
      if (v11) {
        unsigned int v13 = v12 + 1;
      }
      else {
        unsigned int v13 = 0;
      }
      unsigned int v19 = v13;
    }
    else
    {
      unint64_t v20 = 0;
    }
  }
  v14[1] = v20;
  *((_DWORD *)v15 + 8) = v19;
  *uint64_t v14 = &unk_ECE18;
}

void *_dispatch_mach_handoff_context(unsigned int a1)
{
  for (unint64_t i = _dispatch_thread_getspecific(0x17uLL); i; unint64_t i = (void *)*i)
  {
    if (i[1] == (void)"mach_msg")
    {
      uint64_t v7 = i;
      goto LABEL_7;
    }
  }
  uint64_t v7 = 0;
LABEL_7:
  if (!v7 || !v7[2])
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Trying to handoff IPC from non IPC context";
    __break(1u);
    JUMPOUT(0x75FD8);
  }
  BOOL v1 = (uint64_t *)v7[2];
  uint64_t v3 = 0;
  if (*v1) {
    uint64_t v3 = *v1;
  }
  if (*(void *)(v3 + 16) == 515)
  {
    v7[2] = _dispatch_calloc();
    uint64_t v4 = v7[2];
    *(_DWORD *)(v4 + 72) = 1;
  }
  else
  {
    uint64_t v4 = v7[2];
    atomic_fetch_add_explicit((atomic_uint *volatile)(v4 + 72), 1u, memory_order_relaxed);
  }
  if (*(void *)(v4 + 56))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Calling dispatch_mach_handoff_reply multiple times from the same context";
    __break(1u);
    JUMPOUT(0x75FA8);
  }
  *(void *)(v4 + 56) = a1;
  return v7;
}

uint64_t _dispatch_mach_handoff_set_wlh(uint64_t result, uint64_t a2)
{
  uint64_t v4 = result;
  while (*(void *)(a2 + 24))
  {
    if ((*(_DWORD *)(a2 + 80) & 0x400000) != 0)
    {
      unsigned int v5 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      int v2 = 0;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a2 + 100), (unsigned int *)&v2, v5, memory_order_acquire, memory_order_acquire);
      if (v2) {
        _dispatch_unfair_lock_lock_slow((atomic_uint *)(a2 + 100));
      }
      atomic_fetch_and_explicit((atomic_uint *volatile)(a2 + 80), 0xFFBFFFFF, memory_order_relaxed);
      uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
      unsigned int v6 = atomic_exchange_explicit((atomic_uint *volatile)(a2 + 100), 0, memory_order_release);
      if (v6 == (result & 0xFFFFFFFC))
      {
        BOOL v7 = 0;
      }
      else
      {
        uint64_t result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a2 + 100, v6);
        BOOL v7 = (v6 & 2) != 0;
      }
      if (v7)
      {
        uint64_t result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
        if (!((result & 0xF0000) >> 16)) {
          uint64_t result = _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
        }
      }
    }
    if ((*(void *)(a2 + 56) & 0x2000000000) != 0)
    {
      *(void *)(v4 + 64) = a2;
      return result;
    }
    a2 = *(void *)(a2 + 24);
  }
  *(void *)(v4 + 64) = 0;
  return result;
}

void dispatch_mach_handoff_reply(unint64_t a1, unsigned int a2, const void *a3)
{
  uint64_t v16 = _dispatch_mach_handoff_context(a2);
  unint64_t v15 = (uint64_t *)v16[2];
  _dispatch_mach_handoff_set_wlh((uint64_t)v15, a1);
  _dispatch_retain(a1);
  v16[3] = a1;
  unsigned int v19 = _dispatch_Block_copy(a3);
  uint64_t v13 = _Block_get_invoke_fn((uint64_t)a3);
  uint64_t v14 = 0;
  if (v13) {
    uint64_t v14 = (uint64_t (*)())v13;
  }
  if (v14 == _dispatch_block_special_invoke)
  {
    *unint64_t v15 = 276;
    v15[5] = (uint64_t)v19;
    int inited = _dispatch_continuation_init_slow(v15, a1, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)a3);
    *unint64_t v15 = 276;
    v15[4] = (uint64_t)_dispatch_call_block_and_release;
    v15[5] = (uint64_t)v19;
    unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v23 <= 0x10FF) {
      unint64_t v24 = v23;
    }
    else {
      unint64_t v24 = 4351;
    }
    uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
    if (v25) {
      os_retain(v25);
    }
    v15[3] = (uint64_t)v25;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    if (v15[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v22 = v24;
    unsigned int v21 = 0;
    if (v24)
    {
      if ((*(_DWORD *)(a1 + 84) & 0x40000000) != 0 || (*(_DWORD *)(a1 + 84) & 0xFFF) == 0)
      {
        unsigned int v10 = v24 >> 8;
        unsigned int v11 = __clz(__rbit32(v10));
        if (v10) {
          unsigned int v12 = v11 + 1;
        }
        else {
          unsigned int v12 = 0;
        }
        unsigned int v21 = v12;
      }
      else
      {
        unint64_t v22 = 0;
      }
    }
    v15[1] = v22;
    int inited = v21;
  }
  *((_DWORD *)v16 + 8) = inited;
  v15[6] = *v15;
  *unint64_t v15 = (uint64_t)&unk_ECE18;
}

void _dispatch_mach_ipc_handoff_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v42 = (void *)a1;
  uint64_t v41 = a2;
  int v40 = a3;
  uint64_t v39 = a1;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0;
  __b[1] = "mach_msg";
  __b[2] = v39;
  __b[3] = 0;
  LODWORD(__b[4]) = 0;
  uint64_t v37 = _dispatch_thread_getspecific(0x14uLL);
  uint64_t v36 = v42[6];
  unsigned int v35 = v42[7];
  uint64_t v34 = __swp(0, (unsigned int *)(v39 + 64));
  if (v34)
  {
    if (v34) {
      uint64_t v34 = ~v34;
    }
    else {
      _dispatch_sync_ipc_handoff_begin(v34, v35, v39 + 64);
    }
  }
  _OWORD v42[2] = -1985229329;
  v42[7] = 0;
  uint64_t v54 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v54);
  BOOL v33 = v42;
  uint64_t v46 = v42;
  uint64_t v45 = v36;
  int v44 = 0;
  int v44 = (_DWORD *)v42[3];
  uint64_t v43 = v36 & 4;
  uint64_t v48 = 1;
  uint64_t v47 = 600;
  if ((v36 & 4) != 0) {
    v46[3] = -1;
  }
  if (v44 != (_DWORD *)-1)
  {
    int v68 = 771817480;
    unsigned int v67 = v44;
    uint64_t v66 = v46;
    unsigned int v65 = 0;
    if (v44) {
      unsigned int v31 = v67[8];
    }
    else {
      unsigned int v31 = 0;
    }
    unsigned int v65 = v31;
    int v73 = v68;
    uint64_t v72 = v31;
    int v71 = v66;
    uint64_t v70 = 0;
    uint64_t v69 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v9, v10, v11, v12, v13, v14, v15, 607);
  }
  unint64_t v77 = v46[1];
  uint64_t v76 = (uint64_t)v44;
  uint64_t v75 = v43 | 2;
  uint64_t v74 = 0;
  if (v77 != -1)
  {
    unint64_t v84 = v77;
    uint64_t v83 = v75;
    unsigned int v82 = 0;
    unsigned int v82 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v81 = 0;
    unsigned int v97 = v82;
    unsigned int v100 = v82 & 0xF00;
    unsigned int v96 = v100 >> 8;
    uint64_t v95 = v82;
    if (v100 >> 8) {
      v95 |= 1 << (v96 + 7);
    }
    uint64_t v81 = v95;
    uint64_t v98 = v95;
    unint64_t v80 = v95 & 0xFFFFFF00;
    BOOL v79 = 0;
    BOOL v30 = 1;
    if ((v83 & 1) == 0) {
      BOOL v30 = (v84 & 0x10000000) != 0;
    }
    BOOL v79 = v30;
    unint64_t v86 = v84;
    v84 &= 0xFFFFFFu;
    if (v84)
    {
      if (v84 >= v80)
      {
        if (v79 || (v82 & 0x44000000) != 0) {
          uint64_t v85 = v84;
        }
        else {
          uint64_t v85 = v81;
        }
      }
      else
      {
        uint64_t v85 = v81;
      }
    }
    else
    {
      unsigned int v99 = v82 & 0xF000;
      unsigned int v78 = v99 >> 12;
      if (v99 >> 12)
      {
        unsigned int v88 = v78;
        uint64_t v87 = 1 << (v78 + 7);
        uint64_t v29 = v87 | 0xFF;
      }
      else
      {
        uint64_t v29 = v81;
      }
      uint64_t v85 = v29;
    }
    uint64_t v74 = v85;
  }
  uint64_t v92 = v74;
  uint64_t v91 = v76;
  uint64_t v90 = v75;
  uint64_t v104 = v74;
  BOOL v107 = v74 != -1;
  uint64_t v106 = 2395;
  if (v74 == -1) {
    _dispatch_abort(v106, v107, v3, v4, v5, v6, v7, v8);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v118 = v104;
    uint64_t v117 = 4261412863;
    uint64_t v116 = 0;
    v104 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v103 = 0;
    uint64_t v108 = 0;
    uint64_t v108 = _dispatch_thread_getspecific(4uLL);
    unint64_t v103 = (unint64_t)v108;
    uint64_t v102 = 0x1000000;
    uint64_t v101 = 2281701376;
    if ((v108 & 0x1000000) != 0)
    {
      if (v104)
      {
        uint64_t v28 = v104;
      }
      else
      {
        unint64_t v112 = v103;
        uint64_t v111 = v102;
        uint64_t v110 = 0;
        uint64_t v28 = v103 & (~v102 | 0xFFFFFF);
      }
      uint64_t v105 = v28;
    }
    else
    {
      unint64_t v115 = v103;
      uint64_t v114 = v101;
      uint64_t v113 = 0;
      v103 &= ~v101 | 0xFFFFFF;
      if (v104 == v103) {
        uint64_t v105 = 0;
      }
      else {
        uint64_t v105 = v104;
      }
    }
  }
  else
  {
    uint64_t v105 = 0;
  }
  uint64_t v92 = v105;
  if (v105) {
    goto LABEL_56;
  }
  if (v91 == -1)
  {
    uint64_t v93 = -1;
    goto LABEL_57;
  }
  char v27 = (void *)v91;
  if (v27 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_56:
    uint64_t v93 = _dispatch_set_priority_and_voucher_slow(v92, (_DWORD *)v91, v90);
  }
  else
  {
    BOOL v89 = (v90 & 4) != 0;
    if ((v90 & 2) != 0)
    {
      if (v89 && v91)
      {
        uint64_t v109 = v91;
        os_release((void *)v91);
      }
      uint64_t v91 = -1;
    }
    else if (!v89 && v91)
    {
      object = (void *)v91;
      os_retain((void *)v91);
    }
    uint64_t v93 = v91;
  }
LABEL_57:
  if ((v36 & 0x200) == 0)
  {
    uint64_t v52 = v37;
    uint64_t v51 = v42;
    int v50 = 0;
    int v49 = 0;
    uint64_t v120 = v37;
    unint64_t v119 = v42;
  }
  uint64_t v32 = 0;
  if ((v40 & 0x1000000) != 0) {
    uint64_t v32 = _dispatch_autorelease_pool_push();
  }
  uint64_t v16 = (uint64_t (*)(uint64_t))v42[4];
  uint64_t v61 = v42[5];
  unsigned int v60 = v16;
  unsigned int v59 = 0;
  if ((char *)v16 == (char *)_dispatch_call_block_and_release && v61)
  {
    uint64_t v25 = _Block_get_invoke_fn(v61);
    int v26 = 0;
    if (v25) {
      int v26 = (uint64_t (*)(uint64_t))v25;
    }
    unint64_t v24 = v26;
  }
  else
  {
    unint64_t v24 = v60;
  }
  unsigned int v59 = v24;
  uint64_t v129 = v61;
  uint64_t v128 = v24;
  int v58 = 0;
  int v57 = 0;
  int v56 = 0;
  int v55 = 0;
  _dispatch_client_callout(v61, v60);
  uint64_t v131 = v61;
  int v130 = v59;
  if (v32) {
    _dispatch_autorelease_pool_pop(v32);
  }
  if ((v36 & 0x200) == 0)
  {
    int v53 = v33;
    uint64_t v121 = v33;
    int v126 = 772079660;
    uint64_t v125 = v33;
    uint64_t v124 = 0;
    uint64_t v123 = 0;
    uint64_t v122 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v127 = v53;
  }
  BOOL v62 = __b;
  BOOL v23 = _dispatch_thread_getspecific(0x17uLL) == __b;
  BOOL v64 = v23;
  uint64_t v63 = 449;
  if (!v23) {
    _dispatch_abort(v63, v64, v17, v18, v19, v20, v21, v22);
  }
  _dispatch_thread_setspecific(23, *v62);
  if (__b[3]) {
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  }
  else {
    _dispatch_ipc_handoff_release(v39);
  }
  if (v34) {
    _dispatch_sync_ipc_handoff_end(v34, v35);
  }
}

void _dispatch_mach_ipc_handoff_async(uint64_t a1)
{
  uint64_t v5 = *(void *)(a1 + 16);
  unsigned int v4 = *(void *)(v5 + 56);
  uint64_t v3 = *(void *)(v5 + 64);
  uint64_t v2 = 0;
  if (**(void **)(a1 + 24)) {
    uint64_t v2 = **(void **)(a1 + 24);
  }
  (*(void (**)(void, void, void))(v2 + 72))(*(void *)(a1 + 24), *(void *)(a1 + 16), *(unsigned int *)(a1 + 32));
  if (v3)
  {
    _dispatch_sync_ipc_handoff_begin(v3, v4, v5 + 64);
    uint64_t v1 = v3;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v5 + 64), (unint64_t *)&v1, ~v3, memory_order_relaxed, memory_order_relaxed);
  }
  _dispatch_ipc_handoff_release(v5);
  _dispatch_release_tailcall(*(void *)(a1 + 24));
}

void _dispatch_ipc_handoff_release(uint64_t a1)
{
  if (!atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 72), 0xFFFFFFFF, memory_order_relaxed)) {
    free((void *)a1);
  }
}

uint64_t _dispatch_mach_msg_invoke(dispatch_object_s *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v57 = a1;
  uint64_t v56 = a2;
  int v55 = a3;
  long long v54 = 0uLL;
  unsigned int v60 = (uint64_t *)&v54;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v54, 0x15uLL, (pthread_key_t *)&v54 + 1, a5, a6, a7, a8);
  unsigned int v100 = (_OWORD *)v60[1];
  _dispatch_thread_setspecific_packed_pair(20, 21, v100, v8, v9, v10, v11, v12);
  uint64_t v58 = *v60;
  uint64_t v59 = v58;
  uint64_t v76 = v57;
  int v75 = v55;
  uint64_t v74 = v58;
  uint64_t v73 = 0;
  unsigned int v72 = 0;
  uint64_t reason = 0;
  uint64_t reason = _dispatch_mach_msg_get_reason((uint64_t)v57, (int *)&v72);
  uint64_t v70 = 7;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0;
  __b[1] = "mach_msg";
  __b[2] = v76;
  __b[3] = 0;
  LODWORD(__b[4]) = 0;
  unint64_t v86 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v86);
  uint64_t v68 = v74;
  unsigned int v67 = v76;
  uint64_t v84 = v74;
  uint64_t v83 = v76;
  int v82 = 0;
  int v81 = 0;
  uint64_t v147 = v74;
  unint64_t v146 = v76;
  uint64_t v73 = *(void *)(v74 + 88);
  *((void *)v76 + 2) = -1985229329;
  uint64_t v13 = *((void *)v76 + 8);
  int v93 = 771817488;
  uint64_t v92 = v13;
  uint64_t v91 = v76;
  if (v13 != -1)
  {
    unsigned int v90 = 0;
    unsigned int v53 = v92 ? *(_DWORD *)(v92 + 32) : 0;
    unsigned int v90 = v53;
    int v98 = v93;
    uint64_t v97 = v53;
    unsigned int v96 = v91;
    uint64_t v95 = 0;
    uint64_t v94 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] adopt", v14, v15, v16, v17, v18, v19, v20, 2458);
  uint64_t v27 = *((void *)v76 + 8);
  unint64_t v104 = *((void *)v76 + 7);
  uint64_t v103 = v27;
  uint64_t v102 = v70;
  uint64_t v101 = 0;
  if (v104 != -1)
  {
    unint64_t v111 = v104;
    uint64_t v110 = v102;
    unsigned int v109 = 0;
    unsigned int v109 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v108 = 0;
    unsigned int v124 = v109;
    unsigned int v127 = v109 & 0xF00;
    unsigned int v123 = v127 >> 8;
    uint64_t v122 = v109;
    if (v127 >> 8) {
      v122 |= 1 << (v123 + 7);
    }
    uint64_t v108 = v122;
    uint64_t v125 = v122;
    unint64_t v107 = v122 & 0xFFFFFF00;
    BOOL v106 = 0;
    BOOL v52 = 1;
    if ((v110 & 1) == 0) {
      BOOL v52 = (v111 & 0x10000000) != 0;
    }
    BOOL v106 = v52;
    unint64_t v113 = v111;
    v111 &= 0xFFFFFFu;
    if (v111)
    {
      if (v111 >= v107)
      {
        if (v106 || (v109 & 0x44000000) != 0) {
          uint64_t v112 = v111;
        }
        else {
          uint64_t v112 = v108;
        }
      }
      else
      {
        uint64_t v112 = v108;
      }
    }
    else
    {
      unsigned int v126 = v109 & 0xF000;
      unsigned int v105 = v126 >> 12;
      if (v126 >> 12)
      {
        unsigned int v115 = v105;
        uint64_t v114 = 1 << (v105 + 7);
        uint64_t v51 = v114 | 0xFF;
      }
      else
      {
        uint64_t v51 = v108;
      }
      uint64_t v112 = v51;
    }
    uint64_t v101 = v112;
  }
  uint64_t v119 = v101;
  uint64_t v118 = v103;
  uint64_t v117 = v102;
  uint64_t v131 = v101;
  BOOL v134 = v101 != -1;
  uint64_t v133 = 2395;
  if (v101 == -1) {
    _dispatch_abort(v133, v134, v21, v22, v23, v24, v25, v26);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v145 = v131;
    uint64_t v144 = 4261412863;
    uint64_t v143 = 0;
    v131 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v130 = 0;
    unsigned int v135 = 0;
    unsigned int v135 = _dispatch_thread_getspecific(4uLL);
    unint64_t v130 = (unint64_t)v135;
    uint64_t v129 = 0x1000000;
    uint64_t v128 = 2281701376;
    if ((v135 & 0x1000000) != 0)
    {
      if (v131)
      {
        uint64_t v50 = v131;
      }
      else
      {
        unint64_t v139 = v130;
        uint64_t v138 = v129;
        uint64_t v137 = 0;
        uint64_t v50 = v130 & (~v129 | 0xFFFFFF);
      }
      uint64_t v132 = v50;
    }
    else
    {
      unint64_t v142 = v130;
      uint64_t v141 = v128;
      uint64_t v140 = 0;
      v130 &= ~v128 | 0xFFFFFF;
      if (v131 == v130) {
        uint64_t v132 = 0;
      }
      else {
        uint64_t v132 = v131;
      }
    }
  }
  else
  {
    uint64_t v132 = 0;
  }
  uint64_t v119 = v132;
  if (v132) {
    goto LABEL_49;
  }
  if (v118 == -1)
  {
    uint64_t v120 = -1;
    goto LABEL_50;
  }
  int v49 = (void *)v118;
  if (v49 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    uint64_t v120 = _dispatch_set_priority_and_voucher_slow(v119, (_DWORD *)v118, v117);
  }
  else
  {
    BOOL v116 = (v117 & 4) != 0;
    if ((v117 & 2) != 0)
    {
      if (v116 && v118)
      {
        uint64_t v136 = v118;
        os_release((void *)v118);
      }
      uint64_t v118 = -1;
    }
    else if (!v116 && v118)
    {
      object = (void *)v118;
      os_retain((void *)v118);
    }
    uint64_t v120 = v118;
  }
LABEL_50:
  *((void *)v76 + 8) = 0;
  uint64_t v66 = 0;
  if ((v75 & 0x1000000) != 0) {
    uint64_t v66 = _dispatch_autorelease_pool_push();
  }
  if ((v75 & 4) != 0)
  {
    _dispatch_client_callout3(*(void *)(v73 + 48), reason, (uint64_t)v76, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))((char *)&dword_18 + (void)_dispatch_mach_xpc_hooks));
  }
  else
  {
    if (((*(_WORD *)(v74 + 116) >> 2) & 1) == 0) {
      _dispatch_mach_connect_invoke(v74);
    }
    if (reason == 2
      && (uint64_t v65 = v74, v80 = v74, v79 = 0, v78 = *(_DWORD *)(v74 + 80), v79 = v78, v77 = v78, (v78 & 0x10000000) != 0))
    {
      msg = 0;
      msg = (mach_msg_header_t *)_dispatch_mach_msg_get_msg((uint64_t)v76);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v28, v29, v30, v31, v32, v33, v34, 2483);
      mach_msg_destroy(msg);
    }
    else
    {
      uint64_t v48 = 0;
      if (*(void *)(v73 + 40)) {
        uint64_t v48 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v73 + 40);
      }
      _dispatch_client_callout4(*(void *)(v73 + 48), reason, (uint64_t)v76, v72, v48);
    }
  }
  if (v66) {
    _dispatch_autorelease_pool_pop(v66);
  }
  uint64_t v63 = v76;
  uint64_t v85 = v76;
  unsigned int v148 = v76;
  int v153 = 772079660;
  unsigned int v152 = v76;
  uint64_t v151 = 0;
  uint64_t v150 = 0;
  uint64_t v149 = 0;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  int v154 = v85;
  dispatch_object_t v62 = v76;
  dispatch_release(v76);
  uint64_t v87 = __b;
  BOOL v41 = _dispatch_thread_getspecific(0x17uLL) == __b;
  BOOL v89 = v41;
  uint64_t v88 = 449;
  if (!v41) {
    _dispatch_abort(v88, v89, v35, v36, v37, v38, v39, v40);
  }
  _dispatch_thread_setspecific(23, *v87);
  if (__b[3]) {
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  }
  uint64_t v61 = &v54;
  unsigned int v99 = &v54;
  return _dispatch_thread_setspecific_packed_pair(20, 21, &v54, v42, v43, v44, v45, v46);
}

uint64_t _dispatch_mach_barrier_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v49 = a1;
  uint64_t v48 = a2;
  int v47 = a3;
  long long v46 = 0uLL;
  uint64_t v45 = a1[7];
  uint64_t v43 = a1[6];
  uint64_t v74 = a1;
  uint64_t v37 = 0;
  if (*a1) {
    uint64_t v37 = *a1;
  }
  uint64_t v42 = *(void *)(v37 + 16);
  if (v42 == 1024)
  {
    uint64_t v50 = &v46;
    _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v46, 0x15uLL, (pthread_key_t *)&v46 + 1, a5, a6, a7, a8);
    uint64_t v85 = (_OWORD *)*((void *)v50 + 1);
    _dispatch_thread_setspecific_packed_pair(20, 21, v85, v8, v9, v10, v11, v12);
  }
  uint64_t v44 = *(void *)(v45 + 88);
  if (((*(_WORD *)(v45 + 116) >> 2) & 1) == 0)
  {
    uint64_t v41 = 0;
    if ((v47 & 0x1000000) != 0) {
      uint64_t v41 = _dispatch_autorelease_pool_push();
    }
    _dispatch_mach_connect_invoke(v45);
    if (v41) {
      _dispatch_autorelease_pool_pop(v41);
    }
  }
  uint64_t v40 = (uint64_t)v49;
  long long v54 = v49;
  uint64_t v53 = v43;
  BOOL v52 = 0;
  BOOL v52 = (_DWORD *)v49[3];
  uint64_t v51 = v43 & 4;
  uint64_t v56 = 1;
  uint64_t v55 = 600;
  if ((v43 & 4) != 0) {
    v54[3] = -1;
  }
  if (v52 != (_DWORD *)-1)
  {
    int v78 = 771817480;
    int v77 = v52;
    uint64_t v76 = v54;
    unsigned int v75 = 0;
    if (v52) {
      unsigned int v36 = v77[8];
    }
    else {
      unsigned int v36 = 0;
    }
    unsigned int v75 = v36;
    int v83 = v78;
    uint64_t v82 = v36;
    int v81 = v76;
    uint64_t v80 = 0;
    uint64_t v79 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v13, v14, v15, v16, v17, v18, v19, 607);
  }
  unint64_t v89 = v54[1];
  uint64_t v88 = (uint64_t)v52;
  uint64_t v87 = v51 | 2;
  uint64_t v86 = 0;
  if (v89 != -1)
  {
    unint64_t v96 = v89;
    uint64_t v95 = v87;
    unsigned int v94 = 0;
    unsigned int v94 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v93 = 0;
    unsigned int v109 = v94;
    unsigned int v112 = v94 & 0xF00;
    unsigned int v108 = v112 >> 8;
    uint64_t v107 = v94;
    if (v112 >> 8) {
      v107 |= 1 << (v108 + 7);
    }
    uint64_t v93 = v107;
    uint64_t v110 = v107;
    unint64_t v92 = v107 & 0xFFFFFF00;
    BOOL v91 = 0;
    BOOL v35 = 1;
    if ((v95 & 1) == 0) {
      BOOL v35 = (v96 & 0x10000000) != 0;
    }
    BOOL v91 = v35;
    unint64_t v98 = v96;
    v96 &= 0xFFFFFFu;
    if (v96)
    {
      if (v96 >= v92)
      {
        if (v91 || (v94 & 0x44000000) != 0) {
          uint64_t v97 = v96;
        }
        else {
          uint64_t v97 = v93;
        }
      }
      else
      {
        uint64_t v97 = v93;
      }
    }
    else
    {
      unsigned int v111 = v94 & 0xF000;
      unsigned int v90 = v111 >> 12;
      if (v111 >> 12)
      {
        unsigned int v100 = v90;
        uint64_t v99 = 1 << (v90 + 7);
        uint64_t v34 = v99 | 0xFF;
      }
      else
      {
        uint64_t v34 = v93;
      }
      uint64_t v97 = v34;
    }
    uint64_t v86 = v97;
  }
  uint64_t v104 = v86;
  uint64_t v103 = v88;
  uint64_t v102 = v87;
  uint64_t v116 = v86;
  BOOL v119 = v86 != -1;
  uint64_t v118 = 2395;
  if (v86 == -1) {
    _dispatch_abort(v118, v119, a3, a4, a5, a6, a7, a8);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v130 = v116;
    uint64_t v129 = 4261412863;
    uint64_t v128 = 0;
    v116 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v115 = 0;
    uint64_t v120 = 0;
    uint64_t v120 = _dispatch_thread_getspecific(4uLL);
    unint64_t v115 = (unint64_t)v120;
    uint64_t v114 = 0x1000000;
    uint64_t v113 = 2281701376;
    if ((v120 & 0x1000000) != 0)
    {
      if (v116)
      {
        uint64_t v33 = v116;
      }
      else
      {
        unint64_t v124 = v115;
        uint64_t v123 = v114;
        uint64_t v122 = 0;
        uint64_t v33 = v115 & (~v114 | 0xFFFFFF);
      }
      uint64_t v117 = v33;
    }
    else
    {
      unint64_t v127 = v115;
      uint64_t v126 = v113;
      uint64_t v125 = 0;
      v115 &= ~v113 | 0xFFFFFF;
      if (v116 == v115) {
        uint64_t v117 = 0;
      }
      else {
        uint64_t v117 = v116;
      }
    }
  }
  else
  {
    uint64_t v117 = 0;
  }
  uint64_t v104 = v117;
  if (v117) {
    goto LABEL_61;
  }
  if (v103 == -1)
  {
    uint64_t v105 = -1;
    goto LABEL_62;
  }
  uint64_t v32 = (void *)v103;
  if (v32 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_61:
    uint64_t v105 = _dispatch_set_priority_and_voucher_slow(v104, (_DWORD *)v103, v102);
  }
  else
  {
    BOOL v101 = (v102 & 4) != 0;
    if ((v102 & 2) != 0)
    {
      if (v101 && v103)
      {
        uint64_t v121 = v103;
        os_release((void *)v103);
      }
      uint64_t v103 = -1;
    }
    else if (!v101 && v103)
    {
      object = (void *)v103;
      os_retain((void *)v103);
    }
    uint64_t v105 = v103;
  }
LABEL_62:
  if ((v43 & 0x200) == 0)
  {
    uint64_t v60 = v45;
    uint64_t v59 = v49;
    int v58 = 0;
    int v57 = 0;
    uint64_t v132 = v45;
    uint64_t v131 = v49;
  }
  if ((v43 & 4) != 0)
  {
    uint64_t v63 = v40;
    dispatch_object_t v62 = 0;
    dispatch_object_t v62 = _dispatch_thread_getspecific(0x16uLL);
    int v61 = 0;
    if (v62) {
      int v31 = v62[2] + 1;
    }
    else {
      int v31 = 1;
    }
    int v61 = v31;
    if (v31 <= _dispatch_continuation_cache_limit)
    {
      *(void *)(v63 + 16) = v62;
      *(_DWORD *)(v63 + 8) = v61;
      _dispatch_thread_setspecific(22, v63);
      uint64_t v64 = 0;
    }
    else
    {
      uint64_t v64 = v63;
    }
    uint64_t v39 = (void *)v64;
  }
  else
  {
    uint64_t v39 = 0;
  }
  uint64_t v38 = 0;
  if ((v47 & 0x1000000) != 0) {
    uint64_t v38 = _dispatch_autorelease_pool_push();
  }
  uint64_t v20 = (uint64_t (*)(uint64_t))v49[4];
  uint64_t v73 = v49[5];
  unsigned int v72 = v20;
  int v71 = 0;
  if ((char *)v20 == (char *)_dispatch_call_block_and_release && v73)
  {
    uint64_t v29 = _Block_get_invoke_fn(v73);
    uint64_t v30 = 0;
    if (v29) {
      uint64_t v30 = (uint64_t (*)(uint64_t))v29;
    }
    uint64_t v28 = v30;
  }
  else
  {
    uint64_t v28 = v72;
  }
  int v71 = v28;
  uint64_t v141 = v73;
  uint64_t v140 = v28;
  int v70 = 0;
  int v69 = 0;
  int v68 = 0;
  int v67 = 0;
  _dispatch_client_callout(v73, v72);
  uint64_t v143 = v73;
  unint64_t v142 = v71;
  uint64_t v27 = 0;
  if (*(void *)(v44 + 40)) {
    uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v44 + 40);
  }
  uint64_t result = _dispatch_client_callout4(*(void *)(v44 + 48), 6, 0, 0, v27);
  if (v38) {
    uint64_t result = _dispatch_autorelease_pool_pop(v38);
  }
  if ((v43 & 0x200) == 0)
  {
    uint64_t v65 = v40;
    uint64_t v133 = v40;
    int v138 = 772079660;
    uint64_t v137 = v40;
    uint64_t v136 = 0;
    uint64_t v135 = 0;
    uint64_t v134 = 0;
    if (MEMORY[0xFFFFFC100]) {
      uint64_t result = kdebug_trace();
    }
    uint64_t v139 = v65;
  }
  if (v39) {
    uint64_t result = (uint64_t)_dispatch_continuation_free_to_cache_limit(v39);
  }
  if (v42 == 1024)
  {
    uint64_t v66 = &v46;
    uint64_t v84 = &v46;
    return _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v22, v23, v24, v25, v26);
  }
  return result;
}

uint64_t _dispatch_mach_connect_invoke(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 88);
  uint64_t v2 = 0;
  if (*(void *)(v3 + 40)) {
    uint64_t v2 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v3 + 40);
  }
  uint64_t result = _dispatch_client_callout4(*(void *)(v3 + 48), 1, 0, 0, v2);
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFB | 4;
  return result;
}

void dispatch_mach_send_barrier_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = _dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22, v18[2]);
    unint64_t v16 = (unint64_t)v18;
  }
  else
  {
    unint64_t v16 = _dispatch_continuation_alloc_from_heap();
  }
  *(void *)unint64_t v16 = 260;
  *(void *)(v16 + 32) = a3;
  *(void *)(v16 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = a2;
  unint64_t v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = 4351;
  }
  uint64_t v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22) {
    os_retain(v22);
  }
  *(void *)(v16 + 24) = v22;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
  if (*(void *)(v16 + 24) != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v19 = v21;
  if (v21 && (*(_DWORD *)(a1 + 84) & 0x40000000) == 0 && (*(_DWORD *)(a1 + 84) & 0xFFF) != 0) {
    uint64_t v19 = 0;
  }
  *(void *)(v16 + 8) = v19;
  *(void *)(v16 + 48) = *(void *)v16;
  *(void *)(v16 + 56) = a1;
  uint64_t v12 = 0;
  if (&unk_ECCC8) {
    uint64_t v12 = &unk_ECCC8;
  }
  *(void *)unint64_t v16 = v12;
  unint64_t v17 = (*(void *)(v16 + 8) & 0x3FFF00uLL) >> 8;
  unsigned int v10 = __clz(__rbit32(v17));
  if (v17) {
    unsigned int v11 = v10 + 1;
  }
  else {
    unsigned int v11 = 0;
  }
  _dispatch_mach_send_push(a1, (void **)v16, v11);
}

void dispatch_mach_send_barrier(unint64_t a1, const void *a2)
{
  uint64_t v19 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v19)
  {
    _dispatch_thread_setspecific(22, v19[2]);
    unint64_t v16 = v19;
  }
  else
  {
    unint64_t v16 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  unint64_t v17 = _dispatch_Block_copy(a2);
  uint64_t v12 = _Block_get_invoke_fn((uint64_t)a2);
  uint64_t v13 = 0;
  if (v12) {
    uint64_t v13 = (uint64_t (*)())v12;
  }
  if (v13 == _dispatch_block_special_invoke)
  {
    *unint64_t v16 = 276;
    v16[5] = (uint64_t)v17;
    _dispatch_continuation_init_slow(v16, a1, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)a2);
    *unint64_t v16 = 276;
    v16[4] = (uint64_t)_dispatch_call_block_and_release;
    v16[5] = (uint64_t)v17;
    unint64_t v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v21 <= 0x10FF) {
      uint64_t v22 = v21;
    }
    else {
      uint64_t v22 = 4351;
    }
    uint64_t v23 = _dispatch_thread_getspecific(0x1CuLL);
    if (v23) {
      os_retain(v23);
    }
    v16[3] = (uint64_t)v23;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    if (v16[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v20 = v22;
    if (v22 && (*(_DWORD *)(a1 + 84) & 0x40000000) == 0 && (*(_DWORD *)(a1 + 84) & 0xFFF) != 0) {
      uint64_t v20 = 0;
    }
    v16[1] = v20;
  }
  v16[6] = *v16;
  v16[7] = a1;
  unsigned int v11 = 0;
  if (&unk_ECCC8) {
    unsigned int v11 = &unk_ECCC8;
  }
  *unint64_t v16 = (uint64_t)v11;
  unint64_t v18 = (v16[1] & 0x3FFF00uLL) >> 8;
  unsigned int v9 = __clz(__rbit32(v18));
  if (v18) {
    unsigned int v10 = v9 + 1;
  }
  else {
    unsigned int v10 = 0;
  }
  _dispatch_mach_send_push(a1, (void **)v16, v10);
}

uint64_t dispatch_mach_receive_barrier_f(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = _dispatch_thread_getspecific(0x16uLL);
  if (v20)
  {
    _dispatch_thread_setspecific(22, v20[2]);
    uint64_t v19 = v20;
  }
  else
  {
    uint64_t v19 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  *uint64_t v19 = 260;
  v19[4] = a3;
  v19[5] = a2;
  unint64_t v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v23 <= 0x10FF) {
    unint64_t v24 = v23;
  }
  else {
    unint64_t v24 = 4351;
  }
  uint64_t v25 = _dispatch_thread_getspecific(0x1CuLL);
  if (v25) {
    os_retain(v25);
  }
  v19[3] = v25;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
  if (v19[3] != -1 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  unint64_t v22 = v24;
  unsigned int v21 = 0;
  if (v24)
  {
    if ((*((_DWORD *)a1 + 21) & 0x40000000) != 0 || (*((_DWORD *)a1 + 21) & 0xFFF) == 0)
    {
      unsigned int v10 = v24 >> 8;
      unsigned int v11 = __clz(__rbit32(v10));
      if (v10) {
        unsigned int v12 = v11 + 1;
      }
      else {
        unsigned int v12 = 0;
      }
      unsigned int v21 = v12;
    }
    else
    {
      unint64_t v22 = 0;
    }
  }
  v19[1] = v22;
  v19[6] = *v19;
  v19[7] = a1;
  uint64_t v15 = 0;
  if (&unk_ECD00) {
    uint64_t v15 = &unk_ECD00;
  }
  *uint64_t v19 = v15;
  uint64_t v14 = 0;
  if (*a1) {
    uint64_t v14 = *a1;
  }
  return (*(uint64_t (**)(uint64_t *, void *, void))(v14 + 72))(a1, v19, v21);
}

uint64_t dispatch_mach_receive_barrier(unint64_t a1, const void *a2)
{
  unint64_t v22 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v22)
  {
    _dispatch_thread_setspecific(22, v22[2]);
    uint64_t v19 = v22;
  }
  else
  {
    uint64_t v19 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  uint64_t v20 = _dispatch_Block_copy(a2);
  uint64_t v15 = _Block_get_invoke_fn((uint64_t)a2);
  unint64_t v16 = 0;
  if (v15) {
    unint64_t v16 = (uint64_t (*)())v15;
  }
  if (v16 == _dispatch_block_special_invoke)
  {
    *uint64_t v19 = 276;
    v19[5] = (uint64_t)v20;
    unsigned int inited = _dispatch_continuation_init_slow(v19, a1, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)a2);
    *uint64_t v19 = 276;
    v19[4] = (uint64_t)_dispatch_call_block_and_release;
    v19[5] = (uint64_t)v20;
    unint64_t v25 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v25 <= 0x10FF) {
      unint64_t v26 = v25;
    }
    else {
      unint64_t v26 = 4351;
    }
    uint64_t v27 = _dispatch_thread_getspecific(0x1CuLL);
    if (v27) {
      os_retain(v27);
    }
    v19[3] = (uint64_t)v27;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    if (v19[3] != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    unint64_t v24 = v26;
    unsigned int v23 = 0;
    if (v26)
    {
      if ((*(_DWORD *)(a1 + 84) & 0x40000000) != 0 || (*(_DWORD *)(a1 + 84) & 0xFFF) == 0)
      {
        unsigned int v9 = v26 >> 8;
        unsigned int v10 = __clz(__rbit32(v9));
        if (v9) {
          unsigned int v11 = v10 + 1;
        }
        else {
          unsigned int v11 = 0;
        }
        unsigned int v23 = v11;
      }
      else
      {
        unint64_t v24 = 0;
      }
    }
    v19[1] = v24;
    unsigned int inited = v23;
  }
  v19[6] = *v19;
  v19[7] = a1;
  uint64_t v14 = 0;
  if (&unk_ECD00) {
    uint64_t v14 = &unk_ECD00;
  }
  *uint64_t v19 = (uint64_t)v14;
  uint64_t v13 = 0;
  if (*(void *)a1) {
    uint64_t v13 = *(void *)a1;
  }
  return (*(uint64_t (**)(unint64_t, uint64_t *, void))(v13 + 72))(a1, v19, inited);
}

void dispatch_mach_cancel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 80), 0x10000000u, memory_order_relaxed) & 0x10000000) == 0) {
    dispatch_mach_reconnect(a1, 0, (dispatch_object_s *)0xFFFFFFFFFFFFFFFFLL);
  }
  _dispatch_release_tailcall(a1);
}

void _dispatch_mach_activate(uint64_t a1)
{
  uint64_t v8 = a1;
  unsigned int v7 = 0;
  uint64_t v6 = 0;
  _dispatch_lane_activate(a1);
  if ((*(_WORD *)(v8 + 116) & 1) == 0)
  {
    unsigned int v7 = _dispatch_queue_compute_priority_and_wlh(v8, &v6);
    if (v7) {
      _dispatch_mach_install(v8, v6, v7, v1, v2, v3, v4, v5);
    }
  }
}

uint64_t _dispatch_mach_install(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v19 = result;
  unsigned int v17 = a3;
  BOOL v16 = (*(_DWORD *)(result + 80) & 0x10000000) != 0;
  uint64_t v15 = *(void *)(result + 88);
  if (*(_WORD *)(result + 116)) {
    _dispatch_abort(2664, (*(_WORD *)(result + 116) & 1) == 0, a3, a4, a5, a6, a7, a8);
  }
  *(_WORD *)(result + 116) |= 1u;
  unsigned int v14 = *(_DWORD *)(*(void *)(result + 120) + 88);
  if (HIBYTE(v14) >> 7)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel never connected";
    qword_F42C0 = v14;
    __break(1u);
    JUMPOUT(0x7CC5CLL);
  }
  if (!*(_DWORD *)(result + 84)) {
    *(_DWORD *)(result + 84) = a3;
  }
  if (!v16 && (*(_WORD *)(result + 116) & 0x10) != 0)
  {
    uint64_t result = (*(uint64_t (**)(void))((char *)&stru_20.cmd + (void)_dispatch_mach_xpc_hooks))(*(void *)(v15 + 48));
    if (result)
    {
      uint64_t v13 = off_ED470((uint64_t)&_dispatch_xpc_type_sigterm, 15, 0);
      *(void *)(v13 + 8) = ~v19;
      *(void *)(v19 + 128) = v13;
      uint64_t result = _dispatch_unote_register(*(void *)(v19 + 128), a2, v17, v8, v9, v10, v11, v12);
    }
  }
  if (!v16 && *(_DWORD *)(v15 + 24))
  {
    if ((*(unsigned char *)(v15 + 29) & 1) == 0) {
      _dispatch_abort(2692, *(unsigned char *)(v15 + 29) & 1, a3, a4, a5, a6, a7, a8);
    }
    return _dispatch_unote_register(v15, a2, v17, a4, a5, a6, a7, a8);
  }
  return result;
}

void _dispatch_mach_invoke(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = a1;
  uint64_t v51 = a2;
  unsigned int v50 = a3;
  int v49 = 8;
  uint64_t v48 = _dispatch_mach_invoke2;
  uint64_t v47 = a1;
  v46[8] = 0;
  *(void *)long long v46 = (a3 & 1) == 0;
  uint64_t v45 = 0;
  if ((a3 & 3) == 0)
  {
    *(void *)(v47 + 16) = -1985229329;
    uint64_t v44 = _dispatch_thread_getspecific(0x14uLL);
    uint64_t v43 = v47;
    dispatch_object_t v62 = v44;
    uint64_t v61 = v47;
    int v60 = 0;
    int v59 = 0;
    uint64_t v66 = v44;
    uint64_t v65 = v47;
  }
  v50 |= v49;
  if ((v50 & 2) != 0)
  {
    uint64_t v45 = 0x40020000000001;
  }
  else
  {
    uint64_t v99 = v47;
    unsigned int v98 = v50;
    uint64_t v97 = 0;
    uint64_t v97 = (uint64_t)(*(unsigned __int16 *)(v47 + 80) - 1) << 41;
    unsigned int v105 = _dispatch_thread_getspecific(3uLL);
    uint64_t v96 = v105 & 0xFFFFFFFC | 0x20000000000000;
    unint64_t v94 = 0;
    unint64_t v93 = 0;
    uint64_t v92 = 0;
    unint64_t v95 = 0xFFE00000FFFFFFFCLL;
    if (v50)
    {
      v95 |= 0x4000000000uLL;
      uint64_t v92 = 0;
    }
    else if ((v98 & 0x40000) != 0)
    {
      uint64_t v92 = 0x4000000000;
    }
    else
    {
      v95 |= 0x4000000000uLL;
      uint64_t v92 = 1;
    }
    BOOL v104 = (v98 & 2) == 0;
    uint64_t v103 = 1323;
    if ((v98 & 2) != 0) {
      _dispatch_abort(v103, v104, v8, v9, v10, v11, v12, v13);
    }
    unsigned int v91 = 0;
    unsigned int v109 = _dispatch_thread_getspecific(0x19uLL);
    unsigned int v111 = v109 & 0xF00;
    unsigned int v108 = v111 >> 8;
    unsigned int v110 = v109 & 0xF000;
    unsigned int v107 = v110 >> 12;
    int v115 = v109 & 0xF0000;
    unsigned int v106 = (v109 & 0xF0000) >> 16;
    if (v111 >> 8 <= v110 >> 12) {
      unsigned int v38 = v107;
    }
    else {
      unsigned int v38 = v108;
    }
    if (v38 <= v106)
    {
      unsigned int v36 = v106;
    }
    else
    {
      if (v108 <= v107) {
        unsigned int v37 = v107;
      }
      else {
        unsigned int v37 = v108;
      }
      unsigned int v36 = v37;
    }
    unsigned int v91 = v36;
LABEL_22:
    BOOL v90 = 0;
    unint64_t v89 = (atomic_ullong *)(v99 + 56);
    unint64_t v94 = *(void *)(v99 + 56);
    do
    {
      unint64_t v93 = v94;
      if ((v94 & v95) != 0)
      {
        if (!v92) {
          break;
        }
        v93 ^= v92;
      }
      else
      {
        unint64_t v163 = v94;
        unsigned int v162 = v91;
        unint64_t v166 = v94;
        BOOL v35 = 0;
        if ((v94 & 0x1000000000) != 0)
        {
          uint64_t v164 = v163 & 0x700000000;
          BOOL v35 = v162 < (v163 & 0x700000000) >> 32;
        }
        if (v35)
        {
          unint64_t v113 = v94;
          uint64_t v114 = v94 & 0x700000000;
          unsigned int v112 = (v94 & 0x700000000) >> 32;
          unsigned int v117 = _dispatch_thread_getspecific(3uLL);
          unsigned int v116 = v112;
          if (_dispatch_set_qos_class_enabled)
          {
            unsigned int v119 = v116;
            uint64_t v118 = 0;
            if (v116) {
              uint64_t v118 = 1 << (v119 + 7);
            }
            _pthread_workqueue_override_start_direct();
          }
          unsigned int v121 = v112;
          unsigned int v120 = _dispatch_thread_getspecific(0x19uLL);
          int v122 = v120 & 0xF0000;
          if (v112 > (v120 & 0xF0000) >> 16)
          {
            unsigned int v120 = v120 & 0xFFF0FFFF | (v121 << 16);
            _dispatch_thread_setspecific(25, v120);
          }
          unsigned int v91 = v112;
          goto LABEL_22;
        }
        unint64_t v93 = v93 & 0x7700000001 | v96;
        unint64_t v165 = v94;
        if ((v94 & 0x10000000000) != 0 || v94 + v97 < 0x20000000000000) {
          v93 |= 0x40000000000000uLL;
        }
      }
      unint64_t v88 = v93;
      unint64_t v16 = v94;
      unint64_t v17 = v94;
      atomic_compare_exchange_strong_explicit(v89, &v17, v93, memory_order_acquire, memory_order_acquire);
      if (v17 != v16) {
        unint64_t v94 = v17;
      }
      BOOL v87 = v17 == v16;
      BOOL v90 = v17 == v16;
    }
    while (v17 != v16);
    BOOL v86 = v90;
    BOOL v102 = (v94 & v92) == v92;
    uint64_t v101 = 1356;
    if ((v94 & v92) != v92) {
      _dispatch_abort(v101, v102, v14, v15, a5, a6, a7, a8);
    }
    if ((v94 & v95) != 0)
    {
      uint64_t v100 = 0;
    }
    else
    {
      v93 &= v92 | 0x60000000000000;
      v94 &= 0x3FFE0000000000uLL;
      uint64_t v100 = v93 - v94;
    }
    uint64_t v45 = v100;
  }
  if (v45)
  {
    unsigned int v42 = 0;
    if ((v50 & 0x40000) != 0)
    {
      unsigned int v42 = 0;
    }
    else
    {
      int v125 = *(_DWORD *)(v47 + 84);
      unsigned int v124 = _dispatch_thread_getspecific(0x19uLL);
      unsigned int v123 = v124;
      if (v124)
      {
        if ((v125 & 0xFFF) != 0)
        {
          v123 &= 0x880F0000;
          if ((v124 & 0xFFF) <= (v125 & 0xFFFu)) {
            int v34 = v125 & 0xFFF;
          }
          else {
            int v34 = v124 & 0xFFF;
          }
          v123 |= v34;
          unsigned int v127 = v125 & 0xF000;
          unsigned int v129 = v123 & 0xF00;
          if (v127 >> 12 <= v129 >> 8) {
            v125 &= 0x40000000u;
          }
          else {
            v125 &= 0x4400F000u;
          }
          v123 |= v125;
        }
        else
        {
          if ((v123 & 0xFFF) != 0) {
            v123 |= 0x40000000u;
          }
          unsigned int v126 = v125 & 0xF000;
          unsigned int v128 = v123 & 0xF00;
          if (v126 >> 12 > v128 >> 8) {
            unsigned int v123 = v123 & 0xFFFF0FFF | v125 & 0x400F000;
          }
        }
      }
      else
      {
        unsigned int v123 = v125 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v123);
      unsigned int v42 = v124;
    }
    if ((v50 & 0x100000) != 0)
    {
      uint64_t v56 = v52;
      int v55 = 0;
      int v54 = *(_DWORD *)(v52 + 80);
      int v55 = v54;
      int v53 = v54;
      if ((v54 & 0x400000) != 0)
      {
        uint64_t v85 = v52;
        int v84 = 0x400000;
        int v82 = -4194305;
        int v81 = -4194305;
        int v83 = -4194305;
        int v77 = -4194305;
        int v76 = -4194305;
        int v78 = -4194305;
        unsigned int v75 = atomic_fetch_and_explicit((atomic_uint *volatile)(v52 + 80), 0xFFBFFFFF, memory_order_relaxed);
        unsigned int v79 = v75;
        unsigned int v74 = v75;
        unsigned int v80 = v75 & 0xFFBFFFFF;
      }
    }
    uint64_t v41 = v47;
    uint64_t v132 = v47;
    unsigned int v131 = v50;
    int v130 = 0;
    uint64_t v169 = v47;
    uint64_t v168 = 256;
    uint64_t v175 = 1;
    uint64_t v174 = 730;
    int v167 = 0;
    uint64_t v173 = v47;
    int v172 = 0;
    int v171 = *(_DWORD *)(v47 + 80);
    int v172 = v171;
    int v170 = v171;
    int v167 = v171 & 0x30000;
    int v130 = (v171 & 0x30000) << 8;
    if (v130) {
      unsigned int v131 = v131 & 0xFCFFFFFF | v130;
    }
    unsigned int v50 = v131;
    do
    {
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0) {
        _dispatch_last_resort_autorelease_pool_push(v51);
      }
      uint64_t v40 = v47;
      *(void *)&v46[1] = v48(v47, v51, v50, &v45);
      if ((v50 & 2) != 0 && (v50 & 0x1000000) == 0)
      {
        long long v39 = 0uLL;
        uint64_t v134 = v47;
        uint64_t v133 = &v39;
        uint64_t v176 = &v39;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v39, v19, a5, a6, a7, a8);
        _dispatch_thread_setspecific_pair(20, v134, 21, (uint64_t)v133, v20, v21, v22, v23);
        _dispatch_last_resort_autorelease_pool_pop(v51);
        uint64_t v64 = &v39;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v39, v24, v25, v26, v27, v28);
      }
      BOOL v58 = *(void *)&v46[1] != 1;
      uint64_t v57 = 2018;
      if (*(void *)&v46[1] == 1) {
        _dispatch_abort(v57, v58, v18, v19, a5, a6, a7, a8);
      }
      BOOL v33 = 0;
      if (*(void *)&v46[1]) {
        BOOL v33 = *(void *)&v46[1] != -1;
      }
      if (v33) {
        break;
      }
      uint64_t v154 = v47;
      uint64_t v153 = v45;
      BOOL v152 = *(void *)&v46[1] == 0;
      uint64_t v151 = 0;
      unint64_t v150 = 0;
      BOOL v149 = 0;
      unsigned int v148 = (atomic_ullong *)(v47 + 56);
      uint64_t v151 = *(void *)(v47 + 56);
      do
      {
        unint64_t v150 = (v151 - v153) & 0xFFFFFFF700000001;
        uint64_t v156 = v151;
        if ((v151 & 0xFF80000000000000) == 0)
        {
          uint64_t v177 = v151;
          if ((v151 & 0x8000000000) != 0)
          {
            uint64_t v146 = 0x8000000000;
            uint64_t v145 = 0x8000000000;
            uint64_t v147 = 0x8000000000;
            unint64_t v143 = 0;
            uint64_t v141 = 0x8000000000;
            uint64_t v140 = 0x8000000000;
            uint64_t v142 = 0x8000000000;
            xor_unint64_t explicit = atomic_fetch_xor_explicit((atomic_ullong *volatile)(v154 + 56), 0x8000000000uLL, memory_order_acquire);
            unint64_t v143 = xor_explicit;
            unint64_t v138 = xor_explicit;
            unint64_t v144 = xor_explicit ^ v147;
            char v155 = 0;
            goto LABEL_101;
          }
          if (v152) {
            v150 &= 0xFFFFFFF8FFFFFFFFLL;
          }
          else {
            v150 |= 0x8000000000uLL;
          }
        }
        unint64_t v137 = v150;
        uint64_t v29 = v151;
        uint64_t v30 = v151;
        atomic_compare_exchange_strong_explicit(v148, (unint64_t *)&v30, v150, memory_order_release, memory_order_relaxed);
        if (v30 != v29) {
          uint64_t v151 = v30;
        }
        BOOL v136 = v30 == v29;
        BOOL v149 = v30 == v29;
      }
      while (v30 != v29);
      BOOL v135 = v149;
      uint64_t v178 = v151;
      uint64_t v179 = v151;
      BOOL v32 = 0;
      if ((v151 & 0x1000000000) != 0) {
        BOOL v32 = (v178 & 0x800000000) != 0;
      }
      if (v32)
      {
        uint64_t v157 = v151 & 0x700000000;
        uint64_t v158 = v151 & 0x700000000;
        LODWORD(v158) = _dispatch_thread_getspecific(0x19uLL);
        int v159 = v158 & 0xF0000;
        if (HIDWORD(v158) > (v158 & 0xF0000) >> 16)
        {
          LODWORD(v158) = v158 & 0xFFF0FFFF;
          LODWORD(v158) = v158 | (HIDWORD(v158) << 16);
          _dispatch_thread_setspecific(25, v158);
        }
      }
      char v155 = 1;
LABEL_101:
      if (v155)
      {
        uint64_t v45 = 0;
        *(void *)&v46[1] = 0;
        break;
      }
      *(void *)&v46[1] = _dispatch_thread_getspecific(0x14uLL);
      uint64_t v31 = 0;
      if (**(void **)&v46[1]) {
        uint64_t v31 = **(void **)&v46[1];
      }
    }
    while ((*(void *)(v31 + 16) & 0x10000) != 0 || (v46[0] & 1) == 0);
    if ((v50 & 0x40000) == 0)
    {
      unsigned int v161 = v42;
      unsigned int v160 = 0;
      unsigned int v160 = _dispatch_thread_getspecific(0x19uLL);
      v161 &= 0xFFF0FFFF;
      v161 |= v160 & 0xF0000;
      _dispatch_thread_setspecific(25, v161);
    }
  }
  if (v46[0])
  {
    uint64_t v63 = v47;
    uint64_t v67 = v47;
    int v72 = 772079660;
    uint64_t v71 = v47;
    uint64_t v70 = 0;
    uint64_t v69 = 0;
    uint64_t v68 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    uint64_t v73 = v63;
  }
  if (*(void *)&v46[1]) {
    _dispatch_queue_invoke_finish(v47, v51, *(uint64_t (****)())&v46[1], v45, a5, a6, a7, a8);
  }
  else {
    _dispatch_release_2_tailcall(v47);
  }
}

uint64_t _dispatch_mach_invoke2(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  uint64_t v32 = 0;
  uint64_t v31 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  uint64_t v30 = *(void *)(a1 + 120);
  uint64_t v29 = *(void *)(a1 + 88);
  BOOL v25 = 0;
  if ((a3 & 0x40000) == 0)
  {
    BOOL v25 = 0;
    if (v29)
    {
      uint64_t v40 = _dispatch_thread_getspecific(0x1DuLL);
      if (v40) {
        uint64_t v41 = v40[3];
      }
      else {
        uint64_t v41 = -4;
      }
      unint64_t v38 = *(void *)(v29 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      BOOL v24 = 0;
      if (v38)
      {
        BOOL v24 = 0;
        if (v38 != -4) {
          BOOL v24 = v38 != v41;
        }
      }
      BOOL v25 = v24;
    }
  }
  if (v25) {
    _dispatch_mach_handle_wlh_change(a1, v4, v5, v6, v7, v8, v9, v10);
  }
  if ((*(_WORD *)(a1 + 116) & 1) == 0)
  {
    if ((a3 & 0x40000) != 0) {
      return *(void *)(a1 + 24);
    }
    unsigned int v27 = 0x2000000;
    if ((a3 & 0x10000) != 0) {
      unsigned int v27 = _dispatch_thread_getspecific(0x19uLL);
    }
    long long v39 = _dispatch_thread_getspecific(0x1DuLL);
    if (v39) {
      _dispatch_mach_install(a1, v39[3], v27, v11, v12, v13, v14, v15);
    }
    else {
      _dispatch_mach_install(a1, -4, v27, v11, v12, v13, v14, v15);
    }
  }
  if (!*(void *)(a1 + 48)) {
    goto LABEL_24;
  }
  if (v31 != *(uint64_t (****)())(a1 + 24))
  {
    uint64_t v32 = *(void *)(a1 + 24);
    goto LABEL_24;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v32 = _dispatch_lane_serial_drain((uint64_t *)a1, a2, a3, a4, v7, v8, v9, v10);
LABEL_24:
      int v28 = *(_DWORD *)(a1 + 80);
      if (v32 || (v28 & 0x10000000) != 0) {
        break;
      }
      uint64_t v42 = *(void *)(v29 + 16);
      BOOL v23 = 0;
      if (v42)
      {
        BOOL v23 = 0;
        if ((v42 & 1) == 0) {
          BOOL v23 = (v42 & 2) == 0;
        }
      }
      if (!v23) {
        break;
      }
      _dispatch_unote_resume(v29, v4, v5, v6, v7, v8, v9, v10);
      if (v31 == *(uint64_t (****)())(a1 + 24) && !v31[3] && !*(void *)(v30 + 72) && *((int *)v31 + 21) < 0)
      {
        uint64_t v43 = _dispatch_thread_getspecific(0x1DuLL);
        BOOL v22 = 0;
        if (_dispatch_thread_getspecific(5uLL))
        {
          BOOL v22 = 0;
          if (v43)
          {
            BOOL v22 = 0;
            if (v43[3] != -4) {
              BOOL v22 = (*(void *)(v29 + 16) & 0xFFFFFFFFFFFFFFFCLL) == v43[3];
            }
          }
        }
        if (v22)
        {
          _dispatch_event_loop_drain(1u);
          if (*(void *)(a1 + 48)) {
            continue;
          }
        }
      }
      int v28 = *(_DWORD *)(a1 + 80);
      break;
    }
    if (*(void *)(v30 + 72))
    {
      if ((*(unsigned char *)(v30 + 30) & 1) == 0 || *(_DWORD *)(v30 + 88))
      {
        if (*(_DWORD *)(v30 + 88)) {
          int v21 = *(void *)(v30 + 16) != 0;
        }
        else {
          int v21 = *(_WORD *)(a1 + 118) & 1;
        }
        BOOL v20 = 0;
        if (v21) {
          BOOL v20 = v31 != &_dispatch_mgr_q;
        }
        if (v20)
        {
          if (v32) {
            return v32;
          }
          else {
            return (uint64_t)&_dispatch_mgr_q;
          }
        }
        unsigned int v26 = 0;
        if (v31 != &_dispatch_mgr_q) {
          unsigned int v26 = 4;
        }
        _dispatch_mach_send_invoke(a1, a3, v26);
        if (!v32 && *(void *)(a1 + 48)) {
          uint64_t v32 = *(void *)(a1 + 24);
        }
      }
      if (!v32 && *(void *)(v30 + 72)) {
        uint64_t v32 = -1;
      }
    }
    if ((v28 & 0x10000000) == 0) {
      return v32;
    }
    if (v28 >= 0 && !_dispatch_mach_cancel(a1, v4, v5, v6, v7, v8, v9, v10))
    {
      if (v32) {
        return v32;
      }
      else {
        return -1;
      }
    }
    if ((*(_WORD *)(a1 + 116) >> 3)) {
      return v32;
    }
    if (v31 != *(uint64_t (****)())(a1 + 24)) {
      break;
    }
    if ((*(void *)(a1 + 56) & 0xFF80000000000000) != 0) {
      return *(void *)(a1 + 24);
    }
    if (!*(void *)(a1 + 48))
    {
      _dispatch_mach_cancel_invoke(a1, a3);
      return v32;
    }
  }
  if (v32) {
    return v32;
  }
  else {
    return *(void *)(a1 + 24);
  }
}

void _dispatch_mach_wakeup(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 120);
  *(_DWORD *)&v9[8] = 0;
  *(void *)uint64_t v9 = *(unsigned int *)(a1 + 80);
  if (*(_WORD *)(a1 + 116))
  {
    if (*(void *)(a1 + 48))
    {
      *(void *)&v9[4] = 1;
    }
    else if (*(void *)(v10 + 72))
    {
      if ((*(_DWORD *)(v10 + 64) & 0xFFFFFFFC) == 0 && ((*(unsigned char *)(v10 + 30) & 1) == 0 || *(_DWORD *)(v10 + 88)))
      {
        if (*(_DWORD *)(v10 + 88)) {
          int v8 = *(void *)(v10 + 16) != 0;
        }
        else {
          int v8 = *(_WORD *)(a1 + 118) & 1;
        }
        if (v8) {
          *(void *)&v9[4] = &_dispatch_mgr_q;
        }
        else {
          *(void *)&v9[4] = 1;
        }
      }
    }
    else if (((*(_DWORD *)v9 & 0x10000000) == 0 || (*(_DWORD *)v9 & 0x40000000) == 0 || (a3 & 0x10) != 0) {
           && (*(_DWORD *)v9 & 0x10000000) != 0
    }
           && ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0)
    {
      *(void *)&v9[4] = 1;
    }
  }
  else
  {
    *(void *)&v9[4] = 1;
  }
  if (*(void *)&v9[4] == 1 && *(uint64_t (****)())(a1 + 24) == &_dispatch_mgr_q) {
    *(void *)&v9[4] = &_dispatch_mgr_q;
  }
  _dispatch_queue_wakeup(a1, a2, a3, *(uint64_t *)&v9[4], a5, a6, a7, a8);
}

uint64_t _dispatch_xpc_sigterm_merge_evt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v9 = ~*(void *)(a1 + 8);
  _dispatch_barrier_async_detached_f((uint64_t *)v9, v9, (uint64_t)_dispatch_mach_sigterm_invoke);
  uint64_t v8 = 0;
  if (*(void *)v9) {
    uint64_t v8 = *(void *)v9;
  }
  unsigned int v4 = (*(void *)&a4 & 0x3FFF00uLL) >> 8;
  unsigned int v5 = __clz(__rbit32(v4));
  if (v4) {
    uint64_t v6 = v5 + 1;
  }
  else {
    uint64_t v6 = 0;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 64))(v9, v6, 19);
}

uint64_t _dispatch_mach_sigterm_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = _dispatch_unote_unregister(*(void *)(a1 + 128), 5, a3, a4, a5, a6, a7, a8);
  if ((*(_DWORD *)(a1 + 80) & 0x10000000) == 0)
  {
    uint64_t v10 = *(void *)(a1 + 88);
    uint64_t v9 = 0;
    if (*(void *)(v10 + 40)) {
      uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v10 + 40);
    }
    return _dispatch_client_callout4(*(void *)(v10 + 48), 11, 0, 0, v9);
  }
  return result;
}

void *dispatch_mach_msg_create(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = a3;
  char v10 = 1;
  if (a2 >= 0x18)
  {
    BOOL v9 = 0;
    if (a3) {
      BOOL v9 = a1 == 0;
    }
    char v10 = v9;
  }
  if (v10)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Empty message";
    qword_F42C0 = a2;
    __break(1u);
    JUMPOUT(0x7F454);
  }
  unint64_t v11 = 96;
  if (!a3)
  {
    unint64_t v11 = a2 + 88;
    if (a2 - 8 >= 0xFFFFFFFFFFFFFFA0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Message size too large";
      qword_F42C0 = a2;
      __break(1u);
      JUMPOUT(0x7F4E0);
    }
  }
  uint64_t v12 = _dispatch_object_alloc((uint64_t)_OS_dispatch_mach_msg_vtable, v11, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (v14)
  {
    v12[11] = a1;
  }
  else if (a1)
  {
    __memcpy_chk();
  }
  v12[2] = -1985229329;
  pthread_t v12[3] = &off_F0600;
  *((_DWORD *)v12 + 18) = v14;
  void v12[10] = a2;
  if (a4) {
    *a4 = _dispatch_mach_msg_get_msg((uint64_t)v12);
  }
  return v12;
}

uint64_t _dispatch_mach_msg_get_msg(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 72)) {
    return *(void *)(a1 + 88);
  }
  else {
    return a1 + 88;
  }
}

void _dispatch_mach_msg_dispose(uint64_t a1)
{
  kern_return_t v8;

  if (*(void *)(a1 + 64))
  {
    os_release(*(void **)(a1 + 64));
    *(void *)(a1 + 64) = 0;
  }
  int v7 = *(_DWORD *)(a1 + 72);
  if (v7)
  {
    if (v7 == 1)
    {
      free(*(void **)(a1 + 88));
    }
    else if (v7 == 2)
    {
      uint64_t v8 = mach_vm_deallocate(mach_task_self_, *(void *)(a1 + 88), *(void *)(a1 + 80));
      if (v8) {
        _dispatch_bug(3000, v8, v1, v2, v3, v4, v5, v6);
      }
    }
  }
}

uint64_t dispatch_mach_msg_get_msg(uint64_t a1, void *a2)
{
  if (a2) {
    *a2 = *(void *)(a1 + 80);
  }
  return _dispatch_mach_msg_get_msg(a1);
}

void *_dispatch_mach_msg_async_reply_invoke(void *a1, uint64_t a2, int a3)
{
  uint64_t v40 = a1[7];
  uint64_t v51 = (void *)a1[6];
  int v50 = a3 | 4;
  uint64_t v49 = v40;
  uint64_t v48 = 0;
  unsigned int v47 = 0;
  uint64_t reason = _dispatch_mach_msg_get_reason((uint64_t)v51, (int *)&v47);
  uint64_t v45 = 7;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0;
  __b[1] = "mach_msg";
  __b[2] = v51;
  __b[3] = 0;
  LODWORD(__b[4]) = 0;
  uint64_t v61 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v61);
  uint64_t v59 = v49;
  BOOL v58 = v51;
  int v57 = 0;
  int v56 = 0;
  uint64_t v125 = v49;
  unsigned int v124 = v51;
  uint64_t v48 = *(void *)(v49 + 88);
  v51[2] = -1985229329;
  uint64_t v3 = v51[8];
  int v73 = 771817488;
  uint64_t v72 = v3;
  uint64_t v71 = v51;
  if (v3 != -1)
  {
    unsigned int v70 = 0;
    unsigned int v39 = v72 ? *(_DWORD *)(v72 + 32) : 0;
    unsigned int v70 = v39;
    int v78 = v73;
    uint64_t v77 = v39;
    int v76 = v71;
    uint64_t v75 = 0;
    uint64_t v74 = 0;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] adopt", v4, v5, v6, v7, v8, v9, v10, 2458);
  uint64_t v17 = v51[8];
  unint64_t v82 = v51[7];
  uint64_t v81 = v17;
  uint64_t v80 = v45;
  uint64_t v79 = 0;
  if (v82 != -1)
  {
    unint64_t v89 = v82;
    uint64_t v88 = v80;
    unsigned int v87 = 0;
    unsigned int v87 = _dispatch_thread_getspecific(0x19uLL);
    uint64_t v86 = 0;
    unsigned int v102 = v87;
    unsigned int v105 = v87 & 0xF00;
    unsigned int v101 = v105 >> 8;
    uint64_t v100 = v87;
    if (v105 >> 8) {
      v100 |= 1 << (v101 + 7);
    }
    uint64_t v86 = v100;
    uint64_t v103 = v100;
    unint64_t v85 = v100 & 0xFFFFFF00;
    BOOL v84 = 0;
    BOOL v38 = 1;
    if ((v88 & 1) == 0) {
      BOOL v38 = (v89 & 0x10000000) != 0;
    }
    BOOL v84 = v38;
    unint64_t v91 = v89;
    v89 &= 0xFFFFFFu;
    if (v89)
    {
      if (v89 >= v85)
      {
        if (v84 || (v87 & 0x44000000) != 0) {
          uint64_t v90 = v89;
        }
        else {
          uint64_t v90 = v86;
        }
      }
      else
      {
        uint64_t v90 = v86;
      }
    }
    else
    {
      unsigned int v104 = v87 & 0xF000;
      unsigned int v83 = v104 >> 12;
      if (v104 >> 12)
      {
        unsigned int v93 = v83;
        uint64_t v92 = 1 << (v83 + 7);
        uint64_t v37 = v92 | 0xFF;
      }
      else
      {
        uint64_t v37 = v86;
      }
      uint64_t v90 = v37;
    }
    uint64_t v79 = v90;
  }
  uint64_t v97 = v79;
  uint64_t v96 = v81;
  uint64_t v95 = v80;
  uint64_t v109 = v79;
  BOOL v112 = v79 != -1;
  uint64_t v111 = 2395;
  if (v79 == -1) {
    _dispatch_abort(v111, v112, v11, v12, v13, v14, v15, v16);
  }
  if (_dispatch_set_qos_class_enabled)
  {
    uint64_t v123 = v109;
    uint64_t v122 = 4261412863;
    uint64_t v121 = 0;
    v109 &= 0xFFFFFFFF02FFFFFFLL;
    unint64_t v108 = 0;
    unint64_t v113 = 0;
    unint64_t v113 = _dispatch_thread_getspecific(4uLL);
    unint64_t v108 = (unint64_t)v113;
    uint64_t v107 = 0x1000000;
    uint64_t v106 = 2281701376;
    if ((v113 & 0x1000000) != 0)
    {
      if (v109)
      {
        uint64_t v36 = v109;
      }
      else
      {
        unint64_t v117 = v108;
        uint64_t v116 = v107;
        uint64_t v115 = 0;
        uint64_t v36 = v108 & (~v107 | 0xFFFFFF);
      }
      uint64_t v110 = v36;
    }
    else
    {
      unint64_t v120 = v108;
      uint64_t v119 = v106;
      uint64_t v118 = 0;
      v108 &= ~v106 | 0xFFFFFF;
      if (v109 == v108) {
        uint64_t v110 = 0;
      }
      else {
        uint64_t v110 = v109;
      }
    }
  }
  else
  {
    uint64_t v110 = 0;
  }
  uint64_t v97 = v110;
  if (v110) {
    goto LABEL_49;
  }
  if (v96 == -1)
  {
    uint64_t v98 = -1;
    goto LABEL_50;
  }
  BOOL v35 = (void *)v96;
  if (v35 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    uint64_t v98 = _dispatch_set_priority_and_voucher_slow(v97, (_DWORD *)v96, v95);
  }
  else
  {
    BOOL v94 = (v95 & 4) != 0;
    if ((v95 & 2) != 0)
    {
      if (v94 && v96)
      {
        uint64_t v114 = v96;
        os_release((void *)v96);
      }
      uint64_t v96 = -1;
    }
    else if (!v94 && v96)
    {
      object = (void *)v96;
      os_retain((void *)v96);
    }
    uint64_t v98 = v96;
  }
LABEL_50:
  v51[8] = 0;
  uint64_t v43 = 0;
  if ((v50 & 0x1000000) != 0) {
    uint64_t v43 = _dispatch_autorelease_pool_push();
  }
  if ((v50 & 4) != 0)
  {
    _dispatch_client_callout3(*(void *)(v48 + 48), reason, (uint64_t)v51, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))((char *)&dword_18 + (void)_dispatch_mach_xpc_hooks));
  }
  else
  {
    if (((*(_WORD *)(v49 + 116) >> 2) & 1) == 0) {
      _dispatch_mach_connect_invoke(v49);
    }
    if (reason == 2 && (v55 = v49, v54 = 0, v53 = *(_DWORD *)(v49 + 80), v54 = v53, int v52 = v53, (v53 & 0x10000000) != 0))
    {
      msg = (mach_msg_header_t *)_dispatch_mach_msg_get_msg((uint64_t)v51);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v18, v19, v20, v21, v22, v23, v24, 2483);
      mach_msg_destroy(msg);
    }
    else
    {
      int v34 = 0;
      if (*(void *)(v48 + 40)) {
        int v34 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v48 + 40);
      }
      _dispatch_client_callout4(*(void *)(v48 + 48), reason, (uint64_t)v51, v47, v34);
    }
  }
  if (v43) {
    _dispatch_autorelease_pool_pop(v43);
  }
  int v60 = v51;
  unsigned int v126 = v51;
  int v131 = 772079660;
  int v130 = v51;
  uint64_t v129 = 0;
  uint64_t v128 = 0;
  uint64_t v127 = 0;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  uint64_t v132 = v60;
  dispatch_release((dispatch_object_t)v51);
  dispatch_object_t v62 = __b;
  BOOL v31 = _dispatch_thread_getspecific(0x17uLL) == __b;
  BOOL v64 = v31;
  uint64_t v63 = 449;
  if (!v31) {
    _dispatch_abort(v63, v64, v25, v26, v27, v28, v29, v30);
  }
  _dispatch_thread_setspecific(23, *v62);
  if (__b[3]) {
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  }
  _dispatch_release(a1[7]);
  uint64_t v65 = a1;
  uint64_t v68 = a1;
  uint64_t v67 = 0;
  uint64_t result = _dispatch_thread_getspecific(0x16uLL);
  uint64_t v67 = result;
  int v66 = 0;
  if (result) {
    int v33 = *((_DWORD *)v67 + 2) + 1;
  }
  else {
    int v33 = 1;
  }
  int v66 = v33;
  if (v33 <= _dispatch_continuation_cache_limit)
  {
    v68[2] = v67;
    *((_DWORD *)v68 + 2) = v66;
    uint64_t result = (void *)_dispatch_thread_setspecific(22, (uint64_t)v68);
    uint64_t v69 = 0;
  }
  else
  {
    uint64_t v69 = v68;
  }
  uint64_t v65 = v69;
  if (v69) {
    return _dispatch_continuation_free_to_cache_limit(v65);
  }
  return result;
}

uint64_t dispatch_mach_msg_get_filter_policy_id(uint64_t a1, _DWORD *a2)
{
  if (!a2)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Filter id should be non-NULL";
    qword_F42C0 = 0;
    __break(1u);
    JUMPOUT(0x80830);
  }
  uint64_t result = dispatch_mach_msg_get_msg(a1, 0);
  if (!result)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Messsage should be non-NULL";
    qword_F42C0 = a1;
    __break(1u);
    JUMPOUT(0x80894);
  }
  uint64_t v5 = (unsigned int *)(result + ((*(unsigned int *)(result + 4) + 3) & 0x1FFFFFFFCLL));
  if (*v5)
  {
    uint64_t v3 = *v5;
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Trailer format is invalid";
    qword_F42C0 = v3;
    __break(1u);
    JUMPOUT(0x80904);
  }
  if (v5[1] < 0x44)
  {
    uint64_t v4 = v5[1];
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Trailer doesn't contain filter policy id";
    qword_F42C0 = v4;
    __break(1u);
    JUMPOUT(0x8097CLL);
  }
  *a2 = v5[15];
  return result;
}

uint64_t dispatch_mig_server(uint64_t a1, uint64_t a2, uint64_t (*a3)(mach_msg_header_t *, mach_msg_header_t *))
{
  uint64_t v60 = a1;
  uint64_t v59 = a2;
  BOOL v58 = a3;
  mach_msg_option_t v57 = 117442818;
  mach_msg_option_t v56 = 0;
  uint64_t v55 = 0;
  int v54 = 0;
  int v53 = 0;
  unsigned int v52 = 0;
  int v51 = 0;
  uint64_t v50 = 0;
  int v49 = 1000;
  int v48 = 0;
  char v47 = 0;
  size_t v46 = a2 + 68;
  uint64_t v45 = 0;
  uint64_t v45 = *(void *)(a1 + 88);
  int v34 = (mach_msg_header_t *)&v27[-((a2 + 83) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v34, a2 + 68);
  int v54 = v34;
  v34[1].msgh_remote_port = 0;
  unsigned int v70 = v54;
  size_t v69 = v46;
  for (unint64_t i = (unsigned char *)(((unint64_t)v54 + vm_page_size) & ~vm_page_mask);
        i < (unsigned char *)v70 + v69;
        i += vm_page_size)
  {
    *unint64_t i = 0;
  }
  int v33 = (mach_msg_header_t *)&v27[-((v46 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v33, v46);
  int v53 = v33;
  v33->uint64_t msgh_size = 0;
  uint64_t v67 = v53;
  size_t v66 = v46;
  for (unint64_t j = (unsigned char *)(((unint64_t)v53 + vm_page_size) & ~vm_page_mask);
        j < (unsigned char *)v67 + v66;
        j += vm_page_size)
  {
    *unint64_t j = 0;
  }
  v57 |= 4u;
  mach_msg_option_t v56 = v57;
  while (1)
  {
    int v44 = 0;
    uint64_t v43 = v60;
    uint64_t v64 = v60;
    int v63 = 0;
    int v62 = *(_DWORD *)(v60 + 80);
    int v63 = v62;
    int v61 = v62;
    int v44 = v62;
    uint64_t v42 = 0;
    uint64_t v41 = *(void *)(v60 + 56);
    uint64_t v42 = v41;
    uint64_t v40 = v41;
    uint64_t v71 = v41;
    if ((v41 & 0xFF80000000000000) != 0 || (v44 & 0x10000000) != 0 || (--v49, !v49))
    {
      v57 &= ~2u;
      v56 &= ~2u;
      if ((v56 & 1) == 0) {
        break;
      }
    }
    unsigned int v52 = mach_msg(v53, v56, v53->msgh_size, v46, *(_DWORD *)(v45 + 24), 0, 0);
    mach_msg_option_t v56 = v57;
    if (v52)
    {
      unsigned int v32 = v52;
      if (v52 == 268435460 || v52 == 268435459)
      {
        _dispatch_mig_consume_unsent_message(v53, v3, v4, v5, v6, v7, v8, v9);
      }
      else if (v32 != 268451842)
      {
        if (v32 == 268451843)
        {
          if (v53->msgh_remote_port || (v47 & 1) != 0) {
            return 0;
          }
        }
        else
        {
          if (v32 == 268451844)
          {
            v56 &= 0xFFFFFFFA;
            size_t v39 = 0;
            size_t v39 = v53->msgh_size + 68;
            BOOL v38 = 0;
            BOOL v38 = (mach_msg_header_t *)malloc_type_malloc();
            if (v38)
            {
              size_t v46 = v39;
              int v53 = v38;
            }
            if (!mach_msg(v53, v56, 0, v46, *(_DWORD *)(v45 + 24), 0, 0))
            {
              _dispatch_log("BUG in libdispatch client: dispatch_mig_server received message larger than requested size %zd: id = 0x%x, size = %d", v11, v12, v13, v14, v15, v16, v17, v59);
              mach_msg_destroy(v53);
            }
            if (v38) {
              free(v38);
            }
          }
          _dispatch_bug_mach_client((uint64_t)"dispatch_mig_server: mach_msg() failed", v52);
        }
      }
      return v52;
    }
    if ((v56 & 2) == 0) {
      return v52;
    }
    if (v50) {
      uint64_t v50 = 0;
    }
    char v47 = 1;
    uint64_t v55 = v54;
    int v54 = v53;
    int v53 = v55;
    int v73 = voucher_create_with_mach_msg(v54, v3, v4, v5, v6, v7, v8, v9);
    uint64_t v72 = 0;
    uint64_t v76 = (uint64_t)v73;
    uint64_t v75 = 0;
    uint64_t v75 = _dispatch_thread_getspecific(0x1CuLL);
    unint64_t v85 = v75;
    uint64_t v84 = v76;
    if (v75 == (_DWORD *)v76)
    {
      int v86 = -1;
    }
    else
    {
      if (v85)
      {
        int v83 = 0;
        int v82 = 0;
      }
      _dispatch_thread_setspecific(28, v84);
      if (v84)
      {
        int v81 = 0;
        int v80 = 0;
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v18, v19, v20, v21, v22, v23, v24, 400);
      int v79 = 0;
      if (v84) {
        int v31 = *(_DWORD *)(v84 + 32);
      }
      else {
        int v31 = 0;
      }
      int v79 = v31;
      int v78 = 0;
      if (v85) {
        int v30 = v85[8];
      }
      else {
        int v30 = 0;
      }
      int v78 = v30;
      if (v79 == v30) {
        int v29 = -1;
      }
      else {
        int v29 = v79;
      }
      int v86 = v29;
    }
    int v77 = v86;
    if (v86 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0, v77);
    }
    uint64_t v72 = v75;
    if (v75)
    {
      uint64_t v74 = v72;
      os_release(v72);
    }
    uint64_t v25 = v53;
    uint64_t v35 = 0;
    uint64_t v36 = 0;
    uint64_t v37 = 0;
    *(_OWORD *)&v53->msgh_bits = 0u;
    *(void *)&v25->msgh_voucher_port = v37;
    int v48 = v58(v54, v53);
    if (v48) {
      int v51 = _dispatch_mig_return_code((uint64_t)v53);
    }
    else {
      int v51 = -303;
    }
    int v28 = v51;
    if (v51 == -305)
    {
      v53->msgh_remote_port = 0;
    }
    else if (v28)
    {
      v54->msgh_remote_port = 0;
      mach_msg_destroy(v54);
    }
    if (v53->msgh_remote_port)
    {
      v56 |= 1u;
      if ((v53->msgh_bits & 0x1F) != 0x12) {
        v56 |= 0x10u;
      }
    }
  }
  return v52;
}

void _dispatch_mig_consume_unsent_message(mach_msg_header_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  kern_return_t v9;
  mach_port_name_t msgh_local_port;

  msgh_local_port = a1->msgh_local_port;
  if (msgh_local_port && msgh_local_port != -1)
  {
    uint64_t v9 = 0;
    int v8 = (a1->msgh_bits >> 8) & 0x1F;
    if (v8 == 16)
    {
      uint64_t v9 = mach_port_mod_refs(mach_task_self_, msgh_local_port, 1u, -1);
    }
    else if (v8 == 18 || v8 == 17)
    {
      uint64_t v9 = mach_port_deallocate(mach_task_self_, msgh_local_port);
    }
    if (v9 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x81404);
    }
    if (v9) {
      _dispatch_bug(3170, v9, a3, a4, a5, a6, a7, a8);
    }
  }
  mach_msg_destroy(a1);
}

uint64_t _dispatch_mig_return_code(uint64_t a1)
{
  if (*(int *)a1 >= 0) {
    return *(unsigned int *)(a1 + 32);
  }
  else {
    return 0;
  }
}

uint64_t dispatch_mach_mig_demux(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  mach_msg_return_t v22;
  int v23;
  uint64_t v24;
  mach_msg_header_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mach_msg_option_t v29;
  long long v30;
  uint64_t v31;
  mach_msg_return_t v32;
  unsigned int v33;
  mach_msg_header_t *v34;
  uint64_t v35;
  mach_msg_id_t msgh_id;
  mach_msg_header_t *msg;
  void v38[4];
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v43;
  uint64_t *v44;
  uint64_t v45;
  BOOL v46;
  unsigned char *i;
  uint64_t v48;
  mach_msg_header_t *v49;

  uint64_t v41 = a1;
  uint64_t v40 = a2;
  size_t v39 = a3;
  v38[3] = a4;
  uint64_t v26 = 0;
  v38[0] = 0;
  v38[1] = "mach_mig_demux";
  v38[2] = a1;
  msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg(a4, 0);
  msgh_id = 0;
  msgh_id = msg->msgh_id;
  int v34 = 0;
  int v33 = 0;
  unsigned int v32 = 0;
  uint64_t v35 = _dispatch_mach_mig_resolve(msgh_id, v40, v39);
  if (v35)
  {
    uint64_t v43 = v38;
    uint64_t v24 = 23;
    v38[0] = _dispatch_thread_getspecific(0x17uLL);
    _dispatch_thread_setspecific(23, (uint64_t)v43);
    int v33 = *(_DWORD *)(v35 + 32) + 68;
    uint64_t v25 = (mach_msg_header_t *)((char *)&v21 - ((v33 + 15) & 0x1FFFFFFF0));
    bzero(v25, v33);
    int v34 = v25;
    int v49 = v25;
    int v48 = v33;
    for (unint64_t i = (unsigned char *)(((unint64_t)v25 + vm_page_size) & ~vm_page_mask);
          i < (unsigned char *)v49 + v48;
          i += vm_page_size)
    {
      *unint64_t i = 0;
    }
    uint64_t v4 = v34;
    LODWORD(v3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = msg->msgh_bits & 0x1F;
    DWORD1(v3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 36;
    *((void *)&v30 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = msg->msgh_remote_port;
    LODWORD(v3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
    HIDWORD(v3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = msgh_id + 100;
    long long v5 = v30;
    *(void *)&v34->msgh_voucher_port = v31;
    *(_OWORD *)&v4->msgh_bits = v5;
    (*(void (**)(mach_msg_header_t *, mach_msg_header_t *))(v35 + 8))(msg, v34);
    uint64_t v23 = _dispatch_mig_return_code((uint64_t)v34);
    if (v23 == -305)
    {
      v34->msgh_remote_port = 0;
    }
    else if (v23)
    {
      msg->msgh_remote_port = 0;
      mach_msg_destroy(msg);
    }
    if (v34->msgh_remote_port)
    {
      int v29 = 1;
      if ((v34->msgh_bits & 0x1F) != 0x12) {
        v29 |= 0x10u;
      }
      unsigned int v32 = mach_msg(v34, v29, v34->msgh_size, 0, 0, 0, 0);
      uint64_t v22 = v32;
      if (v32)
      {
        if ((v22 - 268435459) >= 2)
        {
          if (v32 == -301)
          {
            int v28 = -301;
            qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
            qword_F42C0 = -301;
            __break(1u);
            JUMPOUT(0x81838);
          }
          uint64_t v27 = v32;
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_mig_demux: mach_msg(MACH_SEND_MSG) failed";
          qword_F42C0 = v32;
          __break(1u);
          JUMPOUT(0x8187CLL);
        }
        _dispatch_mig_consume_unsent_message(v34, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    int v44 = v38;
    BOOL v19 = _dispatch_thread_getspecific(0x17uLL) == v38;
    size_t v46 = v19;
    uint64_t v45 = 449;
    if (!v19) {
      _dispatch_abort(v45, v46, v13, v14, v15, v16, v17, v18);
    }
    _dispatch_thread_setspecific(23, *v44);
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t _dispatch_mach_mig_resolve(int a1, uint64_t a2, unint64_t a3)
{
  for (unint64_t i = 0; ; ++i)
  {
    if (i >= a3) {
      return 0;
    }
    if (*(_DWORD *)(*(void *)(a2 + 8 * i) + 8) <= a1 && a1 < *(_DWORD *)(*(void *)(a2 + 8 * i) + 12)) {
      break;
    }
  }
  if (*(void *)(*(void *)(a2 + 8 * i) + 32 + 40 * (a1 - *(_DWORD *)(*(void *)(a2 + 8 * i) + 8)) + 8)) {
    return *(void *)(a2 + 8 * i) + 32 + 40 * (a1 - *(_DWORD *)(*(void *)(a2 + 8 * i) + 8));
  }
  else {
    return 0;
  }
}

uint64_t dispatch_mach_mig_demux_get_context()
{
  for (unint64_t i = _dispatch_thread_getspecific(0x17uLL); i; unint64_t i = (void *)*i)
  {
    if (i[1] == (void)"mach_mig_demux")
    {
      uint64_t v2 = i;
      goto LABEL_7;
    }
  }
  uint64_t v2 = 0;
LABEL_7:
  if (!v2)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_mig_demux_get_context not called from dispatch_ma"
                           "ch_mig_demux context";
    __break(1u);
    JUMPOUT(0x81B0CLL);
  }
  return v2[2];
}

uint64_t _dispatch_mach_msg_set_reason(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 0xFFFFFFFFFFFFC000) != 0) {
    _dispatch_abort(597, a3 & 0xFFFFFFFFFFFFC000, a3, a4, a5, a6, a7, a8);
  }
  if (!a2 && a3) {
    int v8 = a3 | 0xF8F80000;
  }
  else {
    int v8 = a2;
  }
  *(_DWORD *)(result + 48) = v8;
  return result;
}

uint64_t _dispatch_mach_reply_list_remove_locked(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(result + 72)) {
    _dispatch_abort(310, *(void *)(result + 72) != 0, a3, a4, a5, a6, a7, a8);
  }
  if (*(void *)(result + 64)) {
    *(void *)(*(void *)(result + 64) + 72) = *(void *)(result + 72);
  }
  **(void **)(result + 72) = *(void *)(result + 64);
  *(void *)(result + 64) = -1;
  *(void *)(result + 72) = -1;
  *(void *)(result + 72) = 0;
  return result;
}

void *_dispatch_mach_msg_create_reply_disconnected(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v28 = a1;
  uint64_t v27 = a2;
  uint64_t v26 = a3;
  uint64_t v25 = a1;
  uint64_t v24 = 0;
  int v23 = 0;
  if (a1) {
    int v21 = *(_DWORD *)(v25 + 52);
  }
  else {
    int v21 = *(_DWORD *)(v27 + 24);
  }
  int v23 = v21;
  if (v21)
  {
    if (v27
      && (v22[1] = v27, v33 = v27, v32 = 0, v31 = *(void *)(v27 + 16), v32 = v31, uint64_t v30 = v31, (v34 = v31) == 0)
      && (*(unsigned char *)(v27 + 30) & 1) != 0)
    {
      if (*(void *)(v27 + 56))
      {
        os_release(*(void **)(v27 + 56));
        *(void *)(v27 + 56) = 0;
      }
      _dispatch_destruct_reply_port();
      return 0;
    }
    else
    {
      v22[0] = 0;
      uint64_t v24 = dispatch_mach_msg_create(0, 0x18uLL, 0, v22, a5, a6, a7, a8);
      *(_DWORD *)(v22[0] + 12) = v23;
      if (v25)
      {
        v24[7] = *(void *)(v25 + 56);
        v24[4] = *(void *)(v25 + 32);
        v24[8] = *(void *)(v25 + 64);
        if (v24[8])
        {
          uint64_t v35 = (void *)v24[8];
          os_retain(v35);
        }
      }
      else
      {
        v24[7] = *(unsigned int *)(v27 + 40);
        v24[4] = *(void *)(v27 + 48);
        v24[8] = *(void *)(v27 + 56);
        *(void *)(v27 + 56) = 0;
      }
      _dispatch_mach_msg_set_reason((uint64_t)v24, 0, v26, v8, v9, v10, v11, v12);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: reply disconnected, ctxt %p", v13, v14, v15, v16, v17, v18, v19, 1005);
      return v24;
    }
  }
  else
  {
    if (!v25 && *(void *)(v27 + 56))
    {
      os_release(*(void **)(v27 + 56));
      *(void *)(v27 + 56) = 0;
    }
    return 0;
  }
}

void _dispatch_destruct_reply_port()
{
  int v6 = thread_destruct_special_reply_port();
  if (v6 == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x8201CLL);
  }
  if (v6) {
    _dispatch_bug(515, v6, v0, v1, v2, v3, v4, v5);
  }
}

uint64_t _dispatch_mach_send_drain(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v41 = a3;
  uint64_t v40 = *(void *)(a1 + 120);
  unsigned int v36 = (*(void *)(v40 + 64) & 0x700000000uLL) >> 32;
  char v32 = 0;
  unsigned int v31 = 0;
  do
  {
LABEL_2:
    if (!*(void *)(v40 + 72))
    {
      for (uint64_t i = *(void *)(v40 + 64); ; uint64_t i = v10)
      {
        unint64_t v34 = (i & 0x2000000000) != 0 ? i & 0xFFFFFFC7FFFFFFFFLL : 0;
        uint64_t v9 = i;
        uint64_t v10 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v40 + 64), (unint64_t *)&v10, v34, memory_order_release, memory_order_relaxed);
        if (v10 == v9) {
          break;
        }
      }
      goto LABEL_75;
    }
    uint64_t v30 = *(void *)(v40 + 80);
    if (!v30) {
      uint64_t v30 = _dispatch_wait_for_enqueuer((unint64_t *)(v40 + 80));
    }
    uint64_t v37 = (void *)v30;
    while (1)
    {
      int v29 = v41;
      v41 &= ~8u;
      uint64_t v28 = (void *)v37[2];
      *(void *)(v40 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v28;
      if (!v28)
      {
        for (uint64_t j = *(void *)(v40 + 72); v37 == (void *)(j & 0xFFFFFFFFFFFFFFF8); uint64_t j = v8)
        {
          uint64_t v8 = j;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v40 + 72), (unint64_t *)&v8, 0, memory_order_release, memory_order_relaxed);
          if (v8 == j) {
            goto LABEL_15;
          }
        }
        uint64_t v26 = v37[2];
        if (!v26) {
          uint64_t v26 = _dispatch_wait_for_enqueuer(v37 + 2);
        }
        uint64_t v28 = (void *)v26;
        *(void *)(v40 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v26;
      }
LABEL_15:
      BOOL v24 = 0;
      if (*v37 > 0xFFFuLL)
      {
        uint64_t v23 = 0;
        if (*v37) {
          uint64_t v23 = *v37;
        }
        BOOL v24 = *(void *)(v23 + 16) == 768;
      }
      if (v24)
      {
        if ((v41 & 4) == 0) {
          goto LABEL_55;
        }
        _dispatch_continuation_pop(v37, 0, a2, a1);
        goto LABEL_47;
      }
      if (*v37 <= 0xFFFuLL && (*v37 & 1) != 0)
      {
        BOOL v38 = (dispatch_object_s *)v37[6];
        uint64_t v39 = v37[7];
        goto LABEL_34;
      }
      if (*v37 > 0xFFFuLL) {
        break;
      }
      if (*(void *)(v40 + 16) && _dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q)
      {
        *(_WORD *)(a1 + 118) = *(_WORD *)(a1 + 118) & 0xFFFE | 1;
        v31 |= 2u;
        goto LABEL_55;
      }
      if (!_dispatch_mach_reconnect_invoke((uint64_t *)a1, v37, a3, a4, a5, a6, a7, a8)) {
        goto LABEL_55;
      }
LABEL_47:
      uint64_t v37 = v28;
      if (!v28) {
        goto LABEL_2;
      }
    }
    BOOL v38 = (dispatch_object_s *)v37;
    uint64_t v39 = 0;
LABEL_34:
    if (*((void *)v38 + 8) != -1 && MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    BOOL v22 = 1;
    if (!*(_DWORD *)(v40 + 88)) {
      BOOL v22 = (*(_DWORD *)(a1 + 80) & 0x10000000) != 0;
    }
    if (v22)
    {
      _dispatch_mach_msg_not_sent(a1, v38, v39);
      goto LABEL_47;
    }
    int v33 = _dispatch_mach_msg_send(a1, v38, v39, v36, v29);
    if (v33)
    {
      if ((v33 & 2) != 0) {
        char v32 = 1;
      }
      goto LABEL_47;
    }
    if (*(_WORD *)(a1 + 118)) {
      v31 |= 2u;
    }
LABEL_55:
    v37[2] = v28;
    BOOL v21 = 0;
    if (!v28)
    {
      uint64_t v11 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v40 + 72), (unint64_t *)&v11, (unint64_t)v37, memory_order_release, memory_order_relaxed);
      BOOL v21 = v11 != 0;
    }
    if (v21)
    {
      uint64_t v25 = *(void *)(v40 + 80);
      if (!v25) {
        uint64_t v25 = _dispatch_wait_for_enqueuer((unint64_t *)(v40 + 80));
      }
      v37[2] = v25;
    }
    *(void *)(v40 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v37;
    BOOL v20 = 0;
    if (*v37 > 0xFFFuLL)
    {
      uint64_t v19 = 0;
      if (*v37) {
        uint64_t v19 = *v37;
      }
      BOOL v20 = *(void *)(v19 + 16) == 768;
    }
    if (v20)
    {
      for (uint64_t i = *(void *)(v40 + 64); ; uint64_t i = v13)
      {
        unint64_t v34 = i & 0xFFFFFFC700000000 | 0x3000000000;
        uint64_t v12 = i;
        uint64_t v13 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v40 + 64), (unint64_t *)&v13, v34, memory_order_release, memory_order_relaxed);
        if (v13 == v12) {
          break;
        }
      }
    }
    else
    {
      for (uint64_t i = *(void *)(v40 + 64); ; uint64_t i = v15)
      {
        unint64_t v34 = (i & 0x2800000000) != 0 ? i & 0xFFFFFFC7FFFFFFFFLL : i & 0xFFFFFFDF00000000 | 0x2000000000;
        uint64_t v14 = i;
        uint64_t v15 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v40 + 64), (unint64_t *)&v15, v34, memory_order_release, memory_order_relaxed);
        if (v15 == v14) {
          break;
        }
      }
    }
LABEL_75:
    if ((i & 0x800000000) != 0)
    {
      unsigned int v45 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(i) & 7u) > (v45 & 0xF0000) >> 16) {
        _dispatch_thread_setspecific(25, v45 & 0xFFF0FFFF | ((BYTE4(i) & 7) << 16));
      }
    }
    unsigned int v36 = (v34 & 0x700000000) >> 32;
  }
  while (v34);
  if ((v34 & 0x1000000000) != 0)
  {
    _dispatch_mach_push_send_barrier_drain(a1, v36);
    char v44 = v32 & 1;
  }
  else
  {
    if (!v34 && ((*(_WORD *)(a1 + 118) >> 1) & 1) != 0 && ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0) {
      v31 |= 0x12u;
    }
    if (((i ^ v34) & 0x8000000000) != 0)
    {
      if (v31) {
        v31 |= 1u;
      }
      else {
        _dispatch_release_2(a1);
      }
    }
    if (v31)
    {
      uint64_t v18 = 0;
      if (*(void *)a1) {
        uint64_t v18 = *(void *)a1;
      }
      if (*(_WORD *)(a1 + 118)) {
        unsigned int v17 = (v34 & 0x700000000) >> 32;
      }
      else {
        unsigned int v17 = 0;
      }
      (*(void (**)(uint64_t, void, void))(v18 + 64))(a1, v17, v31);
    }
    char v44 = v32;
  }
  return v44 & 1;
}

void _dispatch_mach_msg_not_sent(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  int v41 = dispatch_semaphore_signal;
  uint64_t v42 = _dispatch_lane_invoke;
  unsigned int v52 = a2;
  uint64_t v51 = a1;
  uint64_t v50 = a3;
  int v49 = a2;
  reply_disconnected = 0;
  char v47 = 0;
  msg = (unsigned int *)_dispatch_mach_msg_get_msg((uint64_t)a2);
  unsigned int v45 = 0;
  unsigned int v45 = *((_DWORD *)v49 + 12);
  uint64_t v3 = _dispatch_thread_getspecific(0);
  uint64_t v4 = msg[2];
  uint64_t v5 = msg[5];
  uint64_t v6 = *((void *)v49 + 4);
  uint64_t v7 = msg[4];
  uint64_t v8 = *((unsigned int *)v49 + 13);
  uint64_t v40 = v35;
  v35[1] = v3;
  v35[2] = v4;
  v35[3] = v5;
  v35[4] = v6;
  v35[5] = v45;
  v35[6] = v7;
  v35[7] = v8;
  _dispatch_log("%u\t%p\tmachport[0x%08x]: not sent msg id 0x%x, ctxt %p, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x", v9, v10, v11, v12, v13, v14, v15, 1021);
  uint64_t v21 = 0;
  uint64_t v44 = 0;
  if ((v45 & 2) == 0) {
    uint64_t v21 = 5;
  }
  uint64_t v44 = v21;
  if (((*(_WORD *)(v51 + 116) >> 4) & 1) != 0 && *((void *)v49 + 4))
  {
    uint64_t v22 = *((void *)v49 + 4);
    uint64_t v55 = v51;
    uint64_t v54 = v22;
    uint64_t v53 = 0;
    uint64_t v53 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v22);
    if (!v53) {
      uint64_t v53 = v55;
    }
    char v47 = (void *)v53;
  }
  uint64_t v43 = v49;
  if (v50) {
    uint64_t v39 = v50;
  }
  else {
    uint64_t v39 = 0;
  }
  if (v47) {
    uint64_t v23 = 12;
  }
  else {
    uint64_t v23 = 7;
  }
  reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected((uint64_t)v43, v39, v23, v16, v17, v18, v19, v20);
  _dispatch_mach_msg_set_reason((uint64_t)v49, 0, v44, v24, v25, v26, v27, v28);
  _dispatch_mach_handle_or_push_received_msg(v51, v49, 0);
  if (reply_disconnected)
  {
    if (v47)
    {
      uint64_t v63 = v51;
      int v62 = reply_disconnected;
      int v61 = v47;
      uint64_t v60 = 0;
      uint64_t v60 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, v51);
      uint64_t v59 = v61;
      BOOL v58 = v60;
      uint64_t v67 = v61;
      size_t v66 = v60;
      int v65 = 0;
      int v64 = 0;
      unsigned int v70 = v61;
      size_t v69 = v60;
      uint64_t v36 = *v61;
      uint64_t v37 = v61;
      uint64_t v38 = 0;
      if (v36) {
        uint64_t v38 = v36;
      }
      char v32 = *(void (**)(void *, void *, uint64_t, uint64_t, uint64_t, uint64_t))(v38 + 72);
      mach_msg_option_t v57 = v61;
      mach_msg_option_t v56 = v60;
      unint64_t v68 = *((void *)v62 + 7);
      v68 &= 0x3FFF00uLL;
      v68 >>= 8;
      unsigned int v33 = __clz(__rbit32(v68));
      if (v68) {
        uint64_t v34 = v33 + 1;
      }
      else {
        uint64_t v34 = 0;
      }
      v32(v57, v56, v34, v29, v30, v31);
    }
    else
    {
      _dispatch_mach_handle_or_push_received_msg(v51, reply_disconnected, 0);
    }
  }
}

uint64_t _dispatch_mach_msg_send(uint64_t a1, void *a2, uint64_t a3, unsigned int a4, int a5)
{
  unint64_t v137 = v167;
  uint64_t v183 = a2;
  uint64_t v182 = a1;
  uint64_t v181 = a3;
  unsigned int v180 = a4;
  int v179 = a5;
  uint64_t v136 = 0;
  uint64_t v178 = 0;
  uint64_t v178 = *(void *)(a1 + 120);
  uint64_t v177 = a2;
  reply_disconnected = 0;
  uint64_t v175 = 0;
  uint64_t v175 = a2[8];
  uint64_t v174 = 0;
  int v138 = 0;
  unsigned int v173 = 0;
  char v172 = 0;
  uint64_t msg = 0;
  uint64_t msg = _dispatch_mach_msg_get_msg((uint64_t)a2);
  BOOL v170 = 0;
  BOOL v170 = (*(_DWORD *)msg & 0x1F) == 18;
  unsigned int v169 = 0;
  unsigned int v169 = *((_DWORD *)v177 + 13);
  memset(v291, 0, 32);
  long long v290 = 0u;
  uint64_t v168 = 0;
  memset(v167, 0, sizeof(v167));
  int v166 = 0;
  if (!v170)
  {
    *(_WORD *)(v182 + 118) &= ~1u;
    uint64_t v12 = *(void *)(v178 + 48);
    BOOL v135 = 0;
    if (v12) {
      BOOL v135 = v177 != *(void **)(v178 + 48);
    }
    if (v135)
    {
      uint64_t v165 = v178;
      uint64_t v203 = v178;
      uint64_t v202 = 0;
      uint64_t v201 = *(void *)(v178 + 16);
      uint64_t v202 = v201;
      uint64_t v200 = v201;
      uint64_t v228 = v201;
      BOOL v134 = 0;
      if (v201) {
        BOOL v134 = _dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q;
      }
      if (v134)
      {
        *(_WORD *)(v182 + 118) |= 1u;
        return v173;
      }
      uint64_t v13 = *(void *)(v178 + 48);
      uint64_t v239 = v182;
      uint64_t v238 = v13;
      int v237 = 0;
      if ((*(_WORD *)(v182 + 116) & 0x10) != 0)
      {
        uint64_t v236 = v238;
        if (_dispatch_mach_msg_get_reply_port(v238))
        {
          uint64_t v14 = *(void *)(v238 + 32);
          uint64_t v242 = v239;
          uint64_t v241 = v14;
          uint64_t v240 = 0;
          uint64_t v240 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v14);
          if (!v240) {
            uint64_t v240 = v242;
          }
          uint64_t v244 = v240;
          uint64_t v243 = 1830;
          if (!v240) {
            _dispatch_abort(v243, 0, v15, v16, v17, v18, v19, v20);
          }
        }
      }
      if ((v237 & 0x40000) != 0)
      {
        *(void *)(v238 + 56) = 0;
      }
      else
      {
        int v235 = 1;
        if ((v237 & 4) != 0) {
          v235 |= 2u;
        }
        unint64_t v246 = 0;
        int v245 = v235;
        if (v235)
        {
          uint64_t v248 = 0;
          uint64_t v248 = _dispatch_thread_getspecific(4uLL);
          unint64_t v246 = (unint64_t)v248;
        }
        unint64_t v249 = v246;
        v246 &= 0xFFFFFFu;
        if ((v245 & 2) != 0 || (unint64_t v133 = v246, v253 = 5, v252 = 4096, v246 <= 0x10FF))
        {
          uint64_t v247 = v246;
        }
        else
        {
          int v251 = 5;
          uint64_t v250 = 4096;
          uint64_t v247 = 4351;
        }
        *(void *)(v238 + 56) = v247;
      }
      uint64_t v254 = 0;
      uint64_t v254 = _dispatch_thread_getspecific(0x1CuLL);
      if (v254)
      {
        object = v254;
        os_retain(v254);
      }
      *(void *)(v238 + 64) = v254;
      uint64_t v132 = 0;
      uint64_t v21 = _dispatch_thread_getspecific(0);
      uint64_t v22 = *(void *)(v238 + 64);
      uint64_t v103 = (void *)v238;
      uint64_t v102 = v22;
      unsigned int v101 = v21;
      _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] set", v23, v24, v25, v26, v27, v28, v29, 1847);
      v237 |= _dispatch_mach_send_options();
      *(_DWORD *)(v238 + 48) = v237;
      uint64_t v164 = *(void *)(v178 + 48);
      if (!_dispatch_mach_msg_send(v182, v164, 0, v180, 0))
      {
        unint64_t v163 = 0;
        unint64_t v163 = *(void **)(*(void *)(v178 + 48) + 64);
        if (v163)
        {
          int v229 = v163;
          os_release(v163);
          *(void *)(*(void *)(v178 + 48) + 64) = 0;
        }
        return v173;
      }
      if ((*(_WORD *)(v182 + 116) & 0x20) != 0) {
        _dispatch_mach_arm_no_senders(v182, 1);
      }
      *(void *)(v178 + 48) = 0;
    }
  }
  mach_error_t error_value = 0;
  unsigned int v161 = 0;
  unsigned int v160 = 0;
  unsigned int v160 = *((_DWORD *)v177 + 12);
  if ((v160 & 2) != 0) {
    goto LABEL_117;
  }
  int v159 = 0;
  unsigned int v161 = (HIWORD(v160) << 16) | 1;
  if (v170)
  {
LABEL_88:
    if ((v160 & 4) != 0)
    {
      if (*(unsigned char *)(v181 + 30))
      {
        v161 |= 0x100000u;
        _dispatch_clear_thread_reply_port(v169);
      }
      _dispatch_mach_reply_waiter_register(v182, v181, v169, v177);
    }
    long long v150 = (unint64_t)msg;
    uint64_t v151 = *(unsigned int *)(msg + 4);
    v291[0] = v151;
    *((_OWORD *)v137 + 67) = (unint64_t)msg;
    uint64_t v128 = &v291[1];
    *(void *)&long long v148 = v167;
    *((void *)&v148 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
    uint64_t v129 = v149;
    if (v166) {
      int v127 = v167[0];
    }
    else {
      int v127 = 0;
    }
    int v64 = v128;
    *uint64_t v129 = v127;
    v149[1] = 0;
    long long v65 = v148;
    v64[2] = v149[0];
    *(_OWORD *)int v64 = v65;
    long long v66 = *(_OWORD *)msg;
    uint64_t v147 = *(void *)(msg + 16);
    long long v146 = v66;
    mach_error_t error_value = mach_msg2();
    uint64_t v125 = _dispatch_thread_getspecific(0);
    uint64_t v122 = (const char *)v177[4];
    uint64_t v124 = *(unsigned int *)(msg + 8);
    uint64_t v123 = (void *)*(unsigned int *)(msg + 20);
    uint64_t v121 = v161;
    uint64_t v120 = v160;
    uint64_t v119 = *(unsigned int *)(msg + 16);
    uint64_t v118 = v169;
    uint64_t v67 = mach_error_string(error_value);
    unsigned int v126 = &v100;
    uint64_t v110 = error_value;
    uint64_t v109 = v67;
    uint64_t v108 = v118;
    uint64_t v107 = v119;
    uint64_t v106 = v120;
    uint64_t v105 = v121;
    unsigned int v104 = v122;
    uint64_t v103 = v123;
    uint64_t v102 = v124;
    unsigned int v101 = v125;
    _dispatch_log("%u\t%p\tmachport[0x%08x]: sent msg id 0x%x, ctxt %p, opts 0x%x, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x: %s - 0x%x", v68, v69, v70, v71, v72, v73, v74, 1193);
    int v117 = 0;
    if (error_value) {
      int v117 = (v160 >> 2) & 1;
    }
    if (v117)
    {
      int v145 = 36;
      uint64_t v216 = v181;
      uint64_t v215 = 1196;
      if (!v181) {
        _dispatch_abort(v215, 0, v6, v7, v8, v9, v10, v11);
      }
      _dispatch_mach_reply_unregister(v182, v181, v145);
    }
    if (v172)
    {
      if (error_value == 268435461 && *(_DWORD *)(msg + 16))
      {
        uint64_t v144 = error_value;
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher port corruption";
        qword_F42C0 = error_value;
        __break(1u);
        JUMPOUT(0x848A4);
      }
      mach_port_name_t v143 = 0;
      int v234 = (_DWORD *)msg;
      char v233 = 0;
      int v232 = 0;
      int v232 = HIWORD(*(_DWORD *)msg) & 0x1F;
      mach_port_name_t v231 = 0;
      mach_port_name_t v231 = *(_DWORD *)(msg + 16);
      mach_port_name_t v230 = 0;
      if ((v232 == 19 || v232 == 17) && v231)
      {
        uint64_t v75 = _dispatch_thread_getspecific(0);
        if (v233) {
          int v83 = "move-send";
        }
        else {
          int v83 = "copy-send";
        }
        unsigned int v104 = v83;
        uint64_t v103 = v234;
        uint64_t v102 = v231;
        unsigned int v101 = v75;
        _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v76, v77, v78, v79, v80, v81, v82, 520);
        if (v232 == 17)
        {
          if (v233) {
            mach_port_name_t v230 = v231;
          }
          else {
            _voucher_dealloc_mach_voucher(v231);
          }
        }
        v234[4] = 0;
        *v234 &= 0xFFE0FFFF;
      }
      mach_port_name_t v143 = v230;
    }
LABEL_117:
    if (error_value == 268435460 && (v161 & 0x10) != 0)
    {
      if (*(_DWORD *)(msg + 8) == -1)
      {
        *(_DWORD *)msg &= 0xFFFFFFE0;
        *(_DWORD *)msg |= 0x13u;
      }
      if ((v161 & 0x80) != 0) {
        _dispatch_mach_notification_set_armed(v178, v5, v6, v7, v8, v9, v10, v11);
      }
      else {
        *(_WORD *)(v182 + 118) |= 1u;
      }
    }
    else
    {
      uint64_t v142 = 0;
      uint64_t v142 = *(void *)(v182 + 88);
      if ((v160 & 4) == 0 && !error_value)
      {
        if (v169)
        {
          uint64_t v141 = v142;
          uint64_t v191 = v142;
          uint64_t v190 = 0;
          uint64_t v189 = *(void *)(v142 + 16);
          uint64_t v190 = v189;
          uint64_t v188 = v189;
          uint64_t v225 = v189;
          if (!v189 || *(_DWORD *)(v142 + 24) != v169) {
            _dispatch_mach_reply_kevent_register(v182, v169, v177);
          }
        }
      }
      BOOL v116 = 0;
      if (!v170)
      {
        uint64_t v84 = *(void **)(v178 + 48);
        BOOL v116 = 0;
        if (v177 == v84)
        {
          uint64_t v140 = v178;
          uint64_t v187 = v178;
          uint64_t v186 = 0;
          uint64_t v185 = *(void *)(v178 + 16);
          uint64_t v186 = v185;
          uint64_t v184 = v185;
          uint64_t v224 = v185;
          BOOL v116 = v185 != 0;
        }
      }
      if (v116)
      {
        uint64_t v276 = v182;
        int v115 = 0;
        unsigned int v275 = 5;
        dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
        uint64_t v274 = *(void *)(v276 + 120);
        _dispatch_unote_unregister(v274, v275, v85, v86, v87, v88, v89, v90);
        *(_DWORD *)(*(void *)(v276 + 120) + 24) = v115;
      }
      if (error_value)
      {
        if ((*(_WORD *)(v182 + 116) & 0x10) != 0 && v177[4])
        {
          uint64_t v91 = v177[4];
          uint64_t v206 = v182;
          uint64_t v205 = v91;
          uint64_t v204 = 0;
          uint64_t v204 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v91);
          if (!v204) {
            uint64_t v204 = v206;
          }
          uint64_t v174 = (void *)v204;
        }
        uint64_t v139 = v177;
        if (v181) {
          uint64_t v114 = v181;
        }
        else {
          uint64_t v114 = 0;
        }
        if (v174) {
          uint64_t v92 = 12;
        }
        else {
          uint64_t v92 = 7;
        }
        reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected((uint64_t)v139, v114, v92, v7, v8, v9, v10, v11);
      }
      _dispatch_mach_msg_set_reason((uint64_t)v177, error_value, 0, v7, v8, v9, v10, v11);
      if (v179 & 8) != 0 && (v160) {
        v173 |= 2u;
      }
      else {
        _dispatch_mach_handle_or_push_received_msg(v182, (dispatch_object_s *)v177, 0);
      }
      if (reply_disconnected)
      {
        if (v174)
        {
          uint64_t v214 = v182;
          BOOL v213 = reply_disconnected;
          unint64_t v212 = (unint64_t)v174;
          BOOL v211 = 0;
          BOOL v211 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, v182);
          unint64_t v210 = v212;
          int v209 = v211;
          unint64_t v222 = v212;
          int v221 = v211;
          int v220 = 0;
          int v219 = 0;
          unint64_t v289 = v212;
          v288 = v211;
          uint64_t v111 = *(void *)v212;
          uint64_t v112 = v212 & 0xFFFFFFFFFFFFLL | 0x6AE1000000000000;
          uint64_t v113 = 0;
          if (v111) {
            uint64_t v113 = v111;
          }
          uint64_t v96 = *(void (**)(unint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t))(v113 + 72);
          unint64_t v208 = v212;
          int v207 = v211;
          LODWORD(v223) = *((void *)v213 + 7);
          v223 &= 0x3FFF00u;
          v223 >>= 8;
          unsigned int v97 = __clz(__rbit32(v223));
          if (v223) {
            uint64_t v98 = v97 + 1;
          }
          else {
            uint64_t v98 = 0;
          }
          v96(v208, v207, v98, v93, v94, v95);
        }
        else
        {
          _dispatch_mach_handle_or_push_received_msg(v182, reply_disconnected, 0);
        }
      }
      v173 |= 1u;
    }
    return v173;
  }
  if (v177 != *(void **)(v178 + 48)) {
    *(_DWORD *)(msg + 8) = *(_DWORD *)(v178 + 92);
  }
  if (_dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q)
  {
LABEL_47:
    v161 |= 0x10u;
    if (v175 && *(void *)(v175 + 48))
    {
      uint64_t v42 = v137;
      int v166 = 32;
      *(void *)&long long v152 = 59821818;
      *((void *)&v152 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *(void *)(v175 + 48);
      long long v153 = *(_OWORD *)(v175 + 56);
      long long v43 = v152;
      *(_OWORD *)(v137 + 6) = v153;
      *(_OWORD *)(v42 + 2) = v43;
    }
    if (v166) {
      v167[0] = v166 + 8;
    }
    uint64_t v44 = _dispatch_thread_getspecific(0);
    uint64_t v103 = v177;
    uint64_t v102 = v175;
    unsigned int v101 = v44;
    _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] msg_set", v45, v46, v47, v48, v49, v50, v51, 1149);
    unsigned int v265 = (_DWORD *)msg;
    uint64_t v264 = v175;
    if ((*(_DWORD *)msg & 0x1F0000) != 0)
    {
      char v266 = 0;
    }
    else
    {
      int mach_voucher = 0;
      if (v264)
      {
        int mach_voucher = _voucher_get_mach_voucher(v264);
      }
      else
      {
        v283 = &_voucher_task_mach_voucher_pred;
        v282 = 0;
        dispatch_function_t v281 = (dispatch_function_t)_voucher_task_mach_voucher_init;
        if (_voucher_task_mach_voucher_pred != -1) {
          dispatch_once_f(v283, v282, v281);
        }
        int mach_voucher = _voucher_task_mach_voucher;
      }
      unsigned int v279 = v265;
      unsigned int v278 = mach_voucher;
      char v277 = 0;
      if ((*v265 & 0x1F0000) != 0)
      {
        char v280 = 0;
      }
      else if (v278)
      {
        v279[4] = v278;
        if (v277) {
          int v52 = 1114112;
        }
        else {
          int v52 = 1245184;
        }
        *v279 |= v52;
        uint64_t v53 = _dispatch_thread_getspecific(0);
        if (v277) {
          int v61 = "move-send";
        }
        else {
          int v61 = "copy-send";
        }
        unsigned int v104 = v61;
        uint64_t v103 = v279;
        uint64_t v102 = v278;
        unsigned int v101 = v53;
        _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] set %s", v54, v55, v56, v57, v58, v59, v60, 476);
        char v280 = 1;
      }
      else
      {
        char v280 = 0;
      }
      char v266 = v280;
    }
    char v172 = v266;
    uint64_t v271 = v177;
    unsigned int v270 = v180;
    uint64_t v269 = &v161;
    unsigned int v284 = v180;
    if (v180 > 4) {
      int v131 = 5;
    }
    else {
      int v131 = v284;
    }
    unsigned int v270 = v131;
    if (v131)
    {
      unsigned __int8 v268 = 0;
      int v267 = 0;
      unint64_t v273 = v271[7];
      v273 &= 0x3FFF00uLL;
      v273 >>= 8;
      char v62 = __clz(__rbit32(v273));
      if (v273) {
        unsigned __int8 v63 = v62 + 1;
      }
      else {
        unsigned __int8 v63 = 0;
      }
      unsigned __int8 v268 = v63;
      uint64_t v285 = v271[7];
      uint64_t v287 = v285;
      BOOL v130 = 0;
      if ((v285 & 0x22000000) == 0) {
        BOOL v130 = (v287 & 0x3F00) != 0;
      }
      if (v130)
      {
        uint64_t v285 = v285;
        int v286 = (char)v285 + 1;
      }
      else
      {
        int v286 = 0;
      }
      int v267 = v286;
      *v269 |= 0x20u;
      int v272 = mach_msg_priority_encode_inline(v270, v268, v267);
    }
    else
    {
      int v272 = 0;
    }
    int v159 = v272;
    if (v169 && (*(_WORD *)(v182 + 116) & 0x80) != 0) {
      v161 |= 0x200u;
    }
    goto LABEL_88;
  }
  uint64_t v158 = v178;
  uint64_t v199 = v178;
  uint64_t v198 = 0;
  uint64_t v197 = *(void *)(v178 + 16);
  uint64_t v198 = v197;
  uint64_t v196 = v197;
  uint64_t v227 = v197;
  if (!v197)
  {
    int v30 = *(_DWORD *)(msg + 8);
    uint64_t v260 = v182;
    int v259 = v30;
    dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
    *(_DWORD *)(*(void *)(v260 + 120) + 24) = v259;
    char v258 = 0;
    uint64_t v257 = *(void *)(v260 + 120);
    char v258 = _dispatch_unote_register(v257, -4, 0x2000000, v31, v32, v33, v34, v35);
    uint64_t v262 = v258 & 1;
    uint64_t v261 = 1743;
    if ((v258 & 1) == 0) {
      _dispatch_bug(v261, v262, v36, v37, v38, v39, v40, v41);
    }
    char v256 = v258 & 1;
    uint64_t v157 = v178;
    uint64_t v195 = v178;
    uint64_t v194 = 0;
    uint64_t v193 = *(void *)(v178 + 16);
    uint64_t v194 = v193;
    uint64_t v192 = v193;
    uint64_t v226 = v193;
    BOOL v218 = v193 != 0;
    uint64_t v217 = 1125;
    if (!v193) {
      _dispatch_abort(v217, v218, v36, v37, v38, v39, v40, v41);
    }
  }
  char v156 = 0;
  char v155 = *(unsigned char *)(v178 + 30);
  char v156 = v155 & 1;
  char v154 = v155 & 1;
  if ((v155 & 1) == 0)
  {
    v161 |= 0x80u;
    goto LABEL_47;
  }
  return v173;
}

void _dispatch_mach_push_send_barrier_drain(uint64_t a1, unsigned int a2)
{
  uint64_t v10 = _dispatch_thread_getspecific(0x16uLL);
  if (v10)
  {
    _dispatch_thread_setspecific(22, v10[2]);
    uint64_t v9 = v10;
  }
  else
  {
    uint64_t v9 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  void *v9 = &unk_ECC90;
  v9[4] = 0;
  v9[5] = 0;
  v9[3] = -1;
  v9[1] = -1;
  _dispatch_lane_push(a1, v9, a2, v2, v3, v4, v5, v6);
}

void _dispatch_clear_thread_reply_port(int a1)
{
  unsigned int v15 = _dispatch_thread_getspecific(8uLL);
  if (a1 == v15)
  {
    _dispatch_thread_setspecific(8, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: cleared thread sync reply port", v8, v9, v10, v11, v12, v13, v14, 555);
  }
  else if (v15)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: did not clear thread sync reply port (found 0x%08x)", v1, v2, v3, v4, v5, v6, v7, 548);
  }
}

void *_dispatch_mach_reply_waiter_register(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  *(void *)(a2 + 8) = ~a1;
  *(unsigned char *)(a2 + 28) = -8;
  *(_DWORD *)(a2 + 24) = a3;
  if ((*(unsigned char *)(a2 + 30) & 1) == 0)
  {
    if (a4[8])
    {
      unsigned int v15 = (void *)a4[8];
      os_retain(v15);
      *(void *)(a2 + 56) = v15;
    }
    *(_DWORD *)(a2 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = a4[7];
    *(void *)(a2 + 48) = a4[4];
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for sync reply, ctxt %p", v4, v5, v6, v7, v8, v9, v10, 432);
  return _dispatch_mach_reply_list_insert(*(void *)(a1 + 120), a2);
}

uint64_t mach_msg2()
{
  return mach_msg2_internal();
}

void _dispatch_mach_reply_kevent_register(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v36 = a1;
  unsigned int v35 = a2;
  uint64_t v34 = a3;
  unsigned int v32 = 0;
  unsigned int v31 = 0;
  unsigned int v30 = 0;
  unsigned int v29 = 0;
  unint64_t v28 = 0;
  uint64_t v33 = off_ED430((uint64_t)&_dispatch_mach_type_reply, a2, 0);
  uint64_t v49 = *(unsigned char *)(v33 + 29) & 1;
  uint64_t v48 = 447;
  if (!v49) {
    _dispatch_abort(v48, 0, v3, v4, v5, v6, v7, v8);
  }
  *(void *)(v33 + 8) = ~v36;
  if (v34[8])
  {
    uint64_t v50 = (void *)v34[8];
    os_retain(v50);
    *(void *)(v33 + 56) = v50;
  }
  *(_DWORD *)(v33 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v34[7];
  *(void *)(v33 + 48) = v34[4];
  unint64_t v27 = 0;
  if (((*(_WORD *)(v36 + 116) >> 4) & 1) != 0 && v34[4])
  {
    uint64_t v9 = v34[4];
    uint64_t v47 = v36;
    uint64_t v46 = v9;
    uint64_t v45 = 0;
    uint64_t v45 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (void)_dispatch_mach_xpc_hooks))(v9);
    if (!v45) {
      uint64_t v45 = v47;
    }
    unint64_t v27 = v45;
  }
  if ((*(_WORD *)(v36 + 116) >> 7)) {
    *(_DWORD *)(v33 + 32) |= 0x200u;
  }
  if (!v27 || (BOOL v26 = 0, v27 == v36))
  {
    uint64_t v44 = *(void *)(v36 + 88);
    uint64_t v43 = 0;
    uint64_t v42 = *(void *)(v44 + 16);
    uint64_t v43 = v42;
    uint64_t v41 = v42;
    uint64_t v53 = v42;
    BOOL v26 = (v42 & 0xFFFFFFFFFFFFFFFCLL) != 0;
  }
  if (v26)
  {
    uint64_t v40 = *(void *)(v36 + 88);
    uint64_t v39 = 0;
    uint64_t v38 = *(void *)(v40 + 16);
    uint64_t v39 = v38;
    uint64_t v37 = v38;
    uint64_t v52 = v38;
    unint64_t v28 = v38 & 0xFFFFFFFFFFFFFFFCLL;
    unsigned int v31 = *(_DWORD *)(v36 + 84);
  }
  else
  {
    uint64_t v25 = 0;
    if (*(void *)v27) {
      uint64_t v25 = *(void *)v27;
    }
    if ((*(void *)(v25 + 16) & 0x10000) != 0)
    {
      unint64_t v28 = -4;
      unint64_t v54 = v27;
      BOOL v24 = 0;
      if (v27 >= (unint64_t)&_dispatch_root_queues) {
        BOOL v24 = v54 < (unint64_t)&qword_F0A80;
      }
      if (v24) {
        unsigned int v31 = *(_DWORD *)(v27 + 84);
      }
      else {
        unsigned int v31 = 0x2000000;
      }
    }
    else
    {
      unsigned int v31 = _dispatch_queue_compute_priority_and_wlh(v27, (uint64_t *)&v28);
      if (!v31)
      {
        unint64_t v28 = -4;
        unsigned int v31 = *(_DWORD *)(v27 + 84);
      }
    }
  }
  uint64_t v57 = v34[7];
  char v56 = 0;
  BOOL v59 = (v57 & 0x20000000) == 0;
  uint64_t v58 = 458;
  if ((v57 & 0x20000000) != 0) {
    _dispatch_abort(v58, 0, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v55 = v57;
  unint64_t v60 = v57 & 0x3FFF00;
  v60 >>= 8;
  unsigned int v10 = __clz(__rbit32(v60));
  if (v60) {
    unsigned int v11 = v10 + 1;
  }
  else {
    unsigned int v11 = 0;
  }
  v55 |= v11 << 8;
  unsigned int v32 = v55;
  unsigned int v30 = v31 & 0x80000000;
  unsigned int v51 = v31 & 0xF000;
  unsigned int v29 = v51 >> 12;
  if ((v31 & 0xFFF) != 0)
  {
    v31 &= 0xFFFu;
    if (v31 < v32) {
      unsigned int v31 = v32;
    }
    v31 |= v30;
  }
  else if (v29 && v32)
  {
    unsigned int v31 = v32 | v30;
  }
  else if (!v29 || v32)
  {
    unsigned int v31 = 0x2000000;
    unint64_t v28 = -4;
  }
  else
  {
    unsigned int v31 = (v29 << 8) & 0xF00 | 0xFF | v30;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for reply, ctxt %p", v12, v13, v14, v15, v16, v17, v18, 495);
  _dispatch_mach_reply_list_insert(*(void *)(v36 + 120), v33);
  if ((_dispatch_unote_register(v33, v28, v31, v19, v20, v21, v22, v23) & 1) == 0) {
    _dispatch_mach_reply_unregister(v36, v33, 52);
  }
}

uint64_t _dispatch_mach_send_options()
{
  unsigned int v0 = (_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
  unsigned int v1 = __clz(__rbit32(v0));
  if (v0) {
    unsigned int v2 = v1 + 1;
  }
  else {
    unsigned int v2 = 0;
  }
  BOOL v4 = 0;
  if (v2) {
    BOOL v4 = v2 <= 2;
  }
  if (v4) {
    return 0x40000;
  }
  else {
    return 0;
  }
}

uint64_t mach_msg_priority_encode_inline(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  unsigned int v4 = 0;
  if (a2 && a2 <= 6u) {
    unsigned int v4 = (a2 << 16) | ((a3 - 1) << 8);
  }
  if (a1 && a1 <= 6u) {
    v4 |= a1 << 20;
  }
  return v4;
}

void *_dispatch_mach_reply_list_insert(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = (atomic_uint *)(a1 + 40);
  unsigned int v13 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v8 = 0;
  atomic_compare_exchange_strong_explicit(v14, (unsigned int *)&v8, v13, memory_order_acquire, memory_order_acquire);
  if (v8) {
    _dispatch_unfair_lock_lock_slow(v14);
  }
  if (*(void *)(a2 + 72)) {
    _dispatch_abort(302, *(void *)(a2 + 72) == 0, v2, v3, v4, v5, v6, v7);
  }
  uint64_t v9 = *(void *)(a1 + 56);
  *(void *)(a2 + 64) = v9;
  if (v9) {
    *(void *)(*(void *)(a1 + 56) + 72) = a2 + 64;
  }
  *(void *)(a1 + 56) = a2;
  *(void *)(a2 + 72) = a1 + 56;
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  unsigned int v15 = atomic_exchange_explicit((atomic_uint *volatile)(a1 + 40), 0, memory_order_release);
  if (v15 != (result & 0xFFFFFFFC)) {
    return _dispatch_unfair_lock_unlock_slow(a1 + 40, v15);
  }
  return result;
}

void *_dispatch_mach_msg_async_reply_wrap(uint64_t a1, uint64_t a2)
{
  _dispatch_retain(a2);
  uint64_t v6 = _dispatch_thread_getspecific(0x16uLL);
  if (v6)
  {
    _dispatch_thread_setspecific(22, v6[2]);
    uint64_t v5 = v6;
  }
  else
  {
    uint64_t v5 = (void *)_dispatch_continuation_alloc_from_heap();
  }
  *uint64_t v5 = &unk_ECD38;
  v5[6] = a1;
  v5[7] = a2;
  v5[1] = -1;
  v5[3] = -1;
  return v5;
}

uint64_t _dispatch_mach_send_push_and_trydrain(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v28 = *(void *)(a1 + 120);
  unsigned int v27 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  uint64_t v22 = 0;
  unsigned int v21 = 0;
  *(void *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, v28 + 72);
  unint64_t v20 = atomic_exchange_explicit((atomic_ullong *volatile)(v28 + 72), a2, memory_order_release);
  if (v20)
  {
    *(void *)(v20 + 16) = a2;
  }
  else
  {
    _dispatch_retain_2(a1);
    uint64_t v22 = 0xA000000000;
    unsigned int v21 = 3;
    *(void *)(v28 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = a2;
  }
  _dispatch_thread_setspecific(122, 0);
  BOOL v19 = 1;
  if (!*(_DWORD *)(v28 + 88)) {
    BOOL v19 = (*(_DWORD *)(a1 + 80) & 0x10000000) != 0;
  }
  if (v19)
  {
    for (unint64_t i = *(void *)(v28 + 64); ; unint64_t i = v10)
    {
      unint64_t v36 = i;
      if ((i & 0x700000000) < (unint64_t)a3 << 32) {
        unint64_t v36 = i & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      }
      unint64_t v9 = i;
      unint64_t v10 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v28 + 64), &v10, v36 | v22, memory_order_release, memory_order_relaxed);
      if (v10 == v9) {
        break;
      }
    }
    if (((i ^ (v36 | v22)) & 0x8000000000) != 0) {
      v21 &= ~1u;
    }
    uint64_t v18 = 0;
    if (*(void *)a1) {
      uint64_t v18 = *(void *)a1;
    }
    (*(void (**)(uint64_t, void, void))(v18 + 64))(a1, a3, v21);
    char v33 = 0;
  }
  else if (v22)
  {
    for (unint64_t j = *(void *)(v28 + 64); ; unint64_t j = v12)
    {
      unint64_t v35 = j;
      if ((j & 0x700000000) < (unint64_t)a3 << 32) {
        unint64_t v35 = j & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      }
      unint64_t v23 = v35 | v22;
      if ((j & 0x10FFFFFFFFLL) == 0) {
        unint64_t v23 = (v23 | v27) & 0xFFFFFFC7FFFFFFFFLL;
      }
      unint64_t v11 = j;
      unint64_t v12 = j;
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v28 + 64), &v12, v23);
      if (v12 == v11) {
        break;
      }
    }
    if (((j ^ v23) & 0x8000000000) != 0) {
      v21 &= ~1u;
    }
LABEL_37:
    if ((j & 0xFFFFFFFC) != 0) {
      int v37 = j | 3;
    }
    else {
      int v37 = 0;
    }
    if (v37)
    {
      if (j & 0x700000000) < (unint64_t)a3 << 32 && (_dispatch_set_qos_class_enabled) {
        _pthread_workqueue_override_start_direct_check_owner();
      }
      if (v21) {
        _dispatch_release_2(a1);
      }
      char v33 = 0;
    }
    else if ((j & 0x1000000000) != 0)
    {
      uint64_t v17 = 0;
      if (*(void *)a1) {
        uint64_t v17 = *(void *)a1;
      }
      (*(void (**)(uint64_t, void, void))(v17 + 64))(a1, a3, v21);
      char v33 = 0;
    }
    else
    {
      BOOL v16 = 0;
      if (v21) {
        BOOL v16 = a2 == *(void *)(v28 + 80);
      }
      if (!v16) {
        a4 &= ~8u;
      }
      if (v21) {
        _dispatch_release_2_no_dispose(a1);
      }
      char v33 = _dispatch_mach_send_drain(a1, 0, a4, v4, v5, v6, v7, v8) & 1;
    }
  }
  else
  {
    for (unint64_t j = *(void *)(v28 + 64); ; unint64_t j = v14)
    {
      unint64_t v34 = j;
      if ((j & 0x700000000) < (unint64_t)a3 << 32) {
        unint64_t v34 = j & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      }
      unint64_t v24 = v34;
      if (v34 == j) {
        break;
      }
      if ((j & 0x10FFFFFFFFLL) == 0) {
        unint64_t v24 = (v34 | v27) & 0xFFFFFFC7FFFFFFFFLL;
      }
      unint64_t v13 = j;
      unint64_t v14 = j;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(v28 + 64), &v14, v24, memory_order_acquire, memory_order_acquire);
      if (v14 == v13) {
        goto LABEL_37;
      }
    }
    char v33 = 0;
  }
  return v33 & 1;
}

uint64_t _dispatch_get_thread_reply_port()
{
  unsigned int v16 = _dispatch_thread_getspecific(8uLL);
  if (v16)
  {
    special_int reply_port = v16;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: borrowed thread sync reply port", v0, v1, v2, v3, v4, v5, v6, 526);
  }
  else
  {
    special_int reply_port = thread_get_special_reply_port();
    _dispatch_thread_setspecific(8, special_reply_port);
    BOOL v15 = 0;
    if (special_reply_port) {
      BOOL v15 = special_reply_port != -1;
    }
    if (!v15)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate reply port, possible port leak";
      __break(1u);
      JUMPOUT(0x86F20);
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: allocated thread sync reply port", v7, v8, v9, v10, v11, v12, v13, 535);
  }
  return special_reply_port;
}

uint64_t __copy_assignment_8_8_S_pa2_27361_0_tv64w64_tv128w64_tv192w32_tv224w8_tv232w1_tv233w1_tv234w1_tv235w1_tv236w1_tv237w1_tv238w1_tv239w1_tv240w8_tv248w8_tv256w32_tv288w32_tv320w32_tv384w64_tv448w64_tv512w128_tv640w32(uint64_t a1, uint64_t a2)
{
  uint64_t result = __copy_assignment_8_8_pa2_27361_0_tv64w64_tv128w64_tv192w32_tv224w8_tv232w1_tv233w1_tv234w1_tv235w1_tv236w1_tv237w1_tv238w1_tv239w1_tv240w8_tv248w8_tv256w32_tv288w32_tv320w32_tv384w64_tv448w64_tv512w128(a1, (unint64_t *)a2);
  *(_DWORD *)(a1 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(_DWORD *)(a2 + 80);
  return result;
}

uint64_t __copy_assignment_8_8_pa2_27361_0_tv64w64_tv128w64_tv192w32_tv224w8_tv232w1_tv233w1_tv234w1_tv235w1_tv236w1_tv237w1_tv238w1_tv239w1_tv240w8_tv248w8_tv256w32_tv288w32_tv320w32_tv384w64_tv448w64_tv512w128(uint64_t result, unint64_t *a2)
{
  unint64_t v4 = 0;
  if (*a2) {
    unint64_t v4 = *a2;
  }
  *(void *)uint64_t result = v4;
  *(void *)(result + 8) = a2[1];
  unint64_t v2 = atomic_load(a2 + 2);
  atomic_store(v2, (unint64_t *)(result + 16));
  *(_DWORD *)(result + 24) = *((_DWORD *)a2 + 6);
  *(unsigned char *)(result + 28) = *((unsigned char *)a2 + 28);
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xFE | *((unsigned char *)a2 + 29) & 1;
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xFD | (2 * ((*((unsigned char *)a2 + 29) & 2) != 0));
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xFB | (4 * ((*((unsigned char *)a2 + 29) & 4) != 0));
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xF7 | (8 * ((*((unsigned char *)a2 + 29) & 8) != 0));
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xEF | (16 * ((*((unsigned char *)a2 + 29) & 0x10) != 0));
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xDF | (32 * ((*((unsigned char *)a2 + 29) & 0x20) != 0));
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0xBF | (((*((unsigned char *)a2 + 29) & 0x40) != 0) << 6);
  *(unsigned char *)(result + 29) = *(unsigned char *)(result + 29) & 0x7F | (((*((unsigned char *)a2 + 29) & 0x80) != 0) << 7);
  *(unsigned char *)(result + 3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *((unsigned char *)a2 + 30);
  *(unsigned char *)(result + 3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *((unsigned char *)a2 + 31);
  *(_DWORD *)(result + 32) = *((_DWORD *)a2 + 8);
  *(_DWORD *)(result + 36) = *((_DWORD *)a2 + 9);
  *(_DWORD *)(result + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *((_DWORD *)a2 + 10);
  *(void *)(result + 48) = a2[6];
  *(void *)(result + 56) = a2[7];
  unint64_t v3 = a2[9];
  *(void *)(result + 64) = a2[8];
  *(void *)(result + 72) = v3;
  return result;
}

void _dispatch_mach_msg_reply_received(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v26 = a1;
  uint64_t v25 = a2;
  unsigned int v24 = a3;
  uint64_t v23 = a2;
  BOOL v22 = 0;
  BOOL v22 = _dispatch_mach_reply_list_tryremove(*(void *)(a1 + 120), a2);
  unsigned int v21 = 0;
  unsigned int v21 = *(_DWORD *)(v23 + 24);
  if (v22)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistered for sync reply, ctxt %p", v7, v8, v9, v10, v11, v12, v13, 906);
  }
  if (*(unsigned char *)(v23 + 30))
  {
    if (v24 != v21 && (v22 || v24 && v24 != -1))
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Reply received on unexpected port";
      qword_F42C0 = v24;
      __break(1u);
      JUMPOUT(0x872D8);
    }
    if (v22) {
      _dispatch_set_thread_reply_port(v21);
    }
    else {
      _dispatch_destruct_reply_port();
    }
  }
  else if (v24 && v24 != -1 && v22)
  {
    uint64_t v20 = 0;
    BOOL v19 = (dispatch_object_s *)dispatch_mach_msg_create(0, 0x18uLL, 0, &v20, v3, v4, v5, v6);
    *(_DWORD *)(v20 + 12) = v24;
    *((void *)v19 + 8) = *(void *)(v23 + 56);
    *(void *)(v23 + 56) = 0;
    *((void *)v19 + 7) = *(unsigned int *)(v23 + 40);
    *((void *)v19 + 4) = *(void *)(v23 + 48);
    _dispatch_mach_msg_set_reason((uint64_t)v19, 0, 9, v14, v15, v16, v17, v18);
    _dispatch_mach_handle_or_push_received_msg(v26, v19, 0);
  }
}

BOOL _dispatch_mach_reply_list_tryremove(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = (atomic_uint *)(a1 + 40);
  unsigned int v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v9 = 0;
  atomic_compare_exchange_strong_explicit(v15, (unsigned int *)&v9, v14, memory_order_acquire, memory_order_acquire);
  if (v9) {
    _dispatch_unfair_lock_lock_slow(v15);
  }
  BOOL v11 = *(void *)(a2 + 72) != 0;
  if (*(void *)(a2 + 72)) {
    _dispatch_mach_reply_list_remove_locked(a2, v2, v3, v4, v5, v6, v7, v8);
  }
  unsigned int v16 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  unsigned int v17 = atomic_exchange_explicit((atomic_uint *volatile)(a1 + 40), 0, memory_order_release);
  if (v17 != v16) {
    _dispatch_unfair_lock_unlock_slow(a1 + 40, v17);
  }
  return v11;
}

void _dispatch_set_thread_reply_port(unsigned int a1)
{
  if (_dispatch_thread_getspecific(8uLL))
  {
    _dispatch_destruct_reply_port();
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: deallocated sync reply port (found 0x%08x)", v1, v2, v3, v4, v5, v6, v7, 567);
  }
  else
  {
    _dispatch_thread_setspecific(8, a1);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: restored thread sync reply port", v8, v9, v10, v11, v12, v13, v14, 571);
  }
}

void _dispatch_mach_msg_disconnected(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v24 = a1;
  int v23 = a2;
  int v22 = a3;
  uint64_t v21 = 0;
  uint64_t v20 = (dispatch_object_s *)dispatch_mach_msg_create(0, 0x18uLL, 0, &v21, a5, a6, a7, a8);
  if (v23) {
    *(_DWORD *)(v21 + 12) = v23;
  }
  if (v22) {
    *(_DWORD *)(v21 + 8) = v22;
  }
  _dispatch_mach_msg_set_reason((uint64_t)v20, 0, 7, v8, v9, v10, v11, v12);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: %s right disconnected", v13, v14, v15, v16, v17, v18, v19, 955);
  _dispatch_mach_handle_or_push_received_msg(v24, v20, 0);
}

void _dispatch_mach_handle_wlh_change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 80), 0x8000000u, memory_order_relaxed);
  if ((v8 & 0x400000) == 0)
  {
    if ((*(_WORD *)(a1 + 116) & 0x10) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after xpc connection was activated";
      __break(1u);
      JUMPOUT(0x878E0);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after mach channel was connected";
    __break(1u);
    JUMPOUT(0x8790CLL);
  }
  if ((v8 & 0x8000000) == 0)
  {
    if ((*(_WORD *)(a1 + 116) & 0x10) != 0) {
      _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy after xpc connection was activated", a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy after mach channel was connected", a2, a3, a4, a5, a6, a7, a8);
    }
  }
}

BOOL _dispatch_mach_cancel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v26 = (*(unsigned char *)(a1 + 118) & 2) != 0;
  if (*(_DWORD *)(*(void *)(a1 + 120) + 88)) {
    BOOL v26 = 0;
  }
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_cancel");
  unsigned int v25 = 1;
  if ((*(_DWORD *)(a1 + 80) & 0x40000000) == 0) {
    unsigned int v25 = 3;
  }
  uint64_t v24 = *(void *)(a1 + 128);
  if (v24 && (_dispatch_unote_unregister(v24, v25, v8, v9, v10, v11, v12, v13) & 1) == 0) {
    BOOL v26 = 0;
  }
  uint64_t v23 = *(void *)(a1 + 88);
  int v22 = *(_DWORD *)(v23 + 24);
  if (v22)
  {
    if (_dispatch_unote_unregister(v23, v25, v8, v9, v10, v11, v12, v13))
    {
      _dispatch_mach_msg_disconnected(a1, v22, 0, v14, v15, v16, v17, v18);
      *(_DWORD *)(v23 + 24) = 0;
    }
    else
    {
      BOOL v26 = 0;
    }
  }
  if (v26)
  {
    for (unsigned int i = *(_DWORD *)(a1 + 80); ; unsigned int i = v20)
    {
      if ((i & 0x3FFFFFFF | 0x80000000) == i)
      {
        unsigned int v29 = i;
        goto LABEL_19;
      }
      unsigned int v19 = i;
      unsigned int v20 = i;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 80), &v20, i & 0x3FFFFFFF | 0x80000000, memory_order_relaxed, memory_order_relaxed);
      if (v20 == v19) {
        break;
      }
    }
    unsigned int v29 = i;
LABEL_19:
    if ((v29 & 0xA0000000) != 0)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt channel state";
      qword_F42C0 = v29;
      __break(1u);
      JUMPOUT(0x87C78);
    }
    _dispatch_release_no_dispose(a1);
  }
  else
  {
    atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 80), 0x40000000u, memory_order_relaxed);
  }
  return v26;
}

uint64_t _dispatch_mach_cancel_invoke(uint64_t a1, int a2)
{
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v4 = 0;
  if ((a2 & 0x1000000) != 0) {
    uint64_t v4 = _dispatch_autorelease_pool_push();
  }
  if (((*(_WORD *)(a1 + 116) >> 2) & 1) == 0) {
    _dispatch_mach_connect_invoke(a1);
  }
  uint64_t v3 = 0;
  if (*(void *)(v5 + 40)) {
    uint64_t v3 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(v5 + 40);
  }
  uint64_t result = _dispatch_client_callout4(*(void *)(v5 + 48), 8, 0, 0, v3);
  if (v4) {
    uint64_t result = _dispatch_autorelease_pool_pop(v4);
  }
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFF7 | 8;
  return result;
}

uint64_t _dispatch_unote_create_with_handle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    return _dispatch_unote_create(a1, a2, a3);
  }
  else {
    return 0;
  }
}

uint64_t _dispatch_unote_create(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = a3;
  if ((a3 & ~*(_DWORD *)(a1 + 20)) != 0) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 20) && (*(unsigned char *)(a1 + 10) & 4) == 0 && !a3) {
    return 0;
  }
  if ((*(_WORD *)(a1 + 12) & 0x100) != 0) {
    uint64_t v5 = _dispatch_calloc();
  }
  else {
    uint64_t v5 = _dispatch_calloc() + 24;
  }
  uint64_t v4 = 0;
  if (a1) {
    uint64_t v4 = a1;
  }
  *(void *)uint64_t v5 = v4;
  *(unsigned char *)(v5 + 29) = *(unsigned char *)(v5 + 29) & 0xDF | (32 * (*(unsigned char *)(a1 + 10) & 1));
  *(_DWORD *)(v5 + 24) = a2;
  *(unsigned char *)(v5 + 28) = *(unsigned char *)(a1 + 8);
  *(_DWORD *)(v5 + 32) = v6;
  if ((*(_WORD *)(a1 + 12) & 0x100) != 0) {
    *(unsigned char *)(v5 + 29) = *(unsigned char *)(v5 + 29) & 0xFE | 1;
  }
  return v5;
}

uint64_t _dispatch_unote_create_with_fd(uint64_t a1, int a2, uint64_t a3)
{
  return _dispatch_unote_create(a1, a2, a3);
}

uint64_t _dispatch_unote_create_without_handle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2) {
    return 0;
  }
  else {
    return _dispatch_unote_create(a1, 0, a3);
  }
}

void _dispatch_unote_dispose(uint64_t a1)
{
  uint64_t v2 = (void *)a1;
  if ((*(unsigned char *)(a1 + 29) & 0x40) != 0) {
    _Block_release(*(const void **)(a1 + 48));
  }
  if ((*(unsigned char *)(a1 + 29) & 2) != 0)
  {
    BOOL v1 = 1;
    if (*(_DWORD *)(a1 + 112) == -1) {
      BOOL v1 = *(_DWORD *)(a1 + 116) != -1;
    }
    if (v1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Disposing of timer still in its heap";
      __break(1u);
      JUMPOUT(0x8824CLL);
    }
    if (*(void *)(a1 + 104))
    {
      free(*(void **)(a1 + 104));
      *(void *)(a1 + 104) = 0;
    }
  }
  else if ((*(unsigned char *)(a1 + 29) & 1) == 0)
  {
    uint64_t v2 = (void *)(a1 - 24);
  }
  free(v2);
}

uint64_t _dispatch_unote_register(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v12 = a3;
  BOOL v10 = 1;
  if ((*(unsigned char *)(a1 + 29) & 2) == 0) {
    BOOL v10 = *(void *)(a1 + 16) == 0;
  }
  if (!v10) {
    _dispatch_abort(127, v10, a3, a4, a5, a6, a7, a8);
  }
  int v11 = a3 & 0x4600FFFF;
  BOOL v9 = 1;
  if (a2 != -4) {
    BOOL v9 = v11 != 0;
  }
  if (!v9) {
    _dispatch_abort(136, v9, a3, a4, a5, a6, a7, a8);
  }
  if (v11 == 67125248 && MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  *(_DWORD *)(a1 + 36) = v12;
  if ((*(char *)(a1 + 28) + 23) > 2)
  {
    if ((*(unsigned char *)(a1 + 29) & 2) != 0)
    {
      _dispatch_timer_unote_register(a1, a2, v12, a4, a5, a6, a7, a8);
      char v15 = 1;
    }
    else if (*(unsigned char *)(a1 + 29))
    {
      char v15 = _dispatch_unote_register_direct((uint64_t *)a1, a2);
    }
    else
    {
      char v15 = _dispatch_unote_register_muxed((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8) & 1;
    }
  }
  else
  {
    *(void *)(a1 + 16) = -3;
    char v15 = 1;
  }
  return v15 & 1;
}

void _dispatch_timer_unote_register(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = (unsigned __int16)(a3 & 0xF00) >> 8;
  BOOL v8 = 0;
  if (v11) {
    BOOL v8 = v11 <= 2;
  }
  if (v8)
  {
    if (*(unsigned char *)(a1 + 30))
    {
      if (MEMORY[0xFFFFFC100]) {
        kdebug_trace();
      }
    }
    else
    {
      *(unsigned char *)(a1 + 30) |= 2u;
      int v12 = _dispatch_timer_flags_to_clock(*(unsigned char *)(a1 + 30));
      if ((*(unsigned char *)(a1 + 30) & 3u) >= 3) {
        _dispatch_abort(781, (*(unsigned char *)(a1 + 30) & 3u) < 3, a3, a4, a5, a6, a7, a8);
      }
      *(_DWORD *)(a1 + 24) = 3 * v12 + (*(unsigned char *)(a1 + 30) & 3);
    }
  }
  if ((*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) != a2)
  {
    if ((*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) != 0) {
      _dispatch_abort(853, (*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) == 0, a3, a4, a5, a6, a7, a8);
    }
    *(void *)(a1 + 16) = -4;
  }
  if (*(void *)(a1 + 104)) {
    _dispatch_timer_unote_configure(a1);
  }
}

void _dispatch_unote_resume(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = 1;
  if ((*(unsigned char *)(a1 + 29) & 2) == 0)
  {
    uint64_t v10 = *(void *)(a1 + 16);
    BOOL v8 = 0;
    if (v10)
    {
      BOOL v8 = 0;
      if ((v10 & 1) == 0) {
        BOOL v8 = (v10 & 2) == 0;
      }
    }
    char v9 = v8;
  }
  if ((v9 & 1) == 0) {
    _dispatch_abort(166, v9 & 1, a3, a4, a5, a6, a7, a8);
  }
  if ((*(unsigned char *)(a1 + 29) & 2) != 0)
  {
    _dispatch_timer_unote_resume(a1);
  }
  else if (*(unsigned char *)(a1 + 29))
  {
    _dispatch_unote_resume_direct((uint64_t *)a1);
  }
  else
  {
    _dispatch_unote_resume_muxed((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_timer_unote_resume(uint64_t a1)
{
  if ((*(void *)(55 - *(void *)(a1 + 8)) & 0xFF80000000000000) != 0)
  {
    BOOL v22 = 0;
  }
  else
  {
    BOOL v15 = 0;
    if (*(_DWORD *)(a1 + 24) != -1) {
      BOOL v15 = *(void *)(a1 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
    }
    BOOL v22 = v15;
  }
  BOOL v18 = (*(void *)(a1 + 16) & 1) != 0;
  int v21 = _dispatch_timer_flags_to_clock(*(unsigned char *)(a1 + 30));
  unsigned int v20 = *(unsigned char *)(a1 + 30) & 3;
  if (v20 >= 3) {
    _dispatch_abort(781, v20 < 3, v1, v2, v3, v4, v5, v6);
  }
  unsigned int v17 = 3 * v21 + v20;
  uint64_t v16 = _dispatch_timer_unote_heap(a1);
  BOOL v14 = 0;
  if (v18)
  {
    BOOL v13 = 1;
    if (v22) {
      BOOL v13 = *(_DWORD *)(a1 + 24) != v17;
    }
    BOOL v14 = v13;
  }
  if (v14) {
    _dispatch_timer_unote_disarm(a1, (uint64_t)v16, v7, v8, v9, v10, v11, v12);
  }
  if (v22)
  {
    if (!v18) {
      _dispatch_retain_2(~*(void *)(a1 + 8));
    }
    _dispatch_timer_unote_arm(a1, (uint64_t)v16, v17);
  }
  else if (v18)
  {
    _dispatch_release_2_tailcall(~*(void *)(a1 + 8));
  }
}

uint64_t _dispatch_unote_unregister(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16))
  {
    if ((*(char *)(a1 + 28) + 23) > 2)
    {
      if ((*(unsigned char *)(a1 + 29) & 2) != 0)
      {
        _dispatch_timer_unote_unregister(a1);
        char v9 = 1;
      }
      else if (*(unsigned char *)(a1 + 29))
      {
        char v9 = _dispatch_unote_unregister_direct(a1, a2) & 1;
      }
      else
      {
        if ((a2 & 1) == 0) {
          _dispatch_abort(201, a2 & 1, a3, a4, a5, a6, a7, a8);
        }
        char v9 = _dispatch_unote_unregister_muxed((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8) & 1;
      }
    }
    else
    {
      *(void *)(a1 + 16) = 0;
      char v9 = 1;
    }
  }
  else
  {
    char v9 = 1;
  }
  return v9 & 1;
}

void _dispatch_timer_unote_unregister(uint64_t a1)
{
  uint64_t v7 = _dispatch_timer_unote_heap(a1);
  if (*(void *)(a1 + 16))
  {
    _dispatch_timer_unote_disarm(a1, (uint64_t)v7, v1, v2, v3, v4, v5, v6);
    _dispatch_release_2_no_dispose(~*(void *)(a1 + 8));
  }
  unint64_t v9 = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if (v9)
  {
    if (v9 != -4)
    {
      signed int v10 = atomic_fetch_add_explicit((atomic_uint *volatile)(v9 + 96), 0xFFFFFFFF, memory_order_relaxed) - 1;
      if (v10 < 0)
      {
        if (v10 <= -2)
        {
          qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x892A8);
        }
        *(void *)(v9 + 56) = 0xDEAD000000000000;
        _dispatch_object_dealloc((void *)v9);
      }
    }
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = -1;
}

uint64_t _dispatch_source_data_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 || a3) {
    return 0;
  }
  uint64_t v5 = _dispatch_calloc();
  uint64_t v4 = 0;
  if (a1) {
    uint64_t v4 = a1;
  }
  *(void *)uint64_t v5 = v4;
  *(unsigned char *)(v5 + 28) = *(unsigned char *)(a1 + 8);
  *(unsigned char *)(v5 + 29) = *(unsigned char *)(v5 + 29) & 0xFE | 1;
  return v5;
}

uint64_t _dispatch_source_signal_create(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 < 0x20) {
    return _dispatch_unote_create_with_handle(a1, a2, a3);
  }
  else {
    return 0;
  }
}

void _dispatch_timer_unote_configure(uint64_t a1)
{
  uint64_t v2 = (_DWORD *)__swp(0, (unsigned int *)(a1 + 104));
  int v1 = v2[6];
  if (v1 != _dispatch_timer_flags_to_clock(*(unsigned char *)(a1 + 30)))
  {
    *(unsigned char *)(a1 + 30) &= 0xF3u;
    *(unsigned char *)(a1 + 30) |= _dispatch_timer_flags_from_clock(v2[6]);
  }
  *(_OWORD *)(a1 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(_OWORD *)v2;
  *(void *)(a1 + 96) = *((void *)v2 + 2);
  free(v2);
  *(void *)(a1 + 72) = 0;
  if (*(void *)(a1 + 16)) {
    _dispatch_timer_unote_resume(a1);
  }
}

uint64_t _dispatch_source_timer_create(uint64_t a1, uint64_t a2, unsigned int a3)
{
  BOOL v15 = (char **)a1;
  unsigned int v14 = a3;
  if (a3) {
    unsigned int v14 = a3 & 0xFFFFFFFD;
  }
  if ((v14 & ~*(_DWORD *)(a1 + 20)) != 0) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 11) & 0x10) != 0)
  {
    if (!a2) {
      return 0;
    }
  }
  else if (*(char *)(a1 + 8) == -20)
  {
    if (a2) {
      return 0;
    }
  }
  else
  {
    if (a2)
    {
      uint64_t v4 = a2;
      char v3 = 1;
    }
    else
    {
      uint64_t v4 = 0;
      char v3 = 0;
    }
    if (v3) {
      return 0;
    }
    switch(v4)
    {
      case 0:
        break;
      case 1:
        BOOL v15 = &_dispatch_source_type_timer_with_clock;
        break;
      case 2:
        BOOL v15 = &_dispatch_source_type_timer_with_clock;
        LOBYTE(v14) = v14 | 4;
        break;
      case 3:
        BOOL v15 = &_dispatch_source_type_timer_with_clock;
        LOBYTE(v14) = v14 | 8;
        break;
      default:
        JUMPOUT(0);
    }
  }
  uint64_t v13 = _dispatch_calloc();
  uint64_t v12 = 0;
  if (v15) {
    uint64_t v12 = v15;
  }
  *(void *)uint64_t v13 = v12;
  *(unsigned char *)(v13 + 28) = *((unsigned char *)v15 + 8);
  *(unsigned char *)(v13 + 29) = *(unsigned char *)(v13 + 29) & 0xFD | 2;
  *(unsigned char *)(v13 + 30) |= v14 | *((unsigned char *)v15 + 11);
  int v17 = _dispatch_timer_flags_to_clock(*(unsigned char *)(v13 + 30));
  if ((*(unsigned char *)(v13 + 30) & 3u) >= 3) {
    _dispatch_abort(781, (*(unsigned char *)(v13 + 30) & 3u) < 3, v5, v6, v7, v8, v9, v10);
  }
  *(_DWORD *)(v13 + 24) = 3 * v17 + (*(unsigned char *)(v13 + 30) & 3);
  *(void *)(v13 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
  *(void *)(v13 + 88) = -1;
  *(void *)(v13 + 96) = -1;
  *(_DWORD *)(v13 + 112) = -1;
  *(_DWORD *)(v13 + 116) = -1;
  return v13;
}

void _dispatch_event_loop_drain_timers(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = a1;
  unsigned int v11 = a2;
  memset(v10, 0, sizeof(v10));
  do
  {
    for (unsigned int i = 0; i < v11; ++i)
      _dispatch_timers_run(v12, i, (uint64_t)v10, a4, a5, a6, a7, a8);
    *(unsigned char *)(v12 + 6) = 0;
    for (unsigned int j = 0; j < v11; ++j)
    {
      if ((*(unsigned char *)(v12 + 32 * j + 7) & 2) != 0) {
        _dispatch_timers_program(v12, j, (uint64_t)v10, a4, a5, a6, a7, a8);
      }
    }
  }
  while (*(unsigned char *)(v12 + 6));
}

void _dispatch_timers_run(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  while (1)
  {
    uint64_t v14 = *(void *)(a1 + 32 * a2 + 8);
    if (!v14) {
      break;
    }
    unsigned int v11 = *(_DWORD *)(v14 + 24);
    if (v11 != a2)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: tidx";
      qword_F42C0 = v11;
      __break(1u);
      JUMPOUT(0x89C6CLL);
    }
    if (!*(void *)(v14 + 80))
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: missing target";
      qword_F42C0 = 0;
      __break(1u);
      JUMPOUT(0x89CD0);
    }
    if (!*(void *)(a3 + 8 * (a2 / 3)))
    {
      mach_get_times();
      *(void *)(a3 + 16) = 0;
    }
    unint64_t v12 = *(void *)(a3 + 8 * (a2 / 3));
    if (*(void *)(v14 + 80) > v12) {
      break;
    }
    if ((*(unsigned char *)(v14 + 30) & 0x40) != 0)
    {
      _dispatch_timer_unote_disarm(v14, a1, a3, a4, a5, a6, a7, a8);
      unint64_t v19 = *(void *)(v14 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      if (v19)
      {
        if (v19 != -4)
        {
          signed int v20 = atomic_fetch_add_explicit((atomic_uint *volatile)(v19 + 96), 0xFFFFFFFF, memory_order_relaxed) - 1;
          if (v20 < 0)
          {
            if (v20 <= -2)
            {
              qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
              __break(1u);
              JUMPOUT(0x89EFCLL);
            }
            *(void *)(v19 + 56) = 0xDEAD000000000000;
            _dispatch_object_dealloc((void *)v19);
          }
        }
      }
      *(void *)(v14 + 16) = 0;
      *(void *)(v14 + 72) = 2;
      uint64_t v10 = 0;
      if (*(void *)v14) {
        uint64_t v10 = *(void *)v14;
      }
      (*(void (**)(uint64_t, uint64_t, void))(v10 + 48))(v14, 16, 0);
    }
    else if (*(void *)(v14 + 104))
    {
      _dispatch_timer_unote_configure(v14);
    }
    else
    {
      if (*(void *)(v14 + 72))
      {
        _dispatch_timer_unote_disarm(v14, a1, a3, a4, a5, a6, a7, a8);
        atomic_fetch_or_explicit((atomic_ullong *volatile)(v14 + 72), 1uLL, memory_order_relaxed);
      }
      else
      {
        uint64_t v22 = (v12 - *(void *)(v14 + 80)) / *(void *)(v14 + 96) + 1;
        if (v22 < 0) {
          uint64_t v22 = 0x7FFFFFFFFFFFFFFFLL;
        }
        if (*(void *)(v14 + 96) > 0x7FFFFFFFFFFFFFFEuLL)
        {
          *(void *)(v14 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
          *(void *)(v14 + 88) = -1;
        }
        else
        {
          uint64_t v21 = v22 * *(void *)(v14 + 96);
          *(void *)(v14 + 80) += v21;
          *(void *)(v14 + 88) += v21;
        }
        uint64_t v13 = 2 * v22;
        if ((*(void *)(55 - *(void *)(v14 + 8)) & 0xFF80000000000000) != 0)
        {
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace();
          }
          BOOL v18 = 0;
        }
        else
        {
          BOOL v9 = 0;
          if (*(_DWORD *)(v14 + 24) != -1) {
            BOOL v9 = *(void *)(v14 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
          }
          BOOL v18 = v9;
        }
        if (v18)
        {
          _dispatch_retain_2(~*(void *)(v14 + 8));
          _dispatch_timer_unote_arm(v14, a1, a2);
          *(void *)(v14 + 72) = v13;
        }
        else
        {
          _dispatch_timer_unote_disarm(v14, a1, a3, a4, a5, a6, a7, a8);
          atomic_store(v13 | 1, (unint64_t *)(v14 + 72));
        }
      }
      uint64_t v8 = 0;
      if (*(void *)v14) {
        uint64_t v8 = *(void *)v14;
      }
      (*(void (**)(uint64_t, uint64_t, void))(v8 + 48))(v14, 16, 0);
    }
  }
}

void _dispatch_timers_program(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = a2 % 3;
  unsigned int v20 = a2 % 3;
  if (*(void *)(a1 + 32 * a2 + 8))
  {
    unint64_t v18 = *(void *)(*(void *)(a1 + 32 * a2 + 8) + 80);
    unint64_t v17 = *(void *)(*(void *)(a1 + 32 * a2 + 16) + 88);
    BOOL v10 = 0;
    if (v18 <= v17) {
      BOOL v10 = v18 < 0x7FFFFFFFFFFFFFFFLL;
    }
    if (!v10) {
      _dispatch_abort(1141, v10, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v25 = a2 / 3;
    if (!*(void *)(a3 + 8 * (a2 / 3)))
    {
      mach_get_times();
      *(void *)(a3 + 16) = 0;
    }
    unint64_t v16 = *(void *)(a3 + 8 * v25);
    if (v18 > v16)
    {
      if (v20 < 3 && *(_DWORD *)(a1 + 32 * a2) > 2u)
      {
        uint64_t v15 = _dispatch_kevent_coalescing_window[v20];
        if (v18 + v15 < v17) {
          unint64_t v18 = _dispatch_timer_heap_max_target_before(a1 + 32 * a2, v17 - v15);
        }
      }
      if (v18 - v16 >= 0x7FFFFFFFFFFFFFFFLL) {
        uint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v9 = v18 - v16;
      }
      unint64_t v23 = v9;
      if (v17 - v18 >= 0x7FFFFFFFFFFFFFFFLL) {
        uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v8 = v17 - v18;
      }
      uint64_t v24 = v8;
    }
    else
    {
      uint64_t v24 = 0;
      unint64_t v23 = 0;
    }
  }
  else
  {
    uint64_t v24 = 0x7FFFFFFFFFFFFFFFLL;
    unint64_t v23 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v23)
  {
    if (v23 < 0x7FFFFFFFFFFFFFFFLL)
    {
      _dispatch_trace_next_timer[v11] = *(void *)(a1 + 32 * a2 + 8);
      uint64_t v29 = _dispatch_trace_next_timer[v11];
      unint64_t v28 = v23;
      int v27 = 0;
      int v26 = 0;
      _dispatch_event_loop_timer_arm(a1, a2, v23, v24, a3);
      *(unsigned char *)(a1 + 32 * a2 + 7) = *(unsigned char *)(a1 + 32 * a2 + 7) & 0xFE | 1;
      *(unsigned char *)(a1 + 32 * a2 + 7) &= ~2u;
      return;
    }
  }
  else
  {
    *(unsigned char *)(a1 + 6) |= (1 << (a2 % 3)) | 0x80;
  }
  _dispatch_trace_next_timer[v11] = 0;
  if (*(unsigned char *)(a1 + 32 * a2 + 7)) {
    _dispatch_event_loop_timer_delete(a1, a2);
  }
  *(unsigned char *)(a1 + 32 * a2 + 7) &= ~1u;
  *(unsigned char *)(a1 + 32 * a2 + 7) &= ~2u;
}

void *_dispatch_timer_unote_heap(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if (v2 == -4) {
    return &_dispatch_timers_heap;
  }
  else {
    return *(void **)(v2 + 48);
  }
}

void _dispatch_timer_unote_disarm(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v15 = *(_DWORD *)(a1 + 24);
  if ((*(void *)(a1 + 16) & 1) == 0) {
    _dispatch_abort(793, (*(void *)(a1 + 16) & 1) != 0, a3, a4, a5, a6, a7, a8);
  }
  _dispatch_timer_heap_remove(a2 + 32 * v15, a1);
  *(unsigned char *)(a2 + 6) |= (1 << (v15 % 3)) | 0x80;
  *(void *)(a1 + 16) &= ~1uLL;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v8, v9, v10, v11, v12, v13, v14, 797);
}

uint64_t _dispatch_timer_unote_arm(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(void *)(a1 + 16))
  {
    unsigned int v20 = *(_DWORD *)(a1 + 24);
    if (v20 != a3)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: tidx";
      qword_F42C0 = v20;
      __break(1u);
      JUMPOUT(0x8B440);
    }
    uint64_t v24 = a2 + 32 * a3;
    if (*(_DWORD *)(a1 + 112) == -1)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
      qword_F42C0 = 0xFFFFFFFFLL;
      __break(1u);
      JUMPOUT(0x8B4BCLL);
    }
    if (*(_DWORD *)(a1 + 116) == -1)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
      qword_F42C0 = 0xFFFFFFFFLL;
      __break(1u);
      JUMPOUT(0x8B51CLL);
    }
    _dispatch_timer_heap_resift(v24, a1, *(_DWORD *)(a1 + 112));
    _dispatch_timer_heap_resift(v24, a1, *(_DWORD *)(a1 + 116));
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v3, v4, v5, v6, v7, v8, v9, 807);
  }
  else
  {
    *(_DWORD *)(a1 + 24) = a3;
    uint64_t v28 = a2 + 32 * a3;
    unsigned int v10 = *(_DWORD *)v28;
    *(_DWORD *)v28 += 2;
    unsigned int v27 = v10;
    unsigned int v26 = *(_DWORD *)(a1 + 112);
    if (v26 != -1)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
      qword_F42C0 = v26;
      __break(1u);
      JUMPOUT(0x8B634);
    }
    unsigned int v25 = *(_DWORD *)(a1 + 116);
    if (v25 != -1)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
      qword_F42C0 = v25;
      __break(1u);
      JUMPOUT(0x8B694);
    }
    if ((*(_DWORD *)(a1 + 36) & 0xF00u) >> 8 > (*(_DWORD *)(a1 + 36) & 0xF000u) >> 12) {
      unsigned int v19 = (*(_DWORD *)(a1 + 36) & 0xF00u) >> 8;
    }
    else {
      unsigned int v19 = (*(_DWORD *)(a1 + 36) & 0xF000u) >> 12;
    }
    if (*(unsigned __int8 *)(v28 + 5) < v19)
    {
      *(unsigned char *)(v28 + 5) = v19;
      *(unsigned char *)(v28 + 7) |= 2u;
    }
    if (v10)
    {
      if (*(unsigned char *)(v28 + 4)) {
        unsigned int v29 = (8 << (*(unsigned char *)(v28 + 4) - 1)) - (*(unsigned __int8 *)(v28 + 4) - 1) + 2;
      }
      else {
        unsigned int v29 = 2;
      }
      if (v10 + 2 > v29) {
        _dispatch_timer_heap_grow(v28);
      }
      _dispatch_timer_heap_resift(v28, a1, v27);
      _dispatch_timer_heap_resift(v28, a1, v27 + 1);
    }
    else
    {
      *(unsigned char *)(v28 + 7) |= 2u;
      *(_DWORD *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 116) = 1;
      *(void *)(v28 + 16) = a1;
      *(void *)(v28 + 8) = a1;
    }
    *(void *)(a1 + 16) |= 1uLL;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v11, v12, v13, v14, v15, v16, v17, 812);
  }
  uint64_t result = 2863311531;
  *(unsigned char *)(a2 + 6) |= (1 << (a3 % 3)) | 0x80;
  return result;
}

void _dispatch_timer_heap_remove(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)a1 - 2;
  *(_DWORD *)a1 = v2;
  unsigned int v7 = v2;
  if (*(_DWORD *)(a2 + 112) == -1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
    qword_F42C0 = 0xFFFFFFFFLL;
    __break(1u);
    JUMPOUT(0x8BA54);
  }
  if (*(_DWORD *)(a2 + 116) == -1)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
    qword_F42C0 = 0xFFFFFFFFLL;
    __break(1u);
    JUMPOUT(0x8BABCLL);
  }
  if (v2)
  {
    for (unsigned int i = 0; i <= 1; ++i)
    {
      unsigned int v13 = v7 + i;
      int v11 = *(unsigned __int8 *)(a1 + 4);
      if (v7 + i > 1)
      {
        unsigned int v14 = v13 - 2;
        unsigned int v12 = 29 - __clz(v14 | 7);
        if (v12 + 1 == v11) {
          uint64_t v10 = *(void *)(a1 + 24);
        }
        else {
          uint64_t v10 = *(void *)(*(void *)(a1 + 24) + 8 * (~v12 + (8 << (v11 - 2))));
        }
        if (v12) {
          v14 -= 8 << (v12 - 1);
        }
        uint64_t v15 = (uint64_t *)(v10 + 8 * v14);
      }
      else
      {
        uint64_t v15 = (uint64_t *)(a1 + 8 * v13 + 8);
      }
      uint64_t v3 = *v15;
      *uint64_t v15 = 0;
      if (v3 != a2) {
        _dispatch_timer_heap_resift(a1, v3, *(_DWORD *)(a2 + 4 * i + 112));
      }
    }
    if (*(unsigned char *)(a1 + 4) == 1) {
      unsigned int v16 = 2;
    }
    else {
      unsigned int v16 = (8 << (*(unsigned char *)(a1 + 4) - 2)) - (*(unsigned __int8 *)(a1 + 4) - 2) + 2;
    }
    if (v7 <= v16) {
      _dispatch_timer_heap_shrink(a1);
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6 != a2)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target slot";
      qword_F42C0 = v6;
      __break(1u);
      JUMPOUT(0x8BB34);
    }
    uint64_t v5 = *(void *)(a1 + 16);
    if (v5 != a2)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline slot";
      qword_F42C0 = v5;
      __break(1u);
      JUMPOUT(0x8BBA0);
    }
    *(unsigned char *)(a1 + 7) |= 2u;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 8) = 0;
  }
  *(_DWORD *)(a2 + 112) = -1;
  *(_DWORD *)(a2 + 116) = -1;
}

uint64_t _dispatch_timer_heap_resift(uint64_t result, uint64_t a2, unsigned int a3)
{
  unsigned int v15 = a3;
  unsigned int v10 = *(_DWORD *)result;
  char v8 = 0;
  int v33 = *(unsigned __int8 *)(result + 4);
  if (a3 >= 2)
  {
    unsigned int v35 = a3 - 2;
    unsigned int v3 = __clz((a3 - 2) | 7);
    unsigned int v34 = 29 - v3;
    if (30 - v3 == v33) {
      uint64_t v32 = *(void *)(result + 24);
    }
    else {
      uint64_t v32 = *(void *)(*(void *)(result + 24) + 8 * ((8 << (v33 - 2)) - v34 - 1));
    }
    if (v34) {
      v35 -= 8 << (28 - v3);
    }
    uint64_t v36 = v32 + 8 * v35;
  }
  else
  {
    uint64_t v36 = result + 8 + 8 * a3;
  }
  uint64_t v9 = (void *)v36;
  while (v15 >= 2)
  {
    unsigned int v29 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
    int v27 = *(unsigned __int8 *)(result + 4);
    if (v29 >= 2)
    {
      unsigned int v30 = v29 - 2;
      unsigned int v4 = __clz(v30 | 7);
      unsigned int v28 = 29 - v4;
      if (30 - v4 == v27) {
        uint64_t v26 = *(void *)(result + 24);
      }
      else {
        uint64_t v26 = *(void *)(*(void *)(result + 24) + 8 * ((8 << (v27 - 2)) - v28 - 1));
      }
      if (v28) {
        v30 -= 8 << (28 - v4);
      }
      unsigned int v31 = (void *)(v26 + 8 * v30);
    }
    else
    {
      unsigned int v31 = (void *)(result + 8 + 8 * v29);
    }
    uint64_t v14 = *v31;
    if (*(void *)(*v31 + 80 + 8 * (a3 & 1)) <= *(void *)(a2 + 80 + 8 * (a3 & 1))) {
      break;
    }
    void *v9 = v14;
    *(_DWORD *)(v14 + 112 + 4 * (v15 & 1)) = v15;
    uint64_t v9 = v31;
    unsigned int v15 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
    char v8 = 1;
  }
  if ((v8 & 1) == 0)
  {
    while (1)
    {
      unsigned int v11 = 2 * v15 + 2 - (v15 & 1);
      if (v11 >= v10) {
        break;
      }
      unsigned int v7 = v11 + 2;
      int v22 = *(unsigned __int8 *)(result + 4);
      if (v11 >= 2)
      {
        unsigned int v24 = 2 * v15 - (v15 & 1);
        unsigned int v5 = __clz(v24 | 7);
        unsigned int v23 = 29 - v5;
        if (30 - v5 == v22) {
          uint64_t v21 = *(void *)(result + 24);
        }
        else {
          uint64_t v21 = *(void *)(*(void *)(result + 24) + 8 * ((8 << (v22 - 2)) - v23 - 1));
        }
        if (v23) {
          v24 -= 8 << (28 - v5);
        }
        unsigned int v25 = (void *)(v21 + 8 * v24);
      }
      else
      {
        unsigned int v25 = (void *)(result + 8 + 8 * v11);
      }
      unsigned int v13 = v25;
      uint64_t v12 = *v25;
      if (v7 < v10)
      {
        int v17 = *(unsigned __int8 *)(result + 4);
        if (v7 >= 2)
        {
          unsigned int v19 = 2 * v15 + 2 - (v15 & 1);
          unsigned int v6 = __clz(v11 | 7);
          unsigned int v18 = 29 - v6;
          if (30 - v6 == v17) {
            uint64_t v16 = *(void *)(result + 24);
          }
          else {
            uint64_t v16 = *(void *)(*(void *)(result + 24) + 8 * ((8 << (v17 - 2)) - v18 - 1));
          }
          if (v18) {
            unsigned int v19 = v11 - (8 << (28 - v6));
          }
          unsigned int v20 = (void *)(v16 + 8 * v19);
        }
        else
        {
          unsigned int v20 = (void *)(result + 8 + 8 * v7);
        }
        if (*(void *)(v12 + 80 + 8 * (a3 & 1)) > *(void *)(*v20 + 80 + 8 * (a3 & 1)))
        {
          v11 += 2;
          uint64_t v12 = *v20;
          unsigned int v13 = v20;
        }
      }
      if (*(void *)(a2 + 80 + 8 * (a3 & 1)) <= *(void *)(v12 + 80 + 8 * (a3 & 1))) {
        break;
      }
      if (v15 < 2) {
        *(unsigned char *)(result + 7) = *(unsigned char *)(result + 7) & 0xFD | 2;
      }
      void *v9 = v12;
      *(_DWORD *)(v12 + 112 + 4 * (v15 & 1)) = v15;
      uint64_t v9 = v13;
      unsigned int v15 = v11;
    }
  }
  if (v15 < 2) {
    *(unsigned char *)(result + 7) = *(unsigned char *)(result + 7) & 0xFD | 2;
  }
  void *v9 = a2;
  *(_DWORD *)(a2 + 112 + 4 * (v15 & 1)) = v15;
  return result;
}

void _dispatch_timer_heap_shrink(uint64_t a1)
{
  char v1 = *(unsigned char *)(a1 + 4);
  *(unsigned char *)(a1 + 4) = v1 - 1;
  unsigned int v4 = (v1 - 1);
  unsigned int v3 = *(void **)(a1 + 24);
  uint64_t v2 = 0;
  if (v1 != 1) {
    uint64_t v2 = v3[(8 << (v1 - 2)) - v4];
  }
  if (v4 > 1) {
    __memcpy_chk();
  }
  *(void *)(a1 + 24) = v2;
  free(v3);
}

uint64_t _dispatch_timer_heap_grow(uint64_t a1)
{
  int v6 = 8;
  unsigned int v1 = *(unsigned __int8 *)(a1 + 4);
  *(unsigned char *)(a1 + 4) = v1 + 1;
  unsigned int v5 = v1;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v1) {
    int v6 = 8 << (v1 - 1);
  }
  uint64_t result = _dispatch_calloc();
  uint64_t v4 = result;
  if (v5 > 1) {
    uint64_t result = __memcpy_chk();
  }
  if (v5) {
    *(void *)(v4 + 8 * (v6 - v5)) = v3;
  }
  *(void *)(a1 + 24) = v4;
  return result;
}

unint64_t _dispatch_timer_heap_max_target_before(uint64_t a1, unint64_t a2)
{
  unsigned int v9 = 2;
  unsigned int v8 = *(_DWORD *)a1;
  unint64_t v6 = *(void *)(*(void *)(a1 + 8) + 80);
  while (v9 < v8)
  {
    int v11 = *(unsigned __int8 *)(a1 + 4);
    if (v9 >= 2)
    {
      unsigned int v13 = v9 - 2;
      unsigned int v2 = __clz((v9 - 2) | 7);
      unsigned int v12 = 29 - v2;
      if (30 - v2 == v11) {
        uint64_t v10 = *(void *)(a1 + 24);
      }
      else {
        uint64_t v10 = *(void *)(*(void *)(a1 + 24) + 8 * ((8 << (v11 - 2)) - v12 - 1));
      }
      if (v12) {
        v13 -= 8 << (28 - v2);
      }
      uint64_t v14 = v10 + 8 * v13;
    }
    else
    {
      uint64_t v14 = a1 + 8 + 8 * v9;
    }
    unint64_t v7 = *(void *)(*(void *)v14 + 80);
    if (v7 <= a2)
    {
      if (v7 > v6) {
        unint64_t v6 = *(void *)(*(void *)v14 + 80);
      }
      if (2 * v9 + 2 - (v9 & 1) >= v8)
      {
        unsigned int v18 = v9 - (v9 & 1);
        if (v18 + 2 == v8) {
          unsigned int v18 = ((v18 - 2) / 2) & 0xFFFFFFFE | v18 & 1;
        }
        unsigned int v19 = (v18 + 3) >> __clz(__rbit32(~(v18 + 3)));
        if (v19) {
          int v4 = 2 * v19 + (v9 & 1);
        }
        else {
          int v4 = -1;
        }
        int v17 = v4;
      }
      else
      {
        int v17 = 2 * v9 + 2 - (v9 & 1);
      }
      unsigned int v9 = v17;
    }
    else
    {
      unsigned int v15 = v9 - (v9 & 1);
      if (v15 + 2 == v8) {
        unsigned int v15 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
      }
      unsigned int v16 = (v15 + 3) >> __clz(__rbit32(~(v15 + 3)));
      if (v16) {
        int v5 = 2 * v16 + (v9 & 1);
      }
      else {
        int v5 = -1;
      }
      unsigned int v9 = v5;
    }
  }
  return v6;
}

uint64_t _dispatch_sync_ipc_handoff_begin(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v12 = a1;
  unsigned int v11 = a2;
  uint64_t v10 = a3;
  v5[0] = a2;
  v5[1] = 655343;
  v5[2] = a1;
  v5[3] = 2147483904;
  long long v6 = 0uLL;
  uint64_t v7 = a3;
  uint64_t v8 = -1;
  uint64_t v9 = a1;
  uint64_t result = _dispatch_kq_immediate_update(a1, (uint64_t)v5);
  BOOL v4 = 0;
  if (result) {
    BOOL v4 = result != 2;
  }
  if (v4)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
    qword_F42C0 = (int)result;
    __break(1u);
    JUMPOUT(0x8CF0CLL);
  }
  return result;
}

uint64_t _dispatch_kq_immediate_update(uint64_t a1, uint64_t a2)
{
  BOOL v4 = _dispatch_thread_getspecific(0x1DuLL);
  if (v4 && v4[3] == a1)
  {
    uint64_t v8 = v4[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v4 + 20)
       && (*(__int16 *)(v8 + 72 * i + 8) != *(__int16 *)(a2 + 8)
        || *(void *)(v8 + 72 * i) != *(void *)a2
        || *(void *)(v8 + 72 * i + 16) != *(void *)(a2 + 16));
    if (i < *((unsigned __int16 *)v4 + 20))
    {
      __int16 v2 = *((_WORD *)v4 + 20);
      *((_WORD *)v4 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v2 - 1;
      if (i != (unsigned __int16)(v2 - 1)) {
        memcpy((void *)(v4[4] + 72 * i), (const void *)(v4[4] + 72 * (unsigned __int16)(v2 - 1)), 0x48uLL);
      }
    }
  }
  return _dispatch_kq_drain(a1, a2, 1, 3u);
}

void _dispatch_sync_ipc_handoff_end(uint64_t a1, unsigned int a2)
{
  unsigned int v11 = a2;
  uint64_t __b = a2;
  __int16 v3 = -17;
  __int16 v4 = 7;
  int v5 = 0;
  unsigned int v6 = 0x80000000;
  int v7 = 0;
  uint64_t v8 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  _dispatch_kq_deferred_update(a1, (__int16 *)&__b);
}

void _dispatch_kq_deferred_update(uint64_t a1, __int16 *a2)
{
  uint64_t v8 = _dispatch_thread_getspecific(0x1DuLL);
  if (v8 && v8[3] == a1 && *((_WORD *)v8 + 21))
  {
    uint64_t v12 = v8[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v8 + 20)
       && (*(__int16 *)(v12 + 72 * i + 8) != a2[4]
        || *(void *)(v12 + 72 * i) != *(void *)a2
        || *(void *)(v12 + 72 * i + 16) != *((void *)a2 + 2));
    int v14 = i;
    if (a1 != -4) {
      _dispatch_thread_setspecific(5, 1);
    }
    if (i == *((unsigned __int16 *)v8 + 21))
    {
      int v13 = *((unsigned __int16 *)v8 + 20);
      *((_WORD *)v8 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 1;
      _dispatch_kq_drain(a1, v8[4], v13, 3u);
      if (*((_WORD *)v8 + 20) != 1) {
        _dispatch_abort(915, *((unsigned __int16 *)v8 + 20) == 1, v2, v3, v4, v5, v6, v7);
      }
      int v14 = 0;
    }
    else if (i == *((unsigned __int16 *)v8 + 20))
    {
      ++*((_WORD *)v8 + 20);
    }
    memcpy((void *)(v8[4] + 72 * v14), a2, 0x48uLL);
    if (a2[4] != -10) {
      dispatch_kevent_debug("deferred", (uint64_t)a2, 0, 0, (uint64_t)"_dispatch_kq_deferred_update", 0x3B3u);
    }
  }
  else
  {
    _dispatch_kq_drain(a1, (uint64_t)a2, 1, 3u);
  }
}

uint64_t _dispatch_unote_register_muxed(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v35 = *((unsigned int *)a1 + 6);
  if (*((char *)a1 + 28) == -24 || *((char *)a1 + 28) == -8) {
    v35 >>= 8;
  }
  int v33 = (char *)&_dispatch_sources + 8 * (v35 & 0x3F);
  char v31 = 1;
  for (uint64_t i = *(void *)v33;
        i && (*(void *)(i + 24) != *((_DWORD *)a1 + 6) || *(__int16 *)(i + 32) != *((char *)a1 + 28));
  uint64_t v32 = i;
  if (i)
  {
    int v30 = a1[4] & ~*(_DWORD *)(i + 48);
    if (v30)
    {
      *(_DWORD *)(i + 48) |= v30;
      uint64_t v28 = 0;
      if (*a1) {
        uint64_t v28 = *a1;
      }
      if (*(void *)(v28 + 40))
      {
        uint64_t v27 = 0;
        if (*a1) {
          uint64_t v27 = *a1;
        }
        char v31 = (*(uint64_t (**)(uint64_t))(v27 + 40))(i) & 1;
      }
      else
      {
        char v31 = _dispatch_kq_immediate_update(-4, i + 24) == 0;
      }
      if ((v31 & 1) == 0) {
        *(_DWORD *)(i + 48) &= ~v30;
      }
    }
    goto LABEL_45;
  }
  uint64_t v32 = _dispatch_calloc();
  uint64_t v43 = a1;
  uint64_t v42 = (void *)(v32 + 24);
  __int16 v41 = 5;
  uint64_t v40 = (unsigned int *)a1;
  uint64_t v39 = 0;
  uint64_t v26 = 0;
  if (*a1) {
    uint64_t v26 = *a1;
  }
  uint64_t v39 = v26;
  __int16 v38 = 0;
  __int16 v38 = *(_WORD *)(v26 + 12) | v41;
  if ((v38 & 0x200) != 0 && (v38 & 1) == 0) {
    v38 &= ~0x200u;
  }
  __src[0] = v40[6];
  LOWORD(__src[1]) = *(char *)(v39 + 8);
  WORD1(__src[1]) = v38;
  unsigned int v57 = v40[9];
  unsigned int v56 = 0;
  uint64_t v55 = 0;
  if ((v57 & 0x4000000) != 0)
  {
    uint64_t v55 = v57 & 0x8E000000 | 0xFFLL;
    unsigned int v61 = v57 & 0xF000;
    unsigned int v56 = v61 >> 12;
    BOOL v60 = v61 >> 12 != 0;
    uint64_t v59 = 523;
    if (!(v61 >> 12)) {
      _dispatch_abort(v59, v60, v8, v9, v10, v11, v12, v13);
    }
    goto LABEL_32;
  }
  uint64_t v55 = v57 & 0x8E0000FF;
  unsigned int v62 = v57 & 0xF00;
  unsigned int v56 = v62 >> 8;
  if (v62 >> 8)
  {
LABEL_32:
    uint64_t v58 = v55 | (1 << (v56 + 7));
    goto LABEL_33;
  }
  uint64_t v58 = v55;
LABEL_33:
  HIDWORD(__src[1]) = v58;
  __src[2] = v40;
  __src[3] = v40[8] | (unint64_t)*(unsigned int *)(v39 + 16);
  __src[4] = *(unsigned __int16 *)(v39 + 14);
  memset(&__src[5], 0, 32);
  memcpy(v42, __src, 0x48uLL);
  *(_DWORD *)(v32 + 36) = 0x2000000;
  *(void *)(v32 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v32 | 1;
  uint64_t v25 = 0;
  if (*a1) {
    uint64_t v25 = *a1;
  }
  if (*(void *)(v25 + 40))
  {
    uint64_t v24 = 0;
    if (*a1) {
      uint64_t v24 = *a1;
    }
    char v31 = (*(uint64_t (**)(uint64_t))(v24 + 40))(v32) & 1;
  }
  else
  {
    char v31 = _dispatch_kq_immediate_update(-4, v32 + 24) == 0;
  }
  if (v31)
  {
    *(_WORD *)(v32 + 34) &= 0xFDFEu;
    uint64_t v14 = *(void *)v33;
    *(void *)uint64_t v32 = *(void *)v33;
    if (v14) {
      *(void *)(*(void *)v33 + 8) = v32;
    }
    *(void *)int v33 = v32;
    *(void *)(v32 + 8) = v33;
  }
  else
  {
    free((void *)v32);
  }
LABEL_45:
  if (v31)
  {
    uint64_t v44 = a1;
    BOOL v54 = (*((unsigned char *)a1 + 29) & 1) == 0;
    uint64_t v53 = 588;
    if (!v54) {
      _dispatch_abort(v53, 0, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v29 = v44 - 3;
    uint64_t v15 = *(void *)(v32 + 16);
    *(v44 - 3) = v15;
    if (v15) {
      *(void *)(*(void *)(v32 + 16) + 8) = v29;
    }
    *(void *)(v32 + 16) = v29;
    v29[1] = v32 + 16;
    if (*((char *)a1 + 28) == -24) {
      *((unsigned char *)a1 + 3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(v32 + 64) != 0;
    }
    v29[2] = v32;
    uint64_t v47 = a1;
    uint64_t v46 = -4;
    uint64_t v45 = 1;
    uint64_t v52 = a1;
    uint64_t v51 = -3;
    uint64_t v50 = -3;
    uint64_t v49 = -3;
    a1[2] = -3;
    uint64_t v48 = v50;
    _dispatch_thread_getspecific(0);
    _evfiltstr(*((char *)a1 + 28));
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v16, v17, v18, v19, v20, v21, v22, 1183);
  }
  return v31 & 1;
}

const char *_evfiltstr(__int16 a1)
{
  if (!v2 & v1)
  {
    uint64_t v4 = (a1 + 24);
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = (a1 + 24);
    char v3 = 0;
  }
  if ((v3 & 1) == 0)
  {
    switch(v4)
    {
      case 0:
        return "DISPATCH_EVFILT_MACH_NOTIFICATION";
      case 1:
        return "DISPATCH_EVFILT_CUSTOM_REPLACE";
      case 2:
        return "DISPATCH_EVFILT_CUSTOM_OR";
      case 3:
        return "DISPATCH_EVFILT_CUSTOM_ADD";
      case 4:
        return "DISPATCH_EVFILT_TIMER_WITH_CLOCK";
      case 5:
        return "DISPATCH_EVFILT_TIMER";
      case 6:
        return "EVFILT_EXCLAVES_NOTIFICATION";
      case 7:
        return "EVFILT_WORKLOOP";
      case 8:
      case 9:
      case 12:
      case 13:
        return "EVFILT_missing";
      case 10:
        return "EVFILT_MEMORYSTATUS";
      case 11:
        return "EVFILT_SOCK";
      case 14:
        return "EVFILT_USER";
      case 15:
        return "EVFILT_FS";
      case 16:
        return "EVFILT_MACHPORT";
      case 17:
        return "EVFILT_TIMER";
      case 18:
        return "EVFILT_SIGNAL";
      case 19:
        return "EVFILT_PROC";
      case 20:
        return "EVFILT_VNODE";
      case 21:
        return "EVFILT_AIO";
      case 22:
        return "EVFILT_WRITE";
      case 23:
        return "EVFILT_READ";
      default:
        JUMPOUT(0);
    }
  }
  return "EVFILT_missing";
}

void _dispatch_unote_resume_muxed(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  a1[2] |= 1uLL;
  uint64_t v9 = 0;
  if (*a1) {
    uint64_t v9 = *a1;
  }
  if (*(void *)(v9 + 40))
  {
    if (*((unsigned char *)a1 + 29)) {
      _dispatch_abort(588, (*((unsigned char *)a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v8 = 0;
    if (*a1) {
      uint64_t v8 = *a1;
    }
    (*(void (**)(void))(v8 + 40))(*(a1 - 1));
  }
  else
  {
    if (*((unsigned char *)a1 + 29)) {
      _dispatch_abort(588, (*((unsigned char *)a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_kq_deferred_update(-4, (__int16 *)(*(a1 - 1) + 24));
  }
}

uint64_t _dispatch_unote_unregister_muxed(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v31 = a1;
  if (*((unsigned char *)a1 + 29)) {
    _dispatch_abort(588, 0, a3, a4, a5, a6, a7, a8);
  }
  unsigned int v29 = a1 - 3;
  uint64_t v28 = (__int16 *)*(a1 - 1);
  BOOL v27 = 0;
  char v26 = 0;
  if (v28[16] == -24) {
    *((unsigned char *)a1 + 3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
  }
  a1[2] = 0;
  if (*v29) {
    *(void *)(*(a1 - 3) + 8) = *(a1 - 2);
  }
  *(void *)*(a1 - 2) = *(a1 - 3);
  *unsigned int v29 = -1;
  *(a1 - 2) = -1;
  *unsigned int v29 = -1;
  *(a1 - 2) = -1;
  *(a1 - _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
  if (*((void *)v28 + 2))
  {
    uint64_t v24 = 0;
    if (*a1) {
      uint64_t v24 = *a1;
    }
    int v25 = *(_DWORD *)(v24 + 16);
    for (uint64_t i = (uint64_t *)*((void *)v28 + 2); i; uint64_t i = (uint64_t *)*i)
    {
      char v31 = i + 3;
      v25 |= *((_DWORD *)i + 14);
    }
    if ((*((_DWORD *)v28 + 12) & ~v25) != 0)
    {
      *((_DWORD *)v28 + 12) &= v25;
      BOOL v27 = 1;
    }
  }
  else
  {
    char v26 = 1;
    BOOL v27 = (v28[17] & 2) == 0;
    v28[17] |= 2u;
  }
  if (v27)
  {
    uint64_t v23 = 0;
    if (*v31) {
      uint64_t v23 = *v31;
    }
    if (*(void *)(v23 + 40))
    {
      uint64_t v22 = 0;
      if (*v31) {
        uint64_t v22 = *v31;
      }
      if (((*(uint64_t (**)(__int16 *))(v22 + 40))(v28) & 1) == 0) {
        _dispatch_bug(1236, 0, v8, v9, v10, v11, v12, v13);
      }
    }
    else
    {
      _dispatch_kq_deferred_update(-4, v28 + 12);
    }
  }
  if (v26)
  {
    if (*(void *)v28) {
      *(void *)(*(void *)v28 + 8) = *((void *)v28 + 1);
    }
    **((void **)v28 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *(void *)v28;
    *(void *)uint64_t v28 = -1;
    *((void *)v28 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = -1;
    free(v28);
  }
  _dispatch_thread_getspecific(0);
  _evfiltstr(*((char *)v31 + 28));
  _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v14, v15, v16, v17, v18, v19, v20, 1245);
  return 1;
}

BOOL _dispatch_unote_register_direct(uint64_t *a1, uint64_t a2)
{
  return _dispatch_kq_unote_update(a2, a1, 5);
}

BOOL _dispatch_kq_unote_update(uint64_t a1, uint64_t *a2, __int16 a3)
{
  uint64_t v70 = (unsigned int *)a2;
  uint64_t v69 = a1;
  __int16 v68 = a3;
  uint64_t v67 = _dispatch_thread_getspecific(0x1DuLL);
  long long v66 = v70;
  long long v65 = 0;
  int v64 = 0;
  if (v68)
  {
    uint64_t v145 = v69;
    if (v69)
    {
      if (v145 != -4)
      {
        uint64_t v144 = v145;
        uint64_t v189 = v145;
        int v186 = 1;
        int v185 = 1;
        int v187 = 1;
        int v181 = 1;
        int v180 = 1;
        int v182 = 1;
        unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v145 + 96), 1u, memory_order_relaxed);
        unsigned int v183 = add_explicit;
        unsigned int v178 = add_explicit;
        unsigned int v184 = add_explicit + 1;
        unsigned int v188 = add_explicit + 1;
        if ((int)(add_explicit + 1) <= 0)
        {
          qword_F4290 = (uint64_t)"API MISUSE: Resurrection of an object";
          __break(1u);
          JUMPOUT(0x8EA60);
        }
      }
    }
    unsigned __int8 v63 = v66;
    uint64_t v92 = v66;
    uint64_t v91 = v69;
    uint64_t v90 = 1;
    unsigned int v97 = v66;
    uint64_t v96 = v69 | 1;
    uint64_t v95 = v69 | 1;
    uint64_t v94 = v69 | 1;
    *((void *)v66 + 2) = v69 | 1;
    uint64_t v93 = v95;
  }
  if (v67 && v67[3] == v69)
  {
    int v62 = 0;
    __int16 v9 = *((char *)v66 + 28);
    uint64_t v10 = v66[6];
    uint64_t v113 = v67;
    __int16 v112 = v9;
    uint64_t v111 = v10;
    uint64_t v110 = v66;
    uint64_t v109 = 0;
    uint64_t v109 = v67[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v113 + 20)
       && (*(__int16 *)(v109 + 72 * i + 8) != v112
        || *(void *)(v109 + 72 * i) != v111
        || *(void *)(v109 + 72 * i + 16) != (void)v110);
    int v62 = i;
    if (i < *((unsigned __int16 *)v67 + 20)) {
      v68 |= *(_WORD *)(v67[4] + 72 * v62 + 10) & 4;
    }
    if ((v68 & 1) == 0 && (v68 & 4) != 0)
    {
      uint64_t v122 = v69;
      uint64_t v121 = v67;
      int v120 = v62;
      if (v69 != -4) {
        _dispatch_thread_setspecific(5, 1);
      }
      if (v120 == *((unsigned __int16 *)v121 + 21))
      {
        unsigned int v119 = 0;
        unsigned int v119 = *((unsigned __int16 *)v121 + 20);
        *((_WORD *)v121 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 1;
        uint64_t v11 = v121[4];
        uint64_t v127 = v122;
        uint64_t v126 = v11;
        unsigned int v125 = v119;
        _dispatch_kq_drain(v122, v11, v119, 3);
        BOOL v12 = *((unsigned __int16 *)v121 + 20) == 1;
        BOOL v124 = *((unsigned __int16 *)v121 + 20) == 1;
        uint64_t v123 = 915;
        if (!v12) {
          _dispatch_abort(v123, v124, v3, v4, v5, v6, v7, v8);
        }
        int v120 = 0;
      }
      else if (v120 == *((unsigned __int16 *)v121 + 20))
      {
        ++*((_WORD *)v121 + 20);
      }
      long long v65 = (_OWORD *)(v121[4] + 72 * v120);
      unsigned int v61 = v66;
      uint64_t v89 = v66;
      uint64_t v88 = v65;
      __int16 v87 = v68;
      uint64_t v86 = v66;
      uint64_t v85 = 0;
      uint64_t v58 = 0;
      if (*(void *)v66) {
        uint64_t v58 = *(void *)v66;
      }
      uint64_t v85 = v58;
      __int16 v84 = 0;
      __int16 v84 = *(_WORD *)(v58 + 12) | v87;
      if ((v84 & 0x200) != 0 && (v84 & 1) == 0) {
        v84 &= ~0x200u;
      }
      unsigned int v57 = v88;
      *(void *)&long long v81 = v86[6];
      WORD4(v8_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *(char *)(v85 + 8);
      WORD5(v8_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v84;
      unsigned int v130 = v86[9];
      unsigned int v129 = 0;
      uint64_t v128 = 0;
      if ((v130 & 0x4000000) != 0)
      {
        uint64_t v128 = v130 & 0x8E000000 | 0xFFLL;
        unsigned int v141 = v130 & 0xF000;
        unsigned int v129 = v141 >> 12;
        BOOL v133 = v141 >> 12 != 0;
        uint64_t v132 = 523;
        if (!(v141 >> 12)) {
          _dispatch_abort(v132, v133, v3, v4, v5, v6, v7, v8);
        }
      }
      else
      {
        uint64_t v128 = v130 & 0x8E0000FF;
        unsigned int v143 = v130 & 0xF00;
        unsigned int v129 = v143 >> 8;
        if (!(v143 >> 8))
        {
          uint64_t v131 = v128;
LABEL_39:
          HIDWORD(v8_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v131;
          *(void *)&long long v82 = v86;
          *((void *)&v82 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v86[8] | (unint64_t)*(unsigned int *)(v85 + 16);
          *(void *)int v83 = *(unsigned __int16 *)(v85 + 14);
          memset(&v83[8], 0, 32);
          _OWORD *v88 = v81;
          long long v13 = v82;
          long long v14 = *(_OWORD *)v83;
          long long v15 = *(_OWORD *)&v83[16];
          *((void *)v57 + 8) = *(void *)&v83[32];
          v57[3] = v15;
          v57[2] = v14;
          v57[1] = v13;
          dispatch_kevent_debug("deferred", (uint64_t)v65, 0, 0, (uint64_t)"_dispatch_kq_unote_update", 0x410u);
          goto LABEL_57;
        }
      }
      uint64_t v131 = v128 | (1 << (v129 + 7));
      goto LABEL_39;
    }
    BOOL v116 = v67;
    int v115 = v62;
    if (v62 < *((unsigned __int16 *)v67 + 20))
    {
      int v114 = 0;
      unsigned __int16 v16 = *((_WORD *)v116 + 20) - 1;
      *((_WORD *)v116 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v16;
      int v114 = v16;
      if (v115 != v16)
      {
        uint64_t v17 = v116[4];
        uint64_t v18 = v17 + 72 * v115;
        uint64_t v19 = v17 + 72 * v114;
        *(_OWORD *)uint64_t v18 = *(_OWORD *)v19;
        long long v20 = *(_OWORD *)(v19 + 16);
        long long v21 = *(_OWORD *)(v19 + 32);
        long long v22 = *(_OWORD *)(v19 + 48);
        *(void *)(v18 + 64) = *(void *)(v19 + 64);
        *(_OWORD *)(v18 + 48) = v22;
        *(_OWORD *)(v18 + 32) = v21;
        *(_OWORD *)(v18 + 16) = v20;
      }
    }
  }
  if (v68)
  {
    uint64_t v60 = 0;
    memset(v59, 0, sizeof(v59));
    uint64_t v80 = v66;
    uint64_t v79 = v59;
    __int16 v78 = v68;
    uint64_t v77 = v66;
    uint64_t v76 = 0;
    uint64_t v56 = 0;
    if (*(void *)v66) {
      uint64_t v56 = *(void *)v66;
    }
    uint64_t v76 = v56;
    __int16 v75 = 0;
    __int16 v75 = *(_WORD *)(v56 + 12) | v78;
    if ((v75 & 0x200) != 0 && (v75 & 1) == 0) {
      v75 &= ~0x200u;
    }
    uint64_t v55 = v79;
    *(void *)&long long v72 = v77[6];
    WORD4(v72) = *(char *)(v76 + 8);
    WORD5(v72) = v75;
    unsigned int v136 = v77[9];
    unsigned int v135 = 0;
    uint64_t v134 = 0;
    if ((v136 & 0x4000000) != 0)
    {
      uint64_t v134 = v136 & 0x8E000000 | 0xFFLL;
      unsigned int v140 = v136 & 0xF000;
      unsigned int v135 = v140 >> 12;
      BOOL v139 = v140 >> 12 != 0;
      uint64_t v138 = 523;
      if (!(v140 >> 12)) {
        _dispatch_abort(v138, v139, v3, v4, v5, v6, v7, v8);
      }
    }
    else
    {
      uint64_t v134 = v136 & 0x8E0000FF;
      unsigned int v142 = v136 & 0xF00;
      unsigned int v135 = v142 >> 8;
      if (!(v142 >> 8))
      {
        uint64_t v137 = v134;
LABEL_56:
        HIDWORD(v72) = v137;
        *(void *)&long long v73 = v77;
        *((void *)&v73 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v77[8] | (unint64_t)*(unsigned int *)(v76 + 16);
        *(void *)uint64_t v74 = *(unsigned __int16 *)(v76 + 14);
        memset(&v74[8], 0, 32);
        *uint64_t v79 = v72;
        long long v23 = v73;
        long long v24 = *(_OWORD *)v74;
        long long v25 = *(_OWORD *)&v74[16];
        *((void *)v55 + 8) = *(void *)&v74[32];
        v55[3] = v25;
        v55[2] = v24;
        v55[1] = v23;
        uint64_t v118 = v69;
        int v117 = v59;
        int v64 = _dispatch_kq_drain(v69, v59, 1, 3);
        goto LABEL_57;
      }
    }
    uint64_t v137 = v134 | (1 << (v135 + 7));
    goto LABEL_56;
  }
LABEL_57:
  if (v68)
  {
    if (v64)
    {
      uint64_t v162 = v69;
      if (v69)
      {
        if (v162 != -4)
        {
          uint64_t v161 = v162;
          uint64_t v175 = (void *)v162;
          int v174 = 0;
          int v172 = 1;
          int v171 = 1;
          int v173 = 1;
          unsigned int v169 = 0;
          int v167 = 1;
          int v166 = 1;
          int v168 = 1;
          unsigned int v165 = atomic_fetch_add_explicit((atomic_uint *volatile)(v162 + 96), 0xFFFFFFFF, memory_order_relaxed);
          unsigned int v169 = v165;
          unsigned int v164 = v165;
          unsigned int v170 = v165 - v173;
          int v174 = v165 - v173;
          if (((v165 - v173) & 0x80000000) != 0)
          {
            if (v174 <= -2)
            {
              qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
              __break(1u);
              JUMPOUT(0x8F4F4);
            }
            v175[7] = 0xDEAD000000000000;
            unint64_t v163 = v175;
            _dispatch_object_dealloc(v175);
          }
        }
      }
      uint64_t v107 = v66;
      uint64_t v106 = 0;
      uint64_t v105 = 0;
      uint64_t v104 = 0;
      *((void *)v66 + 2) = 0;
      uint64_t v103 = v105;
    }
    else
    {
      _dispatch_thread_getspecific(0);
      _evfiltstr(*((char *)v66 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v26, v27, v28, v29, v30, v31, v32, 1060);
    }
    return v64 == 0;
  }
  else
  {
    if ((v68 & 2) != 0)
    {
      if (v64 == 36)
      {
        _dispatch_thread_getspecific(0);
        _evfiltstr(*((char *)v66 + 28));
        _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v33, v34, v35, v36, v37, v38, v39, 1067);
        return 0;
      }
      uint64_t v147 = v69;
      if (v69)
      {
        if (v147 != -4)
        {
          uint64_t v146 = v147;
          unsigned int v160 = (void *)v147;
          int v159 = 0;
          int v157 = 1;
          int v156 = 1;
          int v158 = 1;
          unsigned int v154 = 0;
          int v152 = 1;
          int v151 = 1;
          int v153 = 1;
          unsigned int v150 = atomic_fetch_add_explicit((atomic_uint *volatile)(v147 + 96), 0xFFFFFFFF, memory_order_relaxed);
          unsigned int v154 = v150;
          unsigned int v149 = v150;
          unsigned int v155 = v150 - v158;
          int v159 = v150 - v158;
          if (((v150 - v158) & 0x80000000) != 0)
          {
            if (v159 <= -2)
            {
              qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
              __break(1u);
              JUMPOUT(0x8F7A4);
            }
            v160[7] = 0xDEAD000000000000;
            long long v148 = v160;
            _dispatch_object_dealloc(v160);
          }
        }
      }
      uint64_t v102 = v66;
      uint64_t v101 = 0;
      uint64_t v100 = 0;
      uint64_t v99 = 0;
      *((void *)v66 + 2) = 0;
      uint64_t v98 = v100;
      _dispatch_thread_getspecific(0);
      _evfiltstr(*((char *)v66 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v40, v41, v42, v43, v44, v45, v46, 1072);
    }
    else if ((v68 & 4) != 0)
    {
      _dispatch_thread_getspecific(0);
      _evfiltstr(*((char *)v66 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v47, v48, v49, v50, v51, v52, v53, 1074);
    }
    uint64_t v177 = v64;
    uint64_t v176 = 1077;
    if (v64) {
      _dispatch_bug(v176, v177, v3, v4, v5, v6, v7, v8);
    }
    return 1;
  }
}

BOOL _dispatch_unote_resume_direct(uint64_t *a1)
{
  a1[2] |= 1uLL;
  return _dispatch_kq_unote_update(a1[2] & 0xFFFFFFFFFFFFFFFCLL, a1, 4);
}

uint64_t _dispatch_unote_unregister_direct(uint64_t a1, char a2)
{
  uint64_t v14 = *(void *)(a1 + 16);
  unint64_t v13 = v14 & 0xFFFFFFFFFFFFFFFCLL;
  BOOL v12 = _dispatch_thread_getspecific(0x1DuLL);
  __int16 v11 = 2;
  BOOL v10 = 0;
  if ((v14 & 0xFFFFFFFFFFFFFFFCLL) != 0xFFFFFFFFFFFFFFFCLL)
  {
    BOOL v10 = 0;
    if (v12) {
      BOOL v10 = v12[3] == v13;
    }
  }
  if (v10)
  {
    __int16 v11 = 6;
    a2 |= 5u;
  }
  if (v14 & 2) == 0 || (a2)
  {
    if (v14 == 2)
    {
      *(void *)(a1 + 16) = 0;
      _dispatch_thread_getspecific(0);
      _evfiltstr(*(char *)(a1 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v2, v3, v4, v5, v6, v7, v8, 1285);
      return 1;
    }
    if ((v14 & 1) == 0)
    {
      v11 |= 4u;
      a2 |= 4u;
    }
    if (((v11 & 4) != 0 || (a2 & 2) != 0) && _dispatch_kq_unote_update(v13, (uint64_t *)a1, v11)) {
      return 1;
    }
  }
  if ((a2 & 4) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unregistration failed";
    __break(1u);
    JUMPOUT(0x8FD18);
  }
  return 0;
}

void _dispatch_event_loop_atfork_child()
{
  _dispatch_mach_host_port_pred = 0;
  _dispatch_mach_host_port = 0;
}

void _dispatch_event_loop_poke(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = a1;
  unint64_t v20 = a2;
  int v19 = a3;
  if (a1 == -8)
  {
    uint64_t v18 = 0;
    long long v17 = 0u;
    long long v16 = 0u;
    v15[1] = 65526;
    v15[0] = 1;
    void v15[2] = -8;
    v15[3] = 0x1000000;
    _dispatch_kq_deferred_update(-4, (__int16 *)v15);
  }
  else
  {
    if (!v21 || v21 == -4)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unsupported wlh configuration";
      qword_F42C0 = v21;
      __break(1u);
      JUMPOUT(0x903D4);
    }
    unint64_t v28 = v20;
    unint64_t v27 = (v20 >> 37) & 1;
    uint64_t v26 = 1890;
    if (!v27) {
      _dispatch_abort(v26, 0, a3, a4, a5, a6, a7, a8);
    }
    unint64_t v29 = v20;
    if ((BYTE4(v20) >> 6))
    {
      BOOL v25 = v19 >= 0;
      uint64_t v24 = 1892;
      if (v19 < 0) {
        _dispatch_abort(v24, v25, a3, a4, a5, a6, a7, a8);
      }
      uint64_t v23 = v19 & 1;
      uint64_t v22 = 1893;
      if ((v19 & 1) == 0) {
        _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
      }
      uint64_t v33 = &_dispatch_mgr_q;
      uint64_t v32 = v21;
      int v31 = 0;
      int v30 = 0;
      uint64_t v35 = &_dispatch_mgr_q;
      uint64_t v34 = v21;
      unint64_t v13 = 0;
      if (_dispatch_mgr_q) {
        unint64_t v13 = _dispatch_mgr_q;
      }
      ((void (*)(uint64_t (***)(), uint64_t, void))v13[9])(&_dispatch_mgr_q, v21, 0);
    }
    else
    {
      uint64_t v14 = _dispatch_thread_getspecific(0x1DuLL);
      if (v14 && v14[3] == v21) {
        _dispatch_kevent_workloop_poke_self((uint64_t)v14, v20, v19, v8, v9, v10, v11, v12);
      }
      else {
        _dispatch_kevent_workloop_poke(v21, v20, v19, v8, v9, v10, v11, v12);
      }
    }
  }
}

void _dispatch_kevent_workloop_poke_self(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *(void *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 45) & 4) != 0)
  {
    if ((*(unsigned char *)(a1 + 45) & 1) == 0) {
      _dispatch_abort(1790, *(unsigned char *)(a1 + 45) & 1, a3, a4, a5, a6, a7, a8);
    }
    if ((int)a3 >= 0)
    {
      if ((a2 & 0xFFFFFFFC) != 0) {
        _dispatch_abort(1802, (a2 & 0xFFFFFFFC) == 0, a3, a4, a5, a6, a7, a8);
      }
      if ((a2 & 1) == 0) {
        _dispatch_abort(1803, (a2 & 1) != 0, a3, a4, a5, a6, a7, a8);
      }
      if ((a3 & 1) == 0) {
        _dispatch_abort(1804, a3 & 1, a3, a4, a5, a6, a7, a8);
      }
      _dispatch_release_no_dispose(v14);
      _dispatch_event_loop_leave_deferred(a1, a2, v8, v9, v10, v11, v12, v13);
    }
    else
    {
      _dispatch_kevent_workloop_override_self(a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
  else if (*(unsigned char *)(a1 + 45))
  {
    if ((int)a3 >= 0) {
      _dispatch_abort(1825, a3 & 0x80000000, a3, a4, a5, a6, a7, a8);
    }
    if (!*(void *)(a1 + 8)) {
      _dispatch_abort(1826, 0, a3, a4, a5, a6, a7, a8);
    }
    if (a3) {
      _dispatch_release_2_no_dispose(v14);
    }
  }
  else
  {
    if ((int)a3 >= 0)
    {
      if ((a3 & 1) == 0) {
        _dispatch_abort(1864, a3 & 1, a3, a4, a5, a6, a7, a8);
      }
    }
    else if (a3)
    {
      _dispatch_release_no_dispose(v14);
    }
    else
    {
      _dispatch_retain(v14);
    }
    if (*(void *)(a1 + 8)) {
      _dispatch_abort(1866, *(void *)(a1 + 8) == 0, a3, a4, a5, a6, a7, a8);
    }
    *(unsigned char *)(a1 + 45) = *(unsigned char *)(a1 + 45) & 0xFE | 1;
    *(unsigned char *)(a1 + 45) = *(unsigned char *)(a1 + 45) & 0xFD | 2;
    *(void *)a1 = *(void *)(v14 + 24);
    *(void *)(a1 + 8) = v14;
    *(_DWORD *)(a1 + 16) = (a2 & 0x700000000) >> 32;
  }
}

void _dispatch_kevent_workloop_poke(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = a1;
  unint64_t v20 = a2;
  int v19 = a3;
  unsigned int v18 = 3;
  uint64_t v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  memset(v14, 0, sizeof(v14));
  unint64_t v44 = a2;
  unint64_t v25 = a2 & 1;
  uint64_t v24 = 1737;
  if ((a2 & 1) == 0) {
    _dispatch_abort(v24, 0, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v26 = v20;
  BOOL v23 = (v20 & 0x4000000000) == 0;
  uint64_t v22 = 1738;
  if ((v20 & 0x4000000000) != 0) {
    _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v38 = v20;
  unint64_t v42 = v20;
  unint64_t v41 = (v20 >> 37) & 1;
  uint64_t v40 = 1659;
  if (!v41) {
    _dispatch_abort(v40, 0, a3, a4, a5, a6, a7, a8);
  }
  unint64_t v43 = v38;
  if (v38)
  {
    unint64_t v45 = v38;
    int v46 = v38;
    if ((v38 & 0xFFFFFFFC) != 0) {
      int v39 = 2;
    }
    else {
      int v39 = 0;
    }
  }
  else
  {
    int v39 = 3;
  }
  _dispatch_kq_fill_workloop_event((uint64_t)v14, v39, v21, v20, a5, a6, a7, a8);
  if (_dispatch_kq_poll(v21, v14, 1, v14, 1, 0, 0, v18))
  {
    uint64_t v34 = v14;
    uint64_t v33 = 0;
    unsigned int v32 = v15;
    dispatch_kevent_debug("received error", (uint64_t)v14, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    uint64_t v37 = *((_WORD *)v34 + 5) & 0x4000;
    uint64_t v36 = 1582;
    if (!v37) {
      _dispatch_abort(v36, 0, v8, v9, v10, v11, v12, v13);
    }
    *((_WORD *)v34 + 5) &= ~0x4000u;
    *((_DWORD *)v34 + 7) = v32;
    *((void *)v34 + 4) = 0;
    switch(v32)
    {
      case 2u:
        if ((v33 & 1) == 0
          || (*((_WORD *)v34 + 5) & 2) == 0
          || (*((unsigned char *)v34 + 24) & 8) == 0
          || (*((unsigned char *)v34 + 24) & 0x20) == 0)
        {
          unint64_t v31 = 0;
          unint64_t v31 = (unint64_t)*((unsigned int *)v34 + 6) << 32;
          v31 |= *((unsigned __int16 *)v34 + 5) << 16;
          v31 |= v32;
          unint64_t v30 = v31;
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_F42C0 = v31;
          __break(1u);
          JUMPOUT(0x90B4CLL);
        }
        int v35 = 2;
        break;
      case 4u:
        if ((v33 & 4) == 0 || (*((unsigned char *)v34 + 24) & 4) == 0) {
          goto LABEL_39;
        }
        int v35 = 4;
        break;
      case 0x22u:
        uint64_t v29 = 0;
        uint64_t v29 = *((int *)v34 + 3);
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_F42C0 = v29;
        __break(1u);
        JUMPOUT(0x90BD8);
      case 0x46u:
        if ((v33 & 2) == 0 || (*((unsigned char *)v34 + 25) & 1) != 0 || !*((void *)v34 + 6) || !*((void *)v34 + 7)) {
          goto LABEL_39;
        }
        int v35 = 70;
        break;
      case 0x69u:
        uint64_t v28 = 0;
        uint64_t v28 = *((void *)v34 + 8);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_F42C0 = v28;
        __break(1u);
        JUMPOUT(0x90C18);
      default:
LABEL_39:
        uint64_t v27 = (int)v32;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = (int)v32;
        __break(1u);
        JUMPOUT(0x90C58);
    }
    __break(1u);
  }
  if (v19 < 0)
  {
    if (v19) {
      _dispatch_release_2_tailcall(v21);
    }
  }
  else
  {
    _dispatch_release_tailcall(v21);
  }
}

void _dispatch_event_loop_drain(unsigned int a1)
{
  unsigned int v18 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v17 = (void *)v18[3];
  do
  {
    if ((*((unsigned char *)v18 + 45) & 2) != 0)
    {
      unint64_t v15 = v17[7];
      if ((*((unsigned char *)v18 + 45) & 1) == 0) {
        _dispatch_abort(1925, 0, v1, v2, v3, v4, v5, v6);
      }
      *((unsigned char *)v18 + 45) &= ~2u;
      uint64_t v22 = v18[4];
      for (int i = 0;
            i < *((unsigned __int16 *)v18 + 20)
         && (*(__int16 *)(v22 + 72 * i + 8) != -17
          || *(void **)(v22 + 72 * i) != v17
          || *(void **)(v22 + 72 * i + 16) != v17);
      if (i == *((unsigned __int16 *)v18 + 20))
      {
        if (i >= 16) {
          _dispatch_abort(1496, i < 16, v1, v2, v3, v4, v5, v6);
        }
        ++*((_WORD *)v18 + 20);
      }
      _dispatch_kq_fill_workloop_event(v18[4] + 72 * i, 2, (uint64_t)v17, v15, v3, v4, v5, v6);
    }
    int v16 = *((unsigned __int16 *)v18 + 20);
    *((_WORD *)v18 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
    _dispatch_kq_drain((uint64_t)v17, v18[4], v16, a1);
    if (v17 && v17 != (void *)-4)
    {
      uint64_t v13 = 0;
      if (*v17) {
        uint64_t v13 = *v17;
      }
      if (*(unsigned char *)(v13 + 16) == 18) {
        unint64_t v20 = v17;
      }
      else {
        unint64_t v20 = 0;
      }
    }
    else
    {
      unint64_t v20 = 0;
    }
    if (v20)
    {
      uint64_t v14 = v20[6];
      if (v14)
      {
        if (*(unsigned char *)(v14 + 6)) {
          _dispatch_event_loop_drain_timers(v14, 6u, v7, v8, v9, v10, v11, v12);
        }
      }
    }
  }
  while ((a1 & 1) != 0 && (a1 & 2) == 0 && _dispatch_thread_getspecific(5uLL));
}

uint64_t _dispatch_kq_drain(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v21 = a1;
  uint64_t v20 = a2;
  int v19 = a3;
  unsigned int v18 = a4;
  BOOL v17 = (a4 & 2) == 0;
  int v16 = 0;
  uint64_t v14 = 16;
  unsigned int v15 = 16;
  int i = 0;
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  if ((a4 & 2) == 0)
  {
    uint64_t v23 = 1;
    uint64_t v22 = 803;
    uint64_t v9 = &v10;
    uint64_t v10 = 0x8000;
    uint64_t v8 = &v5 - 4096;
    bzero(&v5 - 4096, 0x8000uLL);
    uint64_t v11 = v8;
    uint64_t v12 = v9;
  }
  for (int i = 0; i < v19; ++i)
    dispatch_kevent_debug(0, v20 + 72 * i, i, v19, (uint64_t)"_dispatch_kq_drain", 0x32Du);
  if (v17) {
    _dispatch_thread_setspecific(5, 0);
  }
  int v19 = _dispatch_kq_poll(v21, v20, v19, v24, v15, v11, v12, v18);
  if (v19)
  {
    if ((v18 & 2) != 0)
    {
      int v16 = 0;
      int i = 0;
      while (v16 < v19)
      {
        if ((v24[36 * v16 + 5] & 0x4000) != 0 && *(void *)&v24[36 * v16 + 16])
        {
          uint64_t v6 = 72;
          uint64_t v7 = v24;
          _dispatch_kevent_drain((unsigned __int8 *)&v24[36 * v16]);
          int i = *(void *)((char *)v7 + v16 * v6 + 32);
        }
        ++v16;
      }
    }
    else
    {
      if ((v24[5] & 0x4000) != 0) {
        _dispatch_thread_setspecific(5, 1);
      }
      int v16 = 0;
      int i = 0;
      while (v16 < v19)
        _dispatch_kevent_drain((unsigned __int8 *)&v24[36 * v16++]);
    }
  }
  else
  {
    return 0;
  }
  return i;
}

void _dispatch_event_loop_merge(uint64_t a1, unsigned int a2)
{
  uint64_t v20 = a1;
  unsigned int v19 = a2;
  unsigned int v18 = _dispatch_thread_getspecific(0x1DuLL);
  BOOL v17 = 0;
  BOOL v17 = (void *)v18[3];
  int v16 = &v8;
  uint64_t v12 = (char *)&v8 - ((72 * v19 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = v19;
  __memcpy_chk();
  *((_WORD *)v18 + 2_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 14;
  for (int i = 0; i < (int)v19; ++i)
    _dispatch_kevent_drain((unsigned __int8 *)&v12[72 * i]);
  if (v17 == (void *)-4)
  {
    if (v18[1])
    {
      if (*((_WORD *)v18 + 20)) {
        _dispatch_event_loop_drain(3u);
      }
    }
  }
  else
  {
    uint64_t v9 = *v17;
    uint64_t v10 = v17;
    uint64_t v11 = 0;
    if (v9) {
      uint64_t v11 = v9;
    }
    if (*(unsigned char *)(v11 + 16) == 18)
    {
      uint64_t v13 = 0;
      uint64_t v13 = v17[6];
      if (v13)
      {
        if (*(unsigned char *)(v13 + 6)) {
          _dispatch_event_loop_drain_timers(v13, 6u, v2, v3, v4, v5, v6, v7);
        }
      }
    }
  }
}

void _dispatch_kevent_drain(unsigned __int8 *a1)
{
  if (*((__int16 *)a1 + 4) == -10)
  {
    dispatch_kevent_debug("received", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x22Du);
    return;
  }
  if (*((__int16 *)a1 + 4) == -17)
  {
    _dispatch_kevent_workloop_poke_drain((uint64_t)a1);
    return;
  }
  dispatch_kevent_debug("received", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x235u);
  if ((*((_WORD *)a1 + 5) & 0x4000) != 0)
  {
    if (*((__int16 *)a1 + 4) != -5 || *((void *)a1 + 4) != 3)
    {
      _dispatch_kevent_print_error((uint64_t)a1);
      return;
    }
    *((_WORD *)a1 + 5) = 274;
    *((_DWORD *)a1 + 6) = -2080374784;
    *((void *)a1 + 4) = 0;
    dispatch_kevent_debug("synthetic NOTE_EXIT", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x23Eu);
  }
  if (*((__int16 *)a1 + 4) == -7)
  {
    uint64_t v9 = *((void *)a1 + 2);
    unsigned int v8 = *a1;
    if (*((uint64_t *)a1 + 4) <= 0) {
      _dispatch_abort(2408, *((void *)a1 + 4) > 0, v1, v2, v3, v4, v5, v6);
    }
    if (*(void *)a1 != (v8 | 0xFFFFFFFFFFFFFF00)) {
      _dispatch_abort(2409, *(void *)a1 == (v8 | 0xFFFFFFFFFFFFFF00), v1, v2, v3, v4, v5, v6);
    }
    if (v8 >= 9) {
      _dispatch_abort(2410, v8 < 9, v1, v2, v3, v4, v5, v6);
    }
    *(unsigned char *)(v9 + 6) |= (1 << (*a1 % 3u)) | 0x80;
    *(unsigned char *)(v9 + 32 * v8 + 7) = *(unsigned char *)(v9 + 32 * v8 + 7) & 0xFD | 2;
    *(unsigned char *)(v9 + 32 * v8 + 7) &= ~1u;
  }
  else if (*((__int16 *)a1 + 4) == -8 {
         && (_dispatch_kevent_mach_msg_size((uint64_t)a1)
  }
          || _dispatch_kevent_has_machmsg_rcv_error((uint64_t)a1)))
  {
    _dispatch_kevent_mach_msg_drain((uint64_t)a1);
  }
  else if (*((void *)a1 + 2))
  {
    _dispatch_kevent_merge_muxed((uint64_t)a1);
  }
  else
  {
    _dispatch_kevent_merge(*((void *)a1 + 2), (uint64_t)a1);
  }
}

void _dispatch_event_loop_leave_immediate(unint64_t a1)
{
  unint64_t v20 = a1;
  unsigned int v19 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v18 = 0;
  uint64_t v18 = v19[3];
  int v17 = 131075;
  uint64_t v16 = 0;
  long long v15 = 0u;
  long long v14 = 0u;
  memset(v13, 0, sizeof(v13));
  unint64_t v25 = v20;
  BOOL v24 = (v20 & 0x2000000000) == 0;
  uint64_t v23 = 1994;
  if ((v20 & 0x2000000000) != 0) {
    _dispatch_abort(v23, v24, v1, v2, v3, v4, v5, v6);
  }
  uint64_t v22 = *((unsigned char *)v19 + 45) & 1;
  uint64_t v21 = 2004;
  if (!v22) {
    _dispatch_abort(v21, 0, v1, v2, v3, v4, v5, v6);
  }
  *((unsigned char *)v19 + 45) &= ~1u;
  *((unsigned char *)v19 + 45) &= ~2u;
  _dispatch_kq_fill_workloop_event((uint64_t)v13, 6, v18, v20, v3, v4, v5, v6);
  if (_dispatch_kq_poll(v18, (uint64_t)v13, 1, (uint64_t)v13, 1, 0, 0, v17))
  {
    uint64_t v33 = v13;
    uint64_t v32 = 0;
    unsigned int v31 = v14;
    dispatch_kevent_debug("received error", (uint64_t)v13, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    uint64_t v36 = *((_WORD *)v33 + 5) & 0x4000;
    uint64_t v35 = 1582;
    if (!v36) {
      _dispatch_abort(v35, 0, v7, v8, v9, v10, v11, v12);
    }
    *((_WORD *)v33 + 5) &= ~0x4000u;
    *((_DWORD *)v33 + 7) = v31;
    *((void *)v33 + 4) = 0;
    switch(v31)
    {
      case 2u:
        if ((v32 & 1) == 0
          || (*((_WORD *)v33 + 5) & 2) == 0
          || (*((unsigned char *)v33 + 24) & 8) == 0
          || (*((unsigned char *)v33 + 24) & 0x20) == 0)
        {
          unint64_t v30 = 0;
          unint64_t v30 = (unint64_t)*((unsigned int *)v33 + 6) << 32;
          v30 |= *((unsigned __int16 *)v33 + 5) << 16;
          v30 |= v31;
          unint64_t v29 = v30;
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_F42C0 = v30;
          __break(1u);
          JUMPOUT(0x91DECLL);
        }
        int v34 = 2;
        break;
      case 4u:
        if ((v32 & 4) == 0 || (*((unsigned char *)v33 + 24) & 4) == 0) {
          goto LABEL_32;
        }
        int v34 = 4;
        break;
      case 0x22u:
        uint64_t v28 = 0;
        uint64_t v28 = *((int *)v33 + 3);
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_F42C0 = v28;
        __break(1u);
        JUMPOUT(0x91E78);
      case 0x46u:
        if ((v32 & 2) == 0 || (*((unsigned char *)v33 + 25) & 1) != 0 || !*((void *)v33 + 6) || !*((void *)v33 + 7)) {
          goto LABEL_32;
        }
        int v34 = 70;
        break;
      case 0x69u:
        uint64_t v27 = 0;
        uint64_t v27 = *((void *)v33 + 8);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_F42C0 = v27;
        __break(1u);
        JUMPOUT(0x91EB8);
      default:
LABEL_32:
        uint64_t v26 = (int)v31;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = (int)v31;
        __break(1u);
        JUMPOUT(0x91EF8);
    }
    __break(1u);
  }
}

void _dispatch_kq_fill_workloop_event(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = 0;
  unsigned int v13 = 0;
  uint64_t v12 = 0;
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
      if (((a4 >> 37) & 1) == 0) {
        _dispatch_abort(1439, 0, a3, a4, a5, a6, a7, a8);
      }
      if ((a4 & 1) == 0) {
        _dispatch_abort(1440, 0, a3, a4, a5, a6, a7, a8);
      }
      __int16 v11 = 5;
      uint64_t v12 = 0x3700000001;
      unsigned int v13 = 272;
      if ((a4 & 2) != 0)
      {
        unsigned int v13 = 400;
        uint64_t v12 = 0x3700000003;
      }
      unsigned int v16 = (a4 & 0x700000000) >> 32;
      unsigned int v15 = *(_DWORD *)(*(void *)(a3 + 24) + 84);
      if (v16 < (unsigned __int16)(v15 & 0xF00) >> 8) {
        unsigned int v16 = (unsigned __int16)(v15 & 0xF00) >> 8;
      }
      if (!v16) {
        LOBYTE(v16) = 1;
      }
      if ((v15 & 0x8000000) != 0)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Waking up a kq with cooperative thread request is not supported";
        qword_F42C0 = v15;
        __break(1u);
        JUMPOUT(0x921D0);
      }
      int v14 = (1 << (v16 + 7)) | 0xFF | v15 & 0x80000000;
      break;
    case 3:
      goto LABEL_16;
    case 4:
    case 5:
      unsigned int v13 = 256;
LABEL_16:
      if (a4) {
        _dispatch_abort(1459, (a4 & 1) == 0, a3, a4, a5, a6, a7, a8);
      }
      __int16 v11 = 7;
      uint64_t v12 = 1;
      break;
    case 6:
      __int16 v11 = 7;
      unsigned int v13 = 32;
      break;
    default:
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid transition";
      qword_F42C0 = a2;
      __break(1u);
      JUMPOUT(0x922CCLL);
  }
  *(void *)&long long v8 = a3;
  WORD4(v8) = -17;
  WORD5(v8) = v11;
  HIDWORD(v8) = v14;
  *(void *)&long long v9 = a3;
  *((void *)&v9 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v13 | 1;
  *(void *)&long long v10 = a3 + 56;
  *((void *)&v10 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v12;
  *(_OWORD *)a1 = v8;
  *(void *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 48) = v10;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 16) = v9;
  dispatch_kevent_debug(_dispatch_workloop_actions[a2], a1, 0, 0, (uint64_t)"_dispatch_kq_fill_workloop_event", 0x5CDu);
}

uint64_t _dispatch_kq_poll(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  int v17 = a3;
  uint64_t v16 = a4;
  int v15 = a5;
  uint64_t v14 = a6;
  uint64_t v13 = a7;
  int v12 = a8;
  char v11 = 0;
  uint64_t v23 = &_dispatch_kq_poll_pred;
  uint64_t v22 = &v11;
  dispatch_function_t v21 = (dispatch_function_t)_dispatch_kq_init;
  if (_dispatch_kq_poll_pred != -1) {
    dispatch_once_f(v23, v22, v21);
  }
  if (v11)
  {
    _dispatch_memorypressure_init();
    _voucher_activity_debug_channel_init();
  }
  while (2)
  {
    if (!v19)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid wlh";
      qword_F42C0 = 0;
      __break(1u);
      JUMPOUT(0x924B4);
    }
    if (v19 == -4)
    {
      _dispatch_kq_fd();
      if (_dispatch_kevent_workqueue_enabled) {
        v12 |= 0x20u;
      }
      unsigned int v10 = kevent_qos();
    }
    else
    {
      v12 |= 0x400u;
      if ((v12 & 2) == 0) {
        v12 |= 0x20000u;
      }
      unsigned int v10 = kevent_id();
    }
    if (v10 == -1)
    {
      uint64_t v24 = 1;
      uint64_t v25 = 1;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v9 = **(_DWORD **)(StatusReg + 8);
      switch(v9)
      {
        case 2:
          if ((v12 & 2) == 0 || (v12 & 0x20000) == 0) {
            goto LABEL_21;
          }
          unsigned int v20 = 0;
          break;
        case 4:
          continue;
        case 9:
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Do not close random Unix descriptors";
          qword_F42C0 = v9;
          __break(1u);
          JUMPOUT(0x92658);
        case 12:
          _dispatch_temporary_resource_shortage();
          continue;
        default:
LABEL_21:
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected error from kevent";
          qword_F42C0 = v9;
          __break(1u);
          JUMPOUT(0x926C4);
      }
    }
    else
    {
      return v10;
    }
    return v20;
  }
}

void _dispatch_event_loop_leave_deferred(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = 0;
  if ((a2 & 0x2000000000) != 0) {
    BOOL v8 = (a2 & 0x800000000) != 0;
  }
  if (v8)
  {
    if ((a2 & 0xFFFFFFFC) != 0) {
      int v17 = a2 | 3;
    }
    else {
      int v17 = 0;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    for (int i = 0;
          i < *(unsigned __int16 *)(a1 + 40)
       && (*(__int16 *)(v15 + 72 * i + 8) != -17
        || *(void *)(v15 + 72 * i) != *(void *)(a1 + 24)
        || *(void *)(v15 + 72 * i + 16) != v17);
    if (i == *(unsigned __int16 *)(a1 + 40))
    {
      if (i >= 16) {
        _dispatch_abort(2028, i < 16, a3, a4, a5, a6, a7, a8);
      }
      ++*(_WORD *)(a1 + 40);
    }
    if ((a2 & 0xFFFFFFFC) != 0) {
      unsigned int v18 = a2 | 3;
    }
    else {
      unsigned int v18 = 0;
    }
    _dispatch_kq_fill_workloop_sync_event(*(void *)(a1 + 32) + 72 * i, 7, *(void *)(a1 + 24), a2, v18, a6, a7, a8);
  }
  if ((a2 & 0x2000000000) == 0) {
    _dispatch_abort(1659, 0, a3, a4, a5, a6, a7, a8);
  }
  if (a2)
  {
    if ((a2 & 0xFFFFFFFC) != 0) {
      int v16 = 2;
    }
    else {
      int v16 = 0;
    }
  }
  else
  {
    int v16 = 3;
  }
  if ((*(unsigned char *)(a1 + 45) & 1) == 0) {
    _dispatch_abort(2037, 0, a3, a4, a5, a6, a7, a8);
  }
  *(unsigned char *)(a1 + 45) &= ~1u;
  *(unsigned char *)(a1 + 45) &= ~2u;
  uint64_t v11 = *(void *)(a1 + 24);
  uint64_t v13 = *(void *)(a1 + 32);
  for (int j = 0;
        j < *(unsigned __int16 *)(a1 + 40)
     && (*(__int16 *)(v13 + 72 * j + 8) != -17
      || *(void *)(v13 + 72 * j) != *(void *)(a1 + 24)
      || *(void *)(v13 + 72 * j + 16) != *(void *)(a1 + 24));
  if (j == *(unsigned __int16 *)(a1 + 40))
  {
    if (j >= 16) {
      _dispatch_abort(1496, j < 16, a3, a4, a5, a6, a7, a8);
    }
    ++*(_WORD *)(a1 + 40);
  }
  _dispatch_kq_fill_workloop_event(*(void *)(a1 + 32) + 72 * j, v16, v11, a2, a5, a6, a7, a8);
}

void _dispatch_kq_fill_workloop_sync_event(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v20 = a5;
  unsigned int v18 = 0;
  uint64_t v16 = 0;
  switch(a2)
  {
    case 7:
      LOBYTE(v1_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
      if ((a4 & 0x2000000000) != 0) {
        int v11 = (BYTE4(a4) >> 3) & 1;
      }
      if ((v11 & 1) == 0) {
        _dispatch_abort(1516, v11 & 1, a3, a4, a5, a6, a7, a8);
      }
      if (((a4 >> 1) & 1) == 0) {
        _dispatch_abort(1517, 0, a3, a4, a5, a6, a7, a8);
      }
      __int16 v15 = 9;
      unsigned int v17 = 392;
      uint64_t v16 = 0x3800000002;
      break;
    case 8:
      __int16 v15 = 9;
      unsigned int v17 = 4;
      unsigned int v18 = _dispatch_thread_getspecific(4uLL);
      unsigned int v8 = (*(void *)&v18 & 0x3FFF00uLL) >> 8;
      unsigned int v9 = __clz(__rbit32(v8));
      if (v8) {
        unsigned int v10 = v9 + 1;
      }
      else {
        unsigned int v10 = 0;
      }
      if (!v10) {
        unsigned int v18 = 2303;
      }
      break;
    case 9:
      if (((a4 ^ a5) & 0xFFFFFFFC) != 0) {
        _dispatch_abort(1540, ((a4 ^ a5) & 0xFFFFFFFC) == 0, a3, a4, a5, a6, a7, a8);
      }
      __int16 v15 = 9;
      unsigned int v17 = 136;
      break;
    case 10:
      __int16 v15 = 9;
      unsigned int v17 = 8;
      break;
    case 11:
      __int16 v15 = 6;
      unsigned int v17 = 40;
      break;
    default:
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid transition";
      qword_F42C0 = a2;
      __break(1u);
      JUMPOUT(0x92FECLL);
  }
  *(void *)&long long v12 = v20;
  WORD4(v12) = -17;
  WORD5(v12) = v15;
  HIDWORD(v12) = v18;
  *(void *)&long long v13 = a3;
  *((void *)&v13 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v17;
  *(void *)&long long v14 = 0;
  *((void *)&v14 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v16;
  *(_OWORD *)a1 = v12;
  *(void *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 48) = v14;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 16) = v13;
  if ((v17 & 0x80) != 0) {
    *(void *)(a1 + 48) = a3 + 56;
  }
  dispatch_kevent_debug(_dispatch_workloop_actions[a2], a1, 0, 0, (uint64_t)"_dispatch_kq_fill_workloop_sync_event", 0x620u);
}

uint64_t _dispatch_event_loop_cancel_waiter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = a1;
  uint64_t v21 = 0;
  uint64_t v21 = *(void *)(a1 + 48);
  int v20 = 3;
  uint64_t v19 = 0;
  long long v18 = 0u;
  long long v17 = 0u;
  memset(v16, 0, sizeof(v16));
  while (1)
  {
    _dispatch_kq_fill_workloop_sync_event((uint64_t)v16, 11, v21, 0, *(unsigned int *)(v22 + 100), a6, a7, a8);
    uint64_t result = _dispatch_kq_poll(v21, (uint64_t)v16, 1, (uint64_t)v16, 1, 0, 0, v20);
    if (!result) {
      return result;
    }
    BOOL v9 = ((*(unsigned __int8 *)(v22 + 106) >> 5) & 1) == 0;
    unint64_t v30 = v16;
    BOOL v29 = v9;
    unsigned int v28 = v17;
    dispatch_kevent_debug("received error", (uint64_t)v16, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    uint64_t v33 = *((_WORD *)v30 + 5) & 0x4000;
    uint64_t v32 = 1582;
    if (!v33) {
      _dispatch_abort(v32, 0, v10, v11, v12, v13, v14, v15);
    }
    *((_WORD *)v30 + 5) &= ~0x4000u;
    *((_DWORD *)v30 + 7) = v28;
    *((void *)v30 + 4) = 0;
    switch(v28)
    {
      case 2u:
        if (!v29
          || (*((_WORD *)v30 + 5) & 2) == 0
          || (*((unsigned char *)v30 + 24) & 8) == 0
          || (*((unsigned char *)v30 + 24) & 0x20) == 0)
        {
          unint64_t v27 = 0;
          unint64_t v27 = (unint64_t)*((unsigned int *)v30 + 6) << 32;
          v27 |= *((unsigned __int16 *)v30 + 5) << 16;
          v27 |= v28;
          unint64_t v26 = v27;
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_F42C0 = v27;
          __break(1u);
          JUMPOUT(0x93388);
        }
        int v31 = 2;
        break;
      case 4u:
        if (!(v29 & 4) || (*((unsigned char *)v30 + 24) & 4) == 0) {
          goto LABEL_29;
        }
        int v31 = 4;
        break;
      case 0x22u:
        uint64_t v25 = 0;
        uint64_t v25 = *((int *)v30 + 3);
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_F42C0 = v25;
        __break(1u);
        JUMPOUT(0x93414);
      case 0x46u:
        if (!(v29 & 2) || (*((unsigned char *)v30 + 25) & 1) != 0 || !*((void *)v30 + 6) || !*((void *)v30 + 7)) {
          goto LABEL_29;
        }
        int v31 = 70;
        break;
      case 0x69u:
        uint64_t v24 = 0;
        uint64_t v24 = *((void *)v30 + 8);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_F42C0 = v24;
        __break(1u);
        JUMPOUT(0x93454);
      default:
LABEL_29:
        uint64_t v23 = (int)v28;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = (int)v28;
        __break(1u);
        JUMPOUT(0x93494);
    }
    thread_switch(*(_DWORD *)(v22 + 100), 4, 1u);
  }
}

void _dispatch_event_loop_wake_owner(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v47 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v46 = *(void *)(a1 + 48);
  int v44 = 0;
  if (((a4 ^ *(_DWORD *)(a1 + 100)) & 0xFFFFFFFC) != 0) {
    _dispatch_abort(2105, 0, v4, v5, v6, v7, v8, v9);
  }
  if ((*(unsigned __int8 *)(a1 + 106) >> 3)) {
    _dispatch_abort(2106, 0, v4, v5, v6, v7, v8, v9);
  }
  if (a2 == -4 || !v47 || v47[3] != a2) {
    goto LABEL_41;
  }
  if ((*((unsigned char *)v47 + 45) & 1) == 0) {
    _dispatch_abort(2109, 0, v4, v5, v6, v7, v8, v9);
  }
  *((unsigned char *)v47 + 45) &= ~1u;
  *((unsigned char *)v47 + 45) &= ~2u;
  if (a2 == v46)
  {
    if ((a3 & 1) == 0) {
      _dispatch_abort(2114, 0, v4, v5, v6, v7, v8, v9);
    }
    if ((a3 & 2) != 0) {
      _dispatch_abort(2115, 0, v4, v5, v6, v7, v8, v9);
    }
    if ((a4 & 2) != 0) {
      _dispatch_abort(2116, (a4 & 2) == 0, v4, v5, v6, v7, v8, v9);
    }
    if (a4) {
      int v45 = 2;
    }
    else {
      int v45 = 5;
    }
    uint64_t v54 = v47[4];
    for (int i = 0;
          i < *((unsigned __int16 *)v47 + 20)
       && (*(__int16 *)(v54 + 72 * i + 8) != -17
        || *(void *)(v54 + 72 * i) != a2
        || *(void *)(v54 + 72 * i + 16) != a2);
    if (i == *((unsigned __int16 *)v47 + 20))
    {
      if (i >= 16) {
        _dispatch_abort(1496, 0, v4, v5, v6, v7, v8, v9);
      }
      ++*((_WORD *)v47 + 20);
    }
    _dispatch_kq_fill_workloop_event(v47[4] + 72 * i, v45, a2, a4, v6, v7, v8, v9);
    uint64_t v56 = v47[4];
    for (int j = 0;
          j < *((unsigned __int16 *)v47 + 20)
       && (*(__int16 *)(v56 + 72 * j + 8) != -17
        || *(void *)(v56 + 72 * j) != a2
        || *(void *)(v56 + 72 * j + 16) != *(_DWORD *)(a1 + 100));
    if (j == *((unsigned __int16 *)v47 + 20))
    {
      if (j >= 16) {
        _dispatch_abort(2128, j < 16, v10, v11, v12, v13, v14, v15);
      }
      ++*((_WORD *)v47 + 20);
    }
    _dispatch_kq_fill_workloop_sync_event(v47[4] + 72 * j, 9, a2, a4, *(unsigned int *)(a1 + 100), v13, v14, v15);
  }
  else
  {
LABEL_41:
    if ((a3 ^ a4))
    {
      if ((a3 & 1) == 0) {
        _dispatch_abort(2138, 0, v4, v5, v6, v7, v8, v9);
      }
      if ((a4 & 2) != 0) {
        _dispatch_abort(2139, (a4 & 2) == 0, v4, v5, v6, v7, v8, v9);
      }
      int v44 = 1;
      _dispatch_kq_fill_workloop_event((uint64_t)v57, 5, a2, a4, v6, v7, v8, v9);
    }
    if ((a4 & 0x2000000000) != 0)
    {
      int v16 = v44++;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)&v57[72 * v16], 9, a2, a4, *(unsigned int *)(a1 + 100), v7, v8, v9);
    }
    if ((*(unsigned char *)(a1 + 106) & 0x80) == 0 && (a3 & 0x2000000000) != 0 && (a3 & 2) == 0)
    {
      unsigned int v43 = _dispatch_thread_getspecific(3uLL);
      int v17 = v44++;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)&v57[72 * v17], 11, a2, a3, v43, v18, v19, v20);
    }
    if (_dispatch_kq_poll(a2, (uint64_t)v57, v44, (uint64_t)v57, v44, 0, 0, 3))
    {
      BOOL v42 = 0;
      if (v46 != -4) {
        BOOL v42 = v46 != a2;
      }
      if (v42) {
        _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy with a dispatch_sync in flight", v21, v22, v23, v24, v25, v26, v27);
      }
      int v52 = v62;
      dispatch_kevent_debug("received error", (uint64_t)v57, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
      if ((v58 & 0x4000) == 0) {
        _dispatch_abort(1582, 0, v28, v29, v30, v31, v32, v33);
      }
      v58 &= ~0x4000u;
      int v61 = v52;
      uint64_t v62 = 0;
      if (v52 != 2)
      {
        if (v52 != 4)
        {
          if (v52 == 34)
          {
            qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
            qword_F42C0 = v59;
            __break(1u);
            JUMPOUT(0x93FD0);
          }
          if (v52 == 105)
          {
            qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
            qword_F42C0 = v63;
            __break(1u);
            JUMPOUT(0x94014);
          }
        }
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = v52;
        __break(1u);
        JUMPOUT(0x94058);
      }
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
      qword_F42C0 = ((unint64_t)v60 << 32) | (v58 << 16) | 2;
      __break(1u);
      JUMPOUT(0x93F34);
    }
    BOOL v41 = 0;
    if (v46 != -4) {
      BOOL v41 = v46 != a2;
    }
    if (v41)
    {
      _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy with a dispatch_sync in flight", v21, v22, v23, v24, v25, v26, v27);
      _dispatch_event_loop_cancel_waiter(a1, v34, v35, v36, v37, v38, v39, v40);
    }
  }
}

void _dispatch_event_loop_wait_for_ownership(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v25 = *(void *)(a1 + 48);
  int v21 = 0;
  unint64_t v24 = *(void *)(v25 + 56);
  if ((v24 & 0xFFFFFFFC) != 0 || (v24 & 1) == 0)
  {
    LOBYTE(v19) = 0;
    if ((v24 & 0x2000000000) != 0) {
      int v19 = (BYTE4(v24) >> 3) & 1;
    }
    if (v19)
    {
      int v21 = 1;
      if ((v24 & 0xFFFFFFFC) != 0) {
        unsigned int v31 = v24 | 3;
      }
      else {
        unsigned int v31 = 0;
      }
      _dispatch_kq_fill_workloop_sync_event((uint64_t)v32, 7, v25, v24, v31, a6, a7, a8);
    }
  }
  else
  {
    int v21 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 0, v25, v24, a5, a6, a7, a8);
  }
  while (1)
  {
    _dispatch_kq_fill_workloop_sync_event((uint64_t)&v32[9 * v21], 8, v25, v24, *(unsigned int *)(a1 + 100), a6, a7, a8);
    int v22 = _dispatch_kq_poll(v25, (uint64_t)v32, v21 + 1, (uint64_t)v32, v21 + 1, 0, 0, 3);
    for (int i = 0; i < v22; ++i)
    {
      char v20 = 0;
      if ((v32[9 * i + 3] & 4) != 0) {
        char v20 = 4;
      }
      uint64_t v28 = &v32[9 * i];
      int v27 = v28[4];
      dispatch_kevent_debug("received error", (uint64_t)v28, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
      if ((*((_WORD *)v28 + 5) & 0x4000) == 0) {
        _dispatch_abort(1582, 0, v9, v10, v11, v12, v13, v14);
      }
      *((_WORD *)v28 + 5) &= ~0x4000u;
      *((_DWORD *)v28 + 7) = v27;
      v28[4] = 0;
      if (v27 == 2)
      {
        unint64_t v15 = ((unint64_t)*((unsigned int *)v28 + 6) << 32) | (*((unsigned __int16 *)v28 + 5) << 16) | 2;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = v15;
        __break(1u);
        JUMPOUT(0x94564);
      }
      if (v27 != 4)
      {
        if (v27 == 34)
        {
          uint64_t v16 = *((int *)v28 + 3);
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
          qword_F42C0 = v16;
          __break(1u);
          JUMPOUT(0x945F0);
        }
        if (v27 == 105)
        {
          uint64_t v17 = v28[8];
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
          qword_F42C0 = v17;
          __break(1u);
          JUMPOUT(0x94630);
        }
LABEL_28:
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = v27;
        __break(1u);
        JUMPOUT(0x94670);
      }
      if ((v20 & 4) == 0 || (v28[3] & 4) == 0) {
        goto LABEL_28;
      }
    }
    if (!v22) {
      break;
    }
    LOBYTE(v18) = 0;
    if (v22 == 1) {
      int v18 = (v33 >> 2) & 1;
    }
    if ((v18 & 1) == 0) {
      _dispatch_abort(2245, v18 & 1, v9, v10, v11, v12, v13, v14);
    }
    dispatch_kevent_debug("restarting", (uint64_t)v32, 0, 0, (uint64_t)"_dispatch_event_loop_wait_for_ownership", 0x8C6u);
    unint64_t v24 = v34;
    int v21 = 0;
  }
  if ((*(unsigned char *)(a1 + 106) & 0x20) != 0)
  {
    _dispatch_event_loop_cancel_waiter(a1, v8, v9, v10, v11, v12, v13, v14);
    *(unsigned char *)(a1 + 106) &= ~0x20u;
  }
  if ((*(unsigned char *)(a1 + 106) & 0x40) != 0)
  {
    uint64_t v30 = *(void *)(a1 + 48);
    signed int v29 = atomic_fetch_add_explicit((atomic_uint *volatile)(v30 + 96), 0xFFFFFFFF, memory_order_relaxed) - 1;
    if (v29 < 0)
    {
      if (v29 <= -2)
      {
        qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x94840);
      }
      *(void *)(v30 + 56) = 0xDEAD000000000000;
      _dispatch_object_dealloc((void *)v30);
    }
  }
}

void dispatch_kevent_debug(const char *a1, uint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  uint64_t v28 = a1;
  uint64_t v27 = a2;
  int v26 = a3;
  int v25 = a4;
  uint64_t v24 = a5;
  unsigned int v23 = a6;
  if (a4 <= 1) {
    v29[0] = 0;
  }
  else {
    __snprintf_chk(v29, 0x1FuLL, 0, 0x1FuLL, "%d/%d ", v26 + 1, v25);
  }
  if (!v28)
  {
    if ((*(_WORD *)(v27 + 10) & 2) != 0)
    {
      uint64_t v28 = "deleting";
    }
    else if (*(_WORD *)(v27 + 10))
    {
      uint64_t v28 = "adding";
    }
    else
    {
      uint64_t v28 = "updating";
    }
  }
  uint64_t v17 = _dispatch_thread_getspecific(0);
  int v18 = v28;
  uint64_t v19 = v27;
  uint64_t v20 = *(void *)v27;
  int v21 = _evfiltstr(*(_WORD *)(v27 + 8));
  uint64_t v6 = _evflagstr(*(_WORD *)(v27 + 10), v30);
  uint64_t v7 = *(unsigned __int16 *)(v27 + 10);
  uint64_t v8 = *(unsigned int *)(v27 + 24);
  uint64_t v9 = *(void *)(v27 + 32);
  uint64_t v10 = *(void *)(v27 + 16);
  uint64_t v11 = *(unsigned int *)(v27 + 12);
  uint64_t v12 = *(void *)(v27 + 40);
  uint64_t v13 = *(void *)(v27 + 48);
  uint64_t v14 = *(void *)(v27 + 56);
  uint64_t v15 = *(void *)(v27 + 64);
  int v22 = v16;
  v16[1] = v17;
  _OWORD v16[2] = v28;
  v16[3] = v27;
  v16[4] = v29;
  v16[5] = v20;
  v16[6] = v21;
  v16[7] = v6;
  v16[8] = v7;
  v16[9] = v8;
  v16[10] = v9;
  v16[11] = v10;
  v16[12] = v11;
  v16[13] = v12;
  v16[14] = v13;
  v16[15] = v14;
  v16[16] = v15;
  v16[17] = v24;
  v16[18] = v23;
  _dispatch_log("%u\t%p\t%s kevent[%p] %s= { ident = 0x%llx, filter = %s, flags = %s (0x%x), fflags = 0x%x, uintptr_t data = 0x%llx, uuintptr_t data = 0x%llx, qos = 0x%x, ext[0] = 0x%llx, ext[1] = 0x%llx, ext[2] = 0x%llx, ext[3] = 0x%llx }: %s #%u", v7, v7, (uint64_t)v21, v20, (uint64_t)v29, (uint64_t)v28, (uint64_t)v17, 203);
}

void _dispatch_event_loop_ensure_ownership(uint64_t a1)
{
  uint64_t v16 = a1;
  unsigned int v15 = 3;
  unsigned int v14 = _dispatch_thread_getspecific(3uLL);
  uint64_t v13 = 0;
  long long v12 = 0u;
  long long v11 = 0u;
  memset(v10, 0, sizeof(v10));
  _dispatch_kq_fill_workloop_sync_event((uint64_t)v10, 9, v16, v14, v14, v1, v2, v3);
  if (_dispatch_kq_poll(v16, v10, 1, v10, 1, 0, 0, v15))
  {
    uint64_t v24 = v10;
    uint64_t v23 = 0;
    unsigned int v22 = v11;
    dispatch_kevent_debug("received error", (uint64_t)v10, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    uint64_t v27 = *((_WORD *)v24 + 5) & 0x4000;
    uint64_t v26 = 1582;
    if (!v27) {
      _dispatch_abort(v26, 0, v4, v5, v6, v7, v8, v9);
    }
    *((_WORD *)v24 + 5) &= ~0x4000u;
    *((_DWORD *)v24 + 7) = v22;
    *((void *)v24 + 4) = 0;
    switch(v22)
    {
      case 2u:
        if ((v23 & 1) == 0
          || (*((_WORD *)v24 + 5) & 2) == 0
          || (*((unsigned char *)v24 + 24) & 8) == 0
          || (*((unsigned char *)v24 + 24) & 0x20) == 0)
        {
          unint64_t v21 = 0;
          unint64_t v21 = (unint64_t)*((unsigned int *)v24 + 6) << 32;
          v21 |= *((unsigned __int16 *)v24 + 5) << 16;
          v21 |= v22;
          unint64_t v20 = v21;
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_F42C0 = v21;
          __break(1u);
          JUMPOUT(0x94DA4);
        }
        int v25 = 2;
        break;
      case 4u:
        if ((v23 & 4) == 0 || (*((unsigned char *)v24 + 24) & 4) == 0) {
          goto LABEL_28;
        }
        int v25 = 4;
        break;
      case 0x22u:
        uint64_t v19 = 0;
        uint64_t v19 = *((int *)v24 + 3);
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_F42C0 = v19;
        __break(1u);
        JUMPOUT(0x94E30);
      case 0x46u:
        if ((v23 & 2) == 0 || (*((unsigned char *)v24 + 25) & 1) != 0 || !*((void *)v24 + 6) || !*((void *)v24 + 7)) {
          goto LABEL_28;
        }
        int v25 = 70;
        break;
      case 0x69u:
        uint64_t v18 = 0;
        uint64_t v18 = *((void *)v24 + 8);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_F42C0 = v18;
        __break(1u);
        JUMPOUT(0x94E70);
      default:
LABEL_28:
        uint64_t v17 = (int)v22;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = (int)v22;
        __break(1u);
        JUMPOUT(0x94EB0);
    }
    __break(1u);
  }
}

void _dispatch_event_loop_end_ownership(uint64_t a1, char a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v27 = a4;
  unsigned int v26 = 0;
  if (((a3 >> 37) & 1) == 0) {
    _dispatch_abort(2289, 0, a3, a4, a5, a6, a7, a8);
  }
  if (a3)
  {
    unsigned int v26 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 1, a1, a3, a5, a6, a7, a8);
  }
  else if (a2)
  {
    if ((a3 & 0xFF80000000000000) == 0) {
      _dispatch_abort(2294, (a3 & 0xFF80000000000000) != 0, a3, a4, a5, a6, a7, a8);
    }
    unsigned int v26 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 4, a1, a3, a5, a6, a7, a8);
  }
  if ((a2 & 2) == 0)
  {
    unsigned int v25 = _dispatch_thread_getspecific(3uLL);
    unsigned int v8 = v26++;
    _dispatch_kq_fill_workloop_sync_event((uint64_t)&v32[72 * v8], 11, a1, a3, v25, v9, v10, v11);
  }
  if (_dispatch_kq_poll(a1, v32, v26, v32, v26, 0, 0, 3))
  {
    int v31 = v37;
    dispatch_kevent_debug("received error", (uint64_t)v32, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    if ((v33 & 0x4000) == 0) {
      _dispatch_abort(1582, 0, v12, v13, v14, v15, v16, v17);
    }
    v33 &= ~0x4000u;
    int v36 = v31;
    uint64_t v37 = 0;
    if (v31 != 2)
    {
      if (v31 != 4)
      {
        if (v31 == 34)
        {
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
          qword_F42C0 = v34;
          __break(1u);
          JUMPOUT(0x95320);
        }
        if (v31 == 105)
        {
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
          qword_F42C0 = v38;
          __break(1u);
          JUMPOUT(0x95360);
        }
      }
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
      qword_F42C0 = v31;
      __break(1u);
      JUMPOUT(0x953A0);
    }
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
    qword_F42C0 = ((unint64_t)v35 << 32) | (v33 << 16) | 2;
    __break(1u);
    JUMPOUT(0x95294);
  }
  _dispatch_event_loop_assert_not_owned(a1);
  int v24 = 2 * (v27 & 1);
  if (a2) {
    ++v24;
  }
  if (a3) {
    --v24;
  }
  if (v24 < 0) {
    _dispatch_abort(2315, v24 >= 0, v18, v19, v20, v21, v22, v23);
  }
  if (v24 >= 1) {
    _dispatch_release_n(a1, v24);
  }
}

uint64_t _dispatch_event_loop_assert_not_owned(uint64_t result)
{
  uint64_t v8 = result;
  if (result != -4)
  {
    memset(__b, 0, sizeof(__b));
    uint64_t result = _dispatch_kevent_workloop_get_info(v8, __b);
    if (result)
    {
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      BOOL v10 = __b[5] != *(void *)(StatusReg - 8);
      uint64_t v9 = 2330;
      if (!v10) {
        _dispatch_abort(v9, 0, v1, v2, v3, v4, v5, v6);
      }
    }
  }
  return result;
}

BOOL _dispatch_kevent_workloop_get_info(uint64_t a1, _WORD *a2)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  unsigned int v12 = 131075;
  memset(__b, 0, sizeof(__b));
  __b[4] = -17;
  void __b[5] = 5;
  memcpy(a2, __b, 0x48uLL);
  if (_dispatch_kq_poll(v14, v13, 1, v13, 1, 0, 0, v12))
  {
    uint64_t v17 = v13[5] & 0x4000;
    uint64_t v16 = 1375;
    if (!v17) {
      _dispatch_abort(v16, 0, v2, v3, v4, v5, v6, v7);
    }
    return *((void *)v13 + 4) == 16;
  }
  else
  {
    memset(v10, 0, sizeof(v10));
    WORD1(v10[1]) = 0x4000;
    v10[4] = 2;
    memcpy(v13, v10, 0x48uLL);
    return 1;
  }
}

void _dispatch_event_loop_timer_arm(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v7 = a2 / 3;
  unsigned int v12 = a2 / 3;
  if (!*(void *)(a5 + 8 * (a2 / 3)))
  {
    mach_get_times();
    *(void *)(a5 + 16) = 0;
  }
  uint64_t v6 = a3 + *(void *)(a5 + 8 * v12);
  if (_dispatch_timers_force_max_leeway)
  {
    v6 += a4;
    a4 = 0;
  }
  _dispatch_event_loop_timer_program(a1, a2, v6, a4, 5);
  if (v7 == 2 && _dispatch_mach_calendar_pred != -1) {
    dispatch_once_f(&_dispatch_mach_calendar_pred, 0, (dispatch_function_t)_dispatch_mach_host_notify_update);
  }
}

void _dispatch_event_loop_timer_program(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  uint64_t v12 = a1;
  unsigned int v11 = a2;
  uint64_t v10 = a3;
  uint64_t v9 = a4;
  __int16 v8 = a5;
  unsigned int v7 = _dispatch_thread_getspecific(0x1BuLL);
  uint64_t v6 = 0x2000000;
  if (v7 != (void *)-4)
  {
    int v14 = *(unsigned __int8 *)(v12 + 32 * v11 + 5);
    uint64_t v13 = 0;
    if (v14) {
      uint64_t v13 = 1 << (v14 + 7);
    }
    uint64_t v6 = v13 | 0xFF;
  }
  memset(__b, 0, sizeof(__b));
  __b[0] = v11 | 0xFFFFFFFFFFFFFF00;
  LOWORD(__b[1]) = -7;
  WORD1(__b[1]) = v8 | 0x10;
  HIDWORD(__b[1]) = v6;
  __b[2] = v12;
  __b[3] = _dispatch_timer_index_to_fflags[v11];
  __b[4] = v10;
  void __b[5] = 0;
  *(_OWORD *)&__b[7] = 0u;
  void __b[6] = v9;
  _dispatch_kq_deferred_update((uint64_t)v7, (__int16 *)__b);
}

void _dispatch_event_loop_timer_delete(uint64_t a1, unsigned int a2)
{
}

uint64_t _dispatch_source_proc_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = a3;
  uint64_t v5 = _dispatch_unote_create_with_handle(a1, a2, a3);
  if (v5 && (v4 & 0x4000000) != 0) {
    *(unsigned char *)(v5 + 29) = *(unsigned char *)(v5 + 29) & 0xFB | 4;
  }
  return v5;
}

uint64_t _dispatch_source_vm_create(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = off_ED230((uint64_t)&_dispatch_source_type_memorystatus, a2, 2);
  if (v3) {
    *(unsigned char *)(v3 + 29) = *(unsigned char *)(v3 + 29) & 0xEF | 0x10;
  }
  return v3;
}

BOOL _dispatch_mach_msg_sender_is_kernel(uint64_t a1)
{
  uint64_t audit_trailer = _dispatch_mach_msg_get_audit_trailer(a1);
  if (!audit_trailer)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: message received without expected trailer";
    __break(1u);
    JUMPOUT(0x95B60);
  }
  return *(_DWORD *)(audit_trailer + 40) == 0;
}

uint64_t _dispatch_mach_msg_get_audit_trailer(uint64_t a1)
{
  uint64_t v2 = 0;
  uint64_t v3 = (_DWORD *)(a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0xFFFFFFFFFFFFFFFCLL));
  if (!*v3 && v3[1] >= 0x34uLL) {
    return a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  }
  return v2;
}

uint64_t _dispatch_get_mach_host_port()
{
  if (_dispatch_mach_host_port_pred != -1) {
    dispatch_once_f(&_dispatch_mach_host_port_pred, 0, (dispatch_function_t)_dispatch_mach_host_port_init);
  }
  return _dispatch_mach_host_port;
}

void _dispatch_mach_host_port_init(uint64_t a1)
{
  kern_return_t special_port;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  uint64_t v10 = a1;
  special_mach_port_t port = 0;
  mach_port_t port = 0;
  mach_port_t v7 = mach_host_self();
  special_mach_port_t port = host_get_special_port(v7, -1, 1, &port);
  if (special_port == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x95D10);
  }
  if (special_port)
  {
    if (special_port != 4)
    {
      uint64_t v12 = special_port;
      unsigned int v11 = 2859;
      _dispatch_bug(2859, special_port, v1, v2, v3, v4, v5, v6);
    }
  }
  else
  {
    special_mach_port_t port = mach_port_deallocate(mach_task_self_, v7);
    if (special_port == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x95D88);
    }
    mach_port_t v7 = port;
  }
  if (!v7)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not get unprivileged host port";
    qword_F42C0 = special_port;
    __break(1u);
    JUMPOUT(0x95E40);
  }
  _dispatch_mach_host_mach_port_t port = v7;
}

uint64_t _dispatch_mach_notify_port_deleted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v14 = a2;
  _dispatch_log("Corruption: Mach send/send-once/dead-name right 0x%x deleted prematurely", a2, a3, a4, a5, a6, a7, a8, a2);
  _dispatch_mach_notify_merge(v14, 4, 1, v8, v9, v10, v11, v12);
  return 0;
}

uint64_t _dispatch_mach_notify_merge(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v23 = a3 & 1;
  uint64_t v21 = 0;
  unsigned int v20 = 4;
  for (uint64_t i = _dispatch_sources[((unint64_t)result >> 8) & 0x3F];
        i && (*(void *)(i + 24) != result || *(__int16 *)(i + 32) != -24);
  if (i)
  {
    *(void *)(i + 56) &= 0xFFFFFFFFFFFFFFF2;
    if ((a3 & 1) != 0
      || (uint64_t result = _dispatch_kevent_mach_notify_resume(i, a2, 0, a4, a5, a6, a7, a8), (result & 1) == 0))
    {
      unsigned int v20 = 16;
      *(_WORD *)(i + 34) |= 2u;
    }
    *(void *)(i + 64) = 0;
    for (int j = *(uint64_t **)(i + 16); ; int j = v21)
    {
      char v17 = 0;
      if (j)
      {
        uint64_t v21 = (uint64_t *)*j;
        char v17 = 1;
      }
      if ((v17 & 1) == 0) {
        break;
      }
      if (*(void *)(i + 64))
      {
        if (((v23 ^ 1) & 1) == 0) {
          _dispatch_abort(3026, (v23 ^ 1) & 1, a3, a4, a5, a6, a7, a8);
        }
        return result;
      }
      uint64_t v19 = j + 3;
      unsigned int v18 = a2 & j[7];
      *((unsigned char *)j + 54) = 0;
      if ((v23 & 1) != 0 || v18)
      {
        _dispatch_retain_2(~j[4]);
        if (v23) {
          _dispatch_unote_unregister_muxed(v19, v8, v9, v10, v11, v12, v13, v14);
        }
        if (v18)
        {
          uint64_t v16 = 0;
          if (*v19) {
            uint64_t v16 = *v19;
          }
          if (*(unsigned char *)(v16 + 9) == 2) {
            atomic_fetch_or_explicit((atomic_ullong *volatile)(j + 12), v18, memory_order_relaxed);
          }
        }
        uint64_t v15 = 0;
        if (*v19) {
          uint64_t v15 = *v19;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t *, void, void, void))(v15 + 48))(v19, v20, v18, 0);
      }
    }
  }
  return result;
}

uint64_t _dispatch_mach_notify_dead_name(uint64_t a1, mach_port_name_t a2)
{
  uint64_t v15 = a2;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: dead-name notification", v2, v3, v4, v5, v6, v7, v8, 3064);
  _dispatch_mach_notify_merge(v15, 1, 1, v9, v10, v11, v12, v13);
  if (mach_port_deallocate(mach_task_self_, a2) == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x964BCLL);
  }
  return 0;
}

uint64_t _dispatch_mach_notify_send_possible(uint64_t a1, unsigned int a2)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: send-possible notification", v2, v3, v4, v5, v6, v7, v8, 3080);
  _dispatch_mach_notify_merge(a2, 8, 0, v9, v10, v11, v12, v13);
  return 0;
}

void _dispatch_mach_notification_set_armed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 29)) {
    _dispatch_abort(588, (*(unsigned char *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v16 = *(void *)(a1 - 8);
  if (v16)
  {
    *(void *)(v16 + 64) = 1;
    for (uint64_t i = *(uint64_t **)(v16 + 16); i; uint64_t i = (uint64_t *)*i)
      *((unsigned char *)i + 54) = 1;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: send-possible notification armed", v8, v9, v10, v11, v12, v13, v14, 3099);
  }
}

uint64_t _dispatch_source_mach_send_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a2;
  uint64_t v4 = a3;
  if (!a3) {
    uint64_t v4 = 1;
  }
  if (!a2) {
    uint64_t v5 = 0xFFFFFFFFLL;
  }
  return _dispatch_unote_create_with_handle(a1, v5, v4);
}

BOOL _dispatch_mach_send_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 34) & 2) != 0) {
    return _dispatch_kevent_mach_notify_resume(a1, 0, *(unsigned int *)(a1 + 48), a4, a5, a6, a7, a8);
  }
  else {
    return _dispatch_kevent_mach_notify_resume(a1, *(_DWORD *)(a1 + 48), 0, a4, a5, a6, a7, a8);
  }
}

uint64_t _dispatch_mach_send_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = _dispatch_unote_create_without_handle(a1, a2, a3);
  if (v4)
  {
    *(_DWORD *)(v4 + 88) = 0x80000000;
    *(void *)(v4 + 56) = 0;
  }
  return v4;
}

void _dispatch_mach_notification_event(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 24);
  qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected non message event";
  qword_F42C0 = v1;
  __break(1u);
}

void _dispatch_mach_notification_merge_msg(uint64_t a1, int a2, mach_msg_header_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v36 = a1;
  int v35 = a2;
  int v34 = a3;
  int v33 = a4;
  uint64_t v32 = a5;
  uint64_t v31 = a6;
  uint64_t v30 = a7;
  memset(__b, 0, sizeof(__b));
  uint64_t v44 = 1;
  uint64_t v43 = 2786;
  uint64_t v42 = 1;
  uint64_t v41 = 2788;
  if (v34->msgh_id <= 77)
  {
    BOOL is_kernel = _dispatch_mach_msg_sender_is_kernel((uint64_t)v34);
    BOOL v40 = is_kernel;
    uint64_t v39 = 2790;
    if (!is_kernel) {
      _dispatch_bug(v39, 0, v7, v8, v9, v10, v11, v12);
    }
    if (!is_kernel) {
      goto LABEL_18;
    }
  }
  int v27 = libdispatch_internal_protocol_server(v34, (uint64_t)__b);
  if (!v27 && __b[8] == -303 && (v34->msgh_id == 951 || v34->msgh_id == 950))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tcalendar-change notification", v20, v21, v22, v23, v24, v25, v26, 2799);
    _dispatch_timers_calendar_change();
    _dispatch_mach_host_notify_update();
    int v27 = 1;
    __b[8] = 0;
  }
  uint64_t v38 = v27;
  uint64_t v37 = 2805;
  if (v27)
  {
    if (__b[8] != -305)
    {
      uint64_t v46 = __b[8];
      uint64_t v45 = 2806;
      if (__b[8]) {
        _dispatch_bug(v45, v46, v14, v15, v16, v17, v18, v19);
      }
    }
  }
  else
  {
    _dispatch_bug(v37, v38, v14, v15, v16, v17, v18, v19);
  }
  if (!v27 || __b[8] && __b[8] != -305) {
LABEL_18:
  }
    mach_msg_destroy(v34);
  if ((v35 & 0x10000) != 0) {
    free(v34);
  }
  _dispatch_unote_resume(v36, v13, v14, v15, v16, v17, v18, v19);
}

uint64_t _dispatch_mach_recv_direct_merge_evt(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x200) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
    __break(1u);
    JUMPOUT(0x96C58);
  }
  return _dispatch_source_merge_evt(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_mach_reply_merge_evt(uint64_t a1, unsigned int a2, int a3)
{
  if ((a2 & 0x200) != 0)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
  }
  else
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected event";
    qword_F42C0 = a3 | ((unint64_t)a2 << 32);
  }
  __break(1u);
  JUMPOUT(0x96CC4);
}

void sub_96D24()
{
}

void _dispatch_kevent_workloop_override_self(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = a1;
  unint64_t v21 = a2;
  int v20 = a3;
  uint64_t v19 = 0;
  uint64_t v19 = *(void *)(a1 + 24);
  unsigned int v18 = 3;
  uint64_t v17 = 0;
  long long v16 = 0u;
  long long v15 = 0u;
  memset(v14, 0, sizeof(v14));
  uint64_t v24 = *(unsigned char *)(a1 + 45) & 1;
  uint64_t v23 = 1769;
  if (!v24) {
    _dispatch_abort(v23, 0, a3, a4, a5, a6, a7, a8);
  }
  *(unsigned char *)(v22 + 45) &= ~2u;
  _dispatch_kq_fill_workloop_event((uint64_t)v14, 0, v19, v21, a5, a6, a7, a8);
  if (_dispatch_kq_poll(v19, v14, 1, v14, 1, 0, 0, v18))
  {
    uint64_t v32 = v14;
    uint64_t v31 = 0;
    unsigned int v30 = v15;
    dispatch_kevent_debug("received error", (uint64_t)v14, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    uint64_t v35 = *((_WORD *)v32 + 5) & 0x4000;
    uint64_t v34 = 1582;
    if (!v35) {
      _dispatch_abort(v34, 0, v8, v9, v10, v11, v12, v13);
    }
    *((_WORD *)v32 + 5) &= ~0x4000u;
    *((_DWORD *)v32 + 7) = v30;
    *((void *)v32 + 4) = 0;
    switch(v30)
    {
      case 2u:
        if ((v31 & 1) == 0
          || (*((_WORD *)v32 + 5) & 2) == 0
          || (*((unsigned char *)v32 + 24) & 8) == 0
          || (*((unsigned char *)v32 + 24) & 0x20) == 0)
        {
          unint64_t v29 = 0;
          unint64_t v29 = (unint64_t)*((unsigned int *)v32 + 6) << 32;
          v29 |= *((unsigned __int16 *)v32 + 5) << 16;
          v29 |= v30;
          unint64_t v28 = v29;
          qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_F42C0 = v29;
          __break(1u);
          JUMPOUT(0x96FF8);
        }
        int v33 = 2;
        break;
      case 4u:
        if ((v31 & 4) == 0 || (*((unsigned char *)v32 + 24) & 4) == 0) {
          goto LABEL_30;
        }
        int v33 = 4;
        break;
      case 0x22u:
        uint64_t v27 = 0;
        uint64_t v27 = *((int *)v32 + 3);
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_F42C0 = v27;
        __break(1u);
        JUMPOUT(0x97084);
      case 0x46u:
        if ((v31 & 2) == 0 || (*((unsigned char *)v32 + 25) & 1) != 0 || !*((void *)v32 + 6) || !*((void *)v32 + 7)) {
          goto LABEL_30;
        }
        int v33 = 70;
        break;
      case 0x69u:
        uint64_t v26 = 0;
        uint64_t v26 = *((void *)v32 + 8);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_F42C0 = v26;
        __break(1u);
        JUMPOUT(0x970C4);
      default:
LABEL_30:
        uint64_t v25 = (int)v30;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = (int)v30;
        __break(1u);
        JUMPOUT(0x97104);
    }
    __break(1u);
  }
  if (v20) {
    _dispatch_release_2_no_dispose(v19);
  }
}

void _dispatch_kevent_workloop_poke_drain(uint64_t a1)
{
  uint64_t v35 = _dispatch_thread_getspecific(0x1DuLL);
  uint64_t v34 = *(void *)(a1 + 16);
  if ((*(unsigned char *)(a1 + 27) & 0x80) != 0)
  {
    BOOL v32 = 0;
    if ((*(_WORD *)(a1 + 10) & 0x4000) != 0) {
      BOOL v32 = *(void *)(a1 + 32) == 2;
    }
    if (!v32) {
      _dispatch_abort(1679, v32, v1, v2, v3, v4, v5, v6);
    }
    dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x690u);
    return;
  }
  if ((*(_DWORD *)(a1 + 24) & 1) == 0) {
    _dispatch_abort(1684, 0, v1, v2, v3, v4, v5, v6);
  }
  if ((*(_WORD *)(a1 + 10) & 0x4000) != 0)
  {
    unint64_t v33 = *(void *)(a1 + 64);
    int v37 = *(void *)(a1 + 32);
    dispatch_kevent_debug("received error", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    if ((*(_WORD *)(a1 + 10) & 0x4000) == 0) {
      _dispatch_abort(1582, 0, v7, v8, v9, v10, v11, v12);
    }
    *(_WORD *)(a1 + 10) &= ~0x4000u;
    *(_DWORD *)(a1 + 28) = v37;
    *(void *)(a1 + 32) = 0;
    switch(v37)
    {
      case 2:
        unint64_t v13 = ((unint64_t)*(unsigned int *)(a1 + 24) << 32) | (*(unsigned __int16 *)(a1 + 10) << 16) | 2;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = v13;
        __break(1u);
        JUMPOUT(0x97488);
      case 4:
LABEL_26:
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_F42C0 = v37;
        __break(1u);
        JUMPOUT(0x975A8);
      case 34:
        uint64_t v14 = *(int *)(a1 + 12);
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_F42C0 = v14;
        __break(1u);
        JUMPOUT(0x97524);
    }
    if (v37 != 70)
    {
      if (v37 == 105)
      {
        uint64_t v15 = *(void *)(a1 + 64);
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_F42C0 = v15;
        __break(1u);
        JUMPOUT(0x97568);
      }
      goto LABEL_26;
    }
    if ((*(unsigned char *)(a1 + 25) & 1) != 0 || !*(void *)(a1 + 48) || !*(void *)(a1 + 56)) {
      goto LABEL_26;
    }
    if ((v33 & 0x2000000000) != 0)
    {
      if (((v33 >> 37) & 1) == 0) {
        _dispatch_abort(1659, 0, v7, v8, v9, v10, v11, v12);
      }
      if (v33)
      {
        if ((v33 & 0xFFFFFFFC) != 0) {
          int v38 = 2;
        }
        else {
          int v38 = 0;
        }
      }
      else
      {
        int v38 = 3;
      }
      if (v38)
      {
        _dispatch_kq_fill_workloop_event(a1, v38, v34, v33, v9, v10, v11, v12);
        _dispatch_kq_deferred_update(v34, a1);
      }
      else
      {
        dispatch_kevent_debug("retry drain", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6ABu);
        if (v35[1]) {
          _dispatch_abort(1647, 0, v16, v17, v18, v19, v20, v21);
        }
        *((unsigned char *)v35 + 45) |= 1u;
        _dispatch_retain(v34);
        *uint64_t v35 = *(void *)(v34 + 24);
        v35[1] = v34;
        unint64_t v39 = (unint64_t)(*(_DWORD *)(a1 + 12) & 0x3FFF00) >> 8;
        unsigned int v22 = __clz(__rbit32(v39));
        if (v39) {
          unsigned int v23 = v22 + 1;
        }
        else {
          unsigned int v23 = 0;
        }
        *((_DWORD *)v35 + 4) = v23;
      }
    }
    else
    {
      if ((*(_WORD *)(a1 + 10) & 2) != 0) {
        _dispatch_abort(1692, (*(_WORD *)(a1 + 10) & 2) == 0, v7, v8, v9, v10, v11, v12);
      }
      dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6A2u);
    }
  }
  else if (*((unsigned char *)v35 + 45))
  {
    dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6B7u);
  }
  else
  {
    dispatch_kevent_debug("got drain", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6BCu);
    if (v35[1]) {
      _dispatch_abort(1647, 0, v24, v25, v26, v27, v28, v29);
    }
    *((unsigned char *)v35 + 45) |= 1u;
    _dispatch_retain(v34);
    *uint64_t v35 = *(void *)(v34 + 24);
    v35[1] = v34;
    unint64_t v40 = (unint64_t)(*(_DWORD *)(a1 + 12) & 0x3FFF00) >> 8;
    unsigned int v30 = __clz(__rbit32(v40));
    if (v40) {
      unsigned int v31 = v30 + 1;
    }
    else {
      unsigned int v31 = 0;
    }
    *((_DWORD *)v35 + 4) = v31;
  }
}

void _dispatch_kevent_print_error(uint64_t a1)
{
  uint64_t v13 = 0;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkevent[0x%llx]: handling error", v1, v2, v3, v4, v5, v6, v7, 390);
  if ((*(_WORD *)(a1 + 10) & 2) != 0)
  {
    if ((*(_WORD *)(a1 + 10) & 0x100) != 0 && *(void *)(a1 + 32) == 36) {
      return;
    }
  }
  else if (*(unsigned char *)(a1 + 16))
  {
    *(_WORD *)(a1 + 10) |= *(_WORD *)((*(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL) + 34);
  }
  else if (*(void *)(a1 + 16))
  {
    uint64_t v13 = *(void *)(a1 + 16);
    if (!*(void *)(v13 + 16)) {
      *(_WORD *)(a1 + 10) |= 1u;
    }
  }
  if (*(void *)(a1 + 32))
  {
    if (*(void *)(a1 + 32) == 34)
    {
      uint64_t v8 = *(int *)(a1 + 12);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid kevent priority";
      qword_F42C0 = v8;
      __break(1u);
      JUMPOUT(0x97B98);
    }
    uint64_t v9 = _evfiltstr(*(_WORD *)(a1 + 8));
    uint64_t v12 = (uint64_t)v9;
    if (*(void *)(a1 + 16))
    {
      if ((*(_WORD *)(a1 + 10) & 2) != 0)
      {
        _dispatch_bug_kevent_client((uint64_t)"kevent", (uint64_t)v9, (uint64_t)"delete", *(unsigned int *)(a1 + 32), *(void *)a1, *(void *)(a1 + 16), v13, v10);
      }
      else if (*(_WORD *)(a1 + 10))
      {
        _dispatch_bug_kevent_client((uint64_t)"kevent", (uint64_t)v9, (uint64_t)"add", *(unsigned int *)(a1 + 32), *(void *)a1, *(void *)(a1 + 16), v13, v10);
      }
      else
      {
        if ((*(_WORD *)(a1 + 10) & 4) != 0) {
          uint64_t v11 = "enable";
        }
        else {
          uint64_t v11 = "monitor";
        }
        _dispatch_bug_kevent_client((uint64_t)"kevent", v12, (uint64_t)v11, *(unsigned int *)(a1 + 32), *(void *)a1, *(void *)(a1 + 16), v13, v10);
      }
    }
    else
    {
      _dispatch_bug_kevent_client((uint64_t)"kevent", (uint64_t)v9, 0, *(unsigned int *)(a1 + 32), *(void *)a1, *(void *)(a1 + 16), v13, v10);
    }
  }
}

uint64_t _dispatch_kevent_mach_msg_size(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

BOOL _dispatch_kevent_has_machmsg_rcv_error(uint64_t a1)
{
  int v3 = *(_DWORD *)(a1 + 24);
  BOOL v2 = 0;
  if ((v3 & 0xFC000000) == 0x10000000) {
    return ((v3 >> 14) & 0xFFF) == 1;
  }
  return v2;
}

void _dispatch_kevent_mach_msg_drain(uint64_t a1)
{
  uint64_t v68 = a1;
  uint64_t v41 = 0;
  uint64_t v67 = (unsigned int *)_dispatch_kevent_mach_msg_buf(a1);
  int v40 = 0;
  unsigned int v66 = _dispatch_kevent_mach_msg_size(v68);
  *(_DWORD *)&v65[8] = 0;
  *(void *)long long v65 = _dispatch_kevent_mach_msg_aux_size(v68);
  uint64_t v64 = *(unsigned int *)&v65[4];
  uint64_t v75 = v68;
  uint64_t v79 = v68;
  BOOL v9 = (*(void *)(v68 + 16) & 1) == 0;
  BOOL v78 = (*(void *)(v68 + 16) & 1) == 0;
  uint64_t v77 = 380;
  if (!v9) {
    _dispatch_abort(v77, v78, v3, v4, v5, v6, v7, v8);
  }
  uint64_t v76 = *(void *)(v75 + 16);
  uint64_t v64 = v76;
  uint64_t v63 = 0;
  uint64_t v63 = *(unsigned int *)(v68 + 60);
  uint64_t v62 = 0;
  uint64_t v62 = *(int *)(v68 + 12);
  unsigned int v61 = 0;
  unsigned int v61 = *(unsigned __int16 *)(v68 + 10);
  mach_error_t v60 = 0;
  mach_error_t v60 = *(_DWORD *)(v68 + 24);
  if (v60 == 268451844)
  {
    if (!v66)
    {
      uint64_t v59 = v60;
      uint64_t v28 = v1;
      uint64_t v29 = v2;
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with no message size";
      qword_F42C0 = v60;
      __break(1u);
      JUMPOUT(0x97E90);
    }
    if (!*(void *)(v68 + 32))
    {
      uint64_t v28 = v1;
      uint64_t v29 = v2;
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: MACH_RCV_LARGE_IDENTITY with no identity";
      __break(1u);
      JUMPOUT(0x98018);
    }
    if (_dispatch_kevent_mach_msg_size(v68) >= 0xFFFFFFBC)
    {
      uint64_t v56 = _dispatch_kevent_mach_msg_size(v68);
      uint64_t v28 = v1;
      uint64_t v29 = v2;
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with overlarge message";
      qword_F42C0 = v56;
      __break(1u);
      JUMPOUT(0x98078);
    }
    int v55 = 0;
    if ((*(unsigned char *)(v64 + 33) & 2) != 0) {
      v55 |= 0x200u;
    }
    int v36 = 0;
    unsigned int v54 = v55 & 0xF8FFF6F1 | 0x700090A;
    v66 += 68;
    uint64_t v67 = (unsigned int *)malloc_type_malloc();
    *(_DWORD *)long long v65 = 40;
    uint64_t v35 = v27;
    bzero(v27, 0x28uLL);
    *(void *)&v65[4] = v35;
    int v37 = &v80;
    long long v52 = (unint64_t)v67;
    LODWORD(v53) = v36;
    int v38 = (unsigned int *)&v53 + 1;
    uint64_t v51 = v67;
    long long v72 = v67;
    uint64_t v71 = 3256;
    if (!v67) {
      _dispatch_bug(v71, 0, v10, v11, v12, v13, v14, v15);
    }
    v50[1] = v51;
    if (v51) {
      unsigned int v34 = v66;
    }
    else {
      unsigned int v34 = 0;
    }
    uint64_t v16 = v37;
    *int v38 = v34;
    long long v17 = v52;
    *((void *)v16 + 2) = v53;
    *(_OWORD *)uint64_t v16 = v17;
    BOOL v32 = &v81;
    long long v49 = *(unint64_t *)&v65[4];
    LODWORD(v50[0]) = 0;
    unint64_t v33 = (_DWORD *)v50 + 1;
    uint64_t v48 = *(void *)&v65[4];
    uint64_t v70 = *(void *)&v65[4];
    uint64_t v69 = 3262;
    if (!*(void *)&v65[4]) {
      _dispatch_bug(v69, 0, v10, v11, v12, v13, v14, v15);
    }
    uint64_t v47 = v48;
    if (v48) {
      int v31 = *(_DWORD *)v65;
    }
    else {
      int v31 = 0;
    }
    uint64_t v18 = v32;
    *unint64_t v33 = v31;
    long long v19 = v49;
    v18[2] = v50[0];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v46 = 0;
    uint64_t v45 = 0;
    uint64_t v44 = 0;
    uint64_t v43 = 0;
    long long v42 = 0u;
    mach_error_t v60 = mach_msg2();
    if (!v60)
    {
      v61 |= 0x10000u;
      if (!**(_DWORD **)&v65[4]) {
        *(void *)&v65[4] = 0;
      }
      _dispatch_kevent_mach_msg_recv(v64, v61, v67, *(uint64_t *)&v65[4], v63, v62);
      return;
    }
    if (v60 == 268451844)
    {
      uint64_t v30 = v67[5];
      _dispatch_kevent_mach_msg_size(v68);
      _dispatch_log("BUG in libdispatch client: _dispatch_kevent_mach_msg_drain: dropped message too large to fit in memory: id = 0x%x, size = %u", v20, v21, v22, v23, v24, v25, v26, v30);
      mach_error_t v60 = 0;
    }
    free(v67);
  }
  else
  {
    if (v60 == 268451848)
    {
      BOOL v74 = v66 == 0;
      uint64_t v73 = 3214;
      if (v66) {
        _dispatch_abort(v73, v74, v3, v4, v5, v6, v7, v8);
      }
      uint64_t v58 = v60;
      uint64_t v28 = v1;
      uint64_t v29 = v2;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to copyout msg, possible port leak";
      qword_F42C0 = v60;
      __break(1u);
      JUMPOUT(0x97F24);
    }
    if (!v67)
    {
      uint64_t v57 = v60;
      uint64_t v28 = v1;
      uint64_t v29 = v2;
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with no message";
      qword_F42C0 = v60;
      __break(1u);
      JUMPOUT(0x97F74);
    }
    if (!v60)
    {
      if (*(_DWORD *)v65) {
        uint64_t v39 = (uint64_t)v67 + v66;
      }
      else {
        uint64_t v39 = 0;
      }
      *(void *)&v65[4] = v39;
      _dispatch_kevent_mach_msg_recv(v64, v61, v67, v39, v63, v62);
      return;
    }
  }
  if (v60) {
    _dispatch_bug_mach_client((uint64_t)"_dispatch_kevent_mach_msg_drain: message reception failed", v60);
  }
}

uint64_t _dispatch_kevent_merge_muxed(uint64_t result)
{
  uint64_t v5 = result;
  unint64_t v4 = *(void *)(result + 16) & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v2 = 0;
  if ((*(_WORD *)(result + 10) & 0x12) != 0) {
    *(_WORD *)(v4 + 34) |= 2u;
  }
  for (uint64_t i = *(void **)(v4 + 16); ; uint64_t i = v2)
  {
    char v1 = 0;
    if (i)
    {
      uint64_t v2 = (void *)*i;
      char v1 = 1;
    }
    if ((v1 & 1) == 0) {
      break;
    }
    uint64_t result = _dispatch_kevent_merge((uint64_t)(i + 3), v5);
  }
  return result;
}

uint64_t _dispatch_kevent_merge(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = 0;
  if (*(void *)a1) {
    uint64_t v20 = *(void *)a1;
  }
  unsigned __int8 v24 = *(unsigned char *)(v20 + 9);
  _dispatch_retain_2(~*(void *)(a1 + 8));
  switch(v24)
  {
    case 0u:
      unint64_t v23 = *(void *)(a2 + 32);
      break;
    case 1u:
      unint64_t v23 = *(unsigned int *)(a2 + 24);
      if (*(char *)(a1 + 28) == -8) {
        unint64_t v23 = 2;
      }
      break;
    case 2u:
      unint64_t v23 = (*(_DWORD *)(a2 + 24) & *(_DWORD *)(a1 + 32));
      if ((*(unsigned char *)(a1 + 29) & 4) != 0)
      {
        unint64_t v21 = v23 | ((unint64_t)*(void *)(a2 + 32) << 32);
        for (uint64_t i = *(void *)(a1 + 72); ; uint64_t i = v9)
        {
          uint64_t v8 = i;
          uint64_t v9 = i;
          atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 72), (unint64_t *)&v9, i | v21, memory_order_relaxed, memory_order_relaxed);
          if (v9 == v8) {
            break;
          }
        }
      }
      else if (*(char *)(a1 + 28) == -8)
      {
        unint64_t v23 = 2;
        *(void *)(a1 + 72) = 2;
      }
      else if ((*(_DWORD *)(a2 + 24) & *(_DWORD *)(a1 + 32)) != 0)
      {
        atomic_fetch_or_explicit((atomic_ullong *volatile)(a1 + 72), v23, memory_order_relaxed);
      }
      break;
    case 3u:
      if (*(uint64_t *)(a2 + 32) < 0) {
        _dispatch_abort(494, 0, v2, v3, v4, v5, v6, v7);
      }
      unint64_t v23 = *(void *)(a2 + 32);
      *(void *)(a1 + 72) = ~v23;
      break;
    case 4u:
      unint64_t v23 = *(void *)(a2 + 32);
      if (v23) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 72), v23, memory_order_relaxed);
      }
      break;
    default:
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Corrupt unote action";
      qword_F42C0 = v24;
      __break(1u);
      JUMPOUT(0x9895CLL);
  }
  __int16 v27 = *(_WORD *)(a2 + 10);
  LOBYTE(v19) = 0;
  if ((v27 & 0x100) == 0) {
    int v19 = (v27 >> 4) & 1;
  }
  if (v19)
  {
    _dispatch_unote_unregister(a1, 5, v2, v3, v4, v5, v6, v7);
    goto LABEL_36;
  }
  if ((v27 & 2) != 0)
  {
    *(void *)(a1 + 16) = 2;
LABEL_35:
    _dispatch_thread_getspecific(0);
    _evfiltstr(*(char *)(a1 + 28));
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v10, v11, v12, v13, v14, v15, v16, 460);
    goto LABEL_36;
  }
  if ((*(_WORD *)(a2 + 10) & 0x210) != 0)
  {
    *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL | 2;
    goto LABEL_35;
  }
  if ((v27 & 0x80) != 0)
  {
    *(void *)(a1 + 16) &= ~1uLL;
    goto LABEL_35;
  }
LABEL_36:
  uint64_t v18 = 0;
  if (*(void *)a1) {
    uint64_t v18 = *(void *)a1;
  }
  return (*(uint64_t (**)(uint64_t, void, unint64_t, uint64_t))(v18 + 48))(a1, *(unsigned __int16 *)(a2 + 10), v23, *(_DWORD *)(a2 + 12) & 0xFFFFFFLL);
}

uint64_t _dispatch_kevent_mach_msg_buf(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t _dispatch_kevent_mach_msg_aux_size(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t _dispatch_kevent_mach_msg_recv(uint64_t a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v24 = a3[1] + 68;
  if (((a3[1] + 68) & 0x100000000) != 0)
  {
    uint64_t v6 = a3[1];
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Overlarge message received";
    qword_F42C0 = v6;
    __break(1u);
    JUMPOUT(0x98DB8);
  }
  if (!a3[3])
  {
    uint64_t v7 = (int)a3[5];
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Received message with MACH_PORT_NULL msgh_local_port";
    qword_F42C0 = v7;
    __break(1u);
    JUMPOUT(0x98E0CLL);
  }
  _dispatch_retain_2(~*(void *)(a1 + 8));
  LOBYTE(v23) = 0;
  if ((a2 & 0x100) == 0) {
    int v23 = (a2 >> 4) & 1;
  }
  if (v23)
  {
    _dispatch_unote_unregister(a1, 5, v8, v9, v10, v11, v12, v13);
    goto LABEL_17;
  }
  if ((a2 & 2) != 0)
  {
    *(void *)(a1 + 16) = 2;
LABEL_16:
    _dispatch_thread_getspecific(0);
    _evfiltstr(*(char *)(a1 + 28));
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v14, v15, v16, v17, v18, v19, v20, 460);
    goto LABEL_17;
  }
  if ((a2 & 0x210) != 0)
  {
    *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL | 2;
    goto LABEL_16;
  }
  if ((a2 & 0x80) != 0)
  {
    *(void *)(a1 + 16) &= ~1uLL;
    goto LABEL_16;
  }
LABEL_17:
  uint64_t v22 = 0;
  if (*(void *)a1) {
    uint64_t v22 = *(void *)a1;
  }
  return (*(uint64_t (**)(uint64_t, void, _DWORD *, void, uint64_t, uint64_t, uint64_t))(v22 + 56))(a1, a2, a3, v24, a4, a5, a6);
}

uint64_t _dispatch_kq_init(unsigned char *a1)
{
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  if (getenv("LIBDISPATCH_TIMERS_FORCE_MAX_LEEWAY")) {
    _dispatch_timers_force_max_leeway = 1;
  }
  *a1 = 1;
  _dispatch_kevent_workqueue_init();
  if (_dispatch_kevent_workqueue_enabled)
  {
    _dispatch_kq_fd();
    while (1)
    {
      uint64_t result = kevent_qos();
      if (result != -1) {
        break;
      }
      int v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v6 != 4)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Failed to initalize workqueue kevent";
        qword_F42C0 = v6;
        __break(1u);
        JUMPOUT(0x99330);
      }
    }
  }
  else
  {
    _dispatch_kq_create(&qword_F0120);
    uint64_t v5 = 0;
    if (*off_F0118) {
      uint64_t v5 = (uint64_t)*off_F0118;
    }
    return (*(uint64_t (**)(uint64_t (***)(), uint64_t (***)(), void, uint64_t, uint64_t, uint64_t))(v5 + 72))(off_F0118, &_dispatch_mgr_q, 0, v2, v3, v4);
  }
  return result;
}

void _dispatch_memorypressure_init()
{
}

uint64_t _dispatch_kq_fd()
{
  return qword_F0120;
}

void _dispatch_kq_create(void *a1)
{
  if ((_dispatch_unsafe_fork & 1) == 0) {
    _dispatch_fork_becomes_unsafe_slow();
  }
  int v9 = guarded_kqueue_np();
  if (v9 == -1)
  {
    int v8 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v8 != 12)
    {
      if (v8 != 23)
      {
        if (v8 == 24)
        {
          qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: process is out of file descriptors";
          qword_F42C0 = 24;
          __break(1u);
          JUMPOUT(0x9993CLL);
        }
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: kqueue() failure";
        qword_F42C0 = v8;
        __break(1u);
        JUMPOUT(0x99A08);
      }
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: system is out of file descriptors";
      qword_F42C0 = 23;
      __break(1u);
      JUMPOUT(0x99980);
    }
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: kernel is out of memory";
    qword_F42C0 = 12;
    __break(1u);
    JUMPOUT(0x999C4);
  }
  int v7 = kevent_qos();
  if (v7) {
    _dispatch_bug(640, v7, v1, v2, v3, v4, v5, v6);
  }
  *a1 = v9;
}

void _dispatch_memorypressure_create(uintptr_t a1)
{
  dispatch_source_t v1 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_memorystatus, 0, a1, (dispatch_queue_t)&_dispatch_mgr_q);
  dispatch_set_context(v1, v1);
  dispatch_source_set_event_handler_f(v1, (dispatch_function_t)_dispatch_memorypressure_handler);
  dispatch_activate(v1);
  if (_dispatch_memorypressure_source)
  {
    dispatch_source_cancel((dispatch_source_t)_dispatch_memorypressure_source);
    dispatch_release((dispatch_object_t)_dispatch_memorypressure_source);
  }
  _dispatch_memorypressure_source = (uint64_t)v1;
}

uint64_t _dispatch_memorypressure_handler(dispatch_source_s *a1)
{
  int data = dispatch_source_get_data(a1);
  if ((data & 0xF0000000) != 0
    && dispatch_source_get_mask((dispatch_source_t)_dispatch_memorypressure_source) != malloc_memorypressure_mask_msl_4libdispatch)
  {
    _dispatch_memorypressure_create(malloc_memorypressure_mask_msl_4libdispatch);
  }
  if (data)
  {
    _dispatch_memory_warn = 0;
    _dispatch_continuation_cache_limit = 112;
    if (_firehose_task_buffer)
    {
      uint64_t v4 = _firehose_task_buffer;
      unint64_t v3 = atomic_fetch_and_explicit((atomic_ullong *volatile)(_firehose_task_buffer + 512), 0xFFFFFFFFFFFFFFFELL, memory_order_relaxed);
      if (v3 != (v3 & 0xFFFFFFFFFFFFFFFELL)) {
        firehose_buffer_update_limits(v4);
      }
    }
  }
  if ((data & 2) != 0)
  {
    _dispatch_memory_warn = 1;
    _dispatch_continuation_cache_limit = 16;
    if (_firehose_task_buffer)
    {
      uint64_t v6 = _firehose_task_buffer;
      unint64_t v5 = atomic_fetch_or_explicit((atomic_ullong *volatile)(_firehose_task_buffer + 512), 1uLL, memory_order_relaxed);
      if (v5 != (v5 | 1)) {
        firehose_buffer_update_limits(v6);
      }
    }
  }
  return malloc_memory_event_handler();
}

const char *_evflagstr(__int16 a1, const char *a2)
{
  __int16 v5 = a1;
  *a2 = 0;
  while (v5)
  {
    _evflagstr2(&v5);
    __strlcat_chk();
  }
  size_t v3 = strlen(a2);
  if (v3) {
    a2[v3 - 1] = 0;
  }
  return a2;
}

const char *_evflagstr2(_WORD *a1)
{
  if ((*a1 & 1) == 1)
  {
    *a1 &= ~1u;
    return "EV_ADD|";
  }
  else if ((*a1 & 2) == 2)
  {
    *a1 &= ~2u;
    return "EV_DELETE|";
  }
  else if ((*a1 & 4) == 4)
  {
    *a1 &= ~4u;
    return "EV_ENABLE|";
  }
  else if ((*a1 & 8) == 8)
  {
    *a1 &= ~8u;
    return "EV_DISABLE|";
  }
  else if ((*a1 & 0x10) == 0x10)
  {
    *a1 &= ~0x10u;
    return "EV_ONESHOT|";
  }
  else if ((*a1 & 0x20) == 0x20)
  {
    *a1 &= ~0x20u;
    return "EV_CLEAR|";
  }
  else if ((*a1 & 0x40) == 0x40)
  {
    *a1 &= ~0x40u;
    return "EV_RECEIPT|";
  }
  else if ((*a1 & 0x80) == 0x80)
  {
    *a1 &= ~0x80u;
    return "EV_DISPATCH|";
  }
  else if ((*a1 & 0x100) == 0x100)
  {
    *a1 &= ~0x100u;
    return "EV_UDATA_SPECIFIC|";
  }
  else if ((*a1 & 0x1000) == 0x1000)
  {
    *a1 &= ~0x1000u;
    return "EV_POLL|";
  }
  else if ((*a1 & 0x2000) == 0x2000)
  {
    *a1 &= ~0x2000u;
    return "EV_OOBAND|";
  }
  else if ((*a1 & 0x4000) == 0x4000)
  {
    *a1 &= ~0x4000u;
    return "EV_ERROR|";
  }
  else if ((*a1 & 0x8000) == 0x8000)
  {
    *a1 &= ~0x8000u;
    return "EV_EOF|";
  }
  else if ((*a1 & 0x200) == 0x200)
  {
    *a1 &= ~0x200u;
    return "EV_VANISHED|";
  }
  else
  {
    *a1 = 0;
    return "EV_UNKNOWN ";
  }
}

void _dispatch_mach_host_notify_update()
{
  kern_return_t v14;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tregistering for calendar-change notification", v0, v1, v2, v3, v4, v5, v6, 2888);
  host_t host = _dispatch_get_mach_host_port();
  if (_dispatch_mach_notify_port_pred != -1) {
    dispatch_once_f(&_dispatch_mach_notify_port_pred, 0, (dispatch_function_t)_dispatch_mach_notify_port_init);
  }
  uint64_t v14 = host_request_notification(host, 1, _dispatch_mach_notify_port);
  if (v14 == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x9A320);
  }
  if (v14) {
    _dispatch_bug(2893, v14, v7, v8, v9, v10, v11, v12);
  }
}

void _dispatch_mach_notify_port_init(uint64_t a1)
{
  kern_return_t v14;
  mach_port_options_t options;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  uint64_t v16 = a1;
  options.reserved[1] = 0;
  *(_OWORD *)&options.flags = xmmword_CAA60;
  uint64_t v14 = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)&_dispatch_mach_notify_port, (mach_port_name_t *)&_dispatch_mach_notify_port);
  if (v14)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: mach_port_construct() failed: cannot create receive right";
    qword_F42C0 = v14;
    __break(1u);
    JUMPOUT(0x9A420);
  }
  uint64_t v13 = off_ED3B0((uint64_t)&_dispatch_mach_type_notification, _dispatch_mach_notify_port, 0);
  *(void *)(v13 + 8) = ~(unint64_t)&_dispatch_mgr_q;
  char v12 = _dispatch_unote_register(v13, -4, 0x2000000, v1, v2, v3, v4, v5);
  uint64_t v18 = v12 & 1;
  uint64_t v17 = 2842;
  if ((v12 & 1) == 0) {
    _dispatch_bug(v17, v18, v6, v7, v8, v9, v10, v11);
  }
  _dispatch_mach_notify_unote = v13;
}

BOOL _dispatch_kevent_mach_notify_resume(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = 0;
  if ((a2 & a3) != 0) {
    _dispatch_abort(2986, a2 & a3, a3, a4, a5, a6, a7, a8);
  }
  if ((a2 & 0xD) != 0 || (a3 & 0xD) != 0) {
    int v9 = _dispatch_mach_notify_update(a1, a2, a3, 0xDu, 66, 0);
  }
  return v9 == 0;
}

uint64_t _dispatch_mach_notify_update(uint64_t a1, int a2, int a3, unsigned int a4, mach_msg_id_t a5, mach_port_mscount_t a6)
{
  kern_return_t v48;
  kern_return_t v49;
  kern_return_t v50;
  uint64_t v51;
  mach_port_name_t v52;
  mach_port_t previous;
  mach_port_mscount_t v54;
  mach_msg_id_t v55;
  unsigned int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  dispatch_function_t v71;
  void *v72;
  dispatch_once_t *v73;

  uint64_t v59 = a1;
  uint64_t v58 = a2;
  uint64_t v57 = a3;
  uint64_t v56 = a4;
  int v55 = a5;
  unsigned int v54 = a6;
  previous = 0;
  long long v52 = *(void *)(a1 + 24);
  uint64_t v51 = *(void *)(a1 + 56);
  uint64_t v48 = 0;
  *(void *)(a1 + 56) = v51 | (a2 | *(_DWORD *)(a1 + 48)) & a4;
  *(void *)(v59 + 56) &= ~(v57 & v56);
  if ((*(void *)(v59 + 56) & v56) == 0 || (v51 & v56) != 0)
  {
    if ((*(void *)(v59 + 56) & v56) != 0 || (v51 & v56) == 0) {
      return 0;
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistering for send-possible notification", v25, v26, v27, v28, v29, v30, v31, 2953);
    previous = 0;
    uint64_t v50 = mach_port_request_notification(mach_task_self_, v52, v55, v54, 0, 0x12u, &previous);
    if (v50 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x9AA74);
    }
    if (v50 != 4 && v50 != 15 && v50 != 17)
    {
      uint64_t v64 = v50;
      uint64_t v63 = 2966;
      if (v50) {
        _dispatch_bug(v63, v64, v32, v33, v34, v35, v36, v37);
      }
    }
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for send-possible notification", v6, v7, v8, v9, v10, v11, v12, 2920);
    previous = 0;
    tassigned int k = mach_task_self_;
    uint64_t v73 = &_dispatch_mach_notify_port_pred;
    long long v72 = 0;
    uint64_t v71 = (dispatch_function_t)_dispatch_mach_notify_port_init;
    if (_dispatch_mach_notify_port_pred != -1) {
      dispatch_once_f(v73, v72, v71);
    }
    uint64_t v48 = mach_port_request_notification(task, v52, v55, v54, _dispatch_mach_notify_port, 0x15u, &previous);
    if (v48 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x9A7B8);
    }
    if (v48 == 15 || v48 == 17)
    {
      *(void *)(v59 + 56) &= ~v56;
    }
    else
    {
      uint64_t v70 = v48;
      uint64_t v69 = 2935;
      if (v48)
      {
        _dispatch_bug(v69, v70, v13, v14, v15, v16, v17, v18);
        *(void *)(v59 + 56) &= ~v56;
      }
      else
      {
        mach_port_t v47 = previous;
        uint64_t v68 = previous;
        uint64_t v67 = 2938;
        if (previous) {
          _dispatch_bug(v67, v68, v13, v14, v15, v16, v17, v18);
        }
        if (v47)
        {
          long long v49 = mach_port_deallocate(mach_task_self_, previous);
          if (v49 == -301)
          {
            qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
            qword_F42C0 = -301;
            __break(1u);
            JUMPOUT(0x9A934);
          }
          unsigned int v66 = v49;
          long long v65 = 2947;
          if (v49) {
            _dispatch_bug(v65, v66, v19, v20, v21, v22, v23, v24);
          }
          previous = 0;
        }
      }
    }
  }
  if (previous)
  {
    int v46 = _dispatch_send_consume_send_once_right(previous);
    uint64_t v62 = v46;
    unsigned int v61 = 2976;
    if (v46) {
      _dispatch_bug(v61, v62, v38, v39, v40, v41, v42, v43);
    }
  }
  return v48;
}

void _dispatch_timers_calendar_change()
{
  for (unsigned int i = 0; i < 3; ++i)
  {
    byte_F432E |= (1 << ((i + 6) % 3)) | 0x80;
    *((unsigned char *)&_dispatch_timers_heap + 32 * i + 199) = *((unsigned char *)&_dispatch_timers_heap + 32 * i + 199) & 0xFD | 2;
  }
}

void _voucher_xref_dispose(_DWORD *a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: xref_dispose", v1, v2, v3, v4, v5, v6, v7, 782);
  _voucher_remove(a1);
  signed int v10 = a1[2];
  if (v10 != 0x7FFFFFFF) {
    signed int v10 = atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 2), 0xFFFFFFFF, memory_order_release) - 1;
  }
  if (v10 < 1)
  {
    if (v10 < 0)
    {
      qword_F4290 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x9ADD8);
    }
    int v9 = a1[3];
    if (v9 >= 1)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_F42C0 = v9;
      __break(1u);
      JUMPOUT(0x9AE38);
    }
    _os_object_dispose((uint64_t *)a1);
  }
}

void _voucher_dispose(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: dispose", v1, v2, v3, v4, v5, v6, v7, 791);
  if (*(void *)(a1 + 24))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v8, v9, v10, v11, v12, v13, v14, 793);
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
    __break(1u);
    JUMPOUT(0x9AF44);
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = -1985229329;
  if (*(_DWORD *)(a1 + 36))
  {
    if (*(_DWORD *)(a1 + 36) != *(_DWORD *)(a1 + 32)) {
      _voucher_dealloc_mach_voucher(*(_DWORD *)(a1 + 36));
    }
    *(_DWORD *)(a1 + 36) = 0;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    if (!*(void *)(a1 + 40)) {
      _voucher_dealloc_mach_voucher(*(_DWORD *)(a1 + 32));
    }
    *(_DWORD *)(a1 + 32) = 0;
  }
  if (*(void *)(a1 + 40))
  {
    os_release(*(void **)(a1 + 40));
    *(void *)(a1 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  _os_object_dealloc((void *)a1);
}

_DWORD *voucher_adopt(uint64_t a1)
{
  if (a1 == -3)
  {
    uint64_t v14 = _dispatch_thread_getspecific(0x1CuLL);
    if (v14) {
      os_retain(v14);
    }
    return v14;
  }
  else
  {
    uint64_t v15 = _dispatch_thread_getspecific(0x1CuLL);
    if (v15 == (_DWORD *)a1)
    {
      int v16 = -1;
    }
    else
    {
      _dispatch_thread_setspecific(28, a1);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v1, v2, v3, v4, v5, v6, v7, 400);
      if (a1) {
        int v11 = *(_DWORD *)(a1 + 32);
      }
      else {
        int v11 = 0;
      }
      if (v15) {
        int v10 = v15[8];
      }
      else {
        int v10 = 0;
      }
      if (v11 == v10) {
        int v9 = -1;
      }
      else {
        int v9 = v11;
      }
      int v16 = v9;
    }
    if (v16 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0, v16);
    }
    return v15;
  }
}

void *voucher_copy()
{
  uint64_t v1 = _dispatch_thread_getspecific(0x1CuLL);
  if (v1) {
    os_retain(v1);
  }
  return v1;
}

_DWORD *voucher_copy_without_importance()
{
  uint64_t v1 = _dispatch_thread_getspecific(0x1CuLL);
  if (v1) {
    return _voucher_create_without_importance(v1);
  }
  return v1;
}

void *voucher_retain(void *a1)
{
  return a1;
}

void voucher_release(void *a1)
{
}

void _voucher_thread_cleanup(void *a1)
{
}

void _voucher_dealloc_mach_voucher(mach_port_name_t a1)
{
  kern_return_t v14;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkvoucher[0x%08x]: dealloc", v1, v2, v3, v4, v5, v6, v7, 298);
  uint64_t v14 = mach_voucher_deallocate(a1);
  if (v14 == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x9B4D4);
  }
  if (v14) {
    _dispatch_bug(302, v14, v8, v9, v10, v11, v12, v13);
  }
}

uint64_t _voucher_task_mach_voucher_init(uint64_t a1)
{
  uint64_t v4 = a1;
  int v3 = 0;
  int v2 = 0;
  uint64_t result = _voucher_create_mach_voucher(_voucher_task_mach_voucher_init_task_create_recipe, 16, (ipc_voucher_t *)&v2);
  int v3 = result;
  if (result)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not create task mach voucher";
    qword_F42C0 = v3;
    __break(1u);
    JUMPOUT(0x9B5B4);
  }
  _voucher_default_task_int mach_voucher = v2;
  _voucher_task_int mach_voucher = v2;
  return result;
}

uint64_t _voucher_create_mach_voucher(uint8_t *a1, uint64_t a2, ipc_voucher_t *a3)
{
  mach_voucher_attr_raw_recipe_array_t v16 = a1;
  uint64_t v15 = a2;
  uint64_t v14 = a3;
  unsigned int v13 = 0;
  mach_host_mach_port_t port = _dispatch_get_mach_host_port();
  ipc_voucher_t voucher = 0;
  unsigned int v13 = host_create_mach_voucher(mach_host_port, v16, v15, &voucher);
  if (v13 == -301)
  {
    qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_F42C0 = -301;
    __break(1u);
    JUMPOUT(0x9B6A8);
  }
  if (!v13)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkvoucher[0x%08x]: create", v3, v4, v5, v6, v7, v8, v9, 319);
  }
  *uint64_t v14 = voucher;
  return v13;
}

void voucher_replace_default_voucher()
{
  uint64_t v24 = &_voucher_task_mach_voucher_pred;
  uint64_t v23 = 0;
  dispatch_function_t v22 = (dispatch_function_t)_voucher_task_mach_voucher_init;
  if (_voucher_task_mach_voucher_pred != -1) {
    dispatch_once_f(v24, v23, v22);
  }
  mach_port_name_t v19 = 0;
  ipc_voucher_t v18 = 0;
  uint64_t v17 = _dispatch_thread_getspecific(0x1CuLL);
  if (v17 && v17[8])
  {
    int v16 = 0;
    if (v17[9]) {
      mach_port_name_t v13 = v17[9];
    }
    else {
      mach_port_name_t v13 = v17[8];
    }
    mach_port_name_t v19 = v13;
    v15[0] = 0x100000003;
    v15[1] = v13;
    int v16 = _voucher_create_mach_voucher((uint8_t *)v15, 16, &v18);
    int v14 = v16;
    uint64_t v21 = v16;
    uint64_t v20 = 362;
    if (v16) {
      _dispatch_bug(v20, v21, v0, v1, v2, v3, v4, v5);
    }
    if (v14) {
      ipc_voucher_t v18 = 0;
    }
  }
  if (!v18) {
    ipc_voucher_t v18 = _voucher_default_task_mach_voucher;
  }
  mach_port_name_t v19 = __swp(v18, (unsigned int *)&_voucher_task_mach_voucher);
  if (v19 && v19 != _voucher_default_task_mach_voucher) {
    _voucher_dealloc_mach_voucher(v19);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] replace default voucher", v6, v7, v8, v9, v10, v11, v12, 371);
}

uint64_t _voucher_get_mach_voucher(uint64_t a1)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 36))
    {
      return *(unsigned int *)(a1 + 36);
    }
    else
    {
      unsigned int v2 = *(_DWORD *)(a1 + 32);
      if (!v2)
      {
        if (_voucher_task_mach_voucher_pred != -1) {
          dispatch_once_f(&_voucher_task_mach_voucher_pred, 0, (dispatch_function_t)_voucher_task_mach_voucher_init);
        }
        return _voucher_task_mach_voucher;
      }
      return v2;
    }
  }
  else
  {
    return 0;
  }
}

_DWORD *_voucher_create_without_importance(_DWORD *a1)
{
  uint64_t v37 = a1;
  if (!a1) {
    return 0;
  }
  if (v37[8] && (v37[18] & 1) != 0)
  {
    int v36 = 0;
    ipc_voucher_t v35 = 0;
    if (v37[9]) {
      int v30 = v37[9];
    }
    else {
      int v30 = v37[8];
    }
    v49[0] = -1;
    v49[1] = 1;
    v49[2] = v30;
    v49[3] = 0;
    v49[4] = 2;
    uint64_t v50 = 2;
    int v51 = 0;
    int v36 = _voucher_create_mach_voucher((uint8_t *)v49, 32, &v35);
    int v34 = v36;
    uint64_t v41 = v36;
    uint64_t v40 = 639;
    if (v36) {
      _dispatch_bug(v40, v41, v1, v2, v3, v4, v5, v6);
    }
    if (v34 || !v35)
    {
      if (v37[9]) {
        return 0;
      }
      ipc_voucher_t v35 = 0;
    }
    if (v35 == v30)
    {
      _voucher_dealloc_mach_voucher(v35);
      uint64_t v39 = v37;
      os_retain(v37);
      return v39;
    }
    else
    {
      uint64_t v32 = _voucher_find_and_retain(v35);
      if (v32 && v37[9])
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find without importance from voucher[%p]", v14, v15, v16, v17, v18, v19, v20, 650);
        _voucher_dealloc_mach_voucher(v35);
        return (_DWORD *)v32;
      }
      else
      {
        uint64_t v31 = v32;
        mach_port_t v47 = v37;
        __int16 v46 = 1;
        unsigned int v45 = 0;
        uint64_t v44 = 0;
        if (v37) {
          unsigned int v45 = 0;
        }
        uint64_t v44 = _voucher_alloc(v45, v7, v8, v9, v10, v11, v12, v13);
        if (v47)
        {
          __int16 v43 = ~v46;
          if ((v46 & 1) == 0 && v47[8])
          {
            uint64_t v42 = 0;
            if (*((void *)v47 + 5)) {
              uint64_t v29 = (_DWORD *)*((void *)v47 + 5);
            }
            else {
              uint64_t v29 = v47;
            }
            uint64_t v42 = v29;
            uint64_t v48 = v29;
            os_retain(v29);
            v44[5] = v48;
            *((_DWORD *)v44 + 8) = v42[8];
            *((unsigned char *)v44 + 72) = v44[9] & 0xFE | v42[18] & 1;
          }
          if ((v43 & 2) != 0)
          {
            v44[6] = *((void *)v47 + 6);
            v44[7] = *((void *)v47 + 7);
            v44[8] = *((void *)v47 + 8);
          }
        }
        uint64_t v33 = v44;
        *((_DWORD *)v44 + 8) = v35;
        if (v37[9])
        {
          *((_DWORD *)v33 + 9) = v35;
          _voucher_insert(v33);
        }
        else if (v31)
        {
          v33[5] = v31;
          _voucher_dealloc_mach_voucher(v35);
        }
        if (!v31)
        {
          _dispatch_thread_getspecific(0);
          _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create without importance from voucher[%p]", v21, v22, v23, v24, v25, v26, v27, 667);
        }
        return v33;
      }
    }
  }
  else
  {
    os_retain(v37);
    return v37;
  }
}

uint64_t _voucher_find_and_retain(unsigned int a1)
{
  if (!a1) {
    return 0;
  }
  unsigned int v21 = _dispatch_thread_getspecific(3uLL);
  int v1 = 0;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&_voucher_hash_lock, (unsigned int *)&v1, v21 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
  if (v1) {
    _dispatch_unfair_lock_lock_slow((atomic_uint *)&_voucher_hash_lock);
  }
  for (uint64_t i = ~_voucher_hash[(a1 >> 8) & 0x3F]; i; uint64_t i = ~*(void *)(i + 16))
  {
    if (*(_DWORD *)(i + 36) == a1)
    {
      signed int v17 = atomic_fetch_add_explicit((atomic_uint *volatile)(i + 12), 1u, memory_order_relaxed) + 1;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: retain  -> %d", v2, v3, v4, v5, v6, v7, v8, 234);
      if (v17 <= 0)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: over-release", v9, v10, v11, v12, v13, v14, v15, 236);
        qword_F4290 = (uint64_t)"API MISUSE: Voucher over-release";
        __break(1u);
        JUMPOUT(0x9C31CLL);
      }
      if (v17 == 1) {
        atomic_fetch_add_explicit((atomic_uint *volatile)(i + 8), 1u, memory_order_relaxed);
      }
      break;
    }
  }
  unsigned int v22 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  unsigned int v23 = atomic_exchange_explicit((atomic_uint *volatile)&_voucher_hash_lock, 0, memory_order_release);
  if (v23 != v22) {
    _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v23);
  }
  return i;
}

void *_voucher_insert(void *result)
{
  unint64_t v33 = (unint64_t)result;
  unsigned int v32 = *((_DWORD *)result + 9);
  if (v32)
  {
    unsigned int v34 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    int v1 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&_voucher_hash_lock, (unsigned int *)&v1, v34, memory_order_acquire, memory_order_acquire);
    if (v1) {
      _dispatch_unfair_lock_lock_slow((atomic_uint *)&_voucher_hash_lock);
    }
    if (*(void *)(v33 + 24))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v2, v3, v4, v5, v6, v7, v8, 259);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
      __break(1u);
      JUMPOUT(0x9C65CLL);
    }
    if (*(void *)(v33 + 48))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: Activity data corruption", v9, v10, v11, v12, v13, v14, v15, 263);
      uint64_t v16 = *(void *)(v33 + 48);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has non-zero activity value";
      qword_F42C0 = v16;
      __break(1u);
      JUMPOUT(0x9C6E8);
    }
    if (*(void *)(v33 + 40))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: Incoming voucher with corrupted base", v17, v18, v19, v20, v21, v22, v23, 267);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: Corrupted base for incoming voucher", v24, v25, v26, v27, v28, v29, v30, 268);
      uint64_t v31 = *(void *)(v33 + 40);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has nested base voucher";
      qword_F42C0 = v31;
      __break(1u);
      JUMPOUT(0x9C7ACLL);
    }
    int v36 = &_voucher_hash[(v32 >> 8) & 0x3F];
    unint64_t v35 = ~*v36;
    *(void *)(v33 + 16) = *v36;
    if (v35) {
      *(void *)(v35 + 24) = ~(v33 + 16);
    }
    *int v36 = ~v33;
    *(void *)(v33 + 24) = ~(unint64_t)v36;
    uint64_t result = _dispatch_thread_getspecific(3uLL);
    unsigned int v37 = atomic_exchange_explicit((atomic_uint *volatile)&_voucher_hash_lock, 0, memory_order_release);
    if (v37 != (result & 0xFFFFFFFC)) {
      return _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v37);
    }
  }
  return result;
}

void *_voucher_create_accounting_voucher(_DWORD *a1)
{
  uint64_t v38 = a1;
  if (!a1 || !v38[8]) {
    return 0;
  }
  int v37 = 0;
  unsigned int v36 = 0;
  ipc_voucher_t v35 = 0;
  if (v38[9]) {
    unsigned int v30 = v38[9];
  }
  else {
    unsigned int v30 = v38[8];
  }
  unsigned int v36 = v30;
  v34[0] = 0x100000003;
  v34[1] = v30;
  int v37 = _voucher_create_mach_voucher((uint8_t *)v34, 16, &v35);
  int v33 = v37;
  uint64_t v42 = v37;
  uint64_t v41 = 689;
  if (v37) {
    _dispatch_bug(v41, v42, v1, v2, v3, v4, v5, v6);
  }
  if (v33 || !v35) {
    return 0;
  }
  uint64_t v31 = _voucher_find_and_retain(v35);
  if (v31)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find accounting voucher from voucher[%p]", v14, v15, v16, v17, v18, v19, v20, 695);
    _voucher_dealloc_mach_voucher(v35);
    return (void *)v31;
  }
  else
  {
    unsigned int v32 = _voucher_alloc(0, v7, v8, v9, v10, v11, v12, v13);
    ipc_voucher_t v21 = v35;
    *((_DWORD *)v32 + 8) = v35;
    *((_DWORD *)v32 + 9) = v21;
    if (v35 == v36)
    {
      uint64_t v40 = v38;
      os_retain(v38);
      v32[5] = v40;
      _voucher_dealloc_mach_voucher(v35);
    }
    _voucher_insert(v32);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create accounting voucher from voucher[%p]", v22, v23, v24, v25, v26, v27, v28, 708);
    return v32;
  }
}

void *_voucher_alloc(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = _os_object_alloc_realized((uint64_t)_OS_voucher_vtable, a1 + 80, a3, a4, a5, a6, a7, a8);
  if (a1) {
    _dispatch_abort(62, a1 == 0, v8, v9, v10, v11, v12, v13);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: alloc", v14, v15, v16, v17, v18, v19, v20, 64);
  return v22;
}

void *_voucher_create_with_mach_msgv(_DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  unsigned int v13 = 0;
  uint64_t v12 = 0;
  unsigned int v11 = 0;
  uint64_t v19 = a1;
  uint64_t v18 = (int *)&v13;
  if ((*a1 & 0x1F0000) != 0)
  {
    unsigned int v17 = 0;
    unsigned int v17 = v19[4];
    v19[4] = 0;
    int v16 = 538902528;
    *uint64_t v18 = *v19 & 0x201F0000;
    *v19 &= ~v16;
    unsigned int v20 = v17;
  }
  else
  {
    *uint64_t v18 = 0;
    unsigned int v20 = 0;
  }
  if (a2)
  {
    unsigned int v10 = *a2;
    if (*a2 <= 7u)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid msg aux data size.";
      qword_F42C0 = v10;
      __break(1u);
      JUMPOUT(0x9CE6CLL);
    }
    unsigned int v11 = v10 - 8;
    if (v10 == 8) {
      uint64_t v9 = 0;
    }
    else {
      uint64_t v9 = a2 + 2;
    }
    uint64_t v12 = (uint64_t)v9;
  }
  return _voucher_create_with_mach_voucher(v20, v13, v12, v11, a5, a6, a7, a8);
}

void *_voucher_create_with_mach_voucher(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v37 = a2;
  unsigned int v35 = a4;
  uint64_t v33 = 0;
  if (a1)
  {
    uint64_t v33 = _voucher_find_and_retain(a1);
    if (v33)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] found", v15, v16, v17, v18, v19, v20, v21, 485);
      _voucher_dealloc_mach_voucher(a1);
    }
    else
    {
      uint64_t v33 = (uint64_t)_voucher_alloc(0, v8, v9, v10, v11, v12, v13, v14);
      *(_DWORD *)(v33 + 32) = a1;
      *(_DWORD *)(v33 + 36) = a1;
      *(unsigned char *)(v33 + 72) = *(unsigned char *)(v33 + 72) & 0xFE | ((v37 & 0x20000000) != 0);
      _voucher_insert((void *)v33);
    }
  }
  if (v35 < 0x20 || *(_DWORD *)a3 != 59821818 || !*(void *)(a3 + 8)) {
    return (void *)v33;
  }
  if (v33)
  {
    if (*(void *)(v33 + 48))
    {
      uint64_t v22 = *(void *)(v33 + 48);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has non-zero activity value";
      qword_F42C0 = v22;
      __break(1u);
      JUMPOUT(0x9D0A0);
    }
    if (*(void *)(v33 + 40))
    {
      uint64_t v23 = *(void *)(v33 + 40);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has nested base voucher";
      qword_F42C0 = v23;
      __break(1u);
      JUMPOUT(0x9D0F8);
    }
    uint64_t v40 = _voucher_alloc(0, a2, a3, a4, a5, a6, a7, a8);
    if (*(_DWORD *)(v33 + 32))
    {
      if (*(void *)(v33 + 40)) {
        uint64_t v32 = *(void *)(v33 + 40);
      }
      else {
        uint64_t v32 = v33;
      }
      os_retain((void *)v32);
      v40[5] = v32;
      *((_DWORD *)v40 + 8) = *(_DWORD *)(v32 + 32);
      *((unsigned char *)v40 + 72) = v40[9] & 0xFE | *(unsigned char *)(v32 + 72) & 1;
    }
    unsigned int v34 = v40;
    voucher_release((void *)v33);
  }
  else
  {
    unsigned int v34 = _voucher_alloc(0, a2, a3, a4, a5, a6, a7, a8);
  }
  v34[6] = *(void *)(a3 + 8);
  v34[7] = *(void *)(a3 + 16);
  v34[8] = *(void *)(a3 + 24);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create", v24, v25, v26, v27, v28, v29, v30, 521);
  return v34;
}

void *voucher_create_with_mach_msg(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1;
  unsigned int v9 = 0;
  uint64_t v14 = a1;
  uint64_t v13 = (int *)&v9;
  if ((*a1 & 0x1F0000u) >> 16)
  {
    unsigned int v12 = 0;
    unsigned int v12 = v14[4];
    v14[4] = 0;
    int v11 = 538902528;
    int *v13 = *v14 & 0x201F0000;
    *v14 &= ~v11;
    unsigned int v15 = v12;
  }
  else
  {
    int *v13 = 0;
    unsigned int v15 = 0;
  }
  return _voucher_create_with_mach_voucher(v15, v9, 0, 0, a5, a6, a7, a8);
}

void voucher_decrement_importance_count4CF(uint64_t a1)
{
  uint64_t v24 = a1;
  if (a1 && *(_DWORD *)(v24 + 32) && (*(unsigned char *)(v24 + 72) & 1) != 0)
  {
    mach_error_t v23 = 0;
    ipc_voucher_t v22 = 0;
    if (*(_DWORD *)(v24 + 36)) {
      ipc_voucher_t v14 = *(_DWORD *)(v24 + 36);
    }
    else {
      ipc_voucher_t v14 = *(_DWORD *)(v24 + 32);
    }
    ipc_voucher_t v22 = v14;
    int v21 = 1;
    uint64_t v20 = &v21;
    int v19 = 4;
    int v16 = -1;
    uint64_t v18 = &v16;
    mach_msg_type_number_t out_contentCnt = 4;
    mach_error_t v23 = mach_voucher_attr_command(v14, 2u, 2u, (mach_voucher_attr_content_t)&v21, 4u, (mach_voucher_attr_content_t)&v16, &out_contentCnt);
    if (v23 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x9D568);
    }
    if (v23 != 16)
    {
      _dispatch_thread_getspecific(0);
      mach_error_string(v23);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] decrement importance count to %u: %s - 0x%x", v1, v2, v3, v4, v5, v6, v7, 764);
      mach_error_t v15 = v23;
      uint64_t v26 = v23;
      uint64_t v25 = 766;
      if (v23) {
        _dispatch_bug(v25, v26, v8, v9, v10, v11, v12, v13);
      }
      if (v15 == 5)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher importance count underflow";
        qword_F42C0 = v23;
        __break(1u);
        JUMPOUT(0x9D694);
      }
    }
  }
}

_DWORD *_voucher_remove(_DWORD *result)
{
  uint64_t v10 = result;
  int v9 = result[9];
  if (*((void *)result + 3))
  {
    unsigned int v11 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    int v1 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&_voucher_hash_lock, (unsigned int *)&v1, v11, memory_order_acquire, memory_order_acquire);
    if (v1) {
      _dispatch_unfair_lock_lock_slow((atomic_uint *)&_voucher_hash_lock);
    }
    if (!v9)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v2, v3, v4, v5, v6, v7, v8, 282);
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
      __break(1u);
      JUMPOUT(0x9D834);
    }
    if ((int)v10[3] <= 0 && *((void *)v10 + 3))
    {
      uint64_t v13 = *((void *)v10 + 2);
      uint64_t v12 = *((void *)v10 + 3);
      if (v13 != -1) {
        *(void *)(23 - v13) = v12;
      }
      *(void *)~uint64_t v12 = v13;
      *((void *)v10 + 3) = 0;
      *((void *)v10 + 2) = -1985229329;
    }
    uint64_t result = _dispatch_thread_getspecific(3uLL);
    unsigned int v14 = atomic_exchange_explicit((atomic_uint *volatile)&_voucher_hash_lock, 0, memory_order_release);
    if (v14 != (result & 0xFFFFFFFC)) {
      return _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v14);
    }
  }
  return result;
}

void _voucher_activity_debug_channel_init()
{
  kern_return_t v8;
  mach_port_t special_port;
  uint64_t *f;
  uint64_t v11;

  unsigned int v11 = 0;
  if (_voucher_libtrace_hooks) {
    unsigned int v11 = *(void *)(_voucher_libtrace_hooks + 16);
  }
  if (v11)
  {
    f = 0;
    special_mach_port_t port = 0;
    uint64_t v8 = task_get_special_port(mach_task_self_, 10, &special_port);
    if (v8 == -301)
    {
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0x9DAE4);
    }
    if (v8)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Couldn't get debug control port";
      qword_F42C0 = v8;
      __break(1u);
      JUMPOUT(0x9DB34);
    }
    if (special_port)
    {
      f = dispatch_mach_create_f((uint64_t)"com.apple.debug-channel", 0, 0, v11, v0, v1, v2, v3);
      *(unsigned char *)(f[11] + 29) &= ~0x20u;
      dispatch_mach_connect((uint64_t)f, special_port, 0, 0, v4, v5, v6, v7);
      _voucher_activity_debug_channel = (uint64_t)f;
    }
  }
}

uint64_t _voucher_atfork_prepare()
{
  uint64_t result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  int v1 = 0;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)&_voucher_hash_lock, (unsigned int *)&v1, result & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
  if (v1) {
    return _dispatch_unfair_lock_lock_slow((atomic_uint *)&_voucher_hash_lock);
  }
  return result;
}

void *_voucher_atfork_parent()
{
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  unsigned int v1 = atomic_exchange_explicit((atomic_uint *volatile)&_voucher_hash_lock, 0, memory_order_release);
  if (v1 != (result & 0xFFFFFFFC)) {
    return _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v1);
  }
  return result;
}

uint64_t _voucher_atfork_child()
{
  _voucher_hash_reset_locked();
  _voucher_hash_locsigned int k = 0;
  uint64_t result = _dispatch_thread_setspecific(28, 0);
  _voucher_task_mach_voucher_pred = 0;
  _voucher_task_int mach_voucher = 0;
  _voucher_default_task_int mach_voucher = 0;
  _voucher_aid_next = 0;
  _firehose_task_buffer_pred = 0;
  _firehose_task_buffer = 0;
  return result;
}

void *_voucher_hash_reset_locked()
{
  for (unsigned int i = 0; i < 0x40; ++i)
  {
    uint64_t v2 = (void *)((char *)&_voucher_hash + 8 * i);
    while (1)
    {
      uint64_t v1 = ~*v2;
      if (*v2 == -1) {
        break;
      }
      *(_DWORD *)(31 - *v2) = 0;
      *(_DWORD *)(v1 + 36) = 0;
      uint64_t v5 = ~*(void *)(v1 + 16);
      uint64_t v4 = *(void *)(v1 + 24);
      if (*(void *)(v1 + 16) != -1) {
        *(void *)(23 - *(void *)(v1 + 16)) = v4;
      }
      *(void *)~uint64_t v4 = ~v5;
      *(void *)(v1 + 24) = 0;
      *(void *)(v1 + 16) = -1985229329;
    }
  }
  return memset(&_voucher_hash, -1, 0x200uLL);
}

uint64_t voucher_process_can_use_arbitrary_personas()
{
  if (_voucher_process_can_use_arbitrary_personas_pred != -1) {
    dispatch_once_f(&_voucher_process_can_use_arbitrary_personas_pred, 0, (dispatch_function_t)_voucher_process_can_use_arbitrary_personas_init);
  }
  return _voucher_process_can_use_arbitrary_personas & 1;
}

uint64_t _voucher_process_can_use_arbitrary_personas_init(uint64_t a1)
{
  uint64_t v7 = a1;
  ipc_voucher_t voucher = 0;
  uint64_t v10 = &_voucher_task_mach_voucher_pred;
  int v9 = 0;
  dispatch_function_t v8 = (dispatch_function_t)_voucher_task_mach_voucher_init;
  if (_voucher_task_mach_voucher_pred != -1) {
    dispatch_once_f(v10, v9, v8);
  }
  ipc_voucher_t voucher = _voucher_task_mach_voucher;
  int v5 = 0;
  int v2 = 0;
  mach_voucher_attr_content_t out_content = (mach_voucher_attr_content_t)&v2;
  mach_msg_type_number_t out_contentCnt = 4;
  uint64_t result = mach_voucher_attr_command(_voucher_task_mach_voucher, 3u, 4u, 0, 0, (mach_voucher_attr_content_t)&v2, &out_contentCnt);
  int v5 = result;
  if (result)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: mach_voucher_attr_command(BANK_PERSONA_ADOPT_ANY) failed";
    qword_F42C0 = v5;
    __break(1u);
    JUMPOUT(0x9E0F4);
  }
  _voucher_process_can_use_arbitrary_personas = v2 != 0;
  return result;
}

uint64_t voucher_copy_with_persona_mach_voucher(unsigned int a1)
{
  unsigned int v39 = a1;
  if (!a1) {
    return (uint64_t)voucher_copy();
  }
  int v38 = 0;
  int v37 = 0;
  ipc_voucher_t v36 = 0;
  unsigned int v35 = _dispatch_thread_getspecific(0x1CuLL);
  if (v35)
  {
    if (v35[9]) {
      int v30 = v35[9];
    }
    else {
      int v30 = v35[8];
    }
    int v37 = v30;
  }
  v51[0] = -1;
  v51[1] = 1;
  v51[2] = v37;
  v51[3] = 0;
  v51[4] = 3;
  v51[5] = 10;
  uint64_t v52 = v39;
  int v38 = _voucher_create_mach_voucher((uint8_t *)v51, 32, &v36);
  int v34 = v38;
  uint64_t v43 = v38;
  uint64_t v42 = 944;
  if (v38) {
    _dispatch_bug(v42, v43, v1, v2, v3, v4, v5, v6);
  }
  if (v34)
  {
    if (v38 == 20) {
      return -1;
    }
    ipc_voucher_t v36 = 0;
  }
  if (v36 == v37)
  {
    if (v36) {
      _voucher_dealloc_mach_voucher(v36);
    }
    uint64_t v41 = v35;
    os_retain(v35);
    return (uint64_t)v41;
  }
  else
  {
    uint64_t v32 = _voucher_find_and_retain(v36);
    if (v32 && (!v35 || v35[9]))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find with persona from voucher[%p]", v14, v15, v16, v17, v18, v19, v20, 958);
      _voucher_dealloc_mach_voucher(v36);
      return v32;
    }
    else
    {
      uint64_t v31 = v32;
      long long v49 = v35;
      __int16 v48 = 1;
      unsigned int v47 = 0;
      __int16 v46 = 0;
      if (v35) {
        unsigned int v47 = 0;
      }
      __int16 v46 = _voucher_alloc(v47, v7, v8, v9, v10, v11, v12, v13);
      if (v49)
      {
        __int16 v45 = ~v48;
        if ((v48 & 1) == 0 && v49[8])
        {
          uint64_t v44 = 0;
          if (*((void *)v49 + 5)) {
            uint64_t v29 = (_DWORD *)*((void *)v49 + 5);
          }
          else {
            uint64_t v29 = v49;
          }
          uint64_t v44 = v29;
          uint64_t v50 = v29;
          os_retain(v29);
          v46[5] = v50;
          *((_DWORD *)v46 + 8) = v44[8];
          *((unsigned char *)v46 + 72) = v46[9] & 0xFE | v44[18] & 1;
        }
        if ((v45 & 2) != 0)
        {
          v46[6] = *((void *)v49 + 6);
          v46[7] = *((void *)v49 + 7);
          v46[8] = *((void *)v49 + 8);
        }
      }
      uint64_t v33 = v46;
      *((_DWORD *)v46 + 8) = v36;
      if (v35 && !v35[9])
      {
        if (v31)
        {
          v33[5] = v31;
          _voucher_dealloc_mach_voucher(v36);
        }
      }
      else
      {
        *((_DWORD *)v33 + 9) = v36;
        _voucher_insert(v33);
      }
      if (!v31)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create with persona from voucher[%p]", v21, v22, v23, v24, v25, v26, v27, 975);
      }
      return (uint64_t)v33;
    }
  }
}

uint64_t mach_voucher_persona_self(_DWORD *a1)
{
  uint64_t v10 = a1;
  ipc_voucher_t v9 = 0;
  v13[0] = xmmword_CAA88;
  v13[1] = xmmword_CAA98;
  unsigned int v8 = _voucher_create_mach_voucher((uint8_t *)v13, 32, &v9);
  uint64_t v12 = (int)v8;
  uint64_t v11 = 1000;
  if (v8)
  {
    _dispatch_bug(v11, v12, v1, v2, v3, v4, v5, v6);
    ipc_voucher_t v9 = 0;
  }
  _DWORD *v10 = v9;
  return v8;
}

uint64_t mach_voucher_persona_for_originator(unsigned int a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  unsigned int v22 = a1;
  unsigned int v21 = a2;
  uint64_t v20 = a3;
  uint64_t v19 = a4;
  uint64_t v11 = (ipc_voucher_t *)&v18;
  int v8 = 0;
  int v18 = 0;
  unsigned int mach_voucher = 46;
  ipc_voucher_t v9 = v16;
  v16[0] = a1;
  v16[1] = a3;
  uint64_t v15 = 48;
  uint64_t v14 = 0;
  uint64_t v7 = v6;
  bzero(v6, 0x30uLL);
  uint64_t v14 = v7;
  uint64_t v10 = -1;
  __memset_chk();
  uint64_t v4 = v9;
  *(void *)&long long v13 = 0x100000003;
  *((void *)&v13 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v21;
  *(_OWORD *)uint64_t v14 = v13;
  *(void *)&long long v12 = 0x26300000003;
  *((void *)&v12 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0x1000000000;
  *((_OWORD *)v14 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v12;
  uint64_t v25 = v14 + 32;
  uint64_t v24 = v4;
  uint64_t v23 = 16;
  __memcpy_chk();
  unsigned int mach_voucher = _voucher_create_mach_voucher(v14, v15, v11);
  if (mach_voucher) {
    int v18 = 0;
  }
  *uint64_t v19 = v18;
  return mach_voucher;
}

uint64_t voucher_get_current_persona()
{
  unsigned int v8 = -1;
  if (_voucher_get_current_persona_id((uint8_t *)&v8))
  {
    if ((int)kpersona_get() < 0)
    {
      uint64_t v12 = 1;
      uint64_t v13 = 1;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v7 = **(_DWORD **)(StatusReg + 8);
      if (v7 != 3)
      {
        uint64_t v11 = v7;
        uint64_t v10 = 1126;
        if (v7) {
          _dispatch_bug(v10, v11, v0, v1, v2, v3, v4, v5);
        }
      }
    }
    return v8;
  }
  else
  {
    return v8;
  }
}

uint64_t _voucher_get_current_persona_id(uint8_t *a1)
{
  kern_return_t v15;
  mach_voucher_attr_content_t v16;
  uint64_t v17;
  uint64_t v18;

  uint64_t v16 = a1;
  uint64_t v15 = 5;
  uint64_t v14 = _dispatch_thread_getspecific(0x1CuLL);
  if (v14 && v14[8])
  {
    ipc_voucher_t v13 = 0;
    if (v14[9]) {
      ipc_voucher_t v8 = v14[9];
    }
    else {
      ipc_voucher_t v8 = v14[8];
    }
    ipc_voucher_t v13 = v8;
    mach_voucher_attr_content_t in_content = 0;
    mach_msg_type_number_t in_contentCnt = 0;
    mach_voucher_attr_content_t out_content = v16;
    mach_msg_type_number_t out_contentCnt = 4;
    uint64_t v15 = mach_voucher_attr_command(v8, 3u, 3u, 0, 0, v16, &out_contentCnt);
    if (v15 != 46 && v15 != 18 && v15 != 4)
    {
      int v18 = v15;
      uint64_t v17 = 1103;
      if (v15) {
        _dispatch_bug(v17, v18, v1, v2, v3, v4, v5, v6);
      }
    }
  }
  return v15;
}

uint64_t voucher_get_current_persona_originator_info(void *a1)
{
  memset(__b, 0, sizeof(__b));
  if (_voucher_get_current_persona_token(__b))
  {
    return -1;
  }
  else
  {
    memcpy(a1, __b, 0x30uLL);
    return 0;
  }
}

uint64_t _voucher_get_current_persona_token(uint8_t *a1)
{
  kern_return_t v15;
  mach_voucher_attr_content_t v16;
  uint64_t v17;
  uint64_t v18;

  uint64_t v16 = a1;
  uint64_t v15 = 5;
  uint64_t v14 = _dispatch_thread_getspecific(0x1CuLL);
  if (v14 && v14[8])
  {
    ipc_voucher_t v13 = 0;
    if (v14[9]) {
      ipc_voucher_t v8 = v14[9];
    }
    else {
      ipc_voucher_t v8 = v14[8];
    }
    ipc_voucher_t v13 = v8;
    mach_voucher_attr_content_t in_content = 0;
    mach_msg_type_number_t in_contentCnt = 0;
    mach_voucher_attr_content_t out_content = v16;
    mach_msg_type_number_t out_contentCnt = 96;
    uint64_t v15 = mach_voucher_attr_command(v8, 3u, 2u, 0, 0, v16, &out_contentCnt);
    if (v15 != 46 && v15 != 18 && v15 != 4)
    {
      int v18 = v15;
      uint64_t v17 = 1075;
      if (v15) {
        _dispatch_bug(v17, v18, v1, v2, v3, v4, v5, v6);
      }
    }
  }
  return v15;
}

uint64_t voucher_get_current_persona_proximate_info(void *a1)
{
  memset(__b, 0, sizeof(__b));
  if (_voucher_get_current_persona_token(__b))
  {
    return -1;
  }
  else
  {
    memcpy(a1, &__b[48], 0x30uLL);
    return 0;
  }
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  uint64_t v10 = _dispatch_thread_getspecific(0x1CuLL);
  if ((msg->msgh_bits & 0x1F0000) >> 16)
  {
    char v12 = 0;
  }
  else
  {
    if (v10)
    {
      mach_port_name_t mach_voucher = _voucher_get_mach_voucher((uint64_t)v10);
    }
    else
    {
      if (_voucher_task_mach_voucher_pred != -1) {
        dispatch_once_f(&_voucher_task_mach_voucher_pred, 0, (dispatch_function_t)_voucher_task_mach_voucher_init);
      }
      mach_port_name_t mach_voucher = _voucher_task_mach_voucher;
    }
    if ((msg->msgh_bits & 0x1F0000) >> 16)
    {
      char v13 = 0;
    }
    else if (mach_voucher)
    {
      msg->msgh_voucher_mach_port_t port = mach_voucher;
      msg->msgh_bits |= 0x130000u;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] set %s", v1, v2, v3, v4, v5, v6, v7, 476);
      char v13 = 1;
    }
    else
    {
      char v13 = 0;
    }
    char v12 = v13;
  }
  return v12 & 1;
}

void voucher_mach_msg_clear(mach_msg_header_t *msg)
{
  mach_msg_bits_t v9 = (msg->msgh_bits & 0x1F0000) >> 16;
  msgh_voucher_mach_port_t port = msg->msgh_voucher_port;
  if ((v9 == 19 || v9 == 17) && msgh_voucher_port)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v1, v2, v3, v4, v5, v6, v7, 520);
    if (v9 == 17) {
      _voucher_dealloc_mach_voucher(msgh_voucher_port);
    }
    msg->msgh_voucher_mach_port_t port = 0;
    msg->msgh_bits &= 0xFFE0FFFF;
  }
}

voucher_mach_msg_state_t voucher_mach_msg_adopt(mach_msg_header_t *msg)
{
  uint64_t v23 = msg;
  unsigned int v22 = 0;
  uint64_t v21 = 0;
  unsigned int v20 = 0;
  int v30 = msg;
  uint64_t v29 = &v22;
  if ((msg->msgh_bits & 0x1F0000) >> 16)
  {
    msgh_voucher_mach_port_t port = 0;
    msgh_voucher_mach_port_t port = v30->msgh_voucher_port;
    v30->msgh_voucher_mach_port_t port = 0;
    int v27 = 538902528;
    *uint64_t v29 = v30->msgh_bits & 0x201F0000;
    v30->msgh_bits &= ~v27;
    unsigned int v31 = msgh_voucher_port;
  }
  else
  {
    *uint64_t v29 = 0;
    unsigned int v31 = 0;
  }
  unsigned int v19 = v31;
  if (!v31) {
    return (voucher_mach_msg_state_t)-1;
  }
  int v18 = (unsigned int *)_dispatch_thread_getspecific(0x7BuLL);
  if (v18)
  {
    int v17 = *v18;
    if (*v18 >= 8uLL)
    {
      unsigned int v20 = v17 - 8;
      if (v17 == 8) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = v18 + 2;
      }
      uint64_t v21 = (uint64_t)v16;
    }
  }
  uint64_t v26 = (voucher_mach_msg_state_s *)_voucher_create_with_mach_voucher(v19, v22, v21, v20, v1, v2, v3, v4);
  uint64_t v25 = 0;
  uint64_t v25 = (voucher_mach_msg_state_s *)_dispatch_thread_getspecific(0x1CuLL);
  uint64_t v40 = v25;
  unsigned int v39 = v26;
  if (v25 == v26)
  {
    int v41 = -1;
  }
  else
  {
    if (v40)
    {
      int v38 = 0;
      int v37 = 0;
    }
    _dispatch_thread_setspecific(28, (uint64_t)v39);
    if (v39)
    {
      int v36 = 0;
      int v35 = 0;
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v5, v6, v7, v8, v9, v10, v11, 400);
    int v34 = 0;
    if (v39) {
      int v15 = *((_DWORD *)v39 + 8);
    }
    else {
      int v15 = 0;
    }
    int v34 = v15;
    int v33 = 0;
    if (v40) {
      int v14 = *((_DWORD *)v40 + 8);
    }
    else {
      int v14 = 0;
    }
    int v33 = v14;
    if (v34 == v14) {
      int v13 = -1;
    }
    else {
      int v13 = v34;
    }
    int v41 = v13;
  }
  int v32 = v41;
  if (v41 != -1) {
    _dispatch_set_priority_and_mach_voucher_slow(0, v32);
  }
  return v25;
}

void voucher_mach_msg_revert(voucher_mach_msg_state_t state)
{
  if (state != (voucher_mach_msg_state_t)-1)
  {
    char v12 = _dispatch_thread_getspecific(0x1CuLL);
    if (v12 == (_DWORD *)state)
    {
      int v13 = -1;
    }
    else
    {
      _dispatch_thread_setspecific(28, (uint64_t)state);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v1, v2, v3, v4, v5, v6, v7, 400);
      if (state) {
        int v10 = *((_DWORD *)state + 8);
      }
      else {
        int v10 = 0;
      }
      if (v12) {
        int v9 = v12[8];
      }
      else {
        int v9 = 0;
      }
      if (v10 == v9) {
        int v8 = -1;
      }
      else {
        int v8 = v10;
      }
      int v13 = v8;
    }
    if (v13 != -1) {
      _dispatch_set_priority_and_mach_voucher_slow(0, v13);
    }
    if (v12) {
      os_release(v12);
    }
  }
}

uint64_t *voucher_activity_initialize_4libtrace(uint64_t *result)
{
  if (*result <= 2)
  {
    uint64_t v1 = *result;
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: unsupported vah_version";
    qword_F42C0 = v1;
    __break(1u);
    JUMPOUT(0x9F954);
  }
  uint64_t v2 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)&_voucher_libtrace_hooks, (unint64_t *)&v2, (unint64_t)result, memory_order_relaxed, memory_order_relaxed);
  if (v2)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: voucher_activity_initialize_4libtrace called twice";
    qword_F42C0 = _voucher_libtrace_hooks;
    __break(1u);
    JUMPOUT(0x9FA3CLL);
  }
  return result;
}

uint64_t _voucher_init()
{
  return _voucher_libkernel_init();
}

uint64_t _voucher_libkernel_init()
{
  uint64_t result = __libkernel_voucher_init();
  if (result) {
    _dispatch_abort(1262, result == 0, v1, v2, v3, v4, v5, v6);
  }
  return result;
}

unint64_t voucher_activity_id_allocate(unsigned __int8 a1)
{
  for (uint64_t i = _voucher_aid_next; ; uint64_t i = v2)
  {
    unint64_t v4 = i + 1;
    if (!i || !(v4 % 0x10)) {
      break;
    }
    uint64_t v1 = i;
    uint64_t v2 = i;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)&_voucher_aid_next, &v2, v4, memory_order_relaxed, memory_order_relaxed);
    if (v2 == v1) {
      return i & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a1 << 56);
    }
  }
  uint64_t i = _voucher_activity_id_allocate_slow(i);
  return i & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a1 << 56);
}

mach_vm_address_t voucher_activity_get_logging_preferences(mach_vm_size_t *a1)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v2 = 1;
  if (_firehose_task_buffer) {
    BOOL v2 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  if (!v2) {
    return firehose_buffer_get_logging_prefs(_firehose_task_buffer, a1);
  }
  *a1 = 0;
  return 0;
}

BOOL voucher_activity_should_send_strings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v9 = 1;
  if (_firehose_task_buffer) {
    BOOL v9 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  return !v9 && firehose_buffer_should_send_strings(_firehose_task_buffer, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t voucher_activity_get_metadata_buffer(void *a1)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v2 = 1;
  if (_firehose_task_buffer) {
    BOOL v2 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  if (v2)
  {
    *a1 = 0;
    return 0;
  }
  else
  {
    uint64_t v3 = _firehose_task_buffer;
    *a1 = 2048;
    return v3 + 4096 - *a1;
  }
}

void *voucher_activity_create_with_data_2(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  long long v65 = a1;
  uint64_t v64 = a2;
  uint64_t v63 = a3;
  uint64_t v62 = a4;
  unint64_t v61 = a5;
  int v60 = a6;
  unint64_t v59 = 0;
  uint64_t v58 = 0;
  uint64_t v57 = 0;
  unint64_t v56 = 0;
  unint64_t v56 = *a1;
  uint64_t v55 = 0;
  uint64_t v53 = _dispatch_thread_getspecific(0x1CuLL);
  BOOL v51 = (v60 & 1) == 0;
  unsigned __int16 v13 = v61 + 8;
  BOOL v14 = v61 >= 0xFFFFFFFFFFFFFFF8;
  if (((v61 + 8) & 0xFFFFFFFFFFFF0000) != 0) {
    BOOL v14 = 1;
  }
  unsigned __int16 v54 = v61 + 8;
  BOOL v100 = v14;
  if (v14 || v13 >= 0x81u)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Absurd publen";
    qword_F42C0 = v13;
    __break(1u);
    JUMPOUT(0xA005CLL);
  }
  if (v64 == (void *)-3) {
    uint64_t v64 = v53;
  }
  WORD1(v56) &= ~0x10u;
  if (v53)
  {
    uint64_t v58 = v53[6];
    if (v58)
    {
      WORD1(v56) |= 1u;
      unsigned __int16 v54 = v61 + 16;
      uint64_t v55 = v53[7];
      if (v55)
      {
        WORD1(v56) |= 0x10u;
        unsigned __int16 v54 = v61 + 24;
      }
    }
  }
  if (v64) {
    uint64_t v57 = v64[6];
  }
  if (v57)
  {
    WORD1(v56) |= 0x200u;
    v54 += 8;
    v63 |= HIBYTE(v57);
  }
  if ((MEMORY[0xFFFFFC104] & 0x80) == 0) {
    v63 |= 0x80uLL;
  }
  uint64_t v71 = v64;
  __int16 v70 = 2;
  unsigned int v69 = 0;
  uint64_t v68 = 0;
  if (v64) {
    unsigned int v69 = 0;
  }
  uint64_t v68 = _voucher_alloc(v69, v6, v7, v8, v9, v10, v11, v12);
  if (v71)
  {
    __int16 v67 = ~v70;
    if (*((_DWORD *)v71 + 8))
    {
      unsigned int v66 = 0;
      if (v71[5]) {
        __int16 v46 = (_DWORD *)v71[5];
      }
      else {
        __int16 v46 = v71;
      }
      unsigned int v66 = v46;
      object = v46;
      os_retain(v46);
      v68[5] = v46;
      *((_DWORD *)v68 + 8) = v66[8];
      *((unsigned char *)v68 + 72) = v68[9] & 0xFE | v66[18] & 1;
    }
    if ((v67 & 2) != 0)
    {
      v68[6] = v71[6];
      v68[7] = v71[7];
      v68[8] = v71[8];
    }
  }
  uint64_t v52 = v68;
  uint64_t v95 = v63;
  unint64_t v93 = 0;
  BOOL v92 = 0;
  uint64_t v91 = (atomic_ullong *)&_voucher_aid_next;
  uint64_t slow = _voucher_aid_next;
  while (1)
  {
    unint64_t v93 = slow + 1;
    if (!slow || (v93 & 0xF) == 0) {
      break;
    }
    unint64_t v90 = v93;
    uint64_t v15 = slow;
    uint64_t v16 = slow;
    atomic_compare_exchange_strong_explicit(v91, &v16, v93, memory_order_relaxed, memory_order_relaxed);
    if (v16 != v15) {
      uint64_t slow = v16;
    }
    BOOL v89 = v16 == v15;
    BOOL v92 = v16 == v15;
    if (v16 == v15) {
      goto LABEL_36;
    }
  }
  uint64_t slow = _voucher_activity_id_allocate_slow(slow);
LABEL_36:
  BOOL v88 = v92;
  unint64_t v59 = slow & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v95 << 56);
  v68[6] = v59;
  v52[7] = _voucher_unique_pid;
  v52[8] = v57;
  predicate = &_firehose_task_buffer_pred;
  context = 0;
  dispatch_function_t function = (dispatch_function_t)_firehose_task_buffer_init;
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(predicate, context, function);
  }
  uint64_t v96 = _firehose_task_buffer;
  BOOL v45 = 1;
  if (_firehose_task_buffer) {
    BOOL v45 = *(_DWORD *)(v96 + 1552) == -1;
  }
  if (!v45)
  {
    uint64_t v101 = v63;
    if ((MEMORY[0xFFFFFC104] & 0x80) != 0 && (v101 & 0x80) == 0) {
      uint64_t v102 = mach_continuous_approximate_time();
    }
    else {
      uint64_t v102 = mach_continuous_time();
    }
    uint64_t v49 = v102;
    for (unint64_t i = 0; i < 2; ++i)
    {
      if (voucher_activity_create_with_data_2_streams[i] == 3)
      {
        unsigned __int8 v17 = voucher_activity_create_with_data_2_streams[i];
        uint64_t v194 = _firehose_task_buffer;
        unint64_t v193 = v49;
        unsigned __int8 v192 = v17;
        unsigned __int16 v191 = v54;
        unsigned __int16 v190 = 0;
        uint64_t v189 = 0;
        char v188 = 1;
        int v187 = (atomic_ullong *)(_firehose_task_buffer + ((unint64_t)v17 << 7) + 640);
        unint64_t v186 = 0;
        unint64_t v185 = 0;
        uint64_t v184 = 0;
        char v183 = 0;
        BOOL v182 = 0;
        uint64_t v181 = 0;
        unsigned __int8 v180 = 0;
        unint64_t v179 = 0;
        unint64_t v178 = *(void *)v187;
        unint64_t v179 = v178;
        unint64_t v177 = v178;
        unint64_t v186 = v178;
        do
        {
          while (1)
          {
            while (1)
            {
              unint64_t v185 = v186;
              unsigned __int8 v180 = BYTE4(v186);
              BOOL v44 = 0;
              if (BYTE4(v186)) {
                BOOL v44 = v180 != 255;
              }
              if (v44)
              {
                uint64_t v205 = v194;
                unsigned __int8 v204 = v180;
                uint64_t v184 = v194 + ((unint64_t)v180 << 12);
                uint64_t v225 = v184;
                unint64_t v224 = v193;
                unsigned __int8 v223 = v192;
                unsigned __int8 v222 = 0;
                unsigned __int16 v221 = v191;
                unsigned __int16 v220 = v190;
                int v219 = v189;
                __int16 v218 = 24;
                unint64_t v217 = 0;
                unint64_t v216 = 0;
                char v215 = 0;
                BOOL v214 = 0;
                BOOL v214 = (v193 - *(void *)(v184 + 8)) >> 48 == 0;
                BOOL v213 = 0;
                unint64_t v212 = (atomic_ullong *)v184;
                unint64_t v217 = *(void *)v184;
                do
                {
                  if (!v217)
                  {
                    uint64_t v226 = 0;
                    goto LABEL_78;
                  }
                  if ((HIWORD(v217) & 0x1FF) != (unint64_t)v223)
                  {
                    uint64_t v226 = 0;
                    goto LABEL_78;
                  }
                  unint64_t v216 = v217;
                  v307 = &v217;
                  unsigned __int16 v306 = v221 + v220 + 24;
                  if ((unsigned __int16)v217 + v306 <= WORD1(v217) && v214)
                  {
                    if (v222 > (int)BYTE5(v216)) {
                      BYTE5(v216) = v222;
                    }
                    if ((((_BYTE)v221 + 24) & 7) != 0) {
                      int v43 = ((v221 + 24) & 0x1FFF8) + 8;
                    }
                    else {
                      int v43 = v221 + 24;
                    }
                    v216 += v43;
                    v216 -= (unint64_t)v220 << 16;
                    v216 += 0x100000000;
                    __int16 v211 = 16;
                    v305 = &v216;
                    __int16 v304 = 40;
                    if ((unsigned __int16)v216 + 40 > WORD1(v216)) {
                      HIBYTE(v216) |= 1u;
                    }
                    char v215 = 0;
                  }
                  else
                  {
                    HIBYTE(v216) |= 1u;
                    char v215 = 1;
                  }
                  unint64_t v210 = v216;
                  unint64_t v18 = v217;
                  unint64_t v19 = v217;
                  atomic_compare_exchange_strong_explicit(v212, &v19, v216, memory_order_relaxed, memory_order_relaxed);
                  if (v19 != v18) {
                    unint64_t v217 = v19;
                  }
                  BOOL v209 = v19 == v18;
                  BOOL v213 = v19 == v18;
                }
                while (v19 != v18);
                BOOL v208 = v213;
                if (v215)
                {
                  if (BYTE4(v216)) {
                    uint64_t v226 = 0;
                  }
                  else {
                    uint64_t v226 = -1;
                  }
                }
                else
                {
                  if (v219) {
                    *int v219 = v225 + WORD1(v216);
                  }
                  uint64_t v226 = (unsigned __int16)v217;
                }
LABEL_78:
                uint64_t v181 = v226;
                if (v226 >= 1)
                {
                  uint64_t v176 = 0;
                  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                  uint64_t v176 = *(void *)(StatusReg - 8);
                  uint64_t v254 = v184;
                  unint64_t v253 = v193;
                  unsigned __int16 v252 = v191;
                  uint64_t v251 = v176;
                  uint64_t v250 = v181;
                  uint64_t v249 = v184 + v181;
                  unint64_t v253 = (v193 - *(void *)(v184 + 8)) | ((unint64_t)v191 << 48);
                  unint64_t v248 = v253;
                  *(void *)(v184 + v181 + 16) = v253;
                  *(void *)(v249 + 8) = v251;
                  uint64_t v195 = (char *)v249;
                  goto LABEL_117;
                }
                if (v181 < 0) {
                  firehose_buffer_ring_enqueue(v194, BYTE4(v186));
                }
                BYTE4(v185) = 0;
              }
              if ((v188 & 1) != 0 || ((v183 & 1) == 0 || (v186 & 0x400000000000) == 0) && !(BYTE5(v186) >> 7)) {
                break;
              }
              if ((BYTE5(v186) & 0x3Fu) + 1 > 0x3E) {
                char v42 = 63;
              }
              else {
                char v42 = (BYTE5(v186) & 0x3F) + 1;
              }
              BYTE5(v185) = BYTE5(v185) & 0xC0 | v42 & 0x3F;
              unint64_t v175 = v186;
              BOOL v174 = 0;
              unint64_t v172 = v185;
              unint64_t v171 = v185;
              unint64_t v173 = v185;
              unint64_t v20 = v186;
              unint64_t v21 = v186;
              atomic_compare_exchange_strong_explicit(v187, &v21, v185, memory_order_relaxed, memory_order_relaxed);
              if (v21 != v20) {
                unint64_t v175 = v21;
              }
              BOOL v170 = v21 == v20;
              BOOL v174 = v21 == v20;
              unint64_t v186 = v175;
              BOOL v169 = v174;
              BOOL v182 = v21 == v20;
              if (v21 == v20)
              {
                unsigned __int8 v268 = v192;
                unsigned __int8 v267 = v180;
                char v266 = v183 & 1;
                unint64_t v265 = v186;
                unint64_t v264 = v185;
                unint64_t v263 = v192 | ((unint64_t)v180 << 8);
                uint64_t v262 = v183 & 1;
                int v337 = 772145156;
                unint64_t v336 = v263;
                uint64_t v335 = v262;
                unint64_t v334 = v186;
                unint64_t v333 = v185;
                if (MEMORY[0xFFFFFC100]) {
                  kdebug_trace();
                }
                uint64_t v195 = 0;
                goto LABEL_117;
              }
            }
            if (!v186) {
              break;
            }
            if (v188) {
              LODWORD(v185) = v185 | 1;
            }
            else {
              LODWORD(v185) = v185 | 2;
            }
            BOOL v168 = v185 == v186;
            BOOL v41 = 1;
            if (v185 != v186)
            {
              unint64_t v167 = v186;
              BOOL v166 = 0;
              unint64_t v164 = v185;
              unint64_t v163 = v185;
              unint64_t v165 = v185;
              unint64_t v22 = v186;
              unint64_t v23 = v186;
              atomic_compare_exchange_strong_explicit(v187, &v23, v185, memory_order_relaxed, memory_order_relaxed);
              if (v23 != v22) {
                unint64_t v167 = v23;
              }
              BOOL v162 = v23 == v22;
              BOOL v166 = v23 == v22;
              unint64_t v186 = v167;
              BOOL v161 = v166;
              BOOL v41 = v23 == v22;
            }
            BOOL v182 = v41;
            if (v41)
            {
              unsigned __int8 v283 = v192;
              unsigned __int8 v282 = v180;
              char v281 = v183 & 1;
              unint64_t v280 = v186;
              unint64_t v279 = v185;
              char v278 = v188 & 1;
              unint64_t v277 = v192 | ((unint64_t)v180 << 8);
              uint64_t v276 = v183 & 1 | (2 * (v188 & 1));
              int v327 = 772145160;
              unint64_t v326 = v277;
              uint64_t v325 = v276;
              unint64_t v324 = v186;
              unint64_t v323 = v185;
              if (MEMORY[0xFFFFFC100]) {
                kdebug_trace();
              }
              _dispatch_firehose_gate_wait((uint64_t)v187, v185);
              char v183 = 1;
              unint64_t v160 = 0;
              unint64_t v159 = *(void *)v187;
              unint64_t v160 = v159;
              unint64_t v158 = v159;
              unint64_t v186 = v159;
            }
          }
          unsigned int v203 = _dispatch_thread_getspecific(3uLL);
          LODWORD(v185) = v203 & 0xFFFFFFFC;
          unint64_t v157 = v186;
          BOOL v156 = 0;
          unint64_t v154 = v185;
          unint64_t v153 = v185;
          unint64_t v155 = v185;
          unint64_t v24 = v186;
          unint64_t v25 = v186;
          atomic_compare_exchange_strong_explicit(v187, &v25, v185, memory_order_relaxed, memory_order_relaxed);
          if (v25 != v24) {
            unint64_t v157 = v25;
          }
          BOOL v152 = v25 == v24;
          BOOL v156 = v25 == v24;
          unint64_t v186 = v157;
          BOOL v151 = v156;
          BOOL v182 = v25 == v24;
        }
        while (v25 != v24);
        unint64_t v149 = v193;
        LOWORD(v15pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v191;
        WORD1(v15pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v190;
        WORD2(v15pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v192;
        HIWORD(v15pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = ((1 << v192) & 0x13) != 0;
        BYTE6(v15pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = (((1 << v192) & 0x13) != 0) | (2 * (*(unsigned char *)(v194 + 1569) & 1));
        BYTE6(v15pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = BYTE6(v150) & 0xFB | (4 * (v188 & 1));
        unint64_t v295 = v193;
        uint64_t v294 = v150;
        unint64_t v293 = v186;
        unint64_t v292 = v185;
        int v317 = 772145164;
        unint64_t v316 = v193;
        uint64_t v315 = v150;
        unint64_t v314 = v186;
        unint64_t v313 = v185;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
        uint64_t v195 = firehose_buffer_tracepoint_reserve_slow(v194, &v149, v189);
LABEL_117:
        uint64_t v50 = (unint64_t *)v195;
      }
      else
      {
        unsigned __int8 v26 = voucher_activity_create_with_data_2_streams[i];
        uint64_t v147 = _firehose_task_buffer;
        unint64_t v146 = v49;
        unsigned __int8 v145 = v26;
        unsigned __int16 v144 = v54;
        unsigned __int16 v143 = 0;
        v142[8] = 0;
        *(void *)unsigned int v142 = v51;
        unsigned int v141 = (atomic_ullong *)(_firehose_task_buffer + ((unint64_t)v26 << 7) + 640);
        unint64_t v140 = *(void *)&v142[1];
        unint64_t v139 = *(void *)&v142[1];
        uint64_t v138 = *(void *)&v142[1];
        char v137 = 0;
        BOOL v136 = 0;
        uint64_t v135 = *(void *)&v142[1];
        unsigned __int8 v134 = 0;
        unint64_t v133 = *(void *)&v142[1];
        unint64_t v132 = *(void *)v141;
        unint64_t v133 = v132;
        unint64_t v131 = v132;
        unint64_t v140 = v132;
        do
        {
          while (1)
          {
            while (1)
            {
              unint64_t v139 = v140;
              unsigned __int8 v134 = BYTE4(v140);
              BOOL v40 = 0;
              if (BYTE4(v140)) {
                BOOL v40 = v134 != 255;
              }
              if (v40)
              {
                uint64_t v207 = v147;
                unsigned __int8 v206 = v134;
                uint64_t v138 = v147 + ((unint64_t)v134 << 12);
                uint64_t v244 = v138;
                unint64_t v243 = v146;
                unsigned __int8 v242 = v145;
                unsigned __int8 v241 = 0;
                unsigned __int16 v240 = v144;
                unsigned __int16 v239 = v143;
                uint64_t v238 = *(void **)&v142[1];
                __int16 v237 = 24;
                unint64_t v236 = 0;
                unint64_t v235 = 0;
                char v234 = 0;
                BOOL v233 = 0;
                BOOL v233 = (v146 - *(void *)(v138 + 8)) >> 48 == 0;
                BOOL v232 = 0;
                mach_port_name_t v231 = (atomic_ullong *)v138;
                unint64_t v236 = *(void *)v138;
                do
                {
                  if (!v236)
                  {
                    uint64_t v245 = 0;
                    goto LABEL_148;
                  }
                  if ((HIWORD(v236) & 0x1FF) != (unint64_t)v242)
                  {
                    uint64_t v245 = 0;
                    goto LABEL_148;
                  }
                  unint64_t v235 = v236;
                  v303 = &v236;
                  unsigned __int16 v302 = v240 + v239 + 24;
                  if ((unsigned __int16)v236 + v302 <= WORD1(v236) && v233)
                  {
                    if (v241 > (int)BYTE5(v235)) {
                      BYTE5(v235) = v241;
                    }
                    if ((((_BYTE)v240 + 24) & 7) != 0) {
                      int v39 = ((v240 + 24) & 0x1FFF8) + 8;
                    }
                    else {
                      int v39 = v240 + 24;
                    }
                    v235 += v39;
                    v235 -= (unint64_t)v239 << 16;
                    v235 += 0x100000000;
                    __int16 v230 = 16;
                    v301 = &v235;
                    __int16 v300 = 40;
                    if ((unsigned __int16)v235 + 40 > WORD1(v235)) {
                      HIBYTE(v235) |= 1u;
                    }
                    char v234 = 0;
                  }
                  else
                  {
                    HIBYTE(v235) |= 1u;
                    char v234 = 1;
                  }
                  unint64_t v229 = v235;
                  unint64_t v27 = v236;
                  unint64_t v28 = v236;
                  atomic_compare_exchange_strong_explicit(v231, &v28, v235, memory_order_relaxed, memory_order_relaxed);
                  if (v28 != v27) {
                    unint64_t v236 = v28;
                  }
                  BOOL v228 = v28 == v27;
                  BOOL v232 = v28 == v27;
                }
                while (v28 != v27);
                BOOL v227 = v232;
                if (v234)
                {
                  if (BYTE4(v235)) {
                    uint64_t v245 = 0;
                  }
                  else {
                    uint64_t v245 = -1;
                  }
                }
                else
                {
                  if (v238) {
                    void *v238 = v244 + WORD1(v235);
                  }
                  uint64_t v245 = (unsigned __int16)v236;
                }
LABEL_148:
                uint64_t v135 = v245;
                if (v245 >= 1)
                {
                  uint64_t v130 = 0;
                  unint64_t v247 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                  uint64_t v130 = *(void *)(v247 - 8);
                  uint64_t v261 = v138;
                  unint64_t v260 = v146;
                  unsigned __int16 v259 = v144;
                  uint64_t v258 = v130;
                  uint64_t v257 = v135;
                  uint64_t v256 = v138 + v135;
                  unint64_t v260 = (v146 - *(void *)(v138 + 8)) | ((unint64_t)v144 << 48);
                  unint64_t v255 = v260;
                  *(void *)(v138 + v135 + 16) = v260;
                  *(void *)(v256 + 8) = v258;
                  long long v148 = (char *)v256;
                  goto LABEL_187;
                }
                if (v135 < 0) {
                  firehose_buffer_ring_enqueue(v147, BYTE4(v140));
                }
                BYTE4(v139) = 0;
              }
              if ((v142[0] & 1) != 0 || ((v137 & 1) == 0 || (v140 & 0x400000000000) == 0) && !(BYTE5(v140) >> 7)) {
                break;
              }
              if ((BYTE5(v140) & 0x3Fu) + 1 > 0x3E) {
                char v38 = 63;
              }
              else {
                char v38 = (BYTE5(v140) & 0x3F) + 1;
              }
              BYTE5(v139) = BYTE5(v139) & 0xC0 | v38 & 0x3F;
              unint64_t v129 = v140;
              BOOL v128 = 0;
              unint64_t v126 = v139;
              unint64_t v125 = v139;
              unint64_t v127 = v139;
              unint64_t v29 = v140;
              unint64_t v30 = v140;
              atomic_compare_exchange_strong_explicit(v141, &v30, v139, memory_order_relaxed, memory_order_relaxed);
              if (v30 != v29) {
                unint64_t v129 = v30;
              }
              BOOL v124 = v30 == v29;
              BOOL v128 = v30 == v29;
              unint64_t v140 = v129;
              BOOL v123 = v128;
              BOOL v136 = v30 == v29;
              if (v30 == v29)
              {
                unsigned __int8 v275 = v145;
                unsigned __int8 v274 = v134;
                char v273 = v137 & 1;
                unint64_t v272 = v140;
                unint64_t v271 = v139;
                unint64_t v270 = v145 | ((unint64_t)v134 << 8);
                uint64_t v269 = v137 & 1;
                int v332 = 772145156;
                unint64_t v331 = v270;
                uint64_t v330 = v269;
                unint64_t v329 = v140;
                unint64_t v328 = v139;
                if (MEMORY[0xFFFFFC100]) {
                  kdebug_trace();
                }
                long long v148 = 0;
                goto LABEL_187;
              }
            }
            if (!v140) {
              break;
            }
            if (v142[0]) {
              LODWORD(v139) = v139 | 1;
            }
            else {
              LODWORD(v139) = v139 | 2;
            }
            BOOL v122 = v139 == v140;
            BOOL v37 = 1;
            if (v139 != v140)
            {
              unint64_t v121 = v140;
              BOOL v120 = 0;
              unint64_t v118 = v139;
              unint64_t v117 = v139;
              unint64_t v119 = v139;
              unint64_t v31 = v140;
              unint64_t v32 = v140;
              atomic_compare_exchange_strong_explicit(v141, &v32, v139, memory_order_relaxed, memory_order_relaxed);
              if (v32 != v31) {
                unint64_t v121 = v32;
              }
              BOOL v116 = v32 == v31;
              BOOL v120 = v32 == v31;
              unint64_t v140 = v121;
              BOOL v115 = v120;
              BOOL v37 = v32 == v31;
            }
            BOOL v136 = v37;
            if (v37)
            {
              unsigned __int8 v291 = v145;
              unsigned __int8 v290 = v134;
              char v289 = v137 & 1;
              unint64_t v288 = v140;
              unint64_t v287 = v139;
              char v286 = v142[0] & 1;
              unint64_t v285 = v145 | ((unint64_t)v134 << 8);
              uint64_t v284 = v137 & 1 | (2 * (v142[0] & 1));
              int v322 = 772145160;
              unint64_t v321 = v285;
              uint64_t v320 = v284;
              unint64_t v319 = v140;
              unint64_t v318 = v139;
              if (MEMORY[0xFFFFFC100]) {
                kdebug_trace();
              }
              _dispatch_firehose_gate_wait((uint64_t)v141, v139);
              char v137 = 1;
              unint64_t v114 = 0;
              unint64_t v113 = *(void *)v141;
              unint64_t v114 = v113;
              unint64_t v112 = v113;
              unint64_t v140 = v113;
            }
          }
          unsigned int v202 = _dispatch_thread_getspecific(3uLL);
          LODWORD(v139) = v202 & 0xFFFFFFFC;
          unint64_t v111 = v140;
          BOOL v110 = 0;
          unint64_t v108 = v139;
          unint64_t v107 = v139;
          unint64_t v109 = v139;
          unint64_t v33 = v140;
          unint64_t v34 = v140;
          atomic_compare_exchange_strong_explicit(v141, &v34, v139, memory_order_relaxed, memory_order_relaxed);
          if (v34 != v33) {
            unint64_t v111 = v34;
          }
          BOOL v106 = v34 == v33;
          BOOL v110 = v34 == v33;
          unint64_t v140 = v111;
          BOOL v105 = v110;
          BOOL v136 = v34 == v33;
        }
        while (v34 != v33);
        unint64_t v103 = v146;
        LOWORD(v104) = v144;
        WORD1(v104) = v143;
        WORD2(v104) = v145;
        HIWORD(v104) = ((1 << v145) & 0x13) != 0;
        BYTE6(v104) = (((1 << v145) & 0x13) != 0) | (2 * (*(unsigned char *)(v147 + 1569) & 1));
        BYTE6(v104) = BYTE6(v104) & 0xFB | (4 * (v142[0] & 1));
        unint64_t v299 = v146;
        uint64_t v298 = v104;
        unint64_t v297 = v140;
        unint64_t v296 = v139;
        int v312 = 772145164;
        unint64_t v311 = v146;
        uint64_t v310 = v104;
        unint64_t v309 = v140;
        unint64_t v308 = v139;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
        long long v148 = firehose_buffer_tracepoint_reserve_slow(v147, &v103, *(void **)&v142[1]);
LABEL_187:
        uint64_t v50 = (unint64_t *)v148;
      }
      if (v50)
      {
        unsigned int v47 = v50 + 3;
        if (v58)
        {
          __int16 v87 = v50 + 3;
          uint64_t v86 = &v58;
          uint64_t v85 = 8;
          __memcpy_chk();
          unsigned int v47 = &v87[(unint64_t)v85 / 8];
        }
        if (v55)
        {
          __int16 v84 = v47;
          int v83 = &v55;
          uint64_t v82 = 8;
          __memcpy_chk();
          unsigned int v47 = &v84[(unint64_t)v82 / 8];
        }
        if (v57)
        {
          uint64_t v81 = v47;
          char v80 = &v57;
          uint64_t v79 = 8;
          __memcpy_chk();
          unsigned int v47 = &v81[(unint64_t)v79 / 8];
        }
        BOOL v78 = v47;
        uint64_t v77 = &v59;
        uint64_t v76 = 8;
        __memcpy_chk();
        uint64_t v75 = &v78[(unint64_t)v76 / 8];
        uint64_t v74 = v62;
        unint64_t v73 = v61;
        __memcpy_chk();
        unint64_t v199 = v56;
        mach_port_context_t v198 = _firehose_task_buffer;
        uint64_t v197 = v50;
        uint64_t v201 = v50;
        unint64_t v200 = (unint64_t)v50 & 0xFFFFFFFFFFFFF000;
        unint64_t v196 = (unint64_t)v50 & 0xFFFFFFFFFFFFF000;
        unint64_t v344 = v56;
        v343 = (atomic_ullong *)((unint64_t)v50 & 0xFFFFFFFFFFFFF000);
        v342 = v50;
        unint64_t v341 = 0;
        unint64_t v340 = v56;
        atomic_store(v56, v50);
        uint64_t v339 = 0x100000000;
        unint64_t add_explicit = atomic_fetch_add_explicit(v343, 0xFFFFFFFF00000000, memory_order_relaxed);
        unint64_t v341 = add_explicit;
        char v36 = 0;
        if (BYTE4(add_explicit) == 1) {
          char v36 = HIBYTE(v341) & 1;
        }
        if (v36)
        {
          mach_port_context_t v346 = v198;
          unint64_t v345 = v196;
          firehose_buffer_ring_enqueue(v198, (v196 - v198) >> 12);
        }
      }
    }
  }
  *long long v65 = v56;
  return v52;
}

void *voucher_activity_create_with_data(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return voucher_activity_create_with_data_2(a1, a2, a3, a4, a5, 0);
}

void *voucher_activity_create_with_location(unint64_t *a1, void *a2, uint64_t a3, uint64_t a4)
{
  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  return voucher_activity_create_with_data(a1, a2, a3, (uint64_t)v5, 8uLL);
}

uint64_t voucher_get_activity_id_and_creator(void *a1, void *a2, void *a3)
{
  uint64_t v6 = a1;
  if (a1 == (void *)-3) {
    uint64_t v6 = _dispatch_thread_getspecific(0x1CuLL);
  }
  if (v6)
  {
    if (a2) {
      *a2 = v6[7];
    }
    if (a3) {
      *a3 = v6[8];
    }
    return v6[6];
  }
  else
  {
    if (a2) {
      *a2 = 0;
    }
    if (a3) {
      *a3 = 0;
    }
    return 0;
  }
}

uint64_t voucher_get_activity_id(void *a1, void *a2)
{
  return voucher_get_activity_id_and_creator(a1, 0, a2);
}

void voucher_activity_flush(unsigned __int8 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  }
  BOOL v12 = 1;
  if (_firehose_task_buffer) {
    BOOL v12 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  }
  if (!v12)
  {
    mach_port_context_t v18 = _firehose_task_buffer;
    unsigned __int8 v17 = (atomic_ullong *)(_firehose_task_buffer + ((unint64_t)a1 << 7) + 640);
    unint64_t v16 = *(void *)v17;
    if (BYTE4(*(void *)v17) && BYTE4(v16) != 255)
    {
      unint64_t v31 = (atomic_ullong *)(_firehose_task_buffer + ((unint64_t)BYTE4(v16) << 12));
      uint64_t v30 = -1;
      unsigned __int8 v29 = a1;
      unsigned __int8 v28 = 0;
      unsigned __int16 v27 = 1;
      unsigned __int16 v26 = 0;
      unint64_t v25 = 0;
      __int16 v24 = 24;
      unint64_t i = 0;
      unint64_t v22 = 0;
      BOOL v20 = (unint64_t)(-1 - *((void *)v31 + 1)) >> 48 == 0;
      unint64_t v19 = v31;
      for (unint64_t i = *(void *)v31; ; unint64_t i = v9)
      {
        if (!i)
        {
          uint64_t v32 = 0;
          goto LABEL_34;
        }
        if ((HIWORD(i) & 0x1FF) != (unint64_t)v29)
        {
          uint64_t v32 = 0;
          goto LABEL_34;
        }
        unint64_t v22 = i;
        p_unint64_t i = &i;
        unsigned __int16 v35 = v27 + v26 + 24;
        if ((unsigned __int16)i + v35 <= WORD1(i) && v20)
        {
          if (v28 > (int)BYTE5(v22)) {
            BYTE5(v22) = v28;
          }
          if ((((_BYTE)v27 + 24) & 7) != 0) {
            int v11 = ((v27 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v11 = v27 + 24;
          }
          v22 += v11;
          v22 -= (unint64_t)v26 << 16;
          v22 += 0x100000000;
          unint64_t v34 = &v22;
          __int16 v33 = 40;
          if ((unsigned __int16)v22 + 40 > WORD1(v22)) {
            HIBYTE(v22) |= 1u;
          }
          char v21 = 0;
        }
        else
        {
          HIBYTE(v22) |= 1u;
          char v21 = 1;
        }
        unint64_t v8 = i;
        unint64_t v9 = i;
        atomic_compare_exchange_strong_explicit(v19, &v9, v22, memory_order_relaxed, memory_order_relaxed);
        if (v9 == v8) {
          break;
        }
      }
      if (v21)
      {
        if (BYTE4(v22)) {
          uint64_t v32 = 0;
        }
        else {
          uint64_t v32 = -1;
        }
      }
      else
      {
        if (v25) {
          *unint64_t v25 = (char *)v31 + WORD1(v22);
        }
        uint64_t v32 = (unsigned __int16)i;
      }
LABEL_34:
      uint64_t v14 = v32;
      if (v32 < 0) {
        firehose_buffer_ring_enqueue(v18, BYTE4(v16));
      }
      if (v14 >= 1)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_F42C0 = v14;
        __break(1u);
        JUMPOUT(0xA2670);
      }
      unint64_t v15 = v16;
      BYTE4(v15) = 0;
      unint64_t v10 = v16;
      atomic_compare_exchange_strong_explicit(v17, &v10, v15, memory_order_relaxed, memory_order_relaxed);
    }
    else
    {
      firehose_buffer_force_connect(_firehose_task_buffer, a2, a3, a4, a5, a6, a7, a8);
    }
  }
}

unint64_t voucher_activity_trace_v_2(unsigned __int8 a1, unint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6, int a7)
{
  unsigned __int8 v55 = a1;
  unint64_t v54 = a2;
  uint64_t v53 = a3;
  uint64_t v52 = a4;
  unint64_t v51 = a5;
  unint64_t v50 = a6;
  int v49 = a7;
  unint64_t v48 = a2;
  __int16 v47 = 24;
  uint64_t v46 = 4080;
  BOOL v45 = (a7 & 1) == 0;
  uint64_t v75 = &_firehose_task_buffer_pred;
  uint64_t v74 = 0;
  unint64_t v73 = _firehose_task_buffer_init;
  if (_firehose_task_buffer_pred != -1) {
    dispatch_once_f(v75, v74, (dispatch_function_t)v73);
  }
  uint64_t v72 = _firehose_task_buffer;
  BOOL v34 = 1;
  if (_firehose_task_buffer) {
    BOOL v34 = *(_DWORD *)(v72 + 1552) == -1;
  }
  if (v34) {
    return 0;
  }
  BOOL v44 = 0;
  uint64_t v43 = 0;
  unint64_t v42 = 0;
  uint64_t v41 = 0;
  BOOL v40 = 0;
  unint64_t v39 = v51;
  char v38 = _dispatch_thread_getspecific(0x1CuLL);
  uint64_t v37 = 0;
  uint64_t v130 = v38;
  unint64_t v129 = &v37;
  if (&v37)
  {
    if (v130) {
      uint64_t v33 = v130[7];
    }
    else {
      uint64_t v33 = 0;
    }
    *unint64_t v129 = v33;
  }
  if (v130) {
    uint64_t v32 = v130[6];
  }
  else {
    uint64_t v32 = 0;
  }
  uint64_t v43 = v32;
  if (v32)
  {
    WORD1(v48) |= 1u;
    v39 += 8;
  }
  if ((v48 & 0x100000) != 0)
  {
    if (v37) {
      v39 += 8;
    }
    else {
      WORD1(v48) &= ~0x10u;
    }
  }
  else
  {
    uint64_t v37 = 0;
  }
  if (v50)
  {
    WORD1(v48) |= 0x100u;
    v39 += 4;
  }
  if (v39 + v50 + 24 >= 0xFF1)
  {
    uint64_t v36 = v39 + v50 + 24;
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Log is too large";
    qword_F42C0 = v36;
    __break(1u);
    JUMPOUT(0xA2A3CLL);
  }
  uint64_t v123 = _firehose_task_buffer;
  uint64_t v122 = v53;
  unsigned __int8 v121 = v55;
  unsigned __int16 v120 = v39;
  unsigned __int16 v119 = v50;
  unint64_t v118 = &v41;
  BOOL v117 = v45;
  BOOL v116 = (atomic_ullong *)(_firehose_task_buffer + ((unint64_t)v55 << 7) + 640);
  unint64_t v115 = 0;
  unint64_t v114 = 0;
  uint64_t v113 = 0;
  char v112 = 0;
  BOOL v111 = 0;
  uint64_t v110 = 0;
  unsigned __int8 v109 = 0;
  unint64_t v108 = 0;
  unint64_t v107 = *(void *)v116;
  unint64_t v108 = v107;
  unint64_t v106 = v107;
  unint64_t v115 = v107;
  do
  {
    while (1)
    {
      while (1)
      {
        unint64_t v114 = v115;
        unsigned __int8 v109 = BYTE4(v115);
        BOOL v31 = 0;
        if (BYTE4(v115)) {
          BOOL v31 = v109 != 255;
        }
        if (v31)
        {
          uint64_t v137 = v123;
          unsigned __int8 v136 = v109;
          uint64_t v113 = v123 + ((unint64_t)v109 << 12);
          uint64_t v155 = v113;
          uint64_t v154 = v122;
          unsigned __int8 v153 = v121;
          unsigned __int8 v152 = 0;
          unsigned __int16 v151 = v120;
          unsigned __int16 v150 = v119;
          unint64_t v149 = v118;
          __int16 v148 = 24;
          unint64_t v147 = 0;
          unint64_t v146 = 0;
          char v145 = 0;
          BOOL v144 = 0;
          BOOL v144 = (unint64_t)(v122 - *(void *)(v113 + 8)) >> 48 == 0;
          BOOL v143 = 0;
          unsigned int v142 = (atomic_ullong *)v113;
          unint64_t v147 = *(void *)v113;
          do
          {
            if (!v147)
            {
              uint64_t v156 = 0;
              goto LABEL_56;
            }
            if ((HIWORD(v147) & 0x1FF) != (unint64_t)v153)
            {
              uint64_t v156 = 0;
              goto LABEL_56;
            }
            unint64_t v146 = v147;
            int v187 = &v147;
            unsigned __int16 v186 = v151 + v150 + 24;
            if ((unsigned __int16)v147 + v186 <= WORD1(v147) && v144)
            {
              if (v152 > (int)BYTE5(v146)) {
                BYTE5(v146) = v152;
              }
              if ((((_BYTE)v151 + 24) & 7) != 0) {
                int v30 = ((v151 + 24) & 0x1FFF8) + 8;
              }
              else {
                int v30 = v151 + 24;
              }
              v146 += v30;
              v146 -= (unint64_t)v150 << 16;
              v146 += 0x100000000;
              __int16 v141 = 16;
              unint64_t v185 = &v146;
              __int16 v184 = 40;
              if ((unsigned __int16)v146 + 40 > WORD1(v146)) {
                HIBYTE(v146) |= 1u;
              }
              char v145 = 0;
            }
            else
            {
              HIBYTE(v146) |= 1u;
              char v145 = 1;
            }
            unint64_t v140 = v146;
            unint64_t v7 = v147;
            unint64_t v8 = v147;
            atomic_compare_exchange_strong_explicit(v142, &v8, v146, memory_order_relaxed, memory_order_relaxed);
            if (v8 != v7) {
              unint64_t v147 = v8;
            }
            BOOL v139 = v8 == v7;
            BOOL v143 = v8 == v7;
          }
          while (v8 != v7);
          BOOL v138 = v143;
          if (v145)
          {
            if (BYTE4(v146)) {
              uint64_t v156 = 0;
            }
            else {
              uint64_t v156 = -1;
            }
          }
          else
          {
            if (v149) {
              *unint64_t v149 = v155 + WORD1(v146);
            }
            uint64_t v156 = (unsigned __int16)v147;
          }
LABEL_56:
          uint64_t v110 = v156;
          if (v156 >= 1)
          {
            unint64_t v105 = 0;
            unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            unint64_t v105 = *(void *)(StatusReg - 8);
            uint64_t v164 = v113;
            uint64_t v163 = v122;
            unsigned __int16 v162 = v120;
            unint64_t v161 = v105;
            uint64_t v160 = v110;
            unint64_t v159 = (unint64_t *)(v113 + v110);
            uint64_t v163 = v122 - *(void *)(v113 + 8);
            v163 |= (unint64_t)v120 << 48;
            uint64_t v158 = v163;
            *(void *)(v113 + v110 + 16) = v163;
            v159[1] = v161;
            BOOL v124 = v159;
            goto LABEL_95;
          }
          if (v110 < 0) {
            firehose_buffer_ring_enqueue(v123, BYTE4(v115));
          }
          BYTE4(v114) = 0;
        }
        if (v117 || ((v112 & 1) == 0 || (v115 & 0x400000000000) == 0) && !(BYTE5(v115) >> 7)) {
          break;
        }
        if ((BYTE5(v115) & 0x3Fu) + 1 > 0x3E) {
          char v29 = 63;
        }
        else {
          char v29 = (BYTE5(v115) & 0x3F) + 1;
        }
        BYTE5(v114) = BYTE5(v114) & 0xC0 | v29 & 0x3F;
        unint64_t v104 = v115;
        BOOL v103 = 0;
        unint64_t v101 = v114;
        unint64_t v100 = v114;
        unint64_t v102 = v114;
        unint64_t v9 = v115;
        unint64_t v10 = v115;
        atomic_compare_exchange_strong_explicit(v116, &v10, v114, memory_order_relaxed, memory_order_relaxed);
        if (v10 != v9) {
          unint64_t v104 = v10;
        }
        BOOL v99 = v10 == v9;
        BOOL v103 = v10 == v9;
        unint64_t v115 = v104;
        BOOL v98 = v103;
        BOOL v111 = v10 == v9;
        if (v10 == v9)
        {
          unsigned __int8 v171 = v121;
          unsigned __int8 v170 = v109;
          char v169 = v112 & 1;
          unint64_t v168 = v115;
          unint64_t v167 = v114;
          unint64_t v166 = v121 | ((unint64_t)v109 << 8);
          uint64_t v165 = v112 & 1;
          int v202 = 772145156;
          unint64_t v201 = v166;
          uint64_t v200 = v165;
          unint64_t v199 = v115;
          unint64_t v198 = v114;
          if (MEMORY[0xFFFFFC100]) {
            kdebug_trace();
          }
          BOOL v124 = 0;
          goto LABEL_95;
        }
      }
      if (!v115) {
        break;
      }
      if (v117) {
        LODWORD(v114) = v114 | 1;
      }
      else {
        LODWORD(v114) = v114 | 2;
      }
      BOOL v97 = v114 == v115;
      BOOL v28 = 1;
      if (v114 != v115)
      {
        unint64_t v96 = v115;
        BOOL v95 = 0;
        unint64_t v93 = v114;
        unint64_t v92 = v114;
        unint64_t v94 = v114;
        unint64_t v11 = v115;
        unint64_t v12 = v115;
        atomic_compare_exchange_strong_explicit(v116, &v12, v114, memory_order_relaxed, memory_order_relaxed);
        if (v12 != v11) {
          unint64_t v96 = v12;
        }
        BOOL v91 = v12 == v11;
        BOOL v95 = v12 == v11;
        unint64_t v115 = v96;
        BOOL v90 = v95;
        BOOL v28 = v12 == v11;
      }
      BOOL v111 = v28;
      if (v28)
      {
        unsigned __int8 v179 = v121;
        unsigned __int8 v178 = v109;
        char v177 = v112 & 1;
        unint64_t v176 = v115;
        unint64_t v175 = v114;
        BOOL v174 = v117;
        unint64_t v173 = v121 | ((unint64_t)v109 << 8);
        uint64_t v172 = v112 & 1 | (2 * v117);
        int v197 = 772145160;
        unint64_t v196 = v173;
        uint64_t v195 = v172;
        unint64_t v194 = v115;
        unint64_t v193 = v114;
        if (MEMORY[0xFFFFFC100]) {
          kdebug_trace();
        }
        _dispatch_firehose_gate_wait((uint64_t)v116, v114);
        char v112 = 1;
        unint64_t v89 = 0;
        unint64_t v88 = *(void *)v116;
        unint64_t v89 = v88;
        unint64_t v87 = v88;
        unint64_t v115 = v88;
      }
    }
    unsigned int v135 = _dispatch_thread_getspecific(3uLL);
    LODWORD(v114) = v135 & 0xFFFFFFFC;
    unint64_t v86 = v115;
    BOOL v85 = 0;
    unint64_t v83 = v114;
    unint64_t v82 = v114;
    unint64_t v84 = v114;
    unint64_t v13 = v115;
    unint64_t v14 = v115;
    atomic_compare_exchange_strong_explicit(v116, &v14, v114, memory_order_relaxed, memory_order_relaxed);
    if (v14 != v13) {
      unint64_t v86 = v14;
    }
    BOOL v81 = v14 == v13;
    BOOL v85 = v14 == v13;
    unint64_t v115 = v86;
    BOOL v80 = v85;
    BOOL v111 = v14 == v13;
  }
  while (v14 != v13);
  uint64_t v78 = v122;
  LOWORD(v79) = v120;
  WORD1(v79) = v119;
  WORD2(v79) = v121;
  HIWORD(v79) = ((1 << v121) & 0x13) != 0;
  BYTE6(v79) = (((1 << v121) & 0x13) != 0) | (2 * (*(unsigned char *)(v123 + 1569) & 1));
  BYTE6(v79) = BYTE6(v79) & 0xFB | (4 * v117);
  uint64_t v183 = v122;
  uint64_t v182 = v79;
  unint64_t v181 = v115;
  unint64_t v180 = v114;
  int v192 = 772145164;
  uint64_t v191 = v122;
  uint64_t v190 = v79;
  unint64_t v189 = v115;
  unint64_t v188 = v114;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  BOOL v124 = (unint64_t *)firehose_buffer_tracepoint_reserve_slow(v123, &v78, v118);
LABEL_95:
  BOOL v44 = v124;
  if (!v124) {
    return 0;
  }
  BOOL v40 = v44 + 3;
  if (v43)
  {
    uint64_t v71 = v40;
    __int16 v70 = &v43;
    uint64_t v69 = 8;
    __memcpy_chk();
    BOOL v40 = &v71[(unint64_t)v69 / 8];
  }
  if (v37)
  {
    uint64_t v68 = v40;
    __int16 v67 = &v37;
    uint64_t v66 = 8;
    __memcpy_chk();
    BOOL v40 = &v68[(unint64_t)v66 / 8];
  }
  if (v50)
  {
    unsigned __int8 v134 = v44;
    unint64_t v133 = (unint64_t)v44 & 0xFFFFFFFFFFFFF000;
    unint64_t v42 = (unint64_t)v44 & 0xFFFFFFFFFFFFF000;
    v35[0] = v41 - ((unsigned __int16)v44 & 0xF000);
    v35[1] = v50;
    long long v65 = v40;
    uint64_t v64 = v35;
    uint64_t v63 = 4;
    __memcpy_chk();
    BOOL v40 = (unint64_t *)((char *)v65 + v63);
  }
  while (v51)
  {
    uint64_t v15 = *v52;
    uint64_t v16 = v52[1];
    uint64_t v62 = v40;
    uint64_t v61 = v15;
    uint64_t v60 = v16;
    __memcpy_chk();
    BOOL v40 = (unint64_t *)((char *)v62 + v60);
    unint64_t v17 = v52[1];
    BOOL v18 = v51 >= v17;
    unint64_t v19 = v51 - v17;
    char v20 = !v18;
    unint64_t v51 = v19;
    char v77 = v20;
    if (v20)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid arguments";
      __break(1u);
      JUMPOUT(0xA3878);
    }
    v52 += 2;
  }
  while (v50)
  {
    uint64_t v21 = *v52;
    uint64_t v22 = v52[1];
    uint64_t v59 = v41;
    uint64_t v58 = v21;
    uint64_t v57 = v22;
    __memcpy_chk();
    uint64_t v41 = v59 + v57;
    unint64_t v23 = v52[1];
    BOOL v18 = v50 >= v23;
    unint64_t v24 = v50 - v23;
    char v25 = !v18;
    unint64_t v50 = v24;
    char v76 = v25;
    if (v25)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid arguments";
      __break(1u);
      JUMPOUT(0xA3938);
    }
    v52 += 2;
  }
  unint64_t v128 = v48;
  uint64_t v127 = _firehose_task_buffer;
  unint64_t v126 = v44;
  unint64_t v132 = v44;
  unint64_t v131 = (unint64_t)v44 & 0xFFFFFFFFFFFFF000;
  unint64_t v125 = (unint64_t)v44 & 0xFFFFFFFFFFFFF000;
  unint64_t v209 = v48;
  BOOL v208 = (atomic_ullong *)((unint64_t)v44 & 0xFFFFFFFFFFFFF000);
  uint64_t v207 = v44;
  unint64_t v206 = 0;
  unint64_t v205 = v48;
  atomic_store(v48, v44);
  uint64_t v204 = 0x100000000;
  unint64_t add_explicit = atomic_fetch_add_explicit(v208, 0xFFFFFFFF00000000, memory_order_relaxed);
  unint64_t v206 = add_explicit;
  char v27 = 0;
  if (BYTE4(add_explicit) == 1) {
    char v27 = HIBYTE(v206) & 1;
  }
  if (v27)
  {
    mach_port_context_t v211 = v127;
    unint64_t v210 = v125;
    firehose_buffer_ring_enqueue(v211, (v125 - v211) >> 12);
  }
  return v48;
}

unint64_t voucher_activity_trace_v(unsigned __int8 a1, unint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6)
{
  return voucher_activity_trace_v_2(a1, a2, a3, a4, a5, a6, 0);
}

unint64_t voucher_activity_trace(unsigned __int8 a1, unint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unsigned __int8 v7 = a1;
  v6[5] = a2;
  v6[4] = a3;
  v6[3] = a4;
  v6[2] = a5;
  v6[0] = a4;
  v6[1] = a5;
  return voucher_activity_trace_v(a1, a2, a3, v6, a5, 0);
}

unint64_t format_recipe_detail(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, const char *a5, unint64_t a6)
{
  unint64_t v51 = a4;
  if (a5)
  {
    if (a3 <= a4) {
      size_t v38 = 0;
    }
    else {
      size_t v38 = a3 - a4;
    }
    int v48 = __snprintf_chk((char *)(a2 + a4), v38, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
    if (v48 >= 0)
    {
      if (v48 <= v38) {
        size_t v36 = v48;
      }
      else {
        size_t v36 = v38;
      }
      size_t v37 = v36;
    }
    else
    {
      size_t v37 = 0;
    }
    v51 += v37;
  }
  if (a3 <= v51) {
    size_t v35 = 0;
  }
  else {
    size_t v35 = a3 - v51;
  }
  int v47 = __snprintf_chk((char *)(a2 + v51), v35, 0, 0xFFFFFFFFFFFFFFFFLL, "Key: %u, ", *(_DWORD *)a1);
  if (v47 >= 0)
  {
    if (v47 <= v35) {
      size_t v33 = v47;
    }
    else {
      size_t v33 = v35;
    }
    size_t v34 = v33;
  }
  else
  {
    size_t v34 = 0;
  }
  unint64_t v52 = v51 + v34;
  if (a3 <= v52) {
    size_t v32 = 0;
  }
  else {
    size_t v32 = a3 - v52;
  }
  int v46 = __snprintf_chk((char *)(a2 + v52), v32, 0, 0xFFFFFFFFFFFFFFFFLL, "Command: %u, ", *(_DWORD *)(a1 + 4));
  if (v46 >= 0)
  {
    if (v46 <= v32) {
      size_t v30 = v46;
    }
    else {
      size_t v30 = v32;
    }
    size_t v31 = v30;
  }
  else
  {
    size_t v31 = 0;
  }
  unint64_t v53 = v52 + v31;
  if (a3 <= v53) {
    size_t v29 = 0;
  }
  else {
    size_t v29 = a3 - v53;
  }
  int v45 = __snprintf_chk((char *)(a2 + v53), v29, 0, 0xFFFFFFFFFFFFFFFFLL, "Previous voucher: 0x%x, ", *(_DWORD *)(a1 + 8));
  if (v45 >= 0)
  {
    if (v45 <= v29) {
      size_t v27 = v45;
    }
    else {
      size_t v27 = v29;
    }
    size_t v28 = v27;
  }
  else
  {
    size_t v28 = 0;
  }
  unint64_t v54 = v53 + v28;
  if (a3 <= v54) {
    size_t v26 = 0;
  }
  else {
    size_t v26 = a3 - v54;
  }
  int v44 = __snprintf_chk((char *)(a2 + v54), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "Content size: %u\n", *(_DWORD *)(a1 + 12));
  if (v44 >= 0)
  {
    if (v44 <= v26) {
      size_t v24 = v44;
    }
    else {
      size_t v24 = v26;
    }
    size_t v25 = v24;
  }
  else
  {
    size_t v25 = 0;
  }
  unint64_t v55 = v54 + v25;
  if (*(_DWORD *)a1 == 2)
  {
    if (a5)
    {
      if (a3 <= v55) {
        size_t v23 = 0;
      }
      else {
        size_t v23 = a3 - v55;
      }
      int v43 = __snprintf_chk((char *)(a2 + v55), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
      if (v43 >= 0)
      {
        if (v43 <= v23) {
          size_t v21 = v43;
        }
        else {
          size_t v21 = v23;
        }
        size_t v22 = v21;
      }
      else
      {
        size_t v22 = 0;
      }
      v55 += v22;
    }
    if (a3 <= v55) {
      size_t v20 = 0;
    }
    else {
      size_t v20 = a3 - v55;
    }
    int v42 = __snprintf_chk((char *)(a2 + v55), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "IMPORTANCE INFO: %s", (const char *)(a1 + 16));
    if (v42 >= 0)
    {
      if (v42 <= v20) {
        size_t v18 = v42;
      }
      else {
        size_t v18 = v20;
      }
      size_t v19 = v18;
    }
    else
    {
      size_t v19 = 0;
    }
    unint64_t v56 = v55 + v19;
  }
  else if (*(_DWORD *)a1 == 3)
  {
    if (a5)
    {
      if (a3 <= v55) {
        size_t v17 = 0;
      }
      else {
        size_t v17 = a3 - v55;
      }
      int v41 = __snprintf_chk((char *)(a2 + v55), v17, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
      if (v41 >= 0)
      {
        if (v41 <= v17) {
          size_t v15 = v41;
        }
        else {
          size_t v15 = v17;
        }
        size_t v16 = v15;
      }
      else
      {
        size_t v16 = 0;
      }
      v55 += v16;
    }
    if (a3 <= v55) {
      size_t v14 = 0;
    }
    else {
      size_t v14 = a3 - v55;
    }
    int v40 = __snprintf_chk((char *)(a2 + v55), v14, 0, 0xFFFFFFFFFFFFFFFFLL, "RESOURCE ACCOUNTING INFO: %s", (const char *)(a1 + 16));
    if (v40 >= 0)
    {
      if (v40 <= v14) {
        size_t v12 = v40;
      }
      else {
        size_t v12 = v14;
      }
      size_t v13 = v12;
    }
    else
    {
      size_t v13 = 0;
    }
    unint64_t v56 = v55 + v13;
  }
  else
  {
    uint64_t v11 = a1 + 16;
    if (*(unsigned int *)(a1 + 12) >= a6) {
      unint64_t v6 = format_hex_data(a5, "Recipe Contents", v11, a6, a2, a3, v55);
    }
    else {
      unint64_t v6 = format_hex_data(a5, "Recipe Contents", v11, *(unsigned int *)(a1 + 12), a2, a3, v55);
    }
    unint64_t v56 = v6;
  }
  if (*(unsigned char *)(a2 + v56 - 1) != 10)
  {
    if (a3 <= v56) {
      size_t v10 = 0;
    }
    else {
      size_t v10 = a3 - v56;
    }
    int v39 = __snprintf_chk((char *)(a2 + v56), v10, 0, 0xFFFFFFFFFFFFFFFFLL, "\n");
    if (v39 >= 0)
    {
      if (v39 <= v10) {
        size_t v8 = v39;
      }
      else {
        size_t v8 = v10;
      }
      size_t v9 = v8;
    }
    else
    {
      size_t v9 = 0;
    }
    v56 += v9;
  }
  return v56;
}

uint64_t voucher_mach_msg_fill_aux(uint64_t a1, unsigned int a2)
{
  uint64_t v5 = (char *)_dispatch_thread_getspecific(0x1CuLL);
  if (v5 && *((void *)v5 + 6))
  {
    if (a2 >= 0x28uLL)
    {
      *(_DWORD *)a1 = 40;
      *(_DWORD *)(a1 + 4) = 0;
      *(void *)&long long v3 = 59821818;
      *((void *)&v3 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *((void *)v5 + 6);
      long long v4 = *(_OWORD *)(v5 + 56);
      *(_OWORD *)(a1 + 8) = v3;
      *(_OWORD *)(a1 + 24) = v4;
      return 40;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _voucher_activity_id_allocate_slow(uint64_t a1)
{
  kern_return_t v4;
  uint64_t v5;

  uint64_t v5 = a1;
  long long v4 = 0;
  uint64_t activity_id = 0;
  long long v4 = mach_generate_activity_id(mach_task_self_, 1, &activity_id);
  if (v4)
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not generate an activity ID";
    qword_F42C0 = v4;
    __break(1u);
    JUMPOUT(0xA478CLL);
  }
  activity_id *= 16;
  activity_id &= 0xFFFFFFFFFFFFFFuLL;
  if (!activity_id) {
    uint64_t activity_id = 1;
  }
  if (v5) {
    return __swp(activity_id, (unsigned int *)&_voucher_aid_next);
  }
  uint64_t v1 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)&_voucher_aid_next, (unint64_t *)&v1, activity_id + 1, memory_order_relaxed, memory_order_relaxed);
  if (v1) {
    return __swp(activity_id, (unsigned int *)&_voucher_aid_next);
  }
  else {
    return activity_id;
  }
}

uint64_t _firehose_task_buffer_init()
{
  uint64_t v6 = 0;
  long long v5 = 0u;
  long long v4 = 0u;
  long long buffer = 0u;
  pid_t v0 = getpid();
  uint64_t result = proc_pidinfo(v0, 17, 1uLL, &buffer, 56);
  if (result != 56)
  {
    if (!result)
    {
      uint64_t v2 = **(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unable to get the unique pid (error)";
      qword_F42C0 = v2;
      __break(1u);
      JUMPOUT(0xA49D4);
    }
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Unable to get the unique pid (size)";
    qword_F42C0 = (int)result;
    __break(1u);
    JUMPOUT(0xA4A18);
  }
  _voucher_unique_pid = v4;
  if (_voucher_libtrace_hooks)
  {
    uint64_t result = (*(uint64_t (**)(void))(_voucher_libtrace_hooks + 8))();
    if (result)
    {
      uint64_t result = firehose_buffer_create(result, _voucher_unique_pid, (_dispatch_memory_warn & 1) != 0);
      _firehose_task_long long buffer = result;
      if (*(uint64_t *)_voucher_libtrace_hooks >= 4)
      {
        if (*(void *)(_voucher_libtrace_hooks + 32)) {
          return (*(uint64_t (**)(uint64_t, uint64_t))(_voucher_libtrace_hooks + 32))(_firehose_task_buffer + 2048, 2048);
        }
      }
    }
  }
  return result;
}

unint64_t format_hex_data(const char *a1, const char *a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  unint64_t v36 = a7;
  if (a2)
  {
    if (a6 <= a7) {
      size_t v26 = 0;
    }
    else {
      size_t v26 = a6 - a7;
    }
    int v33 = __snprintf_chk((char *)(a5 + a7), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s:\n", a1, a2);
    if (v33 >= 0)
    {
      if (v33 <= v26) {
        size_t v24 = v33;
      }
      else {
        size_t v24 = v26;
      }
      size_t v25 = v24;
    }
    else
    {
      size_t v25 = 0;
    }
    v36 += v25;
  }
  unint64_t v32 = -1;
  for (unint64_t i = 0; i < a4; ++i)
  {
    unint64_t v32 = i % 0x10;
    if (!(i % 0x10))
    {
      if (i)
      {
        if (a6 <= v36) {
          size_t v23 = 0;
        }
        else {
          size_t v23 = a6 - v36;
        }
        int v31 = __snprintf_chk((char *)(a5 + v36), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "  %s\n", v41);
        if (v31 >= 0)
        {
          if (v31 <= v23) {
            size_t v21 = v31;
          }
          else {
            size_t v21 = v23;
          }
          size_t v22 = v21;
        }
        else
        {
          size_t v22 = 0;
        }
        v36 += v22;
      }
      if (a6 <= v36) {
        size_t v20 = 0;
      }
      else {
        size_t v20 = a6 - v36;
      }
      int v30 = __snprintf_chk((char *)(a5 + v36), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "%s  %04lx ", a1, i);
      if (v30 >= 0)
      {
        if (v30 <= v20) {
          size_t v18 = v30;
        }
        else {
          size_t v18 = v20;
        }
        size_t v19 = v18;
      }
      else
      {
        size_t v19 = 0;
      }
      v36 += v19;
    }
    if (a6 <= v36) {
      size_t v17 = 0;
    }
    else {
      size_t v17 = a6 - v36;
    }
    int v29 = __snprintf_chk((char *)(a5 + v36), v17, 0, 0xFFFFFFFFFFFFFFFFLL, " %02x", *(unsigned __int8 *)(a3 + i));
    if (v29 >= 0)
    {
      if (v29 <= v17) {
        size_t v15 = v29;
      }
      else {
        size_t v15 = v17;
      }
      size_t v16 = v15;
    }
    else
    {
      size_t v16 = 0;
    }
    v36 += v16;
    if (*(unsigned __int8 *)(a3 + i) >= 0x20u && *(unsigned __int8 *)(a3 + i) <= 0x7Eu) {
      char v14 = *(unsigned char *)(a3 + i);
    }
    else {
      char v14 = 46;
    }
    v41[v32] = v14;
  }
  v41[v32 + 1] = 0;
  if (i % 0x10)
  {
    while (i % 0x10)
    {
      if (a6 <= v36) {
        size_t v13 = 0;
      }
      else {
        size_t v13 = a6 - v36;
      }
      int v28 = __snprintf_chk((char *)(a5 + v36), v13, 0, 0xFFFFFFFFFFFFFFFFLL, "   ");
      if (v28 >= 0)
      {
        if (v28 <= v13) {
          size_t v11 = v28;
        }
        else {
          size_t v11 = v13;
        }
        size_t v12 = v11;
      }
      else
      {
        size_t v12 = 0;
      }
      v36 += v12;
      ++i;
    }
    if (a6 <= v36) {
      size_t v10 = 0;
    }
    else {
      size_t v10 = a6 - v36;
    }
    int v27 = __snprintf_chk((char *)(a5 + v36), v10, 0, 0xFFFFFFFFFFFFFFFFLL, "  %s\n", v41);
    if (v27 >= 0)
    {
      if (v27 <= v10) {
        size_t v8 = v27;
      }
      else {
        size_t v8 = v10;
      }
      size_t v9 = v8;
    }
    else
    {
      size_t v9 = 0;
    }
    v36 += v9;
  }
  return v36;
}

mach_vm_address_t firehose_buffer_create(mach_port_name_t a1, uint64_t a2, uint64_t a3)
{
  kern_return_t v18;
  mach_vm_address_t address;
  mach_vm_address_t v20;
  mach_vm_address_t v21;
  uint64_t v22;
  uint64_t v23;
  mach_port_name_t v24;
  uint64_t v26;
  uint64_t v27;
  kern_return_t v28;
  kern_return_t v29;
  uint64_t v30;
  kern_return_t v31;
  mach_port_name_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  kern_return_t v37;
  mach_port_options_t options;
  mach_port_name_t name;
  mach_vm_address_t v40;
  int v41;
  int v42;

  size_t v24 = a1;
  size_t v23 = a2;
  size_t v22 = a3;
  size_t v21 = 0;
  size_t v20 = 0;
  address = vm_page_size;
  if (0x4000 % vm_page_size)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Invalid values for MADVISE_CHUNK_COUNT / CHUNK_SIZE";
    qword_F42C0 = 0x4000;
    __break(1u);
    JUMPOUT(0xA53F4);
  }
  size_t v18 = mach_vm_map(mach_task_self_, &address, 0x40000uLL, 0, 1308622851, 0, 0, 0, 3, 7, 2u);
  if (v18)
  {
    if (v18 != 3)
    {
      int v27 = v18;
      size_t v26 = 346;
      _dispatch_bug(v26, v27, v3, v4, v5, v6, v7, v8);
    }
    unint64_t v32 = v24;
    int v31 = 0;
    int v31 = mach_port_deallocate(mach_task_self_, v24);
    if (v31 == -301)
    {
      int v30 = -301;
      qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_F42C0 = -301;
      __break(1u);
      JUMPOUT(0xA5524);
    }
    int v29 = v31;
    size_t v34 = v31;
    int v33 = 91;
    if (v31) {
      _dispatch_bug(v33, v34, v9, v10, v11, v12, v13, v14);
    }
    int v28 = v29;
    return 0;
  }
  else
  {
    size_t v20 = address;
    size_t v21 = address;
    *(_DWORD *)(address + 1548) = v24;
    *(_DWORD *)(v21 + 1544) = getpid();
    *(void *)(v21 + 1536) = v23;
    int v42 = 49;
    int v41 = 5;
    int v40 = v20;
    mach_port_name_t name = 0;
    options.flags = 51;
    options.mpl.mpl_qlimit = 5;
    options.reserved[1] = 0;
    options.reserved[0] = 0;
    size_t v37 = 0;
    size_t v37 = mach_port_construct(mach_task_self_, &options, v20, &name);
    if (v37)
    {
      if (v37 == -301)
      {
        unint64_t v36 = -301;
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xA5688);
      }
      size_t v35 = v37;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate mach port";
      qword_F42C0 = v37;
      __break(1u);
      JUMPOUT(0xA56C4);
    }
    *(_DWORD *)(v21 + 156pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = name;
    *(_DWORD *)(v21 + 264) = 20180226;
    *(void *)(v21 + 512) = v22;
    for (unint64_t i = 0; i < 7; ++i)
    {
      if (i != 3) {
        *(unsigned char *)(v21 + (i << 7) + 644) = -1;
      }
    }
    firehose_buffer_update_limits_unlocked(v20);
    *(void *)(v21 + 52pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 31;
    for (unsigned __int16 j = 0; j <= 3u; ++j)
      *(_WORD *)(v21 + 2 * j) = j + 1;
    *(void *)(v21 + 464) = 4;
    *(_WORD *)(v21 + 32pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 4;
    *(void *)(v21 + 256) = 0x40000;
    return v20;
  }
}

uint64_t firehose_buffer_update_limits_unlocked(uint64_t result)
{
  uint64_t v12 = *(void *)(result + 512);
  unsigned __int16 v11 = 0;
  __int16 v10 = 0;
  for (unint64_t i = 0; i < 7; ++i)
  {
    if (*(unsigned __int8 *)(result + 640 + (i << 7) + 4) != 255)
    {
      if (((1 << i) & 0x13) != 0) {
        ++v11;
      }
      else {
        ++v10;
      }
    }
  }
  if (v12)
  {
    if ((v12 & 2) != 0) {
      unsigned __int16 v8 = 4 * v10 + 1 + v11;
    }
    else {
      unsigned __int16 v8 = v10 + 3 + v11;
    }
  }
  else if ((v12 & 2) != 0)
  {
    unsigned __int16 v8 = 6 * v10 + 1 + 3 * v11;
  }
  else
  {
    unsigned __int16 v8 = 2 * (v10 + v11) + 1;
  }
  unsigned __int16 v6 = vm_page_size / 0x1000;
  if (v6 > 1u)
  {
    if (v8 % (int)v6) {
      int v4 = v8 + v6 - v8 % (int)v6;
    }
    else {
      LOWORD(v4) = v8;
    }
    unsigned __int16 v8 = v4;
  }
  if (v8 <= 4u) {
    unsigned __int16 v3 = 4;
  }
  else {
    unsigned __int16 v3 = v8;
  }
  unsigned __int16 v9 = v3;
  if ((v12 & 1) == 0)
  {
    if (v3 <= 8u) {
      __int16 v2 = 8;
    }
    else {
      __int16 v2 = v3;
    }
    unsigned __int16 v9 = v2;
  }
  LOWORD(v5) = v9 - 1;
  if (3 * v9 / 8 <= 2 * v11) {
    LOWORD(v_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 2 * v11;
  }
  else {
    int v1 = 3 * v9 / 8;
  }
  WORD1(v5) = v1;
  HIDWORD(v5) = (v9 + 1);
  uint64_t v13 = *(void *)(result + 528);
  *(void *)(result + 528) = v5;
  if (v13 != v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(result + 448), v5 - v13, memory_order_relaxed);
  }
  return result;
}

mach_vm_address_t firehose_buffer_get_logging_prefs(uint64_t a1, mach_vm_size_t *a2)
{
  kern_return_t v23;
  kern_return_t v24;
  mach_vm_address_t address;
  mach_vm_size_t size;
  mach_port_name_t v27;
  int v28;
  mach_vm_size_t *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  int v30 = a1;
  int v29 = a2;
  int v28 = 0;
  int v28 = *(_DWORD *)(a1 + 1548);
  int v27 = 0;
  size = 0;
  address = 0;
  BOOL v21 = 0;
  if (v28) {
    BOOL v21 = v28 != -1;
  }
  if (v21)
  {
    int logging_prefs = firehose_send_get_logging_prefs(v28, &v27, &size);
    if (logging_prefs)
    {
      if (logging_prefs != 268435459)
      {
        if (logging_prefs == -301)
        {
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA5D68);
        }
        size_t v37 = logging_prefs;
        unint64_t v36 = 601;
        _dispatch_bug(v36, v37, v2, v3, v4, v5, v6, v7);
      }
      *int v29 = 0;
      return 0;
    }
    else
    {
      size_t v23 = mach_vm_map(mach_task_self_, &address, size, 0, 1, v27, 0, 0, 1, 1, 2u);
      if (v23 == -301)
      {
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xA5E5CLL);
      }
      size_t v35 = v23;
      size_t v34 = 612;
      if (v23)
      {
        _dispatch_bug(v34, v35, v8, v9, v10, v11, v12, v13);
        address = 0;
        size = 0;
      }
      size_t v24 = mach_port_deallocate(mach_task_self_, v27);
      if (v24 == -301)
      {
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xA5F28);
      }
      int v33 = v24;
      unint64_t v32 = 618;
      if (v24) {
        _dispatch_bug(v32, v33, v14, v15, v16, v17, v18, v19);
      }
      *int v29 = size;
      return address;
    }
  }
  else
  {
    *int v29 = 0;
    return 0;
  }
}

BOOL firehose_buffer_should_send_strings(mach_port_context_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_context_t v20 = a1;
  mach_port_t v19 = 0;
  mach_port_t v19 = *(_DWORD *)(a1 + 1552);
  int should_send_strings = 0;
  mach_port_t v17 = 0;
  if (v19 != -1)
  {
    if (v19)
    {
      int should_send_strings = firehose_send_should_send_strings(v19, &v17);
      if (!should_send_strings) {
        return v17 != 0;
      }
      if (should_send_strings != 268435459)
      {
        if (should_send_strings == -301)
        {
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA608CLL);
        }
        uint64_t v25 = should_send_strings;
        uint64_t v24 = 642;
        _dispatch_bug(v24, v25, v8, a4, a5, a6, a7, a8);
      }
    }
    mach_port_t v19 = firehose_client_reconnect(v20, v19, 0, a4, a5, a6, a7, a8);
    BOOL v16 = 0;
    if (v19) {
      BOOL v16 = v19 != -1;
    }
    if (v16)
    {
      int should_send_strings = firehose_send_should_send_strings(v19, &v17);
      if (!should_send_strings) {
        return v17 != 0;
      }
      if (should_send_strings != 268435459)
      {
        if (should_send_strings == -301)
        {
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA61C0);
        }
        uint64_t v23 = should_send_strings;
        uint64_t v22 = 654;
        _dispatch_bug(v22, v23, v9, v10, v11, v12, v13, v14);
      }
    }
    return 0;
  }
  return 0;
}

uint64_t firehose_client_reconnect(mach_port_context_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  kern_return_t v59;
  kern_return_t v60;
  uint64_t v61;
  kern_return_t v62;
  mach_port_name_t v63;
  uint64_t v64;
  uint64_t v65;
  kern_return_t v66;
  kern_return_t v67;
  uint64_t v68;
  kern_return_t v69;
  mach_port_name_t v70;
  uint64_t v71;
  uint64_t v72;
  kern_return_t v73;
  kern_return_t v74;
  uint64_t v75;
  kern_return_t v76;
  mach_port_name_t v77;
  uint64_t v78;
  uint64_t v79;
  kern_return_t v80;
  kern_return_t v81;
  uint64_t v82;
  kern_return_t v83;
  mach_port_name_t name;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  kern_return_t v89;
  mach_port_options_t options;
  mach_port_name_t v91;
  mach_port_context_t context;
  int v93;
  int v94;
  BOOL v95;
  BOOL v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  BOOL v100;
  int v101;
  unsigned int v102;
  atomic_uint *v103;
  mach_port_context_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  BOOL v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  kern_return_t v114;
  mach_port_context_t v115;
  mach_port_name_t v116;
  kern_return_t v117;
  mach_port_context_t v118;
  mach_port_name_t v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  int v123;
  int v124;
  int v125;
  unsigned int v126;
  unsigned int v127;
  unsigned int v128;
  atomic_uint *v129;
  BOOL v130;
  unsigned int v131;
  unsigned int v132;
  int v133[2];

  mach_port_context_t v56 = a1;
  int v55 = a2;
  unsigned __int8 v54 = a3;
  unsigned int v53 = 0;
  mach_port_t object_handle = 0;
  mach_port_t v51 = 0;
  memory_object_size_t v50 = 0;
  v49[4] = 0;
  *(_DWORD *)int v49 = a2 != 0;
  char v112 = *(unsigned int *)(a1 + 1548);
  BOOL v111 = 157;
  if (!v112) {
    _dispatch_abort(v111, 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v110 = *(unsigned int *)(v56 + 1560);
  unsigned __int8 v109 = 158;
  if (!v110) {
    _dispatch_abort(v109, 0, a3, a4, a5, a6, a7, a8);
  }
  BOOL v8 = *(void *)(v56 + 1536) != 0;
  unint64_t v108 = *(void *)(v56 + 1536) != 0;
  unint64_t v107 = 159;
  if (!v8) {
    _dispatch_abort(v107, v108, a3, a4, a5, a6, a7, a8);
  }
  BOOL v103 = (atomic_uint *)(v56 + 1564);
  unsigned __int16 v120 = _dispatch_thread_getspecific(3uLL);
  unint64_t v102 = v120 & 0xFFFFFFFC;
  unint64_t v101 = 0;
  BOOL v98 = v120 & 0xFFFFFFFC;
  BOOL v97 = v120 & 0xFFFFFFFC;
  BOOL v99 = v120 & 0xFFFFFFFC;
  int v15 = 0;
  atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v56 + 1564), (unsigned int *)&v15, v120 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
  if (v15) {
    unint64_t v101 = v15;
  }
  unint64_t v96 = v15 == 0;
  unint64_t v100 = v15 == 0;
  BOOL v95 = v100;
  if (v15) {
    _dispatch_unfair_lock_lock_slow(v103);
  }
  unsigned int v53 = *(_DWORD *)(v56 + 4 * v54 + 1552);
  if (v53 == v55 && v53 != -1)
  {
    if (v49[0])
    {
      for (int i = 0; i <= 1; ++i)
      {
        mach_port_name_t v47 = 0;
        mach_port_name_t v47 = *(_DWORD *)(v56 + 4 * i + 1552);
        unint64_t v106 = v47;
        unint64_t v105 = 171;
        if (!v47) {
          _dispatch_abort(v105, v106, v9, v10, v11, v12, v13, v14);
        }
        unsigned __int16 v119 = v47;
        unint64_t v118 = v56;
        BOOL v117 = mach_port_destruct(mach_task_self_, v47, 0, v56);
        if (v117 == -301)
        {
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA653CLL);
        }
        mach_port_name_t name = v47;
        unint64_t v83 = mach_port_deallocate(mach_task_self_, v47);
        if (v83 == -301)
        {
          unint64_t v82 = -301;
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA65B0);
        }
        BOOL v81 = v83;
        unint64_t v86 = v83;
        BOOL v85 = 91;
        if (v83) {
          _dispatch_bug(v85, v86, v9, v10, v11, v12, v13, v14);
        }
        BOOL v80 = v81;
        *(_DWORD *)(v56 + 4 * i + 1552) = 0;
      }
    }
    vm_prot_t permission = 4194305;
    memory_object_size_t size = 0x40000;
    memory_object_offset_t offset = v56;
    *(_DWORD *)&v49[1] = mach_make_memory_entry_64(mach_task_self_, &size, v56, 4194305, &object_handle, 0);
    if (!(size >> 18))
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid size for the firehose buffer";
      qword_F42C0 = size;
      __break(1u);
      JUMPOUT(0xA66C4);
    }
    if (*(_DWORD *)&v49[1])
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to make memory port";
      qword_F42C0 = *(int *)&v49[1];
      __break(1u);
      JUMPOUT(0xA6714);
    }
    if (v49[0])
    {
      if (*(void *)(_voucher_libtrace_hooks + 24))
      {
        *(_DWORD *)&v49[1] = (*(uint64_t (**)(memory_object_offset_t *, memory_object_size_t *))(_voucher_libtrace_hooks + 24))(&offset, &size);
        if (!*(_DWORD *)&v49[1] && offset && size)
        {
          memory_object_size_t v50 = size;
          *(_DWORD *)&v49[1] = mach_make_memory_entry_64(mach_task_self_, &size, offset, permission, &v51, 0);
          if (*(_DWORD *)&v49[1])
          {
            qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to make memory port";
            qword_F42C0 = *(int *)&v49[1];
            __break(1u);
            JUMPOUT(0xA6800);
          }
          *(_DWORD *)&v49[1] = mach_vm_deallocate(mach_task_self_, offset, size);
          uint64_t v58 = *(int *)&v49[1];
          uint64_t v57 = 209;
          if (*(_DWORD *)&v49[1]) {
            _dispatch_bug(v57, v58, v16, v17, v18, v19, v20, v21);
          }
        }
      }
    }
    for (int j = 0; j <= 1; ++j)
    {
      unint64_t v94 = 21;
      unint64_t v93 = 1;
      context = v56;
      BOOL v91 = 0;
      options.flags = 23;
      options.mpl.mpl_qlimit = 1;
      options.reserved[1] = 0;
      options.reserved[0] = 0;
      unint64_t v89 = 0;
      unint64_t v89 = mach_port_construct(mach_task_self_, &options, v56, &v91);
      if (v89)
      {
        if (v89 == -301)
        {
          unint64_t v88 = -301;
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA6964);
        }
        unint64_t v87 = v89;
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate mach port";
        qword_F42C0 = v89;
        __break(1u);
        JUMPOUT(0xA69A0);
      }
      v133[j] = v91;
    }
    unsigned int v53 = v133[v54];
    *(_DWORD *)&v49[1] = firehose_send_register(*(_DWORD *)(v56 + 1548), object_handle, 0x40000, v133[0], v133[1], *(_DWORD *)(v56 + 1560), v51, v50);
    if (*(_DWORD *)&v49[1])
    {
      if (*(_DWORD *)&v49[1] != 268435459)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to register with logd";
        qword_F42C0 = *(int *)&v49[1];
        __break(1u);
        JUMPOUT(0xA6DDCLL);
      }
      for (int k = 0; k <= 1; ++k)
      {
        BOOL v116 = v133[k];
        unint64_t v115 = v56;
        unint64_t v114 = 0;
        unint64_t v114 = mach_port_destruct(mach_task_self_, v116, 0, v56);
        if (v114 == -301)
        {
          uint64_t v113 = -301;
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA6B28);
        }
        char v77 = v133[k];
        char v76 = 0;
        char v76 = mach_port_deallocate(mach_task_self_, v77);
        if (v76 == -301)
        {
          uint64_t v75 = -301;
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA6BA4);
        }
        uint64_t v74 = v76;
        uint64_t v79 = v76;
        uint64_t v78 = 91;
        if (v76) {
          _dispatch_bug(v78, v79, v22, v23, v24, v25, v26, v27);
        }
        unint64_t v73 = v74;
        *(_DWORD *)(v56 + 4 * k + 1552) = -1;
      }
      unsigned int v53 = -1;
      __int16 v70 = object_handle;
      uint64_t v69 = 0;
      uint64_t v69 = mach_port_deallocate(mach_task_self_, object_handle);
      if (v69 == -301)
      {
        uint64_t v68 = -301;
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xA6C8CLL);
      }
      __int16 v67 = v69;
      uint64_t v72 = v69;
      uint64_t v71 = 91;
      if (v69) {
        _dispatch_bug(v71, v72, v28, v29, v30, v31, v32, v33);
      }
      uint64_t v66 = v67;
      if (v51)
      {
        uint64_t v63 = v51;
        uint64_t v62 = 0;
        uint64_t v62 = mach_port_deallocate(mach_task_self_, v51);
        if (v62 == -301)
        {
          uint64_t v61 = -301;
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA6D50);
        }
        uint64_t v60 = v62;
        long long v65 = v62;
        uint64_t v64 = 91;
        if (v62) {
          _dispatch_bug(v64, v65, v34, v35, v36, v37, v38, v39);
        }
        uint64_t v59 = v60;
      }
    }
    else
    {
      for (int m = 0; m <= 1; ++m)
        *(_DWORD *)(v56 + 4 * m + 1552) = v133[m];
    }
  }
  unint64_t v104 = v56 + 1564;
  unint64_t v129 = (atomic_uint *)(v56 + 1564);
  unint64_t v128 = 0;
  uint64_t v127 = 0;
  unint64_t v131 = _dispatch_thread_getspecific(3uLL);
  uint64_t v127 = v131 & 0xFFFFFFFC;
  unint64_t v126 = 0;
  BOOL v124 = 0;
  uint64_t v123 = 0;
  unint64_t v125 = 0;
  uint64_t v122 = atomic_exchange_explicit(v129, 0, memory_order_release);
  unint64_t v126 = v122;
  unsigned __int8 v121 = v122;
  unint64_t v128 = v122;
  if (v122 == v127)
  {
    uint64_t v130 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)v129, v128);
    unint64_t v132 = v128;
    uint64_t v130 = (v128 & 2) != 0;
  }
  return v53;
}

void firehose_client_push_reply(uint64_t a1, int a2)
{
  qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: firehose_push_reply should never be sent to the buffer receive port";
  qword_F42C0 = a2;
  __break(1u);
}

uint64_t sub_A6F4C()
{
  return v1;
}

uint64_t firehose_client_push_notify_async(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  for (int i = (char *)_dispatch_thread_getspecific(0x17uLL); i; int i = *(char **)i)
  {
    if (*((char **)i + 1) == "firehose")
    {
      uint64_t v9 = i;
      goto LABEL_7;
    }
  }
  uint64_t v9 = 0;
LABEL_7:
  firehose_client_merge_updates(*((void *)v9 + 2), 1, a2, a3, a4 != 0, 0);
  return 0;
}

void firehose_client_merge_updates(uint64_t a1, char a2, unint64_t a3, unint64_t a4, char a5, unint64_t *a6)
{
  char v31 = a2 & 1;
  unsigned __int16 v23 = 0;
  unsigned __int16 v22 = 0;
  if ((a5 & 1) != 0 && !*(unsigned char *)(a1 + 1568))
  {
    char v6 = 0;
    atomic_compare_exchange_strong_explicit((atomic_uchar *volatile)(a1 + 1568), (unsigned __int8 *)&v6, 1u, memory_order_relaxed, memory_order_relaxed);
  }
  BOOL v21 = 0;
  unint64_t v24 = *(void *)(a1 + 464);
  do
  {
    if (v24 >= a3) {
      break;
    }
    unint64_t v7 = v24;
    unint64_t v8 = v24;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 464), &v8, a3, memory_order_relaxed, memory_order_relaxed);
    if (v8 != v7) {
      unint64_t v24 = v8;
    }
    BOOL v21 = v8 == v7;
  }
  while (v8 != v7);
  if (v21) {
    unsigned __int16 v22 = a3 - v24;
  }
  BOOL v20 = 0;
  unint64_t v25 = *(void *)(a1 + 488);
  do
  {
    if (v25 >= a4) {
      break;
    }
    unint64_t v9 = v25;
    unint64_t v10 = v25;
    atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 488), &v10, a4, memory_order_relaxed, memory_order_relaxed);
    if (v10 != v9) {
      unint64_t v25 = v10;
    }
    BOOL v20 = v10 == v9;
  }
  while (v10 != v9);
  if (v20) {
    unsigned __int16 v23 = a4 - v25;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tclient side: mem: +%d->%llx, io: +%d->%llx", v11, v12, v13, v14, v15, v16, v17, 544);
  if (v22 || v23)
  {
    for (unint64_t i = *(void *)(a1 + 256); ; unint64_t i = v19)
    {
      unint64_t v26 = i;
      HIWORD(v26) = HIWORD(i) + v23;
      WORD1(v26) = WORD1(i) + v22;
      unint64_t v18 = i;
      unint64_t v19 = i;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 256), &v19, v26, memory_order_relaxed, memory_order_relaxed);
      if (v19 == v18) {
        break;
      }
    }
    unint64_t v28 = atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 448), ((unint64_t)v23 << 16) | v22, memory_order_release)+ (((unint64_t)v23 << 16) | v22);
    if (a6) {
      *a6 = v28;
    }
    if (v31)
    {
      if (v23) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 496), 1uLL, memory_order_relaxed);
      }
      if (v22) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 472), 1uLL, memory_order_relaxed);
      }
    }
  }
  else if (a6)
  {
    *a6 = *(void *)(a1 + 448);
  }
}

void *firehose_buffer_update_limits(uint64_t a1)
{
  uint64_t v3 = (atomic_uint *)(a1 + 536);
  char v6 = (atomic_uint *)(a1 + 536);
  unsigned int v5 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  int v1 = 0;
  atomic_compare_exchange_strong_explicit(v6, (unsigned int *)&v1, v5, memory_order_acquire, memory_order_acquire);
  if (v1) {
    _dispatch_unfair_lock_lock_slow(v6);
  }
  firehose_buffer_update_limits_unlocked(a1);
  uint64_t result = _dispatch_thread_getspecific(3uLL);
  unsigned int v7 = atomic_exchange_explicit(v3, 0, memory_order_release);
  if (v7 != (result & 0xFFFFFFFC)) {
    return _dispatch_unfair_lock_unlock_slow((uint64_t)v3, v7);
  }
  return result;
}

void firehose_buffer_ring_enqueue(mach_port_context_t a1, unsigned __int8 a2)
{
  BOOL v15 = (*(void *)(a1 + ((unint64_t)a2 << 12)) & 0x200000000000000) != 0;
  if ((*(void *)(a1 + ((unint64_t)a2 << 12)) & 0x200000000000000) != 0)
  {
    mach_port_context_t v20 = a1 + 128;
    unint64_t v19 = (atomic_ushort *)(a1 + 384);
  }
  else
  {
    mach_port_context_t v20 = a1;
    unint64_t v19 = (atomic_ushort *)(a1 + 320);
  }
  unsigned __int16 v18 = *(_WORD *)v19;
  while (1)
  {
    while (1)
    {
      unsigned __int16 v17 = v18 & 0xFFC0;
      unsigned __int16 v16 = v18 & 0x3F;
      _dispatch_thread_setspecific(122, (uint64_t)v19);
      unsigned __int16 v2 = v18 & 0xFFC0;
      atomic_compare_exchange_strong_explicit((atomic_ushort *volatile)(v20 + 2 * (v18 & 0x3F)), &v2, v18 & 0xFFC0 | a2, memory_order_relaxed, memory_order_relaxed);
      if ((v18 & 0xFFC0) == v2) {
        break;
      }
      _dispatch_thread_setspecific(122, 0);
      for (int i = -1024; ; ++i)
      {
        unsigned __int16 v12 = v18;
        unsigned __int16 v18 = *(_WORD *)v19;
        BOOL v11 = 1;
        if (*(unsigned __int16 *)v19 == v12) {
          BOOL v11 = *(unsigned __int16 *)(v20 + 2 * v16) == v17;
        }
        if (v11) {
          break;
        }
        int v5 = i;
        if (v5 < 0) {
          __yield();
        }
        else {
          _pthread_yield_to_enqueuer_4dispatch();
        }
      }
    }
    unsigned __int16 v14 = v18;
    int v3 = v18;
    unsigned __int16 v4 = v18;
    atomic_compare_exchange_strong_explicit(v19, &v4, v18 + 1, memory_order_release, memory_order_relaxed);
    if (v3 != v4) {
      unsigned __int16 v14 = v4;
    }
    unsigned __int16 v18 = v14;
    if (v3 == v4) {
      break;
    }
    *(_WORD *)(v20 + 2 * v16) = v17;
    _dispatch_thread_setspecific(122, 0);
  }
  _dispatch_thread_setspecific(122, 0);
  firehose_client_send_push_async(a1, 0, v15, v6, v7, v8, v9, v10);
}

void firehose_client_send_push_async(mach_port_context_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v22 = a3 & 1;
  int v20 = *(_DWORD *)(a1 + 4 * (a3 & 1) + 1552);
  if (v20 == -1) {
    return;
  }
  if (!v20) {
    goto LABEL_11;
  }
  int v18 = firehose_send_push_async(v20, a2, 0);
  BOOL v17 = 1;
  if (v18) {
    BOOL v17 = v18 == 268435460;
  }
  if (!v17)
  {
    if (v18 != 268435459)
    {
      if (v18 == -301)
      {
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xA7E18);
      }
      if (v18) {
        _dispatch_bug(476, v18, v8, a4, a5, a6, a7, a8);
      }
    }
LABEL_11:
    int v21 = firehose_client_reconnect(a1, v20, v22, a4, a5, a6, a7, a8);
    BOOL v16 = 0;
    if (v21) {
      BOOL v16 = v21 != -1;
    }
    if (v16)
    {
      int v19 = firehose_send_push_async(v21, a2, 0);
      BOOL v15 = 1;
      if (v19) {
        BOOL v15 = v19 == 268435460;
      }
      if (!v15 && v19 != 268435459)
      {
        if (v19 == -301)
        {
          qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_F42C0 = -301;
          __break(1u);
          JUMPOUT(0xA7F6CLL);
        }
        if (v19) {
          _dispatch_bug(488, v19, v9, v10, v11, v12, v13, v14);
        }
      }
    }
  }
}

mach_port_context_t firehose_buffer_force_connect(mach_port_context_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(result + 1552)) {
    return firehose_client_reconnect(result, 0, 0, a4, a5, a6, a7, a8);
  }
  return result;
}

char *firehose_buffer_tracepoint_reserve_slow(uint64_t a1, unsigned char *a2, void *a3)
{
  mach_port_context_t v31 = a1;
  uint64_t v30 = a2;
  uint64_t v29 = a3;
  int v28 = 0;
  int v28 = a2[14] & 1;
  uint64_t v27 = a1 + 448;
  unint64_t v26 = 0;
  unsigned __int8 v24 = 0;
  firehose_drain_notifications_once(a1);
  unint64_t v26 = *(void *)v27;
  mach_port_context_t v46 = v31;
  BOOL v45 = v28 != 0;
  int v44 = &v26;
  BOOL v43 = 0;
  int v42 = (atomic_ullong *)(v31 + 448);
  unint64_t v41 = v26;
  unint64_t v40 = 0;
  do
  {
    if (!*((_WORD *)&v41 + v45))
    {
      char v47 = 0;
      goto LABEL_8;
    }
    unint64_t v40 = v41;
    --*((_WORD *)&v40 + v45);
    unint64_t v39 = v41;
    BOOL v38 = 0;
    unint64_t v36 = v40;
    unint64_t v35 = v40;
    unint64_t v37 = v40;
    unint64_t v8 = v41;
    unint64_t v9 = v41;
    atomic_compare_exchange_strong_explicit(v42, &v9, v40, memory_order_acquire, memory_order_acquire);
    if (v9 != v8) {
      unint64_t v39 = v9;
    }
    BOOL v34 = v9 == v8;
    BOOL v38 = v9 == v8;
    unint64_t v41 = v39;
    BOOL v33 = v38;
    BOOL v43 = v9 == v8;
  }
  while (v9 != v8);
  unint64_t *v44 = v40;
  char v47 = 1;
LABEL_8:
  char v25 = v47;
  if (v47)
  {
    while (!v24)
    {
      mach_port_context_t v81 = v31;
      unint64_t v80 = 0;
      unint64_t v79 = 0;
      mach_port_context_t v78 = 0;
      __int16 v77 = 0;
      __int16 v76 = 0;
      unsigned __int16 v75 = 0;
      unsigned __int8 v74 = 0;
      mach_port_context_t v73 = 0;
      BOOL v72 = 0;
      BOOL v71 = 0;
      __int16 v70 = (atomic_ullong *)(v31 + 256);
      unint64_t v79 = *(void *)(v31 + 256);
      do
      {
        unint64_t v80 = v79;
        if ((unsigned __int16)v79 == WORD1(v79))
        {
          if (WORD2(v79) == HIWORD(v79))
          {
            unsigned __int8 v82 = 0;
            goto LABEL_32;
          }
          ++WORD2(v80);
        }
        else
        {
          LOWORD(v8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v80 + 1;
        }
        unint64_t v69 = v80;
        unint64_t v10 = v79;
        unint64_t v11 = v79;
        atomic_compare_exchange_strong_explicit(v70, &v11, v80, memory_order_relaxed, memory_order_relaxed);
        if (v11 != v10) {
          unint64_t v79 = v11;
        }
        BOOL v68 = v11 == v10;
        BOOL v71 = v11 == v10;
      }
      while (v11 != v10);
      BOOL v67 = v71;
      BOOL v72 = WORD2(v80) != WORD2(v79);
      if (WORD2(v80) == WORD2(v79))
      {
        mach_port_context_t v78 = v81;
        unsigned __int16 v75 = v79 & 0x3F;
      }
      else
      {
        mach_port_context_t v78 = v81 + 128;
        unsigned __int16 v75 = BYTE4(v79) & 0x3F;
      }
      int v66 = 0;
      mach_msg_timeout_t option_time = -1024;
      while (1)
      {
        __int16 v76 = *(_WORD *)(v78 + 2 * v75);
        int v66 = v76 & 0x3F;
        if (v66) {
          break;
        }
        int v12 = option_time++;
        if (v12 < 0) {
          __yield();
        }
        else {
          thread_switch(0, 4, option_time);
        }
      }
      int v64 = v66;
      __int16 v77 = (v76 & 0xFFC0) + 64;
      unsigned __int8 v74 = v76 & 0x3F;
      mach_port_context_t v84 = v81;
      char v83 = v76 & 0x3F;
      mach_port_context_t v73 = v81 + ((unint64_t)(v76 & 0x3F) << 12);
      if (!v72 && *(unsigned char *)(v73 + 6) == 3)
      {
        unint64_t v62 = ~(1 << v74);
        unint64_t v61 = v62;
        unint64_t v63 = v62;
        unint64_t v59 = 0;
        unint64_t v57 = v62;
        unint64_t v56 = v62;
        unint64_t v58 = v62;
        unint64_t v55 = atomic_fetch_and_explicit((atomic_ullong *volatile)(v81 + 456), v62, memory_order_relaxed);
        unint64_t v59 = v55;
        unint64_t v54 = v55;
        unint64_t v60 = v55 & v63;
      }
      uint64_t v53 = 0x100000000000000;
      uint64_t v52 = 0x100000000000000;
      *(void *)mach_port_context_t v73 = 0x100000000000000;
      uint64_t v51 = v53;
      __int16 v50 = v77;
      __int16 v49 = v77;
      *(_WORD *)(v78 + 2 * v75) = v77;
      __int16 v48 = v50;
      unsigned __int8 v82 = v74;
LABEL_32:
      unsigned __int8 v24 = v82;
      if (!v82) {
        break;
      }
      if (v82 >= (int)BYTE4(v26))
      {
        mach_port_context_t v90 = v31;
        unsigned __int8 v89 = v82;
        uint64_t v88 = 0x4000;
        uint64_t v87 = 15;
        unint64_t v86 = (atomic_uint *)(v31 + 536);
        uint64_t v85 = 0;
        BOOL v99 = (atomic_uint *)(v31 + 536);
        unsigned int v98 = 0;
        unsigned int v150 = _dispatch_thread_getspecific(3uLL);
        unsigned int v98 = v150 & 0xFFFFFFFC;
        int v97 = 0;
        BOOL v96 = 0;
        unsigned int v94 = v150 & 0xFFFFFFFC;
        unsigned int v93 = v150 & 0xFFFFFFFC;
        unsigned int v95 = v150 & 0xFFFFFFFC;
        int v13 = 0;
        atomic_compare_exchange_strong_explicit(v99, (unsigned int *)&v13, v150 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
        if (v13) {
          int v97 = v13;
        }
        BOOL v92 = v13 == 0;
        BOOL v96 = v13 == 0;
        BOOL v91 = v96;
        if (v13) {
          _dispatch_unfair_lock_lock_slow(v99);
        }
        if (v89 >= (int)*(unsigned __int8 *)(v90 + 532))
        {
          uint64_t v14 = *(void *)(v90 + 520) & ~(1 << v89);
          *(void *)(v90 + 52pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v14;
          uint64_t v85 = v14;
          v89 &= 0xFCu;
          if ((v14 & (15 << v89)) == 0)
          {
            mach_port_context_t v102 = v90;
            unsigned __int8 v101 = v89;
            madvise((void *)(v90 + ((unint64_t)v89 << 12)), 0x4000uLL, 5);
          }
          unsigned __int8 v89 = 0;
        }
        unint64_t v100 = v86;
        unsigned __int8 v171 = v86;
        unsigned int v170 = 0;
        unsigned int v169 = 0;
        unsigned int v173 = _dispatch_thread_getspecific(3uLL);
        unsigned int v169 = v173 & 0xFFFFFFFC;
        unsigned int v168 = 0;
        int v166 = 0;
        int v165 = 0;
        int v167 = 0;
        unsigned int v164 = atomic_exchange_explicit(v171, 0, memory_order_release);
        unsigned int v168 = v164;
        unsigned int v163 = v164;
        unsigned int v170 = v164;
        if (v164 == v169)
        {
          BOOL v172 = 0;
        }
        else
        {
          _dispatch_unfair_lock_unlock_slow((uint64_t)v171, v170);
          unsigned int v174 = v170;
          BOOL v172 = (v170 & 2) != 0;
        }
        unsigned __int8 v24 = v89;
      }
    }
    if (!v24)
    {
      uint64_t v106 = v27;
      __int16 v105 = BYTE4(v26);
      unsigned __int8 v104 = 0;
      unint64_t v103 = 0;
      unint64_t v115 = (atomic_uint *)(v27 + 88);
      unsigned int v114 = 0;
      unsigned int v151 = _dispatch_thread_getspecific(3uLL);
      unsigned int v114 = v151 & 0xFFFFFFFC;
      int v113 = 0;
      BOOL v112 = 0;
      unsigned int v110 = v151 & 0xFFFFFFFC;
      unsigned int v109 = v151 & 0xFFFFFFFC;
      unsigned int v111 = v151 & 0xFFFFFFFC;
      int v15 = 0;
      atomic_compare_exchange_strong_explicit(v115, (unsigned int *)&v15, v151 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
      if (v15) {
        int v113 = v15;
      }
      BOOL v108 = v15 == 0;
      BOOL v112 = v15 == 0;
      BOOL v107 = v112;
      if (v15) {
        _dispatch_unfair_lock_lock_slow(v115);
      }
      unint64_t v103 = ~(*(void *)(v106 + 72) | (-1 << v105));
      if (v103)
      {
        unint64_t v176 = v103;
        BOOL v178 = v103 != 0;
        uint64_t v177 = 45;
        unsigned __int8 v104 = __clz(__rbit64(v103));
        *(void *)(v106 + 72) |= (1 << v104);
      }
      uint64_t v116 = v106 + 88;
      uint64_t v160 = (atomic_uint *)(v106 + 88);
      unsigned int v159 = 0;
      unsigned int v158 = 0;
      unsigned int v162 = _dispatch_thread_getspecific(3uLL);
      unsigned int v158 = v162 & 0xFFFFFFFC;
      unsigned int v157 = 0;
      int v155 = 0;
      int v154 = 0;
      int v156 = 0;
      unsigned int v153 = atomic_exchange_explicit(v160, 0, memory_order_release);
      unsigned int v157 = v153;
      unsigned int v152 = v153;
      unsigned int v159 = v153;
      if (v153 == v158)
      {
        BOOL v161 = 0;
      }
      else
      {
        _dispatch_unfair_lock_unlock_slow((uint64_t)v160, v159);
        unsigned int v175 = v159;
        BOOL v161 = (v159 & 2) != 0;
      }
      unsigned __int8 v24 = v104;
    }
  }
  BOOL v23 = 1;
  if (!v24) {
    BOOL v23 = (v30[14] & 4) == 0;
  }
  if (v23)
  {
    if (!v24 && (v25 & 1) != 0)
    {
      mach_port_context_t v129 = v31;
      BOOL v128 = v28 != 0;
      mach_port_context_t v127 = v31 + 448;
      unint64_t v125 = 1 << (16 * (v28 != 0));
      unint64_t v124 = v125;
      unint64_t v126 = v125;
      unint64_t v122 = 0;
      unint64_t v120 = v125;
      unint64_t v119 = v125;
      unint64_t v121 = v125;
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 448), v125, memory_order_relaxed);
      unint64_t v122 = add_explicit;
      unint64_t v117 = add_explicit;
      unint64_t v123 = add_explicit + v126;
    }
    return firehose_buffer_stream_chunk_install(v31, (uint64_t)v30, v29, v24);
  }
  else
  {
    unsigned __int8 v16 = v30[12];
    mach_port_context_t v149 = v31;
    unsigned __int8 v148 = v16;
    uint64_t v147 = 0;
    unint64_t v146 = 0;
    char v145 = (atomic_ullong *)(v31 + 640 + ((unint64_t)v16 << 7));
    uint64_t v144 = 0;
    uint64_t v143 = *(void *)v145;
    uint64_t v144 = v143;
    uint64_t v142 = v143;
    uint64_t v147 = v143;
    if ((v143 & 0x400000000000) != 0)
    {
      BOOL v135 = 0;
      unsigned __int8 v134 = v145;
      uint64_t v147 = *(void *)v145;
      do
      {
        LODWORD(v133) = v147 & 0xFFFFFFFD;
        BYTE4(v133) = BYTE4(v147);
        BYTE5(v133) = BYTE5(v133) & 0xC0 | BYTE5(v147) & 0x3F;
        BYTE5(v133) = BYTE5(v133) & 0xBF | 0x40;
        BYTE5(v133) = BYTE5(v133) & 0x7F | 0x80;
        HIWORD(v133) = HIWORD(v147);
        unint64_t v146 = v133;
        unint64_t v132 = v133;
        uint64_t v19 = v147;
        uint64_t v20 = v147;
        atomic_compare_exchange_strong_explicit(v134, (unint64_t *)&v20, v133, memory_order_relaxed, memory_order_relaxed);
        if (v20 != v19) {
          uint64_t v147 = v20;
        }
        BOOL v131 = v20 == v19;
        BOOL v135 = v20 == v19;
      }
      while (v20 != v19);
      BOOL v130 = v135;
    }
    else
    {
      *((void *)v145 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = mach_continuous_time();
      BOOL v141 = 0;
      unint64_t v140 = v145;
      uint64_t v147 = *(void *)v145;
      do
      {
        LODWORD(v139) = v147 & 0xFFFFFFFD;
        BYTE4(v139) = BYTE4(v147);
        BYTE5(v139) = BYTE5(v139) & 0xC0 | BYTE5(v147) & 0x3F;
        BYTE5(v139) = BYTE5(v139) & 0xBF | 0x40;
        BYTE5(v139) = BYTE5(v139) & 0x7F | 0x80;
        HIWORD(v139) = HIWORD(v147);
        unint64_t v146 = v139;
        unint64_t v138 = v139;
        uint64_t v17 = v147;
        uint64_t v18 = v147;
        atomic_compare_exchange_strong_explicit(v140, (unint64_t *)&v18, v139, memory_order_release, memory_order_relaxed);
        if (v18 != v17) {
          uint64_t v147 = v18;
        }
        BOOL v137 = v18 == v17;
        BOOL v141 = v18 == v17;
      }
      while (v18 != v17);
      BOOL v136 = v141;
    }
    uint64_t v21 = *((void *)v145 + 1);
    unsigned __int8 v182 = v148;
    uint64_t v181 = v21;
    uint64_t v180 = v147;
    unint64_t v179 = v146;
    int v187 = 772145168;
    uint64_t v186 = v148;
    uint64_t v185 = v21;
    uint64_t v184 = v147;
    unint64_t v183 = v146;
    if (MEMORY[0xFFFFFC100]) {
      kdebug_trace();
    }
    if ((v147 & 2) != 0) {
      _dispatch_gate_broadcast_slow((uint64_t)v145, v147);
    }
    v30[13] = v25 & 1;
    return firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(v31, (uint64_t)v30, v29, v3, v4, v5, v6, v7);
  }
}

BOOL firehose_drain_notifications_once(uint64_t a1)
{
  mach_msg_return_t v26;
  mach_msg_header_t *v27;
  mach_msg_size_t v28;
  uint64_t v29;
  uint64_t v30;
  mach_msg_option_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  long long v35;
  uint64_t v36;
  BOOL v37;
  int v38;
  void *v39;
  mach_msg_header_t *v40;
  uint64_t v41;
  uint64_t (*v42)(mach_msg_header_t *, uint64_t);
  uint64_t *v43;
  uint64_t v44;
  BOOL v45;

  uint64_t v32 = a1;
  mach_msg_size_t v23 = 0;
  mach_port_context_t v31 = 67109126;
  uint64_t v30 = 56;
  uint64_t v29 = 36;
  int v28 = 124;
  uint64_t v27 = 0;
  unsigned __int8 v22 = (mach_msg_header_t *)v15;
  bzero(v15, 0x7CuLL);
  uint64_t v27 = v22;
  unint64_t v26 = v23;
  unint64_t v26 = mach_msg(v22, v31, v23, v28, *(_DWORD *)(v32 + 1560), v23, v23);
  if (v26)
  {
    if (v26 != 268451843)
    {
      uint64_t v24 = v26;
      v14[4] = v1;
      v14[5] = v2;
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: firehose_drain_notifications_once() failed";
      qword_F42C0 = v26;
      __break(1u);
      JUMPOUT(0xA9458);
    }
  }
  else
  {
    uint64_t v19 = 0;
    v25[0] = 0;
    v25[1] = "firehose";
    v25[2] = v32;
    BOOL v33 = v25;
    uint64_t v18 = 23;
    uint64_t v3 = _dispatch_thread_getspecific(0x17uLL);
    uint64_t v4 = v18;
    *BOOL v33 = v3;
    _dispatch_thread_setspecific(v4, (uint64_t)v33);
    uint64_t v20 = v15;
    int v42 = (uint64_t (*)(mach_msg_header_t *, uint64_t))firehoseReply_server;
    unint64_t v41 = 36;
    unint64_t v40 = v27;
    unint64_t v39 = v19;
    uint64_t v21 = v14;
    bzero(v14, 0x24uLL);
    unint64_t v39 = v21;
    BOOL v38 = 0;
    unint64_t v37 = (v40->msgh_bits & 0x1F) == 18;
    uint64_t v5 = v21;
    unint64_t v36 = 0;
    unint64_t v35 = 0uLL;
    v21[2] = 0;
    *uint64_t v5 = 0uLL;
    if (v42(v40, (uint64_t)v39))
    {
      if ((*((unsigned char *)v39 + 3) & 0x80) != 0) {
        BOOL v38 = 0;
      }
      else {
        BOOL v38 = *((_DWORD *)v39 + 8);
      }
    }
    else
    {
      BOOL v38 = -303;
    }
    BOOL v17 = 0;
    if (!v38) {
      BOOL v17 = v37;
    }
    if (v17)
    {
      BOOL v34 = 0;
      BOOL v34 = *((int *)v39 + 5);
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: firehose_mig_server doesn't handle replies";
      qword_F42C0 = v34;
      __break(1u);
      JUMPOUT(0xA9340);
    }
    BOOL v16 = 0;
    if (v38) {
      BOOL v16 = v38 != -305;
    }
    if (v16)
    {
      v40->msgh_remote_mach_port_t port = 0;
      mach_msg_destroy(v40);
    }
    BOOL v43 = v25;
    BOOL v12 = _dispatch_thread_getspecific(0x17uLL) == v25;
    BOOL v45 = v12;
    int v44 = 449;
    if (!v12) {
      _dispatch_abort(v44, v45, v6, v7, v8, v9, v10, v11);
    }
    _dispatch_thread_setspecific(23, *v43);
  }
  return v26 == 0;
}

char *firehose_buffer_stream_chunk_install(mach_port_context_t a1, uint64_t a2, void *a3, unsigned __int8 a4)
{
  mach_port_context_t v45 = a1;
  uint64_t v44 = a2;
  BOOL v43 = a3;
  unsigned __int8 v42 = a4;
  uint64_t i = 0;
  unint64_t v40 = 0;
  unint64_t v39 = 0;
  BOOL v38 = 0;
  uint64_t v36 = a1 + 640 + ((unint64_t)*(unsigned __int8 *)(a2 + 12) << 7);
  if (a4)
  {
    BOOL v34 = 0;
    mach_port_context_t v47 = v45;
    unsigned __int8 v46 = v42;
    BOOL v33 = (void *)(v45 + ((unint64_t)v42 << 12));
    if (*v33) {
      __memset_chk();
    }
    if (*(unsigned char *)(v44 + 12) == 3) {
      atomic_fetch_or_explicit((atomic_ullong *volatile)(a1 + 456), 1 << v42, memory_order_relaxed);
    }
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    unint64_t v35 = *(void *)(StatusReg - 8);
    uint64_t i = *(void *)v36;
    if ((i & 0x3F0000000000) == 0)
    {
      uint64_t v85 = (char *)(v45 + ((unint64_t)v42 << 12));
      uint64_t v84 = v44;
      char v83 = v43;
      unint64_t v82 = v35;
      uint64_t v81 = 0;
      uint64_t v80 = 0;
      unint64_t v79 = 0;
      uint64_t v78 = 0;
      __int16 v77 = 24;
      __int16 v76 = 16;
      unsigned __int16 v75 = 4096;
      unint64_t v90 = *(void *)v44;
      if (v90 <= 0x1000000000) {
        unint64_t v25 = 0;
      }
      else {
        unint64_t v25 = v90 - 0x1000000000;
      }
      *((void *)v85 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v25;
      unint64_t v79 = v85 + 16;
      if ((*(unsigned __int16 *)(v84 + 8) + 24) % 8) {
        int v24 = *(unsigned __int16 *)(v84 + 8) + 24 + 8 - (*(unsigned __int16 *)(v84 + 8) + 24) % 8;
      }
      else {
        LOWORD(v24) = *(_WORD *)(v84 + 8) + 24;
      }
      v76 += v24;
      v75 -= *(_WORD *)(v84 + 10);
      uint64_t v78 = *(void *)v84 - *((void *)v85 + 1);
      v78 |= (unint64_t)*(unsigned __int16 *)(v84 + 8) << 48;
      uint64_t v74 = v78;
      uint64_t v73 = v78;
      *((void *)v79 + 2) = v78;
      uint64_t v72 = v74;
      *((void *)v79 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v82;
      __src[0] = v76;
      __src[1] = v75;
      __src[2] = 1;
      LOBYTE(__src[3]) = *(unsigned char *)(v84 + 12);
      HIBYTE(__src[3]) &= ~1u;
      HIBYTE(__src[3]) = HIBYTE(__src[3]) & 0xFD | (2 * (*(unsigned char *)(v84 + 14) & 1));
      HIBYTE(__src[3]) = HIBYTE(__src[3]) & 0xFB | (4 * ((*(unsigned char *)(v84 + 14) & 2) != 0));
      HIBYTE(__src[3]) &= 7u;
      memcpy(v85, __src, 8uLL);
      if (v83) {
        *char v83 = &v85[v75];
      }
      unint64_t v39 = v79;
      BOOL v32 = 0;
      uint64_t i = *(void *)v36;
      do
      {
        if ((i & 0x3F0000000000) != 0) {
          break;
        }
        LODWORD(v3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
        WORD2(v3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = __PAIR16__(BYTE5(v31), v42) & 0xC0FF;
        BYTE5(v31) &= 0x3Fu;
        HIWORD(v3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = HIWORD(i) + 1;
        unint64_t v40 = v31;
        uint64_t v4 = i;
        uint64_t v5 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v36, (unint64_t *)&v5, v31, memory_order_release, memory_order_relaxed);
        if (v5 != v4) {
          uint64_t i = v5;
        }
        BOOL v32 = v5 == v4;
      }
      while (v5 != v4);
      BOOL v34 = v32;
    }
    if (!v34)
    {
      atomic_load_explicit((atomic_ullong *volatile)v36, memory_order_acquire);
      unint64_t v30 = *(void *)(v36 + 8);
      *(void *)(v36 + 8) = 0;
      mach_continuous_time();
      __dst = v33;
      uint64_t v69 = v44;
      BOOL v68 = v43;
      unint64_t v67 = v35;
      int v66 = &v38;
      unint64_t v65 = v30;
      int v64 = 0;
      uint64_t v63 = 0;
      __int16 v62 = 24;
      __int16 v61 = 16;
      unsigned __int16 v60 = 4096;
      if (&v38)
      {
        __int16 v59 = 24;
        unint64_t v58 = 0;
        unint64_t v57 = 0;
        __int16 v56 = 0;
        if (*(void *)v69 >= v65) {
          unint64_t v23 = v65;
        }
        else {
          unint64_t v23 = *(void *)v69;
        }
        unint64_t v57 = v23;
        unint64_t v91 = v23;
        if (v23 <= 0x1000000000) {
          unint64_t v22 = 0;
        }
        else {
          unint64_t v22 = v91 - 0x1000000000;
        }
        *((void *)__dst + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v22;
        unint64_t v6 = *(void *)v69;
        BOOL v96 = __dst;
        unint64_t v95 = v6;
        if ((v6 - *((void *)__dst + 1)) >> 48) {
          *((void *)__dst + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *(void *)v69 - 0x1000000000;
        }
        *int v66 = (unint64_t *)((char *)__dst + 16);
        unsigned int v94 = __dst;
        unint64_t v93 = v65;
        if ((v65 - *((void *)__dst + 1)) >> 48) {
          unint64_t v21 = *(void *)v69;
        }
        else {
          unint64_t v21 = v65;
        }
        unint64_t v58 = v21;
        uint64_t v63 = (v21 - *((void *)__dst + 1)) | 0x18000000000000;
        uint64_t v55 = v63;
        uint64_t v7 = *v66;
        uint64_t v54 = v63;
        v7[2] = v63;
        uint64_t v53 = v55;
        (*v66)[1] = v67;
        __int16 v56 = 48;
        v61 += 48;
        int v64 = (char *)__dst + 64;
      }
      else
      {
        unint64_t v92 = *(void *)v69;
        if (v92 <= 0x1000000000) {
          unint64_t v20 = 0;
        }
        else {
          unint64_t v20 = v92 - 0x1000000000;
        }
        *((void *)__dst + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v20;
        int v64 = (char *)__dst + 16;
      }
      if ((*(unsigned __int16 *)(v69 + 8) + 24) % 8) {
        int v19 = *(unsigned __int16 *)(v69 + 8) + 24 + 8 - (*(unsigned __int16 *)(v69 + 8) + 24) % 8;
      }
      else {
        LOWORD(v19) = *(_WORD *)(v69 + 8) + 24;
      }
      v61 += v19;
      v60 -= *(_WORD *)(v69 + 10);
      uint64_t v63 = *(void *)v69 - *((void *)__dst + 1);
      v63 |= (unint64_t)*(unsigned __int16 *)(v69 + 8) << 48;
      uint64_t v52 = v63;
      uint64_t v51 = v63;
      *((void *)v64 + 2) = v63;
      uint64_t v50 = v52;
      *((void *)v64 + _dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v67;
      v49[0] = v61;
      v49[1] = v60;
      v49[2] = 1;
      LOBYTE(v49[3]) = *(unsigned char *)(v69 + 12);
      HIBYTE(v49[3]) &= ~1u;
      HIBYTE(v49[3]) = HIBYTE(v49[3]) & 0xFD | (2 * (*(unsigned char *)(v69 + 14) & 1));
      HIBYTE(v49[3]) = HIBYTE(v49[3]) & 0xFB | (4 * ((*(unsigned char *)(v69 + 14) & 2) != 0));
      HIBYTE(v49[3]) &= 7u;
      memcpy(__dst, v49, 8uLL);
      if (v68) {
        *BOOL v68 = (char *)__dst + v60;
      }
      unint64_t v39 = v64;
      for (uint64_t i = *(void *)v36; ; uint64_t i = v9)
      {
        LODWORD(v29) = 0;
        WORD2(v29) = __PAIR16__(BYTE5(v29), v42) & 0xC0FF;
        BYTE5(v29) &= 0x3Fu;
        HIWORD(v29) = HIWORD(i) + 1;
        unint64_t v40 = v29;
        uint64_t v8 = i;
        uint64_t v9 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v36, (unint64_t *)&v9, v29, memory_order_release, memory_order_relaxed);
        if (v9 == v8) {
          break;
        }
      }
      __memcpy_chk();
      LODWORD(v28) = 7;
      HIDWORD(v28) = *(unsigned __int8 *)(v44 + 12);
      atomic_store(v28, v38);
    }
  }
  else
  {
    uint64_t i = *(void *)v36;
    if ((i & 0x400000000000) != 0)
    {
      for (uint64_t i = *(void *)v36; ; uint64_t i = v13)
      {
        LODWORD(v26) = 0;
        BYTE4(v26) = 0;
        char v17 = (BYTE5(i) & 0x3Fu) + 1 >= 0x3F ? 63 : (BYTE5(i) & 0x3F) + 1;
        BYTE5(v26) = v17 & 0x3F | 0x40;
        HIWORD(v26) = HIWORD(i);
        unint64_t v40 = v26;
        uint64_t v12 = i;
        uint64_t v13 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v36, (unint64_t *)&v13, v26, memory_order_relaxed, memory_order_relaxed);
        if (v13 == v12) {
          break;
        }
      }
    }
    else
    {
      *(void *)(v36 + 8) = mach_continuous_time();
      for (uint64_t i = *(void *)v36; ; uint64_t i = v11)
      {
        LODWORD(v27) = 0;
        BYTE4(v27) = 0;
        char v18 = (BYTE5(i) & 0x3Fu) + 1 >= 0x3F ? 63 : (BYTE5(i) & 0x3F) + 1;
        BYTE5(v27) = v18 & 0x3F | 0x40;
        HIWORD(v27) = HIWORD(i);
        unint64_t v40 = v27;
        uint64_t v10 = i;
        uint64_t v11 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)v36, (unint64_t *)&v11, v27, memory_order_release, memory_order_relaxed);
        if (v11 == v10) {
          break;
        }
      }
    }
  }
  uint64_t v14 = *(void *)(v44 + 8);
  unint64_t v89 = *(void *)v44;
  uint64_t v88 = v14;
  uint64_t v87 = i;
  unint64_t v86 = v40;
  int v101 = 772145172;
  unint64_t v100 = v89;
  uint64_t v99 = v14;
  uint64_t v98 = i;
  unint64_t v97 = v40;
  if (MEMORY[0xFFFFFC100]) {
    kdebug_trace();
  }
  if ((i & 3) != 0) {
    _dispatch_gate_broadcast_slow(v36, i);
  }
  if (BYTE4(i) == 255) {
    firehose_buffer_update_limits(v45);
  }
  if (*(unsigned char *)(a1 + 1568) == 1)
  {
    char v15 = 1;
    atomic_compare_exchange_strong_explicit((atomic_uchar *volatile)(a1 + 1568), (unsigned __int8 *)&v15, 2u, memory_order_relaxed, memory_order_relaxed);
    if (v15 == 1) {
      firehose_client_start_quarantine(v45);
    }
  }
  return v39;
}

char *firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(mach_port_context_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_context_t v33 = a1;
  uint64_t v32 = a2;
  unint64_t v31 = a3;
  char v30 = 0;
  char v30 = *(unsigned char *)(a2 + 14) & 1;
  unsigned __int8 v29 = v30 & 1;
  mach_port_context_t v28 = a1 + 448;
  unint64_t v27 = 0;
  int v24 = 5;
  do
  {
    int v8 = v24--;
    BOOL v23 = 0;
    if (v8) {
      BOOL v23 = firehose_drain_notifications_once(v33);
    }
  }
  while (v23);
  if (((*(unsigned char *)(v32 + 13) ^ 1) & 1) == 0)
  {
    unsigned __int8 v25 = *(unsigned char *)(v28 + 4);
    goto LABEL_23;
  }
  unint64_t v27 = *(void *)v28;
  while (1)
  {
    mach_port_context_t v48 = v33;
    char v47 = v30 & 1;
    unsigned __int8 v46 = &v27;
    BOOL v45 = 0;
    uint64_t v44 = (atomic_ullong *)(v33 + 448);
    unint64_t v43 = v27;
    unint64_t v42 = 0;
    do
    {
      if (!*((_WORD *)&v43 + (v47 & 1)))
      {
        char v49 = 0;
        goto LABEL_14;
      }
      unint64_t v42 = v43;
      --*((_WORD *)&v42 + (v47 & 1));
      unint64_t v41 = v43;
      BOOL v40 = 0;
      unint64_t v38 = v42;
      unint64_t v37 = v42;
      unint64_t v39 = v42;
      unint64_t v9 = v43;
      unint64_t v10 = v43;
      atomic_compare_exchange_strong_explicit(v44, &v10, v42, memory_order_acquire, memory_order_acquire);
      if (v10 != v9) {
        unint64_t v41 = v10;
      }
      BOOL v36 = v10 == v9;
      BOOL v40 = v10 == v9;
      unint64_t v43 = v41;
      BOOL v35 = v40;
      BOOL v45 = v10 == v9;
    }
    while (v10 != v9);
    *unsigned __int8 v46 = v42;
    char v49 = 1;
LABEL_14:
    if (v49) {
      break;
    }
    if ((*(unsigned char *)(v32 + 14) & 2) != 0) {
      __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(v33, v30 & 1, &v27, a4, a5, a6, a7, a8);
    }
    else {
      firehose_client_send_push_and_wait(v33, v30 & 1, &v27, a4, a5, a6, a7, a8);
    }
    if (*(_DWORD *)(v33 + 1552 + 4 * v29) == -1) {
      return 0;
    }
  }
  unsigned __int8 v25 = BYTE4(v27);
  do
  {
LABEL_23:
    while (1)
    {
      mach_port_context_t v83 = v33;
      unint64_t v82 = 0;
      unint64_t v81 = 0;
      mach_port_context_t v80 = 0;
      __int16 v79 = 0;
      __int16 v78 = 0;
      unsigned __int16 v77 = 0;
      unsigned __int8 v76 = 0;
      mach_port_context_t v75 = 0;
      BOOL v74 = 0;
      BOOL v73 = 0;
      uint64_t v72 = (atomic_ullong *)(v33 + 256);
      unint64_t v81 = *(void *)(v33 + 256);
      do
      {
        unint64_t v82 = v81;
        if ((unsigned __int16)v81 == WORD1(v81))
        {
          if (WORD2(v81) == HIWORD(v81))
          {
            unsigned __int8 v84 = 0;
            goto LABEL_45;
          }
          ++WORD2(v82);
        }
        else
        {
          LOWORD(v82) = v82 + 1;
        }
        unint64_t v71 = v82;
        unint64_t v11 = v81;
        unint64_t v12 = v81;
        atomic_compare_exchange_strong_explicit(v72, &v12, v82, memory_order_relaxed, memory_order_relaxed);
        if (v12 != v11) {
          unint64_t v81 = v12;
        }
        BOOL v70 = v12 == v11;
        BOOL v73 = v12 == v11;
      }
      while (v12 != v11);
      BOOL v69 = v73;
      BOOL v74 = WORD2(v82) != WORD2(v81);
      if (WORD2(v82) == WORD2(v81))
      {
        mach_port_context_t v80 = v83;
        unsigned __int16 v77 = v81 & 0x3F;
      }
      else
      {
        mach_port_context_t v80 = v83 + 128;
        unsigned __int16 v77 = BYTE4(v81) & 0x3F;
      }
      int v68 = 0;
      mach_msg_timeout_t option_time = -1024;
      while (1)
      {
        __int16 v78 = *(_WORD *)(v80 + 2 * v77);
        int v68 = v78 & 0x3F;
        if (v68) {
          break;
        }
        int v13 = option_time++;
        if (v13 < 0) {
          __yield();
        }
        else {
          thread_switch(0, 4, option_time);
        }
      }
      int v66 = v68;
      __int16 v79 = (v78 & 0xFFC0) + 64;
      unsigned __int8 v76 = v78 & 0x3F;
      mach_port_context_t v86 = v83;
      char v85 = v78 & 0x3F;
      mach_port_context_t v75 = v83 + ((unint64_t)(v78 & 0x3F) << 12);
      if (!v74 && *(unsigned char *)(v75 + 6) == 3)
      {
        unint64_t v64 = ~(1 << v76);
        unint64_t v63 = v64;
        unint64_t v65 = v64;
        unint64_t v61 = 0;
        unint64_t v59 = v64;
        unint64_t v58 = v64;
        unint64_t v60 = v64;
        unint64_t v57 = atomic_fetch_and_explicit((atomic_ullong *volatile)(v83 + 456), v64, memory_order_relaxed);
        unint64_t v61 = v57;
        unint64_t v56 = v57;
        unint64_t v62 = v57 & v65;
      }
      uint64_t v55 = 0x100000000000000;
      uint64_t v54 = 0x100000000000000;
      *(void *)mach_port_context_t v75 = 0x100000000000000;
      uint64_t v53 = v55;
      __int16 v52 = v79;
      __int16 v51 = v79;
      *(_WORD *)(v80 + 2 * v77) = v79;
      __int16 v50 = v52;
      unsigned __int8 v84 = v76;
LABEL_45:
      unsigned __int8 v26 = v84;
      if (!v84) {
        break;
      }
      if (v84 >= (int)v25)
      {
        mach_port_context_t v92 = v33;
        unsigned __int8 v91 = v84;
        uint64_t v90 = 0x4000;
        uint64_t v89 = 15;
        uint64_t v88 = (atomic_uint *)(v33 + 536);
        uint64_t v87 = 0;
        int v101 = (atomic_uint *)(v33 + 536);
        unsigned int v100 = 0;
        unsigned int v119 = _dispatch_thread_getspecific(3uLL);
        unsigned int v100 = v119 & 0xFFFFFFFC;
        int v99 = 0;
        BOOL v98 = 0;
        unsigned int v96 = v119 & 0xFFFFFFFC;
        unsigned int v95 = v119 & 0xFFFFFFFC;
        unsigned int v97 = v119 & 0xFFFFFFFC;
        int v14 = 0;
        atomic_compare_exchange_strong_explicit(v101, (unsigned int *)&v14, v119 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
        if (v14) {
          int v99 = v14;
        }
        BOOL v94 = v14 == 0;
        BOOL v98 = v14 == 0;
        BOOL v93 = v98;
        if (v14) {
          _dispatch_unfair_lock_lock_slow(v101);
        }
        if (v91 >= (int)*(unsigned __int8 *)(v92 + 532))
        {
          uint64_t v15 = *(void *)(v92 + 520) & ~(1 << v91);
          *(void *)(v92 + 52pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v15;
          uint64_t v87 = v15;
          v91 &= 0xFCu;
          if ((v15 & (15 << v91)) == 0)
          {
            mach_port_context_t v104 = v92;
            unsigned __int8 v103 = v91;
            madvise((void *)(v92 + ((unint64_t)v91 << 12)), 0x4000uLL, 5);
          }
          unsigned __int8 v91 = 0;
        }
        mach_port_context_t v102 = v88;
        unint64_t v140 = v88;
        unsigned int v139 = 0;
        unsigned int v138 = 0;
        unsigned int v142 = _dispatch_thread_getspecific(3uLL);
        unsigned int v138 = v142 & 0xFFFFFFFC;
        unsigned int v137 = 0;
        int v135 = 0;
        int v134 = 0;
        int v136 = 0;
        unsigned int v133 = atomic_exchange_explicit(v140, 0, memory_order_release);
        unsigned int v137 = v133;
        unsigned int v132 = v133;
        unsigned int v139 = v133;
        if (v133 == v138)
        {
          BOOL v141 = 0;
        }
        else
        {
          _dispatch_unfair_lock_unlock_slow((uint64_t)v140, v139);
          unsigned int v143 = v139;
          BOOL v141 = (v139 & 2) != 0;
        }
        unsigned __int8 v26 = v91;
        if (!v91) {
          continue;
        }
      }
      return firehose_buffer_stream_chunk_install(v33, v32, v31, v26);
    }
    mach_port_context_t v108 = v28;
    __int16 v107 = v25;
    unsigned __int8 v106 = 0;
    unint64_t v105 = 0;
    unint64_t v117 = (atomic_uint *)(v28 + 88);
    unsigned int v116 = 0;
    unsigned int v120 = _dispatch_thread_getspecific(3uLL);
    unsigned int v116 = v120 & 0xFFFFFFFC;
    int v115 = 0;
    BOOL v114 = 0;
    unsigned int v112 = v120 & 0xFFFFFFFC;
    unsigned int v111 = v120 & 0xFFFFFFFC;
    unsigned int v113 = v120 & 0xFFFFFFFC;
    int v16 = 0;
    atomic_compare_exchange_strong_explicit(v117, (unsigned int *)&v16, v120 & 0xFFFFFFFC, memory_order_acquire, memory_order_acquire);
    if (v16) {
      int v115 = v16;
    }
    BOOL v110 = v16 == 0;
    BOOL v114 = v16 == 0;
    BOOL v109 = v114;
    if (v16) {
      _dispatch_unfair_lock_lock_slow(v117);
    }
    unint64_t v105 = ~(*(void *)(v108 + 72) | (-1 << v107));
    if (v105)
    {
      unint64_t v145 = v105;
      BOOL v147 = v105 != 0;
      uint64_t v146 = 45;
      unsigned __int8 v106 = __clz(__rbit64(v105));
      *(void *)(v108 + 72) |= (1 << v106);
    }
    mach_port_context_t v118 = v108 + 88;
    mach_port_context_t v129 = (atomic_uint *)(v108 + 88);
    unsigned int v128 = 0;
    unsigned int v127 = 0;
    unsigned int v131 = _dispatch_thread_getspecific(3uLL);
    unsigned int v127 = v131 & 0xFFFFFFFC;
    unsigned int v126 = 0;
    int v124 = 0;
    int v123 = 0;
    int v125 = 0;
    unsigned int v122 = atomic_exchange_explicit(v129, 0, memory_order_release);
    unsigned int v126 = v122;
    unsigned int v121 = v122;
    unsigned int v128 = v122;
    if (v122 == v127)
    {
      BOOL v130 = 0;
    }
    else
    {
      _dispatch_unfair_lock_unlock_slow((uint64_t)v129, v128);
      unsigned int v144 = v128;
      BOOL v130 = (v128 & 2) != 0;
    }
    unsigned __int8 v26 = v106;
    if (v106) {
      break;
    }
    if ((*(unsigned char *)(v32 + 14) & 2) != 0) {
      __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(v33, v30 & 1, 0, v17, v18, v19, v20, v21);
    }
    else {
      firehose_client_send_push_and_wait(v33, v30 & 1, 0, v17, v18, v19, v20, v21);
    }
  }
  while (*(_DWORD *)(v33 + 1552 + 4 * v29) != -1);
  return firehose_buffer_stream_chunk_install(v33, v32, v31, v26);
}

void firehose_client_start_quarantine(mach_port_context_t a1)
{
  if (*(uint64_t *)_voucher_libtrace_hooks > 4 && *(void *)(_voucher_libtrace_hooks + 40))
  {
    (*(void (**)(void))(_voucher_libtrace_hooks + 40))();
    *(unsigned char *)(a1 + 1569) = 1;
    unint64_t v29 = *(void *)(a1 + 768);
    if (BYTE4(v29) && BYTE4(*(void *)(a1 + 768)) != 255)
    {
      unint64_t v41 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v29) << 12));
      uint64_t v40 = -1;
      unsigned __int8 v39 = 1;
      unsigned __int8 v38 = 0;
      unsigned __int16 v37 = 1;
      unsigned __int16 v36 = 0;
      BOOL v35 = 0;
      __int16 v34 = 24;
      unint64_t i = 0;
      unint64_t v32 = 0;
      BOOL v30 = (-1 - v41[1]) >> 48 == 0;
      for (unint64_t i = *v41; ; unint64_t i = v9)
      {
        if (!i)
        {
          uint64_t v42 = 0;
          goto LABEL_31;
        }
        if ((HIWORD(i) & 0x1FF) != (unint64_t)v39)
        {
          uint64_t v42 = 0;
          goto LABEL_31;
        }
        unint64_t v32 = i;
        p_unint64_t i = &i;
        unsigned __int16 v91 = v37 + v36 + 24;
        if ((unsigned __int16)i + v91 <= WORD1(i) && v30)
        {
          if (v38 > (int)BYTE5(v32)) {
            BYTE5(v32) = v38;
          }
          if ((((_BYTE)v37 + 24) & 7) != 0) {
            int v19 = ((v37 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v19 = v37 + 24;
          }
          v32 += v19;
          v32 -= (unint64_t)v36 << 16;
          v32 += 0x100000000;
          uint64_t v90 = &v32;
          __int16 v89 = 40;
          if ((unsigned __int16)v32 + 40 > WORD1(v32)) {
            HIBYTE(v32) |= 1u;
          }
          char v31 = 0;
        }
        else
        {
          HIBYTE(v32) |= 1u;
          char v31 = 1;
        }
        unint64_t v8 = i;
        unint64_t v9 = i;
        atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + ((unint64_t)BYTE4(v29) << 12)), &v9, v32, memory_order_relaxed, memory_order_relaxed);
        if (v9 == v8) {
          break;
        }
      }
      if (v31)
      {
        if (BYTE4(v32)) {
          uint64_t v42 = 0;
        }
        else {
          uint64_t v42 = -1;
        }
      }
      else
      {
        if (v35) {
          *BOOL v35 = (char *)v41 + WORD1(v32);
        }
        uint64_t v42 = (unsigned __int16)i;
      }
LABEL_31:
      uint64_t v27 = v42;
      if (v42 < 0) {
        firehose_buffer_ring_enqueue(a1, BYTE4(v29));
      }
      if (v27 >= 1)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_F42C0 = v27;
        __break(1u);
        JUMPOUT(0xAB994);
      }
      unint64_t v28 = v29;
      BYTE4(v28) = 0;
      unint64_t v10 = v29;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 768), &v10, v28, memory_order_relaxed, memory_order_relaxed);
    }
    else
    {
      firehose_buffer_force_connect(a1, v1, v2, v3, v4, v5, v6, v7);
    }
    unint64_t v26 = *(void *)(a1 + 640);
    if (BYTE4(v26) && BYTE4(*(void *)(a1 + 640)) != 255)
    {
      mach_port_context_t v60 = a1 + ((unint64_t)BYTE4(v26) << 12);
      uint64_t v59 = -1;
      unsigned __int8 v58 = 0;
      unsigned __int8 v57 = 0;
      unsigned __int16 v56 = 1;
      unsigned __int16 v55 = 0;
      uint64_t v54 = 0;
      __int16 v53 = 24;
      unint64_t v52 = 0;
      unint64_t v51 = 0;
      char v50 = 0;
      BOOL v49 = 0;
      BOOL v49 = (unint64_t)(-1 - *(void *)(v60 + 8)) >> 48 == 0;
      BOOL v48 = 0;
      char v47 = (atomic_ullong *)v60;
      unint64_t v52 = *(void *)v60;
      do
      {
        if (!v52)
        {
          uint64_t v61 = 0;
          goto LABEL_65;
        }
        if ((HIWORD(v52) & 0x1FF) != (unint64_t)v58)
        {
          uint64_t v61 = 0;
          goto LABEL_65;
        }
        unint64_t v51 = v52;
        uint64_t v88 = &v52;
        unsigned __int16 v87 = v56 + v55 + 24;
        if ((unsigned __int16)v52 + v87 <= WORD1(v52) && v49)
        {
          if (v57 > (int)BYTE5(v51)) {
            BYTE5(v5_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v57;
          }
          if ((((_BYTE)v56 + 24) & 7) != 0) {
            int v18 = ((v56 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v18 = v56 + 24;
          }
          v51 += v18;
          v51 -= (unint64_t)v55 << 16;
          v51 += 0x100000000;
          __int16 v46 = 16;
          mach_port_context_t v86 = &v51;
          __int16 v85 = 40;
          if ((unsigned __int16)v51 + 40 > WORD1(v51)) {
            HIBYTE(v51) |= 1u;
          }
          char v50 = 0;
        }
        else
        {
          HIBYTE(v51) |= 1u;
          char v50 = 1;
        }
        unint64_t v45 = v51;
        unint64_t v11 = v52;
        unint64_t v12 = v52;
        atomic_compare_exchange_strong_explicit(v47, &v12, v51, memory_order_relaxed, memory_order_relaxed);
        if (v12 != v11) {
          unint64_t v52 = v12;
        }
        BOOL v44 = v12 == v11;
        BOOL v48 = v12 == v11;
      }
      while (v12 != v11);
      BOOL v43 = v48;
      if (v50)
      {
        if (BYTE4(v51)) {
          uint64_t v61 = 0;
        }
        else {
          uint64_t v61 = -1;
        }
      }
      else
      {
        if (v54) {
          *uint64_t v54 = v60 + WORD1(v51);
        }
        uint64_t v61 = (unsigned __int16)v52;
      }
LABEL_65:
      uint64_t v24 = v61;
      if (v61 < 0) {
        firehose_buffer_ring_enqueue(a1, BYTE4(v26));
      }
      if (v24 >= 1)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_F42C0 = v24;
        __break(1u);
        JUMPOUT(0xABE5CLL);
      }
      unint64_t v25 = v26;
      BYTE4(v25) = 0;
      unint64_t v13 = v26;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 640), &v13, v25, memory_order_relaxed, memory_order_relaxed);
    }
    else
    {
      firehose_buffer_force_connect(a1, v1, v2, v3, v4, v5, v6, v7);
    }
    unint64_t v23 = *(void *)(a1 + 896);
    if (BYTE4(v23) && BYTE4(*(void *)(a1 + 896)) != 255)
    {
      mach_port_context_t v79 = a1 + ((unint64_t)BYTE4(v23) << 12);
      uint64_t v78 = -1;
      unsigned __int8 v77 = 2;
      unsigned __int8 v76 = 0;
      unsigned __int16 v75 = 1;
      unsigned __int16 v74 = 0;
      BOOL v73 = 0;
      __int16 v72 = 24;
      unint64_t v71 = 0;
      unint64_t v70 = 0;
      char v69 = 0;
      BOOL v68 = 0;
      BOOL v68 = (unint64_t)(-1 - *(void *)(v79 + 8)) >> 48 == 0;
      BOOL v67 = 0;
      int v66 = (atomic_ullong *)v79;
      unint64_t v71 = *(void *)v79;
      do
      {
        if (!v71)
        {
          uint64_t v80 = 0;
          goto LABEL_99;
        }
        if ((HIWORD(v71) & 0x1FF) != (unint64_t)v77)
        {
          uint64_t v80 = 0;
          goto LABEL_99;
        }
        unint64_t v70 = v71;
        unsigned __int8 v84 = &v71;
        unsigned __int16 v83 = v75 + v74 + 24;
        if ((unsigned __int16)v71 + v83 <= WORD1(v71) && v68)
        {
          if (v76 > (int)BYTE5(v70)) {
            BYTE5(v7pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v76;
          }
          if ((((_BYTE)v75 + 24) & 7) != 0) {
            int v17 = ((v75 + 24) & 0x1FFF8) + 8;
          }
          else {
            int v17 = v75 + 24;
          }
          v70 += v17;
          v70 -= (unint64_t)v74 << 16;
          v70 += 0x100000000;
          __int16 v65 = 16;
          unint64_t v82 = &v70;
          __int16 v81 = 40;
          if ((unsigned __int16)v70 + 40 > WORD1(v70)) {
            HIBYTE(v70) |= 1u;
          }
          char v69 = 0;
        }
        else
        {
          HIBYTE(v70) |= 1u;
          char v69 = 1;
        }
        unint64_t v64 = v70;
        unint64_t v14 = v71;
        unint64_t v15 = v71;
        atomic_compare_exchange_strong_explicit(v66, &v15, v70, memory_order_relaxed, memory_order_relaxed);
        if (v15 != v14) {
          unint64_t v71 = v15;
        }
        BOOL v63 = v15 == v14;
        BOOL v67 = v15 == v14;
      }
      while (v15 != v14);
      BOOL v62 = v67;
      if (v69)
      {
        if (BYTE4(v70)) {
          uint64_t v80 = 0;
        }
        else {
          uint64_t v80 = -1;
        }
      }
      else
      {
        if (v73) {
          *BOOL v73 = v79 + WORD1(v70);
        }
        uint64_t v80 = (unsigned __int16)v71;
      }
LABEL_99:
      uint64_t v21 = v80;
      if (v80 < 0) {
        firehose_buffer_ring_enqueue(a1, BYTE4(v23));
      }
      if (v21 >= 1)
      {
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_F42C0 = v21;
        __break(1u);
        JUMPOUT(0xAC328);
      }
      unint64_t v22 = v23;
      BYTE4(v22) = 0;
      unint64_t v16 = v23;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)(a1 + 896), &v16, v22, memory_order_relaxed, memory_order_relaxed);
    }
    else
    {
      firehose_buffer_force_connect(a1, v1, v2, v3, v4, v5, v6, v7);
    }
  }
}

void __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(mach_port_context_t a1, char a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void firehose_client_send_push_and_wait(mach_port_context_t a1, char a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_context_t v28 = a1;
  char v27 = a2;
  unint64_t v26 = a3;
  unsigned __int8 v25 = a2 & 1;
  int v24 = 0;
  int v24 = *(_DWORD *)(a1 + 4 * (a2 & 1) + 1552);
  long long __s1 = 0uLL;
  int v22 = 0;
  int v21 = 0;
  if (v24 == -1) {
    return;
  }
  if (v24)
  {
    int v21 = firehose_send_push_and_wait(v24, &__s1, &v22);
    if (!v21) {
      goto LABEL_23;
    }
    if (v21 != 268435459)
    {
      if (v21 == -301)
      {
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xAC530);
      }
      int v20 = v21;
      uint64_t v32 = v21;
      uint64_t v31 = 681;
      _dispatch_bug(v31, v32, v8, a4, a5, a6, a7, a8);
      int v19 = v20;
    }
  }
  int v24 = firehose_client_reconnect(v28, v24, v25, a4, a5, a6, a7, a8);
  BOOL v15 = 0;
  if (v24) {
    BOOL v15 = v24 != -1;
  }
  if (!v15) {
    goto LABEL_20;
  }
  int v21 = firehose_send_push_and_wait(v24, &__s1, &v22);
  if (v21)
  {
    if (v21 != 268435459)
    {
      if (v21 == -301)
      {
        qword_F4290 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_F42C0 = -301;
        __break(1u);
        JUMPOUT(0xAC654);
      }
      int v18 = v21;
      uint64_t v30 = v21;
      uint64_t v29 = 693;
      _dispatch_bug(v29, v30, v9, v10, v11, v12, v13, v14);
      int v17 = v18;
    }
LABEL_20:
    if (v26)
    {
      __s2[4] = 0;
      *unint64_t v26 = *(void *)(v28 + 448);
    }
    return;
  }
LABEL_23:
  __s2[0] = -1;
  __s2[1] = -1;
  if (!memcmp(&__s1, __s2, 0x10uLL))
  {
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Memory corruption in the logging buffers";
    __break(1u);
    JUMPOUT(0xAC738);
  }
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 504), 1uLL, memory_order_relaxed);
  }
  else {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 480), 1uLL, memory_order_relaxed);
  }
  firehose_client_merge_updates(v28, 0, __s1, *((unint64_t *)&__s1 + 1), v22 != 0, v26);
}

uint64_t _dispatch_iocntl(uint64_t result, uint64_t a2)
{
  if (result <= 1)
  {
    uint64_t v3 = (result - 1);
    char v2 = 0;
  }
  else
  {
    uint64_t v3 = (result - 1);
    char v2 = 1;
  }
  if ((v2 & 1) == 0)
  {
    switch(v3)
    {
      case 0:
        dispatch_io_defaults = a2 * vm_page_size;
        break;
      case 1:
        qword_F4270 = a2;
        break;
      case 2:
        byte_F4280 = a2 != 0;
        break;
      case 3:
        qword_F4278 = a2;
        break;
      default:
        JUMPOUT(0);
    }
  }
  return result;
}

void _dispatch_io_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112) && (*(_DWORD *)(a1 + 120) & 3) == 0)
  {
    if (*(void *)(*(void *)(a1 + 112) + 8)) {
      **(void **)(*(void *)(a1 + 112) + 8) = 0;
    }
    _dispatch_fd_entry_release(*(void *)(a1 + 112));
  }
  if (*(void *)(a1 + 48)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
  }
  if (*(void *)(a1 + 56)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  }
  if (*(void *)(a1 + 64)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
  }
}

void _dispatch_fd_entry_release(uint64_t a1)
{
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  dispatch_io_type_t v38 = type;
  dispatch_fd_t v37 = fd;
  dispatch_queue_t v36 = queue;
  BOOL v35 = cleanup_handler;
  if (type && v38 != 1) {
    return 0;
  }
  __int16 v34 = _dispatch_io_create(v38, *(uint64_t *)&fd, (uint64_t)queue, (uint64_t)cleanup_handler, v4, v5, v6, v7);
  *((_DWORD *)v34 + 3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v37;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: create", v8, v9, v10, v11, v12, v13, v14, 363);
  *((_DWORD *)v34 + 32) = v37;
  dispatch_object_t v33 = (dispatch_object_t)v34[6];
  dispatch_suspend(v33);
  dispatch_queue_t v32 = v36;
  _dispatch_retain((uint64_t)v36);
  uint64_t v31 = v34;
  _dispatch_retain((uint64_t)v34);
  int v22 = _NSConcreteStackBlock;
  int v23 = 1107296256;
  int v24 = 0;
  unsigned __int8 v25 = __dispatch_io_create_block_invoke;
  unint64_t v26 = &__block_descriptor_tmp_2;
  mach_port_context_t v28 = v34;
  dispatch_io_type_t v29 = v38;
  dispatch_queue_t v30 = v36;
  char v27 = v35;
  _dispatch_fd_entry_init_async(v37, (uint64_t)&v22);
  _dispatch_object_debug(v34, "%s", v15, v16, v17, v18, v19, v20, (char)"dispatch_io_create");
  return (dispatch_io_t)v34;
}

void *_dispatch_io_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = _dispatch_object_alloc((uint64_t)_OS_dispatch_io_vtable, 0x98uLL, a3, a4, a5, a6, a7, a8);
  v9[2] = -1985229329;
  v9[3] = &off_F0680;
  v9[9] = a1;
  v9[11] = -1;
  v9[10] = qword_F4270 * dispatch_io_defaults;
  v9[6] = dispatch_queue_create("com.apple.libdispatch-io.channelq", 0);
  return v9;
}

void _dispatch_fd_entry_init_async(int a1, uint64_t a2)
{
  int v10 = a1;
  uint64_t v9 = a2;
  uint64_t v13 = &_dispatch_io_init_pred;
  uint64_t v12 = 0;
  uint64_t v11 = _dispatch_io_queues_init;
  if (_dispatch_io_init_pred != -1) {
    dispatch_once_f(v13, v12, (dispatch_function_t)v11);
  }
  blocint k = _NSConcreteStackBlock;
  int v3 = 1107296256;
  int v4 = 0;
  uint64_t v5 = ___dispatch_fd_entry_init_async_block_invoke;
  uint64_t v6 = &__block_descriptor_tmp_175;
  int v8 = v10;
  uint64_t v7 = v9;
  dispatch_channel_async((dispatch_queue_t)_dispatch_io_fds_lockq, &block);
}

void __dispatch_io_create_block_invoke(uint64_t *a1, uint64_t a2)
{
  int v17 = *(_DWORD *)(a2 + 24);
  if (!v17) {
    int v17 = _dispatch_io_validate_type(a1[5], *(_WORD *)(a2 + 36));
  }
  if (!v17 && a1[6] == 1)
  {
    do
    {
      off_t v16 = lseek(*(_DWORD *)a2, 0, 1);
      if (v16 == -1) {
        int v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
      else {
        int v14 = 0;
      }
      int v17 = v14;
      if (!v14)
      {
        *(void *)(a1[5] + 136) = v16;
        goto LABEL_13;
      }
    }
    while (v14 == 4);
    _dispatch_bug(389, v14, v2, v3, v4, v5, v6, v7);
  }
LABEL_13:
  *(_DWORD *)(a1[5] + 144) = v17;
  _dispatch_fd_entry_retain(a2);
  _dispatch_io_init((void *)a1[5], a2, a1[7], v17, a1[4]);
  dispatch_resume(*(dispatch_object_t *)(a1[5] + 48));
  _dispatch_object_debug((uint64_t *)a1[5], "%s", v8, v9, v10, v11, v12, v13, (char)"dispatch_io_create_block_invoke");
  _dispatch_release(a1[5]);
  _dispatch_release(a1[7]);
}

uint64_t _dispatch_io_validate_type(uint64_t a1, __int16 a2)
{
  unsigned int v3 = 0;
  if ((a2 & 0xF000) == 0x4000)
  {
    return 21;
  }
  else if (*(void *)(a1 + 72) == 1 && ((a2 & 0xF000) == 0x1000 || (a2 & 0xF000) == 0xC000))
  {
    return 29;
  }
  return v3;
}

void _dispatch_fd_entry_retain(uint64_t a1)
{
}

void _dispatch_io_init(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  int v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  int v18 = a4;
  uint64_t v17 = a5;
  if (a5)
  {
    uint64_t v16 = v19;
    _dispatch_retain(v19);
    if (v18) {
      dispatch_queue_t queue = (dispatch_queue_s *)v21[6];
    }
    else {
      dispatch_queue_t queue = *(dispatch_queue_s **)(v20 + 64);
    }
    blocint k = _NSConcreteStackBlock;
    int v8 = 1107296256;
    int v9 = 0;
    uint64_t v10 = ___dispatch_io_init_block_invoke;
    uint64_t v11 = &__block_descriptor_tmp_105;
    uint64_t v13 = v19;
    int v14 = v21;
    int v15 = v18;
    uint64_t v12 = v17;
    dispatch_channel_async(queue, &block);
  }
  if (v20)
  {
    v21[14] = v20;
    dispatch_retain(*(dispatch_object_t *)(v20 + 72));
    dispatch_retain(*(dispatch_object_t *)(v20 + 80));
    v21[7] = *(void *)(v20 + 72);
    v21[8] = *(void *)(v20 + 80);
  }
  else
  {
    dispatch_queue_t v5 = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0);
    v21[7] = v5;
    v21[8] = dispatch_group_create();
  }
}

void __copy_helper_block_8_32b(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_8_32b(uint64_t a1)
{
}

dispatch_io_t dispatch_io_create_f(dispatch_io_type_t a1, dispatch_fd_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_io_type_t v17 = a1;
  dispatch_fd_t v16 = a2;
  int v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  if (!a5) {
    return dispatch_io_create(a1, a2, a3, 0);
  }
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  int v9 = __dispatch_io_create_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_4;
  uint64_t v11 = v13;
  uint64_t v12 = v14;
  return dispatch_io_create(a1, a2, a3, &v6);
}

uint64_t __dispatch_io_create_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), a2);
}

dispatch_io_t dispatch_io_create_with_path(dispatch_io_type_t type, const char *path, int oflag, mode_t mode, dispatch_queue_t queue, void *cleanup_handler)
{
  dispatch_io_type_t v47 = type;
  __int16 v46 = path;
  int v45 = oflag;
  mode_t v44 = mode;
  dispatch_queue_t v43 = queue;
  uint64_t v42 = cleanup_handler;
  if (type && v47 != 1) {
    return 0;
  }
  if (*v46 != 47) {
    return 0;
  }
  size_t v41 = strlen(v46);
  uint64_t v40 = malloc_type_malloc();
  if (!v40) {
    return 0;
  }
  unsigned __int8 v39 = _dispatch_io_create(v47, v6, v7, v8, v9, v10, v11, v12);
  *((_DWORD *)v39 + 3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = -1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: create with path %s", v13, v14, v15, v16, v17, v18, v19, 444);
  *((_DWORD *)v39 + 32) = -1;
  *(void *)uint64_t v40 = v39;
  *(_DWORD *)(v40 + 8) = v45;
  *(_WORD *)(v40 + 12) = v44;
  *(void *)(v40 + 16) = v41;
  __memcpy_chk();
  dispatch_queue_t v38 = v43;
  _dispatch_retain((uint64_t)v43);
  dispatch_fd_t v37 = v39;
  _dispatch_retain((uint64_t)v39);
  uint64_t v20 = (dispatch_queue_s *)v39[6];
  blocint k = _NSConcreteStackBlock;
  int v29 = 1107296256;
  int v30 = 0;
  uint64_t v31 = __dispatch_io_create_with_path_block_invoke;
  dispatch_queue_t v32 = &__block_descriptor_tmp_12;
  uint64_t v34 = v40;
  BOOL v35 = v39;
  dispatch_queue_t v36 = v43;
  dispatch_object_t v33 = v42;
  dispatch_channel_async(v20, &block);
  _dispatch_object_debug(v39, "%s", v21, v22, v23, v24, v25, v26, (char)"dispatch_io_create_with_path");
  return (dispatch_io_t)v39;
}

void __dispatch_io_create_with_path_block_invoke(uint64_t a1)
{
  uint64_t v29 = a1;
  uint64_t v28 = a1;
  int v27 = 0;
  memset(&__b, 0, sizeof(__b));
  do
  {
    if ((*(_DWORD *)(*(void *)(a1 + 40) + 8) & 0x100) == 0x100
      || (*(_DWORD *)(*(void *)(a1 + 40) + 8) & 0x200000) == 0x200000)
    {
      int v9 = lstat((const char *)(*(void *)(a1 + 40) + 24), &__b);
    }
    else
    {
      int v9 = stat((const char *)(*(void *)(a1 + 40) + 24), &__b);
    }
    if (v9 == -1)
    {
      uint64_t v35 = 1;
      uint64_t v38 = 1;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v8 = **(_DWORD **)(StatusReg + 8);
    }
    else
    {
      int v8 = 0;
    }
    int v27 = v8;
    if (!v8)
    {
      int v27 = _dispatch_io_validate_type(*(void *)(a1 + 48), __b.st_mode);
      goto LABEL_31;
    }
  }
  while (v8 == 4);
  if ((*(_DWORD *)(*(void *)(a1 + 40) + 8) & 0x200) != 0
    && *(unsigned char *)(*(void *)(a1 + 40) + 24 + *(void *)(*(void *)(a1 + 40) + 16) - 1) != 47)
  {
    uint64_t v25 = 0;
    uint64_t i = 0;
    for (uint64_t i = *(void *)(*(void *)(a1 + 40) + 16) - 1; i >= 0; --i)
    {
      if (*(unsigned char *)(*(void *)(a1 + 40) + 24 + i) == 47)
      {
        uint64_t v25 = (unsigned char *)(*(void *)(a1 + 40) + 24 + i);
        break;
      }
    }
    uint64_t v31 = v25;
    uint64_t v30 = 480;
    if (!v25) {
      _dispatch_abort(v30, 0, v1, v2, v3, v4, v5, v6);
    }
    *uint64_t v25 = 0;
    int v23 = 0;
    while (1)
    {
      if (stat((const char *)(*(void *)(a1 + 40) + 24), &__b) == -1)
      {
        uint64_t v36 = 1;
        uint64_t v37 = 1;
        unint64_t v40 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        int v7 = **(_DWORD **)(v40 + 8);
      }
      else
      {
        int v7 = 0;
      }
      int v23 = v7;
      if (!v7) {
        break;
      }
      if (v7 != 4) {
        goto LABEL_30;
      }
    }
    __b.st_mode = 0x8000;
    int v27 = 0;
LABEL_30:
    *uint64_t v25 = 47;
  }
LABEL_31:
  *(_DWORD *)(*(void *)(a1 + 48) + 144) = v27;
  if (v27)
  {
    free(*(void **)(a1 + 40));
    _dispatch_io_init(*(void **)(a1 + 48), 0, *(void *)(a1 + 56), v27, *(void *)(a1 + 32));
    uint64_t v22 = *(void *)(a1 + 48);
    _dispatch_release(v22);
    _dispatch_release(*(void *)(a1 + 56));
  }
  else
  {
    dispatch_object_t object = *(dispatch_object_t *)(*(void *)(a1 + 48) + 48);
    dispatch_suspend(object);
    uint64_t v34 = &_dispatch_io_init_pred;
    dispatch_object_t v33 = 0;
    dispatch_queue_t v32 = _dispatch_io_queues_init;
    if (_dispatch_io_init_pred != -1) {
      dispatch_once_f(v34, v33, (dispatch_function_t)v32);
    }
    uint64_t v11 = _NSConcreteStackBlock;
    int v12 = 1107296256;
    int v13 = 0;
    uint64_t v14 = __dispatch_io_create_with_path_block_invoke_2;
    uint64_t v15 = &__block_descriptor_tmp_9_0;
    uint64_t v17 = *(void *)(a1 + 40);
    memcpy(v18, &__b, sizeof(v18));
    uint64_t v19 = *(void *)(a1 + 48);
    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v16 = *(void *)(a1 + 32);
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &v11);
  }
}

dispatch_queue_t _dispatch_io_queues_init()
{
  _dispatch_io_fds_lockq = (uint64_t)dispatch_queue_create("com.apple.libdispatch-io.fd_lockq", 0);
  dispatch_queue_t result = dispatch_queue_create("com.apple.libdispatch-io.dev_lockq", 0);
  _dispatch_io_devs_lockq = (uint64_t)result;
  return result;
}

void __dispatch_io_create_with_path_block_invoke_2(uint64_t a1)
{
  int v8 = _dispatch_fd_entry_create_with_path(*(void *)(a1 + 40), *(_DWORD *)(a1 + 48), *(_WORD *)(a1 + 52));
  _dispatch_io_init(*(void **)(a1 + 192), (uint64_t)v8, *(void *)(a1 + 200), 0, *(void *)(a1 + 32));
  dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 192) + 48));
  _dispatch_object_debug(*(uint64_t **)(a1 + 192), "%s", v1, v2, v3, v4, v5, v6, (char)"dispatch_io_create_with_path_block_invoke_2");
  _dispatch_release(*(void *)(a1 + 192));
  _dispatch_release(*(void *)(a1 + 200));
}

void *_dispatch_fd_entry_create_with_path(uint64_t a1, int a2, __int16 a3)
{
  uint64_t v34 = a1;
  int v33 = a2;
  __int16 v32 = a3;
  uint64_t v31 = 0;
  uint64_t v31 = (void *)_dispatch_fd_entry_create(*(dispatch_queue_s **)(*(void *)a1 + 48));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: create: path %s", v3, v4, v5, v6, v7, v8, v9, 1588);
  if ((v32 & 0xF000) == 0x8000) {
    _dispatch_disk_init(v31, HIBYTE(v33), v10, v11, v12, v13, v14, v15);
  }
  else {
    _dispatch_stream_init((uint64_t)v31, (dispatch_queue_s *)&off_F0600);
  }
  *(_DWORD *)uint64_t v31 = -1;
  *((_DWORD *)v31 + 4) = -1;
  v31[1] = v34;
  *((_DWORD *)v31 + 8) = v33;
  *((_WORD *)v31 + 18) = v32;
  v31[9] = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0);
  v31[10] = dispatch_group_create();
  uint64_t v16 = (dispatch_queue_s *)v31[8];
  blocint k = _NSConcreteStackBlock;
  int v26 = 0x40000000;
  int v27 = 0;
  uint64_t v28 = ___dispatch_fd_entry_create_with_path_block_invoke;
  uint64_t v29 = &__block_descriptor_tmp_191;
  uint64_t v30 = v31;
  dispatch_channel_async(v16, &block);
  uint64_t v17 = (dispatch_queue_s *)v31[8];
  uint64_t v19 = _NSConcreteStackBlock;
  int v20 = 0x40000000;
  int v21 = 0;
  uint64_t v22 = ___dispatch_fd_entry_create_with_path_block_invoke_2;
  int v23 = &__block_descriptor_tmp_192;
  uint64_t v24 = v31;
  dispatch_channel_async(v17, &v19);
  return v31;
}

dispatch_io_t dispatch_io_create_with_path_f(dispatch_io_type_t a1, const char *a2, int a3, mode_t a4, dispatch_queue_s *a5, uint64_t a6, uint64_t a7)
{
  dispatch_io_type_t v21 = a1;
  int v20 = a2;
  int v19 = a3;
  mode_t v18 = a4;
  uint64_t v17 = a5;
  uint64_t v16 = a6;
  uint64_t v15 = a7;
  if (!a7) {
    return dispatch_io_create_with_path(a1, a2, a3, a4, a5, 0);
  }
  uint64_t v8 = _NSConcreteStackBlock;
  int v9 = 0x40000000;
  int v10 = 0;
  uint64_t v11 = __dispatch_io_create_with_path_f_block_invoke;
  uint64_t v12 = &__block_descriptor_tmp_13;
  uint64_t v13 = v15;
  uint64_t v14 = v16;
  return dispatch_io_create_with_path(a1, a2, a3, a4, a5, &v8);
}

uint64_t __dispatch_io_create_with_path_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), a2);
}

dispatch_io_t dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t io, dispatch_queue_t queue, void *cleanup_handler)
{
  dispatch_io_type_t v41 = type;
  dispatch_io_t v40 = io;
  dispatch_queue_t v39 = queue;
  uint64_t v38 = cleanup_handler;
  if (type && v41 != 1) {
    return 0;
  }
  uint64_t v37 = _dispatch_io_create(v41, (uint64_t)io, (uint64_t)queue, (uint64_t)cleanup_handler, v4, v5, v6, v7);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: create with channel %p", v8, v9, v10, v11, v12, v13, v14, 544);
  dispatch_object_t v36 = (dispatch_object_t)v37[6];
  dispatch_suspend(v36);
  dispatch_queue_t v35 = v39;
  _dispatch_retain((uint64_t)v39);
  uint64_t v34 = v37;
  _dispatch_retain((uint64_t)v37);
  dispatch_io_t v33 = v40;
  _dispatch_retain((uint64_t)v40);
  uint64_t v15 = (dispatch_queue_s *)*((void *)v40 + 6);
  blocint k = _NSConcreteStackBlock;
  int v24 = 1107296256;
  int v25 = 0;
  int v26 = __dispatch_io_create_with_io_block_invoke;
  int v27 = &__block_descriptor_tmp_23;
  dispatch_io_t v29 = v40;
  uint64_t v30 = v37;
  dispatch_queue_t v31 = v39;
  uint64_t v28 = v38;
  dispatch_io_type_t v32 = v41;
  dispatch_channel_async(v15, &block);
  _dispatch_object_debug(v37, "%s", v16, v17, v18, v19, v20, v21, (char)"dispatch_io_create_with_io");
  return (dispatch_io_t)v37;
}

void __dispatch_io_create_with_io_block_invoke(uint64_t *a1)
{
  uint64_t v18 = a1;
  uint64_t v17 = a1;
  int error = 0;
  int error = _dispatch_io_get_error(0, a1[5], 0);
  if (error)
  {
    *(_DWORD *)(a1[6] + 144) = error;
    _dispatch_io_init((void *)a1[6], 0, a1[7], error, a1[4]);
    dispatch_object_t v15 = *(dispatch_object_t *)(a1[6] + 48);
    dispatch_resume(v15);
    uint64_t v14 = a1[6];
    _dispatch_release(v14);
    uint64_t v13 = a1[5];
    _dispatch_release(v13);
    _dispatch_release(a1[7]);
  }
  else
  {
    uint64_t v1 = *(dispatch_queue_s **)(a1[5] + 56);
    blocint k = _NSConcreteStackBlock;
    int v4 = 1107296256;
    int v5 = 0;
    uint64_t v6 = __dispatch_io_create_with_io_block_invoke_2;
    uint64_t v7 = &__block_descriptor_tmp_20;
    uint64_t v9 = a1[5];
    uint64_t v10 = a1[6];
    uint64_t v11 = a1[8];
    uint64_t v12 = a1[7];
    uint64_t v8 = a1[4];
    dispatch_channel_async(v1, &block);
  }
}

uint64_t _dispatch_io_get_error(uint64_t a1, uint64_t a2, char a3)
{
  if (a1) {
    a2 = *(void *)(a1 + 136);
  }
  if ((*(_DWORD *)(a2 + 120) & 3) != 0)
  {
    if ((a3 & 1) != 0 && (*(_DWORD *)(a2 + 120) & 2) == 0) {
      return 0;
    }
    else {
      return 89;
    }
  }
  else if (a1)
  {
    return *(unsigned int *)(*(void *)(a1 + 144) + 24);
  }
  else
  {
    return *(unsigned int *)(a2 + 144);
  }
}

void __dispatch_io_create_with_io_block_invoke_2(uint64_t *a1)
{
  dispatch_queue_t v39 = a1;
  uint64_t v38 = a1;
  int error = 0;
  int error = _dispatch_io_get_error(0, a1[5], 0);
  if (!error)
  {
    int error = *(_DWORD *)(a1[5] + 144);
    if (!error) {
      int error = *(_DWORD *)(*(void *)(a1[5] + 112) + 24);
    }
  }
  if (!error) {
    int error = _dispatch_io_validate_type(a1[6], *(_WORD *)(*(void *)(a1[5] + 112) + 36));
  }
  if (!error && a1[7] == 1 && *(_DWORD *)(a1[5] + 124) != -1)
  {
    off_t v36 = 0;
    do
    {
      off_t v36 = lseek(**(_DWORD **)(a1[5] + 112), 0, 1);
      if (v36 == -1)
      {
        uint64_t v42 = 1;
        uint64_t v43 = 1;
        unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        int v13 = **(_DWORD **)(StatusReg + 8);
      }
      else
      {
        int v13 = 0;
      }
      int error = v13;
      if (!v13)
      {
        *(void *)(a1[6] + 136) = v36;
        goto LABEL_20;
      }
    }
    while (v13 == 4);
    int v35 = error;
    uint64_t v41 = error;
    uint64_t v40 = 590;
    if (error) {
      _dispatch_bug(v40, v41, v1, v2, v3, v4, v5, v6);
    }
    int v34 = v35;
  }
LABEL_20:
  *(_DWORD *)(a1[6] + 144) = error;
  if (error)
  {
    _dispatch_io_init((void *)a1[6], 0, a1[8], error, a1[4]);
    dispatch_object_t v33 = *(dispatch_object_t *)(a1[6] + 48);
    dispatch_resume(v33);
    uint64_t v32 = a1[6];
    _dispatch_release(v32);
    uint64_t v31 = a1[5];
    _dispatch_release(v31);
    _dispatch_release(a1[8]);
  }
  else
  {
    if (*(_DWORD *)(a1[5] + 124) == -1)
    {
      *(_DWORD *)(a1[6] + 124) = -1;
      *(_DWORD *)(a1[6] + 128) = -1;
      __int16 v30 = 0;
      __int16 v30 = *(_WORD *)(*(void *)(a1[5] + 112) + 36);
      int v29 = 0;
      int v29 = *(_DWORD *)(*(void *)(a1[5] + 112) + 32);
      uint64_t v28 = 0;
      uint64_t v28 = *(void *)(*(void *)(*(void *)(a1[5] + 112) + 8) + 16) + 25;
      int v27 = (void *)malloc_type_malloc();
      __memcpy_chk();
      *int v27 = a1[6];
      blocint k = _NSConcreteStackBlock;
      int v17 = 1107296256;
      int v18 = 0;
      uint64_t v19 = __dispatch_io_create_with_io_block_invoke_3;
      uint64_t v20 = &__block_descriptor_tmp_17;
      uint64_t v22 = v27;
      int v25 = v29;
      __int16 v26 = v30;
      uint64_t v23 = a1[6];
      uint64_t v24 = a1[8];
      uint64_t v21 = a1[4];
      dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
    }
    else
    {
      uint64_t v15 = *(void *)(a1[5] + 112);
      *(_DWORD *)(a1[6] + 124) = *(_DWORD *)(a1[5] + 124);
      *(_DWORD *)(a1[6] + 128) = *(_DWORD *)(a1[5] + 128);
      _dispatch_fd_entry_retain(v15);
      _dispatch_io_init((void *)a1[6], v15, a1[8], 0, a1[4]);
      dispatch_resume(*(dispatch_object_t *)(a1[6] + 48));
      _dispatch_release(a1[6]);
      _dispatch_release(a1[8]);
    }
    _dispatch_release(a1[5]);
    _dispatch_object_debug((uint64_t *)a1[6], "%s", v7, v8, v9, v10, v11, v12, (char)"dispatch_io_create_with_io_block_invoke");
  }
}

void __dispatch_io_create_with_io_block_invoke_3(uint64_t a1)
{
  uint64_t v2 = _dispatch_fd_entry_create_with_path(*(void *)(a1 + 40), *(_DWORD *)(a1 + 64), *(_WORD *)(a1 + 68));
  _dispatch_io_init(*(void **)(a1 + 48), (uint64_t)v2, *(void *)(a1 + 56), 0, *(void *)(a1 + 32));
  dispatch_resume(*(dispatch_object_t *)(*(void *)(a1 + 48) + 48));
  _dispatch_release(*(void *)(a1 + 48));
  _dispatch_release(*(void *)(a1 + 56));
}

dispatch_io_t dispatch_io_create_with_io_f(dispatch_io_type_t a1, dispatch_io_s *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_io_type_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = a5;
  if (!a5) {
    return dispatch_io_create_with_io(a1, a2, a3, 0);
  }
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_create_with_io_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_24;
  uint64_t v11 = v13;
  uint64_t v12 = v14;
  return dispatch_io_create_with_io(a1, a2, a3, &v6);
}

uint64_t __dispatch_io_create_with_io_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), a2);
}

void dispatch_io_set_high_water(dispatch_io_t channel, size_t high_water)
{
  dispatch_io_t v12 = channel;
  size_t v11 = high_water;
  dispatch_io_t v10 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v2 = (dispatch_queue_s *)*((void *)v12 + 6);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_set_high_water_block_invoke;
  int v7 = &__block_descriptor_tmp_26;
  dispatch_io_t v8 = v12;
  size_t v9 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_set_high_water_block_invoke(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: set high water: %zu", v1, v2, v3, v4, v5, v6, v7, 662);
  if (*(void *)(*(void *)(a1 + 32) + 80) > *(void *)(a1 + 40)) {
    *(void *)(*(void *)(a1 + 32) + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(a1 + 40);
  }
  if (*(void *)(a1 + 40)) {
    uint64_t v8 = *(void *)(a1 + 40);
  }
  else {
    uint64_t v8 = 1;
  }
  *(void *)(*(void *)(a1 + 32) + 88) = v8;
  _dispatch_release(*(void *)(a1 + 32));
}

void dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water)
{
  dispatch_io_t v12 = channel;
  size_t v11 = low_water;
  dispatch_io_t v10 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v2 = (dispatch_queue_s *)*((void *)v12 + 6);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_set_low_water_block_invoke;
  uint64_t v7 = &__block_descriptor_tmp_28;
  dispatch_io_t v8 = v12;
  size_t v9 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_set_low_water_block_invoke(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: set low water: %zu", v1, v2, v3, v4, v5, v6, v7, 676);
  if (*(void *)(*(void *)(a1 + 32) + 88) < *(void *)(a1 + 40))
  {
    if (*(void *)(a1 + 40)) {
      uint64_t v8 = *(void *)(a1 + 40);
    }
    else {
      uint64_t v8 = 1;
    }
    *(void *)(*(void *)(a1 + 32) + 88) = v8;
  }
  *(void *)(*(void *)(a1 + 32) + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(a1 + 40);
  _dispatch_release(*(void *)(a1 + 32));
}

void dispatch_io_set_interval(dispatch_io_t channel, uint64_t interval, dispatch_io_interval_flags_t flags)
{
  dispatch_io_t v15 = channel;
  uint64_t v14 = interval;
  dispatch_io_interval_flags_t v13 = flags;
  dispatch_io_t v12 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v3 = (dispatch_queue_s *)*((void *)v15 + 6);
  blocint k = _NSConcreteStackBlock;
  int v5 = 0x40000000;
  int v6 = 0;
  uint64_t v7 = __dispatch_io_set_interval_block_invoke;
  uint64_t v8 = &__block_descriptor_tmp_30;
  dispatch_io_t v9 = v15;
  uint64_t v10 = v14;
  dispatch_io_interval_flags_t v11 = v13;
  dispatch_channel_async(v3, &block);
}

void __dispatch_io_set_interval_block_invoke(uint64_t *a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: set interval: %llu", v1, v2, v3, v4, v5, v6, v7, 692);
  if ((unint64_t)a1[5] >= 0x7FFFFFFFFFFFFFFFLL) {
    uint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v8 = a1[5];
  }
  *(void *)(a1[4] + 96) = v8;
  *(void *)(a1[4] + 104) = a1[6];
  _dispatch_release(a1[4]);
}

void _dispatch_io_set_target_queue(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = a1;
  uint64_t v12 = a2;
  uint64_t v11 = a2;
  _dispatch_retain(a2);
  uint64_t v10 = v13;
  _dispatch_retain(v13);
  uint64_t v2 = *(dispatch_queue_s **)(v13 + 48);
  uint64_t v3 = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = ___dispatch_io_set_target_queue_block_invoke;
  uint64_t v7 = &__block_descriptor_tmp_31;
  uint64_t v8 = v13;
  uint64_t v9 = v12;
  dispatch_channel_async(v2, &v3);
}

void ___dispatch_io_set_target_queue_block_invoke(uint64_t a1)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 24);
  *(void *)(*(void *)(a1 + 32) + 24) = *(void *)(a1 + 40);
  _dispatch_release(v8);
  _dispatch_object_debug(*(uint64_t **)(a1 + 32), "%s", v1, v2, v3, v4, v5, v6, (char)"_dispatch_io_set_target_queue_block_invoke");
  _dispatch_release(*(void *)(a1 + 32));
}

dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t channel)
{
  if ((*((_DWORD *)channel + 30) & 3) != 0) {
    return -1;
  }
  if (*((_DWORD *)channel + 32) == -1 && !_dispatch_io_get_error(0, (uint64_t)channel, 0))
  {
    for (uint64_t i = (char *)_dispatch_thread_getspecific(0x17uLL); i; uint64_t i = *(char **)i)
    {
      if (*((char **)i + 1) == "io")
      {
        uint64_t v5 = i;
        goto LABEL_11;
      }
    }
    uint64_t v5 = 0;
LABEL_11:
    if (v5 && *((dispatch_io_t *)v5 + 2) == channel) {
      _dispatch_fd_entry_open(*((void *)channel + 14), (uint64_t)channel);
    }
  }
  return *((_DWORD *)channel + 32);
}

uint64_t _dispatch_fd_entry_open(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 == -1 && *(void *)(a1 + 8))
  {
    if (*(_DWORD *)(a1 + 24))
    {
      return *(unsigned int *)(a1 + 24);
    }
    else
    {
      while (1)
      {
        unsigned int v12 = _dispatch_fd_entry_guarded_open(a1);
        if (v12 != -1) {
          break;
        }
        unsigned int v11 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (v11 != 4)
        {
          int v8 = 0;
          atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(a1 + 24), (unsigned int *)&v8, v11, memory_order_relaxed, memory_order_relaxed);
          return v11;
        }
      }
      int v9 = -1;
      atomic_compare_exchange_strong_explicit((atomic_uint *volatile)a1, (unsigned int *)&v9, v12, memory_order_relaxed, memory_order_relaxed);
      if (v9 == -1) {
        *(_DWORD *)(a2 + 128) = v12;
      }
      else {
        _dispatch_fd_entry_guarded_close(a1);
      }
      _dispatch_object_debug((uint64_t *)a2, "%s", v2, v3, v4, v5, v6, v7, (char)"_dispatch_fd_entry_open");
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
  dispatch_io_t v11 = channel;
  dispatch_io_close_flags_t v10 = flags;
  if (flags)
  {
    if ((*((_DWORD *)v11 + 30) & 2) == 0) {
      _dispatch_io_stop((uint64_t)v11);
    }
  }
  else if ((*((_DWORD *)v11 + 30) & 3) == 0)
  {
    dispatch_io_t v9 = v11;
    _dispatch_retain((uint64_t)v11);
    uint64_t v2 = (dispatch_queue_s *)*((void *)v11 + 6);
    uint64_t v3 = _NSConcreteStackBlock;
    int v4 = 0x40000000;
    int v5 = 0;
    uint64_t v6 = __dispatch_io_close_block_invoke;
    uint64_t v7 = &__block_descriptor_tmp_35;
    dispatch_io_t v8 = v11;
    dispatch_channel_async(v2, &v3);
  }
}

void _dispatch_io_stop(uint64_t a1)
{
  uint64_t v26 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: stop", v1, v2, v3, v4, v5, v6, v7, 736);
  int v24 = 2;
  int v23 = 2;
  int v25 = 2;
  int v19 = 2;
  int v18 = 2;
  int v20 = 2;
  unsigned int v17 = atomic_fetch_or_explicit((atomic_uint *volatile)(v26 + 120), 2u, memory_order_relaxed);
  unsigned int v21 = v17;
  unsigned int v16 = v17;
  int v22 = v17 | 2;
  uint64_t v15 = v26;
  _dispatch_retain(v26);
  dispatch_io_t v8 = *(dispatch_queue_s **)(v26 + 48);
  blocint k = _NSConcreteStackBlock;
  int v10 = 0x40000000;
  int v11 = 0;
  unsigned int v12 = ___dispatch_io_stop_block_invoke;
  uint64_t v13 = &__block_descriptor_tmp_116;
  uint64_t v14 = v26;
  dispatch_channel_async(v8, &block);
}

void __dispatch_io_close_block_invoke(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 56);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_close_block_invoke_2;
  uint64_t v7 = &__block_descriptor_tmp_34;
  uint64_t v8 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_close_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug(*(uint64_t **)(a1 + 32), "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_io_close_block_invoke_2");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: close", v8, v9, v10, v11, v12, v13, v14, 794);
  if ((*(_DWORD *)(*(void *)(a1 + 32) + 120) & 3) == 0)
  {
    atomic_fetch_or_explicit((atomic_uint *volatile)(*(void *)(a1 + 32) + 120), 1u, memory_order_relaxed);
    uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 112);
    if (v16)
    {
      if (*(void *)(v16 + 8)) {
        **(void **)(v16 + 8) = 0;
      }
      *(void *)(*(void *)(a1 + 32) + 112) = 0;
      _dispatch_fd_entry_release(v16);
    }
  }
  _dispatch_release(*(void *)(a1 + 32));
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
  dispatch_io_t v12 = channel;
  dispatch_block_t v11 = barrier;
  dispatch_io_t v10 = channel;
  _dispatch_retain((uint64_t)channel);
  uint64_t v2 = (dispatch_queue_s *)*((void *)v12 + 6);
  blocint k = _NSConcreteStackBlock;
  int v4 = 1107296256;
  int v5 = 0;
  uint64_t v6 = __dispatch_io_barrier_block_invoke;
  uint64_t v7 = &__block_descriptor_tmp_44;
  dispatch_io_t v9 = v12;
  dispatch_block_t v8 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_barrier_block_invoke(uint64_t a1)
{
  uint64_t v15 = a1;
  uint64_t v14 = a1;
  uint64_t v13 = 0;
  uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 24);
  dispatch_queue_t v12 = 0;
  dispatch_queue_t v12 = *(dispatch_queue_t *)(*(void *)(a1 + 40) + 56);
  uint64_t v11 = 0;
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 64);
  uint64_t v1 = _NSConcreteStackBlock;
  int v2 = 1107296256;
  int v3 = 0;
  int v4 = __dispatch_io_barrier_block_invoke_2;
  int v5 = &__block_descriptor_tmp_41;
  dispatch_queue_t v7 = v12;
  uint64_t v8 = v11;
  uint64_t v9 = v13;
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 32);
  dispatch_channel_async(v12, &v1);
}

void __dispatch_io_barrier_block_invoke_2(void *a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = a1;
  dispatch_object_t v12 = (dispatch_object_t)a1[5];
  dispatch_suspend(v12);
  uint64_t v1 = (dispatch_group_s *)a1[6];
  int v2 = (dispatch_queue_s *)a1[7];
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  dispatch_queue_t v7 = __dispatch_io_barrier_block_invoke_3;
  uint64_t v8 = &__block_descriptor_tmp_38;
  uint64_t v10 = a1[8];
  uint64_t v9 = a1[4];
  uint64_t v11 = a1[5];
  dispatch_group_notify(v1, v2, &block);
}

void __dispatch_io_barrier_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = a1;
  uint64_t v17 = a1;
  uint64_t v16 = 0;
  v15[0] = 0;
  v15[1] = "io";
  uint64_t v16 = *(void *)(a1 + 40);
  _dispatch_object_debug(*(uint64_t **)(a1 + 40), "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_io_barrier_block_invoke_3");
  int v19 = v15;
  v15[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v19);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  int v20 = v15;
  BOOL v22 = _dispatch_thread_getspecific(0x17uLL) == v15;
  uint64_t v21 = 449;
  if (!v22) {
    _dispatch_abort(v21, 0, v8, v9, v10, v11, v12, v13);
  }
  _dispatch_thread_setspecific(23, *v20);
  dispatch_resume(*(dispatch_object_t *)(a1 + 48));
  _dispatch_release(*(void *)(a1 + 40));
}

void dispatch_io_barrier_f(dispatch_io_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  barrier = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  int v6 = __dispatch_io_barrier_f_block_invoke;
  dispatch_queue_t v7 = &__block_descriptor_tmp_45;
  uint64_t v8 = a3;
  uint64_t v9 = a2;
  dispatch_io_barrier(a1, &barrier);
}

uint64_t __dispatch_io_barrier_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

void dispatch_io_read(dispatch_io_t channel, off_t offset, size_t length, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  dispatch_io_t v22 = channel;
  off_t v21 = offset;
  size_t v20 = length;
  dispatch_queue_t v19 = queue;
  dispatch_io_handler_t v18 = io_handler;
  dispatch_io_t v17 = channel;
  _dispatch_retain((uint64_t)channel);
  dispatch_queue_t v16 = v19;
  _dispatch_retain((uint64_t)v19);
  int v5 = (dispatch_queue_s *)*((void *)v22 + 6);
  int v6 = _NSConcreteStackBlock;
  int v7 = 1107296256;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_read_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_49;
  dispatch_io_t v12 = v22;
  off_t v13 = v21;
  size_t v14 = v20;
  dispatch_queue_t v15 = v19;
  dispatch_io_handler_t v11 = v18;
  dispatch_channel_async(v5, &v6);
}

void __dispatch_io_read_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = a1;
  uint64_t v17 = a1;
  dispatch_queue_t v16 = 0;
  dispatch_queue_t v16 = _dispatch_operation_create(0, *(void **)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), &_dispatch_data_empty, *(dispatch_queue_s **)(a1 + 64), *(const void **)(a1 + 32), a8);
  if (v16)
  {
    dispatch_queue_t v15 = 0;
    dispatch_queue_t v15 = *(dispatch_queue_t *)(*(void *)(a1 + 40) + 56);
    blocint k = _NSConcreteStackBlock;
    int v10 = 0x40000000;
    int v11 = 0;
    dispatch_io_t v12 = __dispatch_io_read_block_invoke_2;
    off_t v13 = &__block_descriptor_tmp_46;
    size_t v14 = v16;
    dispatch_channel_async(v15, &block);
  }
  _dispatch_release(*(void *)(a1 + 40));
  _dispatch_release(*(void *)(a1 + 64));
}

void *_dispatch_operation_create(unsigned int a1, void *a2, uint64_t a3, uint64_t a4, dispatch_object_s *a5, dispatch_queue_s *a6, const void *a7, uint64_t a8)
{
  unsigned int v52 = a1;
  unint64_t v51 = a2;
  uint64_t v50 = a3;
  uint64_t v49 = a4;
  dispatch_object_t v48 = a5;
  dispatch_queue_t v47 = a6;
  __int16 v46 = a7;
  BOOL v55 = a1 < 2;
  uint64_t v54 = 1064;
  if (a1 >= 2) {
    _dispatch_abort(v54, v55, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  }
  int error = _dispatch_io_get_error(0, (uint64_t)v51, 0);
  if (!error && v49)
  {
    __int16 v30 = _dispatch_object_alloc((uint64_t)_OS_dispatch_operation_vtable, 0x110uLL, v8, v9, v10, v11, v12, v13);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tchannel[%p]: operation create: %p", v15, v16, v17, v18, v19, v20, v21, 1092);
    v30[2] = -1985229329;
    *((_DWORD *)v30 + 3) = 0;
    v30[6] = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.opq", 0, v47);
    *((unsigned char *)v30 + 16pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
    *((_DWORD *)v30 + 14) = v52;
    v30[13] = v50 + v51[17];
    v30[14] = v49;
    v30[16] = _dispatch_Block_copy(v46);
    _dispatch_retain((uint64_t)v51);
    v30[17] = v51;
    memcpy(v30 + 8, v51 + 9, 0x28uLL);
    for (uint64_t i = *(void *)(v30[17] + 24); *(void *)(i + 24); uint64_t i = *(void *)(i + 24))
      ;
    v30[3] = i;
    _dispatch_object_debug(v30, "%s", v22, v23, v24, v25, v26, v27, (char)"_dispatch_operation_create");
    return v30;
  }
  else
  {
    dispatch_object_t v44 = v48;
    dispatch_retain(v48);
    dispatch_queue_t v43 = v47;
    _dispatch_retain((uint64_t)v47);
    uint64_t v42 = v51;
    _dispatch_retain((uint64_t)v51);
    size_t v14 = (dispatch_queue_s *)v51[7];
    blocint k = _NSConcreteStackBlock;
    int v32 = 1107296256;
    int v33 = 0;
    int v34 = ___dispatch_operation_create_block_invoke;
    int v35 = &__block_descriptor_tmp_130;
    dispatch_queue_t v37 = v47;
    dispatch_object_t v38 = v48;
    unsigned int v40 = v52;
    int v41 = error;
    dispatch_queue_t v39 = v51;
    off_t v36 = v46;
    dispatch_channel_async(v14, &block);
    return 0;
  }
}

void __dispatch_io_read_block_invoke_2(uint64_t a1)
{
}

void _dispatch_operation_enqueue(void *a1, unsigned int a2, dispatch_object_s *a3)
{
  __int16 v46 = a1;
  unsigned int v45 = a2;
  dispatch_object_t v44 = a3;
  dispatch_queue_t v43 = a3;
  dispatch_retain(a3);
  int error = 0;
  int error = _dispatch_io_get_error(0, v46[17], 0);
  if (error)
  {
    uint64_t v41 = 0;
    uint64_t v41 = v46[16];
    int v3 = (dispatch_queue_s *)v46[6];
    blocint k = _NSConcreteStackBlock;
    int v33 = 1107296256;
    int v34 = 0;
    int v35 = ___dispatch_operation_enqueue_block_invoke;
    off_t v36 = &__block_descriptor_tmp_135;
    dispatch_object_t v38 = v44;
    unsigned int v39 = v45;
    int v40 = error;
    uint64_t v37 = v41;
    dispatch_channel_async(v3, &block);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: release -> %d, err %d", v4, v5, v6, v7, v8, v9, v10, 1175);
    uint64_t v31 = v46;
    _dispatch_release((uint64_t)v46);
  }
  else
  {
    v46[18] = *(void *)(v46[17] + 112);
    _dispatch_fd_entry_retain(v46[18]);
    dispatch_group_enter(*(dispatch_group_t *)(v46[18] + 80));
    uint64_t v30 = 0;
    uint64_t v30 = *(void *)(v46[18] + 56);
    if (v30)
    {
      uint64_t v12 = *(dispatch_queue_s **)(v30 + 72);
      uint64_t v13 = _NSConcreteStackBlock;
      int v14 = 0x40000000;
      int v15 = 0;
      uint64_t v16 = ___dispatch_operation_enqueue_block_invoke_2;
      uint64_t v17 = &__block_descriptor_tmp_139;
      uint64_t v18 = v30;
      uint64_t v19 = v46;
      uint64_t v20 = v44;
      dispatch_channel_async(v12, &v13);
    }
    else
    {
      int v29 = 0;
      int v29 = *(dispatch_queue_s ***)(v46[18] + 40 + 8 * v45);
      uint64_t v11 = *v29;
      uint64_t v21 = _NSConcreteStackBlock;
      int v22 = 0x40000000;
      int v23 = 0;
      uint64_t v24 = ___dispatch_operation_enqueue_block_invoke_137;
      uint64_t v25 = &__block_descriptor_tmp_138;
      uint64_t v26 = v29;
      uint64_t v27 = v46;
      uint64_t v28 = v44;
      dispatch_channel_async(v11, &v21);
    }
  }
}

void dispatch_io_read_f(dispatch_io_s *a1, off_t a2, size_t a3, dispatch_queue_s *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v18 = a1;
  off_t v17 = a2;
  size_t v16 = a3;
  int v15 = a4;
  uint64_t v14 = a5;
  uint64_t v13 = a6;
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_read_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_51;
  uint64_t v11 = a6;
  uint64_t v12 = a5;
  dispatch_io_read(a1, a2, a3, a4, &v6);
}

uint64_t __dispatch_io_read_f_block_invoke(uint64_t a1, char a2, uint64_t a3, unsigned int a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2 & 1, a3, a4);
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  dispatch_io_t v23 = channel;
  off_t v22 = offset;
  dispatch_data_t v21 = data;
  dispatch_queue_t v20 = queue;
  dispatch_io_handler_t v19 = io_handler;
  dispatch_data_t v18 = data;
  dispatch_retain(data);
  dispatch_io_t v17 = v23;
  _dispatch_retain((uint64_t)v23);
  dispatch_queue_t v16 = v20;
  _dispatch_retain((uint64_t)v20);
  uint64_t v5 = (dispatch_queue_s *)*((void *)v23 + 6);
  blocint k = _NSConcreteStackBlock;
  int v7 = 1107296256;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_write_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_55;
  dispatch_io_t v12 = v23;
  off_t v13 = v22;
  dispatch_data_t v14 = v21;
  dispatch_queue_t v15 = v20;
  dispatch_io_handler_t v11 = v19;
  dispatch_channel_async(v5, &block);
}

void __dispatch_io_write_block_invoke(uint64_t a1)
{
  uint64_t v16 = a1;
  uint64_t v15 = a1;
  dispatch_data_t v14 = 0;
  int v3 = *(void **)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48);
  size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 56));
  dispatch_data_t v14 = _dispatch_operation_create(1u, v3, v4, size, *(dispatch_object_s **)(a1 + 56), *(dispatch_queue_s **)(a1 + 64), *(const void **)(a1 + 32), v2);
  if (v14)
  {
    dispatch_queue_t v13 = 0;
    dispatch_queue_t v13 = *(dispatch_queue_t *)(*(void *)(a1 + 40) + 56);
    blocint k = _NSConcreteStackBlock;
    int v7 = 0x40000000;
    int v8 = 0;
    uint64_t v9 = __dispatch_io_write_block_invoke_2;
    uint64_t v10 = &__block_descriptor_tmp_52;
    dispatch_io_handler_t v11 = v14;
    uint64_t v12 = *(void *)(a1 + 56);
    dispatch_channel_async(v13, &block);
  }
  else
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  }
  _dispatch_release(*(void *)(a1 + 40));
  _dispatch_release(*(void *)(a1 + 64));
}

void __dispatch_io_write_block_invoke_2(uint64_t a1)
{
}

void dispatch_io_write_f(dispatch_io_s *a1, off_t a2, dispatch_data_s *a3, dispatch_queue_s *a4, uint64_t a5, uint64_t a6)
{
  dispatch_data_t v18 = a1;
  off_t v17 = a2;
  uint64_t v16 = a3;
  uint64_t v15 = a4;
  uint64_t v14 = a5;
  uint64_t v13 = a6;
  uint64_t v6 = _NSConcreteStackBlock;
  int v7 = 0x40000000;
  int v8 = 0;
  uint64_t v9 = __dispatch_io_write_f_block_invoke;
  uint64_t v10 = &__block_descriptor_tmp_56;
  uint64_t v11 = a6;
  uint64_t v12 = a5;
  dispatch_io_write(a1, a2, a3, a4, &v6);
}

uint64_t __dispatch_io_write_f_block_invoke(uint64_t a1, char a2, uint64_t a3, unsigned int a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2 & 1, a3, a4);
}

void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t queue, void *handler)
{
  dispatch_fd_t v17 = fd;
  size_t v16 = length;
  dispatch_queue_t v15 = queue;
  uint64_t v14 = handler;
  dispatch_queue_t v13 = queue;
  _dispatch_retain((uint64_t)queue);
  uint64_t v4 = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  int v7 = __dispatch_read_block_invoke;
  int v8 = &__block_descriptor_tmp_71;
  dispatch_queue_t v10 = v15;
  dispatch_fd_t v12 = v17;
  uint64_t v9 = v14;
  size_t v11 = v16;
  _dispatch_fd_entry_init_async(v17, (uint64_t)&v4);
}

void __dispatch_read_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v53 = a1;
  uint64_t v52 = a2;
  uint64_t v51 = a1;
  if (*(_DWORD *)(a2 + 24))
  {
    int v50 = 0;
    int v50 = *(_DWORD *)(v52 + 24);
    int v8 = *(dispatch_queue_s **)(a1 + 40);
    blocint k = _NSConcreteStackBlock;
    int v43 = 1107296256;
    int v44 = 0;
    unsigned int v45 = __dispatch_read_block_invoke_2;
    __int16 v46 = &__block_descriptor_tmp_60;
    int v48 = *(_DWORD *)(a1 + 56);
    uint64_t v47 = *(void *)(a1 + 32);
    int v49 = v50;
    dispatch_channel_async(v8, &block);
    _dispatch_release(*(void *)(a1 + 40));
  }
  else
  {
    uint64_t v41 = 0;
    uint64_t v41 = *(void **)(v52 + 88);
    if (!v41)
    {
      uint64_t v41 = _dispatch_io_create(0, a2, a3, a4, a5, a6, a7, a8);
      *((_DWORD *)v41 + 3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *(_DWORD *)(a1 + 56);
      *((_DWORD *)v41 + 32) = *(_DWORD *)(a1 + 56);
      v41[14] = v52;
      dispatch_object_t v40 = *(dispatch_object_t *)(v52 + 72);
      dispatch_retain(v40);
      dispatch_object_t v39 = *(dispatch_object_t *)(v52 + 80);
      dispatch_retain(v39);
      v41[7] = *(void *)(v52 + 72);
      v41[8] = *(void *)(v52 + 80);
      *(void *)(v52 + 88) = v41;
    }
    v35[0] = 0;
    v35[1] = v35;
    int v36 = 0;
    int v37 = 32;
    dispatch_object_t v38 = &_dispatch_data_empty;
    v31[0] = 0;
    v31[1] = v31;
    int v32 = 0;
    int v33 = 32;
    int v34 = 0;
    uint64_t v9 = *(dispatch_queue_s **)(v52 + 64);
    dispatch_data_t v21 = _NSConcreteStackBlock;
    int v22 = 1107296256;
    int v23 = 0;
    uint64_t v24 = __dispatch_read_block_invoke_61;
    uint64_t v25 = &__block_descriptor_tmp_66;
    uint64_t v29 = *(void *)(a1 + 40);
    int v30 = *(_DWORD *)(a1 + 56);
    uint64_t v26 = *(void *)(a1 + 32);
    uint64_t v27 = v35;
    uint64_t v28 = v31;
    dispatch_channel_async(v9, &v21);
    dispatch_queue_t v20 = 0;
    uint64_t v10 = *(void *)(a1 + 48);
    dispatch_queue_t v13 = _NSConcreteStackBlock;
    int v14 = 1107296256;
    int v15 = 0;
    size_t v16 = __dispatch_read_block_invoke_67;
    dispatch_fd_t v17 = &__block_descriptor_tmp_68;
    dispatch_data_t v18 = v35;
    dispatch_io_handler_t v19 = v31;
    dispatch_queue_t v20 = _dispatch_operation_create(0, v41, 0, v10, &_dispatch_data_empty, (dispatch_queue_s *)&off_F0600, &v13, v11);
    if (v20) {
      _dispatch_operation_enqueue(v20, 0, &_dispatch_data_empty);
    }
    _Block_object_dispose(v31, 8);
    _Block_object_dispose(v35, 8);
  }
}

uint64_t __dispatch_read_block_invoke_2(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 925);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __dispatch_read_block_invoke_61(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 56);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = __dispatch_read_block_invoke_2_62;
  int v8 = &__block_descriptor_tmp_63;
  int v12 = *(_DWORD *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 48);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(void *)(a1 + 56));
}

void __dispatch_read_block_invoke_2_62(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 948);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  dispatch_release(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

void __copy_helper_block_8_32b40r48r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_8_32b40r48r(const void **a1)
{
}

void __dispatch_read_block_invoke_67(uint64_t a1, char a2, dispatch_data_s *a3, int a4)
{
  char v7 = a2 & 1;
  if (a3)
  {
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), a3);
    dispatch_release(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = concat;
  }
  if (v7) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a4;
  }
}

void __copy_helper_block_8_32r40r(uint64_t a1, uint64_t a2)
{
}

void __destroy_helper_block_8_32r40r(uint64_t a1)
{
}

void dispatch_read_f(dispatch_fd_t a1, size_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_fd_t v16 = a1;
  size_t v15 = a2;
  uint64_t v14 = a3;
  uint64_t v13 = a4;
  uint64_t v12 = a5;
  handler = _NSConcreteStackBlock;
  int v6 = 0x40000000;
  int v7 = 0;
  int v8 = __dispatch_read_f_block_invoke;
  uint64_t v9 = &__block_descriptor_tmp_73;
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  dispatch_read(a1, a2, a3, &handler);
}

uint64_t __dispatch_read_f_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2, a3);
}

void dispatch_write(dispatch_fd_t fd, dispatch_data_t data, dispatch_queue_t queue, void *handler)
{
  dispatch_fd_t v18 = fd;
  dispatch_data_t v17 = data;
  dispatch_queue_t v16 = queue;
  size_t v15 = handler;
  dispatch_data_t v14 = data;
  dispatch_retain(data);
  dispatch_queue_t v13 = v16;
  _dispatch_retain((uint64_t)v16);
  uint64_t v4 = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  int v7 = __dispatch_write_block_invoke;
  int v8 = &__block_descriptor_tmp_91;
  dispatch_queue_t v10 = v16;
  dispatch_fd_t v12 = v18;
  uint64_t v9 = v15;
  dispatch_data_t v11 = v17;
  _dispatch_fd_entry_init_async(v18, (uint64_t)&v4);
}

void __dispatch_write_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v55 = a1;
  uint64_t v54 = a2;
  uint64_t v53 = a1;
  if (*(_DWORD *)(a2 + 24))
  {
    int v52 = 0;
    int v52 = *(_DWORD *)(v54 + 24);
    int v8 = *(dispatch_queue_s **)(a1 + 40);
    blocint k = _NSConcreteStackBlock;
    int v45 = 1107296256;
    int v46 = 0;
    uint64_t v47 = __dispatch_write_block_invoke_2;
    int v48 = &__block_descriptor_tmp_76;
    int v50 = *(_DWORD *)(a1 + 56);
    uint64_t v49 = *(void *)(a1 + 32);
    int v51 = v52;
    dispatch_channel_async(v8, &block);
    _dispatch_release(*(void *)(a1 + 40));
  }
  else
  {
    int v43 = 0;
    int v43 = *(void **)(v54 + 88);
    if (!v43)
    {
      int v43 = _dispatch_io_create(0, a2, a3, a4, a5, a6, a7, a8);
      *((_DWORD *)v43 + 3_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = *(_DWORD *)(a1 + 56);
      *((_DWORD *)v43 + 32) = *(_DWORD *)(a1 + 56);
      v43[14] = v54;
      dispatch_object_t v42 = *(dispatch_object_t *)(v54 + 72);
      dispatch_retain(v42);
      dispatch_object_t v41 = *(dispatch_object_t *)(v54 + 80);
      dispatch_retain(v41);
      v43[7] = *(void *)(v54 + 72);
      v43[8] = *(void *)(v54 + 80);
      *(void *)(v54 + 88) = v43;
    }
    v37[0] = 0;
    v37[1] = v37;
    int v38 = 0;
    int v39 = 32;
    uint64_t v40 = 0;
    v33[0] = 0;
    v33[1] = v33;
    int v34 = 0;
    int v35 = 32;
    int v36 = 0;
    uint64_t v9 = *(dispatch_queue_s **)(v54 + 64);
    int v23 = _NSConcreteStackBlock;
    int v24 = 1107296256;
    int v25 = 0;
    uint64_t v26 = __dispatch_write_block_invoke_77;
    uint64_t v27 = &__block_descriptor_tmp_84;
    uint64_t v31 = *(void *)(a1 + 40);
    int v32 = *(_DWORD *)(a1 + 56);
    uint64_t v28 = *(void *)(a1 + 32);
    uint64_t v29 = v37;
    int v30 = v33;
    dispatch_channel_async(v9, &v23);
    int v22 = 0;
    dispatch_queue_t v13 = v43;
    size_t size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 48));
    dispatch_data_t v11 = *(dispatch_object_s **)(a1 + 48);
    size_t v15 = _NSConcreteStackBlock;
    int v16 = 1107296256;
    int v17 = 0;
    dispatch_fd_t v18 = __dispatch_write_block_invoke_85;
    dispatch_io_handler_t v19 = &__block_descriptor_tmp_88;
    dispatch_queue_t v20 = v37;
    dispatch_data_t v21 = v33;
    int v22 = _dispatch_operation_create(1u, v13, 0, size, v11, (dispatch_queue_s *)&off_F0600, &v15, v12);
    if (v22) {
      _dispatch_operation_enqueue(v22, 1u, *(dispatch_object_s **)(a1 + 48));
    }
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
    _Block_object_dispose(v33, 8);
    _Block_object_dispose(v37, 8);
  }
}

uint64_t __dispatch_write_block_invoke_2(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 994);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __dispatch_write_block_invoke_77(uint64_t a1)
{
  uint64_t v14 = a1;
  uint64_t v13 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 56);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = __dispatch_write_block_invoke_2_78;
  int v8 = &__block_descriptor_tmp_81;
  int v12 = *(_DWORD *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 48);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(void *)(a1 + 56));
}

void __dispatch_write_block_invoke_2_78(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 1017);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    dispatch_release(*(dispatch_object_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  }
}

void __dispatch_write_block_invoke_85(uint64_t a1, char a2, dispatch_object_s *a3, int a4)
{
  if (a2)
  {
    if (a3)
    {
      dispatch_retain(a3);
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a4;
  }
}

void dispatch_write_f(dispatch_fd_t a1, dispatch_data_s *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  dispatch_fd_t v16 = a1;
  size_t v15 = a2;
  uint64_t v14 = a3;
  uint64_t v13 = a4;
  uint64_t v12 = a5;
  handler = _NSConcreteStackBlock;
  int v6 = 0x40000000;
  int v7 = 0;
  int v8 = __dispatch_write_f_block_invoke;
  uint64_t v9 = &__block_descriptor_tmp_92;
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  dispatch_write(a1, a2, a3, &handler);
}

uint64_t __dispatch_write_f_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (*(uint64_t (**)(void, uint64_t, void))(a1 + 32))(*(void *)(a1 + 40), a2, a3);
}

void _dispatch_operation_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug((uint64_t *)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_operation_dispose");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: dispose", v8, v9, v10, v11, v12, v13, v14, 1121);
  if (*(void *)(a1 + 144))
  {
    _dispatch_operation_deliver_data((uint64_t *)a1, 2, v15, v16, v17, v18, v19, v20);
    dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1 + 144) + 80));
    _dispatch_fd_entry_release(*(void *)(a1 + 144));
  }
  if (*(void *)(a1 + 136)) {
    _dispatch_release(*(void *)(a1 + 136));
  }
  if (*(void *)(a1 + 152)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 152));
  }
  if (*(void *)(a1 + 176) && !*(_DWORD *)(a1 + 56)) {
    free(*(void **)(a1 + 176));
  }
  if (*(void *)(a1 + 224)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 224));
  }
  if (*(void *)(a1 + 232)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 232));
  }
  if (*(void *)(a1 + 48)) {
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
  }
  _Block_release(*(const void **)(a1 + 128));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: disposed", v21, v22, v23, v24, v25, v26, v27, 1152);
}

void _dispatch_operation_deliver_data(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v65 = a1;
  int v64 = a2;
  subrange = 0;
  int v62 = 0;
  unint64_t v61 = 0;
  unint64_t v61 = a1[26] + a1[25];
  char v60 = 0;
  BOOL v32 = 1;
  if ((a2 & 3) == 0) {
    BOOL v32 = (v65[23] & 1) != 0;
  }
  char v60 = v32;
  *((_DWORD *)v65 + 46) = 0;
  if (v60)
  {
    int v62 = *((_DWORD *)v65 + 30);
    if (!v62 && (*(_DWORD *)(v65[17] + 120) & 2) != 0)
    {
      int v62 = 89;
      *((_DWORD *)v65 + 3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 89;
    }
  }
  else if (v61 < v65[9])
  {
    if (v65[25] < (unint64_t)v65[24])
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: buffer data: undelivered %zu", v8, v9, v10, v11, v12, v13, v14, 2622);
      return;
    }
  }
  else
  {
    char v60 = 1;
  }
  if (!*((_DWORD *)v65 + 14))
  {
    if (v65[25])
    {
      uint64_t v59 = 0;
      uint64_t v59 = (const void *)v65[22];
      subrange = dispatch_data_create(v59, v65[25], 0, &__block_literal_global);
      v65[22] = 0;
      v65[25] = 0;
      dispatch_data_t concat = 0;
      dispatch_data_t concat = dispatch_data_create_concat((dispatch_data_t)v65[29], subrange);
      dispatch_object_t v57 = (dispatch_object_t)v65[29];
      dispatch_release(v57);
      unsigned __int16 v56 = subrange;
      dispatch_release(subrange);
      subrange = concat;
    }
    else
    {
      subrange = (dispatch_data_s *)v65[29];
    }
    if (v60) {
      uint64_t v31 = &_dispatch_data_empty;
    }
    else {
      uint64_t v31 = subrange;
    }
    v65[29] = (uint64_t)v31;
LABEL_33:
    if ((v60 & 1) != 0 && ((v64 & 8) == 0 || dispatch_data_get_size(subrange)))
    {
      v65[26] = 0;
      int v51 = v65;
      _dispatch_object_debug(v65, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_operation_deliver_data");
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: deliver data", v23, v24, v25, v26, v27, v28, v29, 2687);
      int v50 = 0;
      int v50 = *((_DWORD *)v65 + 14);
      uint64_t v49 = 0;
      uint64_t v49 = v65[16];
      uint64_t v48 = 0;
      uint64_t v48 = v65[18];
      _dispatch_fd_entry_retain(v48);
      uint64_t v47 = 0;
      uint64_t v47 = v65[17];
      uint64_t v46 = v47;
      _dispatch_retain(v47);
      int v30 = (dispatch_queue_s *)v65[6];
      blocint k = _NSConcreteStackBlock;
      int v34 = 1107296256;
      int v35 = 0;
      int v36 = ___dispatch_operation_deliver_data_block_invoke;
      int v37 = &__block_descriptor_tmp_199;
      int v43 = v64;
      int v39 = subrange;
      int v44 = v50;
      int v45 = v62;
      uint64_t v40 = v65;
      uint64_t v38 = v49;
      uint64_t v41 = v47;
      uint64_t v42 = v48;
      dispatch_channel_async(v30, &block);
    }
    else
    {
      v65[26] = v61;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: buffer data: undelivered %zu", v16, v17, v18, v19, v20, v21, v22, 2682);
    }
    return;
  }
  if (*((_DWORD *)v65 + 14) == 1)
  {
    if (v60) {
      subrange = dispatch_data_create_subrange((dispatch_data_t)v65[29], v65[25], v65[14]);
    }
    if (v65[28] && v65[25] == v65[24])
    {
      dispatch_object_t v55 = (dispatch_object_t)v65[28];
      dispatch_release(v55);
      v65[28] = 0;
      v65[22] = 0;
      v65[25] = 0;
      dispatch_data_t v54 = 0;
      if (v60)
      {
        uint64_t v53 = subrange;
        dispatch_retain(subrange);
        dispatch_data_t v54 = subrange;
      }
      else
      {
        dispatch_data_t v54 = dispatch_data_create_subrange((dispatch_data_t)v65[29], v65[24], v65[14]);
      }
      dispatch_object_t v52 = (dispatch_object_t)v65[29];
      dispatch_release(v52);
      v65[29] = (uint64_t)v54;
    }
    goto LABEL_33;
  }
  BOOL v15 = *((_DWORD *)v65 + 14) < 2u;
  BOOL v67 = v15;
  uint64_t v66 = 2677;
  if (!v15) {
    _dispatch_abort(v66, v67, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_disk_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 112)) {
    *(void *)(*(void *)(a1 + 112) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(a1 + 120);
  }
  **(void **)(a1 + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(a1 + 112);
  *(void *)(a1 + 112) = -1;
  *(void *)(a1 + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
  if (*(void *)(a1 + 48)) {
    _dispatch_abort(1792, *(void *)(a1 + 48) == 0, a3, a4, a5, a6, a7, a8);
  }
  for (unint64_t i = 0; i < *(void *)(a1 + 128); ++i)
  {
    if (*(void *)(a1 + 136 + 8 * i)) {
      _dispatch_abort(1795, *(void *)(a1 + 136 + 8 * i) == 0, a3, a4, a5, a6, a7, a8);
    }
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 72));
}

void ___dispatch_io_init_block_invoke(uint64_t a1)
{
  uint64_t v13 = a1;
  uint64_t v12 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(a1 + 40);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  int v7 = ___dispatch_io_init_block_invoke_2;
  uint64_t v8 = &__block_descriptor_tmp_102;
  uint64_t v10 = *(void *)(a1 + 48);
  int v11 = *(_DWORD *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(void *)(a1 + 40));
}

uint64_t ___dispatch_io_init_block_invoke_2(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: cleanup handler invoke: err %d", v1, v2, v3, v4, v5, v6, v7, 270);
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ___dispatch_io_stop_block_invoke(uint64_t a1)
{
  uint64_t v10 = a1;
  uint64_t v9 = a1;
  uint64_t v2 = *(dispatch_queue_s **)(*(void *)(a1 + 32) + 56);
  blocint k = _NSConcreteStackBlock;
  int v4 = 0x40000000;
  int v5 = 0;
  uint64_t v6 = ___dispatch_io_stop_block_invoke_2;
  uint64_t v7 = &__block_descriptor_tmp_115;
  uint64_t v8 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
}

void ___dispatch_io_stop_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a1;
  uint64_t v25 = a1;
  uint64_t v24 = *(uint64_t **)(a1 + 32);
  _dispatch_object_debug(v24, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_io_stop_block_invoke_2");
  uint64_t v23 = 0;
  uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 112);
  if (v23)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tchannel[%p]: stop cleanup", v8, v9, v10, v11, v12, v13, v14, 744);
    _dispatch_fd_entry_cleanup_operations(v23, *(void *)(a1 + 32));
    if ((*(_DWORD *)(*(void *)(a1 + 32) + 120) & 1) == 0)
    {
      if (*(void *)(v23 + 8)) {
        **(void **)(v23 + 8) = 0;
      }
      *(void *)(*(void *)(a1 + 32) + 112) = 0;
      _dispatch_fd_entry_release(v23);
    }
  }
  else if (*(_DWORD *)(*(void *)(a1 + 32) + 124) != -1)
  {
    uint64_t v22 = *(void *)(a1 + 32);
    _dispatch_retain(v22);
    blocint k = _NSConcreteStackBlock;
    int v17 = 0x40000000;
    int v18 = 0;
    uint64_t v19 = ___dispatch_io_stop_block_invoke_3;
    uint64_t v20 = &__block_descriptor_tmp_114;
    uint64_t v21 = *(void *)(a1 + 32);
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_fds_lockq, &block);
  }
  _dispatch_release(*(void *)(a1 + 32));
}

void _dispatch_fd_entry_cleanup_operations(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = a1;
  uint64_t v23 = a2;
  if (*(void *)(a1 + 56))
  {
    if (v23)
    {
      uint64_t v22 = v23;
      _dispatch_retain(v23);
    }
    _dispatch_fd_entry_retain(v24);
    uint64_t v2 = *(dispatch_queue_s **)(*(void *)(v24 + 56) + 72);
    blocint k = _NSConcreteStackBlock;
    int v16 = 0x40000000;
    int v17 = 0;
    int v18 = ___dispatch_fd_entry_cleanup_operations_block_invoke;
    uint64_t v19 = &__block_descriptor_tmp_117;
    uint64_t v20 = v24;
    uint64_t v21 = v23;
    dispatch_channel_async(v2, &block);
  }
  else
  {
    for (unsigned int i = 0; i < 2; ++i)
    {
      uint64_t v13 = 0;
      uint64_t v13 = *(dispatch_queue_s ***)(v24 + 40 + 8 * i);
      if (v13)
      {
        if (v23)
        {
          uint64_t v12 = v23;
          _dispatch_retain(v23);
        }
        _dispatch_fd_entry_retain(v24);
        uint64_t v3 = *v13;
        int v4 = _NSConcreteStackBlock;
        int v5 = 0x40000000;
        int v6 = 0;
        uint64_t v7 = ___dispatch_fd_entry_cleanup_operations_block_invoke_2;
        uint64_t v8 = &__block_descriptor_tmp_118;
        uint64_t v9 = v13;
        uint64_t v10 = v23;
        uint64_t v11 = v24;
        dispatch_channel_async(v3, &v4);
      }
    }
  }
}

void ___dispatch_io_stop_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug(*(uint64_t **)(a1 + 32), "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_io_stop_block_invoke_3");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: stop cleanup after close", v8, v9, v10, v11, v12, v13, v14, 759);
  for (uint64_t i = _dispatch_io_fds[*(_DWORD *)(*(void *)(a1 + 32) + 124) & 0x3FLL]; i; uint64_t i = *(void *)(i + 112))
  {
    if (*(_DWORD *)i == *(_DWORD *)(*(void *)(a1 + 32) + 124))
    {
      _dispatch_fd_entry_cleanup_operations(i, *(void *)(a1 + 32));
      break;
    }
  }
  _dispatch_release(*(void *)(a1 + 32));
}

void ___dispatch_fd_entry_cleanup_operations_block_invoke(uint64_t a1)
{
  if (*(void *)(a1 + 40)) {
    _dispatch_release(*(void *)(a1 + 40));
  }
}

void _dispatch_disk_cleanup_inactive_operations(uint64_t a1, uint64_t a2)
{
}

void ___dispatch_fd_entry_cleanup_operations_block_invoke_2(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[5]) {
    _dispatch_release(a1[5]);
  }
}

void _dispatch_stream_cleanup_operations(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = 0;
  for (uint64_t i = *(void *)(a1 + 48); ; uint64_t i = v10)
  {
    char v9 = 0;
    if (i)
    {
      uint64_t v10 = *(void *)(i + 240);
      char v9 = 1;
    }
    if ((v9 & 1) == 0) {
      break;
    }
    if (!a2 || *(void *)(i + 136) == a2) {
      _dispatch_stream_complete_operation(a1, i, a3, a4, a5, a6, a7, a8);
    }
  }
  for (uint64_t j = *(void *)(a1 + 32); ; uint64_t j = v10)
  {
    char v8 = 0;
    if (j)
    {
      uint64_t v10 = *(void *)(j + 240);
      char v8 = 1;
    }
    if ((v8 & 1) == 0) {
      break;
    }
    if (!a2 || *(void *)(j + 136) == a2) {
      _dispatch_stream_complete_operation(a1, j, a3, a4, a5, a6, a7, a8);
    }
  }
  if ((*(unsigned char *)(a1 + 24) & 1) != 0 && !_dispatch_stream_operation_avail(a1))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
    *(unsigned char *)(a1 + 24) = 0;
  }
}

void _dispatch_disk_cleanup_specified_operations(uint64_t a1, uint64_t a2, char a3)
{
  char v19 = a3 & 1;
  uint64_t v17 = 0;
  for (uint64_t i = *(void *)(a1 + 48); ; uint64_t i = v17)
  {
    char v16 = 0;
    if (i)
    {
      uint64_t v17 = *(void *)(i + 240);
      char v16 = 1;
    }
    if ((v16 & 1) == 0) {
      break;
    }
    if (((v19 & 1) == 0 || (*(unsigned char *)(i + 160) & 1) == 0) && (!a2 || *(void *)(i + 136) == a2))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: cleanup: disk %p", v3, v4, v5, v6, v7, v8, v9, 1985);
      _dispatch_disk_complete_operation(a1, i, v10, v11, v12, v13, v14, v15);
    }
  }
}

void _dispatch_disk_complete_operation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug((uint64_t *)a2, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_disk_complete_operation");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: complete: disk %p", v8, v9, v10, v11, v12, v13, v14, 1869);
  if (*(void *)(a1 + 64) == a2) {
    *(void *)(a1 + 64) = **(void **)(*(void *)(a2 + 248) + 8);
  }
  if (!*(void *)(a2 + 64))
  {
    uint64_t v22 = *(void *)(a2 + 256);
    if (v22) {
      *(void *)(*(void *)(a2 + 256) + 264) = *(void *)(a2 + 264);
    }
    else {
      *(void *)(*(void *)(a2 + 144) + 104) = *(void *)(a2 + 264);
    }
    **(void **)(a2 + 264) = *(void *)(a2 + 256);
    *(void *)(a2 + 256) = -1;
    *(void *)(a2 + 264) = -1;
    if (v22)
    {
      *(void *)(v22 + 24pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
      *(void *)(v22 + 248) = *(void *)(a1 + 56);
      **(void **)(a1 + 56) = v22;
      *(void *)(a1 + 56) = v22 + 240;
    }
  }
  if (*(void *)(a2 + 240)) {
    *(void *)(*(void *)(a2 + 240) + 248) = *(void *)(a2 + 248);
  }
  else {
    *(void *)(a1 + 56) = *(void *)(a2 + 248);
  }
  **(void **)(a2 + 248) = *(void *)(a2 + 240);
  *(void *)(a2 + 24pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
  *(void *)(a2 + 248) = -1;
  if (*(void *)(a2 + 152)) {
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 152));
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (disk complete)", v15, v16, v17, v18, v19, v20, v21, 1888);
  _dispatch_release(a2);
}

void _dispatch_stream_complete_operation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug((uint64_t *)a2, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_stream_complete_operation");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: complete: stream %p", v8, v9, v10, v11, v12, v13, v14, 1851);
  if (*(void *)(a2 + 240)) {
    *(void *)(*(void *)(a2 + 240) + 248) = *(void *)(a2 + 248);
  }
  else {
    *(void *)(a1 + 32 + 16 * *(void *)(a2 + 64) + 8) = *(void *)(a2 + 248);
  }
  **(void **)(a2 + 248) = *(void *)(a2 + 240);
  *(void *)(a2 + 24pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
  *(void *)(a2 + 248) = -1;
  if (a2 == *(void *)(a1 + 16)) {
    *(void *)(a1 + 16) = 0;
  }
  if (*(void *)(a2 + 152)) {
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 152));
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (stream complete)", v15, v16, v17, v18, v19, v20, v21, 1860);
  _dispatch_release(a2);
}

BOOL _dispatch_stream_operation_avail(uint64_t a1)
{
  BOOL v2 = 1;
  if (!*(void *)(a1 + 48)) {
    return *(void *)(a1 + 32) != 0;
  }
  return v2;
}

void ___dispatch_operation_create_block_invoke(uint64_t a1)
{
  uint64_t v15 = a1;
  uint64_t v14 = a1;
  BOOL v2 = *(dispatch_queue_s **)(a1 + 40);
  blocint k = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = ___dispatch_operation_create_block_invoke_2;
  uint64_t v8 = &__block_descriptor_tmp_127;
  uint64_t v10 = *(void *)(a1 + 48);
  int v12 = *(_DWORD *)(a1 + 64);
  int v13 = *(_DWORD *)(a1 + 68);
  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 32);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(void *)(a1 + 40));
}

void ___dispatch_operation_create_block_invoke_2(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: IO handler invoke: err %d", v1, v2, v3, v4, v5, v6, v7, 1081);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  _dispatch_release(*(void *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void ___dispatch_operation_enqueue_block_invoke(uint64_t a1)
{
}

void ___dispatch_operation_enqueue_block_invoke_137(uint64_t a1)
{
}

void _dispatch_stream_enqueue_operation(dispatch_queue_t *a1, uint64_t *a2, dispatch_object_s *a3)
{
  if (_dispatch_operation_should_enqueue((uint64_t)a2, *a1, a3))
  {
    _dispatch_object_debug(a2, "%s", v3, v4, v5, v6, v7, v8, (char)"_dispatch_stream_enqueue_operation");
    BOOL v9 = !_dispatch_stream_operation_avail((uint64_t)a1);
    a2[30] = 0;
    a2[31] = (uint64_t)a1[2 * a2[8] + 5];
    *(void *)a1[2 * a2[8] + 5] = a2;
    a1[2 * a2[8] + 5] = (dispatch_queue_t)(a2 + 30);
    if (v9) {
      dispatch_channel_async_f(*a1, *a1, (dispatch_function_t)_dispatch_stream_queue_handler);
    }
  }
}

void ___dispatch_operation_enqueue_block_invoke_2(uint64_t a1)
{
}

void _dispatch_disk_enqueue_operation(uint64_t a1, uint64_t *a2, dispatch_object_s *a3)
{
  if (_dispatch_operation_should_enqueue((uint64_t)a2, *(dispatch_queue_s **)(a1 + 72), a3))
  {
    _dispatch_object_debug(a2, "%s", v3, v4, v5, v6, v7, v8, (char)"_dispatch_disk_enqueue_operation");
    if (a2[8])
    {
      a2[30] = 0;
      a2[31] = *(void *)(a1 + 56);
      **(void **)(a1 + 56) = a2;
      *(void *)(a1 + 56) = a2 + 30;
    }
    else
    {
      if (!*(void *)(a2[18] + 96))
      {
        a2[30] = 0;
        a2[31] = *(void *)(a1 + 56);
        **(void **)(a1 + 56) = a2;
        *(void *)(a1 + 56) = a2 + 30;
      }
      a2[32] = 0;
      a2[33] = *(void *)(a2[18] + 104);
      **(void **)(a2[18] + 104) = a2;
      *(void *)(a2[18] + 104) = a2 + 32;
    }
    _dispatch_disk_handler(a1);
  }
}

uint64_t _dispatch_operation_should_enqueue(uint64_t a1, dispatch_queue_s *a2, dispatch_object_s *a3)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: enqueue", v3, v4, v5, v6, v7, v8, v9, 1203);
  dispatch_retain(a3);
  *(void *)(a1 + 232) = a3;
  int error = _dispatch_io_get_error(a1, 0, 1);
  if (error)
  {
    *(_DWORD *)(a1 + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = error;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: release -> %d, err %d", v10, v11, v12, v13, v14, v15, v16, 1210);
    _dispatch_release(a1);
    char v23 = 0;
  }
  else
  {
    if (*(void *)(a1 + 88))
    {
      dispatch_object_t object = (dispatch_object_s *)_dispatch_operation_timer(a2, a1);
      dispatch_resume(object);
    }
    char v23 = 1;
  }
  return v23 & 1;
}

void _dispatch_stream_queue_handler(dispatch_object_s *a1)
{
  context = (dispatch_queue_t *)dispatch_get_context(a1);
  if (context) {
    _dispatch_stream_handler(context);
  }
}

uint64_t _dispatch_operation_timer(dispatch_queue_s *a1, uint64_t a2)
{
  dispatch_queue_t v13 = a1;
  uint64_t v12 = a2;
  if (!*(void *)(a2 + 152))
  {
    dispatch_source_t v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v13);
    dispatch_time_t v2 = dispatch_time(0, *(void *)(v12 + 88));
    dispatch_source_set_timer(v11, v2, *(void *)(v12 + 88), 0);
    handler = _NSConcreteStackBlock;
    int v5 = 0x40000000;
    int v6 = 0;
    uint64_t v7 = ___dispatch_operation_timer_block_invoke;
    uint64_t v8 = &__block_descriptor_tmp_141;
    dispatch_source_t v9 = v11;
    uint64_t v10 = v12;
    dispatch_source_set_event_handler(v11, &handler);
    *(void *)(v12 + 152) = v11;
  }
  return *(void *)(v12 + 152);
}

void ___dispatch_operation_timer_block_invoke(uint64_t a1)
{
  if (!dispatch_source_testcancel(*(dispatch_source_t *)(a1 + 32)))
  {
    BOOL v8 = (*(void *)(*(void *)(a1 + 40) + 96) & 1) != 0;
    if (*(unsigned char *)(*(void *)(a1 + 40) + 160) & 1) != 0 && (*(void *)(*(void *)(a1 + 40) + 96)) {
      *(_DWORD *)(*(void *)(a1 + 40) + 184) = v8;
    }
    else {
      _dispatch_operation_deliver_data(*(uint64_t **)(a1 + 40), v8, v1, v2, v3, v4, v5, v6);
    }
  }
}

void _dispatch_stream_handler(dispatch_queue_t *a1)
{
  dispatch_object_t v57 = a1;
  unsigned __int16 v56 = a1;
  for (uint64_t i = 0; ; _dispatch_stream_complete_operation((uint64_t)v56, (uint64_t)i, v8, v9, v10, v11, v12, v13))
  {
    uint64_t i = (uint64_t *)_dispatch_stream_pick_next_operation((uint64_t)v56, (uint64_t)v56[2]);
    if (!i)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tno operation found: stream %p", v1, v2, v3, v4, v5, v6, v7, 2072);
      return;
    }
    int error = _dispatch_io_get_error((uint64_t)i, 0, 1);
    if (!error) {
      break;
    }
    *((_DWORD *)i + 3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = error;
  }
  v56[2] = (dispatch_queue_t)i;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: stream handler", v14, v15, v16, v17, v18, v19, v20, 2082);
  uint64_t v53 = 0;
  uint64_t v53 = i[18];
  _dispatch_fd_entry_retain(v53);
  if (!i[27] && (byte_F4280 & 1) != 0)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: initial delivery", v21, v22, v23, v24, v25, v26, v27, 2088);
    _dispatch_operation_deliver_data(i, 1, v28, v29, v30, v31, v32, v33);
  }
  unsigned int v52 = _dispatch_operation_perform(i);
  int v51 = -1;
  if (v52 <= 1)
  {
    uint64_t v41 = v52 - 1;
    char v40 = 0;
  }
  else
  {
    uint64_t v41 = v52 - 1;
    char v40 = 1;
  }
  if ((v40 & 1) == 0)
  {
    switch(v41)
    {
      case 0:
        goto LABEL_19;
      case 1:
        int v51 = 0;
        goto LABEL_15;
      case 2:
LABEL_15:
        if (v51) {
          int v42 = 9;
        }
        else {
          int v42 = 0;
        }
        int v51 = v42;
        _dispatch_operation_deliver_data(i, v42, v34, v35, v36, v37, v38, v39);
LABEL_19:
        if (v51) {
          _dispatch_stream_complete_operation((uint64_t)v56, (uint64_t)i, v34, v35, v36, v37, v38, v39);
        }
        if (_dispatch_stream_operation_avail((uint64_t)v56)) {
          dispatch_channel_async_f(*v56, *v56, (dispatch_function_t)_dispatch_stream_queue_handler);
        }
        break;
      case 3:
        _dispatch_stream_complete_operation((uint64_t)v56, (uint64_t)i, v34, v35, v36, v37, v38, v39);
        goto LABEL_25;
      case 4:
LABEL_25:
        if (_dispatch_stream_operation_avail((uint64_t)v56))
        {
          *((unsigned char *)v56 + 24) = 1;
          dispatch_queue_t v50 = _dispatch_stream_source(v56, (uint64_t)i);
          dispatch_resume(v50);
        }
        break;
      case 5:
        _dispatch_stream_cleanup_operations((uint64_t)v56, i[17], v34, v35, v36, v37, v38, v39);
        break;
      case 6:
        _dispatch_fd_entry_retain(v53);
        int v43 = *(dispatch_queue_s **)(v53 + 72);
        blocint k = _NSConcreteStackBlock;
        int v45 = 0x40000000;
        int v46 = 0;
        uint64_t v47 = ___dispatch_stream_handler_block_invoke;
        uint64_t v48 = &__block_descriptor_tmp_145;
        uint64_t v49 = v53;
        dispatch_channel_async(v43, &block);
        break;
      default:
        JUMPOUT(0);
    }
  }
  _dispatch_fd_entry_release(v53);
}

uint64_t _dispatch_stream_pick_next_operation(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (a2)
  {
    if (*(void *)(a2 + 64))
    {
      if (*(void *)(a2 + 64) == 1)
      {
        uint64_t v4 = *(void *)(a2 + 240);
        if (!v4) {
          return *(void *)(a1 + 48);
        }
        return v4;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return a2;
    }
  }
  else if (_dispatch_stream_operation_avail(a1))
  {
    if (*(void *)(a1 + 32)) {
      return *(void *)(a1 + 32);
    }
    if (*(void *)(a1 + 48)) {
      return *(void *)(a1 + 48);
    }
    return v3;
  }
  else
  {
    return 0;
  }
}

uint64_t _dispatch_operation_perform(uint64_t *a1)
{
  __int16 v72 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: perform", v1, v2, v3, v4, v5, v6, v7, 2328);
  int error = _dispatch_io_get_error((uint64_t)v72, 0, 1);
  if (error) {
    goto LABEL_45;
  }
  unint64_t v70 = v72;
  _dispatch_object_debug(v72, "%s", v8, v9, v10, v11, v12, v13, (char)"_dispatch_operation_perform");
  if (!v72[22])
  {
    unint64_t v69 = 0;
    unint64_t v69 = v72[10];
    unint64_t v68 = dispatch_io_defaults;
    if (*((_DWORD *)v72 + 14))
    {
      if (*((_DWORD *)v72 + 14) == 1)
      {
        if (v68 > v69) {
          unint64_t v68 = v69;
        }
        v72[24] = 0;
        uint64_t v27 = (dispatch_data_s *)v72[29];
        applier = _NSConcreteStackBlock;
        int v61 = 0x40000000;
        int v62 = 0;
        BOOL v63 = ___dispatch_operation_perform_block_invoke;
        int v64 = &__block_descriptor_tmp_149;
        __int16 v65 = v72;
        unint64_t v66 = v68;
        dispatch_data_apply(v27, &applier);
        if (v72[24] > v69) {
          v72[24] = v69;
        }
        int data = dispatch_data_create_subrange((dispatch_data_t)v72[29], 0, v72[24]);
        v72[28] = (uint64_t)dispatch_data_create_map(data, (const void **)v72 + 22, 0);
        dispatch_release(data);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: buffer mapped", v28, v29, v30, v31, v32, v33, v34, 2396);
      }
    }
    else
    {
      size_t size = 0;
      size_t size = dispatch_data_get_size((dispatch_data_t)v72[29]);
      if (size)
      {
        BOOL v77 = size < v69;
        uint64_t v76 = 2342;
        if (size >= v69) {
          _dispatch_abort(v76, 0, v14, v15, v16, v17, v18, v19);
        }
        v69 -= size;
      }
      if (v69 > v68) {
        unint64_t v69 = v68;
      }
      if (v72[14] == -1)
      {
        v72[24] = v69;
      }
      else
      {
        v72[24] = v72[14] - v72[27];
        if (v72[24] > v69) {
          v72[24] = v69;
        }
      }
      int error = malloc_type_posix_memalign();
      if (error) {
        goto LABEL_45;
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: buffer allocated", v20, v21, v22, v23, v24, v25, v26, 2370);
    }
  }
  if (*(_DWORD *)v72[18] == -1)
  {
    int error = _dispatch_fd_entry_open(v72[18], v72[17]);
    if (error)
    {
LABEL_45:
      if (error == 35)
      {
        BOOL v75 = *(void *)(v72[18] + 56) == 0;
        uint64_t v74 = 2583;
        if (!v75) {
          _dispatch_abort(v74, 0, v8, v9, v10, v11, v12, v13);
        }
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: performed: EAGAIN/EWOULDBLOCK", v42, v43, v44, v45, v46, v47, v48, 2584);
        if (!*((_DWORD *)v72 + 14) && v72[27] && v72[17] == *(void *)(v72[18] + 88)) {
          return 4;
        }
        else {
          return 5;
        }
      }
      else
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: performed: err %d", v49, v50, v51, v52, v53, v54, v55, 2592);
        *((_DWORD *)v72 + 3pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = error;
        if (error == 9)
        {
          int v56 = 0;
          atomic_compare_exchange_strong_explicit((atomic_uint *volatile)(v72[18] + 24), (unsigned int *)&v56, 9u, memory_order_relaxed, memory_order_relaxed);
          return 7;
        }
        else if (error == 89)
        {
          return 6;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  uint64_t NOCANCEL = -1;
  while (1)
  {
    if (*((_DWORD *)v72 + 14))
    {
      if (*((_DWORD *)v72 + 14) == 1)
      {
        if (v72[8])
        {
          if (v72[8] == 1) {
            uint64_t NOCANCEL = pwrite_NOCANCEL();
          }
        }
        else
        {
          uint64_t NOCANCEL = write_NOCANCEL();
        }
      }
    }
    else if (v72[8])
    {
      if (v72[8] == 1) {
        uint64_t NOCANCEL = pread_NOCANCEL();
      }
    }
    else
    {
      uint64_t NOCANCEL = read_NOCANCEL();
    }
    if (NOCANCEL != -1) {
      break;
    }
    uint64_t v78 = 1;
    uint64_t v79 = 1;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int error = **(_DWORD **)(StatusReg + 8);
    if (error != 4) {
      goto LABEL_45;
    }
  }
  if (NOCANCEL)
  {
    v72[25] += NOCANCEL;
    v72[27] += NOCANCEL;
    if (v72[27] == v72[14]) {
      return 1;
    }
    else {
      return 2;
    }
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: performed: EOF", v35, v36, v37, v38, v39, v40, v41, 2568);
    return 3;
  }
}

dispatch_queue_t _dispatch_stream_source(dispatch_queue_t *a1, uint64_t a2)
{
  uint64_t v29 = a1;
  uint64_t v28 = a2;
  if (a1[1]) {
    return v29[1];
  }
  int v27 = 0;
  int v27 = **(_DWORD **)(v28 + 144);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: stream source create", v2, v3, v4, v5, v6, v7, v8, 2015);
  dispatch_source_t v26 = 0;
  if (!*(_DWORD *)(v28 + 56))
  {
    dispatch_source_t v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v27, 0, *v29);
LABEL_10:
    dispatch_source_t v25 = v26;
    dispatch_set_context(v26, v29);
    dispatch_source_set_event_handler_f(v26, (dispatch_function_t)_dispatch_stream_source_handler);
    uint64_t v24 = 0;
    uint64_t v24 = *(void *)(*(void *)(v28 + 144) + 64);
    uint64_t v17 = _NSConcreteStackBlock;
    int v18 = 0x40000000;
    int v19 = 0;
    uint64_t v20 = ___dispatch_stream_source_block_invoke;
    uint64_t v21 = &__block_descriptor_tmp_156;
    uint64_t v22 = v28;
    uint64_t v23 = v24;
    dispatch_source_set_mandatory_cancel_handler((uint64_t)v26, &v17);
    v29[1] = (dispatch_queue_t)v26;
    return v29[1];
  }
  if (*(_DWORD *)(v28 + 56) == 1)
  {
    dispatch_source_t v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v27, 0, *v29);
    goto LABEL_10;
  }
  BOOL v15 = *(_DWORD *)(v28 + 56) < 2u;
  BOOL v32 = v15;
  uint64_t v31 = 2024;
  if (!v15) {
    _dispatch_abort(v31, v32, v9, v10, v11, v12, v13, v14);
  }
  return 0;
}

void ___dispatch_stream_handler_block_invoke(uint64_t a1)
{
}

BOOL ___dispatch_operation_perform_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = *(void *)(*(void *)(a1 + 32) + 192) + a5;
  if (!*(void *)(*(void *)(a1 + 32) + 192) || v6 <= *(void *)(a1 + 40)) {
    *(void *)(*(void *)(a1 + 32) + 192) = v6;
  }
  return v6 < *(void *)(a1 + 40);
}

uint64_t _dispatch_stream_source_handler(uint64_t a1)
{
  *(unsigned char *)(a1 + 24) = 0;
  return _dispatch_stream_handler(a1);
}

void ___dispatch_stream_source_block_invoke(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: stream source cancel", v1, v2, v3, v4, v5, v6, v7, 2034);
  dispatch_resume(*(dispatch_object_t *)(a1 + 40));
}

void _dispatch_disk_handler(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 108) & 1) == 0)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tdisk[%p]: disk handler", v1, v2, v3, v4, v5, v6, v7, 2146);
    unint64_t v43 = *(void *)(a1 + 80);
    unint64_t v42 = *(void *)(a1 + 88);
    if (v42 <= v43) {
      v42 += *(void *)(a1 + 128);
    }
    while (v43 <= v42)
    {
      if (*(void *)(a1 + 136 + 8 * (v43 % *(void *)(a1 + 128)))) {
        break;
      }
      uint64_t operation = _dispatch_disk_pick_next_operation(a1);
      if (!operation) {
        break;
      }
      int error = _dispatch_io_get_error(operation, 0, 1);
      if (error)
      {
        *(_DWORD *)(operation + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = error;
        _dispatch_disk_complete_operation(a1, operation, v8, v9, v10, v11, v12, v13);
      }
      else
      {
        _dispatch_retain(operation);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: retain -> %d", v14, v15, v16, v17, v18, v19, v20, 2162);
        *(void *)(a1 + 136 + 8 * (v43 % *(void *)(a1 + 128))) = operation;
        *(unsigned char *)(operation + 16pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 1;
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: activate: disk %p", v21, v22, v23, v24, v25, v26, v27, 2165);
        _dispatch_object_debug((uint64_t *)operation, "%s", v28, v29, v30, v31, v32, v33, (char)"_dispatch_disk_handler");
        ++v43;
      }
    }
    *(void *)(a1 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v43 % *(void *)(a1 + 128);
    uint64_t v45 = *(void *)(a1 + 136 + 8 * *(void *)(a1 + 88));
    if (v45)
    {
      *(unsigned char *)(a1 + 108) = 1;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: async perform: disk %p", v34, v35, v36, v37, v38, v39, v40, 2177);
      dispatch_channel_async_f(*(dispatch_queue_t *)(v45 + 24), (void *)a1, (dispatch_function_t)_dispatch_disk_perform);
    }
  }
}

uint64_t _dispatch_disk_pick_next_operation(uint64_t a1)
{
  if (!*(void *)(a1 + 48)) {
    return 0;
  }
  if (*(void *)(a1 + 64))
  {
    uint64_t v3 = *(void *)(a1 + 64);
    do
    {
      uint64_t v3 = *(void *)(v3 + 240);
      if (!v3) {
        uint64_t v3 = *(void *)(a1 + 48);
      }
      BOOL v2 = 0;
      if (*(unsigned char *)(v3 + 160)) {
        BOOL v2 = v3 != *(void *)(a1 + 64);
      }
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 48);
  }
  if (*(unsigned char *)(v3 + 160)) {
    return 0;
  }
  *(void *)(a1 + 64) = v3;
  return v3;
}

void _dispatch_disk_perform(void *a1)
{
  uint64_t v49 = a1;
  uint64_t v48 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tdisk[%p]: disk perform", v1, v2, v3, v4, v5, v6, v7, 2186);
  uint64_t v47 = dispatch_io_defaults;
  uint64_t v46 = 0;
  unint64_t v45 = 0;
  unint64_t v45 = v48[12];
  unint64_t v44 = 0;
  unint64_t v44 = v48[10];
  if (v44 <= v45) {
    v44 += v48[16];
  }
  while (1)
  {
    uint64_t v46 = (uint64_t *)v48[v45 % v48[16] + 17];
    if (!v46) {
      break;
    }
    if (*((_DWORD *)v46 + 14) != 1
      && (*(_DWORD *)v46[18] != -1 || !_dispatch_fd_entry_open(v46[18], v46[17])))
    {
      if (!v46[27] && (byte_F4280 & 1) != 0)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: initial delivery", v14, v15, v16, v17, v18, v19, v20, 2211);
        _dispatch_operation_deliver_data(v46, 1, v21, v22, v23, v24, v25, v26);
      }
      if (v44 - v45 == 1 && !v48[v48[10] + 17] && !v46[21]) {
        v47 *= 2;
      }
      _dispatch_operation_advise(v46, v47);
    }
    if (++v45 >= v44) {
      goto LABEL_19;
    }
  }
  BOOL v51 = v45 % v48[16] == v48[10];
  uint64_t v50 = 2197;
  if (!v51) {
    _dispatch_abort(v50, 0, v8, v9, v10, v11, v12, v13);
  }
LABEL_19:
  v48[12] = v45 % v48[16];
  uint64_t v46 = (uint64_t *)v48[v48[11] + 17];
  int v43 = _dispatch_operation_perform(v46);
  v48[v48[11] + 17] = 0;
  v48[11] = (unint64_t)(v48[11] + 1) % v48[16];
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: async perform completion: disk %p", v27, v28, v29, v30, v31, v32, v33, 2227);
  uint64_t v34 = (dispatch_queue_s *)v48[9];
  blocint k = _NSConcreteStackBlock;
  int v36 = 0x40000000;
  int v37 = 0;
  uint64_t v38 = ___dispatch_disk_perform_block_invoke;
  uint64_t v39 = &__block_descriptor_tmp_166;
  uint64_t v40 = v46;
  int v42 = v43;
  uint64_t v41 = v48;
  dispatch_channel_async(v34, &block);
}

void _dispatch_operation_advise(uint64_t *a1, uint64_t a2)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: advise", v2, v3, v4, v5, v6, v7, v8, 2270);
  if (!_dispatch_io_get_error((uint64_t)a1, 0, 1)
    && a1[21] <= (uint64_t)(a1[13] + a1[27] + a2 + vm_page_size))
  {
    _dispatch_object_debug(a1, "%s", v9, v10, v11, v12, v13, v14, (char)"_dispatch_operation_advise");
    int v24 = a2;
    if (!a1[21])
    {
      a1[21] = a1[13];
      vm_size_t v23 = (a1[13] + a2) % vm_page_size;
      if (v23) {
        int v22 = vm_page_size - v23;
      }
      else {
        int v22 = 0;
      }
      int v24 = a2 + v22;
    }
    a1[21] += v24;
    while (1)
    {
      int v21 = fcntl_NOCANCEL() == -1 ? **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) : 0;
      if (!v21) {
        break;
      }
      if (v21 != 4)
      {
        if (v21 != 27 && v21 != 45) {
          _dispatch_bug(2308, v21, v15, v16, v17, v18, v19, v20);
        }
        return;
      }
    }
  }
}

void ___dispatch_disk_perform_block_invoke(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: perform completion", v1, v2, v3, v4, v5, v6, v7, 2229);
  unsigned int v14 = *(_DWORD *)(a1 + 48);
  BOOL v15 = v14 > 1;
  uint64_t v16 = v14 - 1;
  if (v15)
  {
    uint64_t v18 = v16;
    char v17 = 1;
  }
  else
  {
    uint64_t v18 = v16;
    char v17 = 0;
  }
  if ((v17 & 1) == 0)
  {
    switch(v18)
    {
      case 0:
        _dispatch_disk_complete_operation(*(void *)(a1 + 40), *(void *)(a1 + 32), v8, v9, v10, v11, v12, v13);
        goto LABEL_13;
      case 1:
        _dispatch_operation_deliver_data(*(uint64_t **)(a1 + 32), 0, v8, v9, v10, v11, v12, v13);
        goto LABEL_13;
      case 2:
        _dispatch_operation_deliver_data(*(uint64_t **)(a1 + 32), 9, v8, v9, v10, v11, v12, v13);
        _dispatch_disk_complete_operation(*(void *)(a1 + 40), *(void *)(a1 + 32), v19, v20, v21, v22, v23, v24);
        goto LABEL_13;
      case 3:
      case 4:
        break;
      case 5:
        _dispatch_disk_cleanup_operations(*(void *)(a1 + 40), *(void *)(*(void *)(a1 + 32) + 136));
        goto LABEL_13;
      case 6:
        _dispatch_disk_cleanup_operations(*(void *)(a1 + 40), 0);
        goto LABEL_13;
      default:
        JUMPOUT(0);
    }
  }
  if (!*(_DWORD *)(a1 + 48)) {
    _dispatch_abort(2248, *(int *)(a1 + 48), v8, v9, v10, v11, v12, v13);
  }
LABEL_13:
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: deactivate: disk %p", v25, v26, v27, v28, v29, v30, v31, 2251);
  *(unsigned char *)(*(void *)(a1 + 32) + 16pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = 0;
  *(unsigned char *)(*(void *)(a1 + 40) + 108) = 0;
  _dispatch_disk_handler(*(void *)(a1 + 40));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (disk perform complete)", v32, v33, v34, v35, v36, v37, v38, 2259);
  _dispatch_release(*(void *)(a1 + 32));
}

void _dispatch_disk_cleanup_operations(uint64_t a1, uint64_t a2)
{
}

void ___dispatch_fd_entry_init_async_block_invoke(uint64_t a1)
{
  uint64_t v20 = a1;
  uint64_t v19 = a1;
  uint64_t i = 0;
  uint64_t v17 = 0;
  uint64_t v17 = *(_DWORD *)(a1 + 40) & 0x3FLL;
  for (uint64_t i = _dispatch_io_fds[v17]; i; uint64_t i = *(void *)(i + 112))
  {
    if (*(_DWORD *)i == *(_DWORD *)(a1 + 40))
    {
      _dispatch_fd_entry_retain(i);
      break;
    }
  }
  if (!i) {
    uint64_t i = _dispatch_fd_entry_create_with_fd(*(_DWORD *)(a1 + 40), v17);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: init", v1, v2, v3, v4, v5, v6, v7, 1400);
  uint64_t v8 = *(dispatch_queue_s **)(i + 72);
  blocint k = _NSConcreteStackBlock;
  int v11 = 1107296256;
  int v12 = 0;
  uint64_t v13 = ___dispatch_fd_entry_init_async_block_invoke_2;
  unsigned int v14 = &__block_descriptor_tmp_172;
  uint64_t v16 = i;
  uint64_t v15 = *(void *)(a1 + 32);
  dispatch_channel_async(v8, &block);
}

uint64_t _dispatch_fd_entry_create_with_fd(int a1, uint64_t a2)
{
  int v36 = a1;
  uint64_t v35 = a2;
  uint64_t v34 = _dispatch_fd_entry_create((dispatch_queue_s *)_dispatch_io_fds_lockq);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: create: fd %d", v2, v3, v4, v5, v6, v7, v8, 1431);
  *(_DWORD *)uint64_t v34 = v36;
  uint64_t v9 = _dispatch_io_fds[v35];
  *(void *)(v34 + 112) = v9;
  if (v9) {
    *(void *)(_dispatch_io_fds[v35] + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v34 + 112;
  }
  _dispatch_io_fds[v35] = v34;
  *(void *)(v34 + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = &_dispatch_io_fds[v35];
  *(void *)(v34 + 72) = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0);
  *(void *)(v34 + 8pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = dispatch_group_create();
  uint64_t v10 = *(dispatch_queue_s **)(v34 + 72);
  blocint k = _NSConcreteStackBlock;
  int v28 = 0x40000000;
  int v29 = 0;
  uint64_t v30 = ___dispatch_fd_entry_create_with_fd_block_invoke;
  uint64_t v31 = &__block_descriptor_tmp_179;
  uint64_t v32 = v34;
  int v33 = v36;
  dispatch_channel_async(v10, &block);
  int v11 = *(dispatch_queue_s **)(v34 + 64);
  uint64_t v21 = _NSConcreteStackBlock;
  int v22 = 0x40000000;
  int v23 = 0;
  uint64_t v24 = ___dispatch_fd_entry_create_with_fd_block_invoke_3;
  uint64_t v25 = &__block_descriptor_tmp_182;
  uint64_t v26 = v34;
  dispatch_channel_async(v11, &v21);
  int v12 = *(dispatch_queue_s **)(v34 + 64);
  unsigned int v14 = _NSConcreteStackBlock;
  int v15 = 0x40000000;
  int v16 = 0;
  uint64_t v17 = ___dispatch_fd_entry_create_with_fd_block_invoke_5;
  uint64_t v18 = &__block_descriptor_tmp_186;
  uint64_t v19 = v34;
  int v20 = v36;
  dispatch_channel_async(v12, &v14);
  return v34;
}

void ___dispatch_fd_entry_init_async_block_invoke_2(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: init completion", v1, v2, v3, v4, v5, v6, v7, 1402);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  _dispatch_fd_entry_release(*(void *)(a1 + 40));
}

uint64_t _dispatch_fd_entry_create(dispatch_queue_s *a1)
{
  uint64_t v2 = _dispatch_calloc();
  *(void *)(v2 + 64) = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.closeq", 0, a1);
  _dispatch_fd_entry_retain(v2);
  return v2;
}

void ___dispatch_fd_entry_create_with_fd_block_invoke(uint64_t a1)
{
  uint64_t v67 = a1;
  uint64_t v66 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: stat", v1, v2, v3, v4, v5, v6, v7, 1459);
  int v65 = 0;
  int v64 = 0;
  int v63 = -1;
  memset(&__b, 0, sizeof(__b));
  while (1)
  {
    if (fstat(*(_DWORD *)(a1 + 40), &__b) == -1)
    {
      uint64_t v81 = 1;
      uint64_t v92 = 1;
      unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v43 = **(_DWORD **)(StatusReg + 8);
    }
    else
    {
      int v43 = 0;
    }
    int v65 = v43;
    if (!v43) {
      break;
    }
    if (v43 != 4)
    {
      *(_DWORD *)(*(void *)(a1 + 32) + 24) = v65;
      return;
    }
  }
  *(_DWORD *)(*(void *)(a1 + 32) + 32) = __b.st_dev;
  *(_WORD *)(*(void *)(a1 + 32) + 36) = __b.st_mode;
  _dispatch_object_finalize();
  while (1)
  {
    int v64 = fcntl_NOCANCEL();
    if (v64 == -1)
    {
      uint64_t v82 = 1;
      uint64_t v91 = 1;
      unint64_t v94 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      int v42 = **(_DWORD **)(v94 + 8);
    }
    else
    {
      int v42 = 0;
    }
    int v65 = v42;
    if (!v42) {
      break;
    }
    if (v42 != 4)
    {
      int v61 = v65;
      uint64_t v77 = v65;
      uint64_t v76 = 1471;
      if (v65) {
        _dispatch_bug(v76, v77, v8, v9, v10, v11, v12, v13);
      }
      int v60 = v61;
      break;
    }
  }
  if ((__b.st_mode & 0xF000) == 0x1000)
  {
    while (1)
    {
      int v63 = fcntl_NOCANCEL();
      if (v63 == -1)
      {
        uint64_t v83 = 1;
        uint64_t v90 = 1;
        unint64_t v95 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        int v41 = **(_DWORD **)(v95 + 8);
      }
      else
      {
        int v41 = 0;
      }
      int v65 = v41;
      if (!v41) {
        break;
      }
      if (v41 != 4)
      {
        int v59 = v65;
        uint64_t v75 = v65;
        uint64_t v74 = 1477;
        if (v65) {
          _dispatch_bug(v74, v75, v14, v15, v16, v17, v18, v19);
        }
        int v58 = v59;
        break;
      }
    }
    if (v63 != -1)
    {
      while (1)
      {
        int v63 = fcntl_NOCANCEL();
        if (v63 == -1)
        {
          uint64_t v84 = 1;
          uint64_t v89 = 1;
          unint64_t v96 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          int v40 = **(_DWORD **)(v96 + 8);
        }
        else
        {
          int v40 = 0;
        }
        int v65 = v40;
        if (!v40) {
          break;
        }
        if (v40 != 4)
        {
          int v63 = -1;
          int v57 = v65;
          uint64_t v73 = v65;
          uint64_t v72 = 1484;
          if (v65) {
            _dispatch_bug(v72, v73, v20, v21, v22, v23, v24, v25);
          }
          int v56 = v57;
          break;
        }
      }
    }
  }
  if ((__b.st_mode & 0xF000) == 0x8000)
  {
    if (v64 != -1)
    {
      while (1)
      {
        if (fcntl_NOCANCEL() == -1)
        {
          uint64_t v85 = 1;
          uint64_t v88 = 1;
          unint64_t v97 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          int v39 = **(_DWORD **)(v97 + 8);
        }
        else
        {
          int v39 = 0;
        }
        int v65 = v39;
        if (!v39) {
          break;
        }
        if (v39 != 4)
        {
          int v64 = -1;
          int v55 = v65;
          uint64_t v71 = v65;
          uint64_t v70 = 1496;
          if (v65) {
            _dispatch_bug(v70, v71, v26, v27, v28, v29, v30, v31);
          }
          int v54 = v55;
          break;
        }
      }
    }
    int st_dev_high = HIBYTE(__b.st_dev);
    dispatch_object_t object = *(dispatch_object_t *)(*(void *)(a1 + 32) + 72);
    dispatch_suspend(object);
    uint64_t v80 = &_dispatch_io_init_pred;
    uint64_t v79 = 0;
    uint64_t v78 = _dispatch_io_queues_init;
    if (_dispatch_io_init_pred != -1) {
      dispatch_once_f(v80, v79, (dispatch_function_t)v78);
    }
    blocint k = _NSConcreteStackBlock;
    int v46 = 0x40000000;
    int v47 = 0;
    uint64_t v48 = ___dispatch_fd_entry_create_with_fd_block_invoke_2;
    uint64_t v49 = &__block_descriptor_tmp_178;
    uint64_t v50 = *(void *)(a1 + 32);
    int v51 = st_dev_high;
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
  }
  else
  {
    if (v64 != -1)
    {
      while (1)
      {
        if (fcntl_NOCANCEL() == -1)
        {
          uint64_t v86 = 1;
          uint64_t v87 = 1;
          unint64_t v98 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          int v38 = **(_DWORD **)(v98 + 8);
        }
        else
        {
          int v38 = 0;
        }
        int v65 = v38;
        if (!v38) {
          break;
        }
        if (v38 != 4)
        {
          int v64 = -1;
          uint64_t v69 = v65;
          uint64_t v68 = 1516;
          if (v65) {
            _dispatch_bug(v68, v69, v32, v33, v34, v35, v36, v37);
          }
          break;
        }
      }
    }
    _dispatch_stream_init(*(void *)(a1 + 32), (dispatch_queue_s *)&off_F0600);
  }
  *(_DWORD *)(*(void *)(a1 + 32) + 16) = v64;
  *(_DWORD *)(*(void *)(a1 + 32) + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v63;
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t _dispatch_disk_init(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a2 & 0x3F;
  for (uint64_t i = (void *)_dispatch_io_devs[v11]; i; uint64_t i = (void *)i[14])
  {
    if (*((_DWORD *)i + 26) == a2)
    {
      uint64_t result = _dispatch_retain((uint64_t)i);
      goto LABEL_9;
    }
  }
  uint64_t v10 = qword_F4278;
  uint64_t i = _dispatch_object_alloc((uint64_t)_OS_dispatch_disk_vtable, 8 * qword_F4278 + 136, a3, a4, a5, a6, a7, a8);
  i[2] = -1985229329;
  *((_DWORD *)i + 3) = 0;
  i[16] = v10;
  i[3] = &off_F0600;
  *((_DWORD *)i + 26) = a2;
  i[6] = 0;
  i[7] = i + 6;
  i[8] = i[6];
  __snprintf_chk(v15, 0x2DuLL, 0, 0x2DuLL, "com.apple.libdispatch-io.deviceq.%d", a2);
  uint64_t result = (uint64_t)dispatch_queue_create(v15, 0);
  i[9] = result;
  uint64_t v9 = _dispatch_io_devs[v11];
  i[14] = v9;
  if (v9) {
    *(void *)(_dispatch_io_devs[v11] + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = i + 14;
  }
  _dispatch_io_devs[v11] = i;
  i[15] = &_dispatch_io_devs[v11];
LABEL_9:
  a1[7] = i;
  a1[12] = 0;
  a1[13] = a1 + 12;
  return result;
}

void _dispatch_stream_init(uint64_t a1, dispatch_queue_s *a2)
{
  for (unsigned int i = 0; i < 2; ++i)
  {
    context = (dispatch_object_t *)_dispatch_calloc();
    dispatch_object_t *context = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.streamq", 0, a2);
    dispatch_set_context(*context, context);
    context[6] = 0;
    context[7] = (dispatch_object_t)(context + 6);
    context[4] = 0;
    context[5] = (dispatch_object_t)(context + 4);
    *(void *)(a1 + 40 + 8 * i) = context;
  }
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_3(uint64_t a1)
{
  uint64_t v24 = a1;
  uint64_t v23 = a1;
  if (*(void *)(*(void *)(a1 + 32) + 56))
  {
    uint64_t v21 = 0;
    uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 56);
    blocint k = _NSConcreteStackBlock;
    int v16 = 0x40000000;
    int v17 = 0;
    uint64_t v18 = ___dispatch_fd_entry_create_with_fd_block_invoke_4;
    uint64_t v19 = &__block_descriptor_tmp_181;
    uint64_t v20 = v21;
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tfd_entry[%p]: close queue cleanup", v1, v2, v3, v4, v5, v6, v7, 1533);
    for (unsigned int i = 0; i < 2; ++i)
      _dispatch_stream_dispose(*(void *)(a1 + 32), i, v8, v9, v10, v11, v12, v13);
  }
  if (*(void *)(*(void *)(a1 + 32) + 112)) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 112) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(*(void *)(a1 + 32) + 120);
  }
  **(void **)(*(void *)(a1 + 32) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = *(void *)(*(void *)(a1 + 32) + 112);
  *(void *)(*(void *)(a1 + 32) + 112) = -1;
  *(void *)(*(void *)(a1 + 32) + 12pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = -1;
}

void _dispatch_stream_dispose(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 40 + 8 * a2);
  if (v8)
  {
    if (*((void *)v8 + 4)) {
      _dispatch_abort(1739, *((void *)v8 + 4) == 0, a3, a4, a5, a6, a7, a8);
    }
    if (*((void *)v8 + 6)) {
      _dispatch_abort(1740, *((void *)v8 + 6) == 0, a3, a4, a5, a6, a7, a8);
    }
    if (*((void *)v8 + 1))
    {
      _dispatch_fd_entry_retain(a1);
      dispatch_source_cancel(*((dispatch_source_t *)v8 + 1));
      dispatch_resume(*((dispatch_object_t *)v8 + 1));
      dispatch_release(*((dispatch_object_t *)v8 + 1));
    }
    dispatch_set_context(*(dispatch_object_t *)v8, 0);
    dispatch_release(*(dispatch_object_t *)v8);
    free(v8);
  }
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_4(uint64_t a1)
{
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_5(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: close queue release", v1, v2, v3, v4, v5, v6, v7, 1551);
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 64));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: barrier queue release", v8, v9, v10, v11, v12, v13, v14, 1553);
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 72));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: barrier group release", v15, v16, v17, v18, v19, v20, v21, 1555);
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 80));
  if (*(_DWORD *)(*(void *)(a1 + 32) + 16) != -1)
  {
    do
    {
      if (fcntl_NOCANCEL() == -1) {
        int v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
      else {
        int v23 = 0;
      }
    }
    while (v23 == 4);
  }
  if (*(_DWORD *)(*(void *)(a1 + 32) + 20) != -1)
  {
    do
    {
      if (fcntl_NOCANCEL() == -1) {
        int v22 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
      else {
        int v22 = 0;
      }
    }
    while (v22 == 4);
  }
  _dispatch_object_finalize();
  if (*(void *)(*(void *)(a1 + 32) + 88))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 88) + 112) = 0;
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 88));
  }
  free(*(void **)(a1 + 32));
}

void ___dispatch_fd_entry_create_with_path_block_invoke(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: close queue cleanup", v1, v2, v3, v4, v5, v6, v7, 1611);
  if (!*(void *)(*(void *)(a1 + 32) + 56))
  {
    for (unsigned int i = 0; i < 2; ++i)
      _dispatch_stream_dispose(*(void *)(a1 + 32), i, v8, v9, v10, v11, v12, v13);
  }
  if (**(_DWORD **)(a1 + 32) != -1) {
    _dispatch_fd_entry_guarded_close(*(void *)(a1 + 32));
  }
  if (**(void **)(*(void *)(a1 + 32) + 8)) {
    *(void *)(**(void **)(*(void *)(a1 + 32) + 8) + 112) = 0;
  }
}

uint64_t _dispatch_fd_entry_guarded_close(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 28)) {
    return guarded_close_np();
  }
  else {
    return close_NOCANCEL();
  }
}

void ___dispatch_fd_entry_create_with_path_block_invoke_2(uint64_t a1)
{
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: close queue release", v1, v2, v3, v4, v5, v6, v7, 1630);
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 64));
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 72));
  dispatch_release(*(dispatch_object_t *)(*(void *)(a1 + 32) + 80));
  free(*(void **)(*(void *)(a1 + 32) + 8));
  free(*(void **)(a1 + 32));
}

uint64_t _dispatch_fd_entry_guarded_open(uint64_t a1)
{
  unsigned int v2 = guarded_open_np();
  if (v2 == -1)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 0;
    return open_NOCANCEL();
  }
  else
  {
    *(_DWORD *)(a1 + 28) = 15;
    return v2;
  }
}

void ___dispatch_operation_deliver_data_block_invoke(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 72) & 2) != 0
    && !*(_DWORD *)(a1 + 76)
    && *(_DWORD *)(a1 + 80)
    && dispatch_data_get_size(*(dispatch_data_t *)(a1 + 40)))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: IO handler invoke", v1, v2, v3, v4, v5, v6, v7, 2701);
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: IO handler invoke: err %d", v8, v9, v10, v11, v12, v13, v14, 2709);
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  _dispatch_release(*(void *)(a1 + 56));
  _dispatch_fd_entry_release(*(void *)(a1 + 64));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void _dispatch_data_destroy_buffer(void *a1, mach_vm_size_t a2, dispatch_queue_s *a3, Block_layout *a4)
{
  uint64_t v4 = a3;
  if (a4 == &__block_literal_global)
  {
    free(a1);
  }
  else if (a4 != &__block_literal_global_4154)
  {
    if (a4 == &__block_literal_global_4158)
    {
      mach_vm_deallocate(mach_task_self_, (mach_vm_address_t)a1, a2);
    }
    else
    {
      if (!a3) {
        uint64_t v4 = (dispatch_queue_s *)&off_F0600;
      }
      dispatch_channel_async_f(v4, a4, (dispatch_function_t)_dispatch_call_block_and_release);
    }
  }
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  uint64_t v21 = (void *)buffer;
  if (buffer && size)
  {
    if (destructor)
    {
      if (destructor == &__block_literal_global_4162)
      {
        if (size < 0xFFFFFFFFFFFFFFB0)
        {
          v26[8] = 0;
          if (is_mul_ok(0, 0x18uLL))
          {
            *(void *)uint64_t v26 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
            uint64_t v27 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, size + 80 + *(void *)&v26[1], (uint64_t)queue, (uint64_t)destructor, v4, v5, v6, v7);
            *((void *)v27 + 9) = 0;
            *((void *)v27 + 3) = &off_F0600;
            *((void *)v27 + 2) = -1985229329;
            uint64_t v28 = v27;
          }
          else
          {
            uint64_t v28 = 0;
          }
        }
        else
        {
          uint64_t v28 = 0;
        }
        uint64_t v16 = v28;
        uint64_t v21 = (void *)__memcpy_chk();
        uint64_t v18 = &__block_literal_global_4154;
      }
      else
      {
        v23[8] = 0;
        if (is_mul_ok(0, 0x18uLL))
        {
          *(void *)int v23 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
          uint64_t v24 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, *(void *)&v23[1] + 80, (uint64_t)queue, (uint64_t)destructor, v4, v5, v6, v7);
          *((void *)v24 + 9) = 0;
          *((void *)v24 + 3) = &off_F0600;
          *((void *)v24 + 2) = -1985229329;
          uint64_t v25 = v24;
        }
        else
        {
          uint64_t v25 = 0;
        }
        uint64_t v16 = v25;
        uint64_t v18 = (Block_layout *)_dispatch_Block_copy(destructor);
      }
    }
    else
    {
      if (!malloc_type_malloc()) {
        return 0;
      }
      uint64_t v21 = (void *)__memcpy_chk();
      v29[8] = 0;
      if (is_mul_ok(0, 0x18uLL))
      {
        *(void *)uint64_t v29 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
        uint64_t v30 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, *(void *)&v29[1] + 80, v9, v10, v11, v12, v13, v14);
        *((void *)v30 + 9) = 0;
        *((void *)v30 + 3) = &off_F0600;
        *((void *)v30 + 2) = -1985229329;
        uint64_t v31 = v30;
      }
      else
      {
        uint64_t v31 = 0;
      }
      uint64_t v16 = v31;
      uint64_t v18 = &__block_literal_global;
    }
    *((void *)v16 + 6) = v21;
    *((void *)v16 + 8) = size;
    *((void *)v16 + 7) = v18;
    if (queue)
    {
      _dispatch_retain((uint64_t)queue);
      *((void *)v16 + 3) = queue;
    }
    return v16;
  }
  else
  {
    if (destructor)
    {
      uint64_t v8 = (Block_layout *)_dispatch_Block_copy(destructor);
      _dispatch_data_destroy_buffer(v21, size, queue, v8);
    }
    return &_dispatch_data_empty;
  }
}

dispatch_data_t dispatch_data_create_f(const void *a1, size_t a2, dispatch_queue_s *a3, Block_layout *a4)
{
  uint64_t v17 = a1;
  size_t v16 = a2;
  dispatch_queue_t v15 = a3;
  uint64_t v14 = a4;
  uint64_t v13 = 0;
  uint64_t v5 = 0;
  if (a4) {
    uint64_t v5 = a4;
  }
  uint64_t v13 = v5;
  if (v5
    && v13 != &__block_literal_global
    && v13 != &__block_literal_global_4154
    && v13 != &__block_literal_global_4158
    && v13 != &__block_literal_global_4162)
  {
    uint64_t v6 = _NSConcreteStackBlock;
    int v7 = 0x40000000;
    int v8 = 0;
    uint64_t v9 = __dispatch_data_create_f_block_invoke;
    uint64_t v10 = &__block_descriptor_tmp_0;
    uint64_t v11 = v14;
    uint64_t v12 = v17;
    uint64_t v13 = (Block_layout *)&v6;
  }
  return dispatch_data_create(v17, v16, v15, v13);
}

uint64_t __dispatch_data_create_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
}

dispatch_data_s *dispatch_data_create_alloc(unint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = &_dispatch_data_empty;
  uint64_t v9 = 0;
  if (a1)
  {
    if (a1 < 0xFFFFFFFFFFFFFFB0)
    {
      if (is_mul_ok(0, 0x18uLL))
      {
        uint64_t v13 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, a1 + 80, a3, a4, a5, a6, a7, a8);
        *((void *)v13 + 9) = 0;
        *((void *)v13 + 3) = &off_F0600;
        *((void *)v13 + 2) = -1985229329;
        uint64_t v14 = v13;
      }
      else
      {
        uint64_t v14 = 0;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v10 = v14;
    uint64_t v9 = (void *)((char *)v14 + 80);
    *((void *)v14 + 6) = (char *)v14 + 80;
    *((void *)v14 + 8) = a1;
    *((void *)v14 + 7) = &__block_literal_global_4154;
  }
  if (a2) {
    *a2 = v9;
  }
  return v10;
}

void _dispatch_data_dispose(uint64_t a1)
{
  if (*(void *)(a1 + 72))
  {
    for (unint64_t i = 0; ; ++i)
    {
      unint64_t v1 = *(void *)(a1 + 72) ? *(void *)(a1 + 72) : 1;
      if (i >= v1) {
        break;
      }
      dispatch_release(*(dispatch_object_t *)(a1 + 80 + 24 * i));
    }
    free(*(void **)(a1 + 48));
  }
  else
  {
    _dispatch_data_destroy_buffer(*(void **)(a1 + 48), *(void *)(a1 + 64), *(dispatch_queue_s **)(a1 + 24), *(Block_layout **)(a1 + 56));
  }
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return *((void *)data + 8);
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  if (*((void *)data1 + 8))
  {
    if (*((void *)data2 + 8))
    {
      if (*((void *)data1 + 9)) {
        uint64_t v15 = *((void *)data1 + 9);
      }
      else {
        uint64_t v15 = 1;
      }
      if (*((void *)data2 + 9)) {
        uint64_t v14 = *((void *)data2 + 9);
      }
      else {
        uint64_t v14 = 1;
      }
      BOOL v8 = __CFADD__(v15, v14);
      uint64_t v17 = v15 + v14;
      if (v8)
      {
        return 0;
      }
      else
      {
        if (((unint64_t)v17 * (unsigned __int128)0x18uLL) >> 64 != 0
          || (unint64_t)(24 * v17) >= 0xFFFFFFFFFFFFFFB0)
        {
          int v22 = 0;
        }
        else
        {
          uint64_t v21 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, 24 * v17 + 80, v2, v3, v4, v5, v6, v7);
          *((void *)v21 + 9) = v17;
          *((void *)v21 + 3) = &off_F0600;
          *((void *)v21 + 2) = -1985229329;
          int v22 = v21;
        }
        *((void *)v22 + 8) = *((void *)data1 + 8) + *((void *)data2 + 8);
        if (*((void *)data1 + 9))
        {
          __memcpy_chk();
        }
        else
        {
          *((void *)v22 + 1_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
          *((void *)v22 + 12) = *((void *)data1 + 8);
          *((void *)v22 + 1pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = data1;
        }
        if (*((void *)data2 + 9))
        {
          __memcpy_chk();
        }
        else
        {
          if (*((void *)data1 + 9)) {
            uint64_t v13 = *((void *)data1 + 9);
          }
          else {
            uint64_t v13 = 1;
          }
          *((void *)v22 + 3 * v13 + 1_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = 0;
          if (*((void *)data1 + 9)) {
            uint64_t v12 = *((void *)data1 + 9);
          }
          else {
            uint64_t v12 = 1;
          }
          *((void *)v22 + 3 * v12 + 12) = *((void *)data2 + 8);
          if (*((void *)data1 + 9)) {
            uint64_t v11 = *((void *)data1 + 9);
          }
          else {
            uint64_t v11 = 1;
          }
          *((void *)v22 + 3 * v11 + 1pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = data2;
        }
        for (unint64_t i = 0; ; ++i)
        {
          unint64_t v10 = *((void *)v22 + 9) ? *((void *)v22 + 9) : 1;
          if (i >= v10) {
            break;
          }
          dispatch_retain(*((dispatch_object_t *)v22 + 3 * i + 10));
        }
        return v22;
      }
    }
    else
    {
      dispatch_retain(data1);
      return data1;
    }
  }
  else
  {
    dispatch_retain(data2);
    return data2;
  }
}

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  size_t v20 = offset;
  size_t lengtha = length;
  if (offset >= *((void *)data + 8) || !length) {
    return &_dispatch_data_empty;
  }
  if (length <= *((void *)data + 8) - offset)
  {
    if (length == *((void *)data + 8))
    {
      dispatch_retain(data);
      return data;
    }
  }
  else
  {
    size_t lengtha = *((void *)data + 8) - offset;
  }
  if (*((void *)data + 9))
  {
    unint64_t v12 = *((void *)data + 9);
    BOOL v18 = offset + lengtha == *((void *)data + 8);
    for (unint64_t i = 0; ; ++i)
    {
      BOOL v11 = 0;
      if (i < v12) {
        BOOL v11 = v20 >= *((void *)data + 3 * i + 12);
      }
      if (!v11) {
        break;
      }
      BOOL v8 = (char *)data + 24 * i;
      v20 -= *((void *)v8 + 12);
    }
    if (i >= v12)
    {
      qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_create_subrange out of bounds";
      qword_F42C0 = i;
      __break(1u);
      JUMPOUT(0xB96E0);
    }
    if (v20 + lengtha > *((void *)data + 3 * i + 12))
    {
      size_t v14 = 0;
      if (offset + lengtha == *((void *)data + 8))
      {
        unint64_t v15 = v12 - i;
      }
      else
      {
        size_t v14 = lengtha + v20 - *((void *)data + 3 * i + 12);
        unint64_t v15 = 1;
        while (i + v15 < v12)
        {
          uint64_t v9 = 24 * (i + v15++);
          size_t v13 = *(void *)((char *)data + v9 + 96);
          if (v14 <= v13) {
            break;
          }
          v14 -= v13;
          if (i + v15 >= v12)
          {
            qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_create_subrange out of bounds";
            qword_F42C0 = i + v15;
            __break(1u);
            JUMPOUT(0xB988CLL);
          }
        }
      }
      if (!is_mul_ok(v15, 0x18uLL) || 24 * v15 >= 0xFFFFFFFFFFFFFFB0)
      {
        uint64_t v24 = 0;
      }
      else
      {
        int v23 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, 24 * v15 + 80, length, v3, v4, v5, v6, v7);
        *((void *)v23 + 9) = v15;
        *((void *)v23 + 3) = &off_F0600;
        *((void *)v23 + 2) = -1985229329;
        uint64_t v24 = v23;
      }
      *((void *)v24 + 8) = lengtha;
      __memcpy_chk();
      if (v20)
      {
        *((void *)v24 + 11) += v20;
        *((void *)v24 + 12) -= v20;
      }
      if (!v18) {
        *((void *)v24 + 3 * v15 + 9) = v14;
      }
      for (unint64_t j = 0; j < v15; ++j)
        dispatch_retain(*((dispatch_object_t *)v24 + 3 * j + 10));
      return v24;
    }
    else
    {
      return dispatch_data_create_subrange(*((dispatch_data_t *)data + 3 * i + 10), *((void *)data + 3 * i + 11) + v20, lengtha);
    }
  }
  else
  {
    if (is_mul_ok(1uLL, 0x18uLL))
    {
      uint64_t v25 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, 0x68uLL, length, v3, v4, v5, v6, v7);
      *((void *)v25 + 9) = 1;
      *((void *)v25 + 3) = &off_F0600;
      *((void *)v25 + 2) = -1985229329;
      uint64_t v26 = v25;
    }
    else
    {
      uint64_t v26 = 0;
    }
    *((void *)v26 + 8) = lengtha;
    *((void *)v26 + 1_dispatch_source_set_handler((unint64_t)source, handler, 2, 1) = v20;
    *((void *)v26 + 12) = lengtha;
    *((void *)v26 + 1pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = data;
    dispatch_retain(data);
    return v26;
  }
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  uint64_t v6 = 0;
  long long buffer = 0;
  size_t size = *((void *)data + 8);
  if (size)
  {
    dispatch_data_t v12 = data;
    uint64_t v11 = 0;
    if (*((void *)data + 9) == 1)
    {
      uint64_t v11 = *((void *)data + 11);
      dispatch_data_t v12 = (dispatch_data_t)*((void *)data + 10);
    }
    if (*((void *)v12 + 9))
    {
      unint64_t v10 = (char *)*((void *)v12 + 6);
      if (v10) {
        v10 += v11;
      }
    }
    else
    {
      unint64_t v10 = (char *)(*((void *)v12 + 6) + v11);
    }
    long long buffer = v10;
    if (v10)
    {
      dispatch_retain(data);
      uint64_t v6 = data;
    }
    else
    {
      long long buffer = (void *)_dispatch_data_flatten(data);
      if (buffer) {
        uint64_t v6 = dispatch_data_create(buffer, size, 0, &__block_literal_global);
      }
      else {
        size_t size = 0;
      }
    }
  }
  else
  {
    uint64_t v6 = &_dispatch_data_empty;
  }
  if (buffer_ptr) {
    *buffer_ptr = buffer;
  }
  if (size_ptr) {
    *size_ptr = size;
  }
  return v6;
}

uint64_t _dispatch_data_flatten(dispatch_data_s *a1)
{
  dispatch_data_t v9 = a1;
  uint64_t v8 = malloc_type_malloc();
  if (v8)
  {
    applier = _NSConcreteStackBlock;
    int v3 = 0x40000000;
    int v4 = 0;
    uint64_t v5 = ___dispatch_data_flatten_block_invoke;
    uint64_t v6 = &__block_descriptor_tmp_11;
    uint64_t v7 = v8;
    dispatch_data_apply(v9, &applier);
  }
  return v8;
}

char *dispatch_data_get_flattened_bytes_4libxpc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v15 = (dispatch_data_s *)a1;
  size_t v14 = 0;
  uint64_t v13 = 0;
  if (!*(void *)(a1 + 64)) {
    return 0;
  }
  uint64_t v24 = v15;
  uint64_t v23 = 0;
  int v22 = &v15;
  uint64_t v21 = &v13;
  size_t v20 = 0;
  uint64_t v29 = *((void *)v15 + 8);
  uint64_t v28 = 131;
  if (!v29) {
    _dispatch_abort(v28, 0, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v26 = v24;
  if (*((void *)v24 + 9))
  {
    uint64_t v27 = v24;
    uint64_t v10 = *((void *)v24 + 9) ? *((void *)v24 + 9) : 1;
    if (v10 == 1)
    {
      v23 += *((void *)v24 + 11);
      uint64_t v24 = (dispatch_data_s *)*((void *)v24 + 10);
    }
  }
  uint64_t v25 = v24;
  if (*((void *)v24 + 9))
  {
    uint64_t v19 = 0;
    BOOL v18 = (char *)*((void *)v24 + 6);
    uint64_t v19 = v18;
    uint64_t v17 = v18;
    size_t v20 = v18;
    if (v18) {
      v20 += v23;
    }
  }
  else
  {
    size_t v20 = (char *)(*((void *)v24 + 6) + v23);
  }
  if (v22) {
    *int v22 = v24;
  }
  if (v21) {
    *uint64_t v21 = v23;
  }
  size_t v14 = v20;
  if (v20) {
    return v14;
  }
  dispatch_data_t v12 = (char *)_dispatch_data_flatten(v15);
  if (!v12) {
    return 0;
  }
  uint64_t v11 = 0;
  uint64_t v8 = 0;
  atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)((char *)v15 + 48), (unint64_t *)&v8, (unint64_t)v12, memory_order_release, memory_order_relaxed);
  if (v8) {
    uint64_t v11 = v8;
  }
  size_t v14 = v11;
  if (v8) {
    free(v12);
  }
  else {
    size_t v14 = v12;
  }
  return &v14[v13];
}

uint64_t dispatch_data_apply_f(void *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[8]) {
    char v9 = _dispatch_data_apply(a1, 0, 0, a1[8], a2, a3, a7, a8) & 1;
  }
  else {
    char v9 = 1;
  }
  return v9 & 1;
}

uint64_t _dispatch_data_apply(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7, uint64_t a8)
{
  uint64_t v15 = a2;
  char v12 = 1;
  size_t v20 = a1;
  uint64_t v19 = 0;
  if (!a1[8]) {
    _dispatch_abort(131, 0, a3, a4, a5, (uint64_t)a6, a7, a8);
  }
  if (a1[9] == 1)
  {
    uint64_t v19 = a1[11];
    size_t v20 = (void *)a1[10];
  }
  if (v20[9])
  {
    uint64_t v18 = v20[6];
    if (v18) {
      v18 += v19;
    }
  }
  else
  {
    uint64_t v18 = v20[6] + v19;
  }
  if (v18)
  {
    char v17 = _dispatch_data_apply_client_callout(a5, (uint64_t)a1, a2, v18 + a3, a4, a6) & 1;
  }
  else
  {
    for (unint64_t i = 0; ; ++i)
    {
      unint64_t v10 = a1[9] ? a1[9] : 1;
      char v9 = 0;
      if (i < v10) {
        char v9 = v12;
      }
      if ((v9 & 1) == 0) {
        break;
      }
      char v12 = _dispatch_data_apply(a1[3 * i + 10], v15, a1[3 * i + 11], a1[3 * i + 12], a5, a6) & 1;
      v15 += a1[3 * i + 12];
    }
    char v17 = v12;
  }
  return v17 & 1;
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  if (!*((void *)data + 8)) {
    return 1;
  }
  uint64_t v6 = *((void *)data + 8);
  uint64_t v7 = _Block_get_invoke_fn((uint64_t)applier);
  uint64_t v8 = 0;
  if (v7) {
    uint64_t v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))v7;
  }
  uint64_t v5 = 0;
  if (v8) {
    uint64_t v5 = v8;
  }
  return _dispatch_data_apply(data, 0, 0, v6, (uint64_t)applier, v5, v2, v3) & 1;
}

dispatch_data_t dispatch_data_copy_region(dispatch_data_t data, size_t location, size_t *offset_ptr)
{
  if (location < *((void *)data + 8))
  {
    *offset_ptr = 0;
    return (dispatch_data_t)_dispatch_data_copy_region(data, 0, *((void *)data + 8), location, offset_ptr, v3, v4, v5);
  }
  else
  {
    *offset_ptr = *((void *)data + 8);
    return &_dispatch_data_empty;
  }
}

dispatch_object_s *_dispatch_data_copy_region(dispatch_object_s *a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = a1;
  unint64_t v25 = a2;
  uint64_t v23 = 0;
  uint64_t v22 = 0;
  if (!a2 && a3 == *((void *)v26 + 8)) {
    uint64_t v23 = v26;
  }
  uint64_t v50 = v26;
  unint64_t v49 = v25;
  uint64_t v48 = &v26;
  int v47 = &v25;
  unint64_t v46 = 0;
  uint64_t v55 = *((void *)v26 + 8);
  uint64_t v54 = 131;
  if (!v55) {
    _dispatch_abort(v54, 0, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
  uint64_t v52 = v50;
  if (*((void *)v50 + 9))
  {
    uint64_t v53 = v50;
    uint64_t v17 = *((void *)v50 + 9) ? *((void *)v50 + 9) : 1;
    if (v17 == 1)
    {
      v49 += *((void *)v50 + 11);
      uint64_t v50 = (dispatch_object_s *)*((void *)v50 + 10);
    }
  }
  int v51 = v50;
  if (*((void *)v50 + 9))
  {
    unint64_t v45 = 0;
    unint64_t v44 = *((void *)v50 + 6);
    unint64_t v45 = v44;
    unint64_t v43 = v44;
    unint64_t v46 = v44;
    if (v44) {
      v46 += v49;
    }
  }
  else
  {
    unint64_t v46 = *((void *)v50 + 6) + v49;
  }
  if (v48) {
    *uint64_t v48 = v50;
  }
  if (v47) {
    *int v47 = v49;
  }
  if (!v46)
  {
    for (unint64_t i = 0; ; ++i)
    {
      int v38 = v26;
      if (*((void *)v26 + 9)) {
        unint64_t v16 = *((void *)v26 + 9);
      }
      else {
        unint64_t v16 = 1;
      }
      if (i >= v16)
      {
        uint64_t v14 = *a5 + v22;
        qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_copy_region out of bounds";
        qword_F42C0 = v14;
        __break(1u);
        JUMPOUT(0xBADE4);
      }
      unint64_t v18 = *((void *)v26 + 3 * i + 12);
      if (v25 < v18)
      {
        unint64_t v19 = v18 - v25;
        if (a4 < v22 + v19)
        {
          v25 += *((void *)v26 + 3 * i + 11);
          uint64_t v26 = (dispatch_object_s *)*((void *)v26 + 3 * i + 10);
          *a5 += v22;
          return (dispatch_object_s *)_dispatch_data_copy_region(v26, v25, v19, a4 - v22, a5);
        }
        v22 += v19;
        unint64_t v25 = 0;
      }
      else
      {
        v25 -= v18;
      }
    }
  }
  if (v23)
  {
    dispatch_retain(v23);
    return v23;
  }
  else
  {
    dispatch_retain(v26);
    if (v25 || a3 != *((void *)v26 + 8))
    {
      uint64_t v36 = 1;
      uint64_t v35 = 0;
      uint64_t v34 = 0;
      uint64_t v32 = 80;
      char v42 = 0;
      uint64_t v31 = 24;
      BOOL v41 = !is_mul_ok(1uLL, 0x18uLL);
      BOOL v30 = v41;
      unint64_t v33 = 104;
      char v40 = 0;
      char v29 = 0;
      int v28 = v41;
      BOOL v39 = v41;
      if (v41)
      {
        uint64_t v37 = 0;
      }
      else
      {
        uint64_t v34 = _dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, v33, v8, v9, v10, v11, v12, v13);
        v34[9] = v36;
        v34[3] = &off_F0600;
        void v34[2] = -1985229329;
        uint64_t v37 = v34;
      }
      uint64_t v21 = v37;
      v37[8] = a3;
      v21[11] = v25;
      v21[12] = a3;
      v21[10] = v26;
      return (dispatch_object_s *)v21;
    }
    else
    {
      return v26;
    }
  }
}

uint64_t dispatch_data_make_memory_entry(uint64_t a1)
{
  kern_return_t v26;
  void **applier;
  int v28;
  int v29;
  uint64_t (*v30)();
  void *v31;
  mach_vm_address_t v32;
  kern_return_t v33;
  kern_return_t v34;
  BOOL i;
  kern_return_t memory_entry_64;
  vm_prot_t permission;
  mach_vm_address_t address;
  mach_vm_size_t size;
  memory_object_size_t v40;
  mach_port_t object_handle;
  dispatch_data_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  char v42 = (dispatch_data_t)a1;
  mach_port_t object_handle = 0;
  char v40 = 0;
  size_t size = 0;
  size_t size = *(void *)(a1 + 64);
  address = 0;
  vm_prot_t permission = 0;
  memory_entry_64 = 0;
  unint64_t i = 0;
  for (unint64_t i = *(void *)(a1 + 56) != (void)&__block_literal_global_4158; ; unint64_t i = 1)
  {
    if (i)
    {
      address = vm_page_size;
      memory_entry_64 = mach_vm_allocate(mach_task_self_, &address, size, 1);
      if (memory_entry_64)
      {
        if (memory_entry_64 != 3)
        {
          uint64_t v34 = memory_entry_64;
          int v51 = memory_entry_64;
          uint64_t v50 = 704;
          _dispatch_bug(v50, v51, v1, v2, v3, v4, v5, v6);
          unint64_t v33 = v34;
        }
        return object_handle;
      }
      applier = _NSConcreteStackBlock;
      int v28 = 0x40000000;
      char v29 = 0;
      BOOL v30 = __dispatch_data_make_memory_entry_block_invoke;
      uint64_t v31 = &__block_descriptor_tmp_9;
      uint64_t v32 = address;
      dispatch_data_apply(v42, &applier);
    }
    else
    {
      address = *((void *)v42 + 6);
    }
    vm_prot_t permission = 2097219;
    char v40 = size;
    memory_entry_64 = mach_make_memory_entry_64(mach_task_self_, &v40, address, 2097219, &object_handle, 0);
    if (memory_entry_64 == 18)
    {
      permission &= ~0x200000u;
      memory_entry_64 = mach_make_memory_entry_64(mach_task_self_, &v40, address, permission, &object_handle, 0);
    }
    uint64_t v26 = memory_entry_64;
    unint64_t v49 = memory_entry_64;
    uint64_t v48 = 726;
    if (memory_entry_64) {
      _dispatch_bug(v48, v49, v7, v8, v9, v10, v11, v12);
    }
    if (v26)
    {
      mach_port_t object_handle = 0;
      goto LABEL_23;
    }
    if (v40 >= size) {
      goto LABEL_23;
    }
    memory_entry_64 = mach_port_deallocate(mach_task_self_, object_handle);
    int v47 = memory_entry_64;
    unint64_t v46 = 731;
    if (memory_entry_64) {
      _dispatch_bug(v46, v47, v13, v14, v15, v16, v17, v18);
    }
    if (i) {
      break;
    }
  }
  mach_port_t object_handle = 0;
LABEL_23:
  if (i)
  {
    memory_entry_64 = mach_vm_deallocate(mach_task_self_, address, size);
    unint64_t v45 = memory_entry_64;
    unint64_t v44 = 740;
    if (memory_entry_64) {
      _dispatch_bug(v44, v45, v19, v20, v21, v22, v23, v24);
    }
  }
  return object_handle;
}

uint64_t __dispatch_data_make_memory_entry_block_invoke()
{
  return 1;
}

uint64_t ___dispatch_data_flatten_block_invoke()
{
  return 1;
}

uint64_t _dispatch_data_apply_client_callout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  return a6(a1, a2, a3, a4, a5) & 1;
}

dispatch_data_s *dispatch_data_create_with_transform(dispatch_data_s *a1, void *a2, uint64_t a3)
{
  uint64_t v7 = a2;
  if (*a2 == 16)
  {
    uint64_t v7 = _dispatch_transform_detect_utf(a1);
    if (!v7) {
      return 0;
    }
  }
  if ((*v7 & ~*(void *)(a3 + 8)) != 0) {
    return 0;
  }
  if ((*(void *)a3 & ~v7[2]) != 0) {
    return 0;
  }
  if (!dispatch_data_get_size(a1)) {
    return a1;
  }
  if (v7[3])
  {
    uint64_t v5 = (dispatch_object_s *)((uint64_t (*)(dispatch_data_s *))v7[3])(a1);
  }
  else
  {
    dispatch_retain(a1);
    uint64_t v5 = a1;
  }
  if (!v5) {
    return 0;
  }
  if (*(void *)(a3 + 32))
  {
    uint64_t v4 = (*(uint64_t (**)(dispatch_object_s *))(a3 + 32))(v5);
  }
  else
  {
    dispatch_retain(v5);
    uint64_t v4 = (uint64_t)v5;
  }
  dispatch_release(v5);
  return (dispatch_data_s *)v4;
}

void *_dispatch_transform_detect_utf(dispatch_data_s *a1)
{
  v4[1] = a1;
  v4[0] = 0;
  dispatch_data_t v3 = _dispatch_data_subrange_map(a1, v4, 0, 2uLL);
  if (!v3) {
    return 0;
  }
  uint64_t v2 = &_dispatch_data_format_type_utf8;
  if (*(unsigned __int16 *)v4[0] == 65279)
  {
    uint64_t v2 = &_dispatch_data_format_type_utf16le;
  }
  else if (*(unsigned __int16 *)v4[0] == 65534)
  {
    uint64_t v2 = &_dispatch_data_format_type_utf16be;
  }
  dispatch_release(v3);
  return v2;
}

uint64_t _dispatch_transform_from_base32(dispatch_data_s *a1)
{
  return _dispatch_transform_from_base32_with_table(a1, (uint64_t)&base32_decode_table, 91);
}

dispatch_data_t _dispatch_transform_to_base32(dispatch_data_s *a1)
{
  return _dispatch_transform_to_base32_with_table(a1, (uint64_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567");
}

uint64_t _dispatch_transform_from_base32hex(dispatch_data_s *a1)
{
  return _dispatch_transform_from_base32_with_table(a1, (uint64_t)&base32hex_decode_table, 33);
}

dispatch_data_t _dispatch_transform_to_base32hex(dispatch_data_s *a1)
{
  return _dispatch_transform_to_base32_with_table(a1, (uint64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUV");
}

uint64_t _dispatch_transform_from_base64(dispatch_data_s *a1)
{
  char v29 = a1;
  v25[0] = 0;
  v25[1] = v25;
  int v26 = 0;
  int v27 = 32;
  uint64_t v28 = 0;
  v21[0] = 0;
  v21[1] = v21;
  int v22 = 0;
  int v23 = 32;
  uint64_t v24 = 0;
  v17[0] = 0;
  v17[1] = v17;
  int v18 = 0;
  int v19 = 32;
  uint64_t v20 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  int v14 = 0;
  int v15 = 32;
  uint64_t v16 = &_dispatch_data_empty;
  BOOL v11 = 0;
  applier = _NSConcreteStackBlock;
  int v3 = 1107296256;
  int v4 = 0;
  uint64_t v5 = ___dispatch_transform_from_base64_block_invoke;
  uint64_t v6 = &__block_descriptor_tmp_4_0;
  uint64_t v7 = v21;
  uint64_t v8 = v17;
  uint64_t v9 = v25;
  uint64_t v10 = &v12;
  BOOL v11 = dispatch_data_apply(a1, &applier);
  if (v11)
  {
    uint64_t v30 = v13[3];
  }
  else
  {
    dispatch_release((dispatch_object_t)v13[3]);
    uint64_t v30 = 0;
  }
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v25, 8);
  return v30;
}

dispatch_data_t _dispatch_transform_to_base64(dispatch_data_s *a1)
{
  dispatch_data_t v25 = a1;
  size_t size = dispatch_data_get_size(a1);
  size_t v23 = 0;
  v19[0] = 0;
  v19[1] = v19;
  int v20 = 0;
  int v21 = 32;
  uint64_t v22 = 0;
  if (size % 3) {
    unint64_t v2 = size / 3 + 1;
  }
  else {
    unint64_t v2 = size / 3;
  }
  size_t v23 = v2;
  if (v2 <= 0x3FFFFFFFFFFFFFFFLL)
  {
    v23 *= 4;
    uint64_t v17 = (void *)malloc_type_malloc();
    if (v17)
    {
      v13[0] = 0;
      v13[1] = v13;
      int v14 = 0;
      int v15 = 32;
      uint64_t v16 = v17;
      BOOL v12 = 0;
      applier = _NSConcreteStackBlock;
      int v4 = 1107296256;
      int v5 = 0;
      uint64_t v6 = ___dispatch_transform_to_base64_block_invoke;
      uint64_t v7 = &__block_descriptor_tmp_7;
      uint64_t v8 = v19;
      dispatch_data_t v10 = v25;
      uint64_t v9 = v13;
      size_t v11 = size;
      BOOL v12 = dispatch_data_apply(v25, &applier);
      if (v12)
      {
        dispatch_data_t v26 = dispatch_data_create(v17, v23, 0, &__block_literal_global);
      }
      else
      {
        free(v17);
        dispatch_data_t v26 = 0;
      }
      int v18 = 1;
      _Block_object_dispose(v13, 8);
    }
    else
    {
      dispatch_data_t v26 = 0;
      int v18 = 1;
    }
  }
  else
  {
    dispatch_data_t v26 = 0;
    int v18 = 1;
  }
  _Block_object_dispose(v19, 8);
  return v26;
}

uint64_t _dispatch_transform_from_utf16le(dispatch_data_s *a1)
{
  return _dispatch_transform_from_utf16(a1, 1);
}

uint64_t _dispatch_transform_to_utf16le(dispatch_data_s *a1)
{
  return _dispatch_transform_to_utf16(a1, 1);
}

uint64_t _dispatch_transform_from_utf16be(dispatch_data_s *a1)
{
  return _dispatch_transform_from_utf16(a1, 2);
}

uint64_t _dispatch_transform_to_utf16be(dispatch_data_s *a1)
{
  return _dispatch_transform_to_utf16(a1, 2);
}

dispatch_data_t _dispatch_transform_to_utf8_without_bom(dispatch_data_s *a1)
{
  uint64_t v7 = a1;
  uint64_t v6 = 0;
  dispatch_data_t v5 = _dispatch_data_subrange_map(a1, &v6, 0, 3uLL);
  BOOL v4 = 0;
  if (v5)
  {
    BOOL v4 = memcmp(v6, &_dispatch_transform_to_utf8_without_bom_utf8_bom, 3uLL) == 0;
    dispatch_release(v5);
  }
  if (v4)
  {
    int data = v7;
    size_t size = dispatch_data_get_size(v7);
    return dispatch_data_create_subrange(data, 3uLL, size - 3);
  }
  else
  {
    dispatch_retain(v7);
    return v7;
  }
}

dispatch_data_t _dispatch_data_subrange_map(dispatch_data_s *a1, const void **a2, size_t a3, size_t a4)
{
  dispatch_data_t map = 0;
  int data = dispatch_data_create_subrange(a1, a3, a4);
  if (dispatch_data_get_size(data) == a4) {
    dispatch_data_t map = dispatch_data_create_map(data, a2, 0);
  }
  dispatch_release(data);
  return map;
}

uint64_t _dispatch_transform_from_base32_with_table(dispatch_data_s *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = a1;
  uint64_t v34 = a2;
  uint64_t v33 = a3;
  v29[0] = 0;
  v29[1] = v29;
  int v30 = 0;
  int v31 = 32;
  uint64_t v32 = 0;
  v25[0] = 0;
  v25[1] = v25;
  int v26 = 0;
  int v27 = 32;
  uint64_t v28 = 0;
  v21[0] = 0;
  v21[1] = v21;
  int v22 = 0;
  int v23 = 32;
  uint64_t v24 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  int v18 = 0;
  int v19 = 32;
  int v20 = &_dispatch_data_empty;
  BOOL v15 = 0;
  applier = _NSConcreteStackBlock;
  int v5 = 1107296256;
  int v6 = 0;
  uint64_t v7 = ___dispatch_transform_from_base32_with_table_block_invoke;
  uint64_t v8 = &__block_descriptor_tmp_3;
  uint64_t v13 = a3;
  uint64_t v14 = a2;
  uint64_t v9 = v25;
  dispatch_data_t v10 = v21;
  size_t v11 = v29;
  BOOL v12 = &v16;
  BOOL v15 = dispatch_data_apply(a1, &applier);
  if (v15)
  {
    uint64_t v36 = v17[3];
  }
  else
  {
    dispatch_release((dispatch_object_t)v17[3]);
    uint64_t v36 = 0;
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v25, 8);
  _Block_object_dispose(v29, 8);
  return v36;
}

uint64_t ___dispatch_transform_from_base32_with_table_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  int v19 = (unsigned char *)malloc_type_malloc();
  int v18 = v19;
  if (v19)
  {
    for (unint64_t i = 0; i < a5; ++i)
    {
      if (*(unsigned char *)(a4 + i) != 10 && *(unsigned char *)(a4 + i) != 9 && *(unsigned char *)(a4 + i) != 32)
      {
        uint64_t v17 = *(unsigned __int8 *)(a4 + i);
        if (v17 >= a1[8] || *(char *)(a1[9] + v17) == -1)
        {
          free(v19);
          char v23 = 0;
          return v23 & 1;
        }
        ++*(void *)(*(void *)(a1[4] + 8) + 24);
        char v16 = *(unsigned char *)(a1[9] + v17);
        if (v16 == -2)
        {
          char v16 = 0;
          ++*(void *)(*(void *)(a1[5] + 8) + 24);
        }
        *(void *)(*(void *)(a1[6] + 8) + 24) *= 32;
        *(void *)(*(void *)(a1[6] + 8) + 24) += v16;
        if ((*(void *)(*(void *)(a1[4] + 8) + 24) & 7) == 0)
        {
          *int v18 = BYTE4(*(void *)(*(void *)(a1[6] + 8) + 24));
          v18[1] = BYTE3(*(void *)(*(void *)(a1[6] + 8) + 24));
          v18[2] = BYTE2(*(void *)(*(void *)(a1[6] + 8) + 24));
          v18[3] = BYTE1(*(void *)(*(void *)(a1[6] + 8) + 24));
          int v5 = v18 + 4;
          v18 += 5;
          *int v5 = *(unsigned char *)(*(void *)(a1[6] + 8) + 24);
        }
      }
    }
    size_t size = v18 - v19;
    unint64_t v6 = *(void *)(*(void *)(a1[5] + 8) + 24);
    BOOL v7 = v6 > 1;
    unint64_t v8 = v6 - 1;
    if (v7)
    {
      unint64_t v10 = v8;
      char v9 = 1;
    }
    else
    {
      unint64_t v10 = v8;
      char v9 = 0;
    }
    if ((v9 & 1) == 0)
    {
      switch(v10)
      {
        case 0uLL:
          --size;
          break;
        case 1uLL:
        case 4uLL:
          break;
        case 2uLL:
          size -= 2;
          break;
        case 3uLL:
          size -= 3;
          break;
        case 5uLL:
          size -= 4;
          break;
        default:
          JUMPOUT(0);
      }
    }
    data2 = dispatch_data_create(v19, size, 0, &__block_literal_global);
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(a1[7] + 8) + 24), data2);
    dispatch_release(data2);
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1[7] + 8) + 24));
    *(void *)(*(void *)(a1[7] + 8) + 24) = concat;
    char v23 = 1;
  }
  else
  {
    char v23 = 0;
  }
  return v23 & 1;
}

void __copy_helper_block_8_32r40r48r56r(uint64_t a1, const void **a2)
{
}

void __destroy_helper_block_8_32r40r48r56r(const void **a1)
{
}

dispatch_data_t _dispatch_transform_to_base32_with_table(dispatch_data_s *a1, uint64_t a2)
{
  dispatch_data_t v28 = a1;
  uint64_t v27 = a2;
  size_t size = dispatch_data_get_size(a1);
  size_t v25 = 0;
  v21[0] = 0;
  v21[1] = v21;
  int v22 = 0;
  int v23 = 32;
  uint64_t v24 = 0;
  if (size % 5) {
    unint64_t v3 = size / 5 + 1;
  }
  else {
    unint64_t v3 = size / 5;
  }
  size_t v25 = v3;
  if (v3 <= 0x1FFFFFFFFFFFFFFFLL)
  {
    v25 *= 8;
    int v19 = (void *)malloc_type_malloc();
    if (v19)
    {
      v15[0] = 0;
      v15[1] = v15;
      int v16 = 0;
      int v17 = 32;
      int v18 = v19;
      BOOL v14 = 0;
      applier = _NSConcreteStackBlock;
      int v5 = 1107296256;
      int v6 = 0;
      BOOL v7 = ___dispatch_transform_to_base32_with_table_block_invoke;
      unint64_t v8 = &__block_descriptor_tmp_1;
      char v9 = v21;
      dispatch_data_t v11 = v28;
      unint64_t v10 = v15;
      uint64_t v12 = v27;
      size_t v13 = size;
      BOOL v14 = dispatch_data_apply(v28, &applier);
      if (v14)
      {
        dispatch_data_t v29 = dispatch_data_create(v19, v25, 0, &__block_literal_global);
      }
      else
      {
        free(v19);
        dispatch_data_t v29 = 0;
      }
      int v20 = 1;
      _Block_object_dispose(v15, 8);
    }
    else
    {
      dispatch_data_t v29 = 0;
      int v20 = 1;
    }
  }
  else
  {
    dispatch_data_t v29 = 0;
    int v20 = 1;
  }
  _Block_object_dispose(v21, 8);
  return v29;
}

uint64_t ___dispatch_transform_to_base32_with_table_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v72 = a1;
  uint64_t v71 = a2;
  uint64_t v70 = a3;
  uint64_t v69 = a4;
  unint64_t v68 = a5;
  uint64_t v67 = a1;
  uint64_t v66 = a4;
  unint64_t v65 = 0;
  while (v65 < v68)
  {
    unsigned __int8 v64 = 0;
    unsigned __int8 v64 = *(unsigned char *)(v66 + v65);
    char v63 = 0;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL)
    {
      if (v65)
      {
        char v63 = *(unsigned char *)(v66 + v65 - 1);
      }
      else
      {
        int v62 = 0;
        dispatch_data_t v61 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v62, v70 - 1, 1uLL);
        if (!v61)
        {
          char v73 = 0;
          return v73 & 1;
        }
        char v63 = *v62;
        dispatch_release(v61);
      }
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL)
    {
      unint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL;
      char v5 = 1;
    }
    else
    {
      unint64_t v6 = 0;
      char v5 = 0;
    }
    if ((v5 & 1) == 0)
    {
      switch(v6)
      {
        case 0uLL:
          char v7 = *(unsigned char *)(*(void *)(a1 + 56) + (((int)v64 >> 3) & 0x1F));
          uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
          char v9 = *(unsigned char **)(v8 + 24);
          *(void *)(v8 + 24) = v9 + 1;
          unsigned char *v9 = v7;
          break;
        case 1uLL:
          char v10 = *(unsigned char *)(*(void *)(a1 + 56) + ((((int)v64 >> 6) | (4 * v63)) & 0x1F));
          uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v12 = *(unsigned char **)(v11 + 24);
          *(void *)(v11 + 24) = v12 + 1;
          *uint64_t v12 = v10;
          char v13 = *(unsigned char *)(*(void *)(a1 + 56) + (((int)v64 >> 1) & 0x1F));
          uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
          BOOL v15 = *(unsigned char **)(v14 + 24);
          *(void *)(v14 + 24) = v15 + 1;
          *BOOL v15 = v13;
          break;
        case 2uLL:
          char v16 = *(unsigned char *)(*(void *)(a1 + 56) + ((((int)v64 >> 4) | (16 * v63)) & 0x1F));
          uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8);
          int v18 = *(unsigned char **)(v17 + 24);
          *(void *)(v17 + 24) = v18 + 1;
          *int v18 = v16;
          break;
        case 3uLL:
          char v19 = *(unsigned char *)(*(void *)(a1 + 56) + ((((int)v64 >> 7) | (2 * v63)) & 0x1F));
          uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8);
          int v21 = *(unsigned char **)(v20 + 24);
          *(void *)(v20 + 24) = v21 + 1;
          *int v21 = v19;
          char v22 = *(unsigned char *)(*(void *)(a1 + 56) + (((int)v64 >> 2) & 0x1F));
          uint64_t v23 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v24 = *(unsigned char **)(v23 + 24);
          *(void *)(v23 + 24) = v24 + 1;
          *uint64_t v24 = v22;
          break;
        case 4uLL:
          char v25 = *(unsigned char *)(*(void *)(a1 + 56) + ((((int)v64 >> 5) | (8 * v63)) & 0x1F));
          uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v27 = *(unsigned char **)(v26 + 24);
          *(void *)(v26 + 24) = v27 + 1;
          *uint64_t v27 = v25;
          char v28 = *(unsigned char *)(*(void *)(a1 + 56) + (v64 & 0x1F));
          uint64_t v29 = *(void *)(*(void *)(a1 + 40) + 8);
          int v30 = *(unsigned char **)(v29 + 24);
          *(void *)(v29 + 24) = v30 + 1;
          *int v30 = v28;
          break;
        default:
          goto LABEL_41;
      }
    }
    ++v65;
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  if (v70 + v68 == *(void *)(a1 + 64))
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL)
    {
      unint64_t v32 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL;
      char v31 = 1;
    }
    else
    {
      unint64_t v32 = 0;
      char v31 = 0;
    }
    if ((v31 & 1) == 0)
    {
      switch(v32)
      {
        case 0uLL:
          break;
        case 1uLL:
          char v33 = *(unsigned char *)(*(void *)(a1 + 56) + ((4 * *(unsigned __int8 *)(v66 + v68 - 1)) & 0x1C));
          uint64_t v34 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v35 = *(unsigned char **)(v34 + 24);
          *(void *)(v34 + 24) = v35 + 1;
          *uint64_t v35 = v33;
          break;
        case 2uLL:
          char v36 = *(unsigned char *)(*(void *)(a1 + 56) + ((16 * *(unsigned __int8 *)(v66 + v68 - 1)) & 0x10));
          uint64_t v37 = *(void *)(*(void *)(a1 + 40) + 8);
          int v38 = *(unsigned char **)(v37 + 24);
          *(void *)(v37 + 24) = v38 + 1;
          *int v38 = v36;
          break;
        case 3uLL:
          char v39 = *(unsigned char *)(*(void *)(a1 + 56) + ((2 * *(unsigned __int8 *)(v66 + v68 - 1)) & 0x1E));
          uint64_t v40 = *(void *)(*(void *)(a1 + 40) + 8);
          BOOL v41 = *(unsigned char **)(v40 + 24);
          *(void *)(v40 + 24) = v41 + 1;
          unsigned char *v41 = v39;
          break;
        case 4uLL:
          char v42 = *(unsigned char *)(*(void *)(a1 + 56) + ((8 * *(unsigned __int8 *)(v66 + v68 - 1)) & 0x18));
          uint64_t v43 = *(void *)(*(void *)(a1 + 40) + 8);
          unint64_t v44 = *(unsigned char **)(v43 + 24);
          *(void *)(v43 + 24) = v44 + 1;
          unsigned char *v44 = v42;
          break;
        default:
LABEL_41:
          JUMPOUT(0);
      }
    }
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL)
    {
      unint64_t v46 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 5uLL;
      char v45 = 1;
    }
    else
    {
      unint64_t v46 = 0;
      char v45 = 0;
    }
    if ((v45 & 1) == 0)
    {
      switch(v46)
      {
        case 0uLL:
          break;
        case 1uLL:
          uint64_t v47 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v48 = *(unsigned char **)(v47 + 24);
          *(void *)(v47 + 24) = v48 + 1;
          *uint64_t v48 = 61;
          uint64_t v49 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v50 = *(unsigned char **)(v49 + 24);
          *(void *)(v49 + 24) = v50 + 1;
          *uint64_t v50 = 61;
          goto LABEL_36;
        case 2uLL:
LABEL_36:
          uint64_t v51 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v52 = *(unsigned char **)(v51 + 24);
          *(void *)(v51 + 24) = v52 + 1;
          *uint64_t v52 = 61;
          goto LABEL_37;
        case 3uLL:
LABEL_37:
          uint64_t v53 = *(void *)(*(void *)(a1 + 40) + 8);
          uint64_t v54 = *(unsigned char **)(v53 + 24);
          *(void *)(v53 + 24) = v54 + 1;
          *uint64_t v54 = 61;
          uint64_t v55 = *(void *)(*(void *)(a1 + 40) + 8);
          int v56 = *(unsigned char **)(v55 + 24);
          *(void *)(v55 + 24) = v56 + 1;
          *int v56 = 61;
          goto LABEL_38;
        case 4uLL:
LABEL_38:
          uint64_t v57 = *(void *)(*(void *)(a1 + 40) + 8);
          int v58 = *(unsigned char **)(v57 + 24);
          *(void *)(v57 + 24) = v58 + 1;
          *int v58 = 61;
          break;
        default:
          goto LABEL_41;
      }
    }
  }
  char v73 = 1;
  return v73 & 1;
}

uint64_t ___dispatch_transform_from_base64_block_invoke(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v14 = (unsigned char *)malloc_type_malloc();
  char v13 = v14;
  if (v14)
  {
    for (unint64_t i = 0; i < a5; ++i)
    {
      if (*(unsigned char *)(a4 + i) != 10 && *(unsigned char *)(a4 + i) != 9 && *(unsigned char *)(a4 + i) != 32)
      {
        unint64_t v12 = *(unsigned __int8 *)(a4 + i);
        if (v12 >= 0x7B || base64_decode_table[v12] == -1)
        {
          free(v14);
          char v18 = 0;
          return v18 & 1;
        }
        ++*(void *)(*(void *)(a1[4] + 8) + 24);
        char v11 = base64_decode_table[v12];
        if (v11 == -2)
        {
          char v11 = 0;
          ++*(void *)(*(void *)(a1[5] + 8) + 24);
        }
        *(void *)(*(void *)(a1[6] + 8) + 24) <<= 6;
        *(void *)(*(void *)(a1[6] + 8) + 24) += v11;
        if ((*(void *)(*(void *)(a1[4] + 8) + 24) & 3) == 0)
        {
          unsigned char *v13 = BYTE2(*(void *)(*(void *)(a1[6] + 8) + 24));
          v13[1] = BYTE1(*(void *)(*(void *)(a1[6] + 8) + 24));
          char v5 = v13 + 2;
          v13 += 3;
          *char v5 = *(unsigned char *)(*(void *)(a1[6] + 8) + 24);
        }
      }
    }
    size_t size = v13 - v14;
    if (*(void *)(*(void *)(a1[5] + 8) + 24)) {
      size -= *(void *)(*(void *)(a1[5] + 8) + 24);
    }
    data2 = dispatch_data_create(v14, size, 0, &__block_literal_global);
    dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(void *)(a1[7] + 8) + 24), data2);
    dispatch_release(data2);
    dispatch_release(*(dispatch_object_t *)(*(void *)(a1[7] + 8) + 24));
    *(void *)(*(void *)(a1[7] + 8) + 24) = concat;
    char v18 = 1;
  }
  else
  {
    char v18 = 0;
  }
  return v18 & 1;
}

uint64_t ___dispatch_transform_to_base64_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v44 = a1;
  uint64_t v43 = a2;
  uint64_t v42 = a3;
  uint64_t v41 = a4;
  unint64_t v40 = a5;
  uint64_t v39 = a1;
  uint64_t v38 = a4;
  unint64_t v37 = 0;
  while (v37 < v40)
  {
    unsigned __int8 v36 = 0;
    unsigned __int8 v36 = *(unsigned char *)(v38 + v37);
    char v35 = 0;
    if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 3uLL)
    {
      if (v37)
      {
        char v35 = *(unsigned char *)(v38 + v37 - 1);
      }
      else
      {
        uint64_t v34 = 0;
        dispatch_data_t v33 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v34, v42 - 1, 1uLL);
        if (!v33)
        {
          char v45 = 0;
          return v45 & 1;
        }
        char v35 = *v34;
        dispatch_release(v33);
      }
    }
    unint64_t v31 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 3uLL;
    if (v31)
    {
      if (v31 == 1)
      {
        char v8 = base64_encode_table[(((int)v36 >> 4) | (16 * v35)) & 0x3F];
        uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
        char v10 = *(char **)(v9 + 24);
        *(void *)(v9 + 24) = v10 + 1;
        char *v10 = v8;
      }
      else if (v31 == 2)
      {
        char v11 = base64_encode_table[(((int)v36 >> 6) | (4 * v35)) & 0x3F];
        uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
        char v13 = *(char **)(v12 + 24);
        *(void *)(v12 + 24) = v13 + 1;
        char *v13 = v11;
        char v14 = base64_encode_table[v36 & 0x3F];
        uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8);
        char v16 = *(char **)(v15 + 24);
        *(void *)(v15 + 24) = v16 + 1;
        *char v16 = v14;
      }
    }
    else
    {
      char v5 = base64_encode_table[((int)v36 >> 2) & 0x3F];
      uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
      char v7 = *(char **)(v6 + 24);
      *(void *)(v6 + 24) = v7 + 1;
      *char v7 = v5;
    }
    ++v37;
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  if (v42 + v40 == *(void *)(a1 + 56))
  {
    unint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) % 3uLL;
    if (v30)
    {
      if (v30 == 1)
      {
        char v17 = base64_encode_table[(16 * *(unsigned __int8 *)(v38 + v40 - 1)) & 0x30];
        uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8);
        char v19 = *(char **)(v18 + 24);
        *(void *)(v18 + 24) = v19 + 1;
        *char v19 = v17;
        uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8);
        int v21 = *(unsigned char **)(v20 + 24);
        *(void *)(v20 + 24) = v21 + 1;
        *int v21 = 61;
        uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8);
        uint64_t v23 = *(unsigned char **)(v22 + 24);
        *(void *)(v22 + 24) = v23 + 1;
        *uint64_t v23 = 61;
      }
      else if (v30 == 2)
      {
        char v24 = base64_encode_table[(4 * *(unsigned __int8 *)(v38 + v40 - 1)) & 0x3C];
        uint64_t v25 = *(void *)(*(void *)(a1 + 40) + 8);
        uint64_t v26 = *(char **)(v25 + 24);
        *(void *)(v25 + 24) = v26 + 1;
        *uint64_t v26 = v24;
        uint64_t v27 = *(void *)(*(void *)(a1 + 40) + 8);
        char v28 = *(unsigned char **)(v27 + 24);
        *(void *)(v27 + 24) = v28 + 1;
        *char v28 = 61;
      }
    }
  }
  char v45 = 1;
  return v45 & 1;
}

uint64_t _dispatch_transform_from_utf16(dispatch_data_s *a1, int a2)
{
  char v24 = a1;
  int v23 = a2;
  v19[0] = 0;
  v19[1] = v19;
  int v20 = 0;
  int v21 = 32;
  uint64_t v22 = 0;
  uint64_t v13 = 0;
  char v14 = &v13;
  int v15 = 0;
  int v16 = 56;
  long long v17 = off_D86E0;
  long long v18 = xmmword_D86F0;
  BOOL v12 = 0;
  applier = _NSConcreteStackBlock;
  int v4 = 1107296256;
  int v5 = 0;
  uint64_t v6 = ___dispatch_transform_from_utf16_block_invoke;
  char v7 = &__block_descriptor_tmp_10;
  char v8 = &v13;
  uint64_t v9 = v19;
  char v10 = a1;
  int v11 = a2;
  BOOL v12 = dispatch_data_apply(a1, &applier);
  if (v12)
  {
    uint64_t v25 = v14[3];
  }
  else
  {
    _dispatch_transform_buffer_new((uint64_t)(v14 + 3), 0, 0);
    dispatch_release((dispatch_object_t)v14[3]);
    uint64_t v25 = 0;
  }
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(v19, 8);
  return v25;
}

uint64_t ___dispatch_transform_from_utf16_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v51 = a1;
  uint64_t v50 = a2;
  uint64_t v49 = a3;
  uint64_t v48 = a4;
  unint64_t v47 = a5;
  uint64_t v46 = a1;
  uint64_t v45 = a4;
  if (a3
    || ((v44 = 0, v47 % 3) ? (unint64_t v33 = v47 / 3 + 1) : (unint64_t v33 = v47 / 3),
        uint64_t v44 = 2 * v33,
        (_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 2 * v33, 0) & 1) != 0))
  {
    unint64_t i = 0;
    unint64_t v42 = v47 / 2;
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) < v47)
    {
      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
      {
        v45 += *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        v47 -= *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        unint64_t v42 = v47 / 2;
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
      }
      if (v47 % 2) {
        ++v42;
      }
      for (unint64_t i = 0; i < v42; ++i)
      {
        unsigned int v41 = 0;
        unsigned __int16 v40 = 0;
        uint64_t v39 = 0;
        if (i == v42 - 1 && v42 > v47 / 2)
        {
          uint64_t v38 = 0;
          dispatch_data_t v37 = 0;
          dispatch_data_t v37 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v38, v49 + 2 * i, 2uLL);
          if (!v37)
          {
            char v52 = 0;
            return v52 & 1;
          }
          unsigned __int16 v40 = _dispatch_transform_swap_to_host(*v38, *(_DWORD *)(a1 + 56));
          v36[1] = v37;
          dispatch_release(v37);
          ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        }
        else
        {
          unsigned __int16 v40 = _dispatch_transform_swap_to_host(*(_WORD *)(v45 + 2 * i), *(_DWORD *)(a1 + 56));
        }
        if (v40 == 65534 && !v49 && !i)
        {
          char v52 = 0;
          return v52 & 1;
        }
        if (v40 != 65279 || v49 || i)
        {
          if (v40 < 0xD800u || v40 > 0xDBFFu)
          {
            if (v40 >= 0xDC00u && v40 < 0xE000u)
            {
              char v52 = 0;
              return v52 & 1;
            }
            unsigned int v41 = v40;
          }
          else
          {
            unsigned int v41 = (v40 - 55296) << 10;
            if (++i < v42)
            {
              unsigned __int16 v40 = _dispatch_transform_swap_to_host(*(_WORD *)(v45 + 2 * i), *(_DWORD *)(a1 + 56));
            }
            else
            {
              v36[0] = 0;
              dispatch_data_t v35 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), v36, v49 + 2 * i, 2uLL);
              if (!v35)
              {
                char v52 = 0;
                return v52 & 1;
              }
              unsigned __int16 v40 = _dispatch_transform_swap_to_host(*(_WORD *)v36[0], *(_DWORD *)(a1 + 56));
              dispatch_release(v35);
              *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += 2;
            }
            if (v40 < 0xDC00u || v40 >= 0xE000u)
            {
              char v52 = 0;
              return v52 & 1;
            }
            v41 |= v40 & 0x3FF;
            v41 += 0x10000;
          }
          uint64_t v39 = 2 * (v42 - i);
          BOOL v53 = (2 * (unsigned __int128)(v42 - i)) >> 64 != 0;
          if (!is_mul_ok(2uLL, v42 - i))
          {
            char v52 = 0;
            return v52 & 1;
          }
          if (v41 >= 0x80)
          {
            if (v41 >= 0x800)
            {
              if (v41 >= 0x10000)
              {
                if (v41 < 0x200000)
                {
                  if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 4uLL, v39) & 1) == 0)
                  {
                    char v52 = 0;
                    return v52 & 1;
                  }
                  char v22 = (v41 >> 18) | 0xF0;
                  uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 8);
                  char v24 = *(unsigned char **)(v23 + 40);
                  *(void *)(v23 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v24 + 1;
                  *char v24 = v22;
                  LOBYTE(v24) = (v41 >> 12) & 0x3F | 0x80;
                  uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 8);
                  uint64_t v26 = *(unsigned char **)(v25 + 40);
                  *(void *)(v25 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v26 + 1;
                  *uint64_t v26 = (_BYTE)v24;
                  LOBYTE(v24) = (v41 >> 6) & 0x3F | 0x80;
                  uint64_t v27 = *(void *)(*(void *)(a1 + 32) + 8);
                  char v28 = *(unsigned char **)(v27 + 40);
                  *(void *)(v27 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v28 + 1;
                  *char v28 = (_BYTE)v24;
                  char v29 = v41 & 0x3F | 0x80;
                  uint64_t v30 = *(void *)(*(void *)(a1 + 32) + 8);
                  unint64_t v31 = *(unsigned char **)(v30 + 40);
                  *(void *)(v30 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v31 + 1;
                  *unint64_t v31 = v29;
                }
              }
              else
              {
                if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 3uLL, v39) & 1) == 0)
                {
                  char v52 = 0;
                  return v52 & 1;
                }
                char v14 = (v41 >> 12) | 0xE0;
                uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
                int v16 = *(unsigned char **)(v15 + 40);
                *(void *)(v15 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v16 + 1;
                *int v16 = v14;
                LOBYTE(v16) = (v41 >> 6) & 0x3F | 0x80;
                uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 8);
                long long v18 = *(unsigned char **)(v17 + 40);
                *(void *)(v17 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v18 + 1;
                *long long v18 = (_BYTE)v16;
                char v19 = v41 & 0x3F | 0x80;
                uint64_t v20 = *(void *)(*(void *)(a1 + 32) + 8);
                int v21 = *(unsigned char **)(v20 + 40);
                *(void *)(v20 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v21 + 1;
                *int v21 = v19;
              }
            }
            else
            {
              if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 2uLL, v39) & 1) == 0)
              {
                char v52 = 0;
                return v52 & 1;
              }
              char v8 = (v41 >> 6) | 0xC0;
              uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
              char v10 = *(unsigned char **)(v9 + 40);
              *(void *)(v9 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v10 + 1;
              unsigned char *v10 = v8;
              char v11 = v41 & 0x3F | 0x80;
              uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
              uint64_t v13 = *(unsigned char **)(v12 + 40);
              *(void *)(v12 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v13 + 1;
              unsigned char *v13 = v11;
            }
          }
          else
          {
            if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 1uLL, v39) & 1) == 0)
            {
              char v52 = 0;
              return v52 & 1;
            }
            char v5 = v41;
            uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
            char v7 = *(unsigned char **)(v6 + 40);
            *(void *)(v6 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v7 + 1;
            *char v7 = v5;
          }
        }
      }
      _dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 0, 0);
      char v52 = 1;
    }
    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) -= v47;
      char v52 = 1;
    }
  }
  else
  {
    char v52 = 0;
  }
  return v52 & 1;
}

uint64_t _dispatch_transform_buffer_new(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 && *(void *)(a1 + 24) - (*(void *)(a1 + 16) - *(void *)(a1 + 8)) >= a2) {
    goto LABEL_13;
  }
  if (*(void *)(a1 + 8))
  {
    if (*(void *)(a1 + 16) <= *(void *)(a1 + 8))
    {
      free(*(void **)(a1 + 8));
    }
    else
    {
      data2 = dispatch_data_create(*(const void **)(a1 + 8), *(void *)(a1 + 16) - *(void *)(a1 + 8), 0, &__block_literal_global);
      dispatch_data_t concat = dispatch_data_create_concat(*(dispatch_data_t *)a1, data2);
      dispatch_release(data2);
      dispatch_release(*(dispatch_object_t *)a1);
      *(void *)a1 = concat;
    }
  }
  *(void *)(a1 + 24) = a2 + a3;
  *(void *)(a1 + 8) = 0;
  if (!*(void *)(a1 + 24))
  {
LABEL_12:
    *(void *)(a1 + 16) = *(void *)(a1 + 8);
LABEL_13:
    char v9 = 1;
    return v9 & 1;
  }
  if (*(void *)(a1 + 24) <= 0x6400000uLL)
  {
    *(void *)(a1 + 8) = malloc_type_malloc();
    if (!*(void *)(a1 + 8))
    {
      char v9 = 0;
      return v9 & 1;
    }
    goto LABEL_12;
  }
  char v9 = 0;
  return v9 & 1;
}

uint64_t _dispatch_transform_swap_to_host(unsigned __int16 a1, int a2)
{
  if (a2 == 1) {
    return a1;
  }
  else {
    return (unsigned __int16)_OSSwapInt16(a1);
  }
}

uint64_t _OSSwapInt16(unsigned __int16 a1)
{
  return (unsigned __int16)(((int)a1 >> 8) | (a1 << 8));
}

uint64_t _dispatch_transform_to_utf16(dispatch_data_s *a1, int a2)
{
  char v24 = a1;
  int v23 = a2;
  v19[0] = 0;
  v19[1] = v19;
  int v20 = 0;
  int v21 = 32;
  uint64_t v22 = 0;
  uint64_t v13 = 0;
  char v14 = &v13;
  int v15 = 0;
  int v16 = 56;
  long long v17 = off_D8700;
  long long v18 = xmmword_D8710;
  BOOL v12 = 0;
  applier = _NSConcreteStackBlock;
  int v4 = 1107296256;
  int v5 = 0;
  uint64_t v6 = ___dispatch_transform_to_utf16_block_invoke;
  char v7 = &__block_descriptor_tmp_13_0;
  char v8 = &v13;
  int v11 = a2;
  char v9 = v19;
  char v10 = a1;
  BOOL v12 = dispatch_data_apply(a1, &applier);
  if (v12)
  {
    uint64_t v25 = v14[3];
  }
  else
  {
    _dispatch_transform_buffer_new((uint64_t)(v14 + 3), 0, 0);
    dispatch_release((dispatch_object_t)v14[3]);
    uint64_t v25 = 0;
  }
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(v19, 8);
  return v25;
}

uint64_t ___dispatch_transform_to_utf16_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  uint64_t v34 = a3;
  unint64_t v33 = a4;
  unint64_t v32 = a5;
  uint64_t v31 = a1;
  uint64_t v30 = a4;
  unint64_t v29 = 0;
  unint64_t v28 = 0;
  if (!a3)
  {
    uint64_t v27 = 2 * v32;
    BOOL v41 = (v32 * (unsigned __int128)2uLL) >> 64 != 0;
    BOOL v26 = v41;
    unint64_t v28 = 2 * v32 + 2;
    BOOL v40 = 2 * v32 >= 0xFFFFFFFFFFFFFFFELL;
    BOOL v25 = v40;
    int v24 = v41 || v40;
    BOOL v39 = v24 != 0;
    if (v24)
    {
      char v37 = 0;
      return v37 & 1;
    }
    if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, v28, 0) & 1) == 0)
    {
      char v37 = 0;
      return v37 & 1;
    }
    __int16 v5 = _dispatch_transform_swap_to_host(0xFEFFu, *(_DWORD *)(a1 + 56));
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    char v7 = *(_WORD **)(v6 + 40);
    *(void *)(v6 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v7 + 1;
    *char v7 = v5;
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) < v32)
  {
    if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      v30 += *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      v32 -= *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    }
    unint64_t v29 = 0;
    while (v29 < v32)
    {
      unsigned int utf8_sequence = 0;
      unsigned __int8 v22 = 0;
      unsigned __int8 v22 = _dispatch_transform_utf8_length(*v30);
      uint64_t v21 = 0;
      if (!v22)
      {
        char v37 = 0;
        return v37 & 1;
      }
      if (v22 + v29 <= v32)
      {
        unsigned int utf8_sequence = _dispatch_transform_read_utf8_sequence(v30);
        v30 += v22;
        v29 += v22;
      }
      else
      {
        int v20 = 0;
        dispatch_data_t v19 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v20, v34 + v29, v22);
        if (!v19)
        {
          char v37 = 0;
          return v37 & 1;
        }
        unsigned int utf8_sequence = _dispatch_transform_read_utf8_sequence(v20);
        *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v22 - (v32 - v29);
        v30 += v22;
        unint64_t v29 = v32;
        dispatch_release(v19);
      }
      uint64_t v21 = 2 * (v32 - v29);
      BOOL v38 = ((v32 - v29) * (unsigned __int128)2uLL) >> 64 != 0;
      if (!is_mul_ok(v32 - v29, 2uLL))
      {
        char v37 = 0;
        return v37 & 1;
      }
      if (utf8_sequence != 65279 || v34 + v29 != 3)
      {
        if (utf8_sequence >= 0xD800 && utf8_sequence < 0xDFFF)
        {
          char v37 = 0;
          return v37 & 1;
        }
        if (utf8_sequence < 0x10000)
        {
          if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 2uLL, v21) & 1) == 0)
          {
            char v37 = 0;
            return v37 & 1;
          }
          __int16 v14 = _dispatch_transform_swap_to_host(utf8_sequence, *(_DWORD *)(a1 + 56));
          uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 8);
          int v16 = *(_WORD **)(v15 + 40);
          *(void *)(v15 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v16 + 1;
          *int v16 = v14;
        }
        else
        {
          if ((_dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 4uLL, v21) & 1) == 0)
          {
            char v37 = 0;
            return v37 & 1;
          }
          utf8_sequence -= 0x10000;
          __int16 v8 = _dispatch_transform_swap_to_host(((utf8_sequence >> 10) & 0x3FF) - 10240, *(_DWORD *)(a1 + 56));
          uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
          char v10 = *(_WORD **)(v9 + 40);
          *(void *)(v9 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v10 + 1;
          _WORD *v10 = v8;
          __int16 v11 = _dispatch_transform_swap_to_host((utf8_sequence & 0x3FF) - 9216, *(_DWORD *)(a1 + 56));
          uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
          uint64_t v13 = *(_WORD **)(v12 + 40);
          *(void *)(v12 + 4pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = v13 + 1;
          _WORD *v13 = v11;
        }
      }
    }
    _dispatch_transform_buffer_new(*(void *)(*(void *)(a1 + 32) + 8) + 24, 0, 0);
    char v37 = 1;
  }
  else
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) -= v32;
    char v37 = 1;
  }
  return v37 & 1;
}

uint64_t _dispatch_transform_utf8_length(char a1)
{
  if (a1 < 0)
  {
    if ((a1 & 0xE0) == 0xC0)
    {
      return 2;
    }
    else if ((a1 & 0xF0) == 0xE0)
    {
      return 3;
    }
    else if ((a1 & 0xF8) == 0xF0)
    {
      return 4;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
}

uint64_t _dispatch_transform_read_utf8_sequence(char *a1)
{
  v4[4] = 0;
  *(_DWORD *)int v4 = _dispatch_transform_utf8_length(*a1);
  if (v4[0] <= 1u)
  {
    uint64_t v2 = v4[0] - 1;
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = v4[0] - 1;
    char v1 = 1;
  }
  if ((v1 & 1) == 0)
  {
    switch(v2)
    {
      case 0:
        *(_DWORD *)&v4[1] = *a1 & 0x7F;
        break;
      case 1:
        *(_DWORD *)&v4[1] = (*(_DWORD *)&v4[1] | *a1 & 0x1F) << 6;
        break;
      case 2:
        *(_DWORD *)&v4[1] = (*(_DWORD *)&v4[1] | *a1 & 0xF) << 6;
        break;
      case 3:
        *(_DWORD *)&v4[1] = (*(_DWORD *)&v4[1] | *a1 & 7) << 6;
        break;
      default:
        JUMPOUT(0);
    }
  }
  uint64_t v6 = a1 + 1;
  --v4[0];
  while (v4[0])
  {
    *(_DWORD *)&v4[1] |= *v6++ & 0x3F;
    if (--v4[0]) {
      *(_DWORD *)&v4[1] <<= 6;
    }
  }
  return *(unsigned int *)&v4[1];
}

void _dispatch_time_init()
{
  kern_return_t v8;
  mach_timebase_info info;
  uint64_t v10;
  uint64_t v11;

  info = 0;
  __int16 v8 = mach_timebase_info(&info);
  __int16 v11 = v8;
  char v10 = 86;
  if (v8) {
    _dispatch_bug(v10, v11, v0, v1, v2, v3, v4, v5);
  }
  BOOL v7 = 0;
  if (info.numer == 125) {
    BOOL v7 = info.denom == 3;
  }
  if (!v7) {
    _dispatch_host_time_init(&info, v6);
  }
}

_DWORD *_dispatch_host_time_init(_DWORD *result, double a2)
{
  LODWORD(a2) = *result;
  *(double *)&unint64_t v2 = (double)*(unint64_t *)&a2;
  _dispatch_host_time_int data = v2;
  LODWORD(v2) = result[1];
  *(double *)&_dispatch_host_time_int data = *(double *)&_dispatch_host_time_data / (double)v2;
  byte_F4C30 = *result == result[1];
  _dispatch_host_time_mach2nano = (uint64_t (*)(void))_dispatch_mach_host_time_mach2nano;
  _dispatch_host_time_nano2mach = (uint64_t (*)(void))_dispatch_mach_host_time_nano2mach;
  return result;
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  dispatch_time_t v8 = when;
  int64_t v7 = delta;
  unint64_t v6 = 0;
  if (when == -1) {
    return -1;
  }
  int v5 = 0;
  uint64_t v4 = 0;
  uint64_t v14 = v8;
  char v13 = 1;
  uint64_t v12 = &v5;
  __int16 v11 = &v4;
  unint64_t v10 = 0;
  if (v8 == 0x8000000000000000)
  {
    *uint64_t v12 = 1;
    uint64_t *v11 = _dispatch_monotonic_time();
  }
  else if (v8 == -2)
  {
    *uint64_t v12 = 2;
    uint64_t *v11 = _dispatch_get_nanoseconds();
  }
  else if (v8)
  {
    if (v14 >= 0)
    {
      *uint64_t v12 = 0;
      unint64_t v10 = v14;
    }
    else if ((v14 & 0x4000000000000000) != 0)
    {
      *uint64_t v12 = 2;
      unint64_t v10 = -v14;
    }
    else
    {
      *uint64_t v12 = 1;
      unint64_t v10 = v14 & 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v10 <= 0x3FFFFFFFFFFFFFFFLL) {
      uint64_t v3 = v10;
    }
    else {
      uint64_t v3 = -1;
    }
    uint64_t *v11 = v3;
  }
  else
  {
    *uint64_t v12 = 0;
    uint64_t *v11 = _dispatch_uptime();
  }
  if (v4 == -1) {
    return -1;
  }
  if (v5 == 2)
  {
    unint64_t v6 = v7;
    if (v7 < 0)
    {
      v4 += v6;
      if (v4 < 1) {
        uint64_t v4 = 2;
      }
    }
    else
    {
      v4 += v6;
      if (v4 <= 0) {
        return -1;
      }
    }
    int v25 = 2;
    uint64_t v24 = v4;
    if ((unint64_t)v4 < 0x3FFFFFFFFFFFFFFFLL) {
      return -v24;
    }
    else {
      return -1;
    }
  }
  else if (v7 < 0)
  {
    unint64_t v27 = -v7;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v28 = _dispatch_host_time_nano2mach(v27);
    }
    else if (v27)
    {
      if (v27 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v27 < 0x5555555555555555) {
          unint64_t v28 = 3 * v27 / 0x7D;
        }
        else {
          unint64_t v28 = 3 * (v27 / 0x7D);
        }
      }
      else
      {
        unint64_t v28 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v28 = 0;
    }
    unint64_t v6 = v28;
    v4 -= v28;
    if (v4 >= 1)
    {
      int v16 = v5;
      dispatch_time_t v15 = v4;
      if ((unint64_t)v4 >= 0x3FFFFFFFFFFFFFFFLL) {
        return -1;
      }
      if (!v16) {
        return v15;
      }
      if (v16 == 1) {
        return v15 | 0x8000000000000000;
      }
      return -(uint64_t)v15;
    }
    else
    {
      int v19 = v5;
      dispatch_time_t v18 = 1;
      if (!v5) {
        return v18;
      }
      if (v19 == 1) {
        return v18 | 0x8000000000000000;
      }
      return -(uint64_t)v18;
    }
  }
  else
  {
    unint64_t v29 = v7;
    if (_dispatch_host_time_nano2mach)
    {
      unint64_t v30 = _dispatch_host_time_nano2mach(v29);
    }
    else if (v29)
    {
      if (v29 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v29 < 0x5555555555555555) {
          unint64_t v30 = 3 * v29 / 0x7D;
        }
        else {
          unint64_t v30 = 3 * (v29 / 0x7D);
        }
      }
      else
      {
        unint64_t v30 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v30 = 0;
    }
    unint64_t v6 = v30;
    v4 += v30;
    if (v4 > 0)
    {
      int v22 = v5;
      dispatch_time_t v21 = v4;
      if ((unint64_t)v4 >= 0x3FFFFFFFFFFFFFFFLL) {
        return -1;
      }
      if (!v22) {
        return v21;
      }
      if (v22 == 1) {
        return v21 | 0x8000000000000000;
      }
      return -(uint64_t)v21;
    }
    else
    {
      return -1;
    }
  }
}

uint64_t dispatch_time_to_nsecs(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v9 = a1;
  dispatch_time_t v8 = a2;
  int64_t v7 = a3;
  int v6 = 0;
  unint64_t v5 = 0;
  if (a1 == -1) {
    goto LABEL_41;
  }
  uint64_t v15 = v9;
  char v14 = 1;
  char v13 = &v6;
  uint64_t v12 = &v5;
  unint64_t v11 = 0;
  if (v9 == 0x8000000000000000)
  {
    int *v13 = 1;
    *uint64_t v12 = _dispatch_monotonic_time();
  }
  else if (v9 == -2)
  {
    int *v13 = 2;
    *uint64_t v12 = _dispatch_get_nanoseconds();
  }
  else if (v9)
  {
    if (v15 >= 0)
    {
      int *v13 = 0;
      unint64_t v11 = v15;
    }
    else if ((v15 & 0x4000000000000000) != 0)
    {
      int *v13 = 2;
      unint64_t v11 = -v15;
    }
    else
    {
      int *v13 = 1;
      unint64_t v11 = v15 & 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v11 <= 0x3FFFFFFFFFFFFFFFLL) {
      uint64_t v4 = v11;
    }
    else {
      uint64_t v4 = -1;
    }
    *uint64_t v12 = v4;
  }
  else
  {
    int *v13 = 0;
    *uint64_t v12 = _dispatch_uptime();
  }
  if (v6)
  {
    if (v6 != 1)
    {
      if (v6 == 2)
      {
        *dispatch_time_t v8 = 3;
        *int64_t v7 = v5;
        char v10 = 1;
        return v10 & 1;
      }
LABEL_41:
      *dispatch_time_t v8 = 0;
      *int64_t v7 = -1;
      char v10 = 0;
      return v10 & 1;
    }
    *dispatch_time_t v8 = 2;
    unint64_t v16 = v5;
    if (_dispatch_host_time_mach2nano)
    {
      unint64_t v17 = _dispatch_host_time_mach2nano(v16);
    }
    else if (v16)
    {
      if (v16 < 0x3126E978D4FDF3ALL)
      {
        if (v16 < 0x20C49BA5E353F7CLL) {
          unint64_t v17 = 125 * v16 / 3;
        }
        else {
          unint64_t v17 = 125 * (v16 / 3);
        }
      }
      else
      {
        unint64_t v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v17 = 0;
    }
    *int64_t v7 = v17;
    char v10 = 1;
  }
  else
  {
    *dispatch_time_t v8 = 1;
    unint64_t v18 = v5;
    if (_dispatch_host_time_mach2nano)
    {
      unint64_t v19 = _dispatch_host_time_mach2nano(v18);
    }
    else if (v18)
    {
      if (v18 < 0x3126E978D4FDF3ALL)
      {
        if (v18 < 0x20C49BA5E353F7CLL) {
          unint64_t v19 = 125 * v18 / 3;
        }
        else {
          unint64_t v19 = 125 * (v18 / 3);
        }
      }
      else
      {
        unint64_t v19 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      unint64_t v19 = 0;
    }
    *int64_t v7 = v19;
    char v10 = 1;
  }
  return v10 & 1;
}

unint64_t dispatch_time_from_nsec(uint64_t a1, unint64_t a2)
{
  unint64_t v3 = a2;
  if (a2 < 2) {
    unint64_t v3 = 2;
  }
  if (_dispatch_host_time_nano2mach)
  {
    unint64_t v9 = _dispatch_host_time_nano2mach(v3);
  }
  else if (v3)
  {
    if (v3 < 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v3 < 0x5555555555555555) {
        unint64_t v9 = 3 * v3 / 0x7D;
      }
      else {
        unint64_t v9 = 3 * (v3 / 0x7D);
      }
    }
    else
    {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  else
  {
    unint64_t v9 = 0;
  }
  switch(a1)
  {
    case 1:
      if (v9 < 0x3FFFFFFFFFFFFFFFLL) {
        return v9;
      }
      else {
        return -1;
      }
    case 2:
      if (v9 < 0x3FFFFFFFFFFFFFFFLL) {
        return v9 | 0x8000000000000000;
      }
      else {
        return -1;
      }
    case 3:
      if (v3 < 0x3FFFFFFFFFFFFFFFLL) {
        return -(uint64_t)v3;
      }
      else {
        return -1;
      }
  }
  return v5;
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  if (when) {
    __uint64_t nanoseconds = 1000000000 * when->tv_sec + when->tv_nsec;
  }
  else {
    __uint64_t nanoseconds = _dispatch_get_nanoseconds();
  }
  uint64_t v5 = nanoseconds + delta;
  if (v5 > 1) {
    return -v5;
  }
  dispatch_time_t v2 = -2;
  if (delta >= 0) {
    return -1;
  }
  return v2;
}

unint64_t _dispatch_timeout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v15 = a1;
  __uint64_t nanoseconds = 0;
  switch(a1)
  {
    case -9223372036854775808:
    case -2:
      return 0;
    case -1:
      return -1;
    case 0:
      return 0;
  }
  int v13 = 0;
  __uint64_t v12 = 0;
  unint64_t v21 = v15;
  char v20 = 0;
  unint64_t v19 = &v13;
  unint64_t v18 = (uint64_t *)&v12;
  unint64_t v17 = 0;
  if (v15 >= 0)
  {
    *unint64_t v19 = 0;
    unint64_t v17 = v21;
  }
  else if ((v21 & 0x4000000000000000) != 0)
  {
    *unint64_t v19 = 2;
    unint64_t v17 = -(uint64_t)v21;
  }
  else
  {
    *unint64_t v19 = 1;
    unint64_t v17 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v17 <= 0x3FFFFFFFFFFFFFFFLL) {
    uint64_t v11 = v17;
  }
  else {
    uint64_t v11 = -1;
  }
  *unint64_t v18 = v11;
  if (v13 == 2)
  {
    __uint64_t nanoseconds = _dispatch_get_nanoseconds();
    if (nanoseconds < v12) {
      return v12 - nanoseconds;
    }
    else {
      return 0;
    }
  }
  else
  {
    if (v13)
    {
      BOOL v25 = v13 == 1;
      uint64_t v24 = 241;
      if (v13 != 1) {
        _dispatch_abort(v24, v25, a3, a4, a5, a6, a7, a8);
      }
      __uint64_t nanoseconds = _dispatch_monotonic_time();
    }
    else
    {
      __uint64_t nanoseconds = _dispatch_uptime();
    }
    if (nanoseconds >= v12) {
      return 0;
    }
    unint64_t v22 = v12 - nanoseconds;
    if (_dispatch_host_time_mach2nano) {
      return _dispatch_host_time_mach2nano(v22);
    }
    if (!v22) {
      return 0;
    }
    if (v22 >= 0x3126E978D4FDF3ALL) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v22 < 0x20C49BA5E353F7CLL) {
      return 125 * v22 / 3;
    }
    return 125 * (v22 / 3);
  }
}

unint64_t _dispatch_mach_host_time_mach2nano(unint64_t a1)
{
  char v2 = 1;
  if (a1) {
    char v2 = byte_F4C30;
  }
  if (v2) {
    return a1;
  }
  if (a1 >= 0x7FFFFFFFFFFFFFFFLL) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((double)a1 * *(double *)&_dispatch_host_time_data + 0.5 < 9.22337204e18) {
    return (unint64_t)((double)a1 * *(double *)&_dispatch_host_time_data + 0.5);
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

unint64_t _dispatch_mach_host_time_nano2mach(unint64_t a1)
{
  char v2 = 1;
  if (a1) {
    char v2 = byte_F4C30;
  }
  if (v2) {
    return a1;
  }
  if (a1 >= 0x7FFFFFFFFFFFFFFFLL) {
    return 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((double)a1 / *(double *)&_dispatch_host_time_data + 0.5 < 9.22337204e18) {
    return (unint64_t)((double)a1 / *(double *)&_dispatch_host_time_data + 0.5);
  }
  return 0x7FFFFFFFFFFFFFFFLL;
}

unint64_t _dispatch_continuation_alloc_from_heap()
{
  if (_dispatch_use_dispatch_alloc) {
    return _dispatch_alloc_continuation_alloc();
  }
  else {
    return _dispatch_malloc_continuation_alloc();
  }
}

void _dispatch_continuation_alloc_once()
{
  if (_dispatch_continuation_alloc_init_pred != -1) {
    dispatch_once_f(&_dispatch_continuation_alloc_init_pred, 0, (dispatch_function_t)_dispatch_continuation_alloc_init);
  }
}

unint64_t _dispatch_alloc_continuation_alloc()
{
  unint64_t v12 = 0;
  if (!_dispatch_main_heap) {
    return _dispatch_alloc_continuation_from_heap_slow();
  }
  uint64_t v11 = 0;
  uint64_t v17 = _dispatch_main_heap;
  uint64_t v16 = 59;
  unsigned int v14 = _dispatch_cpu_number();
  uint64_t v11 = *(void *)(_dispatch_main_heap + ((unint64_t)v14 << 20) + 8);
  if (v11)
  {
    for (unsigned int i = 0; i < 4; ++i)
    {
      unint64_t v9 = (atomic_ullong *)(v11 + 8 * i);
      uint64_t v15 = v9;
      unsigned int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index(v9, 0xFFFFFFFF);
      if (unset_bit_upto_index != -1)
      {
        int64_t v7 = 0;
        unsigned int v6 = 0;
        get_cont_and_indices_for_bitmap_and_index((uint64_t)v9, unset_bit_upto_index, (uint64_t *)&v12, (uint64_t *)&v7, &v6);
        mark_bitmap_as_full_if_still_full(v7, v6, (uint64_t *)v9, v0, v1, v2, v3, v4);
        return v12;
      }
    }
  }
  unint64_t v12 = _dispatch_alloc_continuation_from_heap(_dispatch_main_heap);
  if (v12) {
    return v12;
  }
  else {
    return _dispatch_alloc_continuation_from_heap_slow();
  }
}

uint64_t _dispatch_malloc_continuation_alloc()
{
  while (1)
  {
    uint64_t v1 = malloc_type_calloc();
    if (v1) {
      break;
    }
    _dispatch_temporary_resource_shortage();
  }
  return v1;
}

void _dispatch_continuation_free_to_heap(void *a1)
{
  if (_dispatch_use_dispatch_alloc) {
    _dispatch_alloc_continuation_free(a1);
  }
  else {
    _dispatch_malloc_continuation_free(a1);
  }
}

void _dispatch_alloc_continuation_free(void *a1)
{
  uint64_t v17 = a1;
  uint64_t v16 = 0;
  uint64_t v15 = 0;
  unsigned int v14 = 0;
  unsigned int v13 = 0;
  *a1 = 0;
  get_maps_and_indices_for_continuation((uint64_t)v17, &v15, &v14, &v16, &v13);
  BOOL v12 = bitmap_clear_bit(v16, v13, 1, v1, v2, v3, v4, v5);
  if (v15) {
    bitmap_clear_bit(v15, v14, 0, v6, v7, v8, v9, v10);
  }
  BOOL v11 = 0;
  if (v12) {
    BOOL v11 = v15 != 0;
  }
  if (v11) {
    _dispatch_alloc_maybe_madvise_page((uint64_t)v17);
  }
}

void _dispatch_malloc_continuation_free(void *a1)
{
}

const char *_dispatch_continuation_alloc_init()
{
  BOOL v1 = malloc_engaged_nano() == 0;
  uint64_t result = getenv("LIBDISPATCH_CONTINUATION_ALLOCATOR");
  if (result)
  {
    uint64_t result = (const char *)atoi(result);
    BOOL v1 = result != 0;
  }
  _dispatch_use_dispatch_alloc = v1;
  if (v1) {
    return (const char *)_os_object_atfork_prepare(result);
  }
  return result;
}

uint64_t get_cont_and_indices_for_bitmap_and_index(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t result = magazine_for_continuation(a1);
  uint64_t v15 = result;
  unsigned int v14 = (a1 - (result + 64)) / 8;
  unsigned int v13 = v14 % 0x40;
  unsigned int v12 = v14 / 0x40;
  if (result + 64 + ((unint64_t)(v14 / 0x40) << 9) + 8 * (v14 % 0x40) != a1) {
    _dispatch_abort(114, result + 64 + ((unint64_t)(v14 / 0x40) << 9) + 8 * (v14 % 0x40) == a1, v6, v7, v8, v9, v10, v11);
  }
  if (a3)
  {
    uint64_t result = continuation_address(result, v12, v13, a2, v8, v9, v10, v11);
    *a3 = result;
  }
  if (a4)
  {
    uint64_t result = supermap_address(v15, v12);
    *a4 = result;
  }
  if (a5) {
    *a5 = v13;
  }
  return result;
}

BOOL mark_bitmap_as_full_if_still_full(atomic_ullong *a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x40) {
    _dispatch_abort(274, a2 < 0x40, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
  uint64_t v12 = 1 << a2;
  for (uint64_t i = *(void *)a1; ; uint64_t i = v10)
  {
    BOOL result = bitmap_is_full(*a3);
    if (!result) {
      break;
    }
    uint64_t v9 = i;
    uint64_t v10 = i;
    atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v10, i | v12, memory_order_relaxed, memory_order_relaxed);
    if (v10 == v9) {
      break;
    }
  }
  return result;
}

unint64_t _dispatch_alloc_continuation_from_heap(uint64_t a1)
{
  uint64_t v8 = _dispatch_cpu_number();
  if (v8 >= MEMORY[0xFFFFFC036]) {
    _dispatch_abort(440, v8 < MEMORY[0xFFFFFC036], v1, v2, v3, v4, v5, v6);
  }
  unint64_t page = alloc_continuation_from_first_page(a1 + ((unint64_t)v8 << 20));
  if (page) {
    return page;
  }
  else {
    return alloc_continuation_from_magazine(a1 + ((unint64_t)v8 << 20));
  }
}

unint64_t _dispatch_alloc_continuation_from_heap_slow()
{
  for (uint64_t i = (atomic_ullong *)&_dispatch_main_heap; ; uint64_t i = *(atomic_ullong **)i)
  {
    if (!*(void *)i) {
      _dispatch_alloc_try_create_heap(i);
    }
    unint64_t v1 = _dispatch_alloc_continuation_from_heap(*(void *)i);
    if (v1) {
      break;
    }
  }
  return v1;
}

unint64_t _dispatch_cpu_number()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) & 0xFFF;
}

uint64_t bitmap_set_first_unset_bit_upto_index(atomic_ullong *a1, unsigned int a2)
{
  for (uint64_t i = *(void *)a1; ; uint64_t i = v5)
  {
    int v2 = __clz(__rbit64(~i));
    int v3 = 0;
    if (i != -1) {
      int v3 = v2 + 1;
    }
    if (!v3) {
      return -1;
    }
    unsigned int v8 = v3 - 1;
    if (v3 - 1 > a2) {
      return -1;
    }
    uint64_t v4 = i;
    uint64_t v5 = i;
    atomic_compare_exchange_strong_explicit(a1, (unint64_t *)&v5, i | (1 << v8), memory_order_relaxed, memory_order_relaxed);
    if (v5 == v4) {
      break;
    }
  }
  return v8;
}

unint64_t magazine_for_continuation(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFF00000;
}

unint64_t continuation_address(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 3) {
    _dispatch_abort(88, a2 < 3, a3, a4, a5, a6, a7, a8);
  }
  if (a3 >= 0x40) {
    _dispatch_abort(89, a3 < 0x40, a3, a4, a5, a6, a7, a8);
  }
  if (a4 >= 0x40) {
    _dispatch_abort(90, a4 < 0x40, a3, a4, a5, a6, a7, a8);
  }
  return a1
       + 0x4000
       + ((unint64_t)a2 << 18)
       + ((unint64_t)a3 << 12)
       + ((unint64_t)a4 << 6);
}

uint64_t supermap_address(uint64_t a1, unsigned int a2)
{
  return a1 + 16 + 8 * a2;
}

BOOL bitmap_is_full(uint64_t a1)
{
  return a1 == -1;
}

unint64_t alloc_continuation_from_first_page(uint64_t a1)
{
  for (unsigned int i = 0; i < 3; ++i)
  {
    int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index((atomic_ullong *)(a1 + 1600 + 8 * i), 0xFFFFFFFF);
    if (unset_bit_upto_index != -1) {
      return a1 + 1664 + ((unint64_t)(unset_bit_upto_index + (i << 6)) << 6);
    }
  }
  int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index((atomic_ullong *)(a1 + 1600 + 8 * i), 0x25u);
  if (unset_bit_upto_index == -1) {
    return 0;
  }
  return a1 + 1664 + ((unint64_t)(unset_bit_upto_index + (i << 6)) << 6);
}

unint64_t alloc_continuation_from_magazine(uint64_t a1)
{
  for (unsigned int i = 0; i < 3; ++i)
  {
    unint64_t v18 = (atomic_ullong *)supermap_address(a1, i);
    if (!bitmap_is_full(*(void *)v18))
    {
      for (unsigned int j = 0; j < 0x40; ++j)
      {
        uint64_t v17 = (atomic_ullong *)bitmap_address(a1, i, j);
        unsigned int unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index(v17, 0xFFFFFFFF);
        if (unset_bit_upto_index != -1)
        {
          bitmap_in_same_unint64_t page = first_bitmap_in_same_page((unint64_t)v17);
          if (!_dispatch_main_heap) {
            _dispatch_abort(50, 0, v1, v2, v3, v4, v5, v6);
          }
          *(void *)(_dispatch_main_heap + ((unint64_t)_dispatch_cpu_number() << 20) + 8) = bitmap_in_same_page;
          mark_bitmap_as_full_if_still_full(v18, j, (uint64_t *)v17, v7, v8, v9, v10, v11);
          return continuation_address(a1, i, j, unset_bit_upto_index, v12, v13, v14, v15);
        }
      }
    }
  }
  return 0;
}

unint64_t bitmap_address(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return a1 + 64 + ((unint64_t)a2 << 9) + 8 * a3;
}

unint64_t first_bitmap_in_same_page(unint64_t a1)
{
  unint64_t v8 = magazine_for_continuation(a1);
  if (a1 < v8 + 64) {
    _dispatch_abort(201, a1 >= v8 + 64, v1, v2, v3, v4, v5, v6);
  }
  if (a1 >= v8 + 2112) {
    _dispatch_abort(203, a1 < v8 + 2112, v1, v2, v3, v4, v5, v6);
  }
  return a1 & 0xFFFFFFFFFFFFFFE0;
}

void _dispatch_alloc_try_create_heap(atomic_ullong *a1)
{
  kern_return_t v13;
  atomic_ullong *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  uint64_t v14 = a1;
  uint64_t v13 = 0;
  unint64_t v18 = 0;
  uint64_t v17 = 0xFFFFFC036;
  mach_vm_size_t v12 = MEMORY[0xFFFFFC036] << 20;
  mach_vm_offset_t v11 = 0xFFFFFLL;
  for (mach_vm_address_t address = vm_page_size; ; mach_vm_address_t address = vm_page_size)
  {
    uint64_t v13 = mach_vm_map(mach_task_self_, &address, v12, v11, 1241513985, 0, 0, 0, 3, 7, 1u);
    if (!v13) {
      break;
    }
    if (v13 != 3)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not allocate heap";
      qword_F42C0 = v13;
      __break(1u);
      JUMPOUT(0xC16F0);
    }
    _dispatch_temporary_resource_shortage();
  }
  uint64_t v9 = (void *)address;
  uint64_t v1 = 0;
  atomic_compare_exchange_strong_explicit(v14, (unint64_t *)&v1, address, memory_order_relaxed, memory_order_relaxed);
  if (v1)
  {
    uint64_t v16 = 0;
    uint64_t v15 = 0xFFFFFC036;
    int v8 = mprotect(v9, MEMORY[0xFFFFFC036] << 20, 0);
    char v20 = v8;
    unint64_t v19 = 424;
    if (v8) {
      _dispatch_bug(v19, v20, v2, v3, v4, v5, v6, v7);
    }
  }
}

BOOL get_maps_and_indices_for_continuation(uint64_t a1, void *a2, unsigned int *a3, void *a4, unsigned int *a5)
{
  unint64_t v6 = magazine_for_continuation(a1);
  BOOL result = continuation_is_in_first_page(a1);
  if (result)
  {
    unsigned int v8 = ((uint64_t)(a1 - (v6 + 1664)) / 64) / 0x40;
    if (a2) {
      *a2 = 0;
    }
    if (a3) {
      *a3 = v8;
    }
    if (a4) {
      *a4 = v6 + 1600 + 8 * v8;
    }
    if (a5) {
      *a5 = ((uint64_t)(a1 - (v6 + 1664)) / 64) % 0x40;
    }
  }
  else
  {
    unsigned int v10 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) / 0x1000;
    unsigned int v9 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) / 0x40 % 0x40;
    if (a2) {
      *a2 = v6 + 16 + 8 * v10;
    }
    if (a3) {
      *a3 = v9;
    }
    if (a4) {
      *a4 = v6 + 64 + ((unint64_t)v10 << 9) + 8 * v9;
    }
    if (a5) {
      *a5 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) % 0x40;
    }
  }
  return result;
}

BOOL bitmap_clear_bit(atomic_ullong *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 0x40) {
    _dispatch_abort(251, a2 < 0x40, a3, a4, a5, a6, a7, a8);
  }
  uint64_t v10 = 1 << a2;
  if ((a3 & 1) != 0 && (*(void *)a1 & v10) == 0)
  {
    uint64_t v8 = *(void *)a1;
    qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption: failed to clear bit exclusively";
    qword_F42C0 = v8;
    __break(1u);
    JUMPOUT(0xC1C3CLL);
  }
  return (atomic_fetch_and_explicit(a1, ~v10, memory_order_release) & ~v10) == 0;
}

void _dispatch_alloc_maybe_madvise_page(uint64_t a1)
{
  uint64_t v13 = a1;
  mach_vm_size_t v12 = (void *)madvisable_page_base_for_continuation(a1);
  if (v12)
  {
    mach_vm_offset_t v11 = 0;
    get_maps_and_indices_for_continuation((uint64_t)v12, 0, 0, &v11, 0);
    for (unsigned int i = 0; i < 4; ++i)
    {
      if (v11[i]) {
        return;
      }
    }
    int v9 = 0;
    while (1)
    {
      uint64_t v1 = 0;
      atomic_compare_exchange_strong_explicit((atomic_ullong *volatile)&v11[v9], (unint64_t *)&v1, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed, memory_order_relaxed);
      if (v1) {
        break;
      }
      if (++v9 >= 4)
      {
        __memset_chk();
        int v8 = madvise(v12, 0x4000uLL, 5);
        uint64_t v15 = v8;
        uint64_t v14 = 563;
        if (v8) {
          _dispatch_bug(v14, v15, v2, v3, v4, v5, v6, v7);
        }
        break;
      }
    }
    while (v9 > 1)
      v11[--v9] = 0;
    if (v9) {
      void *v11 = 0;
    }
  }
}

BOOL continuation_is_in_first_page(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFF00000) == (a1 & 0xFFFFFFFFFFFFC000);
}

unint64_t madvisable_page_base_for_continuation(uint64_t a1)
{
  if (continuation_is_in_first_page(a1)) {
    return 0;
  }
  unint64_t v2 = magazine_for_continuation(a1);
  if ((a1 & 0xFFFFFFFFFFFFC000) < v2 + 0x4000)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: madvisable continuation too low";
    qword_F42C0 = a1 & 0xFFFFFFFFFFFFC000;
    __break(1u);
    JUMPOUT(0xC2028);
  }
  if ((a1 & 0xFFFFFFFFFFFFC000) > v2 + 802752)
  {
    qword_F4290 = (uint64_t)"BUG IN LIBDISPATCH: madvisable continuation too high";
    qword_F42C0 = a1 & 0xFFFFFFFFFFFFC000;
    __break(1u);
    JUMPOUT(0xC208CLL);
  }
  return a1 & 0xFFFFFFFFFFFFC000;
}

uint64_t dispatch_benchmark(unint64_t a1, uint64_t a2)
{
  uint64_t v5 = _Block_get_invoke_fn(a2);
  uint64_t v6 = 0;
  if (v5) {
    uint64_t v6 = (void (*)(uint64_t))v5;
  }
  return dispatch_benchmark_f(a1, a2, v6);
}

uint64_t dispatch_benchmark_f(unint64_t a1, uint64_t a2, void (*a3)(uint64_t))
{
  unint64_t v4 = 0;
  if (dispatch_benchmark_f_pred != -1) {
    dispatch_once_f(&dispatch_benchmark_f_pred, &dispatch_benchmark_f_bdata, (dispatch_function_t)_dispatch_benchmark_init);
  }
  if (!a1) {
    return 0;
  }
  _dispatch_uptime();
  do
  {
    ++v4;
    a3(a2);
  }
  while (v4 < a1);
  _dispatch_uptime();
  return __udivti3() - qword_F0AE0;
}

uint64_t _dispatch_benchmark_init(uint64_t a1)
{
  mach_vm_offset_t v11 = *(void (**)(uint64_t))(a1 + 16);
  uint64_t v10 = *(void *)(a1 + 24);
  unint64_t v9 = *(void *)(a1 + 32);
  unint64_t v8 = 0;
  uint64_t v13 = mach_timebase_info((mach_timebase_info_t)a1);
  if (v13) {
    _dispatch_abort(53, v13, v1, v2, v3, v4, v5, v6);
  }
  _dispatch_uptime();
  do
  {
    ++v8;
    v11(v10);
  }
  while (v8 < v9);
  _dispatch_uptime();
  __udivti3();
  uint64_t result = __udivti3();
  *(void *)(a1 + 8) = result;
  return result;
}

uint64_t _dispatch_send_wakeup_runloop_thread(unsigned int a1, mach_msg_timeout_t a2)
{
  unsigned int v6 = a1;
  mach_msg_timeout_t v5 = a2;
  *(void *)&v4.msgh_bits = 19;
  *(void *)&v4.msgh_voucher_mach_port_t port = 0x4E00000000;
  *(void *)&v4.msgh_remote_mach_port_t port = a1;
  unsigned int v3 = mach_msg(&v4, 17, 0x18u, 0, 0, a2, 0);
  if (v3 == 268435460)
  {
    if ((unsigned __int16)(v4.msgh_bits & 0x1F00) >> 8 == 17) {
      mach_port_deallocate(mach_task_self_, v4.msgh_local_port);
    }
    mach_msg_destroy(&v4);
  }
  return v3;
}

uint64_t _dispatch_send_consume_send_once_right(unsigned int a1)
{
  unsigned int v3 = a1;
  *(void *)&v2.msgh_bits = 18;
  *(void *)&v2.msgh_voucher_mach_port_t port = 0x4F00000000;
  *(void *)&v2.msgh_remote_mach_port_t port = a1;
  return mach_msg(&v2, 1, 0x18u, 0, 0, 0, 0);
}

uint64_t libdispatch_internal_protocol_server_routine(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20) - 64;
  if (v2 < 0x10) {
    return qword_EDC70[5 * (int)v2 + 1];
  }
  else {
    return 0;
  }
}

uint64_t _Xmach_notify_port_deleted(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = _dispatch_mach_notify_port_deleted(*(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 32), v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xmach_notify_send_possible(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = _dispatch_mach_notify_send_possible(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xmach_notify_port_destroyed(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_destroyed_t((int *)a1);
  if (!result) {
    _dispatch_mach_notify_port_destroyed(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 28));
  }
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_notify_no_senders(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if (!result) {
    _dispatch_mach_notify_no_senders(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
  }
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_notify_send_once(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_send_once_t((int *)a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = _dispatch_mach_notify_send_once(*(unsigned int *)(a1 + 12), v3, v4, v5, v6, v7, v8, v9);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xmach_notify_dead_name(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = _dispatch_mach_notify_dead_name(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xwakeup_runloop_thread(int *a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_send_once_t(a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = _dispatch_wakeup_runloop_thread();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xconsume_send_once_right(int *a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__mach_notify_send_once_t(a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = _dispatch_wakeup_runloop_thread();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t libdispatch_internal_protocol_server(_DWORD *a1, uint64_t a2)
{
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 4) = 36;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = a1[5] + 100;
  *(_DWORD *)(a2 + 16) = 0;
  if ((int)a1[5] <= 79
    && (int)a1[5] >= 64
    && (uint64_t v3 = (void (*)(_DWORD *, uint64_t))qword_EDC70[5 * a1[5] - 319]) != 0)
  {
    v3(a1, a2);
    return 1;
  }
  else
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
    return 0;
  }
}

uint64_t __MIG_check__Request__mach_notify_port_deleted_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 36) {
    return 0;
  }
  else {
    return -304;
  }
}

uint64_t __MIG_check__Request__mach_notify_port_destroyed_t(int *a1)
{
  if (*a1 < 0 && a1[6] == 1 && a1[1] == 40)
  {
    if (!HIBYTE(a1[9]) && BYTE2(a1[9]) == 16) {
      return 0;
    }
    else {
      return -300;
    }
  }
  else
  {
    return -304;
  }
}

uint64_t __MIG_check__Request__mach_notify_send_once_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 24) {
    return 0;
  }
  else {
    return -304;
  }
}

uint64_t firehose_send_register(int a1, int a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8)
{
  int v17 = a1;
  int v16 = a2;
  uint64_t v15 = a3;
  int v14 = a4;
  int v13 = a5;
  int v12 = a6;
  int v11 = a7;
  uint64_t v10 = a8;
  memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[24] = 5;
  *(_DWORD *)&__b[28] = v16;
  *(_DWORD *)&_WORD __b[36] = *(_DWORD *)&__b[36] & 0xFF00FFFF | 0x110000;
  *(_DWORD *)&__b[36] &= 0xFFFFFFu;
  *(_DWORD *)&__b[40] = v14;
  *(_DWORD *)&__b[48] = *(_DWORD *)&__b[48] & 0xFF00FFFF | 0x100000;
  *(_DWORD *)&__b[48] &= 0xFFFFFFu;
  *(_DWORD *)&__b[52] = v13;
  *(_DWORD *)&__b[60] = *(_DWORD *)&__b[60] & 0xFF00FFFF | 0x100000;
  *(_DWORD *)&__b[60] &= 0xFFFFFFu;
  *(_DWORD *)&__b[64] = v12;
  *(_DWORD *)&__b[72] = *(_DWORD *)&__b[72] & 0xFF00FFFF | 0x140000;
  *(_DWORD *)&__b[72] &= 0xFFFFFFu;
  *(_DWORD *)&__b[76] = v11;
  *(_DWORD *)&__b[84] = *(_DWORD *)&__b[84] & 0xFF00FFFF | 0x110000;
  *(_DWORD *)&__b[84] &= 0xFFFFFFu;
  *(NDR_record_t *)&__b[88] = NDR_record;
  *(void *)&uint8_t __b[96] = v15;
  *(void *)&__b[104] = v10;
  *(_DWORD *)&__b[12] = 0;
  *(_DWORD *)stat __b = -2147483629;
  *(_DWORD *)&__b[8] = v17;
  *(_DWORD *)&__b[20] = 11600;
  *(_DWORD *)&void __b[16] = 0;
  return mach_msg((mach_msg_header_t *)__b, 1, 0x70u, 0, 0, 0, 0);
}

uint64_t firehose_send_push_and_wait(int a1, _OWORD *a2, _DWORD *a3)
{
  memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[12] = mig_get_special_reply_port();
  *(_DWORD *)stat __b = 5395;
  *(_DWORD *)&__b[8] = a1;
  *(_DWORD *)&__b[20] = 11601;
  *(_DWORD *)&void __b[16] = 0;
  unsigned int v6 = mach_msg((mach_msg_header_t *)__b, 3162115, 0x18u, 0x40u, *(mach_port_name_t *)&__b[12], 0, 0);
  if (v6)
  {
    BOOL v3 = v6 == 268435459 || v6 == 268435458;
    if (!v3 && v6 != 268435472) {
      mig_dealloc_special_reply_port();
    }
  }
  if (v6)
  {
    return v6;
  }
  else
  {
    unsigned int v5 = __MIG_check__Reply__push_and_wait_t((int *)__b);
    if (v5)
    {
      mach_msg_destroy((mach_msg_header_t *)__b);
      return v5;
    }
    else
    {
      *a2 = *(_OWORD *)&__b[36];
      *a3 = *(_DWORD *)&__b[52];
      return 0;
    }
  }
}

uint64_t __MIG_check__Reply__push_and_wait_t(int *a1)
{
  if (a1[5] == 11701)
  {
    int v2 = a1[1];
    if (*a1 >= 0 && (v2 == 56 || v2 == 36 && a1[8]))
    {
      if (a1[2])
      {
        return -300;
      }
      else if (a1[8])
      {
        return a1[8];
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return -300;
    }
  }
  else if (a1[5] == 71)
  {
    return -308;
  }
  else
  {
    return -301;
  }
}

uint64_t firehose_send_push_async(int a1, int a2, mach_msg_timeout_t a3)
{
  int v8 = a1;
  int v7 = a2;
  mach_msg_timeout_t v6 = a3;
  memset(__b, 0, sizeof(__b));
  *(NDR_record_t *)&__b[24] = NDR_record;
  *(_DWORD *)&__b[32] = v7;
  *(_DWORD *)&__b[12] = 0;
  *(_DWORD *)stat __b = 19;
  *(_DWORD *)&__b[8] = v8;
  *(_DWORD *)&__b[20] = 11602;
  *(_DWORD *)&void __b[16] = 0;
  unsigned int v4 = mach_msg((mach_msg_header_t *)__b, 17, 0x24u, 0, 0, v6, 0);
  if (v4 == 268435460)
  {
    if ((unsigned __int16)(*(_WORD *)__b & 0x1F00) >> 8 == 17) {
      mach_port_deallocate(mach_task_self_, *(mach_port_name_t *)&__b[12]);
    }
    mach_msg_destroy((mach_msg_header_t *)__b);
  }
  return v4;
}

uint64_t firehose_send_get_logging_prefs(int a1, _DWORD *a2, void *a3)
{
  int v10 = a1;
  uint64_t v9 = a2;
  int v8 = a3;
  memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[12] = mig_get_special_reply_port();
  *(_DWORD *)stat __b = 5395;
  *(_DWORD *)&__b[8] = v10;
  *(_DWORD *)&__b[20] = 11603;
  *(_DWORD *)&void __b[16] = 0;
  unsigned int v6 = mach_msg((mach_msg_header_t *)__b, 3162115, 0x18u, 0x40u, *(mach_port_name_t *)&__b[12], 0, 0);
  if (v6)
  {
    BOOL v3 = v6 == 268435459 || v6 == 268435458;
    if (!v3 && v6 != 268435472) {
      mig_dealloc_special_reply_port();
    }
  }
  if (v6)
  {
    return v6;
  }
  else
  {
    unsigned int v5 = __MIG_check__Reply__get_logging_prefs_t((int *)__b);
    if (v5)
    {
      mach_msg_destroy((mach_msg_header_t *)__b);
      return v5;
    }
    else
    {
      _DWORD *v9 = *(_DWORD *)&__b[28];
      *int v8 = *(void *)&__b[48];
      return 0;
    }
  }
}

uint64_t __MIG_check__Reply__get_logging_prefs_t(int *a1)
{
  if (a1[5] == 11703)
  {
    int v2 = a1[1];
    if (*a1 < 0 && a1[6] == 1 && v2 == 56 || *a1 >= 0 && v2 == 36 && a1[8])
    {
      if (a1[2])
      {
        return -300;
      }
      else if (*a1 < 0)
      {
        if (!HIBYTE(a1[9]) && BYTE2(a1[9]) == 17) {
          return 0;
        }
        else {
          return -300;
        }
      }
      else
      {
        return a1[8];
      }
    }
    else
    {
      return -300;
    }
  }
  else if (a1[5] == 71)
  {
    return -308;
  }
  else
  {
    return -301;
  }
}

uint64_t firehose_send_should_send_strings(mach_port_t a1, mach_port_t *a2)
{
  mach_port_t v8 = a1;
  int v7 = a2;
  memset(__b, 0, sizeof(__b));
  __b[0].msgh_local_mach_port_t port = mig_get_special_reply_port();
  __b[0].msgh_bits = 5395;
  __b[0].msgh_remote_mach_port_t port = v8;
  __b[0].msgh_id = 11604;
  __b[0].msgh_voucher_mach_port_t port = 0;
  unsigned int v5 = mach_msg(__b, 3162115, 0x18u, 0x30u, __b[0].msgh_local_port, 0, 0);
  if (v5)
  {
    BOOL v2 = v5 == 268435459 || v5 == 268435458;
    if (!v2 && v5 != 268435472) {
      mig_dealloc_special_reply_port();
    }
  }
  if (v5)
  {
    return v5;
  }
  else
  {
    unsigned int v4 = __MIG_check__Reply__should_send_strings_t((int *)__b);
    if (v4)
    {
      mach_msg_destroy(__b);
      return v4;
    }
    else
    {
      *int v7 = __b[1].msgh_local_port;
      return 0;
    }
  }
}

uint64_t __MIG_check__Reply__should_send_strings_t(int *a1)
{
  if (a1[5] == 11704)
  {
    int v2 = a1[1];
    if (*a1 >= 0 && (v2 == 40 || v2 == 36 && a1[8]))
    {
      if (a1[2])
      {
        return -300;
      }
      else if (a1[8])
      {
        return a1[8];
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return -300;
    }
  }
  else if (a1[5] == 71)
  {
    return -308;
  }
  else
  {
    return -301;
  }
}

uint64_t firehoseReply_server_routine(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 20) - 11700;
  if (v2 <= 4) {
    return qword_EDF10[5 * (int)v2 + 1];
  }
  else {
    return 0;
  }
}

uint64_t _Xpush_reply(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__push_reply_t((int *)a1);
  if (!result) {
    firehose_client_push_reply(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
  }
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xpush_notify_async(uint64_t a1, uint64_t a2)
{
  uint64_t result = __MIG_check__Request__push_notify_async_t((int *)a1);
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = firehose_client_push_notify_async(*(unsigned int *)(a1 + 12), *(void *)(a1 + 32), *(void *)(a1 + 40), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t firehoseReply_server(_DWORD *a1, uint64_t a2)
{
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 4) = 36;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 2pthread_sigmask(3, _dispatch_sigsuspend_mask, 0) = a1[5] + 100;
  *(_DWORD *)(a2 + 16) = 0;
  if ((int)a1[5] <= 11704
    && (int)a1[5] >= 11700
    && (BOOL v3 = (void (*)(_DWORD *, uint64_t))qword_EDF10[5 * a1[5] - 58499]) != 0)
  {
    v3(a1, a2);
    return 1;
  }
  else
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
    return 0;
  }
}

uint64_t __MIG_check__Request__push_reply_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 56) {
    return 0;
  }
  else {
    return -304;
  }
}

uint64_t __MIG_check__Request__push_notify_async_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 52) {
    return 0;
  }
  else {
    return -304;
  }
}

void _dispatch_bug(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (_dispatch_build_pred != -1) {
    dispatch_once_f(&_dispatch_build_pred, 0, (dispatch_function_t)_dispatch_build_init);
  }
  uint64_t v9 = _dispatch_bug_last_seen;
  _dispatch_bug_last_seen = v8;
  if (v8 != v9) {
    _dispatch_log("BUG in libdispatch: %s - %lu - 0x%lx", a2, a3, a4, a5, a6, a7, a8, (uint64_t)&_dispatch_build);
  }
}

void _dispatch_log(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v9[1] = a1;
  v9[0] = &a9;
  int v12 = a1;
  uint64_t v11 = 0;
  int v10 = (char **)v9;
  uint64_t v15 = &_dispatch_logv_pred;
  int v14 = 0;
  dispatch_function_t v13 = (dispatch_function_t)_dispatch_logv_init;
  if (_dispatch_logv_pred != -1) {
    dispatch_once_f(v15, v14, v13);
  }
  if ((dispatch_log_disabled & 1) == 0)
  {
    if (dispatch_logfile == -1)
    {
      if (v10) {
        _dispatch_vsyslog(v12, *v10);
      }
      else {
        _dispatch_syslog();
      }
    }
    else if (v10)
    {
      _dispatch_logv_file(v12, *v10);
    }
    else
    {
      _dispatch_log_file((uint64_t)v12, v11);
    }
  }
}

void _dispatch_bug_mach_client(uint64_t a1, mach_error_t a2)
{
  uint64_t v10 = _dispatch_bug_mach_client_last_seen;
  _dispatch_bug_mach_client_last_seen = v2;
  if (v2 != v10)
  {
    mach_error_string(a2);
    _dispatch_log("BUG in libdispatch client: %s %s - 0x%x", v3, v4, v5, v6, v7, v8, v9, a1);
    if (_dispatch_mode)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_mach_client";
      __break(1u);
      JUMPOUT(0xC430CLL);
    }
  }
}

void _dispatch_bug_kevent_client(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v63 = a7;
  uint64_t v62 = a1;
  uint64_t v61 = a2;
  int v60 = (char *)a3;
  unsigned int v59 = a4;
  uint64_t v58 = a5;
  uint64_t v57 = (char *)a6;
  uint64_t v56 = 0;
  unint64_t v55 = 0;
  uint64_t function_symbol = 0;
  if (a7)
  {
    unint64_t v55 = ~*(void *)(v63 + 8);
    uint64_t v45 = *(void *)v55;
    uint64_t v46 = v55 & 0xFFFFFFFFFFFFLL | 0x6AE1000000000000;
    uint64_t v47 = 0;
    if (v45) {
      uint64_t v47 = v45;
    }
    uint64_t v44 = *(void *)(v47 + 16);
    if (v44 == 275)
    {
      uint64_t v56 = *(void *)(v63 + 40);
      if (v56) {
        uint64_t function_symbol = _dispatch_continuation_get_function_symbol(v56);
      }
    }
    else if (v44 == 787)
    {
      uint64_t v41 = *(void *)(v63 + 40);
      unint64_t v42 = (v63 + 40) & 0xFFFFFFFFFFFFLL | 0xAFCE000000000000;
      uint64_t v43 = 0;
      if (v41) {
        uint64_t v43 = v41;
      }
      uint64_t v39 = v43;
      uint64_t v40 = 0;
      if (v43) {
        uint64_t v40 = v39;
      }
      uint64_t function_symbol = v40;
    }
    uint64_t v36 = *(uint64_t **)v63;
    uint64_t v37 = v63 & 0xFFFFFFFFFFFFLL | 0x6AE1000000000000;
    BOOL v38 = 0;
    if (v36) {
      BOOL v38 = v36;
    }
    uint64_t v61 = *v38;
  }
  if (v60 && v59)
  {
    uint64_t v53 = _dispatch_bug_kevent_client_last_seen;
    _dispatch_bug_kevent_client_last_seen = v48;
    BOOL v52 = v48 == v53;
    if (v48 != v53)
    {
      uint64_t v34 = v62;
      unint64_t v33 = v60;
      uint64_t v35 = &v22;
      uint64_t v30 = function_symbol;
      uint64_t v29 = v58;
      uint64_t v28 = v58;
      uint64_t v27 = v61;
      uint64_t v26 = (uint64_t)v57;
      uint64_t v25 = v59;
      uint64_t v24 = strerror(v59);
      int v23 = v60;
      _dispatch_log("BUG in libdispatch client: %s %s: \"%s\" - 0x%x { 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }", v8, v9, v10, v11, v12, v13, v14, v62);
      if (_dispatch_mode)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xC4634);
      }
    }
  }
  else if (v60)
  {
    uint64_t v51 = _dispatch_bug_kevent_client_last_seen_4172;
    _dispatch_bug_kevent_client_last_seen_4172 = v48;
    if (v48 != v51)
    {
      uint64_t v28 = function_symbol;
      uint64_t v27 = v58;
      uint64_t v26 = v58;
      uint64_t v25 = v61;
      uint64_t v24 = v57;
      int v23 = v60;
      _dispatch_log("BUG in libdispatch client: %s %s{ 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }", a2, a3, a4, a5, a6, a7, a8, v62);
      if (_dispatch_mode)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xC4708);
      }
    }
  }
  else
  {
    uint64_t v50 = _dispatch_bug_kevent_client_last_seen_4174;
    _dispatch_bug_kevent_client_last_seen_4174 = v48;
    BOOL v49 = v48 == v50;
    if (v48 != v50)
    {
      uint64_t v31 = v62;
      unint64_t v32 = &v22;
      uint64_t v29 = function_symbol;
      uint64_t v28 = v58;
      uint64_t v27 = v58;
      uint64_t v26 = v61;
      uint64_t v25 = (uint64_t)v57;
      uint64_t v24 = (char *)v59;
      int v23 = strerror(v59);
      _dispatch_log("BUG in libdispatch: %s: \"%s\" - 0x%x{ 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }", v15, v16, v17, v18, v19, v20, v21, v62);
      if (_dispatch_mode)
      {
        qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xC47ECLL);
      }
    }
  }
}

void _dispatch_bug_kevent_vanished(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = (uint64_t *)~*(void *)(a1 + 8);
  uint64_t v10 = 0;
  if (*v12) {
    uint64_t v10 = *v12;
  }
  if (*(void *)(v10 + 16) == 275 && *(void *)(a1 + 40)) {
    _dispatch_continuation_get_function_symbol(*(void *)(a1 + 40));
  }
  uint64_t v11 = _dispatch_bug_kevent_vanished_last_seen;
  _dispatch_bug_kevent_vanished_last_seen = v9;
  if (v9 != v11)
  {
    uint64_t v8 = 0;
    if (*(void *)a1) {
      uint64_t v8 = *(uint64_t **)a1;
    }
    _dispatch_log("BUG in libdispatch client: %s, monitored resource vanished before the source cancel handler was invoked { %p[%s], ident: %d / 0x%x, handler: %p }", a2, a3, a4, a5, a6, a7, a8, *v8);
    if (_dispatch_mode)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_vanished";
      __break(1u);
      JUMPOUT(0xC4AE4);
    }
  }
}

void _dispatch_bug_deprecated(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = _dispatch_bug_deprecated_last_seen;
  _dispatch_bug_deprecated_last_seen = v8;
  if (v8 != v9)
  {
    _dispatch_log("DEPRECATED USE in libdispatch client: %s; set a breakpoint on _dispatch_bug_deprecated to debug",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a1);
    if (_dispatch_mode)
    {
      qword_F4290 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_deprecated";
      __break(1u);
      JUMPOUT(0xC4B9CLL);
    }
  }
}

void _dispatch_abort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void dispatch_debugv(dispatch_object_t object, const char *message, va_list ap)
{
}

void dispatch_debug(dispatch_object_t object, const char *message, ...)
{
  va_start(va, message);
  _dispatch_debugv((uint64_t *)object, message, va);
}

size_t _dispatch_object_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v6 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "xref = %d, ref = %d, ", *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8));
  if (v6 < 0) {
    return 0;
  }
  if (v6 <= a3) {
    return v6;
  }
  else {
    return a3;
  }
}

size_t _dispatch_semaphore_debug(void *a1, char *a2, size_t a3)
{
  uint64_t v10 = 0;
  if (*a1) {
    uint64_t v10 = *a1;
  }
  int v13 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v10 + 24), a1);
  if (v13 >= 0)
  {
    if (v13 <= a3) {
      size_t v8 = v13;
    }
    else {
      size_t v8 = a3;
    }
    size_t v9 = v8;
  }
  else
  {
    size_t v9 = 0;
  }
  size_t v15 = v9 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v9], a3 - v9);
  int v12 = __snprintf_chk(&a2[v15], a3 - v15, 0, 0xFFFFFFFFFFFFFFFFLL, "port = 0x%x, ", *((_DWORD *)a1 + 16));
  if (v12 >= 0)
  {
    if (v12 <= a3 - v15) {
      size_t v6 = v12;
    }
    else {
      size_t v6 = a3 - v15;
    }
    size_t v7 = v6;
  }
  else
  {
    size_t v7 = 0;
  }
  size_t v16 = v15 + v7;
  int v11 = __snprintf_chk(&a2[v16], a3 - v16, 0, 0xFFFFFFFFFFFFFFFFLL, "value = %ld, orig = %ld }", a1[6], a1[7]);
  if (v11 >= 0)
  {
    if (v11 <= a3 - v16) {
      size_t v4 = v11;
    }
    else {
      size_t v4 = a3 - v16;
    }
    size_t v5 = v4;
  }
  else
  {
    size_t v5 = 0;
  }
  return v16 + v5;
}

size_t _dispatch_group_debug(uint64_t *a1, char *a2, size_t a3)
{
  uint64_t v13 = a1[6];
  uint64_t v8 = 0;
  if (*a1) {
    uint64_t v8 = *a1;
  }
  int v10 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v8 + 24), a1);
  if (v10 >= 0)
  {
    if (v10 <= a3) {
      size_t v6 = v10;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = v6;
  }
  else
  {
    size_t v7 = 0;
  }
  size_t v12 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  int v9 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "count = %u, gen = %d, waiters = %d, notifs = %d }", -(v13 & 0xFFFFFFFC) >> 2, HIDWORD(v13), (v13 & 1) != 0, (v13 & 2) != 0);
  if (v9 >= 0)
  {
    if (v9 <= a3 - v12) {
      size_t v4 = v9;
    }
    else {
      size_t v4 = a3 - v12;
    }
    size_t v5 = v4;
  }
  else
  {
    size_t v5 = 0;
  }
  return v12 + v5;
}

size_t _dispatch_queue_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  BOOL v49 = *(void **)(a1 + 24);
  if (v49 && v49[9]) {
    unint64_t v33 = (const char *)v49[9];
  }
  else {
    unint64_t v33 = "";
  }
  unint64_t v48 = *(void *)(a1 + 56);
  int v46 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "sref = %d, target = %s[%p], width = 0x%x, state = 0x%016llx", *(_DWORD *)(a1 + 96) + 1, v33, v49, *(unsigned __int16 *)(a1 + 80), v48);
  if (v46 >= 0)
  {
    if (v46 <= a3) {
      size_t v31 = v46;
    }
    else {
      size_t v31 = a3;
    }
    size_t v32 = v31;
  }
  else
  {
    size_t v32 = 0;
  }
  size_t v50 = v32;
  if ((v48 & 0xFF80000000000000) != 0)
  {
    int v45 = __snprintf_chk(&a2[v32], a3 - v32, 0, 0xFFFFFFFFFFFFFFFFLL, ", suspended = %d", v48 / 0x400000000000000);
    if (v45 >= 0)
    {
      if (v45 <= a3 - v32) {
        size_t v29 = v45;
      }
      else {
        size_t v29 = a3 - v32;
      }
      size_t v30 = v29;
    }
    else
    {
      size_t v30 = 0;
    }
    size_t v50 = v32 + v30;
  }
  switch(v48 & 0x180000000000000)
  {
    case 0x180000000000000uLL:
      int v44 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", inactive");
      if (v44 >= 0)
      {
        if (v44 <= a3 - v50) {
          size_t v27 = v44;
        }
        else {
          size_t v27 = a3 - v50;
        }
        size_t v28 = v27;
      }
      else
      {
        size_t v28 = 0;
      }
      v50 += v28;
      break;
    case 0x100000000000000uLL:
      int v43 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", activated");
      if (v43 >= 0)
      {
        if (v43 <= a3 - v50) {
          size_t v25 = v43;
        }
        else {
          size_t v25 = a3 - v50;
        }
        size_t v26 = v25;
      }
      else
      {
        size_t v26 = 0;
      }
      v50 += v26;
      break;
    case 0x80000000000000uLL:
      int v42 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", activating");
      if (v42 >= 0)
      {
        if (v42 <= a3 - v50) {
          size_t v23 = v42;
        }
        else {
          size_t v23 = a3 - v50;
        }
        size_t v24 = v23;
      }
      else
      {
        size_t v24 = 0;
      }
      v50 += v24;
      break;
  }
  if ((v48 & 0x4000000001) != 0)
  {
    int v41 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", enqueued");
    if (v41 >= 0)
    {
      if (v41 <= a3 - v50) {
        size_t v21 = v41;
      }
      else {
        size_t v21 = a3 - v50;
      }
      size_t v22 = v21;
    }
    else
    {
      size_t v22 = 0;
    }
    v50 += v22;
  }
  if ((v48 & 0x8000000000) != 0)
  {
    int v40 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", dirty");
    if (v40 >= 0)
    {
      if (v40 <= a3 - v50) {
        size_t v19 = v40;
      }
      else {
        size_t v19 = a3 - v50;
      }
      size_t v20 = v19;
    }
    else
    {
      size_t v20 = 0;
    }
    v50 += v20;
  }
  int v39 = (v48 & 0x700000000) >> 32;
  if (v39)
  {
    int v38 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", max qos %d", v39);
    if (v38 >= 0)
    {
      if (v38 <= a3 - v50) {
        size_t v17 = v38;
      }
      else {
        size_t v17 = a3 - v50;
      }
      size_t v18 = v17;
    }
    else
    {
      size_t v18 = 0;
    }
    v50 += v18;
  }
  if ((v48 & 0xFFFFFFFC) != 0) {
    int v57 = v48 | 3;
  }
  else {
    int v57 = 0;
  }
  if (v57 && ((*(_DWORD *)(a1 + 80) & 0x40000) == 0 || (*(_DWORD *)(a1 + 80) & 0x1000000) != 0))
  {
    int v37 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", draining on 0x%x", v57);
    if (v37 >= 0)
    {
      if (v37 <= a3 - v50) {
        size_t v15 = v37;
      }
      else {
        size_t v15 = a3 - v50;
      }
      size_t v16 = v15;
    }
    else
    {
      size_t v16 = 0;
    }
    v50 += v16;
  }
  if ((v48 & 0x40000000000000) != 0)
  {
    int v36 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-barrier");
    if (v36 >= 0)
    {
      if (v36 <= a3 - v50) {
        size_t v13 = v36;
      }
      else {
        size_t v13 = a3 - v50;
      }
      size_t v14 = v13;
    }
    else
    {
      size_t v14 = 0;
    }
    size_t v51 = v50 + v14;
  }
  else
  {
    int v11 = &a2[v50];
    size_t v12 = a3 - v50;
    unsigned __int16 v56 = *(_WORD *)(a1 + 80);
    int v55 = (v48 & 0x3FFE0000000000) >> 41;
    if ((v48 & 0x10000000000) != 0) {
      int v3 = __snprintf_chk(v11, v12, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-flight = %d", v55 - (4096 - v56) - (v56 - 1));
    }
    else {
      int v3 = __snprintf_chk(v11, v12, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-flight = %d", v55 - (4096 - v56));
    }
    if (v3 >= 0)
    {
      if (v3 <= a3 - v50) {
        size_t v9 = v3;
      }
      else {
        size_t v9 = a3 - v50;
      }
      size_t v10 = v9;
    }
    else
    {
      size_t v10 = 0;
    }
    size_t v51 = v50 + v10;
  }
  if ((v48 & 0x10000000000) != 0)
  {
    int v35 = __snprintf_chk(&a2[v51], a3 - v51, 0, 0xFFFFFFFFFFFFFFFFLL, ", pending-barrier");
    if (v35 >= 0)
    {
      if (v35 <= a3 - v51) {
        size_t v7 = v35;
      }
      else {
        size_t v7 = a3 - v51;
      }
      size_t v8 = v7;
    }
    else
    {
      size_t v8 = 0;
    }
    v51 += v8;
  }
  if ((*(_DWORD *)(a1 + 80) & 0x40000) != 0 && (*(_DWORD *)(a1 + 80) & 0x1000000) == 0)
  {
    int v34 = __snprintf_chk(&a2[v51], a3 - v51, 0, 0xFFFFFFFFFFFFFFFFLL, ", thread = 0x%x ", v57);
    if (v34 >= 0)
    {
      if (v34 <= a3 - v51) {
        size_t v5 = v34;
      }
      else {
        size_t v5 = a3 - v51;
      }
      size_t v6 = v5;
    }
    else
    {
      size_t v6 = 0;
    }
    v51 += v6;
  }
  return v51;
}

size_t _dispatch_queue_debug(const char **a1, char *a2, size_t a3)
{
  if (a1[9])
  {
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", a1[9], a1);
  }
  else
  {
    size_t v9 = 0;
    if (*a1) {
      size_t v9 = *a1;
    }
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *((const char **)v9 + 3), a1);
  }
  if (v3 >= 0)
  {
    if (v3 <= a3) {
      size_t v7 = v3;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }
  else
  {
    size_t v8 = 0;
  }
  size_t v12 = v8 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v8], a3 - v8);
  size_t v13 = v12 + _dispatch_queue_debug_attr((uint64_t)a1, &a2[v12], a3 - v12);
  int v10 = __snprintf_chk(&a2[v13], a3 - v13, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v10 >= 0)
  {
    if (v10 <= a3 - v13) {
      size_t v5 = v10;
    }
    else {
      size_t v5 = a3 - v13;
    }
    size_t v6 = v5;
  }
  else
  {
    size_t v6 = 0;
  }
  return v13 + v6;
}

size_t _dispatch_channel_debug(_DWORD *a1, char *a2, size_t a3)
{
  int v17 = a1[20];
  uint64_t v11 = 0;
  if (*(void *)a1) {
    uint64_t v11 = *(void *)a1;
  }
  int v13 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v11 + 24), a1);
  if (v13 >= 0)
  {
    if (v13 <= a3) {
      size_t v9 = v13;
    }
    else {
      size_t v9 = a3;
    }
    size_t v10 = v9;
  }
  else
  {
    size_t v10 = 0;
  }
  size_t v15 = v10 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v10], a3 - v10);
  size_t v16 = v15 + _dispatch_queue_debug_attr((uint64_t)a1, &a2[v15], a3 - v15);
  if ((v17 & 0x10000000) != 0) {
    int v3 = "cancelled, ";
  }
  else {
    int v3 = "";
  }
  if ((v17 & 0x40000000) != 0) {
    size_t v4 = "needs-event, ";
  }
  else {
    size_t v4 = "";
  }
  size_t v5 = "deleted, ";
  if (v17 >= 0) {
    size_t v5 = "";
  }
  int v12 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%s", v3, v4, v5);
  if (v12 >= 0)
  {
    if (v12 <= a3) {
      size_t v7 = v12;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }
  else
  {
    size_t v8 = 0;
  }
  return v16 + v8;
}

size_t _dispatch_source_debug(uint64_t *a1, char *a2, size_t a3)
{
  size_t v16 = (unsigned char *)a1[11];
  uint64_t v10 = 0;
  if (*a1) {
    uint64_t v10 = *a1;
  }
  int v12 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v10 + 24), a1);
  if (v12 >= 0)
  {
    if (v12 <= a3) {
      size_t v8 = v12;
    }
    else {
      size_t v8 = a3;
    }
    size_t v9 = v8;
  }
  else
  {
    size_t v9 = 0;
  }
  size_t v14 = v9 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v9], a3 - v9);
  size_t v15 = v14 + _dispatch_source_debug_attr((uint64_t)a1, &a2[v14], a3 - v14);
  if ((v16[29] & 2) != 0) {
    v15 += _dispatch_timer_debug_attr((uint64_t)a1, &a2[v15], a3 - v15);
  }
  int v3 = " (direct)";
  if ((v16[29] & 1) == 0) {
    int v3 = "";
  }
  size_t v7 = 0;
  if (*(void *)v16) {
    size_t v7 = *(const char ***)v16;
  }
  int v11 = __snprintf_chk(&a2[v15], a3 - v15, 0, 0xFFFFFFFFFFFFFFFFLL, "kevent = %p%s, filter = %s }", v16, v3, *v7);
  if (v11 >= 0)
  {
    if (v11 <= a3 - v15) {
      size_t v5 = v11;
    }
    else {
      size_t v5 = a3 - v15;
    }
    size_t v6 = v5;
  }
  else
  {
    size_t v6 = 0;
  }
  return v15 + v6;
}

unint64_t _dispatch_source_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v27 = a1;
  size_t v26 = a2;
  size_t v25 = a3;
  size_t v24 = 0;
  size_t v24 = *(void **)(a1 + 24);
  uint64_t v23 = 0;
  uint64_t v23 = *(void *)(a1 + 88);
  int v22 = 0;
  uint64_t v21 = a1;
  uint64_t v31 = a1;
  int v30 = 0;
  int v29 = *(_DWORD *)(a1 + 80);
  int v30 = v29;
  int v28 = v29;
  int v22 = v29;
  uint64_t v20 = 0;
  uint64_t v19 = v23;
  uint64_t v35 = v23;
  uint64_t v34 = 0;
  uint64_t v33 = *(void *)(v23 + 16);
  uint64_t v34 = v33;
  uint64_t v32 = v33;
  uint64_t v20 = v33;
  unint64_t v18 = a3;
  int v17 = 0;
  size_t v15 = a2;
  size_t v16 = a3;
  if (v24 && v24[9]) {
    size_t v14 = (const char *)v24[9];
  }
  else {
    size_t v14 = "";
  }
  int v3 = *(_DWORD *)(v23 + 24);
  int v4 = *(_DWORD *)(v23 + 32);
  uint64_t v5 = *(void *)(v23 + 72);
  uint64_t v37 = v20;
  uint64_t v36 = v20;
  if ((v22 & 0x10000000) != 0) {
    size_t v6 = "cancelled, ";
  }
  else {
    size_t v6 = "";
  }
  if ((v22 & 0x40000000) != 0) {
    size_t v7 = "needs-event, ";
  }
  else {
    size_t v7 = "";
  }
  size_t v8 = "deleted, ";
  if (v22 >= 0) {
    size_t v8 = "";
  }
  int v13 = &v10;
  int v17 = __snprintf_chk(v15, v16, 0, 0xFFFFFFFFFFFFFFFFLL, "target = %s[%p], ident = 0x%x, mask = 0x%x, pending_data = 0x%llx, registered = %d, armed = %d, %s%s%s", v14, v24, v3, v4, v5, v20 != 0, (v20 & 1) != 0, v6, v7, v8);
  if (v17 < 0) {
    return 0;
  }
  if (v17 <= v18) {
    return v17;
  }
  else {
    return v18;
  }
}

size_t _dispatch_timer_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v6 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "timer = { target = 0x%llx, deadline = 0x%llx, interval = 0x%llx, flags = 0x%x }, ", *(void *)(*(void *)(a1 + 88) + 80), *(void *)(*(void *)(a1 + 88) + 88), *(void *)(*(void *)(a1 + 88) + 96), *(unsigned __int8 *)(*(void *)(a1 + 88) + 30));
  if (v6 < 0) {
    return 0;
  }
  if (v6 <= a3) {
    return v6;
  }
  else {
    return a3;
  }
}

uint64_t _dispatch_mach_msg_debug(_DWORD *a1, char *a2, size_t a3)
{
  uint64_t v28 = 0;
  if (*(void *)a1) {
    uint64_t v28 = *(void *)a1;
  }
  int v41 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v28 + 24), a1);
  if (v41 >= 0)
  {
    if (v41 <= a3) {
      size_t v26 = v41;
    }
    else {
      size_t v26 = a3;
    }
    size_t v27 = v26;
  }
  else
  {
    size_t v27 = 0;
  }
  size_t v43 = v27 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v27], a3 - v27);
  int v40 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "opts/err = 0x%x, msgh[%p] = { ", a1[12], a1 + 22);
  if (v40 >= 0)
  {
    if (v40 <= a3 - v43) {
      size_t v24 = v40;
    }
    else {
      size_t v24 = a3 - v43;
    }
    size_t v25 = v24;
  }
  else
  {
    size_t v25 = 0;
  }
  size_t v44 = v43 + v25;
  uint64_t msg = (_DWORD *)_dispatch_mach_msg_get_msg((uint64_t)a1);
  if (msg[5])
  {
    int v38 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "id 0x%x, ", msg[5]);
    if (v38 >= 0)
    {
      if (v38 <= a3 - v44) {
        size_t v22 = v38;
      }
      else {
        size_t v22 = a3 - v44;
      }
      size_t v23 = v22;
    }
    else
    {
      size_t v23 = 0;
    }
    v44 += v23;
  }
  if (msg[1])
  {
    int v37 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "size %u, ", msg[1]);
    if (v37 >= 0)
    {
      if (v37 <= a3 - v44) {
        size_t v20 = v37;
      }
      else {
        size_t v20 = a3 - v44;
      }
      size_t v21 = v20;
    }
    else
    {
      size_t v21 = 0;
    }
    v44 += v21;
  }
  if (*msg)
  {
    int v36 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "bits <l %u, r %u", (*msg & 0x1F00u) >> 8, *msg & 0x1F);
    if (v36 >= 0)
    {
      if (v36 <= a3 - v44) {
        size_t v18 = v36;
      }
      else {
        size_t v18 = a3 - v44;
      }
      size_t v19 = v18;
    }
    else
    {
      size_t v19 = 0;
    }
    size_t v45 = v44 + v19;
    if ((*msg & 0xFFE0E0E0) != 0)
    {
      int v35 = __snprintf_chk(&a2[v45], a3 - v45, 0, 0xFFFFFFFFFFFFFFFFLL, ", o 0x%x", *msg & 0xFFE0E0E0);
      if (v35 >= 0)
      {
        if (v35 <= a3 - v45) {
          size_t v16 = v35;
        }
        else {
          size_t v16 = a3 - v45;
        }
        size_t v17 = v16;
      }
      else
      {
        size_t v17 = 0;
      }
      v45 += v17;
    }
    int v34 = __snprintf_chk(&a2[v45], a3 - v45, 0, 0xFFFFFFFFFFFFFFFFLL, ">, ");
    if (v34 >= 0)
    {
      if (v34 <= a3 - v45) {
        size_t v14 = v34;
      }
      else {
        size_t v14 = a3 - v45;
      }
      size_t v15 = v14;
    }
    else
    {
      size_t v15 = 0;
    }
    size_t v44 = v45 + v15;
  }
  if (msg[3] && msg[2])
  {
    int v33 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "local 0x%x, remote 0x%x", msg[3], msg[2]);
    if (v33 >= 0)
    {
      if (v33 <= a3 - v44) {
        size_t v12 = v33;
      }
      else {
        size_t v12 = a3 - v44;
      }
      size_t v13 = v12;
    }
    else
    {
      size_t v13 = 0;
    }
    size_t v46 = v44 + v13;
  }
  else if (msg[3])
  {
    int v32 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "local 0x%x", msg[3]);
    if (v32 >= 0)
    {
      if (v32 <= a3 - v44) {
        size_t v10 = v32;
      }
      else {
        size_t v10 = a3 - v44;
      }
      size_t v11 = v10;
    }
    else
    {
      size_t v11 = 0;
    }
    size_t v46 = v44 + v11;
  }
  else if (msg[2])
  {
    int v31 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "remote 0x%x", msg[2]);
    if (v31 >= 0)
    {
      if (v31 <= a3 - v44) {
        size_t v8 = v31;
      }
      else {
        size_t v8 = a3 - v44;
      }
      size_t v9 = v8;
    }
    else
    {
      size_t v9 = 0;
    }
    size_t v46 = v44 + v9;
  }
  else
  {
    int v30 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, "no ports");
    if (v30 >= 0)
    {
      if (v30 <= a3 - v44) {
        size_t v6 = v30;
      }
      else {
        size_t v6 = a3 - v44;
      }
      size_t v7 = v6;
    }
    else
    {
      size_t v7 = 0;
    }
    size_t v46 = v44 + v7;
  }
  int v29 = __snprintf_chk(&a2[v46], a3 - v46, 0, 0xFFFFFFFFFFFFFFFFLL, " } }");
  if (v29 >= 0)
  {
    if (v29 <= a3 - v46) {
      size_t v4 = v29;
    }
    else {
      size_t v4 = a3 - v46;
    }
    size_t v5 = v4;
  }
  else
  {
    size_t v5 = 0;
  }
  return v46 + v5;
}

size_t _dispatch_mach_debug(void *a1, char *a2, size_t a3)
{
  if (!a1[9] || ((*((_WORD *)a1 + 58) >> 3) & 1) != 0)
  {
    uint64_t v9 = 0;
    if (*a1) {
      uint64_t v9 = *a1;
    }
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v9 + 24), a1);
  }
  else
  {
    int v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", (const char *)a1[9], a1);
  }
  if (v3 >= 0)
  {
    if (v3 <= a3) {
      size_t v7 = v3;
    }
    else {
      size_t v7 = a3;
    }
    size_t v8 = v7;
  }
  else
  {
    size_t v8 = 0;
  }
  size_t v12 = v8 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v8], a3 - v8);
  size_t v13 = v12 + _dispatch_mach_debug_attr(a1, &a2[v12], a3 - v12);
  int v10 = __snprintf_chk(&a2[v13], a3 - v13, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v10 >= 0)
  {
    if (v10 <= a3 - v13) {
      size_t v5 = v10;
    }
    else {
      size_t v5 = a3 - v13;
    }
    size_t v6 = v5;
  }
  else
  {
    size_t v6 = 0;
  }
  return v13 + v6;
}

unint64_t _dispatch_mach_debug_attr(void *a1, char *a2, size_t a3)
{
  int v30 = a1;
  int v29 = a2;
  size_t v28 = a3;
  size_t v27 = 0;
  size_t v27 = (void *)a1[3];
  uint64_t v26 = 0;
  uint64_t v26 = a1[15];
  uint64_t v25 = 0;
  uint64_t v25 = a1[11];
  unint64_t v24 = a3;
  int v23 = 0;
  size_t v18 = a2;
  size_t v19 = a3;
  if (v27 && v27[9]) {
    size_t v17 = (const char *)v27[9];
  }
  else {
    size_t v17 = "";
  }
  int v3 = *(_DWORD *)(v25 + 24);
  int v4 = *(_DWORD *)(v26 + 92);
  int v5 = *(_DWORD *)(v26 + 24);
  char v22 = 0;
  char v21 = *(unsigned char *)(v26 + 30);
  char v22 = v21 & 1;
  char v20 = v21 & 1;
  if (v21) {
    size_t v6 = " (armed)";
  }
  else {
    size_t v6 = "";
  }
  int v7 = *(_DWORD *)(v26 + 96);
  if (*(void *)(v26 + 48)) {
    size_t v8 = " (pending)";
  }
  else {
    size_t v8 = "";
  }
  uint64_t v9 = *(void *)(v26 + 64);
  int v10 = *(_DWORD *)(v26 + 88);
  BOOL v11 = (v30[10] & 0x10000000) != 0;
  size_t v16 = &v13;
  int v23 = __snprintf_chk(v18, v19, 0, 0xFFFFFFFFFFFFFFFFLL, "target = %s[%p], receive = 0x%x, send = 0x%x, send-possible = 0x%x%s, checkin = 0x%x%s, send state = %016llx, disconnected = %d, canceled = %d ", v17, v27, v3, v4, v5, v6, v7, v8, v9, v10, v11);
  if (v23 < 0) {
    return 0;
  }
  if (v23 <= v24) {
    return v23;
  }
  else {
    return v24;
  }
}

unint64_t voucher_kvoucher_debug(ipc_space_read_t a1, mach_port_name_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const char *a6, unint64_t a7)
{
  kern_return_t error_value;
  unsigned int object_type;
  unsigned int object_addr;
  mach_msg_type_number_t recipesCnt[2];
  unint64_t v49;
  const char *v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  mach_port_name_t name;
  ipc_space_read_t task;
  uint8_t recipes[8192];

  tasint k = a1;
  mach_port_name_t name = a2;
  uint64_t v53 = a3;
  BOOL v52 = a4;
  size_t v51 = a5;
  size_t v50 = a6;
  BOOL v49 = a7;
  bzero(recipes, 0x2000uLL);
  *(void *)recipesCnt = 0x2000;
  object_addr = 0;
  object_type = 0;
  if (mach_port_kernel_object(task, name, &object_type, &object_addr) || object_type != 37)
  {
    if (v50)
    {
      if (v52 <= v51) {
        size_t v14 = 0;
      }
      else {
        size_t v14 = v52 - v51;
      }
      int v36 = __snprintf_chk((char *)(v53 + v51), v14, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
      if (v36 >= 0)
      {
        if (v36 <= v14) {
          size_t v12 = v36;
        }
        else {
          size_t v12 = v14;
        }
        size_t v13 = v12;
      }
      else
      {
        size_t v13 = 0;
      }
      v51 += v13;
    }
    if (v52 <= v51) {
      size_t v11 = 0;
    }
    else {
      size_t v11 = v52 - v51;
    }
    int v35 = __snprintf_chk((char *)(v53 + v51), v11, 0, 0xFFFFFFFFFFFFFFFFLL, "Invalid voucher: 0x%x\n", name);
    if (v35 >= 0)
    {
      if (v35 <= v11) {
        size_t v9 = v35;
      }
      else {
        size_t v9 = v11;
      }
      size_t v10 = v9;
    }
    else
    {
      size_t v10 = 0;
    }
    v51 += v10;
  }
  else
  {
    mach_error_t error_value = mach_voucher_debug_info(task, name, recipes, recipesCnt);
    if (!error_value || error_value == 46)
    {
      if (*(void *)recipesCnt)
      {
        if (v50)
        {
          if (v52 <= v51) {
            size_t v20 = 0;
          }
          else {
            size_t v20 = v52 - v51;
          }
          int v40 = __snprintf_chk((char *)(v53 + v51), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
          if (v40 >= 0)
          {
            if (v40 <= v20) {
              size_t v18 = v40;
            }
            else {
              size_t v18 = v20;
            }
            size_t v19 = v18;
          }
          else
          {
            size_t v19 = 0;
          }
          v51 += v19;
        }
        if (v52 <= v51) {
          size_t v17 = 0;
        }
        else {
          size_t v17 = v52 - v51;
        }
        int v39 = __snprintf_chk((char *)(v53 + v51), v17, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x\n", object_addr);
        if (v39 >= 0)
        {
          if (v39 <= v17) {
            size_t v15 = v39;
          }
          else {
            size_t v15 = v17;
          }
          size_t v16 = v15;
        }
        else
        {
          size_t v16 = 0;
        }
        v51 += v16;
        for (unsigned int i = 0; *(void *)recipesCnt > (unint64_t)i; i += *((_DWORD *)v37 + 3) + 16)
        {
          int v37 = &recipes[i];
          if (*(_DWORD *)v37) {
            size_t v51 = format_recipe_detail((uint64_t)v37, v53, v52, v51, v50, v49);
          }
        }
      }
      else
      {
        if (v50)
        {
          if (v52 <= v51) {
            size_t v26 = 0;
          }
          else {
            size_t v26 = v52 - v51;
          }
          int v42 = __snprintf_chk((char *)(v53 + v51), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
          if (v42 >= 0)
          {
            if (v42 <= v26) {
              size_t v24 = v42;
            }
            else {
              size_t v24 = v26;
            }
            size_t v25 = v24;
          }
          else
          {
            size_t v25 = 0;
          }
          v51 += v25;
        }
        if (v52 <= v51) {
          size_t v23 = 0;
        }
        else {
          size_t v23 = v52 - v51;
        }
        int v41 = __snprintf_chk((char *)(v53 + v51), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x has no contents\n", object_addr);
        if (v41 >= 0)
        {
          if (v41 <= v23) {
            size_t v21 = v41;
          }
          else {
            size_t v21 = v23;
          }
          size_t v22 = v21;
        }
        else
        {
          size_t v22 = 0;
        }
        v51 += v22;
      }
    }
    else
    {
      if (v50)
      {
        if (v52 <= v51) {
          size_t v34 = 0;
        }
        else {
          size_t v34 = v52 - v51;
        }
        int v44 = __snprintf_chk((char *)(v53 + v51), v34, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
        if (v44 >= 0)
        {
          if (v44 <= v34) {
            size_t v32 = v44;
          }
          else {
            size_t v32 = v34;
          }
          size_t v33 = v32;
        }
        else
        {
          size_t v33 = 0;
        }
        v51 += v33;
      }
      if (v52 <= v51) {
        size_t v31 = 0;
      }
      else {
        size_t v31 = v52 - v51;
      }
      int v30 = (char *)(v53 + v51);
      unsigned int v29 = object_addr;
      int v7 = mach_error_string(error_value);
      int v43 = __snprintf_chk(v30, v31, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x Failed to get contents %s\n", v29, v7);
      if (v43 >= 0)
      {
        if (v43 <= v31) {
          size_t v27 = v43;
        }
        else {
          size_t v27 = v31;
        }
        size_t v28 = v27;
      }
      else
      {
        size_t v28 = 0;
      }
      v51 += v28;
    }
  }
  return v51;
}

size_t _dispatch_io_debug(uint64_t *a1, char *a2, size_t a3)
{
  uint64_t v8 = 0;
  if (*a1) {
    uint64_t v8 = *a1;
  }
  int v10 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v8 + 24), a1);
  if (v10 >= 0)
  {
    if (v10 <= a3) {
      size_t v6 = v10;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = v6;
  }
  else
  {
    size_t v7 = 0;
  }
  size_t v12 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  size_t v13 = v12 + _dispatch_io_debug_attr((uint64_t)a1, &a2[v12], a3 - v12);
  int v9 = __snprintf_chk(&a2[v13], a3 - v13, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v9 >= 0)
  {
    if (v9 <= a3 - v13) {
      size_t v4 = v9;
    }
    else {
      size_t v4 = a3 - v13;
    }
    size_t v5 = v4;
  }
  else
  {
    size_t v5 = 0;
  }
  return v13 + v5;
}

unint64_t _dispatch_io_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v31 = a1;
  int v30 = a2;
  size_t v29 = a3;
  size_t v28 = 0;
  size_t v28 = *(void **)(a1 + 24);
  unint64_t v27 = a3;
  int v26 = 0;
  size_t v22 = a2;
  size_t v23 = a3;
  int v3 = "stream";
  if (*(void *)(a1 + 72)) {
    int v3 = "random";
  }
  size_t v24 = v3;
  uint64_t v25 = *(int *)(v31 + 128);
  if ((*(_DWORD *)(v31 + 120) & 2) != 0)
  {
    size_t v21 = "stopped, ";
  }
  else
  {
    size_t v4 = "closed, ";
    if ((*(_DWORD *)(v31 + 120) & 1) == 0) {
      size_t v4 = "";
    }
    size_t v21 = v4;
  }
  size_t v18 = v21;
  size_t v19 = *(const void **)(v31 + 112);
  size_t v20 = *(const void **)(v31 + 48);
  if (v28 && v28[9]) {
    size_t v17 = (const char *)v28[9];
  }
  else {
    size_t v17 = "";
  }
  size_t v5 = *(const void **)(v31 + 56);
  size_t v6 = *(const void **)(v31 + 64);
  int v7 = *(_DWORD *)(v31 + 144);
  uint64_t v8 = *(void *)(v31 + 80);
  uint64_t v9 = *(void *)(v31 + 88);
  if (*(void *)(v31 + 104)) {
    int v10 = "(strict)";
  }
  else {
    int v10 = "";
  }
  uint64_t v11 = *(void *)(v31 + 96);
  size_t v16 = &v13;
  int v26 = __snprintf_chk(v22, v23, 0, 0xFFFFFFFFFFFFFFFFLL, "type = %s, fd = 0x%lx, %sfd_entry = %p, queue = %p, target = %s[%p], barrier_queue = %p, barrier_group = %p, err = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ", v24, v25, v18, v19, v20, v17, v28, v5, v6, v7, v8, v9, v10,
          v11);
  if (v26 < 0) {
    return 0;
  }
  if (v26 <= v27) {
    return v26;
  }
  else {
    return v27;
  }
}

size_t _dispatch_operation_debug(uint64_t *a1, char *a2, size_t a3)
{
  uint64_t v8 = 0;
  if (*a1) {
    uint64_t v8 = *a1;
  }
  int v10 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(v8 + 24), a1);
  if (v10 >= 0)
  {
    if (v10 <= a3) {
      size_t v6 = v10;
    }
    else {
      size_t v6 = a3;
    }
    size_t v7 = v6;
  }
  else
  {
    size_t v7 = 0;
  }
  size_t v12 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  size_t v13 = v12 + _dispatch_operation_debug_attr((uint64_t)a1, &a2[v12], a3 - v12);
  int v9 = __snprintf_chk(&a2[v13], a3 - v13, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v9 >= 0)
  {
    if (v9 <= a3 - v13) {
      size_t v4 = v9;
    }
    else {
      size_t v4 = a3 - v13;
    }
    size_t v5 = v4;
  }
  else
  {
    size_t v5 = 0;
  }
  return v13 + v5;
}

unint64_t _dispatch_operation_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v40 = a1;
  int v39 = a2;
  size_t v38 = a3;
  int v37 = 0;
  int v37 = *(void **)(a1 + 24);
  int v36 = 0;
  if (*(void *)(a1 + 48)) {
    size_t v33 = *(void **)(*(void *)(v40 + 48) + 24);
  }
  else {
    size_t v33 = 0;
  }
  int v36 = v33;
  unint64_t v35 = v38;
  int v34 = 0;
  size_t v29 = v39;
  size_t v30 = v38;
  int v3 = "stream";
  if (*(void *)(v40 + 64)) {
    int v3 = "random";
  }
  uint64_t v31 = v3;
  size_t v4 = "read";
  if (*(_DWORD *)(v40 + 56)) {
    size_t v4 = "write";
  }
  size_t v32 = v4;
  if (*(void *)(v40 + 144)) {
    int v28 = **(_DWORD **)(v40 + 144);
  }
  else {
    int v28 = -1;
  }
  uint64_t v24 = v28;
  uint64_t v25 = *(const void **)(v40 + 144);
  int v26 = *(const void **)(v40 + 136);
  unint64_t v27 = *(const void **)(v40 + 48);
  if (v36 && v36[9]) {
    size_t v23 = (const char *)v36[9];
  }
  else {
    size_t v23 = "";
  }
  size_t v21 = v23;
  size_t v22 = v36;
  if (v37 && v37[9]) {
    size_t v20 = (const char *)v37[9];
  }
  else {
    size_t v20 = "";
  }
  uint64_t v5 = *(void *)(v40 + 104);
  uint64_t v6 = *(void *)(v40 + 112);
  uint64_t v7 = *(void *)(v40 + 216);
  uint64_t v8 = *(void *)(v40 + 208) + *(void *)(v40 + 200);
  int v9 = *(_DWORD *)(v40 + 184);
  int v10 = *(_DWORD *)(v40 + 120);
  uint64_t v11 = *(void *)(v40 + 72);
  uint64_t v12 = *(void *)(v40 + 80);
  if (*(void *)(v40 + 96)) {
    size_t v13 = "(strict)";
  }
  else {
    size_t v13 = "";
  }
  uint64_t v14 = *(void *)(v40 + 88);
  size_t v19 = &v16;
  int v34 = __snprintf_chk(v29, v30, 0, 0xFFFFFFFFFFFFFFFFLL, "type = %s %s, fd = 0x%lx, fd_entry = %p, channel = %p, queue = %p -> %s[%p], target = %s[%p], offset = %lld, length = %zu, done = %zu, undelivered = %zu, flags = %u, err = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ", v31, v32, v24, v25, v26, v27, v21, v22, v20, v37, v5, v6, v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14);
  if (v34 < 0) {
    return 0;
  }
  if (v34 <= v35) {
    return v34;
  }
  else {
    return v35;
  }
}

size_t _dispatch_data_debug(uint64_t a1, char *a2, size_t a3)
{
  int v27 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "data[%p] = { ", (const void *)a1);
  if (v27 >= 0)
  {
    if (v27 <= a3) {
      size_t v20 = v27;
    }
    else {
      size_t v20 = a3;
    }
    size_t v21 = v20;
  }
  else
  {
    size_t v21 = 0;
  }
  if (*(void *)(a1 + 72))
  {
    uint64_t v14 = &a2[v21];
    size_t v15 = a3 - v21;
    uint64_t v16 = *(void *)(a1 + 64);
    uint64_t v17 = *(void *)(a1 + 72);
    if (v17) {
      int v3 = __snprintf_chk(v14, v15, 0, 0xFFFFFFFFFFFFFFFFLL, "composite, size = %zd, num_records = %zd ", v16, v17);
    }
    else {
      int v3 = __snprintf_chk(v14, v15, 0, 0xFFFFFFFFFFFFFFFFLL, "composite, size = %zd, num_records = %zd ", v16, 1uLL);
    }
    if (v3 >= 0)
    {
      if (v3 <= a3 - v21) {
        size_t v12 = v3;
      }
      else {
        size_t v12 = a3 - v21;
      }
      size_t v13 = v12;
    }
    else
    {
      size_t v13 = 0;
    }
    size_t v29 = v21 + v13;
    if (*(void *)(a1 + 48))
    {
      int v25 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, ", flatbuf = %p ", *(const void **)(a1 + 48));
      if (v25 >= 0)
      {
        if (v25 <= a3 - v29) {
          size_t v10 = v25;
        }
        else {
          size_t v10 = a3 - v29;
        }
        size_t v11 = v10;
      }
      else
      {
        size_t v11 = 0;
      }
      v29 += v11;
    }
    for (unint64_t i = 0; ; ++i)
    {
      unint64_t v9 = *(void *)(a1 + 72) ? *(void *)(a1 + 72) : 1;
      if (i >= v9) {
        break;
      }
      int v23 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, "record[%zd] = { from = %zd, length = %zd, data_object = %p }, ", i, *(void *)(a1 + 80 + 24 * i + 8), *(void *)(a1 + 80 + 24 * i + 16), *(const void **)(a1 + 80 + 24 * i));
      if (v23 >= 0)
      {
        if (v23 <= a3 - v29) {
          size_t v7 = v23;
        }
        else {
          size_t v7 = a3 - v29;
        }
        size_t v8 = v7;
      }
      else
      {
        size_t v8 = 0;
      }
      v29 += v8;
    }
  }
  else
  {
    int v26 = __snprintf_chk(&a2[v21], a3 - v21, 0, 0xFFFFFFFFFFFFFFFFLL, "leaf, size = %zd, buf = %p ", *(void *)(a1 + 64), *(const void **)(a1 + 48));
    if (v26 >= 0)
    {
      if (v26 <= a3 - v21) {
        size_t v18 = v26;
      }
      else {
        size_t v18 = a3 - v21;
      }
      size_t v19 = v18;
    }
    else
    {
      size_t v19 = 0;
    }
    size_t v29 = v21 + v19;
  }
  int v22 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v22 >= 0)
  {
    if (v22 <= a3 - v29) {
      size_t v5 = v22;
    }
    else {
      size_t v5 = a3 - v29;
    }
    size_t v6 = v5;
  }
  else
  {
    size_t v6 = 0;
  }
  return v29 + v6;
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

uint64_t __bsdthread_ctl()
{
  return ___bsdthread_ctl();
}

int *__error(void)
{
  return ___error();
}

uint64_t __libkernel_voucher_init()
{
  return ___libkernel_voucher_init();
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __memset_chk()
{
  return ___memset_chk();
}

int __snprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, ...)
{
  return ___snprintf_chk(a1, a2, a3, a4, a5);
}

uint64_t __strlcat_chk()
{
  return ___strlcat_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

uint64_t __udivti3()
{
  return ___udivti3();
}

uint64_t __ulock_wait()
{
  return ___ulock_wait();
}

uint64_t __ulock_wake()
{
  return ___ulock_wake();
}

int __vsnprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, va_list a6)
{
  return ___vsnprintf_chk(a1, a2, a3, a4, a5, a6);
}

uint64_t __work_interval_ctl()
{
  return ___work_interval_ctl();
}

uint64_t _dyld_is_memory_immutable()
{
  return __dyld_is_memory_immutable();
}

uint64_t _os_assert_log()
{
  return __os_assert_log();
}

uint64_t _os_assumes_log()
{
  return __os_assumes_log();
}

uint64_t _os_crash()
{
  return __os_crash();
}

uint64_t _os_semaphore_create()
{
  return __os_semaphore_create();
}

uint64_t _os_semaphore_dispose()
{
  return __os_semaphore_dispose();
}

uint64_t _pthread_qos_class_encode()
{
  return __pthread_qos_class_encode();
}

uint64_t _pthread_qos_override_end_direct()
{
  return __pthread_qos_override_end_direct();
}

uint64_t _pthread_qos_override_start_direct()
{
  return __pthread_qos_override_start_direct();
}

uint64_t _pthread_set_properties_self()
{
  return __pthread_set_properties_self();
}

uint64_t _pthread_workloop_create()
{
  return __pthread_workloop_create();
}

uint64_t _pthread_workloop_destroy()
{
  return __pthread_workloop_destroy();
}

uint64_t _pthread_workqueue_add_cooperativethreads()
{
  return __pthread_workqueue_add_cooperativethreads();
}

uint64_t _pthread_workqueue_addthreads()
{
  return __pthread_workqueue_addthreads();
}

uint64_t _pthread_workqueue_allow_send_signals()
{
  return __pthread_workqueue_allow_send_signals();
}

uint64_t _pthread_workqueue_override_reset()
{
  return __pthread_workqueue_override_reset();
}

uint64_t _pthread_workqueue_override_start_direct()
{
  return __pthread_workqueue_override_start_direct();
}

uint64_t _pthread_workqueue_override_start_direct_check_owner()
{
  return __pthread_workqueue_override_start_direct_check_owner();
}

uint64_t _pthread_workqueue_set_event_manager_priority()
{
  return __pthread_workqueue_set_event_manager_priority();
}

uint64_t _pthread_workqueue_supported()
{
  return __pthread_workqueue_supported();
}

uint64_t _pthread_yield_to_enqueuer_4dispatch()
{
  return __pthread_yield_to_enqueuer_4dispatch();
}

uint64_t _simple_asl_log()
{
  return __simple_asl_log();
}

void abort(void)
{
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

void bzero(void *a1, size_t a2)
{
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return _clock_gettime_nsec_np(__clock_id);
}

uint64_t close_NOCANCEL()
{
  return _close_NOCANCEL();
}

int dprintf(int a1, const char *a2, ...)
{
  return _dprintf(a1, a2);
}

uint64_t fcntl_NOCANCEL()
{
  return _fcntl_NOCANCEL();
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

pid_t getpid(void)
{
  return _getpid();
}

const char *getprogname(void)
{
  return _getprogname();
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

uint64_t guarded_close_np()
{
  return _guarded_close_np();
}

uint64_t guarded_kqueue_np()
{
  return _guarded_kqueue_np();
}

uint64_t guarded_open_np()
{
  return _guarded_open_np();
}

kern_return_t host_create_mach_voucher(host_t host, mach_voucher_attr_raw_recipe_array_t recipes, mach_msg_type_number_t recipesCnt, ipc_voucher_t *voucher)
{
  return _host_create_mach_voucher(host, recipes, recipesCnt, voucher);
}

kern_return_t host_get_special_port(host_priv_t host_priv, int node, int which, mach_port_t *port)
{
  return _host_get_special_port(host_priv, node, which, port);
}

kern_return_t host_request_notification(host_t host, host_flavor_t notify_type, mach_port_t notify_port)
{
  return _host_request_notification(host, notify_type, notify_port);
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

uint64_t kevent_id()
{
  return _kevent_id();
}

uint64_t kevent_qos()
{
  return _kevent_qos();
}

uint64_t kpersona_get()
{
  return _kpersona_get();
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

int lstat(const char *a1, stat *a2)
{
  return _lstat(a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_continuous_approximate_time(void)
{
  return _mach_continuous_approximate_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return _mach_error_string(error_value);
}

uint64_t mach_eventlink_associate()
{
  return _mach_eventlink_associate();
}

uint64_t mach_eventlink_create()
{
  return _mach_eventlink_create();
}

uint64_t mach_eventlink_destroy()
{
  return _mach_eventlink_destroy();
}

uint64_t mach_eventlink_disassociate()
{
  return _mach_eventlink_disassociate();
}

uint64_t mach_eventlink_signal()
{
  return _mach_eventlink_signal();
}

uint64_t mach_eventlink_signal_wait_until()
{
  return _mach_eventlink_signal_wait_until();
}

uint64_t mach_eventlink_wait_until()
{
  return _mach_eventlink_wait_until();
}

kern_return_t mach_generate_activity_id(mach_port_name_t target, int count, uint64_t *activity_id)
{
  return _mach_generate_activity_id(target, count, activity_id);
}

uint64_t mach_get_times()
{
  return _mach_get_times();
}

mach_port_t mach_host_self(void)
{
  return _mach_host_self();
}

kern_return_t mach_make_memory_entry_64(vm_map_t target_task, memory_object_size_t *size, memory_object_offset_t offset, vm_prot_t permission, mach_port_t *object_handle, mem_entry_name_port_t parent_entry)
{
  return _mach_make_memory_entry_64(target_task, size, offset, permission, object_handle, parent_entry);
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return _mach_msg(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
}

uint64_t mach_msg2_internal()
{
  return _mach_msg2_internal();
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  return _mach_port_construct(task, options, context, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return _mach_port_destruct(task, name, srdelta, guard);
}

kern_return_t mach_port_kernel_object(ipc_space_read_t task, mach_port_name_t name, unsigned int *object_type, unsigned int *object_addr)
{
  return _mach_port_kernel_object(task, name, object_type, object_addr);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return _mach_port_mod_refs(task, name, right, delta);
}

kern_return_t mach_port_request_notification(ipc_space_t task, mach_port_name_t name, mach_msg_id_t msgid, mach_port_mscount_t sync, mach_port_t notify, mach_msg_type_name_t notifyPoly, mach_port_t *previous)
{
  return _mach_port_request_notification(task, name, msgid, sync, notify, notifyPoly, previous);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags)
{
  return _mach_vm_allocate(target, address, size, flags);
}

kern_return_t mach_vm_deallocate(vm_map_t target, mach_vm_address_t address, mach_vm_size_t size)
{
  return _mach_vm_deallocate(target, address, size);
}

kern_return_t mach_vm_map(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, mem_entry_name_port_t object, memory_object_offset_t offset, BOOLean_t copy, vm_prot_t cur_protection, vm_prot_t max_protection, vm_inherit_t inheritance)
{
  return _mach_vm_map(target_task, address, size, mask, flags, object, offset, copy, cur_protection, max_protection, inheritance);
}

kern_return_t mach_voucher_attr_command(ipc_voucher_t voucher, mach_voucher_attr_key_t key, mach_voucher_attr_command_t command, mach_voucher_attr_content_t in_content, mach_msg_type_number_t in_contentCnt, mach_voucher_attr_content_t out_content, mach_msg_type_number_t *out_contentCnt)
{
  return _mach_voucher_attr_command(voucher, key, command, in_content, in_contentCnt, out_content, out_contentCnt);
}

kern_return_t mach_voucher_deallocate(mach_port_name_t voucher)
{
  return _mach_voucher_deallocate(voucher);
}

kern_return_t mach_voucher_debug_info(ipc_space_t task, mach_port_name_t voucher_name, mach_voucher_attr_raw_recipe_array_t recipes, mach_msg_type_number_t *recipesCnt)
{
  return _mach_voucher_debug_info(task, voucher_name, recipes, recipesCnt);
}

int madvise(void *a1, size_t a2, int a3)
{
  return _madvise(a1, a2, a3);
}

uint64_t malloc_engaged_nano()
{
  return _malloc_engaged_nano();
}

uint64_t malloc_memory_event_handler()
{
  return _malloc_memory_event_handler();
}

uint64_t malloc_type_calloc()
{
  return _malloc_type_calloc();
}

uint64_t malloc_type_malloc()
{
  return _malloc_type_malloc();
}

uint64_t malloc_type_posix_memalign()
{
  return _malloc_type_posix_memalign();
}

uint64_t malloc_type_realloc()
{
  return _malloc_type_realloc();
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

uint64_t mig_dealloc_special_reply_port()
{
  return _mig_dealloc_special_reply_port();
}

uint64_t mig_get_special_reply_port()
{
  return _mig_get_special_reply_port();
}

int mprotect(void *a1, size_t a2, int a3)
{
  return _mprotect(a1, a2, a3);
}

uint64_t open_NOCANCEL()
{
  return _open_NOCANCEL();
}

BOOL os_unfair_lock_trylock(os_unfair_lock_t lock)
{
  return _os_unfair_lock_trylock(lock);
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t pread_NOCANCEL()
{
  return _pread_NOCANCEL();
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return _pthread_attr_destroy(a1);
}

int pthread_attr_get_qos_class_np(pthread_attr_t *__attr, qos_class_t *__qos_class, int *__relative_priority)
{
  return _pthread_attr_get_qos_class_np(__attr, __qos_class, __relative_priority);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return _pthread_attr_getschedparam(a1, a2);
}

int pthread_attr_getschedpolicy(const pthread_attr_t *a1, int *a2)
{
  return _pthread_attr_getschedpolicy(a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return _pthread_attr_init(a1);
}

int pthread_attr_set_qos_class_np(pthread_attr_t *__attr, qos_class_t __qos_class, int __relative_priority)
{
  return _pthread_attr_set_qos_class_np(__attr, __qos_class, __relative_priority);
}

uint64_t pthread_attr_setcpupercent_np()
{
  return _pthread_attr_setcpupercent_np();
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return _pthread_attr_setdetachstate(a1, a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return _pthread_attr_setschedparam(a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return _pthread_attr_setschedpolicy(a1, a2);
}

uint64_t pthread_attr_setworkinterval_np()
{
  return _pthread_attr_setworkinterval_np();
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

void pthread_exit(void *a1)
{
}

void *__cdecl pthread_get_stackaddr_np(pthread_t a1)
{
  return _pthread_get_stackaddr_np(a1);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return _pthread_getspecific(a1);
}

uint64_t pthread_install_workgroup_functions_np()
{
  return _pthread_install_workgroup_functions_np();
}

uint64_t pthread_key_init_np()
{
  return _pthread_key_init_np();
}

int pthread_main_np(void)
{
  return _pthread_main_np();
}

uint64_t pthread_qos_max_parallelism()
{
  return _pthread_qos_max_parallelism();
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

int pthread_set_qos_class_self_np(qos_class_t __qos_class, int __relative_priority)
{
  return _pthread_set_qos_class_self_np(__qos_class, __relative_priority);
}

int pthread_setname_np(const char *a1)
{
  return _pthread_setname_np(a1);
}

int pthread_setschedparam(pthread_t a1, int a2, const sched_param *a3)
{
  return _pthread_setschedparam(a1, a2, a3);
}

int pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  return _pthread_sigmask(a1, a2, a3);
}

uint64_t pthread_time_constraint_max_parallelism()
{
  return _pthread_time_constraint_max_parallelism();
}

uint64_t pthread_workqueue_setup()
{
  return _pthread_workqueue_setup();
}

uint64_t pwrite_NOCANCEL()
{
  return _pwrite_NOCANCEL();
}

qos_class_t qos_class_main(void)
{
  return _qos_class_main();
}

uint64_t read_NOCANCEL()
{
  return _read_NOCANCEL();
}

kern_return_t semaphore_create(task_t task, semaphore_t *semaphore, int policy, int value)
{
  return _semaphore_create(task, semaphore, policy, value);
}

kern_return_t semaphore_destroy(task_t task, semaphore_t semaphore)
{
  return _semaphore_destroy(task, semaphore);
}

kern_return_t semaphore_signal(semaphore_t semaphore)
{
  return _semaphore_signal(semaphore);
}

kern_return_t semaphore_timedwait(semaphore_t semaphore, mach_timespec_t wait_time)
{
  return _semaphore_timedwait(semaphore, wait_time);
}

kern_return_t semaphore_wait(semaphore_t semaphore)
{
  return _semaphore_wait(semaphore);
}

uint64_t sigsuspend_NOCANCEL()
{
  return _sigsuspend_NOCANCEL();
}

uint64_t sleep_NOCANCEL()
{
  return _sleep_NOCANCEL();
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

kern_return_t task_get_special_port(task_inspect_t task, int which_port, mach_port_t *special_port)
{
  return _task_get_special_port(task, which_port, special_port);
}

uint64_t thread_destruct_special_reply_port()
{
  return _thread_destruct_special_reply_port();
}

uint64_t thread_get_special_reply_port()
{
  return _thread_get_special_reply_port();
}

kern_return_t thread_switch(mach_port_name_t thread_name, int option, mach_msg_timeout_t option_time)
{
  return _thread_switch(thread_name, option, option_time);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

uint64_t work_interval_copy_port()
{
  return _work_interval_copy_port();
}

uint64_t work_interval_create()
{
  return _work_interval_create();
}

uint64_t work_interval_destroy()
{
  return _work_interval_destroy();
}

uint64_t work_interval_get_flags_from_port()
{
  return _work_interval_get_flags_from_port();
}

uint64_t work_interval_instance_alloc()
{
  return _work_interval_instance_alloc();
}

uint64_t work_interval_instance_clear()
{
  return _work_interval_instance_clear();
}

uint64_t work_interval_instance_finish()
{
  return _work_interval_instance_finish();
}

uint64_t work_interval_instance_free()
{
  return _work_interval_instance_free();
}

uint64_t work_interval_instance_get_telemetry_data()
{
  return _work_interval_instance_get_telemetry_data();
}

uint64_t work_interval_instance_set_complexity()
{
  return _work_interval_instance_set_complexity();
}

uint64_t work_interval_instance_set_deadline()
{
  return _work_interval_instance_set_deadline();
}

uint64_t work_interval_instance_set_finish()
{
  return _work_interval_instance_set_finish();
}

uint64_t work_interval_instance_set_start()
{
  return _work_interval_instance_set_start();
}

uint64_t work_interval_instance_start()
{
  return _work_interval_instance_start();
}

uint64_t work_interval_instance_update()
{
  return _work_interval_instance_update();
}

uint64_t work_interval_join()
{
  return _work_interval_join();
}

uint64_t work_interval_join_port()
{
  return _work_interval_join_port();
}

uint64_t work_interval_leave()
{
  return _work_interval_leave();
}

uint64_t write_NOCANCEL()
{
  return _write_NOCANCEL();
}