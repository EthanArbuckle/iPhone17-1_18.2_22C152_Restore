char *sub_100002E10()
{
  char *result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  uint64_t vars8;

  byte_100074EC8 = 1;
  byte_100074EC9 = 0;
  if (!sub_100038040((uint64_t)&unk_100074ED0, 0, 0, 0x8000000, 2, 0, 0, 4096, 16, 25, 0, 0, (uint64_t)sub_100030730))sub_10003A18C((uint64_t)&unk_100074ED0, 0, 0); {
  result = (char *)sub_10001CF74((uint64_t)&unk_100074ED0, (uint64_t)"clone mapping", (uint64_t)sub_100002EF8);
  }
  if (result)
  {
    sub_100044674("failed to register the clone mapping tree in the fsck memory storage\n", v1, v2, v3, v4, v5, v6, v7, v8);
    return sub_100048B34((char *)0x581, 12);
  }
  return result;
}

uint64_t sub_100002EF8()
{
  if (qword_100074F08) {
    uint64_t result = sub_10003A268((uint64_t)&unk_100074ED0, 0);
  }
  byte_100074EC8 = 0;
  return result;
}

uint64_t sub_100002F30(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)&long long v60 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v60 + 1) = 0xAAAAAAAAAAAAAAAALL;
  memset(v59, 170, 25);
  if (byte_100074EC8 != 1) {
    return 0;
  }
  if ((*(unsigned char *)(*(void *)(a2 + 40) + 48) & 4) == 0)
  {
    uint64_t v3 = 0;
    goto LABEL_9;
  }
  unsigned int v57 = 25;
  int v58 = 16;
  unsigned int v5 = sub_100038610((uint64_t)dword_100074ED0, 0, &v60, &v58, v59, &v57);
  if (!v5)
  {
    while (1)
    {
      char v14 = v59[3];
      if ((v59[3] & 3) == 1) {
        break;
      }
      if ((v59[3] & 2) != 0)
      {
        uint64_t v28 = v60;
        v65[0] = v60;
        v65[1] = 0;
        memset(v56, 170, 25);
        unsigned int v63 = 25;
        unsigned int v64 = 16;
        if (sub_1000380B0((uint64_t)dword_100074ED0, 0, 1, v65, &v64, 0x10u, v56, &v63)
          || v65[0] != v28)
        {
LABEL_22:
          if (v14)
          {
            sub_100044674("clone mapping (private_id %llu, file_id %llu) is orphan\n", v29, v30, v31, v32, v33, v34, v35, v60);
            sub_100048B34((char *)0x559, 92);
            *(void *)v56 = 0xE000000000000009;
            *(_DWORD *)&v56[8] = 19;
            *(_OWORD *)&v56[12] = v60;
            uint64_t v40 = sub_1000032B8(a3, (long long *)v56, 0, 0, 0, v37, v38, v39);
            if (v40)
            {
              uint64_t v3 = v40;
              char v41 = v60;
              strerror(v40);
              sub_10004458C("can't remove orphan clone mapping (private_id %llu, file_id %llu): %s (%d)\n", v42, v43, v44, v45, v46, v47, v48, v41);
              sub_100048B34((char *)0x548, v3);
              goto LABEL_30;
            }
            if ((v59[3] & 4) == 0)
            {
LABEL_28:
              v51 = sub_1000197F0;
              v52 = sub_100008204;
              goto LABEL_29;
            }
LABEL_14:
            uint64_t v3 = 0;
            goto LABEL_30;
          }
        }
        else
        {
          unsigned int v36 = 0;
          while (1)
          {
            v36 += (v56[24] >> 1) & 1;
            if (v36 > 1) {
              break;
            }
            unsigned int v61 = 25;
            unsigned int v62 = 16;
            if (sub_1000380B0((uint64_t)dword_100074ED0, 0, 2, v65, &v62, 0x10u, v56, &v61)
              || v65[0] != v28)
            {
              goto LABEL_22;
            }
          }
          if ((v14 & 1) == 0)
          {
            sub_100044674("clone mapping (private_id %llu, file_id %llu) is missing\n", v29, v30, v31, v32, v33, v34, v35, v60);
            sub_100048B34((char *)0x55A, 92);
            v49 = a3;
            int v50 = 0;
            goto LABEL_35;
          }
          if ((v59[3] & 4) != 0)
          {
            v49 = a3;
            int v50 = 1;
LABEL_35:
            uint64_t v53 = sub_10000330C(v49, &v60, v59, v50);
            if (v53)
            {
              uint64_t v3 = v53;
              goto LABEL_9;
            }
            v51 = (void (*)(uint64_t, uint64_t))sub_100019770;
            v52 = (void (*)(uint64_t, uint64_t))sub_100008170;
LABEL_29:
            uint64_t v3 = sub_100003C4C((uint64_t *)&v60, v59, (uint64_t (*)(void, void))v51, (uint64_t (*)(uint64_t, void))v52);
LABEL_30:
            if (v3) {
              goto LABEL_9;
            }
          }
        }
      }
      unsigned int v54 = 25;
      unsigned int v55 = 16;
      unsigned int v5 = sub_1000380B0((uint64_t)dword_100074ED0, 0, 2, &v60, &v55, 0x10u, v59, &v54);
      if (v5) {
        goto LABEL_6;
      }
    }
    sub_100044674("found an orphan clone mapping (private_id %llu, file_id %llu)\n", v6, v7, v8, v9, v10, v11, v12, v60);
    sub_100048B34((char *)0x545, 92);
    *(void *)v56 = 0xE000000000000009;
    *(_DWORD *)&v56[8] = 19;
    *(_OWORD *)&v56[12] = v60;
    int v18 = sub_1000032B8(a3, (long long *)v56, 0, 0, 0, v15, v16, v17);
    if (!v18) {
      goto LABEL_28;
    }
    int v19 = v18;
    char v20 = v60;
    strerror(v18);
    sub_100044674("can't add orphan clone mapping (private_id %llu, file_id %llu) to the fsck repairs: %s (%d)\n", v21, v22, v23, v24, v25, v26, v27, v20);
    sub_100048B34((char *)0x546, v19);
    goto LABEL_14;
  }
LABEL_6:
  if (v5 == 2) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = v5;
  }
LABEL_9:
  sub_10003A268((uint64_t)dword_100074ED0, 0);
  return v3;
}

uint64_t sub_1000032B8(_DWORD *a1, long long *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, a5, 0, 0, a2, 0x1Cu, a3, a4);
  }
  return sub_100027AD0(0, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
}

uint64_t sub_10000330C(_DWORD *a1, long long *a2, void *a3, int a4)
{
  unint64_t v52 = 0xE000000000000009;
  int v53 = 19;
  long long v54 = *a2;
  uint64_t v9 = a3 + 1;
  uint64_t v8 = a3[1];
  if (*a3)
  {
    unsigned int v10 = 16;
  }
  else
  {
    if (!v8)
    {
      uint64_t v11 = 0;
      goto LABEL_8;
    }
    unsigned int v10 = 4;
  }
  if (v8) {
    uint64_t v11 = v10 + 12;
  }
  else {
    uint64_t v11 = v10;
  }
LABEL_8:
  uint64_t v12 = (unsigned __int16 *)malloc_type_calloc(1uLL, v11 + 8, 0x8EADF7C0uLL);
  char v20 = v12;
  if (!v12)
  {
    sub_10004458C("can't allocate memory to insert a new clone mapping value\n", v13, v14, v15, v16, v17, v18, v19, v51);
    uint64_t v31 = 12;
    sub_100048B34((char *)0x53E, 12);
    goto LABEL_17;
  }
  if (v11)
  {
    if (*a3)
    {
      uint64_t v21 = sub_10003EF1C(v12 + 4, v11, 2, a3, 8, 16, v18, v19);
      if (v21)
      {
        uint64_t v22 = v21;
        char v23 = strerror(v21);
        sub_10004458C("can't add dir stats key for clone mapping: %s (%d)\n", v24, v25, v26, v27, v28, v29, v30, v23);
        sub_100048B34((char *)0x53F, v22);
        uint64_t v31 = v22;
LABEL_17:
        free(v20);
        char v20 = 0;
        goto LABEL_22;
      }
    }
    if (*v9)
    {
      uint64_t v32 = sub_10003EF1C(v20 + 4, v11, 1, v9, 8, 16, v18, v19);
      if (v32)
      {
        uint64_t v33 = v32;
        char v34 = strerror(v32);
        sub_10004458C("can't add attribution tag for clone mapping: %s (%d)\n", v35, v36, v37, v38, v39, v40, v41, v34);
        sub_100048B34((char *)0x540, v33);
        uint64_t v31 = v33;
        goto LABEL_17;
      }
    }
  }
  *(void *)char v20 = a3[2] & 0xFFFFFFFFFFFFFFLL | ((((unint64_t)(a3[3] & 8) >> 3) & 1) << 56);
  if (a4 && (uint64_t v31 = sub_1000032B8(a1, (long long *)&v52, 0, 0, 0, v17, v18, v19), v31)
    || (uint64_t v31 = sub_1000032B8(a1, (long long *)&v52, v20, v11 + 8, 2, v17, v18, v19), v31))
  {
    uint64_t v42 = *((void *)a2 + 1);
    strerror(v31);
    sub_10004458C("can't add clone mapping (private_id %llu, file_id %llu) for repairs: %s (%d)\n", v43, v44, v45, v46, v47, v48, v49, v42);
    sub_100048B34((char *)0x544, v31);
  }
LABEL_22:
  free(v20);
  return v31;
}

uint64_t sub_100003544(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3 & 0xFFFFFFFFFFFFFFLL;
  if ((*a3 & 0x100000000000000) != 0) {
    int v6 = 9;
  }
  else {
    int v6 = 1;
  }
  return sub_10000355C(a1, a2, v6, a4, a5, v5);
}

uint64_t sub_10000355C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (byte_100074EC8 != 1) {
    return 0;
  }
  char v10 = a1;
  memset(v44, 0, 25);
  v43[0] = a1;
  v43[1] = a2;
  unsigned int v41 = 25;
  unsigned int v42 = 16;
  uint64_t v11 = sub_1000380B0((uint64_t)dword_100074ED0, 0, 0, v43, &v42, 0x10u, v44, &v41);
  if (v11 != 2)
  {
    uint64_t v19 = v11;
    if (v11)
    {
      strerror(v11);
      sub_10004458C("failed to search for clone mapping (private_id %llu,  file_id %llu): %s (%d)\n", v20, v21, v22, v23, v24, v25, v26, v10);
      sub_100048B34((char *)0x54B, v19);
      return v19;
    }
    v40[24] = -86;
    if ((a3 & 2) != 0)
    {
      *(_OWORD *)uint64_t v40 = v44[0];
      *(_OWORD *)&v40[9] = *(_OWORD *)((char *)v44 + 9);
    }
    else
    {
      *(void *)&v40[8] = a4;
      *(void *)&v40[16] = a6;
      *(void *)uint64_t v40 = a5;
    }
    if (*(void *)&v44[0] != a5)
    {
      sub_100044674("clone mapping (private_id %llu, file_id %llu): dir stats key (%llu) != inode (id %llu) dir stats key (%llu)\n", v12, v13, v14, v15, v16, v17, v18, v10);
      sub_100048B34((char *)0x55B, -11);
      BYTE8(v44[1]) |= 4u;
      if ((a3 & 2) != 0) {
        *(void *)&v44[0] = a5;
      }
    }
    if (*((void *)&v44[0] + 1) == a4)
    {
      char v27 = BYTE8(v44[1]);
      if (((a3 | BYTE8(v44[1])) & 0x10) != 0)
      {
        if ((a3 & 2) != 0) {
          goto LABEL_25;
        }
        goto LABEL_19;
      }
    }
    else
    {
      sub_100044674("clone mapping (private_id %llu, file_id %llu): attribution tag (%llu) != inode (id %llu) attribution tag (%llu)\n", v12, v13, v14, v15, v16, v17, v18, v10);
      sub_100048B34((char *)0x55C, -11);
      int v28 = BYTE8(v44[1]);
      char v27 = BYTE8(v44[1]) | 4;
      BYTE8(v44[1]) |= 4u;
      if ((a3 & 2) != 0)
      {
        *((void *)&v44[0] + 1) = a4;
        if (((a3 | v28) & 0x10) != 0) {
          goto LABEL_25;
        }
      }
      else if (((a3 | v28) & 0x10) != 0)
      {
LABEL_19:
        if (*(void *)&v44[1] != a6)
        {
          sub_100044674("clone mapping (private_id %llu, file_id %llu): compressed physical size (%llu) != inode (id %llu) compressed physical size (%llu)\n", v12, v13, v14, v15, v16, v17, v18, v10);
          sub_100048B34((char *)0x56E, -11);
          char v27 = BYTE8(v44[1]) | 4;
          BYTE8(v44[1]) |= 4u;
        }
        goto LABEL_25;
      }
    }
    if (*(void *)&v44[1] != a6)
    {
      sub_100044674("clone mapping (private_id %llu, file_id %llu): physical size (%llu) != inode (id %llu) physical size (%llu)\n", v12, v13, v14, v15, v16, v17, v18, v10);
      sub_100048B34((char *)0x55D, -11);
      char v27 = BYTE8(v44[1]) | 4;
      BYTE8(v44[1]) |= 4u;
      if ((a3 & 2) != 0) {
        *(void *)&v44[1] = a6;
      }
    }
LABEL_25:
    if ((a3 & 8) != (v27 & 8))
    {
      sub_100044674("clone mapping (private_id %llu, file_id %llu): purgeable status is different than inode (id %llu) purgeable status\n", v12, v13, v14, v15, v16, v17, v18, v10);
      sub_100048B34((char *)0x55E, -3);
      char v27 = BYTE8(v44[1]) | 4;
      if ((a3 & 2) != 0) {
        char v27 = BYTE8(v44[1]) & 0xF3 | 4 | a3 & 8;
      }
    }
    BYTE8(v44[1]) = v27 | a3 & 0xF7;
    if (v27 & 4 | a3 & 4)
    {
      byte_100074EC9 = 1;
      uint64_t v29 = sub_100003C4C(v43, v40, (uint64_t (*)(void, void))sub_1000197F0, (uint64_t (*)(uint64_t, void))sub_100008204);
      if (v29) {
        return v29;
      }
    }
    goto LABEL_31;
  }
  *(void *)&v44[0] = a5;
  *((void *)&v44[0] + 1) = a4;
  *(void *)&v44[1] = a6;
  BYTE8(v44[1]) |= a3;
LABEL_31:
  uint64_t v30 = sub_100039A6C(dword_100074ED0, 0, v43, 16, v44, 25);
  uint64_t v19 = v30;
  if (v30)
  {
    char v31 = v43[0];
    strerror(v30);
    sub_10004458C("failed to insert clone mapping (private_id %llu,  file_id %llu, flags 0x%x): %s (%d)\n", v32, v33, v34, v35, v36, v37, v38, v31);
    sub_100048B34((char *)0x54C, v19);
  }
  return v19;
}

uint64_t sub_1000038D4(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a1 < 0x10) {
    return 0;
  }
  if ((*(_DWORD *)(a2 + 68) & 0x20) != 0) {
    a4 = 0;
  }
  if ((*(_DWORD *)(a2 + 68) & 0x20) != 0) {
    int v8 = 18;
  }
  else {
    int v8 = 2;
  }
  uint64_t v9 = *(void *)(a2 + 48);
  if ((v9 & 0x180000) == 0x80000 && *(_DWORD *)(a2 + 56) == 1) {
    v8 |= 8u;
  }
  return sub_10000355C(*(void *)(a2 + 8), a1, (v9 >> 9) & 0x20 | v8, a5, a6, a4);
}

uint64_t sub_100003940(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (byte_100074EC8 != 1) {
    return 0;
  }
  char v4 = a1;
  v33[0] = 0;
  v33[1] = 0;
  char v35 = 0;
  uint64_t v34 = 0;
  v32[0] = a1;
  v32[1] = a2;
  unsigned int v30 = 25;
  unsigned int v31 = 16;
  uint64_t v5 = sub_1000380B0((uint64_t)dword_100074ED0, 0, 0, v32, &v31, 0x10u, v33, &v30);
  if (v5)
  {
    uint64_t v13 = v5;
    strerror(v5);
    sub_10004458C("failed to search for clone mapping (private_id %llu,  file_id %llu) to update compressed clone size: %s (%d)\n", v14, v15, v16, v17, v18, v19, v20, v4);
    sub_100048B34((char *)0x56F, v13);
    return v13;
  }
  if (v35)
  {
    if (v34 != a3)
    {
      sub_100044674("clone mapping (private_id %llu, file_id %llu): compressed physical size (%llu) != inode (id %llu) compressed physical size (%llu)\n", v6, v7, v8, v9, v10, v11, v12, v4);
      sub_100048B34((char *)0x570, -11);
      uint64_t v13 = sub_100003C4C(v32, v33, (uint64_t (*)(void, void))sub_1000197F0, (uint64_t (*)(uint64_t, void))sub_100008204);
      if (v13) {
        return v13;
      }
      v35 |= 4u;
      goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  uint64_t v34 = a3;
  uint64_t v21 = sub_100039A6C(dword_100074ED0, 0, v32, 16, v33, 25);
  uint64_t v13 = v21;
  if (v21)
  {
    strerror(v21);
    sub_10004458C("failed to update clone mapping (private_id %llu,  file_id %llu) with compressed clone size: %s (%d)\n", v22, v23, v24, v25, v26, v27, v28, v4);
    sub_100048B34((char *)0x571, v13);
  }
  return v13;
}

uint64_t sub_100003AD8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v24 = a1;
  uint64_t v25 = 0;
  memset(v23, 170, 25);
  if (byte_100074EC8)
  {
    unsigned int v21 = 25;
    unsigned int v22 = 16;
    unsigned int v8 = sub_1000380B0((uint64_t)dword_100074ED0, 0, 1, &v24, &v22, 0x10u, v23, &v21);
    unsigned int v16 = 0;
    if (v8)
    {
LABEL_9:
      if (v8 == 2) {
        uint64_t v17 = 0;
      }
      else {
        uint64_t v17 = v8;
      }
    }
    else
    {
      while (v24 == a1)
      {
        if ((v23[3] & 2) != 0)
        {
          if (v16 < a3) {
            *(void *)(a2 + 8 * (int)v16) = v25;
          }
          ++v16;
        }
        unsigned int v19 = 25;
        unsigned int v20 = 16;
        unsigned int v8 = sub_1000380B0((uint64_t)dword_100074ED0, 0, 2, &v24, &v20, 0x10u, v23, &v19);
        if (v8) {
          goto LABEL_9;
        }
      }
      uint64_t v17 = 0;
    }
    if (v16 != a3)
    {
      sub_100044548("number of files in the clone mapping (%u) != dstream reference count (%u)\n", v9, v10, v11, v12, v13, v14, v15, v16);
      sub_100048B34((char *)0x54E, 92);
    }
    if (a4) {
      *a4 = v16;
    }
  }
  else
  {
    uint64_t v17 = 12;
    sub_100048B34((char *)0x54D, 12);
  }
  return v17;
}

uint64_t sub_100003C30()
{
  return byte_100074EC9 & ~byte_100074EC8 & 1;
}

uint64_t sub_100003C4C(uint64_t *a1, void *a2, uint64_t (*a3)(void, void), uint64_t (*a4)(uint64_t, void))
{
  if (*a2 && (uint64_t v7 = a3(*a2, a2[2]), v7))
  {
    uint64_t v8 = v7;
    uint64_t v9 = *a1;
    strerror(v7);
    sub_10004458C("clone mapping (private_id %llu, file_id %llu): failed to update dir stats %llu: %s (%d)\n", v10, v11, v12, v13, v14, v15, v16, v9);
    sub_100048B34((char *)0x58B, v8);
  }
  else
  {
    uint64_t v17 = a2[1];
    if (v17)
    {
      uint64_t v18 = a4(v17, a2[2]);
      uint64_t v8 = v18;
      if (v18)
      {
        uint64_t v19 = *a1;
        strerror(v18);
        sub_10004458C("clone mapping (private_id %llu, file_id %llu): failed to update attribution tag %llu: %s (%d)\n", v20, v21, v22, v23, v24, v25, v26, v19);
        sub_100048B34((char *)0x58C, v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return v8;
}

void sub_100003D28()
{
  if (!off_100091690)
  {
    int cpu_capabilities = _get_cpu_capabilities();
    v1 = sub_100003DF4;
    if ((cpu_capabilities & 0x4000000) == 0)
    {
      v2 = (char *)off_100091690;
      if (off_100091690) {
        return;
      }
      do
      {
        unsigned int v3 = 0;
        for (int i = 0; i != 8; ++i)
        {
          unsigned int v5 = (v2 >> i) ^ v3;
          unsigned int v6 = v3 >> 1;
          unsigned int v3 = (v3 >> 1) ^ 0x82F63B78;
          if ((v5 & 1) == 0) {
            unsigned int v3 = v6;
          }
        }
        dword_100091698[(void)v2++] = v3;
        v1 = sub_100003DC8;
      }
      while (v2 != (char *)256);
    }
    off_100091690 = (uint64_t (*)(void, void, void))v1;
  }
}

uint64_t sub_100003DC8(uint64_t result, char *a2, uint64_t a3)
{
  for (; a3; --a3)
  {
    char v3 = *a2++;
    uint64_t result = dword_100091698[(v3 ^ result)] ^ (result >> 8);
  }
  return result;
}

uint64_t sub_100003DF4(uint64_t result, unsigned __int16 *a2, unint64_t a3)
{
  if ((a2 & 7) != 0)
  {
    if (!a3) {
      return result;
    }
    if (a2)
    {
      int v4 = *(unsigned __int8 *)a2;
      a2 = (unsigned __int16 *)((char *)a2 + 1);
      _W8 = v4;
      __asm { CRC32CB         W0, W0, W8 }
      uint64_t result = _OFF;
      __asm { CRC32CB         W0, W0, W8 }
      --a3;
    }
    if (a3 >= 2 && (a2 & 3) != 0)
    {
      int v11 = *a2++;
      _W9 = v11;
      __asm { CRC32CH         W0, W0, W9 }
      uint64_t result = _OFF;
      __asm { CRC32CH         W0, W0, W9 }
      a3 -= 2;
    }
    if (a3 >= 4 && (a2 & 7) != 0)
    {
      int v14 = *(_DWORD *)a2;
      a2 += 2;
      _W9 = v14;
      __asm { CRC32CW         W0, W0, W9 }
      uint64_t result = _OFF;
      __asm { CRC32CW         W0, W0, W9 }
      a3 -= 4;
    }
  }
  if (a3 >= 8)
  {
    do
    {
      uint64_t v17 = *(void *)a2;
      a2 += 4;
      _X8 = v17;
      __asm { CRC32CX         W0, W0, X8 }
      uint64_t result = _OFF;
      __asm { CRC32CX         W0, W0, X8 }
      a3 -= 8;
    }
    while (a3 > 7);
  }
  if (a3 >= 4)
  {
    int v20 = *(_DWORD *)a2;
    a2 += 2;
    _W9 = v20;
    __asm { CRC32CW         W0, W0, W9 }
    uint64_t result = _OFF;
    __asm { CRC32CW         W0, W0, W9 }
    a3 -= 4;
  }
  if (a3 >= 2)
  {
    int v23 = *a2++;
    _W9 = v23;
    __asm { CRC32CH         W0, W0, W9 }
    uint64_t result = _OFF;
    __asm { CRC32CH         W0, W0, W9 }
    a3 -= 2;
  }
  if (a3)
  {
    _W8 = *(unsigned __int8 *)a2;
    __asm { CRC32CB         W0, W0, W8 }
    uint64_t result = _OFF;
    __asm { CRC32CB         W0, W0, W8 }
  }
  return result;
}

uint64_t sub_100003E9C(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        uint64_t v8 = a2[1];
        uint64_t v9 = a4[1];
        if (v8 >= v9) {
          int v7 = v9 < v8;
        }
        else {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t sub_100003EFC(unint64_t a1, unsigned int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = (char *)&unk_100091A98 + 104 * a2;
  while (1)
  {
    sub_100005294(a1);
    uint64_t v10 = &v9[v8];
    if (v9[v8 + 24])
    {
      uint64_t v11 = *(void *)v10;
      uint64_t v12 = *((void *)v10 + 1);
      uint64_t v13 = v12 - v11;
      if (v12 != v11)
      {
        if (a2 == 1) {
          v11 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)));
        }
        uint64_t result = a3(v11, v13, a4);
        if (result) {
          break;
        }
      }
    }
    v8 += 32;
    if (v8 == 96) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100003FB4(unint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, uint64_t), uint64_t a3)
{
  unsigned int v6 = 0;
  char v7 = 1;
  do
  {
    char v8 = v7;
    uint64_t result = sub_100003EFC(a1, v6, a2, a3);
    if (result) {
      break;
    }
    char v7 = 0;
    unsigned int v6 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

uint64_t sub_100004010(uint64_t a1, unsigned int a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if ((*(unsigned char *)(v4 + 144) & 1) == 0 || !*(_DWORD *)(v4 + 336)) {
    return 0;
  }
  uint64_t v9 = 0;
  uint64_t v10 = v4 + 1088 * a2;
  while (1)
  {
    uint64_t v11 = *(void *)(v10 + v9 + 344);
    uint64_t v12 = *(void *)(v10 + v9 + 352);
    uint64_t v13 = v12 - v11;
    if (v12 != v11)
    {
      if (a2 == 1) {
        v11 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)));
      }
      uint64_t result = a3(v11, v13, a4);
      if (result) {
        break;
      }
    }
    v9 += 136;
    if (v9 == 1088) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000040C4(uint64_t *a1, int8x16_t *a2, unsigned int a3, unint64_t a4, uint64_t *a5)
{
  uint64_t v9 = a1;
  unsigned int v212 = 0;
  uint64_t v210 = 0;
  uint64_t v211 = 0xAAAAAAAAAAAAAAAALL;
  int64_t v209 = 0;
  uint64_t v10 = a1[3];
  size_t v11 = *(unsigned int *)(v10 + 32);
  v207 = (_DWORD *)v10;
  if (*(void *)(v10 + 96)) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  uint64_t v13 = (char *)malloc_type_malloc(v11, 0x99D8D69EuLL);
  int v14 = (char *)malloc_type_malloc(v11, 0x94948E03uLL);
  v213[0] = v14;
  uint64_t v15 = malloc_type_malloc(v11, 0x8F726F49uLL);
  int v23 = v15;
  if (v13) {
    BOOL v24 = v14 == 0;
  }
  else {
    BOOL v24 = 1;
  }
  if (v24 || v15 == 0)
  {
    sub_10004458C("Space Allocation: failed to allocate memory\n", v16, v17, v18, v19, v20, v21, v22, v182);
    uint64_t v26 = 12;
    uint64_t v27 = 510;
    int v28 = 12;
    goto LABEL_82;
  }
  v193 = a5;
  v189 = a2;
  int v29 = 0;
  int v30 = v12;
  unint64_t v31 = 0;
  uint64_t v32 = 0;
  int v186 = v30;
  int v33 = v30 - 1;
  unsigned int v34 = a3 - 1;
  uint64_t v187 = a3;
  LOBYTE(v30) = __clz(__rbit64(v11));
  uint64_t v35 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v30;
  unint64_t v194 = 0x4000000000000000uLL >> v30;
  int v203 = -1;
  uint64_t v205 = (uint64_t)v15;
  v206 = v9;
  int v192 = v11;
  v198 = v13;
  unsigned int v190 = a3;
  unsigned int v184 = a3 - 1;
  int v185 = v33;
  uint64_t v183 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v30;
  do
  {
    int v191 = v29;
    uint64_t v36 = (dword_100074F20 + v29) & v33;
    uint64_t v37 = v207;
    if (v34 > 2)
    {
LABEL_29:
      int v188 = 0;
      unint64_t v46 = qword_100074F10[v36] & v35;
      goto LABEL_30;
    }
    if (a3 == 3)
    {
      if (a4 - 5 < 0xFFFFFFFFFFFFFFFCLL) {
        goto LABEL_29;
      }
      uint64_t v38 = v9[3];
      if ((*(unsigned char *)(v38 + 144) & 1) == 0 || !*(_DWORD *)(v38 + 336)) {
        goto LABEL_29;
      }
      uint64_t v39 = v38 + 344;
      uint64_t v40 = 8;
      char v41 = a4 + 7;
      while (1)
      {
        unsigned int v42 = v41 & 7;
        if (*(unsigned __int16 *)(v39 + 1088 * v36 + 136 * v42 + 128) == a4) {
          break;
        }
        char v41 = v42 + 1;
        if (!--v40) {
          goto LABEL_29;
        }
      }
      uint64_t v45 = (char *)(v39 + 1088 * v36 + 136 * v42);
    }
    else
    {
      sub_100005294((unint64_t)v9);
      uint64_t v37 = v207;
      if (!*((unsigned char *)&unk_100091A98 + 104 * v36 + 96)) {
        goto LABEL_29;
      }
      uint64_t v43 = (char *)&unk_100091A98 + 104 * v36;
      uint64_t v44 = v187;
      if (!v43[32 * v187 + 24])
      {
        if (a3 != 2 || !v43[56]) {
          goto LABEL_29;
        }
        uint64_t v44 = 1;
      }
      uint64_t v45 = &v43[32 * v44 + 16];
    }
    unint64_t v46 = *(void *)v45;
    int v188 = 1;
LABEL_30:
    unsigned int v47 = 0;
    unint64_t v48 = (unint64_t)&v37[12 * v36];
    v202 = (unint64_t *)(v48 + 48);
    v199 = (char *)v37 + *(unsigned int *)(v48 + 80);
    v204 = (unsigned int *)(v48 + 64);
    uint64_t v200 = v36;
    v201 = (_DWORD *)(v48 + 68);
    LODWORD(v48) = v37[9];
    unint64_t v49 = v194;
    if (v36 != 1) {
      unint64_t v49 = 0;
    }
    unint64_t v208 = v49;
    unint64_t v195 = v46;
    do
    {
      if (v46 >= *v202) {
        unint64_t v46 = 0;
      }
      unint64_t v50 = v46 / v48 / v37[10];
      if (*v201)
      {
        unsigned int v51 = v37[11];
        unsigned int v52 = v50 / v51;
        int v53 = v203;
        if (v50 / v51 != v203)
        {
          int v54 = sub_10002F148(*v206, *(void *)&v199[8 * v52]);
          if (v54)
          {
            sub_10004458C("error (%d) getting cab %u @ %lld on device %d\n", v55, v56, v57, v58, v59, v60, v61, v54);
            uint64_t v37 = v207;
            LODWORD(v48) = v207[9];
            unint64_t v46 = (v37[11] + v37[11] * v52) * v207[10] * v48;
            int v203 = v52;
            uint64_t v9 = v206;
            goto LABEL_76;
          }
          unsigned int v51 = v207[11];
          int v53 = v52;
        }
        int v203 = v53;
        unsigned int v64 = (uint64_t *)&v13[8 * (v50 - v51 * v53) + 40];
        uint64_t v9 = v206;
      }
      else
      {
        unsigned int v64 = (uint64_t *)&v199[8 * v50];
      }
      int v65 = sub_10002F148(*v9, *v64);
      if (v65)
      {
        sub_10004458C("error (%d) getting cib %u @ %lld on device %d\n", v66, v67, v68, v69, v70, v71, v72, v65);
        uint64_t v37 = v207;
        LODWORD(v48) = v207[9];
        unint64_t v46 = ((v37[10] + v37[10] * v50) * v48);
        goto LABEL_76;
      }
      uint64_t v37 = v207;
      unint64_t v48 = v207[9];
      int v73 = v207[10] * *((_DWORD *)v213[0] + 8);
      if (v47 == *v204) {
        unsigned int v74 = v195 / v48 - v73 + 1;
      }
      else {
        unsigned int v74 = *((_DWORD *)v213[0] + 9);
      }
      unsigned int v75 = v46 / v48 - v73;
      unsigned int v212 = v75;
      if (v75 < v74)
      {
        unsigned int v196 = v74 - 1;
        unsigned int v197 = v74;
        do
        {
          v76 = v213[0];
          uint64_t v77 = v75;
          v78 = &v213[0][32 * v75];
          v80 = v78 + 64;
          uint64_t v79 = *((void *)v78 + 8);
          if (v79)
          {
            int v81 = sub_10002F148(*v206, v79);
            unsigned int v75 = v212;
            if (v81)
            {
              sub_10004458C("error (%d) getting cib bitmap %d @ %lld on device %d\n", v82, v83, v84, v85, v86, v87, v88, v81);
              unsigned int v75 = v212 + 1;
              uint64_t v37 = v207;
              LODWORD(v48) = v207[9];
              unint64_t v46 = (v212 + 1 + v207[10] * v50) * v48;
              uint64_t v13 = v198;
              int v23 = (void *)v205;
              goto LABEL_75;
            }
            uint64_t v37 = v207;
          }
          if (v47 == *v204 && v75 == v196) {
            uint64_t v90 = v195 - *(void *)&v76[32 * v77 + 48];
          }
          else {
            uint64_t v90 = *((_DWORD *)v78 + 14) & 0xFFFFFLL;
          }
          int64_t v91 = v46 % v37[9];
          v92 = &v76[32 * v77 + 48];
          int v23 = (void *)v205;
          while (v90 > v91)
          {
            if (!*v80)
            {
              uint64_t v210 = 0;
LABEL_66:
              int64_t v209 = v90;
              goto LABEL_67;
            }
            if (!sub_10000A370(0, v205, v91, v90 - v91, &v210)) {
              break;
            }
            if (!sub_10000A370(1, v205, v210, v90 - v210, &v209)) {
              goto LABEL_66;
            }
LABEL_67:
            int64_t v91 = v209;
            if (v31 + v32 == ((*(void *)v92 + v210) | v208))
            {
              unint64_t v93 = v31;
            }
            else
            {
              uint64_t v32 = (*(void *)v92 + v210) | v208;
              unint64_t v93 = 0;
            }
            unint64_t v94 = v209 - v210;
            if (v209 - v210 >= a4 - v93) {
              unint64_t v94 = a4 - v93;
            }
            unint64_t v31 = v94 + v93;
            if (v94 + v93 >= a4)
            {
              uint64_t *v193 = v32;
              uint64_t v13 = v198;
              uint64_t v9 = v206;
              goto LABEL_80;
            }
          }
          uint64_t v37 = v207;
          unint64_t v48 = v207[9];
          unint64_t v46 = v90 + v46 / v48 * v48;
          unsigned int v75 = v212 + 1;
          uint64_t v13 = v198;
LABEL_75:
          uint64_t v9 = v206;
          unsigned int v212 = v75;
        }
        while (v75 < v197);
      }
LABEL_76:
      ++v47;
    }
    while (v47 <= *v204);
    a3 = v190;
    int v29 = v191 + 1;
    int v33 = v185;
    unsigned int v34 = v184;
    uint64_t v35 = v183;
  }
  while (v191 + 1 != v186);
LABEL_80:
  if (v31 >= a4)
  {
    uint64_t v96 = v31 + v32;
    if (v32 >= (uint64_t)(v31 + v32))
    {
LABEL_100:
      uint64_t v123 = sub_100004B18((uint64_t)v9, v189, (uint64_t)v207, v200, v31, v62, v63);
      if (!v123)
      {
        if (sub_100040BB8(v32, v31, 0, 0, 0)) {
          sub_100044674("fsck may bail out with overallocation - could not mark space allocated in fsck's version of the bitmap (%lld + %lld)\n", v134, v135, v136, v137, v138, v139, v140, v32);
        }
        uint64_t v141 = v96 - 1;
        if (v188)
        {
          if (v190 == 3)
          {
            uint64_t v26 = 0;
          }
          else
          {
            if (v190 == 2)
            {
              uint64_t v181 = 1;
              if (*((unsigned char *)&unk_100091A98 + 104 * v200 + 88)) {
                uint64_t v181 = 2;
              }
              uint64_t v187 = v181;
            }
            uint64_t v26 = 0;
            *((void *)&unk_100091A98 + 13 * v200 + 4 * v187 + 2) = v141;
          }
        }
        else
        {
          uint64_t v26 = 0;
          qword_100074F10[v200] = v141;
          dword_100074F20 = v200;
        }
        goto LABEL_83;
      }
      uint64_t v26 = v123;
      char v124 = strerror(v123);
      sub_10004458C("failed to update allocation counts: %s\n", v125, v126, v127, v128, v129, v130, v131, v124);
      sub_100048B34((char *)0x1F1, v26);
      sub_100004B18((uint64_t)v9, v189, (uint64_t)v207, v200, -(uint64_t)v31, v132, v133);
      uint64_t v97 = v31 + v32;
    }
    else
    {
      uint64_t v97 = v32;
      while (1)
      {
        uint64_t v98 = v207[9];
        uint64_t v99 = v97 % v98;
        uint64_t v100 = v98 - v97 % v98;
        uint64_t v101 = v100 >= v96 - v97 ? v96 - v97 : v100;
        uint64_t v102 = sub_10000CB8C(v9, v97, (uint64_t)v23, &v211, v213, &v212, 1);
        uint64_t v26 = v102;
        if (!v211 || v102) {
          break;
        }
        sub_10000A1C0((uint64_t)v23, v99, v101);
        uint64_t v103 = sub_10002F2C4(*v9, v211);
        if (v103)
        {
          uint64_t v26 = v103;
          sub_10004458C("error (%d) writing bitmap @ %lld\n", v104, v105, v106, v107, v108, v109, v110, v103);
          sub_100048B34((char *)0x1FF, v26);
          break;
        }
        v113 = v213[0];
        *(_DWORD *)&v213[0][32 * v212 + 60] -= v101;
        uint64_t v114 = *((void *)v113 + 1);
        sub_10003D7D8((unint64_t *)v113, (uint32x4_t *)(v113 + 8), (v192 - 8), 0, v111, v112);
        uint64_t v115 = sub_10002F2C4(*v9, v114);
        if (v115)
        {
          uint64_t v26 = v115;
          sub_10004458C("error (%d) writing cib %u @ %lld\n", v116, v117, v118, v119, v120, v121, v122, v115);
          sub_100048B34((char *)0x200, v26);
          int v23 = (void *)v205;
          sub_10000A2A8(v205, v99, v101);
          uint64_t v142 = sub_10002F2C4(*v9, v211);
          if (v142)
          {
            uint64_t v150 = v142;
            sub_10004458C("error (%d) writing bitmap @ %lld\n", v143, v144, v145, v146, v147, v148, v149, v142);
            sub_100048B34((char *)0x1F0, v150);
            uint64_t v26 = v150;
          }
          break;
        }
        v97 += v101;
        int v23 = (void *)v205;
        if (v97 >= v96) {
          goto LABEL_100;
        }
      }
    }
    if (v32 >= v97) {
      goto LABEL_83;
    }
    while (1)
    {
      int v151 = sub_10000CB8C(v9, v32, (uint64_t)v23, &v211, v213, &v212, 0);
      if (v211) {
        BOOL v152 = v151 == 0;
      }
      else {
        BOOL v152 = 0;
      }
      if (!v152) {
        goto LABEL_83;
      }
      uint64_t v153 = v207[9];
      uint64_t v154 = v32 % v153;
      uint64_t v155 = v153 - v32 % v153;
      uint64_t v156 = v155 >= v97 - v32 ? v97 - v32 : v155;
      sub_10000A2A8((uint64_t)v23, v154, v156);
      int v157 = sub_10002F2C4(*v9, v211);
      if (v157) {
        break;
      }
      v170 = v213[0];
      *(_DWORD *)&v213[0][32 * v212 + 60] += v156;
      uint64_t v171 = *((void *)v170 + 1);
      sub_10003D7D8((unint64_t *)v170, (uint32x4_t *)(v170 + 8), (v192 - 8), 0, v165, v166);
      int v172 = sub_10002F2C4(*v9, v171);
      if (v172)
      {
        int v180 = v172;
        sub_10004458C("error (%d) writing cib %u @ %lld\n", v173, v174, v175, v176, v177, v178, v179, v172);
        uint64_t v168 = 514;
        int v169 = v180;
        goto LABEL_123;
      }
LABEL_124:
      v32 += v156;
      int v23 = (void *)v205;
      if (v32 >= v97) {
        goto LABEL_83;
      }
    }
    int v167 = v157;
    sub_10004458C("error (%d) writing bitmap @ %lld\n", v158, v159, v160, v161, v162, v163, v164, v157);
    uint64_t v168 = 513;
    int v169 = v167;
LABEL_123:
    sub_100048B34((char *)v168, v169);
    goto LABEL_124;
  }
  uint64_t v26 = 28;
  uint64_t v27 = 495;
  int v28 = 28;
LABEL_82:
  sub_100048B34((char *)v27, v28);
LABEL_83:
  if (v23) {
    free(v23);
  }
  if (v213[0]) {
    free(v213[0]);
  }
  if (v13) {
    free(v13);
  }
  return v26;
}

uint64_t sub_100004B18(uint64_t a1, int8x16_t *a2, uint64_t a3, unsigned int a4, uint64_t a5, double a6, int8x16_t a7)
{
  *(void *)(a3 + 48 * a4 + 72) -= a5;
  if (!a2) {
    goto LABEL_11;
  }
  uint64_t v8 = a2[2].i64[1];
  unint64_t v9 = *(void *)(v8 + 72);
  unint64_t v10 = *(void *)(v8 + 88);
  uint64_t v11 = v9 >= v10 ? *(void *)(v8 + 88) : *(void *)(v8 + 72);
  unint64_t v12 = v10 + a5;
  *(void *)(v8 + 88) = v12;
  uint64_t v13 = v9 >= v12 ? v12 : v9;
  uint64_t v14 = v13 - v11;
  if (v14) {
    *(void *)(a3 + 192) += v14;
  }
  uint64_t result = sub_100045D54((uint64_t *)a1, a2);
  if (!result)
  {
LABEL_11:
    uint64_t v16 = *(void *)(a1 + 24);
    int8x16_t v17 = *(int8x16_t *)(a1 + 88);
    uint64_t v18 = *(void *)(a1 + 104);
    return sub_100026BA0((uint64_t *)a1, 0, v16, (uint64_t)&v17, v17, a7);
  }
  return result;
}

uint64_t sub_100004BC0(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, char a9, char a10)
{
  uint64_t v129 = a5;
  unint64_t v10 = (unsigned int *)a1[3];
  unint64_t v12 = v10[8];
  uint64_t v11 = v10[9];
  char v13 = __clz(__rbit64(v12));
  uint64_t v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & a3;
  uint64_t v127 = 0;
  uint64_t v128 = a7;
  uint64_t v15 = v14 % v11;
  if (v14 % v11 + a4 > (unint64_t)(8 * v12))
  {
    sub_10004458C("Spaceman Repair: Cannot modify more than a block's worth of bitmap\n", (uint64_t)a2, a3, a4, a5, a6, (uint64_t)a7, a8, v117);
    uint64_t v16 = 45;
    sub_100048B34((char *)0x277, 45);
    return v16;
  }
  int v124 = a8;
  uint64_t v21 = a6;
  uint64_t v125 = (uint64_t)a7;
  uint64_t v126 = a6;
  if (!a6)
  {
    uint64_t v22 = malloc_type_malloc(v12, 0x59278818uLL);
    a7 = (void *)v125;
    a6 = 0;
    uint64_t v21 = (uint64_t)v22;
    if (!v22)
    {
      sub_10004458C("Spaceman Repair: failed to allocate memory for the bitmap block\n", v23, v24, v25, v26, 0, v125, v27, v117);
      uint64_t v16 = 12;
      sub_100048B34((char *)0x278, 12);
      uint64_t v56 = 0;
      uint64_t v57 = 0;
      if (!v125) {
        goto LABEL_30;
      }
      goto LABEL_32;
    }
  }
  if (a7)
  {
    if (a6)
    {
      int v28 = a7;
      if (a5) {
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint64_t v128 = malloc_type_malloc(v12, 0x6C38BF08uLL);
    if (!v128)
    {
      sub_10004458C("Spaceman Repair: failed to allocate memory for the bitmap block\n", v29, v30, v31, v32, v33, v34, v35, v117);
      uint64_t v16 = 12;
      uint64_t v46 = 633;
      int v47 = 12;
      goto LABEL_28;
    }
  }
  uint64_t v36 = sub_10000CB8C(a1, a3, v21, &v129, (char **)&v128, 0, 1);
  if (v36)
  {
    uint64_t v16 = v36;
    goto LABEL_29;
  }
  int v28 = v128;
LABEL_13:
  int v121 = v28[8];
  uint64_t v37 = v10[9];
  unsigned int v119 = v10[10];
  if ((a10 & 1) == 0 && sub_10000A370(v124 == 1, v21, v15, a4, &v127))
  {
    if (v124 == 1) {
      uint64_t v45 = "bitmap was not entirely unset, stopping allocation\n";
    }
    else {
      uint64_t v45 = "bitmap was not entirely set, stopping deallocation\n";
    }
    sub_10004458C(v45, v38, v39, v40, v41, v42, v43, v44, v117);
    uint64_t v16 = 22;
    uint64_t v46 = 634;
    int v47 = 22;
    goto LABEL_28;
  }
  if (v124 == 1)
  {
    sub_10000A1C0(v21, v15, a4);
  }
  else if (v124 == 2)
  {
    sub_10000A2A8(v21, v15, a4);
  }
  uint64_t v48 = sub_10002F2C4(*a1, v129);
  if (!v48)
  {
    uint64_t v59 = v14 / v37 - v119 * v121;
    uint64_t v60 = *((void *)v128 + 1);
    unint64_t v61 = sub_10000A3F4(v21, 0, 0, *((_DWORD *)v128 + 8 * v59 + 14) & 0xFFFFF);
    uint64_t v64 = 0;
    int v65 = (char *)v128;
    uint64_t v120 = v59;
    uint64_t v66 = (char *)v128 + 32 * v59;
    unsigned int v68 = *((_DWORD *)v66 + 15);
    uint64_t v67 = v66 + 60;
    unint64_t v69 = v61 - v68;
    uint64_t v57 = (void *)v21;
    if (v61 != v68)
    {
      *uint64_t v67 = v61;
      uint64_t v64 = v69;
    }
    uint64_t v122 = v64;
    unint64_t v70 = (v12 - 8);
    sub_10003D7D8((unint64_t *)v65, (uint32x4_t *)(v65 + 8), v70, 0, v62, v63);
    uint64_t v71 = sub_10002F2C4(*a1, v60);
    if (v71)
    {
      uint64_t v16 = v71;
      sub_10004458C("error (%d) writing cib during deallocation\n", v72, v73, v74, v75, v76, v77, v78, v71);
      sub_100048B34((char *)0x27C, v16);
LABEL_42:
      if (v124 == 1)
      {
        sub_10000A2A8(v21, v15, a4);
        sub_10000A1C0(v21, v15, a4);
      }
      int v92 = sub_10002F2C4(*a1, v129);
      if (v92)
      {
        int v102 = v92;
        sub_10004458C("error (%d) writing bitmap @ %lld\n", v93, v94, v95, v96, v97, v98, v99, v92);
        uint64_t v103 = 638;
        int v104 = v102;
      }
      else
      {
        uint64_t v105 = (char *)v128;
        *((_DWORD *)v128 + 8 * v120 + 15) -= v122;
        uint64_t v106 = *((void *)v105 + 1);
        sub_10003D7D8((unint64_t *)v105, (uint32x4_t *)(v105 + 8), v70, 0, v100, v101);
        int v107 = sub_10002F2C4(*a1, v106);
        if (!v107) {
          goto LABEL_49;
        }
        int v115 = v107;
        sub_10004458C("error (%d) writing cib\n", v108, v109, v110, v111, v112, v113, v114, v107);
        uint64_t v103 = 639;
        int v104 = v115;
      }
      sub_100048B34((char *)v103, v104);
LABEL_49:
      uint64_t v56 = v126;
      if (v125) {
        goto LABEL_32;
      }
LABEL_30:
      if (v128)
      {
        free(v128);
        uint64_t v56 = v126;
      }
      goto LABEL_32;
    }
    unsigned int v118 = ((a3 << v13) & 0x4000000000000000) != 0;
    uint64_t v81 = sub_100004B18((uint64_t)a1, a2, (uint64_t)v10, v118, -v122, v79, v80);
    if (v81)
    {
      uint64_t v16 = v81;
      char v82 = strerror(v81);
      sub_10004458C("failed to update allocation counts: %s\n", v83, v84, v85, v86, v87, v88, v89, v82);
      sub_100048B34((char *)0x27D, v16);
      sub_100004B18((uint64_t)a1, a2, (uint64_t)v10, v118, v122, v90, v91);
      goto LABEL_42;
    }
    if (!a9)
    {
      uint64_t v16 = 0;
      goto LABEL_49;
    }
    uint64_t v116 = v125;
    uint64_t v56 = v126;
    if (v124 == 2)
    {
      sub_100040D28(a3, a4, 0);
    }
    else
    {
      if (v124 != 1) {
        goto LABEL_58;
      }
      sub_100040BB8(a3, a4, 0, 0, 0);
    }
    uint64_t v116 = v125;
    uint64_t v56 = v126;
LABEL_58:
    uint64_t v16 = 0;
    if (v116) {
      goto LABEL_32;
    }
    goto LABEL_30;
  }
  uint64_t v16 = v48;
  sub_10004458C("error (%d) writing bitmap @ %lld\n", v49, v50, v51, v52, v53, v54, v55, v48);
  uint64_t v46 = 635;
  int v47 = v16;
LABEL_28:
  sub_100048B34((char *)v46, v47);
LABEL_29:
  uint64_t v56 = v126;
  uint64_t v57 = (void *)v21;
  if (!v125) {
    goto LABEL_30;
  }
LABEL_32:
  if (!v56 && v57) {
    free(v57);
  }
  return v16;
}

uint64_t sub_1000050C8(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a4 + a3;
  if (a4 + a3 <= a3) {
    return 0;
  }
  uint64_t v7 = a3;
  unint64_t v10 = *(unsigned int *)(a1[3] + 36);
  uint64_t v11 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(a1[3] + 32)));
  while (1)
  {
    unint64_t v12 = (v7 & (unint64_t)v11) / v10;
    uint64_t v13 = v5 - v7 >= v10 + v12 * v10 - (v7 & v11) ? v10 + v12 * v10 - (v7 & v11) : v5 - v7;
    uint64_t result = sub_100004BC0(a1, a2, v7, v13, 0, 0, 0, a5, 1, 0);
    if (result) {
      break;
    }
    v7 += v13;
    if (v7 >= v5) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1000051A0(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4)
{
  return sub_1000050C8(a1, a2, a3, a4, 2);
}

uint64_t sub_1000051A8(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unsigned char *a5, uint64_t (*a6)(unint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7)
{
  if (a2 + a1 > a3 && a4 + a3 > a1)
  {
    *a5 = 1;
    if (a1 <= a3) {
      unint64_t v14 = a3;
    }
    else {
      unint64_t v14 = a1;
    }
    unint64_t v15 = v14 - a1;
    if (a2 - (v14 - a1) >= a3 - v14 + a4) {
      uint64_t v16 = a3 - v14 + a4;
    }
    else {
      uint64_t v16 = a2 - (v14 - a1);
    }
    uint64_t result = a6(v14, v16, 1, a7);
    if (!result)
    {
      if (a1 >= a3 || (uint64_t result = a6(a1, v15, 0, a7), !result))
      {
        if (a2 - v16 <= v15) {
          return 0;
        }
        uint64_t result = a6(v16 + v14, a2 - v16 - v15, 0, a7);
        if (!result) {
          return 0;
        }
      }
    }
  }
  else
  {
    uint64_t result = 0;
    *a5 = 0;
  }
  return result;
}

unint64_t sub_100005294(unint64_t result)
{
  if (!(byte_100091AF8 | byte_100091B60))
  {
    uint64_t v1 = 0;
    uint64_t v2 = *(void *)(result + 24);
    char v3 = 1;
    do
    {
      char v4 = v3;
      unint64_t v5 = *(unsigned int *)(v2 + 32);
      unint64_t v6 = *(void *)(v2 + 48 * v1 + 48);
      memset(v12, 170, sizeof(v12));
      if (is_mul_ok(v6, v5)) {
        unint64_t v7 = v6 * v5;
      }
      else {
        unint64_t v7 = 0x40000000000;
      }
      uint64_t result = sub_10002BEA4(0, v5, v6, v7, &v12[2], &v12[1]);
      if (!result)
      {
        uint64_t v8 = v12[2] / v5 + v12[1];
        uint64_t result = sub_10002BFAC(v5, v12[2], v12[1], v8, v12, 0);
        uint64_t v10 = v12[0];
        uint64_t v9 = v12[1];
        uint64_t v11 = (char *)&unk_100091A98 + 104 * v1;
        *((void *)v11 + 1) = v12[0];
        *((void *)v11 + 2) = v9;
        *(void *)uint64_t v11 = v9;
        v11[24] = 1;
        *((void *)v11 + 5) = v8;
        *((void *)v11 + 6) = v10;
        *((void *)v11 + 4) = v10;
        v11[56] = 1;
      }
      char v3 = 0;
      *((unsigned char *)&unk_100091A98 + 104 * v1 + 96) = 1;
      uint64_t v1 = 1;
    }
    while ((v4 & 1) != 0);
  }
  return result;
}

uint64_t sub_1000053B0(unint64_t a1, uint64_t a2, int a3, void (*a4)(_OWORD *, uint64_t, uint64_t), uint64_t a5)
{
  unint64_t v19 = a1;
  v22[0] = 0xAAAAAAAAAAAAAAAALL;
  v22[1] = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v8 = a1 + a2;
  int v17 = 0;
  int v18 = -1431655766;
  int v16 = 0;
  char v15 = 1;
  do
  {
    *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v21[6] = v9;
    v21[7] = v9;
    v21[5] = v9;
    v21[3] = v9;
    v21[4] = v9;
    v21[1] = v9;
    v21[2] = v9;
    v20[1] = v9;
    v21[0] = v9;
    v20[0] = v9;
    unsigned int v14 = 0;
    char v13 = 0;
    uint64_t v10 = sub_10000550C(&v19, v8, a3, (unsigned int *)v22, (uint64_t)&v18, &v17, &v16, (uint64_t)v21, (uint64_t)v20, (int *)&v14, &v13, &v15);
    if (v10) {
      break;
    }
    uint64_t v11 = v14;
    if ((int)v14 >= 1)
    {
      if (v13) {
        sub_100005CFC((uint64_t)v21, (uint64_t)v20, v14);
      }
      a4(v21, 4 * v11, a5);
    }
  }
  while (v19 < v8 || v17 > 0);
  return v10;
}

uint64_t sub_10000550C(unint64_t *a1, unint64_t a2, int a3, unsigned int *a4, uint64_t a5, int *a6, int *a7, uint64_t a8, uint64_t a9, int *a10, unsigned char *a11, unsigned char *a12)
{
  int v18 = *a6;
  int v19 = *a7;
  if (*a6 >= 1 && v19 < v18)
  {
    int v22 = 0;
    *a11 = 0;
    *a10 = 0;
    int v19 = *a7;
    while (1)
    {
      if (v22 >= 1
        && *(unsigned char *)(a5 + v19)
        && *(unsigned __int8 *)(a5 + v19) < *(unsigned __int8 *)(a9 + (v22 - 1)))
      {
        *a11 = 1;
      }
      *(_DWORD *)(a8 + 4 * v22) = a4[v19];
      uint64_t v23 = *a7;
      *a7 = v23 + 1;
      LOBYTE(v23) = *(unsigned char *)(a5 + v23);
      uint64_t v24 = *a10;
      *a10 = v24 + 1;
      *(unsigned char *)(a9 + v24) = v23;
      int v19 = *a7;
      int v18 = *a6;
      if (*a7 >= *a6 || !*(unsigned char *)(a5 + v19)) {
        break;
      }
      int v22 = *a10;
    }
  }
  if (v19 < v18) {
    return 0;
  }
  uint64_t result = 0;
  *a6 = 0;
  *a7 = 0;
  uint64_t v25 = (unsigned __int8 *)*a1;
  if (*a1 < a2)
  {
    while (1)
    {
      uint64_t v27 = v25 + 1;
      *a1 = (unint64_t)(v25 + 1);
      unsigned int v28 = *v25;
      uint64_t result = 92;
      if (!*v25 || v28 == 47) {
        return result;
      }
      if ((v28 & 0x80) == 0)
      {
        uint64_t result = 0;
        if (v28 - 91 < 0xFFFFFFE6) {
          int v66 = 1;
        }
        else {
          int v66 = a3;
        }
        if (v66) {
          unsigned int v67 = *v25;
        }
        else {
          unsigned int v67 = v28 + 32;
        }
        *a4 = v67;
        *a6 = 1;
        *(unsigned char *)a5 = 0;
LABEL_138:
        *a12 = 0;
        return result;
      }
      if (v28 - 225 > 0xB)
      {
        if (v28 - 194 <= 0x1D && (unint64_t)v27 < a2)
        {
          unsigned int v33 = *v27 ^ 0x80;
          if (v33 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0x1F) << 6) | v33;
            uint64_t v27 = v25 + 2;
            goto LABEL_52;
          }
        }
      }
      else if ((unint64_t)(v25 + 2) < a2)
      {
        unsigned int v29 = *v27 ^ 0x80;
        if (v29 <= 0x3F)
        {
          unsigned int v30 = v25[2] ^ 0x80;
          if (v30 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0xF) << 12) | (v29 << 6) | v30;
            uint64_t v27 = v25 + 3;
            goto LABEL_52;
          }
        }
      }
      if (v28 > 0xEF)
      {
        if (v28 > 0xFD)
        {
          unsigned __int8 v36 = 0;
          goto LABEL_41;
        }
        if (v28 <= 0xF7) {
          char v34 = 3;
        }
        else {
          char v34 = 4;
        }
        BOOL v35 = v28 > 0xFB;
      }
      else
      {
        char v34 = v28 > 0xDF;
        BOOL v35 = v28 > 0xBF;
      }
      if (v35) {
        unsigned __int8 v36 = v34 + 1;
      }
      else {
        unsigned __int8 v36 = v34;
      }
LABEL_41:
      unsigned int v31 = -1;
      if ((unint64_t)&v27[v36] <= a2)
      {
        unsigned int v37 = v28 & ~(-1 << (6 - v36));
        if (v36 == 1) {
          goto LABEL_49;
        }
        if (v36 == 2
          || v36 == 3
          && (uint64_t v27 = v25 + 2, v38 = v25[1] ^ 0x80, v31 = -1, v38 <= 0x3F)
          && (unsigned int v37 = v38 | (v37 << 6), v37 <= 0x10F))
        {
          int v39 = *v27++;
          int v40 = v39 ^ 0x80;
          unsigned int v31 = -1;
          if ((v39 ^ 0x80u) <= 0x3F)
          {
            unsigned int v37 = v40 | (v37 << 6);
            if ((v37 & 0xFFE0) != 0x360)
            {
LABEL_49:
              int v41 = *v27++;
              int v42 = v41 ^ 0x80;
              if ((v41 ^ 0x80u) > 0x3F || (unsigned int v31 = v42 | (v37 << 6), (signed int)v31 < dword_1000674A0[v36])) {
                unsigned int v31 = -1;
              }
            }
          }
        }
      }
LABEL_52:
      *a1 = (unint64_t)v27;
      if ((int)v31 < 1) {
        return result;
      }
      *(unsigned char *)a5 = 0;
      if (v31 >= 0xF0000)
      {
        if ((~v31 & 0xFFFE) == 0) {
          goto LABEL_139;
        }
LABEL_55:
        *a4 = v31;
        goto LABEL_63;
      }
      int v43 = v31;
      if (v31 >> 10 >= 0xC9)
      {
        if (v31 - 918016 < 0xFFFFFE00) {
          goto LABEL_139;
        }
        int v43 = v31 - 711680;
      }
      int v44 = (unsigned __int16)word_1000674B0[v43 >> 8];
      if (!word_1000674B0[v43 >> 8]) {
        goto LABEL_62;
      }
      if (v44 == 0xFFFF) {
        goto LABEL_139;
      }
      if ((v44 & 0xFF00) == 0xAD00)
      {
LABEL_62:
        *a4 = v31;
        *(unsigned char *)a5 = v44;
        goto LABEL_63;
      }
      if ((unint64_t)(((uint64_t)v43 >> 8) - 172) <= 0x2A) {
        goto LABEL_77;
      }
      int v52 = word_100069EB8[16 * (v44 & 0xFFF) + (v43 >> 4)];
      if (!v52)
      {
LABEL_83:
        *a4 = v31;
        *(unsigned char *)a5 = v52;
        goto LABEL_84;
      }
      if (v52 == 0xFFFF) {
        goto LABEL_139;
      }
      if ((v52 & 0xFF00) == 0xAE00)
      {
        if ((word_100067AFC[v52] >> (v43 & 0xF))) {
          goto LABEL_139;
        }
        *a4 = v31;
        int v45 = 1;
        if (v31 <= 0x4FF && (a3 & 1) == 0) {
          *a4 = word_10006B118[v31];
        }
        goto LABEL_64;
      }
      if ((v52 & 0xFF00) == 0xAD00) {
        goto LABEL_83;
      }
      if (v52 == 44032 || (unsigned int v54 = (unsigned __int16)word_10006BB18[16 * (v52 & 0xFFF) + (v43 & 0xF)], v54 == 44032))
      {
LABEL_77:
        signed int v48 = v31 - 44032;
        int v49 = v48 / 28;
        int v50 = v48 / 588;
        *(_WORD *)(a5 + 1) = 0;
        int v51 = v48 % 28;
        *a4 = v50 + 4352;
        a4[1] = (unsigned __int16)(v49
                                 - 21
                                 * (((__int16)((49933 * (__int16)v49) >> 16) >> 4)
                                  + ((unsigned __int16)(((49933 * (__int16)v49) >> 16) & 0x8000) >> 15))
                                 + 4449);
        if (v51)
        {
          a4[2] = v51 + 4519;
          int v45 = 3;
        }
        else
        {
          int v45 = 2;
        }
        goto LABEL_64;
      }
      if (v54 == 0xFFFF)
      {
LABEL_139:
        int v68 = -1;
LABEL_140:
        *a6 = v68;
        return result;
      }
      if (((unsigned __int16)(v54 + 1792) >> 8) <= 0xB6u)
      {
        if (!v54 || (v54 & 0xFF00) == 0xAD00)
        {
          *a4 = v31;
          *(unsigned char *)a5 = v54;
        }
        else
        {
          *a4 = v54;
        }
LABEL_84:
        if ((a3 & 1) == 0)
        {
          uint64_t v53 = (int)*a4;
          if ((int)v53 <= 1279)
          {
            unsigned int v31 = word_10006B118[v53];
            goto LABEL_55;
          }
        }
LABEL_63:
        int v45 = 1;
LABEL_64:
        *a6 = v45;
        goto LABEL_65;
      }
      switch(((v54 & 0xF000) - 45056) >> 12)
      {
        case 0u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_110;
          }
          unint64_t v69 = 0;
          uint64_t v55 = (char *)&unk_100067C0A + 4 * (v54 & 0x7FF);
          int v45 = 2;
          goto LABEL_115;
        case 1u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_110;
          }
          unint64_t v69 = 0;
          uint64_t v55 = (char *)&unk_10006881E + 6 * (v54 & 0x7FF);
          int v45 = 3;
          goto LABEL_115;
        case 2u:
          unint64_t v69 = 0;
          uint64_t v56 = (unsigned __int16 *)((char *)&unk_100068D52 + 2 * (v54 & 0x3FF));
          unsigned int v58 = *v56;
          uint64_t v55 = (char *)(v56 + 1);
          unsigned int v57 = v58;
          goto LABEL_112;
        case 3u:
          if ((v54 & 0x800) != 0 && a3)
          {
LABEL_110:
            *a4 = v31;
            int v45 = 1;
            goto LABEL_64;
          }
          uint64_t v55 = 0;
          unint64_t v69 = (int *)((char *)&unk_100068EE0 + 4 * (v54 & 0x7FF));
          int v45 = 1;
LABEL_115:
          uint64_t v60 = 0;
          unint64_t v70 = a12;
          int v71 = a3;
          do
          {
            if (v55)
            {
              int v62 = *(unsigned __int16 *)v55;
              v55 += 2;
              int v61 = v62;
            }
            else
            {
              int v61 = *v69++;
            }
            a4[v60] = v61;
            if (v60)
            {
              uint64_t v72 = v60;
              uint64_t v73 = v55;
              char v63 = sub_100005D80(v61);
              uint64_t v60 = v72;
              uint64_t v55 = v73;
              *(unsigned char *)(a5 + v72) = v63;
            }
            ++v60;
            a12 = v70;
            a3 = v71;
          }
          while (v45 != v60);
          if (v71) {
            goto LABEL_128;
          }
          uint64_t v64 = (int)*a4;
          if ((int)v64 <= 1279) {
            *a4 = word_10006B118[v64];
          }
          if (v45 < 2) {
            goto LABEL_63;
          }
          uint64_t v65 = (v45 - 1);
          if (a4[v65] == 837) {
            a4[v65] = 953;
          }
LABEL_128:
          *a6 = v45;
          if (v45 < 1) {
            return 92;
          }
          break;
        case 4u:
          uint64_t v55 = 0;
          uint64_t v59 = (_DWORD *)((char *)&unk_100069D5C + 4 * (v54 & 0x3FF));
          unsigned int v57 = *v59;
          unint64_t v69 = v59 + 1;
LABEL_112:
          int v45 = v57 & 0xF;
          *(unsigned char *)a5 = v57 >> 4;
          if ((v45 - 5) >= 0xFFFFFFFC) {
            goto LABEL_115;
          }
          int v68 = 0;
          goto LABEL_140;
        default:
          goto LABEL_139;
      }
LABEL_65:
      if (!*(unsigned char *)a5 || *a12)
      {
        uint64_t result = 0;
        goto LABEL_138;
      }
      int v46 = *a10;
      if (v45 + *a10 > 32) {
        return 92;
      }
      uint64_t v47 = 0;
      do
      {
        if (v46 >= 1
          && *(unsigned char *)(a5 + v47)
          && *(unsigned __int8 *)(a5 + v47) < *(unsigned __int8 *)(a9 + (v46 - 1)))
        {
          *a11 = 1;
        }
        *(_DWORD *)(a8 + 4 * v46) = a4[v47];
        *(unsigned char *)(a9 + *a10) = *(unsigned char *)(a5 + v47++);
        int v46 = *a10 + 1;
        *a10 = v46;
      }
      while (v47 < *a6);
      *a6 = 0;
      uint64_t v25 = (unsigned __int8 *)*a1;
      if (*a1 >= a2) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100005CFC(uint64_t result, uint64_t a2, unsigned int a3)
{
  if ((int)a3 >= 2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = result + 4 * a3 - 4;
    do
    {
      uint64_t v5 = *(unsigned __int8 *)(a2 + a3 - 1);
      unint64_t v6 = (int *)v4;
      uint64_t v7 = a3 - 2;
      do
      {
        uint64_t v8 = *(unsigned __int8 *)(a2 + v7);
        if (v5 < v8)
        {
          long long v9 = (unsigned char *)(a2 + v7);
          int v10 = *v6;
          *unint64_t v6 = *(v6 - 1);
          uint64_t result = *(unsigned __int8 *)(a2 + v7);
          v9[1] = result;
          *(v6 - 1) = v10;
          *long long v9 = v5;
          uint64_t v8 = v5;
        }
        --v6;
        uint64_t v5 = v8;
      }
      while (v7-- > v3);
      ++v3;
    }
    while (v3 != a3 - 1);
  }
  return result;
}

uint64_t sub_100005D80(int a1)
{
  if (a1 >= 983040) {
    return 0;
  }
  if (a1 == 953) {
    return 240;
  }
  int v2 = a1 - 711680;
  if (a1 <= 205823) {
    int v2 = a1;
  }
  LOWORD(v3) = word_1000674B0[v2 >> 8];
  if ((_WORD)v3) {
    BOOL v4 = (v3 & 0xFF00) == 44288;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return v3;
  }
  int v3 = word_100069EB8[16 * (v3 & 0xFFF) + (v2 >> 4)];
  if (!v3) {
    return v3;
  }
  if ((v3 & 0xFF00) == 0xAE00) {
    return 0;
  }
  if ((v3 & 0xFF00) == 0xAD00) {
    return v3;
  }
  __int16 v5 = word_10006BB18[16 * (v3 & 0xFFF) + (v2 & 0xF)];
  if ((v5 & 0xFF00) == 0xAD00) {
    return v5;
  }
  else {
    return 0;
  }
}

const char *sub_100005E48()
{
  return "2317.60.23.0.1";
}

uint64_t sub_100005E54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_10004435C("usage: fsck_apfs [ [-q | -n | -y] [-l] [-s] [-W] [-S] [-o] [-b num] [-c] [-C] [-d]\n\t\t[-E path] [-F | -M] [-g | -x] [-T [-D]] ] device\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  sub_10004435C("       -q            quick check if the superblock and checkpoint superblock are valid.\n", v9, v10, v11, v12, v13, v14, v15, vars0a);
  sub_10004435C("       -n            verify only (answer \"no\" to questions)\n", v16, v17, v18, v19, v20, v21, v22, vars0b);
  sub_10004435C("       -y            always repair (answer \"yes\" to questions)\n", v23, v24, v25, v26, v27, v28, v29, vars0c);
  sub_10004435C("       -l            live fsck (lock down for verify-only)\n", v30, v31, v32, v33, v34, v35, v36, vars0d);
  sub_10004435C("       -s            print space verification summary\n", v37, v38, v39, v40, v41, v42, v43, vars0e);
  sub_10004435C("       -S            skip iteration of snapshots, although no repairs can be made.\n", v44, v45, v46, v47, v48, v49, v50, vars0f);
  sub_10004435C("       -o            repair overallocations; please do not run an older fsck_apfs on newer systems with this option\n",
    v51,
    v52,
    v53,
    v54,
    v55,
    v56,
    v57,
    vars0g);
  sub_10004435C("       -b <num>      set default cache block size to <num> KiB\n", v58, v59, v60, v61, v62, v63, v64, vars0h);
  sub_10004435C("       -c            enable cache statistics\n", v65, v66, v67, v68, v69, v70, v71, vars0i);
  sub_10004435C("       -C            force a sync prior to freezing for live fsck\n", v72, v73, v74, v75, v76, v77, v78, vars0j);
  sub_10004435C("       -d            print extra debugging information\n", v79, v80, v81, v82, v83, v84, v85, vars0k);
  sub_10004435C("       -E <path>     write warning/error information to <path>; Use \"-\" for stdout\n",
    v86,
    v87,
    v88,
    v89,
    v90,
    v91,
    v92,
    vars0l);
  sub_10004435C("       -F            force checking of encrypted volumes\n", v93, v94, v95, v96, v97, v98, v99, vars0m);
  sub_10004435C("       -M            skip checks which require encrypted volumes to be unlocked\n", v100, v101, v102, v103, v104, v105, v106, vars0n);
  sub_10004435C("       -g            print output in form suitable for automatic parsing\n", v107, v108, v109, v110, v111, v112, v113, vars0o);
  sub_10004435C("       -x            print output in XML\n", v114, v115, v116, v117, v118, v119, v120, vars0p);
  sub_10004435C("       -W            treat warnings as errors\n", v121, v122, v123, v124, v125, v126, v127, vars0q);
  sub_10004435C("       -T            tree node repair\n", v128, v129, v130, v131, v132, v133, v134, vars0r);

  return sub_10004435C("       -D            scavenge disk\n", v135, v136, v137, v138, v139, v140, v141, a9);
}

char *sub_100005F64(const char *a1, _DWORD *a2)
{
  CFMutableDictionaryRef properties = 0;
  *a2 = -1;
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v4 = 5;
  }
  else {
    uint64_t v4 = 0;
  }
  __int16 v5 = &a1[v4];
  if (*v5 == 114) {
    unint64_t v6 = v5 + 1;
  }
  else {
    unint64_t v6 = v5;
  }
  if (strncmp(v6, "disk", 4uLL))
  {
    sub_100044674("%s: not a valid disk name/path\n", v7, v8, v9, v10, v11, v12, v13, (char)a1);
    return 0;
  }
  CFDictionaryRef v14 = IOBSDNameMatching(kIOMasterPortDefault, 0, v6);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v14);
  if (!MatchingService)
  {
    sub_100044674("%s: couldn't find APFS container\n", v16, v17, v18, v19, v20, v21, v22, (char)v6);
    int v31 = 0;
    goto LABEL_35;
  }
  io_object_t v23 = MatchingService;
  if (IOObjectConformsTo(MatchingService, "AppleAPFSSnapshot"))
  {
    parent[0] = -1431655766;
    if (IORegistryEntryGetParentEntry(v23, "IOService", parent))
    {
      sub_100044674("%s: error %d from IORegistryEntryGetParentEntry\n", v24, v25, v26, v27, v28, v29, v30, (char)v6);
      int v31 = 0;
LABEL_34:
      IOObjectRelease(v23);
      goto LABEL_35;
    }
    IOObjectRelease(v23);
    io_object_t v23 = parent[0];
  }
  if (IOObjectConformsTo(v23, "AppleAPFSVolume"))
  {
    *(void *)&long long v32 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v32 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v84 = v32;
    long long v85 = v32;
    long long v82 = v32;
    long long v83 = v32;
    long long v80 = v32;
    long long v81 = v32;
    *(_OWORD *)parent = v32;
    long long v79 = v32;
    io_registry_entry_t entry = -1431655766;
    if (IORegistryEntryGetLocationInPlane(v23, "IOService", (char *)parent))
    {
      sub_100044674("%s: error %d from IORegistryEntryGetLocationInPlane\n", v33, v34, v35, v36, v37, v38, v39, (char)v6);
      goto LABEL_33;
    }
    *a2 = atoi((const char *)parent) - 1;
    if (IORegistryEntryGetParentEntry(v23, "IOService", &entry)
      || (IOObjectRelease(v23), io_object_t v23 = entry, IORegistryEntryGetParentEntry(entry, "IOService", &entry)))
    {
      sub_100044674("%s: error %d from IORegistryEntryGetParentEntry\n", v43, v44, v45, v46, v47, v48, v49, (char)v6);
      goto LABEL_33;
    }
    IOObjectRelease(v23);
    io_object_t v23 = entry;
  }
  else if (!IOObjectConformsTo(v23, "AppleAPFSMedia"))
  {
    parent[0] = -1431655766;
    if (!IORegistryEntryCreateIterator(v23, "IOService", 1u, parent))
    {
      io_object_t v40 = IOIteratorNext(parent[0]);
      if (v40)
      {
        io_object_t v41 = v40;
        while (!IOObjectConformsTo(v41, "AppleAPFSMedia"))
        {
          IOObjectRelease(v41);
          io_object_t v41 = IOIteratorNext(parent[0]);
          if (!v41) {
            goto LABEL_24;
          }
        }
        IOObjectRelease(parent[0]);
        io_object_t v42 = v23;
        io_object_t v23 = v41;
      }
      else
      {
LABEL_24:
        io_object_t v42 = parent[0];
      }
      IOObjectRelease(v42);
    }
  }
  if (IORegistryEntryCreateCFProperties(v23, &properties, kCFAllocatorDefault, 0))
  {
    sub_100044674("%s: error %d from IORegistryEntryCreateCFProperties\n", v50, v51, v52, v53, v54, v55, v56, (char)v6);
    goto LABEL_33;
  }
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(properties, @"BSD Name");
  if (!Value)
  {
    sub_100044674("%s: can't get BSD name of container\n", v59, v60, v61, v62, v63, v64, v65, (char)v6);
    goto LABEL_33;
  }
  memset(v77, 170, sizeof(v77));
  unint64_t v76 = 0xAAAAAAAAAAAAAAAALL;
  strcpy(__s1, "/dev/r");
  if (!CFStringGetCString(Value, &__s1[6], 26, 0x8000100u))
  {
    sub_100044674("%s: can't create path to container\n", v66, v67, v68, v69, v70, v71, v72, (char)v6);
LABEL_33:
    int v31 = 0;
    if (!v23) {
      goto LABEL_35;
    }
    goto LABEL_34;
  }
  int v31 = 1;
  if (v23) {
    goto LABEL_34;
  }
LABEL_35:
  if (properties) {
    CFRelease(properties);
  }
  if (v31) {
    return strdup(__s1);
  }
  return 0;
}

uint64_t start(int a1, char *const *a2)
{
  uint64_t v55 = 0;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  LODWORD(v52) = -1;
  LODWORD(v53) = 1;
  srandomdev();
  sub_100048A64();
  char v4 = 0;
  uint64_t v5 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  int v6 = 0;
  while (2)
  {
    int v50 = 0;
    uint64_t v7 = getopt_long(a1, a2, "b:cCdE:fFglnMopqsSWxyZTD", (const option *)&off_100074000, &v50);
    uint64_t v15 = 1;
    switch((int)v7)
    {
      case 'C':
        BYTE13(v53) = 1;
        goto LABEL_37;
      case 'D':
        v6 |= 0x100u;
        LOBYTE(v54) = 1;
        goto LABEL_37;
      case 'E':
        uint64_t v24 = optarg;
        if (!optarg)
        {
          uint64_t v15 = v5;
          goto LABEL_38;
        }
        if (!strcmp(optarg, "-")) {
          uint64_t v25 = __stdoutp;
        }
        else {
          uint64_t v25 = fopen(v24, "w");
        }
        uint64_t v55 = v25;
        BYTE4(v48) |= v25 == 0;
        goto LABEL_37;
      case 'F':
        BYTE12(v53) = 1;
        goto LABEL_37;
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'U':
      case 'V':
      case 'X':
      case 'Y':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
      case 'a':
      case 'e':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'm':
      case 'r':
      case 't':
      case 'u':
      case 'v':
      case 'w':
        goto LABEL_44;
      case 'M':
        BYTE11(v53) = 1;
        goto LABEL_37;
      case 'S':
        v6 |= 0x10u;
        BYTE10(v53) = 1;
        goto LABEL_37;
      case 'T':
        v6 |= 0x80u;
        HIBYTE(v53) = 1;
        goto LABEL_37;
      case 'W':
        BYTE14(v53) = 1;
        goto LABEL_37;
      case 'Z':
        LOBYTE(v48) = 1;
        goto LABEL_37;
      case 'b':
        dword_100074044 = strtoul(optarg, 0, 10) << 10;
        goto LABEL_37;
      case 'c':
        byte_100091B68 = 1;
        goto LABEL_37;
      case 'd':
        DWORD2(v52) = 1;
        goto LABEL_37;
      case 'f':
        goto LABEL_38;
      case 'g':
        LODWORD(v53) = 2;
        goto LABEL_37;
      case 'l':
        v6 |= 1u;
        char v4 = 1;
        BYTE6(v53) = 1;
        goto LABEL_37;
      case 'n':
        v6 |= 4u;
        HIDWORD(v52) = 1;
        BYTE5(v53) = 1;
        goto LABEL_37;
      case 'o':
        v6 |= 0x20u;
        BYTE9(v53) = 1;
        goto LABEL_37;
      case 'p':
        BYTE4(v47) = 1;
        goto LABEL_37;
      case 'q':
        BYTE4(v53) = 1;
        if ((v6 & 2) == 0)
        {
          HIDWORD(v52) = 1;
          BYTE5(v53) = 1;
        }
        uint64_t v15 = v5;
        v6 |= 8u;
        goto LABEL_38;
      case 's':
        v6 |= 0x40u;
        BYTE7(v53) = 1;
        goto LABEL_37;
      case 'x':
        LODWORD(v53) = 3;
        goto LABEL_37;
      case 'y':
        v6 |= 2u;
        HIDWORD(v52) = 2;
        BYTE5(v53) = 0;
        uint64_t v15 = v5;
        BYTE10(v53) = 0;
        goto LABEL_38;
      default:
        if (!v7)
        {
          if (optarg)
          {
            __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
            uint64_t v16 = strtol(optarg, &__endptr, 0);
            if (*__endptr || v16 < 0 || v16 >= 101)
            {
              uint64_t v27 = "Invalid volume index passed\n";
              goto LABEL_46;
            }
            DWORD1(v52) = v16;
            LOBYTE(v47) = 1;
          }
LABEL_37:
          uint64_t v15 = v5;
LABEL_38:
          uint64_t v5 = v15;
          continue;
        }
        if (v7 != -1 || (uint64_t v26 = optind, a1 - optind != 1))
        {
LABEL_44:
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          return 64;
        }
        if ((v6 & 2) != 0 && (v6 & 5) != 0)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Conflicting options: [ -y ] option cannot be run with the [ -n | -l ] options\n";
          goto LABEL_46;
        }
        if ((v6 & 0xD) == 1)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Missing required option: [ -l ] option requires the [ -n ] or [ -q ] option\n";
          goto LABEL_46;
        }
        if ((v6 & 0x14) == 0x10)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Missing required option: [ -S ] option requires the [ -n ] option\n";
          goto LABEL_46;
        }
        if ((v6 & 0x20) != 0 && (v6 & 0xC) != 0)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Conflicting options: [ -o ] option cannot be run with the [ -n | -q ] options\n";
          goto LABEL_46;
        }
        if ((v6 & 0x80) != 0 && (v6 & 0xC) != 0)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Conflicting options: [ -T ] option cannot be run with the [ -n | -q ] options\n";
          goto LABEL_46;
        }
        if ((v6 & 0x180) == 0x100)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Missing required option: [ -D ] option requires the [ -T ] option\n";
          goto LABEL_46;
        }
        if ((~v6 & 0x48) == 0)
        {
          sub_100005E54(v7, v8, v9, v10, v11, v12, v13, v14, v46);
          uint64_t v27 = "Conflicting options: [ -s ] option cannot be run with the [ -q ] option\n";
          goto LABEL_46;
        }
        qword_100092138 = (uint64_t)a2[optind];
        byte_100092140 = v4;
        sub_100003D28();
        sub_10001F5A8();
        atexit(sub_10001F480);
        if ((v47 & 1) == 0) {
          sub_100043E2C();
        }
        if (v5) {
          sub_100044674("option -f is not implemented, ignoring\n", v29, v30, v31, v32, v33, v34, v35, v46);
        }
        if ((v48 & 0x100000000) != 0) {
          sub_100044674("Could not open error file: %s\n", v29, v30, v31, v32, v33, v34, v35, (char)optarg);
        }
        if ((v47 & 0x100000000) != 0) {
          sub_100044674("option -p is not implemented, ignoring\n", v29, v30, v31, v32, v33, v34, v35, v46);
        }
        if (v48) {
          sub_100044674("option -Z is deprecated, ignoring\n", v29, v30, v31, v32, v33, v34, v35, v46);
        }
        uint64_t v36 = a2[v26];
        if (v47)
        {
          __endptr = (char *)0xAAAAAAAAAAAAAAAALL;
          if (strnlen(v36, 9uLL) < 9 || strncmp(v36, "/dev/fd/", 8uLL))
          {
            uint64_t v27 = "Invalid disk file-descriptor path\n";
            goto LABEL_46;
          }
          uint64_t v45 = strtol(v36 + 8, &__endptr, 0);
          uint64_t v27 = "Invalid disk file-descriptor passed\n";
          if (!*__endptr && v45 < 0x80000000)
          {
            LODWORD(v52) = v45;
            *(void *)&long long v51 = v36;
            *((void *)&v51 + 1) = strdup(v36);
            return sub_10004B29C((uint64_t)&v51);
          }
LABEL_46:
          sub_10004435C(v27, v17, v18, v19, v20, v21, v22, v23, v46);
          return 64;
        }
        else if (access(v36, 0))
        {
          uint64_t v37 = __error();
          strerror(*v37);
          sub_10004458C("unable to access %s: %s\n", v38, v39, v40, v41, v42, v43, v44, (char)v36);
          return 66;
        }
        else
        {
          *(void *)&long long v51 = v36;
          *((void *)&v51 + 1) = sub_100005F64(v36, (_DWORD *)&v52 + 1);
          if (!*((void *)&v51 + 1))
          {
            *((void *)&v51 + 1) = strdup(v36);
            DWORD1(v52) = -1;
          }
          return sub_10004B29C((uint64_t)&v51);
        }
    }
  }
}

BOOL sub_100006948(uint64_t a1, unsigned int a2)
{
  if (a2 < 0x19) {
    return 0;
  }
  if (*(void *)a1 != 0x6C7070612E6D6F63 || *(void *)(a1 + 7) != 0x2E736670612E656CLL) {
    return 0;
  }
  return *(void *)(a1 + 15) == 0x726F746167727570 && *(_WORD *)(a1 + 23) == 11897;
}

uint64_t sub_1000069B8(int8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  int v7 = a4;
  char v8 = a3;
  v48[0] = a4;
  v48[1] = a5;
  char v46 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v47 = a3;
  uint64_t v18 = sub_10002CE38(a1->i64, a2, (uint64_t *)&v46);
  if (!v18)
  {
    sub_10004458C("no snap_meta tree entry found for omap_snap entry with xid %llu\n", v11, v12, v13, v14, v15, v16, v17, v8);
    if ((a6 & 1) == 0
      && !sub_10004641C(qword_100091B70, "Delete omap_snap entries? ", v19, v20, v21, v22, v23, v24, v45))
    {
      return 89;
    }
    LODWORD(v48[0]) = v7 | 1;
    uint64_t v25 = sub_100039A6C(v46, 0, &v47, 8, v48, 16);
    if (v25)
    {
      uint64_t v18 = v25;
      char v26 = strerror(v25);
      sub_10004458C("error updating omap_snap entry: %s\n", v27, v28, v29, v30, v31, v32, v33, v26);
      uint64_t v34 = 657;
LABEL_8:
      sub_100048B34((char *)v34, v18);
      return v18;
    }
    uint64_t v35 = sub_1000311BC(a1, *(_DWORD *)(*(void *)(a2 + 72) + 24), *(_DWORD *)(a2 + 112), *(void *)(*(void *)(a2 + 40) + 8), *(void *)(*(void *)(a2 + 72) + 8), *(void *)(a1->i64[1] + 16), 2);
    uint64_t v18 = v35;
    if (v35)
    {
      char v36 = strerror(v35);
      sub_10004458C("error updating the reap list: %s\n", v37, v38, v39, v40, v41, v42, v43, v36);
      uint64_t v34 = 658;
      goto LABEL_8;
    }
  }
  return v18;
}

uint64_t sub_100006AF8(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, char a5)
{
  uint64_t v73 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = sub_10002D180(a1, a2, (uint64_t *)&v73);
  if (!v15)
  {
    sub_10004458C("no omap_snap tree entry found for snap_meta entry with xid %llu\n", v8, v9, v10, v11, v12, v13, v14, *a3);
    if ((a5 & 1) == 0
      && !sub_10004641C(qword_100091B70, "Delete snap_meta entries? ", v16, v17, v18, v19, v20, v21, v71))
    {
      return 89;
    }
    uint64_t v22 = sub_10002B3F0((uint64_t)v73, *(unsigned __int16 *)(a4 + 48), (const void *)(a4 + 50));
    if (v22)
    {
      uint64_t v15 = v22;
      if (v22 != 2)
      {
        char v52 = strerror(v22);
        sub_10004458C("failed to remove snap_name entry: %s\n", v53, v54, v55, v56, v57, v58, v59, v52);
        uint64_t v60 = 660;
        goto LABEL_15;
      }
      sub_100044674("tried to remove snap_name entry but it's not there!\n", v23, v24, v25, v26, v27, v28, v29, v71);
    }
    *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v75[10] = v30;
    *(_OWORD *)__str = v30;
    *(_OWORD *)uint64_t v75 = v30;
    int v31 = snprintf(__str, 0x2AuLL, "%s%s%llx", "com.apple.apfs.", "purgatory.", *(void *)a3 & 0xFFFFFFFFFFFFFFFLL);
    uint64_t v32 = (unsigned __int16 *)malloc_type_malloc(v31 + 51, 0x57BDCF46uLL);
    if (!v32)
    {
      sub_10004458C("failed to allocate memory for repair\n", v33, v34, v35, v36, v37, v38, v39, v72);
      uint64_t v15 = 12;
      uint64_t v60 = 704;
      int v61 = 12;
LABEL_16:
      sub_100048B34((char *)v60, v61);
      return v15;
    }
    uint64_t v40 = v32;
    unsigned __int16 v41 = v31 + 1;
    v32[24] = v41;
    uint64_t v42 = v32 + 25;
    memcpy(v32 + 25, __str, v41);
    uint64_t v43 = sub_100039A6C(v73, 0, a3, 8, v40, v41 + 50);
    if (v43)
    {
      uint64_t v15 = v43;
      char v44 = strerror(v43);
      sub_10004458C("error updating snap_meta entry: %s\n", v45, v46, v47, v48, v49, v50, v51, v44);
      sub_100048B34((char *)0x295, v15);
      free(v40);
      return v15;
    }
    uint64_t v15 = sub_10002B2CC(v73, v40[24], v42, *(void *)a3 & 0xFFFFFFFFFFFFFFFLL);
    free(v40);
    if (!v15) {
      return v15;
    }
    char v62 = strerror(v15);
    sub_10004458C("failed to insert snap_name entry: %s\n", v63, v64, v65, v66, v67, v68, v69, v62);
    uint64_t v60 = 662;
LABEL_15:
    int v61 = v15;
    goto LABEL_16;
  }
  return v15;
}

uint64_t sub_100006D3C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v62 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v63 = 0xAAAAAAAAAAAAAAAALL;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v59 = 0u;
  long long v57 = 0u;
  memset(v58, 0, sizeof(v58));
  BYTE8(v59) = 1;
  long long v55 = 0u;
  long long v56 = 0u;
  memset(v54, 0, sizeof(v54));
  BYTE8(v55) = 1;
  if (*(void *)(*(void *)(a2 + 72) + 56))
  {
    uint64_t v6 = sub_10002CE38(a1, a2, &v63);
    if (v6)
    {
      uint64_t v14 = v6;
      sub_10004458C("unable to init omap_snap tree for snapshot repair\n", v7, v8, v9, v10, v11, v12, v13, v53);
      uint64_t v15 = 663;
LABEL_15:
      sub_100048B34((char *)v15, v14);
      return v14;
    }
    uint64_t v16 = sub_100038D78((uint64_t)v58, v63, 0, 0, 0);
    if (v16)
    {
      uint64_t v14 = v16;
      char v17 = strerror(v16);
      sub_10004458C("unable to init omap_snap tree iterator for snapshot repair: %s\n", v18, v19, v20, v21, v22, v23, v24, v17);
      uint64_t v15 = 664;
      goto LABEL_15;
    }
  }
  if (*(void *)(*(void *)(a2 + 40) + 152))
  {
    uint64_t v25 = sub_10002D180((uint64_t)a1, a2, &v62);
    if (v25)
    {
      uint64_t v14 = v25;
      sub_10004458C("unable to init snap_meta tree for snapshot repair\n", v26, v27, v28, v29, v30, v31, v32, v53);
      uint64_t v33 = 665;
      goto LABEL_11;
    }
    uint64_t v34 = sub_100038D78((uint64_t)v54, v62, 0, 0, 0);
    if (v34)
    {
      uint64_t v14 = v34;
      char v35 = strerror(v34);
      sub_10004458C("unable to init snap_meta tree iterator for snapshot repair: %s\n", v36, v37, v38, v39, v40, v41, v42, v35);
      uint64_t v33 = 666;
LABEL_11:
      sub_100048B34((char *)v33, v14);
      if (*(void *)&v58[0]) {
        (*(void (**)(_OWORD *))&v58[0])(v58);
      }
      return v14;
    }
  }
  uint64_t v43 = sub_10002C50C((uint64_t)v58, (uint64_t)v54, (uint64_t (*)(long long *, long long *, int *, uint64_t))sub_100006EF0, a3);
  uint64_t v14 = v43;
  if (v43)
  {
    char v44 = strerror(v43);
    sub_10004458C("error iterating trees during snapshot repair: %s\n", v45, v46, v47, v48, v49, v50, v51, v44);
    uint64_t v15 = 667;
    goto LABEL_15;
  }
  return v14;
}

uint64_t sub_100006EF0(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(uint64_t **)a1;
  uint64_t v9 = *(uint64_t **)(a1 + 8);
  uint64_t v11 = *(char **)a2;
  uint64_t v12 = *(void *)(a2 + 8);
  if (*(void *)a1 && (*(_DWORD *)(a1 + 16) < 8u || *(_DWORD *)(a1 + 20) < 0x10u)) {
    return 22;
  }
  if (!v11) {
    return sub_100006FB4(a4, *v10, *v9, v9[1], a5, a6, a7, a8);
  }
  if (*(_DWORD *)(a2 + 16) < 8u) {
    return 22;
  }
  if (*(void *)v11 >> 60 != 1)
  {
    uint64_t result = 0;
    *a3 = 2;
    return result;
  }
  if (*(_DWORD *)(a2 + 20) < 0x32u) {
    return 22;
  }
  if (!v10) {
    return sub_100007038(a4, v11, v12);
  }
  unint64_t v14 = *(void *)v11 & 0xFFFFFFFFFFFFFFFLL;
  if (*v10 < v14)
  {
    *a3 = 1;
    return sub_100006FB4(a4, *v10, *v9, v9[1], a5, a6, a7, a8);
  }
  if (v14 < *v10)
  {
    *a3 = 2;
    return sub_100007038(a4, v11, v12);
  }
  return 0;
}

uint64_t sub_100006FB4(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *((void *)&v10 + 1) = a3;
  uint64_t v11 = a4;
  *(void *)&long long v10 = a2;
  if (a3) {
    return 0;
  }
  sub_10004458C("no snap_meta tree entry found for omap_snap entry with xid %llu\n", a2, a3, a4, a5, a6, a7, a8, a2);
  sub_100048B34((char *)0x290, 92);
  return sub_100027E70(a1, 4u, 0, 0, 1, &v10, 8u, (unsigned char *)&v10 + 8, 0x10u);
}

uint64_t sub_100007038(_DWORD *a1, char *a2, uint64_t a3)
{
  if (sub_100006948(a3 + 50, *(unsigned __int16 *)(a3 + 48)))
  {
    sub_100044674("found a snapshot in the purgatory (xid %llu) with no corresponding omap entry\n", v6, v7, v8, v9, v10, v11, v12, *a2);
    return 0;
  }
  else
  {
    sub_10004458C("no omap_snap tree entry found for snap_meta entry with xid %llu\n", v6, v7, v8, v9, v10, v11, v12, *a2);
    sub_100048B34((char *)0x293, 92);
    return sub_100027E70(a1, 5u, 0, 0, 1, (long long *)a2, 8u, (unsigned char *)a3, *(unsigned __int16 *)(a3 + 48) + 50);
  }
}

void sub_1000070EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 48;
  if (!a3) {
    uint64_t v3 = 40;
  }
  uint64_t v4 = *(void *)(a2 + v3);
  byte_100074F28 = 0;
  unsigned int v5 = *(unsigned __int16 *)(v4 + 964);
  if (v5 > 0x3F)
  {
    if (v5 != 576 && v5 != 64) {
      return;
    }
  }
  else
  {
    if (*(_WORD *)(v4 + 964)) {
      BOOL v6 = v5 == 2;
    }
    else {
      BOOL v6 = 1;
    }
    if (!v6) {
      return;
    }
  }
  if (*(void *)(v4 + 1056) == *(void *)(v4 + 16) && (a3 || (*(unsigned char *)(*(void *)(a2 + 40) + 1064) & 2) == 0))
  {
    if (*(void *)(v4 + 1072))
    {
      if (!sub_100038040((uint64_t)&unk_100074F30, 0, 0, 0x8000000, 2, 0, 0, 4096, 4, 8, 0, 0, (uint64_t)sub_1000306C8))sub_10003A18C((uint64_t)&unk_100074F30, 0, 0); {
      if (sub_10001CF74((uint64_t)&unk_100074F30, (uint64_t)"doc id", (uint64_t)sub_100007230))
      }
      {
        sub_100044674("failed to register the doc id tree in the fsck memory storage\n", v7, v8, v9, v10, v11, v12, v13, v14);
        sub_100048B34((char *)0x584, 12);
      }
    }
    dword_100074F70 = 0;
    byte_100074F28 = 1;
  }
}

uint64_t sub_100007230()
{
  uint64_t result = sub_10003A268((uint64_t)&unk_100074F30, 0);
  byte_100074F28 = 0;
  return result;
}

uint64_t sub_10000725C(uint64_t *a1, int8x16_t *a2, unint64_t a3, _DWORD *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v6 = a2[3].i64[1];
  LODWORD(v90) = *a4;
  if (byte_100074F28 != 1) {
    return 0;
  }
  unint64_t v89 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v11 = v6;
  if (qword_100074F68)
  {
    unsigned int v87 = 8;
    unsigned int v88 = 4;
    uint64_t v14 = sub_1000380B0((uint64_t)dword_100074F30, 0, 0, &v90, &v88, 4u, &v89, &v87);
    if (!v14)
    {
      if (v89)
      {
        if (v89 == a3) {
          goto LABEL_24;
        }
        sub_10004458C("inode with file-id %llu has doc-id %u but doc-id tree record has file-id %llu\n", v15, v16, v17, v18, v19, v20, v21, a3);
        uint64_t v32 = sub_100048B34((char *)0x3FB, 92);
        if (v6) {
          goto LABEL_17;
        }
      }
      else
      {
        sub_10004458C("inode with file-id %llu has doc-id %u but doc-id is already in use\n", v15, v16, v17, v18, v19, v20, v21, a3);
        uint64_t v32 = sub_100048B34((char *)0x3FC, 92);
        if (v6) {
          goto LABEL_17;
        }
        if (!sub_10004641C(qword_100091B70, "Allocate new doc-id %u for file-id %llu? ", v34, v35, v36, v37, v38, v39, *(_DWORD *)(a5 + 48)))return 92; {
        int v75 = *(_DWORD *)(a5 + 48);
        }
        *(_DWORD *)(a5 + 48) = v75 + 1;
        *a4 = v75;
        uint64_t v76 = sub_100045D54(a1, a2);
        if (v76)
        {
          uint64_t v22 = v76;
          char v77 = strerror(v76);
          sub_10004458C("failed to write apfs superblock : %s\n", v78, v79, v80, v81, v82, v83, v84, v77);
          uint64_t v57 = 1021;
          goto LABEL_27;
        }
        *a6 = 1;
        LODWORD(v90) = *a4;
      }
      unint64_t v89 = a3;
LABEL_22:
      uint64_t v48 = sub_100027E70((int8x16_t *)a2[44].i32, 0xAu, 2, 0, 1, &v90, 4u, &v89, 8u);
      if (v48)
      {
        uint64_t v22 = v48;
        char v49 = v90;
        strerror(v48);
        sub_10004458C("failed to insert doc-id tree repair for doc-id %u, file-id %llu : %s\n", v50, v51, v52, v53, v54, v55, v56, v49);
        uint64_t v57 = 1025;
LABEL_27:
        sub_100048B34((char *)v57, v22);
        return v22;
      }
      goto LABEL_24;
    }
    uint64_t v22 = v14;
    if (v14 != 2)
    {
      int v40 = *a4;
      strerror(v14);
      sub_10004458C("failed to lookup doc-id %u error : %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
      sub_100048B34((char *)0x400, v22);
LABEL_19:
      int v31 = 0;
      goto LABEL_20;
    }
    uint64_t v11 = a2[3].i64[1];
  }
  char v86 = -86;
  uint64_t v23 = sub_10003E760((uint64_t)a1, (uint64_t)a2, v11, a3, &v86);
  if (v23)
  {
LABEL_18:
    uint64_t v22 = v23;
    goto LABEL_19;
  }
  if (v86)
  {
LABEL_8:
    int v31 = 0;
    uint64_t v22 = 0;
    goto LABEL_20;
  }
  if (v6)
  {
    sub_10004458C("inode with file-id %llu has doc-id %u but doc-id tree record is missing\n", v24, v25, v26, v27, v28, v29, v30, a3);
    uint64_t v32 = sub_100048B34((char *)0x3FF, 92);
LABEL_17:
    uint64_t v23 = sub_100027AD0((uint64_t)v32, v33, v34, v35, v36, v37, v38, v39);
    goto LABEL_18;
  }
  uint64_t v68 = a2[2].i64[1];
  if ((*(unsigned char *)(v68 + 1064) & 1) != 0 && *(void *)(v68 + 1088) < a3) {
    goto LABEL_8;
  }
  sub_10004458C("inode with file-id %llu has doc-id %u but doc-id tree record is missing\n", v24, v25, v26, v27, v28, v29, v30, a3);
  sub_100048B34((char *)0x3FE, 92);
  if (*(void *)(a2[2].i64[1] + 1072))
  {
    uint64_t v22 = 0;
    unint64_t v89 = a3;
    int v31 = 1;
  }
  else
  {
    if (sub_10004641C(qword_100091B70, "Mark volume for doc-id tree building on next mount? ", v69, v70, v71, v72, v73, v74, v85))
    {
      uint64_t v23 = sub_100007618(a1, a2);
      goto LABEL_18;
    }
    int v31 = 0;
    uint64_t v22 = 92;
  }
LABEL_20:
  if (!v22)
  {
    if (v31) {
      goto LABEL_22;
    }
LABEL_24:
    if (qword_100074F68)
    {
      unint64_t v89 = 0;
      uint64_t v58 = sub_100039A6C(dword_100074F30, 0, &v90, 4, &v89, 8);
      uint64_t v22 = v58;
      if (!v58)
      {
        ++dword_100074F70;
        return v22;
      }
      char v59 = v90;
      strerror(v58);
      sub_10004458C("failed to mark cached doc-id tree record %d as verified error : %s\n", v60, v61, v62, v63, v64, v65, v66, v59);
      uint64_t v57 = 1026;
      goto LABEL_27;
    }
    return 0;
  }
  return v22;
}

uint64_t sub_100007618(uint64_t *a1, int8x16_t *a2)
{
  *(_DWORD *)(a2[2].i64[1] + 1064) = *(_DWORD *)(a2[2].i64[1] + 1064) & 0xFFFFFFFC | 2;
  uint64_t v2 = sub_100045D54(a1, a2);
  uint64_t v3 = v2;
  if (v2)
  {
    char v4 = strerror(v2);
    sub_10004458C("failed to write apfs superblock : %s\n", v5, v6, v7, v8, v9, v10, v11, v4);
    sub_100048B34((char *)0x3FA, v3);
  }
  else
  {
    byte_100074F28 = 0;
  }
  return v3;
}

uint64_t sub_100007690(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v39) = -1431655766;
  unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
  if (qword_100074F68 && (uint64_t v37 = 0, sub_10003A064((uint64_t)&unk_100074F30, 0, &v37), v37 != dword_100074F70))
  {
    unsigned int v35 = 8;
    int v36 = 4;
    unsigned int v6 = sub_100038610((uint64_t)&unk_100074F30, 0, &v39, &v36, &v38, &v35);
    if (!v6)
    {
      uint64_t v14 = (_DWORD *)(a2 + 704);
      do
      {
        if (v38)
        {
          sub_10004458C("doc-id tree: record exists for doc-id %u, file-id %llu but no inode references this doc-id\n", v7, v8, v9, v10, v11, v12, v13, v39);
          uint64_t v15 = sub_100048B34((char *)0x403, 92);
          if (a3)
          {
            sub_100027AD0((uint64_t)v15, v16, v17, v18, v19, v20, v21, v22);
          }
          else
          {
            uint64_t v23 = sub_100027E70(v14, 0xAu, 0, 0, 0, &v39, 4u, 0, 0);
            if (v23)
            {
              uint64_t v5 = v23;
              char v25 = v39;
              strerror(v23);
              sub_10004458C("failed to add doc-id tree repair record, doc-id %u : %s\n", v26, v27, v28, v29, v30, v31, v32, v25);
              sub_100048B34((char *)0x404, v5);
              goto LABEL_14;
            }
          }
        }
        unsigned int v33 = 8;
        unsigned int v34 = 4;
        unsigned int v6 = sub_1000380B0((uint64_t)&unk_100074F30, 0, 2, &v39, &v34, 4u, &v38, &v33);
      }
      while (!v6);
    }
    if (v6 == 2) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = v6;
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
LABEL_14:
  sub_10003A268((uint64_t)&unk_100074F30, 0);
  byte_100074F28 = 0;
  return v5;
}

uint64_t sub_100007840(uint64_t *a1, int8x16_t *a2, uint64_t a3)
{
  uint64_t v6 = 6;
  if (!a3) {
    uint64_t v6 = 5;
  }
  uint64_t v7 = a2->i64[v6];
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v92[2] = v8;
  v92[3] = v8;
  v92[0] = v8;
  v92[1] = v8;
  uint64_t v9 = sub_100038040((uint64_t)v92, (uint64_t)a1, (uint64_t)a2, *(_DWORD *)(v7 + 1068) & 0xC0000000, (unsigned __int16)*(_DWORD *)(v7 + 1068), 34, 0, *(_DWORD *)(a1[1] + 36), 4, 8, 0, *(void *)(v7 + 1072), (uint64_t)sub_1000306C8);
  if (v9)
  {
    uint64_t v10 = v9;
    char v11 = strerror(v9);
    sub_10004458C("failed to initialize the doc-id tree: %s\n", v12, v13, v14, v15, v16, v17, v18, v11);
    uint64_t v19 = 1031;
LABEL_5:
    sub_100048B34((char *)v19, v10);
    return v10;
  }
  if (*(void *)(v7 + 1072))
  {
    if (byte_100074F28 == 1)
    {
      LODWORD(v91[0]) = 0;
      if (qword_100074F68)
      {
        uint64_t v21 = sub_100035168((uint64_t)v92, a3, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100007BB8, (uint64_t)v91, 0, 0);
        uint64_t v10 = v21;
        if (!v21) {
          goto LABEL_23;
        }
        char v22 = strerror(v21);
        sub_10004458C("failed to populate cached doc-id tree : %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
        uint64_t v30 = sub_100048B34((char *)0x406, v10);
        byte_100074F28 = 0;
        if (LODWORD(v91[0]))
        {
LABEL_24:
          sub_10003A268((uint64_t)dword_100074F30, 0);
LABEL_25:
          if (v10) {
            return v10;
          }
          goto LABEL_26;
        }
        if (a3)
        {
          uint64_t v38 = sub_100027AD0((uint64_t)v30, v31, v32, v33, v34, v35, v36, v37);
        }
        else
        {
          if (!sub_10004641C(qword_100091B70, "Mark volume for doc-id tree building on next mount? ", v32, v33, v34, v35, v36, v37, v88))goto LABEL_23; {
          uint64_t v38 = sub_100007618(a1, a2);
          }
        }
        uint64_t v10 = v38;
LABEL_23:
        if (byte_100074F28) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v39 = sub_100035168((uint64_t)v92, a3, 0, 0, 0, 0);
      if (v39)
      {
        uint64_t v10 = v39;
        char v40 = strerror(v39);
        sub_10004458C("failed to traverse doc-id tree : %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
        uint64_t v48 = sub_100048B34((char *)0x40A, v10);
        if (a3)
        {
          uint64_t v56 = sub_100027AD0((uint64_t)v48, v49, v50, v51, v52, v53, v54, v55);
        }
        else
        {
          if (!sub_10004641C(qword_100091B70, "Mark volume for doc-id tree building on next mount? ", v50, v51, v52, v53, v54, v55, v89))return v10; {
          uint64_t v56 = sub_100007618(a1, a2);
          }
        }
        uint64_t v10 = v56;
        goto LABEL_25;
      }
    }
  }
LABEL_26:
  uint64_t v57 = *(void *)(v7 + 1080);
  if (!v57) {
    return 0;
  }
  *(void *)&long long v58 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v58 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v91[2] = v58;
  v91[3] = v58;
  v91[0] = v58;
  v91[1] = v58;
  uint64_t v59 = sub_100038040((uint64_t)v91, (uint64_t)a1, (uint64_t)a2, *(_DWORD *)(v7 + 1068) & 0xC0000000, (unsigned __int16)*(_DWORD *)(v7 + 1068), 34, 0, *(_DWORD *)(a1[1] + 36), 4, 8, 0, v57, (uint64_t)sub_1000306C8);
  if (v59)
  {
    uint64_t v10 = v59;
    char v60 = strerror(v59);
    sub_10004458C("failed to initialize the prev doc-id tree: %s\n", v61, v62, v63, v64, v65, v66, v67, v60);
    uint64_t v19 = 1035;
    goto LABEL_5;
  }
  uint64_t v68 = sub_100035168((uint64_t)v91, a3, 0, 0, 0, 0);
  if (!v68) {
    return 0;
  }
  uint64_t v69 = v68;
  char v70 = strerror(v68);
  sub_10004458C("failed to traverse prev doc-id tree : %s\n", v71, v72, v73, v74, v75, v76, v77, v70);
  uint64_t v78 = sub_100048B34((char *)0x40E, v69);
  if (a3) {
    return sub_100027AD0((uint64_t)v78, v79, v80, v81, v82, v83, v84, v85);
  }
  uint64_t v10 = 0;
  unsigned int v87 = *(unsigned __int16 *)(v7 + 964);
  if (v87 > 0x3F)
  {
    if (v87 != 64 && v87 != 576) {
      goto LABEL_40;
    }
  }
  else if (*(_WORD *)(v7 + 964) && v87 != 2)
  {
LABEL_40:
    uint64_t v10 = v69;
    if (!sub_10004641C(qword_100091B70, "Mark volume for doc-id tree cleanup on next mount? ", v80, v81, v82, v83, v84, v85, v90))return v10; {
    return sub_100007618(a1, a2);
    }
  }
  return v10;
}

uint64_t sub_100007BB8(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, void *a5, uint64_t a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a2 + 56);
  if (a7) {
    *a7 = 0;
  }
  if (byte_100074F28 != 1) {
    return 0;
  }
  if (*a5)
  {
    uint64_t v12 = sub_100039A6C(dword_100074F30, 0, a3, 4, a5, 8);
    uint64_t v13 = v12;
    if (v12)
    {
      int v14 = *a3;
      strerror(v12);
      sub_10004458C("failed to insert cached doc-id record, doc-id %u,file-id %llu : %s\n", v15, v16, v17, v18, v19, v20, v21, v14);
    }
  }
  else
  {
    sub_10004458C("invalid doc-id record, file-id is 0 for doc-id %u\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, (uint64_t)a7, a8, *a3);
    char v22 = sub_100048B34((char *)0x3F9, 92);
    if (v11)
    {
      uint64_t v13 = sub_100027AD0((uint64_t)v22, v23, v24, v25, v26, v27, v28, v29);
    }
    else
    {
      uint64_t v31 = sub_100027E70((_DWORD *)(a2 + 704), 0xAu, 0, 0, 1, (long long *)a3, 4u, 0, 0);
      uint64_t v13 = v31;
      if (v31)
      {
        int v32 = *a3;
        strerror(v31);
        sub_10004458C("failed to add doc-id repair (deletion), doc-id %u : %s\n", v33, v34, v35, v36, v37, v38, v39, v32);
      }
    }
  }
  if (a7) {
    *a7 = v13;
  }
  return v13;
}

char *sub_100007CFC()
{
  if (!sub_100038040((uint64_t)&unk_100074F78, 0, 0, 0x8000000, 2, 0, 0, 4096, 8, 80, 0, 0, (uint64_t)sub_1000306FC))sub_10003A18C((uint64_t)&unk_100074F78, 0, 0); {
  uint64_t result = (char *)sub_10001CF74((uint64_t)&unk_100074F78, (uint64_t)"file info", (uint64_t)sub_100007DD0);
  }
  if (result)
  {
    sub_100044674("failed to register the file info tree in the fsck memory storage\n", v1, v2, v3, v4, v5, v6, v7, v8);
    return sub_100048B34((char *)0x586, 12);
  }
  return result;
}

uint64_t sub_100007DD0()
{
  if (qword_100074FB0) {
    uint64_t result = sub_10003A268((uint64_t)&unk_100074F78, 0);
  }
  qword_100075008 = 0;
  return result;
}

uint64_t sub_100007E08(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100007E24(a1, 0, 0, a4, a2, a3, 0, 0);
}

uint64_t sub_100007E24(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned char *a7, uint64_t a8)
{
  *(void *)&long long v9 = a5 & 0xFFFFFFFFFFFFFFFLL | 0xD000000000000000;
  *((void *)&v9 + 1) = a6 & 0xFFFFFFFFFFFFFFLL | 0x200000000000000;
  if (a1) {
    return sub_100027E70(a1, 8u, a2, a3, a4, &v9, 0x10u, a7, a8);
  }

  return sub_100027AD0(0, a2, a3, a4, a5, a6, (uint64_t)a7, a8);
}

void sub_100007EA0(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, uint64_t a8)
{
  if (qword_100074FB0)
  {
    sub_100007FC8(a2);
    if (!v23)
    {
      if (byte_100075002)
      {
        if (!a8) {
          a8 = a2;
        }
        sub_100044674("file info: found more than one attribution tag with matching computed hash, invalid entry (hash %llu)\n", v16, v17, v18, v19, v20, v21, v22, a8);
        sub_100048B34((char *)0x557, 92);
        if (a7) {
          uint64_t v24 = a7;
        }
        else {
          uint64_t v24 = 9;
        }
        sub_100007E24(a1, 0, 0, 1, v24, a8, 0, 0);
      }
      else
      {
        *(void *)&xmmword_100074FB8 = a3;
        qword_100074FC8 = a4;
        *(void *)&xmmword_100074FD8 = a5;
        byte_100075002 = 1;
        *(void *)&xmmword_100074FF0 = a7;
        *((void *)&xmmword_100074FF0 + 1) = a8;
        word_100075000 = a6;
      }
    }
  }
}

double sub_100007FC8(uint64_t a1)
{
  uint64_t v9 = a1;
  if (!sub_10000886C(a1) && !qword_100075008)
  {
    long long v7 = 0u;
    long long v8 = 0u;
    long long v5 = 0u;
    long long v6 = 0u;
    long long v4 = 0u;
    unsigned int v2 = 80;
    unsigned int v3 = 8;
    if ((sub_1000380B0((uint64_t)dword_100074F78, 0, 0, &v9, &v3, 8u, &v4, &v2) & 0xFFFFFFFD) == 0)
    {
      qword_100075008 = v9;
      xmmword_100074FD8 = v6;
      *(_OWORD *)&qword_100074FE8 = v7;
      *(long long *)((char *)&xmmword_100074FF0 + 8) = v8;
      double result = *(double *)&v5;
      xmmword_100074FB8 = v4;
      *(_OWORD *)&qword_100074FC8 = v5;
    }
  }
  return result;
}

void sub_100008084(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (qword_100074FB0)
  {
    char v4 = a2;
    sub_100007FC8(a2);
    if (!v13)
    {
      uint64_t v14 = *((void *)&xmmword_100074FB8 + 1) == -1;
      uint64_t v15 = v14 << 63 >> 63;
      ++*((void *)&xmmword_100074FB8 + 1);
      if (v15 != v14 || v15 < 0)
      {
        sub_100044674("file info: computed count overflow for hash (%llu)\n", v6, v7, v8, v9, v10, v11, v12, v4);
        *((void *)&xmmword_100074FB8 + 1) = -1;
        sub_100048B34((char *)0x51A, 84);
      }
      BOOL v16 = __CFADD__(qword_100074FD0, a3);
      qword_100074FD0 += a3;
      if (v16)
      {
        sub_100044674("file info: computed size overflow for hash (%llu)\n", v6, v7, v8, v9, v10, v11, v12, v4);
        qword_100074FD0 = -1;
        sub_100048B34((char *)0x51B, 84);
      }
      if (!qword_100074FE8) {
        qword_100074FE8 = a1;
      }
    }
  }
}

void sub_100008174(uint64_t a1, uint64_t a2)
{
  char v2 = a1;
  if (a2)
  {
    if (qword_100074FB0)
    {
      sub_100007FC8(a1);
      if (!v11)
      {
        BOOL v12 = __OFADD__(*((void *)&xmmword_100074FD8 + 1), a2);
        *((void *)&xmmword_100074FD8 + 1) += a2;
        if (v12)
        {
          sub_100044674("file info: clone size overflow for hash (%llu)\n", v4, v5, v6, v7, v8, v9, v10, v2);
          *((void *)&xmmword_100074FD8 + 1) = 0x7FFFFFFFFFFFFFFFLL;
          sub_100048B34((char *)0x555, 84);
        }
      }
    }
  }
}

void sub_100008204(uint64_t a1, uint64_t a2)
{
}

void sub_10000820C(uint64_t a1, uint64_t a2)
{
  if (qword_100074FB0)
  {
    char v3 = a1;
    sub_100007FC8(a1);
    if (!v11)
    {
      BOOL v12 = __CFADD__(qword_100074FD0, a2);
      qword_100074FD0 += a2;
      if (v12)
      {
        sub_100044674("file info: computed size overflow for hash (%llu)\n", v4, v5, v6, v7, v8, v9, v10, v3);
        qword_100074FD0 = -1;
        sub_100048B34((char *)0x567, 84);
      }
    }
  }
}

uint64_t sub_100008290(uint64_t a1, void *a2, uint64_t a3)
{
  if (!qword_100074FB0) {
    return 0;
  }
  uint64_t v6 = sub_10000886C(0);
  if (v6)
  {
    uint64_t v7 = v6;
    if (qword_100074FB0) {
      sub_10003A268((uint64_t)dword_100074F78, 0);
    }
    qword_100075008 = 0;
    return v7;
  }
  v70[0] = 0;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v65 = 0u;
  if (a3) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = a2 + 88;
  }
  v64[0] = 0;
  v64[1] = 0;
  v64[2] = v8;
  uint64_t v9 = malloc_type_malloc(0xEE0uLL, 0x345C1B66uLL);
  int v10 = sub_100003C30();
  if (!v9)
  {
    sub_100044674("file info: failed to allocate memory\n", v11, v12, v13, v14, v15, v16, v17, v49);
    uint64_t v7 = 12;
    sub_100048B34((char *)0x51D, 12);
    goto LABEL_17;
  }
  int v18 = v10;
  unsigned int v62 = 80;
  unsigned int v63 = 8;
  unsigned int v19 = sub_1000380B0((uint64_t)dword_100074F78, 0, 1, v70, &v63, 8u, &v65, &v62);
  if (v19)
  {
    BOOL v27 = v19 == 2;
LABEL_13:
    if (v27) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v19;
    }
    goto LABEL_17;
  }
  char v50 = 0;
  uint64_t v51 = 0;
  unint64_t v52 = -1;
  do
  {
    uint64_t v29 = v69;
    if ((void)v69) {
      uint64_t v30 = v69;
    }
    else {
      uint64_t v30 = v70[0];
    }
    if ((void)v68) {
      BOOL v31 = 1;
    }
    else {
      BOOL v31 = BYTE10(v69) == 0;
    }
    if (v31)
    {
      if (*((void *)&v68 + 1))
      {
        sub_100048B34((char *)0x537, 92);
        uint64_t v32 = sub_100007E24(v8, 1, 26, 1, *((uint64_t *)&v68 + 1), v30, 0, 0);
        if (v32) {
          return v32;
        }
        uint64_t v29 = v69;
      }
      if (v29)
      {
        uint64_t v32 = sub_100007E24(v8, 1, 27, 1, 9, v30, v70, 8);
        if (v32) {
          return v32;
        }
      }
      if (!BYTE10(v69))
      {
        uint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
        uint64_t v55 = 0xD000000000000009;
        uint64_t v56 = v70[0] & 0xFFFFFFFFFFFFFFLL | 0x200000000000000;
        unsigned int v60 = 16;
        int v59 = 3808;
        uint64_t v41 = sub_10003E25C(a1, a2, 13, &v61, v23, v24, v25, v26);
        if (v41) {
          goto LABEL_70;
        }
        uint64_t v42 = sub_1000380B0(v61, a3, 0, &v55, &v60, v60, v9, (unsigned int *)&v59);
        uint64_t v7 = v42;
        if ((v42 & 0xFFFFFFFD) != 0) {
          goto LABEL_17;
        }
        if (v42 == 2 || sub_10000895C((uint64_t)&v55, (uint64_t)v9, v59))
        {
          v64[0] = v51 + *((void *)&v65 + 1);
          unint64_t v43 = v52;
          if ((unint64_t)v68 < v52) {
            unint64_t v43 = v68;
          }
          v51 += *((void *)&v65 + 1);
          unint64_t v52 = v43;
          char v50 = 1;
          goto LABEL_63;
        }
        uint64_t v44 = v9[1];
        uint64_t v45 = *((void *)&v65 + 1) + *v9;
        *(void *)&long long v65 = *v9;
        *((void *)&v65 + 1) = v45;
        BYTE10(v69) = 1;
        *(void *)&long long v66 = v44;
        *((void *)&v66 + 1) += v44;
        uint64_t v46 = *((void *)&v67 + 1) + v9[2];
        *(void *)&long long v67 = v9[2];
        *((void *)&v67 + 1) = v46;
        WORD4(v69) = *((_WORD *)v9 + 12);
        *(void *)&long long v68 = 16;
        uint64_t v41 = sub_100039A6C(dword_100074F78, 0, v70, 8, &v65, 80);
        if (v41)
        {
LABEL_70:
          uint64_t v7 = v41;
          goto LABEL_17;
        }
      }
      if (WORD4(v69) > 1u) {
        goto LABEL_63;
      }
      if (*((void *)&v65 + 1) != (void)v65)
      {
        sub_100044674("file info: attribution tag (hash %llu): total count (%llu) does not match computed count (%llu)\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
        sub_100048B34((char *)0x51F, 92);
        uint64_t v55 = *((void *)&v65 + 1);
        uint64_t v56 = 0;
        uint64_t v57 = 0;
        __int16 v58 = 0;
        uint64_t v32 = sub_100007E24(v8, 1, 28, 0, 9, v70[0], &v55, 26);
        if (v32) {
          return v32;
        }
      }
      if (*((void *)&v66 + 1) != (void)v66)
      {
        sub_100044674("file info: attribution tag (hash %llu): physical size (%llu) does not match computed size (%llu)\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
        sub_100048B34((char *)0x520, 92);
        uint64_t v55 = 0;
        uint64_t v56 = *((void *)&v66 + 1);
        uint64_t v57 = 0;
        __int16 v58 = 0;
        uint64_t v32 = sub_100007E24(v8, 1, 29, 0, 9, v70[0], &v55, 26);
        if (v32) {
          return v32;
        }
      }
      if (v18)
      {
        sub_100044548("file info: attribution tag (hash %llu) skipping clone size repair because the clone mapping repairs were aborted\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
        goto LABEL_63;
      }
      if ((v67 & 0x8000000000000000) != 0)
      {
        sub_100044548("file info: attribution tag (hash %llu) skipping clone size repair: full clone size %llu > %llu\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
        uint64_t v47 = 1440;
LABEL_62:
        sub_100048B34((char *)v47, 92);
        goto LABEL_63;
      }
      if ((*((void *)&v67 + 1) & 0x8000000000000000) != 0)
      {
        sub_100044548("file info: attribution tag (hash %llu) skipping clone size repair because the computed clone size is negative\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
        uint64_t v47 = 1421;
        goto LABEL_62;
      }
      if (*((void *)&v67 + 1) == (void)v67) {
        goto LABEL_63;
      }
      sub_100044674("file info: attribution tag (hash %llu): full clone size (%llu) does not match computed size (%llu)\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
      sub_100048B34((char *)0x556, 92);
      uint64_t v55 = 0;
      uint64_t v56 = 0;
      uint64_t v57 = *((void *)&v67 + 1);
      __int16 v58 = 0;
      uint64_t v38 = v70[0];
      uint64_t v39 = &v55;
      uint64_t v34 = v8;
      uint64_t v35 = 1;
      uint64_t v36 = 30;
      uint64_t v37 = 9;
      uint64_t v40 = 26;
    }
    else
    {
      if (*((void *)&v68 + 1)) {
        uint64_t v33 = *((void *)&v68 + 1);
      }
      else {
        uint64_t v33 = 9;
      }
      sub_100044674("file info: orphan attribution tag with hash (%llu)\n", v20, v21, v22, v23, v24, v25, v26, v70[0]);
      sub_100048B34((char *)0x51E, 92);
      uint64_t v34 = v8;
      uint64_t v35 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = v33;
      uint64_t v38 = v30;
      uint64_t v39 = 0;
      uint64_t v40 = 0;
    }
    uint64_t v32 = sub_100007E24(v34, v35, v36, 0, v37, v38, v39, v40);
    if (v32) {
      return v32;
    }
LABEL_63:
    unsigned int v53 = 80;
    unsigned int v54 = 8;
    unsigned int v48 = sub_1000380B0((uint64_t)dword_100074F78, 0, 2, v70, &v54, 8u, &v65, &v53);
  }
  while (!v48);
  if (v48 == 2) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v48;
  }
  if (v50)
  {
    uint64_t v55 = v52 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
    unsigned int v19 = sub_10003E3C4(a1, a2, a3, 0, (unsigned __int8 *)&v55, 8, (uint64_t (*)(void))sub_1000089E8, (uint64_t)v64);
    BOOL v27 = v19 == -1;
    goto LABEL_13;
  }
LABEL_17:
  free(v9);
  sub_10003A268((uint64_t)dword_100074F78, 0);
  return v7;
}

uint64_t sub_10000886C(uint64_t a1)
{
  if (qword_100075008) {
    BOOL v1 = qword_100075008 == a1;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0;
  }
  uint64_t v5 = qword_100075008;
  if (xmmword_100074FF0 != 0
    || (*((void *)&xmmword_100074FB8 + 1)
      ? (BOOL v3 = *((void *)&xmmword_100074FB8 + 1) == (void)xmmword_100074FB8)
      : (BOOL v3 = 0),
        !v3
     || (qword_100074FD0 ? (BOOL v4 = qword_100074FD0 == qword_100074FC8) : (BOOL v4 = 0),
         !v4 || *((void *)&xmmword_100074FD8 + 1) != (void)xmmword_100074FD8)))
  {
    uint64_t result = sub_100039A6C(dword_100074F78, 0, &v5, 8, &xmmword_100074FB8, 80);
LABEL_22:
    if (result) {
      return result;
    }
    goto LABEL_23;
  }
  uint64_t result = sub_10003A048((uint64_t)dword_100074F78, 0, (uint64_t)&v5, 8);
  if (result != 2) {
    goto LABEL_22;
  }
LABEL_23:
  uint64_t result = 0;
  qword_100075008 = 0;
  return result;
}

BOOL sub_10000895C(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)&__n[1] = 0;
  __n[0] = -21846;
  uint64_t v4 = 1;
  if (!sub_10003EE64((unsigned __int16 *)(a2 + 26), a3 - 26, 1, &__n[1], __n, 0, 0))
  {
    uint64_t v5 = *(void *)(a1 + 8) & 0x1FFFFFFFFFFFFFLL;
    uint64_t v6 = *(const void **)&__n[1];
    CC_LONG v7 = strnlen(*(const char **)&__n[1], __n[0]);
    return v5 != sub_10004E898(v6, v7);
  }
  return v4;
}

uint64_t sub_1000089E8(char *a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v48 = 0;
  uint64_t v49 = 0;
  unsigned int v10 = sub_10003F4CC(a3, a4, 19, 8, &v48, a6, a7, a8);
  if (v10)
  {
    if (v10 == 2) {
      return 0;
    }
    else {
      return v10;
    }
  }
  else
  {
    uint64_t v12 = *v48;
    long long v47 = 0u;
    memset(v46, 0, sizeof(v46));
    unsigned int v44 = 80;
    unsigned int v45 = 8;
    if (!sub_1000380B0((uint64_t)dword_100074F78, 0, 1, &v49, &v45, 8u, v46, &v44))
    {
      while (BYTE10(v47) || v12 != v49)
      {
        unsigned int v42 = 80;
        unsigned int v43 = 8;
        if (sub_1000380B0((uint64_t)dword_100074F78, 0, 2, &v49, &v43, 8u, v46, &v42)) {
          return 0;
        }
      }
      sub_100044674("file info: inode (jobj_id 0x%llx) has unexpected attribution tag with hash (%llu)\n", v13, v14, v15, v16, v17, v18, v19, *a1);
      sub_100048B34((char *)0x51C, 92);
      uint64_t v11 = sub_100026DD0((_DWORD *)a5[2], *(void *)a1, 19, v22, v23, v24, v25, v26);
      if (v11
        || (uint64_t v11 = sub_100026D94((_DWORD *)a5[2], *(void *)a1 & 0xFFFFFFFFFFFFFFFLL, 0x10000000, v27, v28, v29, v30, v31), v11))
      {
        uint64_t v32 = *(void *)a1 & 0xFFFFFFFFFFFFFFFLL;
        strerror(v11);
        sub_10004458C("inode (jobj_id %llu): unable to add repair for unexpected xfield: %s\n", v33, v34, v35, v36, v37, v38, v39, v32);
        sub_100048B34((char *)0x536, v11);
        return v11;
      }
      uint64_t v40 = *a5;
      uint64_t v41 = a5[1] + 1;
      a5[1] = v41;
      if (v40 == v41) {
        return 0xFFFFFFFFLL;
      }
    }
    return 0;
  }
}

char *sub_100008B98(uint64_t a1)
{
  qword_100075010 = a1;
  if (!sub_100038040((uint64_t)&unk_100075018, 0, 0, 0x8000000, 2, 0, 0, 4096, 8, 24, 0, 0, (uint64_t)sub_1000306FC))sub_10003A18C((uint64_t)&unk_100075018, 0, 0); {
  uint64_t result = (char *)sub_10001CF74((uint64_t)&unk_100075018, (uint64_t)"crypto", (uint64_t)sub_100008C74);
  }
  if (result)
  {
    sub_100044674("failed to register the crypto tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
    return sub_100048B34((char *)0x582, 12);
  }
  return result;
}

uint64_t sub_100008C74()
{
  if (qword_100075050) {
    uint64_t result = sub_10003A268((uint64_t)&unk_100075018, 0);
  }
  qword_100075070 = 0;
  return result;
}

void sub_100008CAC(uint64_t a1, char *a2, _DWORD *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100075050)
  {
    uint64_t v12 = *(void *)a2 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v13 = *(void *)(a1 + 40);
    uint64_t v14 = *(void *)(v13 + 264);
    if (v12 == 4)
    {
      if ((v14 & 0x108) != 0 || (v14 & 1) != 0 && *(void *)(v13 + 976)) {
        goto LABEL_10;
      }
      if ((v14 & 9) != 0 && qword_100075010 != 0) {
        goto LABEL_10;
      }
    }
    else if ((v14 & 9) == 0)
    {
LABEL_10:
      sub_100008E38(v12);
      if (!v16)
      {
        BYTE8(xmmword_100075058) = 1;
        LODWORD(xmmword_100075058) = *a3;
      }
      return;
    }
    sub_100044674("found unexpected crypto state object (id %llu, refcnt %u)\n", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *a2);
    sub_100048B34((char *)0x340, -2);
    sub_100008DD0(a4, 0, 0, 0, (long long *)a2, 0, v17, v18);
  }
}

uint64_t sub_100008DD0(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, long long *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (a6) {
      unsigned int v9 = *(unsigned __int16 *)(a6 + 22) + 24;
    }
    else {
      unsigned int v9 = 0;
    }
    return sub_100027E70(a1, 8u, a2, a3, a4, a5, 8u, (unsigned char *)a6, v9);
  }
  else
  {
    return sub_100027AD0(0, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
}

double sub_100008E38(uint64_t a1)
{
  uint64_t v6 = a1;
  if (!sub_100009494(a1) && !qword_100075070)
  {
    long long v4 = 0uLL;
    uint64_t v5 = 0;
    unsigned int v2 = 24;
    unsigned int v3 = 8;
    if ((sub_1000380B0((uint64_t)dword_100075018, 0, 0, &v6, &v3, 8u, &v4, &v2) & 0xFFFFFFFD) == 0)
    {
      qword_100075070 = v6;
      double result = *(double *)&v4;
      xmmword_100075058 = v4;
      qword_100075068 = v5;
    }
  }
  return result;
}

void sub_100008EE4(uint64_t a1, uint64_t a2)
{
  if (qword_100075050)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    if ((unint64_t)(v2 + 1) > 6 || ((1 << (v2 + 1)) & 0x43) == 0)
    {
      sub_100008E38(*(void *)(a2 + 16));
      if (!v5)
      {
        if (v2 != 4 && v2 != a1 && !qword_100075068) {
          qword_100075068 = a1;
        }
        ++DWORD1(xmmword_100075058);
      }
    }
  }
}

double sub_100008F7C(uint64_t *a1, uint64_t a2)
{
  if (qword_100075050)
  {
    if (*(unsigned char *)(a2 + 7))
    {
      double result = sub_100008E38(4);
      if (v4) {
        return result;
      }
    }
    else
    {
      uint64_t v2 = *(void *)(a2 + 16);
      if (!v2) {
        return result;
      }
      if (v2 == 5) {
        return result;
      }
      uint64_t v5 = *a1;
      double result = sub_100008E38(*(void *)(a2 + 16));
      if (v6) {
        return result;
      }
      if (v2 != 4 && (v5 & 0xFFFFFFFFFFFFFFFLL) != v2 && !qword_100075068) {
        qword_100075068 = v5 & 0xFFFFFFFFFFFFFFFLL;
      }
    }
    ++DWORD1(xmmword_100075058);
  }
  return result;
}

double sub_100009020(uint64_t *a1, uint64_t a2)
{
  if (qword_100075050)
  {
    if (*(unsigned char *)(a2 + 7))
    {
      double result = sub_100008E38(4);
      if (v4) {
        return result;
      }
    }
    else
    {
      uint64_t v2 = *(void *)(a2 + 16);
      if (!v2) {
        return result;
      }
      if (v2 == 5) {
        return result;
      }
      uint64_t v5 = *a1;
      double result = sub_100008E38(*(void *)(a2 + 16));
      if (v6) {
        return result;
      }
      if (v2 != 4 && qword_100075068 == (v5 & 0xFFFFFFFFFFFFFFFLL)) {
        qword_100075068 = 0;
      }
    }
    --DWORD1(xmmword_100075058);
  }
  return result;
}

uint64_t sub_1000090C0(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!qword_100075050) {
    return 0;
  }
  uint64_t v60 = 0;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  uint64_t v6 = sub_100009494(0);
  if (v6) {
    goto LABEL_28;
  }
  unsigned int v55 = 24;
  unsigned int v56 = 8;
  unsigned int v7 = sub_1000380B0((uint64_t)dword_100075018, 0, 1, &v60, &v56, 8u, &v57, &v55);
  if (v7)
  {
LABEL_25:
    if (v7 == 2) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = v7;
    }
    goto LABEL_28;
  }
  while (1)
  {
    if ((_BYTE)v58)
    {
LABEL_17:
      if (v60 != 4)
      {
        if (HIDWORD(v57))
        {
          if (v57 >= HIDWORD(v57))
          {
            sub_100044674("refcnt (%u) of crypto state object (id %llu) is greater than expected (%u)\n", v8, v9, v10, v11, v12, v13, v14, v57);
            sub_100048B34((char *)0x348, -8);
            uint64_t v54 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000;
            *(void *)&v49[4] = 0;
            uint64_t v50 = 0;
            int v51 = 0;
            *(_DWORD *)uint64_t v49 = HIDWORD(v57);
            uint64_t v32 = (long long *)&v54;
            uint64_t v33 = v49;
            uint64_t v34 = a3;
            uint64_t v35 = 1;
            uint64_t v36 = 22;
            uint64_t v37 = 0;
          }
          else
          {
            sub_10004458C("refcnt (%u) of crypto state object (id %llu) is less than expected (%u)\n", v8, v9, v10, v11, v12, v13, v14, v57);
            sub_100048B34((char *)0x347, 92);
            uint64_t v54 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000;
            *(void *)&v49[4] = 0;
            uint64_t v50 = 0;
            int v51 = 0;
            *(_DWORD *)uint64_t v49 = HIDWORD(v57);
            uint64_t v32 = (long long *)&v54;
            uint64_t v33 = v49;
            uint64_t v34 = a3;
            uint64_t v35 = 1;
            uint64_t v36 = 22;
            uint64_t v37 = 1;
          }
        }
        else
        {
          sub_100044674("found orphan crypto state object (id %llu, refcnt %u)\n", v8, v9, v10, v11, v12, v13, v14, v60);
          sub_100048B34((char *)0x346, -8);
          *(void *)uint64_t v49 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000;
          uint64_t v32 = (long long *)v49;
          uint64_t v34 = a3;
          uint64_t v35 = 0;
          uint64_t v36 = 0;
          uint64_t v37 = 0;
          uint64_t v33 = 0;
        }
        uint64_t v29 = sub_100008DD0(v34, v35, v36, v37, v32, (uint64_t)v33, v30, v31);
        if (v29)
        {
LABEL_31:
          uint64_t v6 = v29;
          goto LABEL_28;
        }
      }
      goto LABEL_24;
    }
    *(void *)uint64_t v49 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v54 = v60 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000;
    unsigned int v52 = 3808;
    unsigned int v53 = 8;
    uint64_t v19 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x4E265DEFuLL);
    if (!v19) {
      break;
    }
    uint64_t v6 = sub_10003E25C(a1, (void *)a2, 7, (uint64_t *)v49, v15, v16, v17, v18);
    if (!v6) {
      uint64_t v6 = sub_1000380B0(*(uint64_t *)v49, qword_100075010, 0, &v54, &v53, v53, v19, &v52);
    }
    if (v6 == 2)
    {
      free(v19);
      sub_10004458C("missing crypto state object (id %llu) referenced by %u file extents / dstreams\n", v20, v21, v22, v23, v24, v25, v26, v60);
      sub_100048B34((char *)0x345, 92);
      if ((*(void *)(*(void *)(a2 + 40) + 264) & 0x109) == 0x100)
      {
        *(unsigned char *)(a2 + 13) = 1;
      }
      else
      {
        uint64_t v27 = v60;
        uint64_t v28 = v59;
        uint64_t v29 = sub_10000955C(a1, (void *)a2, a3, v60, v60, v12, v13, v14);
        if (v29) {
          goto LABEL_31;
        }
        if (v28)
        {
          uint64_t v29 = sub_10000955C(a1, (void *)a2, a3, v27, v28, v12, v13, v14);
          if (v29) {
            goto LABEL_31;
          }
        }
      }
    }
    else
    {
      if (v6) {
        goto LABEL_33;
      }
      LOBYTE(v58) = 1;
      LODWORD(v57) = *v19;
      HIDWORD(v57) += v57;
      free(v19);
    }
    if ((_BYTE)v58) {
      goto LABEL_17;
    }
LABEL_24:
    unsigned int v47 = 24;
    unsigned int v48 = 8;
    unsigned int v7 = sub_1000380B0((uint64_t)dword_100075018, 0, 2, &v60, &v48, 8u, &v57, &v47);
    if (v7) {
      goto LABEL_25;
    }
  }
  uint64_t v6 = 12;
LABEL_33:
  free(v19);
  char v39 = v60;
  strerror(v6);
  sub_10004458C("failed to look up crypto state object (id %llu): %s\n", v40, v41, v42, v43, v44, v45, v46, v39);
  sub_100048B34((char *)0x3EE, v6);
LABEL_28:
  sub_10003A268((uint64_t)dword_100075018, 0);
  return v6;
}

uint64_t sub_100009494(uint64_t a1)
{
  if (qword_100075070) {
    BOOL v1 = qword_100075070 == a1;
  }
  else {
    BOOL v1 = 1;
  }
  if (v1) {
    return 0;
  }
  long long v5 = xmmword_100075058;
  uint64_t v6 = qword_100075068;
  uint64_t v7 = qword_100075070;
  if (qword_100075070 == 4
    || (!v5 ? (BOOL v3 = BYTE8(v5) == 0) : (BOOL v3 = 1), v3 ? (v4 = v5 == DWORD1(v5)) : (v4 = 0), !v4))
  {
    uint64_t result = sub_100039A6C(dword_100075018, 0, &v7, 8, &v5, 24);
    goto LABEL_16;
  }
  uint64_t result = sub_10003A048((uint64_t)dword_100075018, 0, (uint64_t)&v7, 8);
  if (result != 2)
  {
LABEL_16:
    if (result) {
      return result;
    }
  }
  uint64_t result = 0;
  qword_100075070 = 0;
  return result;
}

uint64_t sub_10000955C(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  LODWORD(v13) = sub_10003E25C(a1, a2, 3, &v52, a5, a6, a7, a8);
  uint64_t v14 = malloc_type_calloc(1uLL, 0x340uLL, 0x57535DC4uLL);
  uint64_t v15 = (uint64_t *)malloc_type_calloc(1uLL, 0xEE0uLL, 0x3FE09C19uLL);
  uint64_t v23 = v15;
  if (v13 || !v14 || !v15)
  {
    if (v13) {
      uint64_t v13 = v13;
    }
    else {
      uint64_t v13 = 12;
    }
    sub_10004458C("unable to allocate memory to repair missing crypto state\n", v16, v17, v18, v19, v20, v21, v22, v45);
    uint64_t v37 = 1084;
LABEL_13:
    sub_100048B34((char *)v37, v13);
    goto LABEL_14;
  }
  int v50 = 3808;
  unsigned int v51 = 8;
  *uint64_t v14 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  uint64_t v24 = sub_1000380B0(v52, qword_100075010, 0, v14, &v51, 8u, v15, (unsigned int *)&v50);
  if (!v24)
  {
LABEL_7:
    uint64_t v29 = sub_10003E25C(a1, a2, 6, &v52, v25, v26, v27, v28);
    if (!v29)
    {
      uint64_t v49 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x6000000000000000;
      unsigned int v47 = 8;
      int v48 = 0;
      unsigned int v46 = 4;
      uint64_t v39 = sub_1000380B0(v52, 0, 0, &v49, &v47, 8u, &v48, &v46);
      if (v39 == 2) {
        goto LABEL_28;
      }
      uint64_t v13 = v39;
      if (v39) {
        goto LABEL_14;
      }
      if (v14)
      {
        uint64_t v40 = v23[1];
        BOOL v41 = v40 == a5;
        uint64_t v42 = v40 == a5 ? (long long *)v14 : 0;
      }
      else
      {
        BOOL v41 = 0;
        uint64_t v42 = 0;
      }
      uint64_t v43 = sub_1000097DC(a1, a2, a3, a5, v42, (uint64_t)v23, v50, a4);
      if (!v43)
      {
        BOOL v44 = !v14 || v41;
        if (v44 || (uint64_t v43 = sub_1000097DC(a1, a2, a3, v23[1], (long long *)v14, (uint64_t)v23, v50, a4), !v43))
        {
LABEL_28:
          v55[0] = a1;
          v55[1] = a2;
          v55[2] = a3;
          v55[3] = v14;
          v55[4] = v23;
          v55[5] = a4;
          uint64_t v53 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x4000000000000000;
          __int16 v54 = 0;
          uint64_t v43 = sub_10003E3C4(a1, a2, 0, 1, (unsigned __int8 *)&v53, 10, (uint64_t (*)(void))sub_100009CC0, (uint64_t)v55);
        }
      }
      uint64_t v13 = v43;
      goto LABEL_14;
    }
    uint64_t v13 = v29;
    sub_10004458C("unable to get fsroot tree to repair missing crypto state\n", v30, v31, v32, v33, v34, v35, v36, v45);
    uint64_t v37 = 1158;
    goto LABEL_13;
  }
  uint64_t v13 = v24;
  if (v24 == 2)
  {
    uint64_t v14 = 0;
    goto LABEL_7;
  }
LABEL_14:
  free(v14);
  free(v23);
  return v13;
}

uint64_t sub_1000097DC(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, long long *a5, uint64_t a6, int a7, uint64_t a8)
{
  if (a5) {
    BOOL v14 = (*(_WORD *)(a6 + 80) & 0xF000) == 0x8000;
  }
  else {
    BOOL v14 = 0;
  }
  unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v51 = v15;
  long long v52 = v15;
  unsigned __int16 v50 = -21846;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  if (v14)
  {
    uint64_t v17 = a3;
    uint64_t v18 = sub_10003EE64((unsigned __int16 *)(a6 + 92), a7 - 92, 8, &v54, &v50, 0, 0);
    if (v18)
    {
LABEL_8:
      uint64_t v19 = *(void *)a5 & 0xFFFFFFFFFFFFFFFLL;
      strerror(v18);
      sub_10004458C("failed to get inode (id %llu) dstream: %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
      sub_100048B34((char *)0x43B, v18);
      return v18;
    }
    if (v50 < 0x28u)
    {
      uint64_t v18 = 34;
      goto LABEL_8;
    }
    unint64_t v27 = *(void *)(v54 + 32);
    long long v28 = *(_OWORD *)(v54 + 16);
    long long v51 = *(_OWORD *)v54;
    long long v52 = v28;
    unint64_t v53 = v27;
    unint64_t v16 = v28;
    a3 = v17;
  }
  BOOL v29 = v16 == a8 && v14;
  v46[0] = a1;
  v46[1] = a2;
  uint64_t v43 = a3;
  v46[2] = a3;
  v46[3] = a8;
  uint64_t v48 = 0;
  unint64_t v47 = 0xAAAAAAAA00000000;
  BYTE4(v47) = v29;
  uint64_t v49 = 0;
  if (v29) {
    LODWORD(v47) = *(_DWORD *)(a6 + 60);
  }
  *((void *)&v44 + 1) = a4 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000;
  uint64_t v45 = 0;
  uint64_t v18 = sub_10003E3C4(a1, a2, 0, 1, (unsigned __int8 *)&v44 + 8, 16, (uint64_t (*)(void))sub_100009A34, (uint64_t)v46);
  if (!v18)
  {
    if (!v29) {
      goto LABEL_22;
    }
    uint64_t v37 = v48;
    if (!v48) {
      uint64_t v37 = -1;
    }
    *(void *)&long long v52 = v37;
    sub_100044674("found dstream (id %llu) with missing crypto state object (id %llu)\n", v30, v31, v32, v33, v34, v35, v36, a4);
    uint64_t v18 = sub_100009BB4(v43, 14, a5, &v51, 40, v38, v39, v40);
    if (!v18)
    {
      if (!v48
        || (*(void *)&long long v44 = v48 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000,
            uint64_t v18 = sub_100008DD0(v43, 1, 23, 1, &v44, 0, v35, v36),
            !v18))
      {
LABEL_22:
        if (v49) {
          BOOL v41 = v14;
        }
        else {
          BOOL v41 = 0;
        }
        if (!v41) {
          return 0;
        }
        uint64_t v18 = sub_100009BB4(v43, 16, a5, &v49, 8, v34, v35, v36);
        if (!v18) {
          return 0;
        }
      }
    }
  }
  return v18;
}

uint64_t sub_100009A34(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a3 + 16);
  if (v10 == *(void *)(a5 + 24))
  {
    uint64_t v12 = *(void *)(a3 + 8);
    if (v12) {
      uint64_t v12 = *(void *)a3 & 0xFFFFFFFFFFFFFFLL;
    }
    uint64_t v13 = *(void *)(a5 + 48);
    BOOL v14 = __CFADD__(v13, v12);
    uint64_t v15 = v13 + v12;
    *(void *)(a5 + 48) = v15;
    if (v14)
    {
      sub_100044674("sparse bytes overflow (current %llu, update %llu)\n", a2, v10, a4, a5, a6, a7, a8, v15);
      sub_100048B34((char *)0x43A, 92);
      uint64_t v10 = *(void *)(a5 + 24);
    }
    sub_10004458C("found fext (id %llu) with missing crypto state object (id %llu)\n", a2, v10, a4, a5, a6, a7, a8, *a1);
    uint64_t v23 = *(_DWORD **)(a5 + 16);
    if (v23)
    {
      uint64_t v25 = *(void *)a5;
      uint64_t v24 = *(void *)(a5 + 8);
      uint64_t result = sub_100027E70(v23, 8u, 1, 0xBu, 1, (long long *)a1, 0x10u, (unsigned char *)a3, 0x18u);
      if (!result)
      {
        unint64_t v27 = *(void *)(a3 + 8);
        unint64_t v28 = (*(void *)a3 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(v25 + 8) + 36);
        return sub_100021270(v24, v27, v28);
      }
    }
    else
    {
      return sub_100027AD0(0, v16, v17, v18, v19, v20, v21, v22);
    }
  }
  else if (*(unsigned char *)(a5 + 36) && (v10 ? (BOOL v29 = *(void *)(a5 + 40) == 0) : (BOOL v29 = 0), v29))
  {
    char v30 = 0;
    uint64_t result = sub_100009C08(*(void *)a5, *(void **)(a5 + 8), v10, *(_DWORD *)(a5 + 32), &v30, a6, a7, a8);
    if (!result && v30) {
      *(void *)(a5 + 40) = *(void *)(a3 + 16);
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t sub_100009BB4(_DWORD *a1, uint64_t a2, long long *a3, unsigned char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, 1, a2, 1, a3, 8u, a4, a5);
  }
  return sub_100027AD0(0, a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8);
}

uint64_t sub_100009C08(uint64_t a1, void *a2, uint64_t a3, int a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E25C(a1, a2, 7, &v18, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    uint64_t v16 = 0;
    uint64_t v17 = a3 & 0xFFFFFFFFFFFFFFFLL | 0x7000000000000000;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unsigned int v12 = 24;
    unsigned int v13 = 8;
    LODWORD(result) = sub_1000380B0(v18, qword_100075010, 0, &v17, &v13, 8u, &v14, &v12);
    if (!result && (BYTE4(v15) & 0x1F) == a4) {
      *a5 = 1;
    }
    if (result == 2) {
      return 0;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t sub_100009CC0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)a3 & 1) == 0 || *(void *)(a3 + 28) != *(void *)(a5 + 40)) {
    return 0;
  }
  uint64_t v10 = *(void *)(a3 + 4);
  uint64_t v11 = (const char *)(a1 + 10);
  sub_100044674("found xattr (id %llu, name %.*s) with missing crypto state\n", a2, a3, a4, a5, a6, a7, a8, *(unsigned char *)a1);
  uint64_t v12 = *(void *)a5;
  unsigned int v13 = *(void **)(a5 + 8);
  v33[0] = *(void *)a5;
  v33[1] = v13;
  void v33[2] = *(void *)(a5 + 40);
  unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = *(void *)(a5 + 24);
  LOBYTE(v34) = v14 != 0;
  HIDWORD(v34) = 0;
  uint64_t v35 = 0;
  unint64_t v36 = 0xAAAAAAAAAAAAAA00;
  if (v14) {
    HIDWORD(v34) = *(_DWORD *)(*(void *)(a5 + 32) + 60);
  }
  v32[0] = v10 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000;
  v32[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E3C4(v12, v13, 0, 1, (unsigned __int8 *)v32, 16, (uint64_t (*)(void))sub_100009F0C, (uint64_t)v33);
  if (!result)
  {
    uint64_t v18 = v35;
    uint64_t v37 = v35;
    if (*(_WORD *)(a1 + 8) == 23)
    {
      int v19 = strncmp(v11, "com.apple.ResourceFork", 0x17uLL);
      BOOL v20 = v19 == 0;
      if (v18) {
        goto LABEL_13;
      }
      if (!v19)
      {
        BOOL v20 = 1;
        LOBYTE(v36) = 1;
        goto LABEL_14;
      }
    }
    else if (v35)
    {
      BOOL v20 = 0;
      goto LABEL_13;
    }
    BOOL v20 = 0;
    uint64_t v37 = -1;
LABEL_13:
    if (!(_BYTE)v36) {
      return sub_100009FA0(*(_DWORD **)(a5 + 16), 1, 25, a1, &v37, 8, v16, v17);
    }
LABEL_14:
    uint64_t result = sub_100009FA0(*(_DWORD **)(a5 + 16), 0, 0, a1, 0, 0, v16, v17);
    if (result) {
      return result;
    }
    uint64_t v24 = *(long long **)(a5 + 24);
    if (v24)
    {
      if (v20)
      {
        uint64_t v30 = 0x8000;
        uint64_t result = sub_100009BB4(*(_DWORD **)(a5 + 16), 17, v24, &v30, 8, v21, v22, v23);
        if (result) {
          return result;
        }
        uint64_t v31 = 0x4000;
        uint64_t v24 = *(long long **)(a5 + 24);
LABEL_27:
        uint64_t result = sub_100009BB4(*(_DWORD **)(a5 + 16), 18, v24, &v31, 8, v25, v26, v27);
        if (result) {
          return result;
        }
        return 0;
      }
      int v28 = *(unsigned __int16 *)(a1 + 8);
      if (v28 == 21)
      {
        if (!strncmp(v11, "com.apple.FinderInfo", 0x15uLL))
        {
          uint64_t v29 = 256;
          goto LABEL_26;
        }
      }
      else if (v28 == 26 && !strncmp(v11, "com.apple.system.Security", 0x1AuLL))
      {
        uint64_t v29 = 64;
LABEL_26:
        uint64_t v31 = v29;
        goto LABEL_27;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100009F0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a3 + 16);
  if (v10 == *(void *)(a5 + 16))
  {
    *(unsigned char *)(a5 + 40) = 1;
    return 0xFFFFFFFFLL;
  }
  else if (*(unsigned char *)(a5 + 24) && (v10 ? (BOOL v12 = *(void *)(a5 + 32) == 0) : (BOOL v12 = 0), v12))
  {
    char v13 = 0;
    uint64_t result = sub_100009C08(*(void *)a5, *(void **)(a5 + 8), v10, *(_DWORD *)(a5 + 28), &v13, a6, a7, a8);
    if (!result)
    {
      if (v13) {
        *(void *)(a5 + 32) = *(void *)(a3 + 16);
      }
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t sub_100009FA0(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, a2, a3, 1, (long long *)a4, *(unsigned __int16 *)(a4 + 8) + 10, a5, a6);
  }
  return sub_100027AD0(0, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
}

BOOL sub_100009FFC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> ((v3 & 0xC0u) - a2);
  if (a3 >= 64)
  {
    while (((-1 << v5) & ~((-1 << v5) & *(void *)(a1 + 8 * v4))) == 0
         && (!v5 || (v6 & ~*(void *)(a1 + 8 * v4 + 8)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1;
      }
    }
    return 0;
  }
  uint64_t v7 = a3;
  if (!a3) {
    return 1;
  }
LABEL_13:
  unint64_t v9 = ~(-1 << v7);
  unint64_t v10 = v9 << v5;
  unint64_t v11 = v9 >> (64 - v5);
  if (!v5) {
    unint64_t v11 = 0;
  }
  return (v10 & ~((-1 << v5) & *(void *)(a1 + 8 * v4))) == 0
      && (v7 <= (uint64_t)(64 - v5) || !v11 || (v11 & ~(v6 & *(void *)(a1 + 8 * v4 + 8))) == 0);
}

uint64_t sub_10000A0DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v6 = 64 - v5;
  if (a3 >= 64)
  {
    while (((-1 << v5) & *(void *)(a1 + 8 * v4)) == 0
         && (!v5 || (*(void *)(a1 + 8 * v4 + 8) & (0xFFFFFFFFFFFFFFFFLL >> v6)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1;
      }
    }
    return 0;
  }
  uint64_t v7 = a3;
  if (a3)
  {
LABEL_13:
    unint64_t v9 = ~(-1 << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0;
    }
    if ((v10 & (-1 << v5) & *(void *)(a1 + 8 * v4)) != 0
      || v7 > v6 && v11 && ((0xFFFFFFFFFFFFFFFFLL >> v6) & v11 & *(void *)(a1 + 8 * v4 + 8)) != 0)
    {
      return 0;
    }
  }
  return 1;
}

uint64_t sub_10000A1C0(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }
  do
  {
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~(-1 << v5) | (-1 << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) |= 0xFFFFFFFFFFFFFFFFLL >> v6;
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64;
  }
  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1 << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0;
    }
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~v10 | v10 & (-1 << v5);
    if (v7 > v6)
    {
      if (v11) {
        *(void *)(result + 8 * v4 + 8) = *(void *)(result + 8 * v4 + 8) & ~v11 | v11 & (0xFFFFFFFFFFFFFFFFLL >> v6);
      }
    }
  }
  return result;
}

uint64_t sub_10000A2A8(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }
  do
  {
    *(void *)(result + 8 * v4) &= ~(-1 << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) &= ~(0xFFFFFFFFFFFFFFFFLL >> v6);
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64;
  }
  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1 << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (v5) {
      unint64_t v12 = v11;
    }
    else {
      unint64_t v12 = 0;
    }
    *(void *)(result + 8 * v4) &= ~v10;
    if (v7 > v6)
    {
      if (v12) {
        *(void *)(result + 8 * v4 + 8) &= ~v12;
      }
    }
  }
  return result;
}

uint64_t sub_10000A370(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a4 < 1) {
    return 0;
  }
  if (a1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = -1;
  }
  uint64_t v6 = (unint64_t *)(a2 + 8 * (a3 / 64));
  while (1)
  {
    uint64_t v7 = a3 & 0x3F;
    if (a3 <= 0) {
      uint64_t v7 = -(-a3 & 0x3F);
    }
    unint64_t v8 = 64 - v7;
    unint64_t v10 = *v6++;
    unint64_t v9 = v10;
    if (64 - v7 >= (unint64_t)a4) {
      unint64_t v8 = a4;
    }
    unint64_t v11 = __clz(__rbit64((v9 >> v7) ^ v5));
    if (v8 > v11) {
      break;
    }
    a3 += v8;
    BOOL v12 = a4 <= (uint64_t)v8;
    a4 -= v8;
    if (v12) {
      return 0;
    }
  }
  *a5 = v11 + a3;
  return 1;
}

unint64_t sub_10000A3F4(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= a4) {
    return 0;
  }
  unint64_t result = 0;
  if (a2) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = -1;
  }
  if (a2) {
    uint64_t v7 = -1;
  }
  else {
    uint64_t v7 = 0;
  }
  do
  {
    unint64_t v8 = a4 - a3;
    if (a4 - a3 < 1) {
      break;
    }
    unint64_t v9 = (unint64_t *)(a1 + 8 * (a3 / 64));
    while (1)
    {
      uint64_t v10 = a3 & 0x3F;
      if (a3 <= 0) {
        uint64_t v10 = -(-a3 & 0x3F);
      }
      unint64_t v11 = 64 - v10;
      unint64_t v13 = *v9++;
      unint64_t v12 = v13;
      if (64 - v10 >= v8) {
        unint64_t v11 = v8;
      }
      unint64_t v14 = __clz(__rbit64((v12 >> v10) ^ v6));
      if (v11 > v14) {
        break;
      }
      a3 += v11;
      BOOL v15 = (uint64_t)v8 <= (uint64_t)v11;
      v8 -= v11;
      if (v15) {
        return result;
      }
    }
    uint64_t v16 = v14 + a3;
    uint64_t v17 = a4 - (v14 + a3);
    if (v17 < 1) {
      return result - v16 + a4;
    }
    uint64_t v18 = v16 + 63;
    if (v16 >= 0) {
      uint64_t v18 = v14 + a3;
    }
    int v19 = (unint64_t *)(a1 + 8 * (v18 >> 6));
    uint64_t v20 = v14 + a3;
    while (1)
    {
      uint64_t v21 = v20 & 0x3F;
      if (v20 <= 0) {
        uint64_t v21 = -(-v20 & 0x3F);
      }
      unint64_t v22 = 64 - v21;
      unint64_t v24 = *v19++;
      unint64_t v23 = v24;
      if (64 - v21 >= (unint64_t)v17) {
        unint64_t v22 = v17;
      }
      unint64_t v25 = __clz(__rbit64((v23 >> v21) ^ v7));
      if (v22 > v25) {
        break;
      }
      v20 += v22;
      BOOL v15 = v17 <= (uint64_t)v22;
      v17 -= v22;
      if (v15) {
        return result - v16 + a4;
      }
    }
    a3 = v25 + v20;
    unint64_t result = result - v16 + v25 + v20;
  }
  while ((uint64_t)(v25 + v20) < a4);
  return result;
}

void *sub_10000A518(void *result, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a2 + 63;
  if (a2 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = a2 + 63;
  }
  unint64_t v7 = a2 - (v6 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v8 = 64 - v7;
  uint64_t v9 = -1 << v7;
  if (a2 == (v6 & 0xFFFFFFFFFFFFFFC0)) {
    unint64_t v10 = 0;
  }
  else {
    unint64_t v10 = 0xFFFFFFFFFFFFFFFFLL >> ((v6 & 0xC0u) - a2);
  }
  if (a4 >= 0) {
    uint64_t v11 = a4;
  }
  else {
    uint64_t v11 = a4 + 63;
  }
  unint64_t v12 = a4 - (v11 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v13 = 64 - v12;
  uint64_t v14 = -1 << v12;
  unint64_t v15 = 0xFFFFFFFFFFFFFFFFLL >> ((v11 & 0xC0u) - a4);
  if (result == a3 && a2 <= a4)
  {
    uint64_t v16 = a5 + a2;
    if (v16 >= 1) {
      uint64_t v17 = v16 - 1;
    }
    else {
      uint64_t v17 = v16 + 62;
    }
    uint64_t v18 = a5 + a4;
    uint64_t v20 = a5 + a4 - 1;
    BOOL v19 = a5 + a4 < 1;
    uint64_t v21 = a5 + a4 + 62;
    if (!v19) {
      uint64_t v21 = v20;
    }
    if (a5 <= 0) {
      uint64_t v22 = -(-a5 & 0x3F);
    }
    else {
      uint64_t v22 = a5 & 0x3F;
    }
    if (v22)
    {
      BOOL v19 = v16 < v22;
      uint64_t v23 = v16 - v22;
      if (v19) {
        v23 += 63;
      }
      uint64_t v24 = v23 >> 6;
      BOOL v19 = v18 < v22;
      uint64_t v25 = v18 - v22;
      if (v19) {
        v25 += 63;
      }
      uint64_t v26 = v25 >> 6;
      unint64_t v27 = (result[v24] & (unint64_t)v9) >> v7;
      if (v7 && v22 >= v8) {
        v27 |= (result[v24 + 1] & v10) << v8;
      }
      unint64_t v28 = ~(-1 << v22);
      unint64_t v29 = v27 & v28;
      unint64_t v30 = v28 >> v13;
      if (!v12) {
        unint64_t v30 = 0;
      }
      result[v26] = (v29 << v12) & (v28 << v12) | result[v26] & ~(v28 << v12);
      if (v22 > v13 && v30) {
        result[v26 + 1] = result[v26 + 1] & ~v30 | (v29 >> v13) & v30;
      }
      a5 -= v22;
      uint64_t v31 = v24 - 1;
      uint64_t v32 = v26 - 1;
    }
    else
    {
      uint64_t v31 = v17 >> 6;
      uint64_t v32 = v21 >> 6;
    }
    if (a5 >= 64)
    {
      uint64_t v45 = v6 >> 6;
      if (v31 >= v45)
      {
        unint64_t v46 = ~v15;
        unint64_t v47 = &result[v32 + 1];
        uint64_t v48 = &result[v31 + 1];
        unint64_t result = v48;
        do
        {
          uint64_t v49 = *--result;
          unint64_t v50 = (v49 & (unint64_t)v9) >> v7;
          if (v7) {
            v50 |= *v48 << v8;
          }
          *(v47 - 1) = *(v47 - 1) & ~v14 | (v50 << v12) & v14;
          if (v12) {
            *unint64_t v47 = *v47 & v46 | (v50 >> v13);
          }
          if (a5 < 128) {
            break;
          }
          a5 -= 64;
          --v47;
          uint64_t v48 = result;
          BOOL v19 = v31-- <= v45;
        }
        while (!v19);
      }
    }
    return result;
  }
  uint64_t v33 = v11 >> 6;
  if (a2 >= 0) {
    uint64_t v5 = a2;
  }
  uint64_t v34 = v5 >> 6;
  if (a5 < 64)
  {
    uint64_t v39 = a5;
    if (!a5) {
      return result;
    }
    goto LABEL_47;
  }
  unint64_t v35 = ~v15;
  unint64_t v36 = &a3[v33 + 1];
  uint64_t v37 = &result[v34 + 1];
  do
  {
    unint64_t v38 = (*(v37 - 1) & (unint64_t)v9) >> v7;
    if (v7) {
      v38 |= *v37 << v8;
    }
    *(v36 - 1) = *(v36 - 1) & ~v14 | (v38 << v12) & v14;
    if (v12) {
      *unint64_t v36 = *v36 & v35 | (v38 >> v13);
    }
    ++v34;
    uint64_t v39 = a5 - 64;
    ++v36;
    ++v37;
    ++v33;
    BOOL v19 = a5 <= 127;
    a5 -= 64;
  }
  while (!v19);
  if (v39)
  {
LABEL_47:
    unint64_t v40 = (result[v34] & (unint64_t)v9) >> v7;
    if (v7 && v39 >= v8) {
      v40 |= (result[v34 + 1] & v10) << v8;
    }
    unint64_t v41 = ~(-1 << v39);
    unint64_t v42 = v40 & v41;
    unint64_t v43 = v41 << v12;
    unint64_t v44 = v41 >> v13;
    if (!v12) {
      unint64_t v44 = 0;
    }
    a3[v33] = (v42 << v12) & v43 | a3[v33] & ~v43;
    if (v39 > v13 && v44) {
      a3[v33 + 1] = a3[v33 + 1] & ~v44 | (v42 >> v13) & v44;
    }
  }
  return result;
}

uint64_t sub_10000A874(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (a2 << 6) - a3;
  sub_10000A518(a1, a3, a1, 0, v5);

  return sub_10000A2A8((uint64_t)a1, v5, a3);
}

uint64_t sub_10000A8D8(uint64_t result)
{
  if (dword_100074040 < 99)
  {
    uint64_t v1 = result;
    int v2 = ++dword_100074040;
    uint64_t v3 = *(void *)(result + 8);
    uint64_t v4 = *(void *)(v3 + 48);
    if (!v4) {
      uint64_t v4 = *(void *)(v3 + 40);
    }
    if ((*(unsigned char *)(v4 + 56) & 0x20) == 0)
    {
      if (sub_100038040((uint64_t)&xmmword_100075078 + 152 * v2, 0, v3, 0x8000000, 2, 0, 0, 4096, 0, 0, 0, 0, (uint64_t)sub_10000AA68)|| sub_10003A18C((uint64_t)&xmmword_100075078 + 152 * v2, 0, 0x42u))
      {
        return sub_10003A268((uint64_t)&xmmword_100075078 + 152 * v2, 0);
      }
      else
      {
        uint64_t v5 = *(void *)(v1 + 8);
        if (v5) {
          uint64_t v5 = *(void *)(*(void *)(v5 + 40) + 8);
        }
        uint64_t v6 = (char *)&xmmword_100075078 + 152 * v2;
        *((void *)v6 + 16) = v5;
        v6[144] = 0;
        unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t result = sub_10003A0F8(v1, 0, &v10);
        if (result)
        {
          *((void *)&xmmword_100075078 + 19 * v2 + 17) = 50;
        }
        else
        {
          unint64_t v7 = v10;
          uint64_t v8 = (char *)&xmmword_100075078 + 152 * v2;
          *((void *)v8 + 17) = v10 / 0x64;
          uint64_t v9 = (unint64_t *)(v8 + 136);
          if (v7 <= 0x3E7)
          {
            if (v7 >= 0xA) {
              unint64_t v7 = 10;
            }
            *uint64_t v9 = v7;
          }
        }
      }
    }
  }
  else
  {
    dword_100074040 = 100;
  }
  return result;
}

uint64_t sub_10000AA68(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 >= 0x1C && a5 >= 0x1C)
  {
    uint64_t result = sub_10003DD34(a1, (unint64_t *)(a2 + 20), *(_DWORD *)(a2 + 16), (unint64_t *)(a4 + 20), *(_DWORD *)(a4 + 16), a6);
    if (!result)
    {
      if (*a6) {
        return 0;
      }
      if (*(void *)a2 > *(void *)a4) {
        goto LABEL_9;
      }
      if (*(void *)a2 >= *(void *)a4)
      {
        unint64_t v11 = *(void *)(a2 + 8);
        unint64_t v12 = *(void *)(a4 + 8);
        if (v11 > v12)
        {
LABEL_9:
          int v13 = 1;
LABEL_12:
          uint64_t result = 0;
          *a6 = v13;
          return result;
        }
        if (v11 >= v12) {
          return 0;
        }
      }
      int v13 = -1;
      goto LABEL_12;
    }
  }
  return result;
}

uint64_t sub_10000AB20(uint64_t a1, int *a2, int *a3, unsigned char *a4, uint64_t a5)
{
  int v27 = -1431655766;
  int v28 = -1431655766;
  unint64_t v10 = (unint64_t *)*((void *)a2 + 2);
  unint64_t v11 = (unint64_t *)*((void *)a3 + 1);
  if (!((unint64_t)v10 | (unint64_t)v11))
  {
    int v28 = 0;
    goto LABEL_10;
  }
  if (!v10)
  {
    int v13 = 1;
LABEL_9:
    int v28 = v13;
    goto LABEL_10;
  }
  if (!v11)
  {
    int v13 = -1;
    goto LABEL_9;
  }
  uint64_t result = sub_10003DD34(a1, v10, a2[1], v11, *a3, &v28);
  if (result) {
    return result;
  }
LABEL_10:
  uint64_t v14 = (unint64_t *)*((void *)a3 + 2);
  unint64_t v15 = (unint64_t *)*((void *)a2 + 1);
  int v16 = v14 | v15;
  if ((unint64_t)v14 | (unint64_t)v15)
  {
    if (v14)
    {
      if (v15)
      {
        uint64_t result = sub_10003DD34(a1, v14, a3[1], v15, *a2, &v27);
        if (result) {
          return result;
        }
        int v16 = v27 > 0;
      }
      else
      {
        int v16 = 0;
        int v27 = -1;
      }
    }
    else
    {
      int v16 = 1;
      int v27 = 1;
    }
  }
  else
  {
    int v27 = 0;
  }
  uint64_t result = 0;
  if (v28 <= 0) {
    int v16 = 0;
  }
  *a4 = v16;
  if (a5 && v16)
  {
    uint64_t v17 = (unint64_t *)*((void *)a2 + 1);
    uint64_t v18 = (unint64_t *)*((void *)a3 + 1);
    if (!((unint64_t)v17 | (unint64_t)v18))
    {
      int v28 = 0;
      goto LABEL_31;
    }
    if (v17)
    {
      if (v18)
      {
        uint64_t result = sub_10003DD34(a1, v17, *a2, v18, *a3, &v28);
        if (result) {
          return result;
        }
LABEL_31:
        uint64_t v20 = (unint64_t *)*((void *)a2 + 2);
        uint64_t v21 = (unint64_t *)*((void *)a3 + 2);
        if ((unint64_t)v20 | (unint64_t)v21)
        {
          if (v20)
          {
            if (v21)
            {
              uint64_t result = sub_10003DD34(a1, v20, a2[1], v21, a3[1], &v27);
              if (result) {
                return result;
              }
              goto LABEL_40;
            }
            int v22 = -1;
          }
          else
          {
            int v22 = 1;
          }
          int v27 = v22;
        }
        else
        {
          int v27 = 0;
        }
LABEL_40:
        uint64_t result = 0;
        if (v28 < 0) {
          uint64_t v23 = a3;
        }
        else {
          uint64_t v23 = a2;
        }
        *(void *)(a5 + 8) = *((void *)v23 + 1);
        int v24 = *v23;
        if (v27 >= 1) {
          uint64_t v25 = a3;
        }
        else {
          uint64_t v25 = a2;
        }
        *(void *)(a5 + 16) = *((void *)v25 + 2);
        int v26 = v25[1];
        *(_DWORD *)a5 = v24;
        *(_DWORD *)(a5 + 4) = v26;
        return result;
      }
      int v19 = -1;
    }
    else
    {
      int v19 = 1;
    }
    int v28 = v19;
    goto LABEL_31;
  }
  return result;
}

uint64_t sub_10000AD08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, unsigned int a7, const void *a8, unsigned int a9, unsigned int a10)
{
  uint64_t v10 = a10;
  if (dword_100074040 != 100)
  {
    if (*((void *)&xmmword_100075078 + 19 * dword_100074040 + 7))
    {
      uint64_t v12 = *(void *)(a1 + 8);
      if (v12)
      {
        if (!*(void *)(v12 + 56) && a6 && *(_DWORD *)(a1 + 48) == 14 && (a10 == 92 || a10 == 2))
        {
          unint64_t v15 = (char *)&xmmword_100075078 + 152 * dword_100074040;
          if (*((void *)v15 + 17) <= (unint64_t)v15[144])
          {
            sub_100044674("reached invalid tree node limit %llu for fs_oid %llu\n", a2, a3, a4, a5, (uint64_t)a6, (uint64_t)a6, (uint64_t)a8, *((void *)v15 + 17));
            sub_10003A268((uint64_t)v15, 0);
          }
          else
          {
            uint64_t v10 = sub_10000AE84(v15, a3, a4, a5, 0x7FFFFFFFFFFFFFFFLL, 0, a6, a7, 0, a8, a9, 0);
            if (!v10)
            {
              *(unsigned char *)(a2 + 74) = 1;
              if ((byte_100078BDC & 1) == 0) {
                sub_100044674("aborting jobj validations for current fsck pass - trying to repair fsroot tree with invalid nodes\n", v16, v17, v18, v19, v20, v21, v22, v23);
              }
              byte_100078BDC = 1;
              sub_1000158D0(*(void *)(a1 + 8));
              sub_100007230();
              uint64_t v10 = 0;
              *(unsigned char *)(*(void *)(a1 + 8) + 9) = 0;
              ++v15[144];
              ++dword_100078BD8;
            }
          }
        }
      }
    }
  }
  return v10;
}

uint64_t sub_10000AE84(_DWORD *a1, uint64_t a2, uint64_t a3, __int16 a4, uint64_t a5, uint64_t a6, const void *a7, unsigned int a8, int a9, const void *a10, unsigned int a11, int a12)
{
  size_t v17 = a8 + 20;
  uint64_t v18 = malloc_type_malloc(v17, 0xCD2F895AuLL);
  uint64_t v19 = (char *)malloc_type_malloc(a11 + 30, 0x39920612uLL);
  uint64_t v20 = v19;
  if (v18) {
    BOOL v21 = v19 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    *uint64_t v18 = a2;
    v18[1] = a3;
    *((_DWORD *)v18 + 4) = a8;
    memcpy((char *)v18 + 20, a7, a8);
    *((_WORD *)v20 + 4) = a4;
    *(void *)(v20 + 10) = a5;
    *(void *)uint64_t v20 = a6;
    *(_DWORD *)(v20 + 18) = a9;
    *(_DWORD *)(v20 + 22) = a12;
    *(_DWORD *)(v20 + 26) = a11;
    if (a10) {
      memcpy(v20 + 30, a10, a11);
    }
    uint64_t v24 = sub_100039A6C(a1, 0, v18, v17, v20, a11 + 30);
    uint64_t v22 = v24;
    if (v24)
    {
      uint64_t v25 = *(void *)((char *)v18 + 20) & 0xFFFFFFFFFFFFFFFLL;
      strerror(v24);
      sub_10004458C("unable to insert tree node at key id %llu for repairs : %s\n", v26, v27, v28, v29, v30, v31, v32, v25);
      sub_100048B34((char *)0x3F1, v22);
    }
LABEL_14:
    free(v18);
    if (!v20) {
      return v22;
    }
    goto LABEL_8;
  }
  uint64_t v22 = 12;
  sub_100048B34((char *)0x3F0, 12);
  if (v18) {
    goto LABEL_14;
  }
  if (v20) {
LABEL_8:
  }
    free(v20);
  return v22;
}

uint64_t sub_10000B01C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  int v3 = dword_100074040;
  if (dword_100074040 == 100) {
    return 0;
  }
  if (!*((void *)&xmmword_100075078 + 19 * dword_100074040 + 7)) {
    return 0;
  }
  v33[0] = 0;
  sub_10003A064((uint64_t)&xmmword_100075078 + 152 * dword_100074040, 0, v33);
  if (!v33[0]) {
    return 0;
  }
  uint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  memset(v33, 0, 80);
  uint64_t v7 = sub_10002D3D4((uint64_t)a1, a2, &v34);
  if (!v7)
  {
    uint64_t v7 = sub_100033E58(v34, *(void *)(v34 + 56), 0, (uint64_t)v33);
    if (!v7)
    {
      memset(v32, 0, sizeof(v32));
      uint64_t v7 = sub_100038D78((uint64_t)v32, (uint64_t)&xmmword_100075078 + 152 * v3, 0, 0, 0);
      if (v7
        || (uint64_t v7 = sub_10002C46C((uint64_t)v32, (uint64_t (*)(void, void, void, void, uint64_t))sub_10000B2E8, a3, 0), v7))
      {
        char v8 = strerror(v7);
        sub_10004458C("unable to enqueue tree node prune repairs: %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
        uint64_t v16 = 1011;
LABEL_9:
        sub_100048B34((char *)v16, v7);
        return v7;
      }
      if (!*(unsigned char *)(qword_100091B78 + 47))
      {
        sub_10000B37C();
        return 0;
      }
      uint64_t v17 = sub_10000B400((uint64_t)&xmmword_100075078 + 152 * v3 + 64, a2);
      if (v17)
      {
        uint64_t v7 = v17;
        uint64_t v16 = 1053;
        goto LABEL_9;
      }
      v29[1] = v34;
      v29[2] = (uint64_t)v33;
      uint64_t v30 = (char *)&xmmword_100075078 + 152 * v3;
      uint64_t v31 = v30 + 64;
      uint64_t v7 = sub_10001F894(a1, a2, 1, 0, (uint64_t (*)(void))sub_10000B490);
      if (v7) {
        return v7;
      }
      if (!*(void *)(*(void *)(a2 + 40) + 216)) {
        return 0;
      }
      if (*(unsigned char *)(qword_100091B78 + 42)) {
        return 0;
      }
      v29[0] = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v19 = sub_100045DD0(a1, a2, v29);
      if (v19 == 2) {
        return 0;
      }
      uint64_t v7 = v19;
      if (!v19)
      {
        uint64_t v7 = sub_100033E58(v34, *(void *)(v34 + 56), v29[0], (uint64_t)v33);
        if (!v7)
        {
          v28[0] = v34;
          v28[1] = v33;
          v28[2] = v29[0];
          v28[3] = (char *)&xmmword_100075078 + 152 * v3 + 64;
          uint64_t v7 = sub_100038D78((uint64_t)v32, (uint64_t)&xmmword_100075078 + 152 * v3, 0, 0, 0);
          if (v7
            || (uint64_t v7 = sub_10002C46C((uint64_t)v32, (uint64_t (*)(void, void, void, void, uint64_t))sub_10000B540, (uint64_t)v28, 0), v7))
          {
            char v20 = strerror(v7);
            sub_10004458C("unable to iterate snap fsroot tree for tree node repairs: %s\n", v21, v22, v23, v24, v25, v26, v27, v20);
            uint64_t v16 = 1054;
            goto LABEL_9;
          }
          return 0;
        }
      }
    }
  }
  return v7;
}

uint64_t sub_10000B2E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  __int16 v17 = *(_WORD *)(a3 + 8);
  uint64_t v5 = (void *)(a1 + 20);
  uint64_t v6 = sub_100027E70(a5, 7u, 0, 0, 1, (long long *)(a1 + 20), *(_DWORD *)(a1 + 16), &v17, 2u);
  uint64_t v7 = v6;
  if (v6)
  {
    uint64_t v8 = *v5 & 0xFFFFFFFFFFFFFFFLL;
    strerror(v6);
    sub_10004458C("unable to add tree repair at key at id %llu : %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
    sub_100048B34((char *)0x3F2, v7);
  }
  return v7;
}

void sub_10000B37C()
{
  int v0 = dword_100074040;
  if (dword_100074040 != 100)
  {
    uint64_t v1 = (char *)&xmmword_100075078 + 152 * dword_100074040;
    dword_100078BD8 -= v1[144];
    v1[144] = 0;
    sub_10003A268((uint64_t)&xmmword_100075078 + 152 * v0, 0);
    sub_10003A268((uint64_t)(v1 + 64), 0);
  }
}

uint64_t sub_10000B400(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100038040(a1, 0, a2, 0x8000000, 2, 0, 0, 4096, 0, 0, 0, 0, (uint64_t)sub_10000AA68);
  if (!result)
  {
    return sub_10003A18C(a1, 0, 0x42u);
  }
  return result;
}

uint64_t sub_10000B490(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)a3) {
    return 0;
  }
  uint64_t v7 = *(void *)a5;
  uint64_t v8 = *(void *)(a5 + 8);
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  if (!sub_1000257B4(*(uint64_t **)v7, *(void *)(v7 + 8), 0, *a1, a1[1], 0, 3, 0xEu, (uint64_t **)&v13, 0, 0))
  {
    uint64_t v11 = sub_10000C0B0(v7, v8, *(void *)(a5 + 16), *(_DWORD **)(a5 + 24), (uint64_t)v13, *(void *)(a3 + 8), v9, v10);
    free(v13);
  }
  return v11;
}

uint64_t sub_10000B540(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v7 = *(_DWORD *)(a3 + 26);
  uint64_t v8 = (unint64_t *)(a3 + 30);
  uint64_t v9 = *a5;
  uint64_t v36 = a5[1];
  if (v7) {
    uint64_t v10 = a3 + 30;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = a5[2];
  uint64_t v12 = (_DWORD *)a5[3];
  long long v52 = 0;
  memset(v51, 170, sizeof(v51));
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v46 = 0u;
  uint64_t v13 = a1 + 20;
  uint64_t v14 = sub_1000389E0((uint64_t)&v46, v9, v11, 4294967294, (const void *)(a1 + 20), *(_DWORD *)(a1 + 16), 1u);
  if (v14)
  {
    uint64_t v15 = v14;
    strerror(v14);
    sub_10004458C("unable to iterate fsroot tree (xid %llu) for tree node repairs: %s\n", v16, v17, v18, v19, v20, v21, v22, v11);
    uint64_t v23 = 1050;
LABEL_6:
    sub_100048B34((char *)v23, v15);
    goto LABEL_9;
  }
  if (!BYTE8(v48))
  {
    while (1)
    {
      uint64_t v25 = **((void **)&v47 + 1);
      if (v52)
      {
        free(v52);
        long long v52 = 0;
      }
      uint64_t v26 = sub_1000257B4(*(uint64_t **)v9, *(void *)(v9 + 8), 0, v25, v11, 0, 3, 0xEu, &v52, (uint64_t)v51, 0);
      if (v26) {
        goto LABEL_24;
      }
      memset(v45, 170, sizeof(v45));
      unsigned __int16 v44 = -21846;
      sub_1000340F4((uint64_t)v52, v36, 0, (uint64_t *)&v45[5], v45, *((_DWORD *)v52 + 9) - 1, (uint64_t *)&v45[1], &v44);
      int v43 = 0;
      if (v7)
      {
        uint64_t v15 = sub_10003DD34(*(void *)(*(void *)(v9 + 8) + 40), *(unint64_t **)&v45[5], v45[0], v8, *(_DWORD *)(a3 + 26), &v43);
        if (v15 || (v43 & 0x80000000) == 0) {
          goto LABEL_9;
        }
      }
      int v27 = *(_DWORD *)(a3 + 26);
      v40[0] = *(_DWORD *)(a1 + 16);
      v40[1] = v27;
      uint64_t v41 = v13;
      uint64_t v42 = v10;
      v37[0] = v45[0];
      v37[1] = v44;
      uint64_t v38 = *(void *)&v45[5];
      uint64_t v39 = *(void *)&v45[1];
      uint64_t v26 = sub_10000C328(v12, *(void *)(*(void *)(v9 + 8) + 40), v36, (uint64_t)v52, v51[0], v11, v40, v37);
      if (v26)
      {
LABEL_24:
        uint64_t v15 = v26;
        goto LABEL_9;
      }
      uint64_t v28 = (*((uint64_t (**)(long long *))&v46 + 1))(&v46);
      if (v28) {
        break;
      }
      if (BYTE8(v48)) {
        goto LABEL_8;
      }
    }
    uint64_t v15 = v28;
    strerror(v28);
    sub_10004458C("error iterating fsroot tree (xid %llu) for tree node repairs: %s\n", v29, v30, v31, v32, v33, v34, v35, v11);
    uint64_t v23 = 1051;
    goto LABEL_6;
  }
LABEL_8:
  uint64_t v15 = 0;
LABEL_9:
  if ((void)v46) {
    ((void (*)(long long *))v46)(&v46);
  }
  if (v52) {
    free(v52);
  }
  return v15;
}

uint64_t sub_10000B7C0(uint64_t *a1)
{
  if (!dword_100078BD8) {
    return 0;
  }
  if (!*(unsigned char *)(qword_100091B78 + 47)) {
    return 92;
  }
  memset(v48, 0, sizeof(v48));
  int v2 = malloc_type_malloc(0x354uLL, 0x303410BFuLL);
  long long v49 = v2;
  int v3 = malloc_type_malloc(0x35EuLL, 0x189F5314uLL);
  long long v50 = v3;
  uint64_t v4 = malloc_type_malloc(0x354uLL, 0xF84C0707uLL);
  uint64_t v5 = malloc_type_malloc(0x35EuLL, 0xA6FC526FuLL);
  uint64_t v6 = v5;
  if (!v4 || !v5 || !v2 || !v3)
  {
    uint64_t v7 = 12;
    sub_100048B34((char *)0x41F, 12);
LABEL_32:
    if (v4) {
      goto LABEL_33;
    }
    goto LABEL_34;
  }
  uint64_t v7 = sub_1000421C8(a1, 0, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10000BBF8, (char **)a1, 0);
  if (v7) {
    goto LABEL_33;
  }
  if (*(unsigned char *)(a1[1] + 65))
  {
    uint64_t v7 = sub_1000421C8(a1, 1, 0, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10000BBF8, (char **)a1, 0);
    if (v7) {
      goto LABEL_33;
    }
  }
  uint64_t v7 = sub_100003FB4((unint64_t)a1, sub_10000BC30, (uint64_t)a1);
  if (v7) {
    goto LABEL_33;
  }
  if (*(unsigned char *)(qword_100091B78 + 48))
  {
    uint64_t v7 = sub_100043130((uint64_t)a1, (uint64_t (*)(unint64_t, unint64_t, uint64_t))sub_10000BC54, (uint64_t)a1);
    if (v7) {
      goto LABEL_33;
    }
  }
  int v8 = dword_100074040;
  if (dword_100074040 >= 99) {
    int v8 = 99;
  }
  if (v8 < 0)
  {
    uint64_t v7 = 0;
    goto LABEL_33;
  }
  uint64_t v9 = (v8 + 1);
  uint64_t v10 = &xmmword_100075078;
  while (1)
  {
    long long v11 = v10[7];
    v45[2] = v10[6];
    v45[3] = v11;
    long long v46 = v10[8];
    uint64_t v47 = *((void *)v10 + 18);
    long long v12 = v10[3];
    uint64_t v43[2] = v10[2];
    long long v44 = v12;
    long long v13 = v10[5];
    v45[0] = v10[4];
    v45[1] = v13;
    long long v14 = v10[1];
    v43[0] = *v10;
    v43[1] = v14;
    if (!(_BYTE)v47) {
      goto LABEL_27;
    }
    if (!*((void *)&v44 + 1)) {
      goto LABEL_27;
    }
    uint64_t v15 = sub_10001F348((uint64_t)a1, v46);
    if (!v15) {
      goto LABEL_27;
    }
    uint64_t v42 = 0xAAAAAAAAAAAAAAAALL;
    memset(v41, 0, sizeof(v41));
    uint64_t v16 = sub_10002D3D4((uint64_t)a1, (uint64_t)v15, &v42);
    if (v16 || (uint64_t v16 = sub_100033E58(v42, *(void *)(v42 + 56), 0, (uint64_t)v41), v16))
    {
      uint64_t v7 = v16;
      goto LABEL_33;
    }
    uint64_t v40 = 0;
    memset(v39, 0, sizeof(v39));
    *(void *)&v48[0] = v42;
    *((void *)&v48[0] + 1) = v45;
    bzero(v49, 0x354uLL);
    bzero(v50, 0x35EuLL);
    bzero(v4, 0x354uLL);
    bzero(v6, 0x35EuLL);
    v4[4] = 8;
    uint64_t v17 = sub_10003889C((uint64_t)v39, (uint64_t)v45, 0, v4, 0x354u, 0x354u, v6, 862);
    if (v17
      || (uint64_t v17 = sub_10002C46C((uint64_t)v39, (uint64_t (*)(void, void, void, void, uint64_t))sub_10000BD94, (uint64_t)v48, 0), v17))
    {
      uint64_t v7 = v17;
      char v20 = strerror(v17);
      sub_10004458C("unable to fix overlaps in candidate tree: %s\n", v21, v22, v23, v24, v25, v26, v27, v20);
      uint64_t v28 = 1056;
      goto LABEL_46;
    }
    v38[0] = v42;
    v38[1] = v41;
    memset(v37, 0, sizeof(v37));
    uint64_t v18 = sub_100038D78((uint64_t)v37, (uint64_t)v45, 0, 0, 0);
    if (v18) {
      break;
    }
    uint64_t v18 = sub_10002C46C((uint64_t)v37, sub_10000BEE4, (uint64_t)v38, 0);
    if (v18) {
      break;
    }
    sub_10003A268((uint64_t)v43, 0);
    sub_10003A268((uint64_t)v45, 0);
LABEL_27:
    uint64_t v7 = 0;
    uint64_t v10 = (long long *)((char *)v10 + 152);
    if (!--v9) {
      goto LABEL_32;
    }
  }
  uint64_t v7 = v18;
  char v29 = strerror(v18);
  sub_10004458C("unable to enqueue tree node insertion repairs: %s\n", v30, v31, v32, v33, v34, v35, v36, v29);
  uint64_t v28 = 1057;
LABEL_46:
  sub_100048B34((char *)v28, v7);
LABEL_33:
  free(v4);
LABEL_34:
  if (v6) {
    free(v6);
  }
  if (v49) {
    free(v49);
  }
  if (v50) {
    free(v50);
  }
  dword_100078BD8 = 0;
  dword_100074040 = -1;
  return v7;
}

uint64_t sub_10000BBF8(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  if (a3 && a4 != 1) {
    sub_10000C51C(a2, a3, a5);
  }
  return 0;
}

uint64_t sub_10000BC30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100042FC4(a3, a1, a2, (uint64_t (*)(unint64_t, unint64_t, uint64_t))sub_10000C51C, a3);
}

uint64_t sub_10000BC54(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v6 = *(unsigned int *)(a3[1] + 36);
  v13[1] = 0;
  uint64_t v14 = 8;
  uint64_t v7 = malloc_type_calloc(8uLL, 0x10uLL, 0x1000040451B5BE8uLL);
  v13[0] = v7;
  if (!v7) {
    return 12;
  }
  HIDWORD(v13[1]) = 1;
  uint64_t v8 = ((unint64_t)(a1 << __clz(__rbit64(v6))) >> 62) & 1;
  *uint64_t v7 = a1;
  v7[1] = a2;
  uint64_t v9 = sub_100004010((uint64_t)a3, v8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_10000C7B0, (uint64_t)v13);
  if (!v9)
  {
    uint64_t v9 = sub_100003EFC((unint64_t)a3, v8, (uint64_t (*)(uint64_t, uint64_t, uint64_t))sub_10000C7B0, (uint64_t)v13);
    if (!v9)
    {
      if (SHIDWORD(v13[1]) >= 1)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        do
        {
          sub_10000C51C(*(void *)((char *)v13[0] + v10), *(void *)((char *)v13[0] + v10 + 8), a3);
          ++v11;
          v10 += 16;
        }
        while (v11 < SHIDWORD(v13[1]));
      }
      uint64_t v9 = 0;
    }
  }
  if (v13[0]) {
    free(v13[0]);
  }
  return v9;
}

uint64_t sub_10000BD94(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t *a5)
{
  uint64_t v10 = *a5;
  uint64_t v11 = a5[1];
  uint64_t v13 = a5[4];
  uint64_t v12 = a5[5];
  char v25 = 0;
  if (!*((unsigned char *)a5 + 16)) {
    goto LABEL_11;
  }
  int v14 = *(_DWORD *)(v12 + 26);
  uint64_t v15 = v12 + 30;
  if (!v14) {
    uint64_t v15 = 0;
  }
  int v16 = *(_DWORD *)(a3 + 26);
  uint64_t v17 = a3 + 30;
  if (!v16) {
    uint64_t v17 = 0;
  }
  v22[0] = *(_DWORD *)(v13 + 16);
  v22[1] = v14;
  uint64_t v23 = v13 + 20;
  uint64_t v24 = v15;
  v19[0] = *(_DWORD *)(a1 + 16);
  v19[1] = v16;
  uint64_t v20 = a1 + 20;
  uint64_t v21 = v17;
  uint64_t result = sub_10000AB20(*(void *)(*(void *)(v10 + 8) + 40), v22, v19, &v25, 0);
  if (!result)
  {
    if (!v25) {
      goto LABEL_11;
    }
    if (*(void *)(v13 + 8) > *(void *)(a1 + 8)) {
      return sub_10000C94C(v11, a1, a2);
    }
    uint64_t result = sub_10000C94C(v11, v13, *((unsigned int *)a5 + 5));
    if (!result)
    {
LABEL_11:
      *((unsigned char *)a5 + 16) = 1;
      bzero((void *)a5[4], 0x354uLL);
      memcpy((void *)a5[4], (const void *)a1, a2);
      *((_DWORD *)a5 + 5) = a2;
      bzero((void *)a5[5], 0x35EuLL);
      memcpy((void *)a5[5], (const void *)a3, a4);
      uint64_t result = 0;
      *((_DWORD *)a5 + 6) = a4;
    }
  }
  return result;
}

uint64_t sub_10000BEE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = *(void *)(a5 + 8);
  uint64_t v7 = **(uint64_t ***)a5;
  uint64_t v8 = *(void *)(*(void *)a5 + 8);
  unsigned int v9 = *(_DWORD *)(*(void *)a5 + 24);
  uint64_t v10 = malloc_type_calloc(1uLL, v9, 0xC14D5E57uLL);
  if (v10)
  {
    uint64_t v11 = v10;
    if (!v8 || (uint64_t v12 = *(void *)(v8 + 40), (*(unsigned char *)(v12 + 264) & 1) != 0))
    {
      uint64_t v14 = 0;
      uint64_t v13 = *v7;
    }
    else
    {
      uint64_t v13 = *v7;
      if (*(void *)(v12 + 976))
      {
        uint64_t v14 = 0;
      }
      else
      {
        BOOL v19 = *(void *)(v12 + 1096) != 0;
        uint64_t v20 = *(void *)(v8 + 8 * v19 + 24);
        uint64_t v21 = v8 + 96 * v19 + 768;
        if (v20)
        {
          uint64_t v13 = v20;
          uint64_t v14 = v21;
        }
        else
        {
          uint64_t v14 = 0;
        }
      }
    }
    uint64_t v15 = sub_10002F238(v13, *(void *)(a3 + 10), v9 / *(_DWORD *)(v7[1] + 36), (uint64_t)v11, v14, 0, 0, 0, 0);
    if (!v15)
    {
      memset(v32, 170, sizeof(v32));
      unsigned __int16 v31 = -21846;
      unsigned int v16 = *(_DWORD *)(a3 + 18);
      if (v16 > *(_DWORD *)(a3 + 22))
      {
LABEL_12:
        uint64_t v15 = 0;
      }
      else
      {
        uint64_t v17 = (_DWORD *)(v8 + 704);
        while (1)
        {
          sub_100033F78((uint64_t)v11, v6, v16, (uint64_t *)&v32[5], v32, (uint64_t *)&v32[1], &v31);
          uint64_t v18 = sub_100027E70(v17, 7u, 2, 0, 1, *(long long **)&v32[5], v32[0], *(unsigned char **)&v32[1], v31);
          if (v18) {
            break;
          }
          if (++v16 > *(_DWORD *)(a3 + 22)) {
            goto LABEL_12;
          }
        }
        uint64_t v15 = v18;
        uint64_t v22 = **(void **)&v32[5] & 0xFFFFFFFFFFFFFFFLL;
        strerror(v18);
        sub_10004458C("unable to add tree node repair at key id %llu : %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
        sub_100048B34((char *)0x41C, v15);
      }
    }
    free(v11);
  }
  else
  {
    uint64_t v15 = 12;
    sub_100048B34((char *)0x436, 12);
  }
  return v15;
}

uint64_t sub_10000C0B0(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a5 + 34)) {
    return 0;
  }
  uint64_t v8 = 0;
  if (sub_10003416C(a5, a2, 0, 0, a5, a6, a7, a8)) {
    return v8;
  }
  memset(v60, 170, 18);
  unsigned __int16 v59 = -21846;
  sub_1000340F4(a5, a2, 0, (uint64_t *)&v60[5], v60, *(_DWORD *)(a5 + 36) - 1, (uint64_t *)&v60[1], &v59);
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v54 = 0u;
  unsigned int v15 = v60[0] + 20;
  unsigned int v16 = (char *)malloc_type_calloc(1uLL, v60[0] + 20, 0x18960485uLL);
  uint64_t v17 = v16;
  if (v16)
  {
    *(void *)unsigned int v16 = -1;
    *((void *)v16 + 1) = -1;
    size_t v18 = v60[0];
    *((_DWORD *)v16 + 4) = v60[0];
    memcpy(v16 + 20, *(const void **)&v60[5], v18);
    uint64_t v19 = sub_1000389E0((uint64_t)&v54, a3, 0, 4294967294, v17, v15, 0);
    if (!v19)
    {
      if (!BYTE8(v56))
      {
        while (1)
        {
          long long v31 = v55;
          int v32 = *(_DWORD *)(*((void *)&v55 + 1) + 26);
          int v53 = 0;
          uint64_t v33 = v55 + 20;
          if (sub_10003DD34(*(void *)(*(void *)(a1 + 8) + 40), (unint64_t *)(v55 + 20), *(_DWORD *)(v55 + 16), *(unint64_t **)&v60[1], v59, &v53)|| v53 >= 1)
          {
            break;
          }
          uint64_t v35 = *((void *)&v31 + 1) + 30;
          if (!v32) {
            uint64_t v35 = 0;
          }
          int v36 = *(_DWORD *)(*((void *)&v31 + 1) + 26);
          v50[0] = *(_DWORD *)(v31 + 16);
          v50[1] = v36;
          uint64_t v51 = v33;
          uint64_t v52 = v35;
          v47[0] = v60[0];
          v47[1] = v59;
          uint64_t v48 = *(void *)&v60[5];
          uint64_t v49 = *(void *)&v60[1];
          uint64_t v37 = sub_10000C328(a4, *(void *)(*(void *)(a1 + 8) + 40), a2, a5, a6, 0, v50, v47);
          if (v37)
          {
            uint64_t v8 = v37;
            goto LABEL_10;
          }
          uint64_t v38 = (*((uint64_t (**)(long long *))&v54 + 1))(&v54);
          uint64_t v8 = v38;
          if (v38)
          {
            char v39 = strerror(v38);
            sub_10004458C("unable to iterate tree for tree node repairs: %s\n", v40, v41, v42, v43, v44, v45, v46, v39);
            uint64_t v28 = 1049;
            goto LABEL_7;
          }
          if (BYTE8(v56)) {
            goto LABEL_10;
          }
        }
      }
      uint64_t v8 = 0;
      goto LABEL_10;
    }
    uint64_t v8 = v19;
    char v20 = strerror(v19);
    sub_10004458C("unable to iterate tree for tree node repairs: %s\n", v21, v22, v23, v24, v25, v26, v27, v20);
    uint64_t v28 = 1048;
LABEL_7:
    int v29 = v8;
  }
  else
  {
    uint64_t v8 = 12;
    uint64_t v28 = 1047;
    int v29 = 12;
  }
  sub_100048B34((char *)v28, v29);
LABEL_10:
  if ((void)v54) {
    ((void (*)(long long *))v54)(&v54);
  }
  if (v17) {
    free(v17);
  }
  return v8;
}

uint64_t sub_10000C328(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, int *a8)
{
  char v33 = 0;
  memset(v32, 170, sizeof(v32));
  int v14 = sub_10000AB20(a2, a7, a8, &v33, (uint64_t)v32);
  uint64_t result = 0;
  if (!v14 && v33)
  {
    memset(v31, 170, sizeof(v31));
    int v30 = 0;
    __int16 v29 = -21846;
    unsigned int v16 = -1;
    int v28 = -1;
    unsigned int v17 = *(_DWORD *)(a4 + 36);
    if (v17)
    {
      do
      {
        unsigned int v18 = v16++;
        sub_100033F78(a4, a3, v16, &v31[2], (_WORD *)&v30 + 1, v31, &v29);
        int v19 = sub_10003DD34(a2, (unint64_t *)v31[2], HIWORD(v30), v32[1], v32[0], &v28);
        unsigned int v17 = *(_DWORD *)(a4 + 36);
        BOOL v20 = v19 == 0;
        BOOL v21 = v18 + 2 < v17 && v19 == 0;
      }
      while (v21 && v28 < 0);
      int v28 = -1;
      if (v16 >= v17 || v19)
      {
        unsigned int v22 = v16;
      }
      else
      {
        unsigned int v22 = v16;
        do
        {
          sub_100033F78(a4, a3, v22, &v31[1], &v30, v31, &v29);
          int v23 = sub_10003DD34(a2, (unint64_t *)v31[1], (unsigned __int16)v30, v32[2], HIDWORD(v32[0]), &v28);
          ++v22;
          unsigned int v17 = *(_DWORD *)(a4 + 36);
          BOOL v20 = v23 == 0;
        }
        while (v22 < v17 && v23 == 0 && v28 < 1);
      }
    }
    else
    {
      BOOL v20 = 1;
      unsigned int v22 = -1;
    }
    int v26 = v22 - 1;
    if (!v20 || v26 == v17) {
      return 0;
    }
    else {
      return sub_10000AE84(a1, *(void *)(a4 + 8), *(void *)(a4 + 16), *(_WORD *)(a4 + 34), a5, a6, (const void *)v31[2], HIWORD(v30), v16, (const void *)v31[1], (unsigned __int16)v30, v26);
    }
  }
  return result;
}

uint64_t sub_10000C51C(unint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = (char *)malloc_type_calloc(1uLL, *(unsigned int *)(a3[1] + 36), 0x4F519D90uLL);
  if (!v6)
  {
    sub_100048B34((char *)0x435, 12);
    return 0;
  }
  uint64_t v7 = (uint64_t)v6;
  int v8 = dword_100074040;
  if (dword_100074040 >= 99) {
    int v8 = 99;
  }
  if (v8 < 0) {
    goto LABEL_30;
  }
  uint64_t v9 = 0;
  unint64_t v10 = a2 + a1;
  uint64_t v11 = (v8 + 1);
  uint64_t v32 = v11;
  char v33 = (uint32x4_t *)(v6 + 8);
  while (1)
  {
    uint64_t v12 = (char *)&xmmword_100075078 + 152 * v9;
    long long v13 = *((_OWORD *)v12 + 7);
    void v38[2] = *((_OWORD *)v12 + 6);
    v38[3] = v13;
    long long v39 = *((_OWORD *)v12 + 8);
    uint64_t v40 = *((void *)v12 + 18);
    long long v14 = *((_OWORD *)v12 + 3);
    v36[2] = *((_OWORD *)v12 + 2);
    long long v37 = v14;
    long long v15 = *((_OWORD *)v12 + 5);
    v38[0] = *((_OWORD *)v12 + 4);
    v38[1] = v15;
    long long v16 = *((_OWORD *)v12 + 1);
    v36[0] = *(_OWORD *)v12;
    v36[1] = v16;
    if (!(_BYTE)v40) {
      goto LABEL_29;
    }
    if (!*((void *)&v37 + 1)) {
      goto LABEL_29;
    }
    unsigned int v17 = sub_10001F348((uint64_t)a3, v39);
    if (!v17) {
      goto LABEL_29;
    }
    unsigned int v18 = v17;
    uint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
    memset(v34, 0, sizeof(v34));
    if (sub_10002D3D4((uint64_t)a3, (uint64_t)v17, &v35)
      || sub_100033E58(v35, *(void *)(v35 + 56), 0, (uint64_t)v34))
    {
      goto LABEL_30;
    }
    uint64_t v19 = *((void *)v18 + 5);
    int v20 = (*(unsigned char *)(v19 + 264) & 1) != 0 ? 0 : 4 * (*(void *)(v19 + 976) == 0);
    if (a1 < v10) {
      break;
    }
LABEL_28:
    uint64_t v11 = v32;
LABEL_29:
    if (++v9 == v11) {
      goto LABEL_30;
    }
  }
  unsigned int v21 = *(_DWORD *)(v35 + 24);
  BOOL v22 = *(void *)(v19 + 1096) != 0;
  int v23 = (uint64_t *)&v18[8 * v22 + 24];
  uint64_t v24 = (uint64_t)&v18[96 * v22 + 768];
  while (1)
  {
    uint64_t v25 = *a3;
    if (v20)
    {
      if (*v23)
      {
        uint64_t v25 = *v23;
        uint64_t v26 = v24;
      }
      else
      {
        uint64_t v26 = 0;
      }
    }
    else
    {
      uint64_t v26 = 0;
    }
    if (sub_10002F238(v25, a1, v21 / *(_DWORD *)(a3[1] + 36), v7, v26, 0, 0, 0, 0)
      || (*(_DWORD *)(v7 + 24) & 0xFFFFFFFE) == 2
      && *(_DWORD *)(v7 + 28) == 14
      && !sub_10003D848((void *)v7, v33, v21 - 8, 0, v27, v28)
      && sub_10000C0B0(v35, (uint64_t)v34, (uint64_t)v36, v38, v7, a1, v29, v30))
    {
      break;
    }
    if (v10 == ++a1)
    {
      a1 = v10;
      goto LABEL_28;
    }
  }
LABEL_30:
  free((void *)v7);
  return 0;
}

uint64_t sub_10000C7B0(unint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 8) = 0;
  if (*(int *)(a3 + 12) < 1) {
    return 0;
  }
  int v6 = 0;
  char v8 = -86;
  while (1)
  {
    uint64_t result = sub_1000051A8(*(void *)(*(void *)a3 + 16 * v6), *(void *)(*(void *)a3 + 16 * v6 + 8), a1, a2, &v8, (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t))sub_10000C85C, a3);
    if (result) {
      break;
    }
    int v6 = *(_DWORD *)(a3 + 8);
    if (!v8) {
      *(_DWORD *)(a3 + 8) = ++v6;
    }
    if (v6 >= *(_DWORD *)(a3 + 12)) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10000C85C(uint64_t a1, uint64_t a2, int a3, int32x2_t *a4)
{
  uint64_t v5 = (char *)*a4;
  uint64_t v6 = a4[1].i32[0];
  if (a3)
  {
    memmove(&v5[16 * v6], &v5[16 * v6 + 16], 16 * (a4[1].i32[1] - (int)v6));
    uint64_t result = 0;
    --a4[1].i32[1];
    return result;
  }
  __int32 v10 = a4[1].i32[1];
  if (v10 != a4[2].i32[0]) {
    goto LABEL_6;
  }
  a4[2].i32[0] = 2 * v10;
  uint64_t v11 = (char *)malloc_type_realloc(v5, 32 * v10, 0x1000040451B5BE8uLL);
  if (v11)
  {
    __int32 v10 = a4[1].i32[1];
    uint64_t v5 = v11;
LABEL_6:
    uint64_t v12 = &v5[16 * v6];
    memmove(v12 + 16, v12, 16 * (v10 - (int)v6));
    uint64_t result = 0;
    *(void *)uint64_t v12 = a1;
    *((void *)v12 + 1) = a2;
    a4[1] = vadd_s32(a4[1], (int32x2_t)0x100000001);
    return result;
  }
  free(v5);
  return 12;
}

uint64_t sub_10000C94C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = sub_10003A048(a1, 0, a2, a3);
  uint64_t v5 = v4;
  if ((v4 & 0xFFFFFFFD) != 0)
  {
    uint64_t v6 = *(void *)(a2 + 20) & 0xFFFFFFFFFFFFFFFLL;
    strerror(v4);
    sub_10004458C("unable to remove tree node at key id %llu for repairs : %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
    sub_100048B34((char *)0x416, v5);
  }
  return v5;
}

uint64_t sub_10000C9C0(uint64_t *a1, unint64_t a2, int a3, void **a4)
{
  uint64_t v8 = (unsigned int *)a1[3];
  uint64_t v9 = v8[12 * a3 + 20];
  uint64_t v10 = *a4;
  if (!*a4)
  {
    uint64_t v10 = malloc_type_malloc(v8[8], 0x43A94A4AuLL);
    if (!v10)
    {
      uint64_t v32 = 526;
      char v33 = "Failed to allocate memory\n";
      goto LABEL_10;
    }
  }
  unsigned int v18 = (char *)v8 + v9;
  unint64_t v19 = a2 / v8[10];
  if (!v8[12 * a3 + 17])
  {
    unsigned int v21 = 0;
    goto LABEL_12;
  }
  int v20 = (char *)malloc_type_malloc(v8[8], 0x3CD19C9AuLL);
  if (!v20)
  {
    uint64_t v32 = 527;
    char v33 = "Failed to allocate memory for cab\n";
LABEL_10:
    sub_10004458C(v33, v11, v12, v13, v14, v15, v16, v17, v43);
    uint64_t v31 = 12;
    sub_100048B34((char *)v32, 12);
    goto LABEL_17;
  }
  unsigned int v21 = v20;
  unsigned int v22 = v19 / v8[11];
  uint64_t v23 = sub_10002F148(*a1, *(void *)&v18[8 * v22]);
  if (v23)
  {
    uint64_t v31 = v23;
    sub_10004458C("error (%d) getting cab %u @ %lld on device %d\n", v24, v25, v26, v27, v28, v29, v30, v23);
    sub_100048B34((char *)0x1D6, v31);
LABEL_15:
    free(v21);
    goto LABEL_16;
  }
  unsigned int v18 = v21 + 40;
  LODWORD(v19) = v19 - v8[11] * v22;
LABEL_12:
  uint64_t v34 = sub_10002F148(*a1, *(void *)&v18[8 * v19]);
  uint64_t v31 = v34;
  if (v34)
  {
    sub_10004458C("error (%d) getting cib %u @ %lld on device %d\n", v35, v36, v37, v38, v39, v40, v41, v34);
    sub_100048B34((char *)0x1D7, v31);
  }
  if (v21) {
    goto LABEL_15;
  }
LABEL_16:
  if (!v31)
  {
LABEL_19:
    *a4 = v10;
    return v31;
  }
LABEL_17:
  if (v10 == *a4) {
    goto LABEL_19;
  }
  free(v10);
  return v31;
}

uint64_t sub_10000CB8C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4, char **a5, _DWORD *a6, int a7)
{
  uint64_t v93 = 0;
  uint64_t v11 = a1[3];
  char v12 = __clz(__rbit64(*(unsigned int *)(v11 + 32)));
  unint64_t v13 = (((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v12) & a2) / *(unsigned int *)(v11 + 36);
  if (a5) {
    uint64_t v93 = *a5;
  }
  uint64_t v14 = sub_10000C9C0(a1, v13, ((a2 << v12) & 0x4000000000000000) != 0, (void **)&v93);
  if (v14)
  {
    uint64_t v15 = v14;
    uint64_t v93 = 0;
    strerror(v14);
    sub_10004458C("failed to get cib for chunk index %llu: %s\n", v16, v17, v18, v19, v20, v21, v22, v13);
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    int v25 = 0;
LABEL_5:
    uint64_t v26 = a6;
    uint64_t v27 = a4;
    goto LABEL_6;
  }
  uint64_t v23 = v93;
  unint64_t v90 = v13 % *(unsigned int *)(v11 + 40);
  uint64_t v28 = &v93[32 * v90];
  uint64_t v30 = *((void *)v28 + 8);
  uint64_t v29 = v28 + 64;
  uint64_t v24 = v30;
  if (v30)
  {
    uint64_t v31 = sub_10002F148(*a1, v24);
    uint64_t v15 = v31;
    if (v31)
    {
      int v25 = v90;
      sub_10004458C("error (%d) getting cib %d bitmap %d @ %lld on device %d\n", v32, v33, v34, v35, v36, v37, v38, v31);
      sub_100048B34((char *)0x1D8, v15);
      goto LABEL_5;
    }
LABEL_41:
    uint64_t v26 = a6;
    uint64_t v27 = a4;
    int v25 = v90;
LABEL_42:
    if (!v26) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  sub_10000A2A8(a3, 0, *(unsigned int *)(v11 + 36));
  if (!a7)
  {
    uint64_t v24 = 0;
    uint64_t v15 = 2;
    goto LABEL_41;
  }
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  uint64_t v39 = (unsigned int *)a1[3];
  size_t v40 = v39[8];
  uint64_t v94 = 0;
  uint64_t v41 = malloc_type_malloc(v40, 0x2801283AuLL);
  if (!v41)
  {
    sub_10004458C("Failed to allocate memory\n", v42, v43, v44, v45, v46, v47, v48, v86);
    sub_100048B34((char *)0x20C, 12);
    goto LABEL_54;
  }
  uint64_t v49 = v41;
  unsigned int v87 = (uint64_t *)v29;
  if (!v39[40])
  {
LABEL_52:
    free(v49);
LABEL_54:
    uint64_t v24 = 0;
    uint64_t v15 = 28;
LABEL_55:
    uint64_t v27 = a4;
    sub_100048B34((char *)0x210, v15);
    int v25 = v90;
    uint64_t v26 = a6;
LABEL_6:
    if ((v15 & 0xFFFFFFFD) != 0)
    {
      if (v26) {
        *uint64_t v26 = 0;
      }
      if (v27)
      {
        uint64_t v24 = 0;
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    goto LABEL_42;
  }
  unsigned int v50 = 0;
  unint64_t v51 = 0;
  uint64_t v52 = (8 * v40);
  int v53 = (char *)v39 + v39[82];
  char v88 = v41;
  char v89 = v53;
  while (1)
  {
    uint64_t v54 = *(unsigned __int16 *)&v53[2 * v51];
    uint64_t v55 = a1[3];
    int v56 = *(_DWORD *)(v55 + 164);
    if ((v56 & 0x7FFFFFFFu) <= v54)
    {
      LOBYTE(v67) = 22;
LABEL_24:
      sub_10004458C("error (%d) looking up spaceman IP bitmap block %u\n", v42, v54, v44, v45, v46, v47, v48, v67);
      goto LABEL_25;
    }
    uint64_t v57 = *(void *)(v55 + 168);
    if (v56 < 0)
    {
      int v67 = sub_100030FD4((uint64_t)a1, v57, v54, &v96, 0);
      if (v67) {
        goto LABEL_24;
      }
      uint64_t v58 = v96;
    }
    else
    {
      uint64_t v58 = v57 + v54;
      uint64_t v96 = v58;
    }
    int v59 = sub_10002F148(*a1, v58);
    if (!v59) {
      break;
    }
    sub_10004458C("error (%d) getting spaceman IP bitmap block %u @ %lld\n", v60, v61, v62, v63, v64, v65, v66, v59);
LABEL_25:
    ++v51;
    v50 += v52;
    if (v51 >= v39[40]) {
      goto LABEL_52;
    }
  }
  if (!sub_10000A370(0, (uint64_t)v49, 0, v52, &v95)) {
    goto LABEL_25;
  }
  uint64_t v69 = v95;
  unint64_t v70 = v95 + v50;
  uint64_t v71 = a1[3];
  uint64_t v72 = *(void *)(v71 + 152);
  if ((v72 & 0x7FFFFFFFFFFFFFFFuLL) <= v70)
  {
    int v83 = 22;
LABEL_36:
    sub_10004458C("error (%d) looking up spaceman IP block %llu\n", v69, v68, v44, v45, v46, v47, v48, v83);
    sub_100048B34((char *)0x21F, v83);
    uint64_t v49 = v88;
    goto LABEL_37;
  }
  uint64_t v73 = *(void *)(v71 + 176);
  if ((v72 & 0x8000000000000000) == 0)
  {
    uint64_t v94 = v73 + v70;
    goto LABEL_33;
  }
  int v83 = sub_100030FD4((uint64_t)a1, v73, v70, &v94, 0);
  if (v83) {
    goto LABEL_36;
  }
  uint64_t v69 = v95;
  uint64_t v49 = v88;
LABEL_33:
  sub_10000A1C0((uint64_t)v49, v69, 1);
  int v74 = sub_10002F2C4(*a1, v96);
  if (v74)
  {
    int v82 = v74;
    sub_10004458C("error (%d) writing spaceman IP bitmap %d @ %lld\n", v75, v76, v77, v78, v79, v80, v81, v74);
    sub_100048B34((char *)0x20D, v82);
LABEL_37:
    int v53 = v89;
    goto LABEL_25;
  }
  uint64_t v24 = v94;
  free(v49);
  if (!v24)
  {
    uint64_t v15 = 92;
    goto LABEL_55;
  }
  uint64_t v15 = 0;
  *unsigned int v87 = v24;
  uint64_t v85 = *(void *)(v11 + 16);
  int v25 = v90;
  *(void *)&v23[32 * v90 + 40] = v85;
  uint64_t v26 = a6;
  uint64_t v27 = a4;
  if (a6) {
LABEL_43:
  }
    *uint64_t v26 = v25;
LABEL_44:
  if (v27) {
LABEL_45:
  }
    *uint64_t v27 = v24;
LABEL_46:
  if (a5 && (!v15 || v23 == *a5)) {
    *a5 = v23;
  }
  else {
    free(v23);
  }
  return v15;
}

uint64_t sub_10000CFB0(uint64_t a1, uint64_t **a2, _DWORD *a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  uint64_t v5 = *(void *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(v5 + 36);
  if (v4 >= v6)
  {
    uint64_t v12 = 0;
    *(unsigned char *)(a1 + 376) = 1;
  }
  else
  {
    uint64_t v9 = v4 + 1;
    if (v9 < v6 && (uint64_t v10 = v5 + 32 * v9, (v11 = *(void *)(v10 + 64)) != 0))
    {
      uint64_t v12 = sub_100026B34(*(uint64_t **)a1, 0, 0x40000000, v11, *(void *)(v10 + 40), 0x20000000, 8, 0, a1 + 176 * (v9 & 1) + 24);
      if (v12) {
        sub_100048B34((char *)0x47A, v12);
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v13 = *(unsigned int *)(a1 + 16);
    uint64_t v14 = *(uint64_t **)a1;
    uint64_t v15 = *(void *)(a1 + 8);
    uint64_t v16 = *(void *)(v15 + 32 * v13 + 64);
    *a3 = v13;
    if (v16)
    {
      int v17 = sub_100026B70(v14, 0, 0x40000000, *(void *)(v15 + 32 * *(unsigned int *)(a1 + 16) + 64), *(void *)(v15 + 32 * *(unsigned int *)(a1 + 16) + 40), 0x20000000, 8, 0, a1 + 176 * (*(_DWORD *)(a1 + 16) & 1) + 24, a2, 0, 0);
      if (v17)
      {
        unsigned int v18 = v17;
        sub_100048B34((char *)0x47B, v17);
        if (v12) {
          uint64_t v12 = v12;
        }
        else {
          uint64_t v12 = v18;
        }
      }
    }
    else
    {
      uint64_t v19 = (uint64_t *)malloc_type_calloc(1uLL, *(unsigned int *)(v14[1] + 36), 0x449A16F8uLL);
      *a2 = v19;
      if (v19) {
        BOOL v20 = 0;
      }
      else {
        BOOL v20 = v12 == 0;
      }
      if (v20) {
        uint64_t v12 = 12;
      }
      else {
        uint64_t v12 = v12;
      }
    }
    ++*(_DWORD *)(a1 + 16);
  }
  return v12;
}

uint64_t sub_10000D12C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t **a4, _DWORD *a5)
{
  if (!a1) {
    return 22;
  }
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  *(unsigned char *)(a1 + 376) = 0;
  uint64_t v8 = *(void *)(a3 + 64);
  if (v8)
  {
    uint64_t v9 = sub_100026B34(a2, 0, 0x40000000, v8, *(void *)(a3 + 40), 0x20000000, 8, 0, a1 + 24);
    if (v9)
    {
      uint64_t v10 = v9;
      sub_100048B34((char *)0x47C, v9);
      return v10;
    }
  }

  return sub_10000CFB0(a1, a4, a5);
}

char *sub_10000D224(uint64_t a1)
{
  qword_100078BE0 = a1;
  if (!sub_100038040((uint64_t)&unk_100078BE8, 0, 0, 0x8000000, 2, 0, 0, 4096, 8, 48, 0, 0, (uint64_t)sub_1000306FC))sub_10003A18C((uint64_t)&unk_100078BE8, 0, 0); {
  uint64_t result = (char *)sub_10001CF74((uint64_t)&unk_100078BE8, (uint64_t)"dstream", (uint64_t)sub_10000D300);
  }
  if (result)
  {
    sub_100044674("failed to register the dstream tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
    return sub_100048B34((char *)0x583, 12);
  }
  return result;
}

uint64_t sub_10000D300()
{
  if (qword_100078C20) {
    uint64_t result = sub_10003A268((uint64_t)&unk_100078BE8, 0);
  }
  qword_100078C28 = 0;
  return result;
}

uint64_t sub_10000D338(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100078C28) {
    return 0;
  }
  if (qword_100078C28 >= a1)
  {
    if (qword_100078C28 > a1)
    {
      sub_10004458C("dstream (id %llu) is older than the current dstream (id %llu)\n", a2, a3, a4, a5, a6, a7, a8, a1);
      uint64_t v13 = 92;
      sub_100048B34((char *)0x3B8, 92);
      return v13;
    }
    return 0;
  }
  uint64_t v15 = qword_100078C28;
  if ((BYTE8(xmmword_100078C50) & 3) != 2)
  {
    if ((BYTE8(xmmword_100078C50) & 4) == 0) {
      goto LABEL_19;
    }
    if (!xmmword_100078C50 || xmmword_100078C50 != DWORD1(xmmword_100078C50)) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = qword_100078C38;
  if (qword_100078C40) {
    BOOL v10 = (BYTE8(xmmword_100078C50) & 0x80) == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    uint64_t v9 = qword_100078C40;
  }
  if ((BYTE8(xmmword_100078C50) & 0x18) == 0 && qword_100078C48 == v9) {
    uint64_t v12 = sub_10003A048((uint64_t)dword_100078BE8, 0, (uint64_t)&v15, 8);
  }
  else {
LABEL_19:
  }
    uint64_t v12 = sub_100039A6C(dword_100078BE8, 0, &v15, 8, &unk_100078C30, 48);
  uint64_t v13 = v12;
  if (!v12) {
    qword_100078C28 = 0;
  }
  return v13;
}

uint64_t sub_10000D454(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100078C20) {
    return 0;
  }
  int v8 = a6;
  int v9 = a5;
  int v10 = a4;
  unint64_t v11 = a3;
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v46 = v14;
  long long v47 = v14;
  long long v45 = v14;
  uint64_t v15 = sub_10000D338(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v15)
  {
    uint64_t v15 = sub_10000D6C8(a2, &v45);
    if (!v15)
    {
      if ((BYTE8(v47) & 3) == 1) {
        int v16 = v10;
      }
      else {
        int v16 = 0;
      }
      if ((BYTE8(v47) & 3) != 0 && !v16)
      {
        uint64_t v43 = sub_10000EB20((uint64_t)&v45, a2, a1);
        sub_10004458C("found cloned xattr dstream (id %llu, object-ids %s)\n", v17, v18, v19, v20, v21, v22, v23, a2);
        free(v43);
        uint64_t v15 = 92;
        uint64_t v24 = 851;
LABEL_22:
        sub_100048B34((char *)v24, 92);
        return v15;
      }
      if (v10) {
        __int16 v25 = 1;
      }
      else {
        __int16 v25 = 2;
      }
      int v26 = v9 | ((BYTE8(v47) & 0x20) >> 5);
      if (v26) {
        __int16 v27 = 32;
      }
      else {
        __int16 v27 = 0;
      }
      if (v8 | ((BYTE8(v47) & 0x40) >> 6)) {
        __int16 v28 = 64;
      }
      else {
        __int16 v28 = 0;
      }
      __int16 v29 = WORD4(v47) & 0xFF9C | v25 | v28 | v27;
      WORD4(v47) = v29;
      if (v26 && DWORD1(v47))
      {
        uint64_t v44 = sub_10000EB20((uint64_t)&v45, a2, a1);
        sub_10004458C("cloned dstream (id %llu, object-ids %s) is being truncated\n", v30, v31, v32, v33, v34, v35, v36, a2);
        free(v44);
        uint64_t v15 = 92;
        uint64_t v24 = 807;
        goto LABEL_22;
      }
      if (DWORD1(v47))
      {
        unint64_t v37 = *((void *)&v45 + 1);
        if (*((void *)&v45 + 1) != v11)
        {
          if (*((void *)&v45 + 1) > v11)
          {
            *((void *)&v45 + 1) = v11;
            unint64_t v37 = v11;
          }
          v29 |= 0x10u;
          WORD4(v47) = v29;
          unint64_t v11 = v37;
        }
      }
      else
      {
        *(void *)&long long v45 = a1;
        *((void *)&v45 + 1) = v11;
      }
      if (((int v38 = DWORD1(v47) + 1, ++DWORD1(v47), v48 = a2, (v29 & 3) == 2)
         || (v29 & 4) != 0 && v47 && v47 == v38)
        && ((void)v46 ? (BOOL v39 = (v29 & 0x80) == 0) : (BOOL v39 = 1),
            !v39 ? (unint64_t v40 = v46) : (unint64_t v40 = v11),
            (v29 & 0x18) == 0 && *((void *)&v46 + 1) == v40))
      {
        uint64_t v41 = sub_10003A048((uint64_t)dword_100078BE8, 0, (uint64_t)&v48, 8);
      }
      else
      {
        uint64_t v41 = sub_100039A6C(dword_100078BE8, 0, &v48, 8, &v45, 48);
      }
      uint64_t v15 = v41;
      if (!v41)
      {
        if (a2 == a1)
        {
          uint64_t v15 = 0;
          qword_100078C28 = a2;
          unk_100078C30 = v45;
          *(_OWORD *)&qword_100078C40 = v46;
          xmmword_100078C50 = v47;
          return v15;
        }
        return 0;
      }
    }
  }
  return v15;
}

uint64_t sub_10000D6C8(uint64_t a1, _OWORD *a2)
{
  uint64_t v6 = a1;
  unsigned int v4 = 48;
  unsigned int v5 = 8;
  uint64_t result = sub_1000380B0((uint64_t)dword_100078BE8, 0, 0, &v6, &v5, 8u, a2, &v4);
  if (result == 2)
  {
    *a2 = xmmword_10006F1D0;
    *((void *)a2 + 3) = 0;
    *((void *)a2 + 4) = 0;
    *((void *)a2 + 2) = 0;
    *((_WORD *)a2 + 20) &= 0xFE00u;
    return sub_100039A6C(dword_100078BE8, 0, &v6, 8, a2, 48);
  }
  return result;
}

uint64_t sub_10000D770(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = 8;
  return sub_10000D7AC(a1, 15, 0, a2, &v9, 1, a7, a8);
}

uint64_t sub_10000D7AC(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&long long var8 = a4;
  if (a1) {
    return sub_100027E70(a1, 8u, 1, a2, a3, &var8, 8u, a5, a6);
  }

  return sub_100027AD0(0, a2, a3, a4, (uint64_t)a5, a6, a7, a8);
}

uint64_t sub_10000D814(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a1;
  if (!qword_100078C20) {
    return 0;
  }
  *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v8 = v3;
  long long v9 = v3;
  long long v7 = v3;
  if (qword_100078C28 == a1)
  {
    uint64_t result = 0;
    qword_100078C40 = a2;
  }
  else
  {
    unsigned int v5 = 48;
    unsigned int v6 = 8;
    LODWORD(result) = sub_1000380B0((uint64_t)dword_100078BE8, 0, 0, &v10, &v6, 8u, &v7, &v5);
    if (result)
    {
      if (result == 2) {
        return 0;
      }
      else {
        return result;
      }
    }
    else
    {
      *(void *)&long long v8 = a2;
      return sub_100039A6C(dword_100078BE8, 0, &v10, 8, &v7, 48);
    }
  }
  return result;
}

void sub_10000D8E8(void *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100078C20)
  {
    sub_10000D948(*a1 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    if (!v9)
    {
      WORD4(xmmword_100078C50) |= 4u;
      LODWORD(xmmword_100078C50) = *a2;
    }
  }
}

double sub_10000D948(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!sub_10000D338(a1, a2, a3, a4, a5, a6, a7, a8) && !qword_100078C28)
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v12 = v10;
    long long v13 = v10;
    long long v11 = v10;
    if (!sub_10000D6C8(a1, &v11))
    {
      qword_100078C28 = a1;
      unk_100078C30 = v11;
      *(_OWORD *)&qword_100078C40 = v12;
      double result = *(double *)&v13;
      xmmword_100078C50 = v13;
    }
  }
  return result;
}

void sub_10000D9C4(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100078C20)
  {
    sub_10000D948(*a1 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    if (!v10)
    {
      uint64_t v11 = *a2 & 0xFFFFFFFFFFFFFFLL;
      if (v11)
      {
        uint64_t v12 = a1[1];
        if (v12 != qword_100078C48)
        {
          WORD4(xmmword_100078C50) |= 8u;
          uint64_t v12 = a1[1];
        }
        qword_100078C48 = v12 + v11;
      }
      else
      {
        WORD4(xmmword_100078C50) |= 8u;
      }
    }
  }
}

uint64_t sub_10000DA64(uint64_t a1, void *a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100078C20) {
    return 0;
  }
  sub_10000D948(*a2 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v19 = v18;
  if (!v18)
  {
    unint64_t v20 = a2[1] & 0xFFFFFFFFFFFFFFLL;
    int v21 = (unsigned __int16)*a3;
    int v22 = *(_DWORD *)(*(void *)(a1 + 8) + 36);
    unint64_t v23 = qword_100078C40;
    if (!qword_100078C40) {
      unint64_t v23 = qword_100078C38;
    }
    WORD4(xmmword_100078C50) |= 0x80u;
    if (v20 >= v23)
    {
      sub_10004458C("data_hash: object (oid 0x%llx): Found unexpected hash at offset %llu (expected length %llu)\n", v11, v12, v13, v14, v15, v16, v17, qword_100078C28);
      uint64_t v19 = 92;
      uint64_t v24 = 929;
    }
    else if (*a3)
    {
      if (v20 == qword_100078C48)
      {
        uint64_t v19 = 0;
        qword_100078C48 = v20 + (v22 * v21);
        return v19;
      }
      sub_10004458C("data_hash: object (oid 0x%llx): Missing hash at offset %llu (found %llu)\n", v11, v12, v13, v14, v15, v16, v17, qword_100078C28);
      uint64_t v19 = 92;
      uint64_t v24 = 931;
    }
    else
    {
      sub_10004458C("data_hash: object (oid 0x%llx): Invalid length at offset %llu\n", v11, v12, v13, v14, v15, v16, v17, qword_100078C28);
      uint64_t v19 = 92;
      uint64_t v24 = 930;
    }
    sub_100048B34((char *)v24, 92);
  }
  return v19;
}

uint64_t sub_10000DBA8(void *a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100078C20) {
    return 0;
  }
  uint64_t result = sub_10000D338(*a1 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!result)
  {
    *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v15 = v10;
    long long v16 = v10;
    long long v14 = v10;
    uint64_t result = sub_10000D6C8(*a2, &v14);
    if (!result)
    {
      char v11 = BYTE8(v16);
      WORD4(v16) |= 0x100u;
      uint64_t v17 = *a2;
      if (((v11 & 3) == 2 || (v11 & 4) != 0 && v16 && v16 == DWORD1(v16))
        && ((void)v15 ? (BOOL v12 = (v11 & 0x80) == 0) : (BOOL v12 = 1),
            !v12 ? (uint64_t v13 = v15) : (uint64_t v13 = *((void *)&v14 + 1)),
            (v11 & 0x18) == 0 && *((void *)&v15 + 1) == v13))
      {
        return sub_10003A048((uint64_t)dword_100078BE8, 0, (uint64_t)&v17, 8);
      }
      else
      {
        return sub_100039A6C(dword_100078BE8, 0, &v17, 8, &v14, 48);
      }
    }
  }
  return result;
}

uint64_t sub_10000DCB0(void *a1)
{
  if (!qword_100078C20) {
    return 0;
  }
  *(void *)&long long v1 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v1 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v7[1] = v1;
  long long v8 = v1;
  v7[0] = v1;
  uint64_t v9 = *a1 & 0xFFFFFFFFFFFFFFFLL;
  if (qword_100078C28 == v9)
  {
    unsigned int v2 = WORD4(xmmword_100078C50);
  }
  else
  {
    unsigned int v5 = 48;
    unsigned int v6 = 8;
    int v4 = sub_1000380B0((uint64_t)&unk_100078BE8, 0, 0, &v9, &v6, 8u, v7, &v5);
    uint64_t result = 0;
    if (v4) {
      return result;
    }
    unsigned int v2 = WORD4(v8);
  }
  return (v2 >> 6) & 1;
}

uint64_t sub_10000DD5C(uint64_t *a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100078C20) {
    return 0;
  }
  uint64_t v119 = 0;
  long long v117 = 0u;
  long long v118 = 0u;
  long long v116 = 0u;
  uint64_t v11 = *(void *)(a2 + 48);
  if (!v11) {
    uint64_t v11 = *(void *)(a2 + 40);
  }
  uint64_t v12 = *(void *)(v11 + 56);
  char v115 = 1;
  if ((v12 & 0x20) == 0
    || (uint64_t v13 = sub_10004AD8C(a1, a2, qword_100078BE0, (BOOL *)&v115, 0, 0, 0, 0), !v13))
  {
    uint64_t v13 = sub_10000D338(0xFFFFFFFFFFFFFFFFLL, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (!v13)
    {
      unsigned int v113 = 48;
      unsigned int v114 = 8;
      unsigned int v14 = sub_1000380B0((uint64_t)dword_100078BE8, 0, 1, &v119, &v114, 8u, &v116, &v113);
      if (v14)
      {
LABEL_8:
        if (v14 == 2) {
          uint64_t v13 = 0;
        }
        else {
          uint64_t v13 = v14;
        }
        goto LABEL_11;
      }
      while (1)
      {
        if (!DWORD1(v118))
        {
          if ((BYTE8(v118) & 4) != 0)
          {
            sub_100044674("found orphan dstream id object (id %llu, refcnt %u)\n", v15, v16, v17, v18, v19, v20, v21, v119);
            sub_100048B34((char *)0x256, -2);
            uint64_t v32 = sub_10000E544(a3, 0, 0, 0, v119, 0, v33, v34);
            if (v32) {
              goto LABEL_93;
            }
          }
          if (*((void *)&v117 + 1))
          {
            uint64_t v35 = "sealed volume hash records";
            if ((BYTE8(v118) & 0x80) == 0) {
              uint64_t v35 = "file extents";
            }
            sub_100044674("found orphan %s (id %llu, size %llu)\n", v15, v16, v17, v18, v19, v20, v21, (char)v35);
            sub_100048B34((char *)0x257, -2);
            if ((v12 & 0x20) == 0)
            {
              uint64_t v32 = sub_10000E5AC((uint64_t)a1, (void *)a2, a3, v119, (uint64_t)&v116, 0);
              if (v32)
              {
LABEL_93:
                uint64_t v13 = v32;
                break;
              }
            }
          }
          goto LABEL_75;
        }
        if ((BYTE8(v118) & 3) == 1)
        {
          if ((BYTE8(v118) & 4) == 0)
          {
            v120[0] = 0xAAAAAAAAAAAAAAAALL;
            v128[0] = v119 & 0xFFFFFFFFFFFFFFFLL | 0x6000000000000000;
            LODWORD(v125) = 0;
            unsigned int v126 = 4;
            unsigned int v127 = 8;
            uint64_t v13 = sub_10003E25C((uint64_t)a1, (void *)a2, 6, v120, v18, v19, v20, v21);
            if (!v13) {
              uint64_t v13 = sub_1000380B0(v120[0], qword_100078BE0, 0, v128, &v127, v127, &v125, &v126);
            }
            if (v13 != 2)
            {
              if (v13)
              {
                char v101 = v119;
                strerror(v13);
                sub_10004458C("failed to look up dstream id object (id %llu): %s\n", v102, v103, v104, v105, v106, v107, v108, v101);
                sub_100048B34((char *)0x3EF, v13);
                break;
              }
              sub_10004458C("refcnt (%u) of dstream id object (id %llu) is less than expected (%u)\n", v23, v24, v25, v26, v27, v28, v29, v125);
              sub_100048B34((char *)0x358, 92);
              LODWORD(v125) = v125 + DWORD1(v118);
              uint64_t v32 = sub_10000E544(a3, 1, 9, 1, v119, v125, v30, v31);
              if (v32) {
                goto LABEL_93;
              }
              WORD4(v118) &= ~0x10u;
              goto LABEL_38;
            }
            sub_10004458C("dstream (id %llu) does not have an associated dstream id object\n", v23, v24, v25, v26, v27, v28, v29, v119);
            sub_100048B34((char *)0x251, 92);
            uint64_t v38 = v119;
            uint64_t v39 = DWORD1(v118);
            unint64_t v40 = a3;
            uint64_t v41 = 2;
            uint64_t v42 = 0;
            goto LABEL_36;
          }
          if (v118 < DWORD1(v118))
          {
            sub_10004458C("refcnt (%u) of dstream id object (id %llu) is less than expected (%u)\n", v15, v16, v17, v18, v19, v20, v21, v118);
            sub_100048B34((char *)0x2C3, 92);
            uint64_t v38 = v119;
            uint64_t v39 = DWORD1(v118);
            unint64_t v40 = a3;
            uint64_t v41 = 1;
            uint64_t v42 = 9;
LABEL_36:
            uint64_t v43 = 1;
LABEL_37:
            uint64_t v32 = sub_10000E544(v40, v41, v42, v43, v38, v39, v36, v37);
            if (v32) {
              goto LABEL_93;
            }
            goto LABEL_38;
          }
          if (v118 > DWORD1(v118))
          {
            sub_100044674("refcnt (%u) of dstream id object (id %llu) is greater than expected (%u)\n", v15, v16, v17, v18, v19, v20, v21, v118);
            sub_100048B34((char *)0x2A2, -2);
            uint64_t v38 = v119;
            uint64_t v39 = DWORD1(v118);
            unint64_t v40 = a3;
            uint64_t v41 = 1;
            uint64_t v42 = 9;
            uint64_t v43 = 0;
            goto LABEL_37;
          }
        }
LABEL_38:
        if ((void)v117) {
          BOOL v44 = (BYTE8(v118) & 0x80) == 0;
        }
        else {
          BOOL v44 = 1;
        }
        if (v44) {
          uint64_t v45 = *((void *)&v116 + 1);
        }
        else {
          uint64_t v45 = v117;
        }
        if ((BYTE8(v118) & 8) == 0 && *((void *)&v117 + 1) == v45)
        {
          if ((BYTE8(v118) & 0x10) == 0) {
            goto LABEL_75;
          }
LABEL_63:
          uint64_t v55 = v119;
          v128[0] = 0xAAAAAAAAAAAAAAAALL;
          unint64_t v125 = 0xAAAAAAAAAAAAAAAALL;
          unsigned __int16 v124 = -21846;
          unsigned int v123 = -1431655766;
          int v56 = malloc_type_calloc(1uLL, 0x340uLL, 0xB5B8BFCEuLL);
          uint64_t v57 = (unsigned __int16 *)malloc_type_calloc(1uLL, 0xEE0uLL, 0x4A28445BuLL);
          uint64_t v58 = malloc_type_calloc(1uLL, 8 * DWORD1(v118), 0x100004000313F17uLL);
          uint64_t v63 = sub_10003E25C((uint64_t)a1, (void *)a2, 3, v128, v59, v60, v61, v62);
          uint64_t v13 = v63;
          if (v56 && v57 && v58 && !v63)
          {
            uint64_t v71 = sub_100003AD8(v55, (uint64_t)v58, DWORD1(v118), &v123);
            if (v71)
            {
              uint64_t v13 = v71;
              sub_10004458C("unable to get the file ids of dstream_id %llu\n", v72, v73, v74, v75, v76, v77, v78, v55);
            }
            else
            {
              unsigned int v79 = v123;
              if (v123 > DWORD1(v118))
              {
                unsigned int v123 = DWORD1(v118);
                unsigned int v79 = DWORD1(v118);
              }
              if (v79)
              {
                uint64_t v110 = v12;
                uint64_t v80 = 0;
                while (1)
                {
                  *int v56 = v58[v80] & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
                  unsigned int v126 = 3808;
                  unsigned int v127 = 8;
                  uint64_t v81 = sub_1000380B0(v128[0], qword_100078BE0, 0, v56, &v127, 0x340u, v57, &v126);
                  if (v81)
                  {
LABEL_89:
                    uint64_t v13 = v81;
                    goto LABEL_70;
                  }
                  uint64_t v82 = sub_10003EE64(v57 + 46, v126 - 92, 8, &v125, &v124, 0, 0);
                  if (v82)
                  {
                    uint64_t v13 = v82;
                    goto LABEL_92;
                  }
                  if (v124 <= 0x27u) {
                    break;
                  }
                  uint64_t v90 = *(void *)(v125 + 8);
                  if (v90 != *((void *)&v116 + 1))
                  {
                    sub_10004458C("alloced_size (%llu) of dstream (id %llu, object-id %llu) does not match minimum found size (%llu)\n", v83, v84, v85, v86, v87, v88, v89, v90);
                    sub_100048B34((char *)0x2A0, 92);
                    v120[0] = 0;
                    long long v121 = 0u;
                    uint64_t v122 = 0;
                    v120[1] = *((void *)&v116 + 1);
                    uint64_t v81 = sub_10000D7AC(a3, 13, 1, *v56, v120, 40, v91, v92);
                    if (v81) {
                      goto LABEL_89;
                    }
                  }
                  if (++v80 >= (unint64_t)v123)
                  {
                    uint64_t v13 = 0;
                    goto LABEL_70;
                  }
                }
                uint64_t v13 = 34;
LABEL_92:
                uint64_t v93 = *v56 & 0xFFFFFFFFFFFFFFFLL;
                strerror(v13);
                sub_10004458C("failed to get inode (id %llu) dstream: %s\n", v94, v95, v96, v97, v98, v99, v100, v93);
                sub_100048B34((char *)0x380, v13);
                uint64_t v12 = v110;
              }
              else
              {
                uint64_t v13 = 0;
              }
            }
LABEL_71:
            free(v57);
          }
          else
          {
            sub_10004458C("unable to init fsroot tree for dstream repair\n", v64, v65, v66, v67, v68, v69, v70, v109);
            sub_100048B34((char *)0x355, v13);
LABEL_70:
            if (v57) {
              goto LABEL_71;
            }
          }
          if (v56) {
            free(v56);
          }
          if (v13) {
            break;
          }
          goto LABEL_75;
        }
        LOBYTE(v120[0]) = 0;
        uint64_t v46 = *(void *)(a2 + 48);
        if (!v46) {
          uint64_t v46 = *(void *)(a2 + 40);
        }
        if ((*(unsigned char *)(v46 + 56) & 0x20) != 0) {
          goto LABEL_55;
        }
        if ((WORD4(v118) & 0x120) == 0)
        {
          if (DWORD1(v118) != 1) {
            goto LABEL_55;
          }
          uint64_t v32 = sub_10003E760((uint64_t)a1, a2, qword_100078BE0, v116, v120);
          if (v32) {
            goto LABEL_93;
          }
          if (!LOBYTE(v120[0]))
          {
LABEL_55:
            if ((v12 & 0x20) != 0)
            {
              if (v115)
              {
                sub_10004458C("sealed volume hash records (id %llu, size %llu) do not match size of dstream (%llu)\n", v15, v16, v17, v18, v19, v20, v21, v119);
                long long v47 = sub_100048B34((char *)0x438, 92);
                if (a3) {
                  *(unsigned char *)(a2 + 13) = 1;
                }
                else {
                  sub_100027AD0((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54);
                }
              }
            }
            else
            {
              uint64_t v32 = sub_10000E5AC((uint64_t)a1, (void *)a2, a3, v119, (uint64_t)&v116, 1u);
              if (v32) {
                goto LABEL_93;
              }
            }
          }
        }
        if ((BYTE8(v118) & 0x10) != 0) {
          goto LABEL_63;
        }
LABEL_75:
        unsigned int v111 = 48;
        unsigned int v112 = 8;
        unsigned int v14 = sub_1000380B0((uint64_t)dword_100078BE8, 0, 2, &v119, &v112, 8u, &v116, &v111);
        if (v14) {
          goto LABEL_8;
        }
      }
    }
  }
LABEL_11:
  sub_10003A268((uint64_t)dword_100078BE8, 0);
  return v13;
}

uint64_t sub_10000E544(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    *(void *)&long long var8 = a5 & 0xFFFFFFFFFFFFFFFLL | 0x6000000000000000;
    return sub_100027E70(a1, 8u, a2, a3, a4, &var8, 8u, &v10, 4u);
  }
  else
  {
    return sub_100027AD0(0, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_10000E5AC(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  *(void *)&long long v107 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v107 + 1) = 0xAAAAAAAAAAAAAAAALL;
  memset(v106, 170, 24);
  if (*(_DWORD *)(a5 + 36)) {
    unint64_t v101 = *(void *)(a5 + 8);
  }
  else {
    unint64_t v101 = 0;
  }
  uint64_t v112 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v108[0] = v12;
  v108[1] = v12;
  long long v109 = v12;
  long long v110 = v12;
  unint64_t v111 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = malloc_type_calloc(1uLL, 0x340uLL, 0x5690539AuLL);
  unsigned int v14 = malloc_type_calloc(1uLL, 0xEE0uLL, 0xE27685BuLL);
  uint64_t v19 = sub_10003E25C(a1, a2, 8, &v112, v15, v16, v17, v18);
  uint64_t v27 = v19;
  if (!v13 || !v14 || v19)
  {
    sub_10004458C("unable to init fsroot tree for dstream repair\n", v20, v21, v22, v23, v24, v25, v26, v97);
    uint64_t v45 = 795;
LABEL_10:
    sub_100048B34((char *)v45, v27);
    goto LABEL_11;
  }
  uint64_t v100 = (uint64_t)a2;
  unint64_t v28 = a4 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000;
  *uint64_t v13 = v28;
  v13[1] = 0;
  uint64_t v29 = sub_10003889C((uint64_t)v108, v112, qword_100078BE0, v13, 0x10u, 0x340u, v14, 3808);
  if (!v29)
  {
    unsigned int v99 = a6;
    if (BYTE8(v109))
    {
      unint64_t v47 = 0;
      unint64_t v48 = v101;
LABEL_18:
      if (v48 != v47) {
        sub_10004458C("alloced_size (%llu) of dstream (id %llu) does not match calculated size (%llu)\n", v30, v31, v32, v33, v34, v35, v36, v48);
      }
      if (v48 < v47)
      {
        sub_100048B34((char *)0x3E3, 92);
        uint64_t v49 = *(void *)&v106[0];
        uint64_t v27 = sub_10000EE48((uint64_t)v106, v48 - *((void *)&v107 + 1), v50, v51, v52, v53, v54, v55);
        if (v27) {
          goto LABEL_11;
        }
        sub_10000ED10(a1, v100, a3, 1, 10, v99, (uint64_t *)&v107, (uint64_t)v106, v49 & 0xFFFFFFFFFFFFFFLL, (*(_WORD *)(a5 + 40) & 0x40) != 0);
        goto LABEL_30;
      }
      if (v48 <= v47)
      {
        uint64_t v27 = 0;
        goto LABEL_11;
      }
      if (v47) {
        uint64_t v57 = 997;
      }
      else {
        uint64_t v57 = 996;
      }
      sub_100048B34((char *)v57, 92);
      *(void *)&long long v105 = a4 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000;
      *((void *)&v105 + 1) = v47;
      memset(v104, 0, sizeof(v104));
      uint64_t v27 = sub_10000EE48((uint64_t)v104, v48 - v47, v58, v59, v60, v61, v62, v63);
      if (!v27)
      {
        sub_10000ED10(a1, v100, a3, 2, 0, v99, (uint64_t *)&v105, (uint64_t)v104, 0, 0);
LABEL_30:
        uint64_t v27 = v56;
      }
LABEL_11:
      if (!v14) {
        goto LABEL_13;
      }
      goto LABEL_12;
    }
    uint64_t v98 = 0;
    unint64_t v47 = 0;
    unint64_t v48 = v101;
    while (1)
    {
      if (*v13 != v28) {
        goto LABEL_18;
      }
      uint64_t v64 = a3;
      unint64_t v65 = v13[1];
      uint64_t v66 = *v14 & 0xFFFFFFFFFFFFFFLL;
      if (v66)
      {
        if (v65 > v47 && v65 < v48)
        {
          sub_10004458C("found file extent gap (id %llu) at logical address %llu (expected %llu)\n", v30, v31, v32, v33, v34, v35, v36, a4);
          sub_100048B34((char *)0x255, 92);
          uint64_t v69 = v13[1];
          *(void *)&long long v105 = *v13;
          *((void *)&v105 + 1) = v47;
          memset(v104, 0, sizeof(v104));
          uint64_t v76 = sub_10000EE48((uint64_t)v104, v69 - v47, v70, v71, v72, v73, v74, v75);
          if (v76)
          {
LABEL_67:
            uint64_t v27 = v76;
            goto LABEL_12;
          }
          sub_10000ED10(a1, v100, v64, 2, 0, v99, (uint64_t *)&v105, (uint64_t)v104, 0, 0);
          goto LABEL_58;
        }
        if (v65 >= v47 || v65 >= v48)
        {
          if (v65 < v48) {
            goto LABEL_59;
          }
          if (*(_DWORD *)(a5 + 36)) {
            sub_10004458C("found file extent (id %llu) at logical address %llu beyond the end of the dstream %llu\n", v30, v31, v32, v33, v34, v35, v36, a4);
          }
          else {
            sub_100044674("found orphan file extent (id %llu) at logical address %llu\n", v30, v31, v32, v33, v34, v35, v36, a4);
          }
          a3 = v64;
          sub_100048B34((char *)0x37F, 92);
          uint64_t v85 = a1;
          uint64_t v86 = v100;
        }
        else
        {
          sub_10004458C("found file extent overlap (id %llu) at logical address %llu (expected %llu)\n", v30, v31, v32, v33, v34, v35, v36, a4);
          sub_100048B34((char *)0x354, 92);
          long long v105 = *(_OWORD *)v13;
          memset(v104, 170, sizeof(v104));
          unsigned int v102 = 24;
          unsigned int v103 = 16;
          int v77 = sub_1000380B0(v112, qword_100078BE0, 2, &v105, &v103, 0x10u, v104, &v102);
          if (v77 || v103 != 16)
          {
            uint64_t v84 = *((void *)&v107 + 1);
LABEL_56:
            uint64_t v87 = *(void *)&v106[0];
            uint64_t v76 = sub_10000EE48((uint64_t)v106, v13[1] - v84, v78, v79, v80, v81, v82, v83);
            if (v76) {
              goto LABEL_67;
            }
            sub_10000ED10(a1, v100, v64, 1, 10, v99, (uint64_t *)&v107, (uint64_t)v106, v87 & 0xFFFFFFFFFFFFFFLL, (*(_WORD *)(a5 + 40) & 0x40) != 0);
LABEL_58:
            if (v76) {
              goto LABEL_67;
            }
LABEL_59:
            unint64_t v47 = v13[1] + v66;
            long long v107 = *(_OWORD *)v13;
            v106[0] = *(_OWORD *)v14;
            *(void *)&v106[1] = v14[2];
            uint64_t v98 = v66;
            a3 = v64;
            goto LABEL_64;
          }
          uint64_t v84 = *((void *)&v107 + 1);
          if ((void)v105 != *v13 || *((void *)&v105 + 1) - *((void *)&v107 + 1) != v98) {
            goto LABEL_56;
          }
          uint64_t v85 = a1;
          uint64_t v86 = v100;
          a3 = v64;
        }
        sub_10000ED10(v85, v86, v64, 0, 0, v99, v13, (uint64_t)v14, 0, 0);
      }
      else
      {
        sub_10004458C("invalid zero-length extent (id %llu) at logical address %llu\n", v30, v31, v32, v33, v34, v35, v36, a4);
        sub_100048B34((char *)0x31A, 92);
        a3 = v64;
        sub_10000ED10(a1, v100, v64, 0, 0, 1, v13, (uint64_t)v14, 0, 0);
      }
      if (v76) {
        goto LABEL_67;
      }
LABEL_64:
      uint64_t v88 = (*((uint64_t (**)(_OWORD *))&v108[0] + 1))(v108);
      if (v88)
      {
        uint64_t v27 = v88;
        char v89 = strerror(v88);
        sub_10004458C("error iterating fsroot tree during dstream repair: %s\n", v90, v91, v92, v93, v94, v95, v96, v89);
        uint64_t v45 = 796;
        goto LABEL_10;
      }
      unint64_t v48 = v101;
      if (BYTE8(v109)) {
        goto LABEL_18;
      }
    }
  }
  uint64_t v27 = v29;
  char v37 = strerror(v29);
  sub_10004458C("unable to init fsroot tree iterator for dstream repair: %s\n", v38, v39, v40, v41, v42, v43, v44, v37);
LABEL_12:
  free(v14);
LABEL_13:
  if (v13) {
    free(v13);
  }
  return v27;
}

char *sub_10000EB20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  LODWORD(v6) = *(_DWORD *)(a1 + 36);
  unsigned int v22 = v6;
  long long v7 = malloc_type_malloc(8 * (v6 + 1), 0x100004000313F17uLL);
  if (!v7) {
    return 0;
  }
  uint64_t v8 = v7;
  unsigned int v9 = *(_DWORD *)(a1 + 36);
  if (v9)
  {
    if (v9 == 1)
    {
      *long long v7 = *(void *)a1;
      goto LABEL_9;
    }
    if (!sub_100003AD8(a2, (uint64_t)v7, v9, &v22))
    {
      LODWORD(v6) = v22;
      unsigned int v9 = *(_DWORD *)(a1 + 36);
      goto LABEL_9;
    }
    free(v8);
    return 0;
  }
LABEL_9:
  if (v6 > v9)
  {
    unsigned int v22 = v9;
    LODWORD(v6) = v9;
  }
  *((void *)v8 + v6) = a3;
  if (v6)
  {
    uint64_t v11 = 0;
    int64_t v12 = 1;
    uint64_t v6 = v6;
    do
    {
      unint64_t v13 = *((void *)v8 + v11);
      int v14 = 1;
      if (v13 >= 0x3E8)
      {
        unint64_t v15 = *((void *)v8 + v11);
        do
        {
          unint64_t v13 = v15 / 0x3E8;
          v14 += 3;
          BOOL v16 = v15 > 0xF423F;
          v15 /= 0x3E8uLL;
        }
        while (v16);
      }
      if (v13 >= 0xA)
      {
        do
        {
          ++v14;
          BOOL v16 = v13 > 0x63;
          v13 /= 0xAuLL;
        }
        while (v16);
      }
      v12 += v14 + 1;
      ++v11;
    }
    while (v11 != v6);
    int v10 = (char *)malloc_type_malloc(v12, 0xACC812AuLL);
    if (v10)
    {
      int64_t v17 = 0;
      uint64_t v18 = (uint64_t *)v8;
      while (1)
      {
        uint64_t v19 = *v18++;
        unsigned int v20 = snprintf(&v10[v17], v12 - v17, "%llu ", v19);
        if ((v20 & 0x80000000) != 0) {
          break;
        }
        v17 += v20;
        if (v17 >= v12) {
          break;
        }
        if (!--v6) {
          goto LABEL_27;
        }
      }
      free(v10);
      int v10 = 0;
    }
  }
  else
  {
    int v10 = (char *)malloc_type_malloc(1uLL, 0xACC812AuLL);
  }
LABEL_27:
  free(v8);
  return v10;
}

void sub_10000ED10(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, unint64_t a9, char a10)
{
  if (a3)
  {
    int v13 = a5;
    int v14 = a4;
    if (!sub_100027E70(a3, 8u, a4, a5, a6, (long long *)a7, 0x10u, (unsigned char *)a8, 0x18u))
    {
      unint64_t v17 = *(void *)(a8 + 8);
      if (v17)
      {
        if (v14)
        {
          if (v14 == 1
            && v13 == 10
            && !sub_100021270(a2, v17, a9 / *(unsigned int *)(*(void *)(a1 + 8) + 36)))
          {
            sub_100020E6C(a2, *(void *)(a8 + 8), (*(void *)a8 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(a1 + 8) + 36), *a7 & 0xFFFFFFFFFFFFFFFLL, a10);
          }
        }
        else
        {
          sub_100009020(a7, a8);
          if (!v18) {
            sub_100021270(a2, *(void *)(a8 + 8), (*(void *)a8 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(a1 + 8) + 36));
          }
        }
      }
    }
  }
  else
  {
    sub_100027AD0(a1, a2, 0, a4, a5, a6, (uint64_t)a7, a8);
  }
}

uint64_t sub_10000EE48(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (HIBYTE(a2))
  {
    sub_10004458C("file extent length %llu does not fit inside %u bits, refusing to repair\n", a2, a3, a4, a5, a6, a7, a8, a2);
    uint64_t v8 = 92;
    sub_100048B34((char *)0x37E, 92);
  }
  else
  {
    uint64_t v8 = 0;
    *(void *)a1 = a2 | ((unint64_t)*(unsigned __int8 *)(a1 + 7) << 56);
  }
  return v8;
}

uint64_t sub_10000EEB0(uint64_t result)
{
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    if (result)
    {
      uint64_t v5 = result + 48 * v1;
      unint64_t v6 = *(void *)(v5 + 48);
      unint64_t v7 = *(void *)(v5 + 72);
      if (v6 > v7) {
        uint64_t v2 = v6 + v2 - v7;
      }
    }
    char v3 = 0;
    uint64_t v1 = 1;
  }
  while ((v4 & 1) != 0);
  byte_100078C60 = 0;
  qword_100078C70 = v2;
  return result;
}

uint64_t sub_10000EF04(uint64_t result)
{
  if (result) {
    uint64_t v1 = *(void *)(result + 88);
  }
  else {
    uint64_t v1 = 0;
  }
  byte_100078C60 = 1;
  qword_100078C70 = v1;
  return result;
}

uint64_t sub_10000EF2C(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (byte_100078C60 != 1 || a2 != 0)
  {
    uint64_t v9 = qword_100078C68 + result;
    qword_100078C68 += result;
    if (qword_100078C70)
    {
      unint64_t v10 = 100 * v9 / (unint64_t)qword_100078C70;
      if (dword_100078C78 < (int)v10 && (int)v10 <= 100)
      {
        uint64_t result = sub_100046EA8(qword_100091B70, 119, a3, a4, a5, a6, a7, a8, v10);
        dword_100078C78 = v10;
      }
    }
  }
  return result;
}

uint64_t sub_10000EFC4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = (uint64_t *)(a2 + 72);
  if (!a2) {
    unint64_t v10 = a1 + 4;
  }
  uint64_t v11 = *v10;
  int64_t v12 = (unint64_t *)(a2 + 104);
  int v13 = (unsigned int *)(a2 + 112);
  if (!a2)
  {
    int v13 = (unsigned int *)(a1 + 15);
    int64_t v12 = (unint64_t *)(a1 + 14);
  }
  unint64_t v14 = *v12;
  unsigned int v15 = *v13;
  uint64_t v16 = *(void *)(v11 + 8);
  unsigned int v17 = *(_DWORD *)(v11 + 32);
  if (v17 >= 0x40)
  {
    sub_100044674("omap (oid 0x%llx): invalid om_flags (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v11 + 8));
    sub_100048B34((char *)0x16C, -3);
    unsigned int v17 = *(_DWORD *)(v11 + 32);
  }
  if ((v17 & 1) != 0 && *(_DWORD *)(v11 + 36))
  {
    sub_10004458C("omap (oid 0x%llx): invalid om_snap_count (%u), given om_flags (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, v16);
    uint64_t v18 = 92;
    uint64_t v19 = 365;
LABEL_35:
    sub_100048B34((char *)v19, 92);
    return v18;
  }
  int v20 = *(_DWORD *)(v11 + 40);
  if ((unsigned __int16)v20 != 2
    || ((unsigned int v21 = v20 & 0xC0000000, (v20 & 0xC0000000) != 0x80000000) ? (v22 = v21 == 0) : (v22 = 1),
        !v22 ? (BOOL v23 = v21 == 0x40000000) : (BOOL v23 = 1),
        !v23))
  {
    sub_10004458C("omap (oid 0x%llx): invalid om_tree_type (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, v16);
    uint64_t v18 = 92;
    uint64_t v19 = 366;
    goto LABEL_35;
  }
  int v24 = *(_DWORD *)(v11 + 44);
  if ((unsigned __int16)v24 != 2
    || ((unsigned int v25 = v24 & 0xC0000000, (v24 & 0xC0000000) != 0x80000000) ? (v26 = v25 == 0) : (v26 = 1),
        !v26 ? (BOOL v27 = v25 == 0x40000000) : (BOOL v27 = 1),
        !v27))
  {
    sub_10004458C("omap (oid 0x%llx): invalid om_snapshot_tree_type (0x%x)\n", a2, a3, a4, a5, a6, a7, a8, v16);
    uint64_t v18 = 92;
    uint64_t v19 = 367;
    goto LABEL_35;
  }
  uint64_t v37 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v18 = sub_10002CD48(a1, a2, &v37);
  if (!v18)
  {
    uint64_t v18 = sub_100035168(v37, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10000F274, 0, 0, 1);
    if (!v18)
    {
      if (*(_DWORD *)(v11 + 32))
      {
        if (*(void *)(v11 + 56))
        {
          sub_10004458C("omap (oid 0x%llx): invalid om_snapshot_tree_oid (0x%llx), given om_flags (0x%x)\n", v28, v29, v30, v31, v32, v33, v34, v16);
          uint64_t v18 = 92;
          uint64_t v19 = 368;
          goto LABEL_35;
        }
        if (*(void *)(v11 + 64))
        {
          sub_10004458C("omap (oid 0x%llx): invalid om_most_recent_snap (0x%llx), given om_flags (0x%x)\n", v28, v29, v30, v31, v32, v33, v34, v16);
          uint64_t v18 = 92;
          uint64_t v19 = 369;
          goto LABEL_35;
        }
        if (*(void *)(v11 + 72))
        {
          sub_10004458C("omap (oid 0x%llx): invalid om_pending_revert_min (0x%llx), given om_flags (0x%x)\n", v28, v29, v30, v31, v32, v33, v34, v16);
          uint64_t v18 = 92;
          uint64_t v19 = 370;
          goto LABEL_35;
        }
        if (*(void *)(v11 + 80))
        {
          sub_10004458C("omap (oid 0x%llx): invalid om_pending_revert_max (0x%llx), given om_flags (0x%x)\n", v28, v29, v30, v31, v32, v33, v34, v16);
          uint64_t v18 = 92;
          uint64_t v19 = 371;
          goto LABEL_35;
        }
      }
      if (a2) {
        unint64_t v35 = *(void *)(*(void *)(a2 + 40) + 8);
      }
      else {
        unint64_t v35 = 0;
      }
      sub_100040DD0((uint64_t)a1, v14, v15 / *(_DWORD *)(a1[1] + 36), v35, 0x40000000, v16, 0, 0xBu, &_mh_execute_header, (unint64_t)&_mh_execute_header >> 32);
      return 0;
    }
  }
  return v18;
}

uint64_t sub_10000F274(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v9 = *(void *)(a1 + 8);
  if ((unint64_t)a3[1] > *(void *)(v9 + 16))
  {
    sub_10004458C("omap entry (oid 0x%llx): invalid ok_xid (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)a8, *a3);
    uint64_t v10 = 92;
    uint64_t v11 = 359;
LABEL_18:
    sub_100048B34((char *)v11, 92);
    return v10;
  }
  if (!a5) {
    return 0;
  }
  unsigned int v16 = *(_DWORD *)(v9 + 36);
  unsigned int v17 = *(_DWORD *)a5;
  if (*(_DWORD *)a5 >= 0x800u)
  {
    sub_100044674("omap entry (oid 0x%llx): invalid ov_flags (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)a8, *a3);
    sub_100048B34((char *)0x168, -3);
    unsigned int v17 = *(_DWORD *)a5;
  }
  unsigned int v18 = v17 >> 5;
  if (v18 >= 2)
  {
    sub_10004458C("omap entry (oid 0x%llx): invalid crypto key index (%u) given ov_flags (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)a8, *a3);
    uint64_t v10 = 92;
    uint64_t v11 = 1151;
    goto LABEL_18;
  }
  if (v18 != 1 || a2 && *(void *)(*(void *)(a2 + 40) + 1096))
  {
LABEL_13:
    if (((v17 >> 8) & 7) >= 2)
    {
      sub_10004458C("omap entry (oid 0x%llx): invalid tweak type (%u) given ov_flags (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)a8, *a3);
      uint64_t v10 = 92;
      uint64_t v11 = 1231;
      goto LABEL_18;
    }
    unsigned int v25 = *(_DWORD *)(a5 + 4);
    if (!v25 || (uint64_t v26 = v25 / v16, v25 % v16))
    {
      sub_10004458C("omap entry (oid 0x%llx): invalid ov_size (%u)\n", a2, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)a8, *a3);
      uint64_t v10 = 92;
      uint64_t v11 = 361;
      goto LABEL_18;
    }
    if ((v17 & 1) == 0)
    {
      unint64_t v27 = *(void *)(a5 + 8);
      if (!sub_1000102B0(a1, v27, v25 / v16))
      {
        sub_10004458C("omap entry (oid 0x%llx): invalid ov_paddr (%llu)\n", v28, v29, v30, v31, v32, v33, v34, *a3);
        uint64_t v10 = 92;
        uint64_t v11 = 362;
        goto LABEL_18;
      }
      if ((v17 & 0xE0) == 0x20) {
        unsigned int v35 = 36;
      }
      else {
        unsigned int v35 = 14;
      }
      if (a2) {
        unint64_t v36 = *(void *)(*(void *)(a2 + 40) + 8);
      }
      else {
        unint64_t v36 = 0;
      }
      BOOL v37 = a2 == 0;
      BOOL v38 = a2 != 0;
      if (v37) {
        unsigned int v39 = 13;
      }
      else {
        unsigned int v39 = 3;
      }
      if (v37) {
        unsigned int v35 = 0;
      }
      sub_100040DD0(a1, v27, v26, v36, 0, *a3, a3[1], v39, v35, 1u);
      int v40 = sub_10001F74C(v38, *a3, 0);
      if (v40)
      {
        int v48 = v40;
        sub_100044674("object (oid 0x%llx): Unable to mark omap entry for omap space verification \n", v41, v42, v43, v44, v45, v46, v47, *a3);
        sub_100048B34((char *)0x3D0, v48);
      }
    }
    return 0;
  }
  sub_10004458C("omap entry (oid 0x%llx): invalid crypto key index (%u) on %s\n", a2, (uint64_t)a3, a4, a5, a6, a7, (uint64_t)a8, *a3);
  uint64_t v10 = 92;
  sub_100048B34((char *)0x4B0, 92);
  if (sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) crypto key index? ", v19, v20, v21, v22, v23, v24, *a3))
  {
    *(_DWORD *)a5 &= 0xFFFFFF1F;
    *a8 = 1;
    unsigned int v17 = *(_DWORD *)a5;
    goto LABEL_13;
  }
  return v10;
}

uint64_t sub_10000F538(uint64_t *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int8x16_t a9, int8x16_t a10)
{
  uint64_t v13 = a2[9];
  uint64_t v14 = a2[13];
  uint64_t v15 = a2[14];
  uint64_t v16 = a2[15];
  unint64_t v41 = 0;
  if (!*(void *)(v13 + 56))
  {
    unint64_t v19 = 0;
    goto LABEL_5;
  }
  v40[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v17 = sub_10002CE38(a1, (uint64_t)a2, v40);
  if (v17) {
    return v17;
  }
  if (*(unsigned char *)(qword_100091B78 + 42)) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = sub_10000F754;
  }
  uint64_t v18 = sub_100035168(v40[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))v29, a3, &v41, 1);
  if (!v18)
  {
    unint64_t v19 = v41;
    if (HIDWORD(v41))
    {
      sub_10004458C("om: invalid om_snap_count (overflow)\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v39);
      uint64_t v18 = 92;
      uint64_t v30 = 375;
LABEL_28:
      int v37 = 92;
      goto LABEL_29;
    }
LABEL_5:
    uint64_t v20 = *(unsigned int *)(v13 + 36);
    unint64_t v21 = v19;
    if (v19 != v20)
    {
      sub_10004458C("om: om_snap_count (%u) is not equal to the number of snapshots found (%llu)\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(v13 + 36));
      if (!sub_10004641C(qword_100091B70, "Fix om_snap_count (oid 0x%llx)? ", v22, v23, v24, v25, v26, v27, *(void *)(v13 + 8)))
      {
        uint64_t v18 = 92;
        uint64_t v30 = 376;
        goto LABEL_28;
      }
      unint64_t v21 = v41;
      *(_DWORD *)(v13 + 36) = v41;
    }
    if (v21) {
      uint64_t v28 = *(void *)(a3 + 56);
    }
    else {
      uint64_t v28 = 0;
    }
    if (*(unsigned char *)(qword_100091B78 + 42) || *(void *)(v13 + 64) == v28)
    {
      if (v19 == v20) {
        return 0;
      }
    }
    else
    {
      sub_10004458C("om: om_most_recent_snap (%llu) is not equal to the largest snapshot xid (%llu)\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *(void *)(v13 + 64));
      if (!sub_10004641C(qword_100091B70, "Fix om_most_recent_snap (oid 0x%llx)? ", v31, v32, v33, v34, v35, v36, *(void *)(v13 + 8)))
      {
        uint64_t v18 = 92;
        uint64_t v30 = 671;
        goto LABEL_28;
      }
      *(void *)(v13 + 64) = v28;
    }
    v40[0] = v14;
    v40[1] = v15;
    int v40[2] = v16;
    uint64_t v18 = sub_100026BA0(a1, (uint64_t)a2, v13, (uint64_t)v40, a9, a10);
    if (!v18)
    {
      sub_100048AE4();
      return v18;
    }
    uint64_t v30 = 377;
    int v37 = v18;
LABEL_29:
    sub_100048B34((char *)v30, v37);
  }
  return v18;
}

uint64_t sub_10000F754(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = *(void *)(*(void *)(a2 + 40) + 1000);
  *(void *)&long long v14 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v14 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v148[2] = v14;
  v148[3] = v14;
  v148[0] = v14;
  v148[1] = v14;
  unsigned int v146 = 3808;
  unsigned int v147 = 832;
  unsigned int v15 = *(_DWORD *)a5;
  *(void *)(a7 + 56) = *a3;
  *(void *)(a2 + 56) = *a3;
  if (v15)
  {
    sub_100046EA8(qword_100091B70, 215, (uint64_t)a3, a4, a5, a6, a7, a8, v138);
  }
  else if ((v15 & 2) == 0)
  {
    unsigned int v16 = v15;
    if ((unint64_t)*a3 > *(void *)(a1[1] + 16)) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  sub_10001F70C(1);
  uint64_t v17 = *a3;
  if ((unint64_t)*a3 > *(void *)(a1[1] + 16))
  {
    if (v15)
    {
LABEL_9:
      sub_10004458C("omap snapshot: invalid key (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v17);
      uint64_t v20 = 92;
      sub_100048B34((char *)0x174, 92);
LABEL_10:
      BOOL v21 = 0;
LABEL_20:
      char v22 = (*(unsigned char *)(a2 + 14) != 0) & (v15 | v21);
      goto LABEL_21;
    }
LABEL_8:
    *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v163 + 15) = v18;
    v163[0] = v18;
    long long v162 = v18;
    long long v161 = v18;
    long long v160 = v18;
    long long v159 = v18;
    long long v158 = v18;
    long long v157 = v18;
    long long v156 = v18;
    long long v155 = v18;
    long long v154 = v18;
    long long v153 = v18;
    *(_OWORD *)&v152[49] = v18;
    *(_OWORD *)&v152[33] = v18;
    *(_OWORD *)&v152[17] = v18;
    *(_OWORD *)&v152[1] = v18;
    uint64_t v19 = *(void *)(a7 + 32) + 1;
    *(void *)(a7 + 32) = v19;
    v152[0] = 0;
    sub_100046EA8(qword_100091B70, 214, (uint64_t)a3, a4, a5, a6, a7, a8, v19);
    uint64_t v17 = *a3;
    goto LABEL_9;
  }
  unsigned int v16 = *(_DWORD *)a5;
LABEL_12:
  if (v16 >= 4)
  {
    sub_100044674("omap snapshot: invalid oms_flags (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v16);
    sub_100048B34((char *)0x175, -3);
  }
  if (*(_DWORD *)(a5 + 4))
  {
    sub_100044674("omap snapshot: invalid oms_pad (0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(_DWORD *)(a5 + 4));
    sub_100048B34((char *)0x176, -10);
  }
  if (*(void *)(a5 + 8))
  {
    sub_100044674("omap snapshot: oms_oid should be unused but has value (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a5 + 8));
    sub_100048B34((char *)0x312, -2);
  }
  if (v15)
  {
    BOOL v21 = 0;
    uint64_t v20 = 0;
    goto LABEL_20;
  }
  uint64_t v28 = *(void *)(a2 + 40);
  if (!v13 || ((*(unsigned char *)(v28 + 264) & 1) == 0 || *(void *)(v28 + 976)) && !*(void *)(a2 + 24)) {
    goto LABEL_46;
  }
  uint64_t v29 = *a3;
  int v151 = 0;
  memset(v152, 170, 24);
  uint64_t v30 = sub_1000257B4(a1, a2, 0, v13, v29, 0, 29, 0, (uint64_t **)&v151, (uint64_t)v152, 0);
  if (!v30)
  {
    BOOL v38 = v151;
    unsigned int v39 = *((_DWORD *)v151 + 8);
    if (v39 < 2)
    {
      if (v39)
      {
        if (*((void *)v151 + 5) == v29
          || (sub_100044674("snap_meta_ext: (0x%llx:0x%llx): invalid xid (0x%llx)\n", v31, v32, v33, v34, v35, v36, v37, v13), sub_100048B34((char *)0x35F, 92), !sub_10004641C(qword_100091B70, "Fix sme_snap_xid (xid 0x%llx)? ", v40, v41, v42, v43, v44, v45,
                               *((void *)v38 + 5))))
        {
          uint64_t v20 = 0;
        }
        else
        {
          *((void *)v38 + 5) = v29;
          uint64_t v20 = 1;
        }
        if (*((_DWORD *)v38 + 9))
        {
          sub_100044674("snap_meta_ext: (0x%llx:0x%llx): unknown flags (%u)\n", v31, v32, v33, v34, v35, v36, v37, v13);
          sub_100048B34((char *)0x360, -3);
        }
        if (uuid_is_null((const unsigned __int8 *)v38 + 48))
        {
          sub_100044674("snap_meta_ext: (0x%llx:0x%llx): sme_uuid is NULL\n", v120, v121, v122, v123, v124, v125, v126, v13);
          sub_100048B34((char *)0x361, 92);
        }
        if (v20)
        {
          long long v149 = *(_OWORD *)v152;
          uint64_t v150 = *(void *)&v152[16];
          uint64_t v20 = sub_100026BA0(a1, a2, (uint64_t)v151, (uint64_t)&v149, *(int8x16_t *)v152, v127);
          if (v20) {
            sub_100048B34((char *)0x362, v20);
          }
          else {
            sub_100048AE4();
          }
        }
        goto LABEL_42;
      }
    }
    else
    {
      sub_100044674("snap_meta_ext: (0x%llx:0x%llx): unknown version (%u)\n", v31, v32, v33, v34, v35, v36, v37, v13);
      sub_100048B34((char *)0x35E, -6);
    }
    goto LABEL_41;
  }
  uint64_t v20 = v30;
  if (v30 == 2)
  {
    sub_100044548("snap_meta_ext: object (oid 0x%llx): no record for snapshot (xid 0x%llx)\n", v31, v32, v33, v34, v35, v36, v37, v13);
LABEL_41:
    uint64_t v20 = 0;
  }
LABEL_42:
  if (v151) {
    free(v151);
  }
  if (v20) {
    goto LABEL_10;
  }
  uint64_t v28 = *(void *)(a2 + 40);
LABEL_46:
  unsigned int v46 = sub_100038040((uint64_t)v148, (uint64_t)a1, a2, *(_DWORD *)(v28 + 124) & 0xC0000000, (unsigned __int16)*(_DWORD *)(v28 + 124), 16, 0, *(_DWORD *)(a1[1] + 36), 0, 0, 0, *(void *)(v28 + 152), (uint64_t)sub_10003DD34);
  uint64_t v47 = malloc_type_calloc(1uLL, 0x340uLL, 0xE5A7BEAAuLL);
  int v48 = (int *)malloc_type_calloc(1uLL, 0xEE0uLL, 0x617EDB7uLL);
  uint64_t v55 = v48;
  if (v46 || !v47 || !v48)
  {
    *(void *)&long long v74 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v74 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v163 + 15) = v74;
    v163[0] = v74;
    long long v162 = v74;
    long long v161 = v74;
    long long v160 = v74;
    long long v159 = v74;
    long long v158 = v74;
    long long v157 = v74;
    long long v156 = v74;
    long long v155 = v74;
    long long v154 = v74;
    long long v153 = v74;
    *(_OWORD *)&v152[49] = v74;
    *(_OWORD *)&v152[33] = v74;
    *(_OWORD *)&v152[17] = v74;
    *(_OWORD *)&v152[1] = v74;
    uint64_t v75 = *(void *)(a7 + 32) + 1;
    *(void *)(a7 + 32) = v75;
    v152[0] = 0;
    sub_100046EA8(qword_100091B70, 214, v49, v50, v51, v52, v53, v54, v75);
    if (v46) {
      uint64_t v20 = v46;
    }
    else {
      uint64_t v20 = 12;
    }
    char v76 = strerror(v20);
    sub_10004458C("unable to init snap_meta tree for extentref_tree_oid lookup: %s\n", v77, v78, v79, v80, v81, v82, v83, v76);
    sub_100048B34((char *)0x2B0, v20);
    if (v55) {
      free(v55);
    }
    if (v47) {
      free(v47);
    }
    goto LABEL_10;
  }
  *uint64_t v47 = *a3 & 0xFFFFFFFFFFFFFFFLL | 0x1000000000000000;
  uint64_t v56 = sub_1000380B0((uint64_t)v148, 0, 0, v47, &v147, 0x340u, v48, &v146);
  if (v56)
  {
    uint64_t v20 = v56;
    *(void *)&long long v63 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v63 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)((char *)v163 + 15) = v63;
    v163[0] = v63;
    long long v162 = v63;
    long long v161 = v63;
    long long v160 = v63;
    long long v159 = v63;
    long long v158 = v63;
    long long v157 = v63;
    long long v156 = v63;
    long long v155 = v63;
    long long v154 = v63;
    long long v153 = v63;
    *(_OWORD *)&v152[49] = v63;
    *(_OWORD *)&v152[33] = v63;
    *(_OWORD *)&v152[17] = v63;
    *(_OWORD *)&v152[1] = v63;
    uint64_t v64 = *(void *)(a7 + 32) + 1;
    *(void *)(a7 + 32) = v64;
    v152[0] = 0;
    sub_100046EA8(qword_100091B70, 214, v57, v58, v59, v60, v61, v62, v64);
    uint64_t v65 = *a3;
    strerror(v20);
    sub_10004458C("Could not lookup cached extent_ref_tree information at snap xid (0x%llx): %s\n", v66, v67, v68, v69, v70, v71, v72, v65);
    sub_100048B34((char *)0x2B7, 92);
    BOOL v73 = 0;
    BOOL v21 = 0;
    goto LABEL_103;
  }
  uint64_t v145 = v47;
  *(void *)&long long v84 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v84 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)((char *)v163 + 15) = v84;
  v163[0] = v84;
  long long v162 = v84;
  long long v161 = v84;
  long long v160 = v84;
  long long v159 = v84;
  long long v158 = v84;
  long long v157 = v84;
  long long v156 = v84;
  long long v155 = v84;
  long long v154 = v84;
  long long v153 = v84;
  *(_OWORD *)&v152[49] = v84;
  *(_OWORD *)&v152[33] = v84;
  *(_OWORD *)&v152[17] = v84;
  *(_OWORD *)&v152[1] = v84;
  ++*(void *)(a7 + 32);
  v152[0] = 0;
  uint64_t v142 = (char *)v55 + 50;
  __strlcpy_chk();
  sub_100046EA8(qword_100091B70, 214, v85, v86, v87, v88, v89, v90, *(void *)(a7 + 32));
  int v141 = v55[10];
  uint64_t v92 = *(void *)v55;
  uint64_t v91 = *((void *)v55 + 1);
  uint64_t v144 = v55;
  BOOL v21 = *(void *)v55 == 0;
  uint64_t v93 = a2 + 48;
  uint64_t v94 = sub_1000257B4(a1, 0, 0x40000000, v91, 0, 0, 13, 0, (uint64_t **)(a2 + 48), 0, 0);
  if (v94)
  {
    uint64_t v20 = v94;
    BOOL v73 = 0;
    uint64_t v55 = v144;
    uint64_t v47 = v145;
    goto LABEL_103;
  }
  uint64_t v140 = v92;
  uint64_t v101 = *(void *)v93;
  if (!*(void *)v93) {
    uint64_t v101 = *(void *)(a2 + 40);
  }
  uint64_t v47 = v145;
  uint64_t v102 = (uint64_t)v142;
  if ((*(unsigned char *)(v101 + 56) & 0x20) != 0)
  {
    uint64_t v128 = *a3;
    if (*(void *)(*(void *)v93 + 1024))
    {
      uint64_t v20 = sub_10004AF1C(a1, a2, v128);
      uint64_t v102 = (uint64_t)v142;
      if (!v20) {
        goto LABEL_63;
      }
    }
    else
    {
      sub_10004458C("Snapshot (0x%llx): apfs_integrity_meta_oid is invalid\n", v95, v128, v96, v97, v98, v99, v100, *a3);
      uint64_t v20 = 92;
      sub_100048B34((char *)0x387, 92);
    }
    BOOL v73 = 0;
    uint64_t v55 = v144;
    goto LABEL_103;
  }
LABEL_63:
  uint64_t v139 = (uint64_t *)(a2 + 48);
  uint64_t v55 = v144;
  BOOL v143 = sub_100006948(v102, *((unsigned __int16 *)v144 + 24));
  if (v140 && !v143)
  {
    if (*(unsigned char *)(a2 + 9)) {
      goto LABEL_69;
    }
    uint64_t v103 = *v139;
    if (!*v139) {
      uint64_t v103 = *(void *)(a2 + 40);
    }
    if ((*(unsigned char *)(v103 + 56) & 0x20) != 0) {
LABEL_69:
    }
      sub_100020D04((char *)a2);
  }
  if (*(unsigned char *)(a2 + 9))
  {
    *(void *)&long long v104 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v104 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v152[32] = v104;
    *(_OWORD *)&v152[48] = v104;
    *(_OWORD *)BOOL v152 = v104;
    *(_OWORD *)&v152[16] = v104;
    sub_100015870(0, *a3);
    sub_1000070EC((uint64_t)a1, a2, *a3);
    uint64_t v20 = sub_100007840(a1, (int8x16_t *)a2, *a3);
    if (v20) {
      goto LABEL_102;
    }
    sub_100010338((uint64_t)v152, (uint64_t)a1, a2, *(_DWORD *)(*(void *)(a2 + 40) + 116), 14, *(void *)(*(void *)(a2 + 48) + 136));
    uint64_t v20 = sub_100035168((uint64_t)v152, *a3, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, a7, 0, 0);
    if (v20) {
      goto LABEL_102;
    }
    if (*(void *)(*(void *)(a2 + 40) + 1096))
    {
      uint64_t v20 = sub_100015910((uint64_t)a1, a2, 0, v105, v106, v107, v108, v109);
      if (v20) {
        goto LABEL_102;
      }
      sub_100010338((uint64_t)v152, (uint64_t)a1, a2, *(_DWORD *)(*(void *)(a2 + 40) + 1104), 36, *(void *)(*(void *)(a2 + 48) + 1096));
      uint64_t v20 = sub_100035168((uint64_t)v152, *a3, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, a7, 0, 0);
      if (v20) {
        goto LABEL_102;
      }
    }
    uint64_t v20 = sub_10002E2D8((uint64_t)a1, a2);
    if (v20) {
      goto LABEL_102;
    }
    uint64_t v20 = sub_100015964(a1, (void *)a2, *a3, 0, v110, v111, v112, v113);
    if (v20) {
      goto LABEL_102;
    }
    uint64_t v20 = sub_100007690((uint64_t)a1, a2, *a3);
    if (v20) {
      goto LABEL_102;
    }
  }
  uint64_t v114 = *v139;
  uint64_t v115 = *v139;
  if (!*v139) {
    uint64_t v115 = *(void *)(a2 + 40);
  }
  if ((*(unsigned char *)(v115 + 56) & 0x20) != 0)
  {
    *(void *)&long long v116 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v116 + 1) = 0xAAAAAAAAAAAAAAAALL;
    *(_OWORD *)&v152[32] = v116;
    *(_OWORD *)&v152[48] = v116;
    *(_OWORD *)BOOL v152 = v116;
    *(_OWORD *)&v152[16] = v116;
    sub_1000103C8((uint64_t)v152, (uint64_t)a1, a2, *(_DWORD *)(*(void *)(a2 + 40) + 1040), *(void *)(v114 + 1032));
    uint64_t v117 = sub_100035168((uint64_t)v152, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001578C, a7, 0, 1);
    if (v117)
    {
LABEL_101:
      uint64_t v20 = v117;
      goto LABEL_102;
    }
  }
  if (!v140) {
    goto LABEL_100;
  }
  *(void *)&long long v118 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v118 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v152[32] = v118;
  *(_OWORD *)&v152[48] = v118;
  *(_OWORD *)BOOL v152 = v118;
  *(_OWORD *)&v152[16] = v118;
  sub_100010424((uint64_t)v152, (uint64_t)a1, a2, v141, v140);
  uint64_t v119 = sub_100035168((uint64_t)v152, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, a7, 0, 1);
  if (!v119)
  {
LABEL_100:
    uint64_t v117 = sub_100021D5C(a2, *a3);
    if (!v117)
    {
      uint64_t v129 = *(void *)(a2 + 40);
      if ((*(unsigned char *)(v129 + 56) & 0x40) != 0)
      {
        *(void *)&long long v130 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v130 + 1) = 0xAAAAAAAAAAAAAAAALL;
        *(_OWORD *)&v152[32] = v130;
        *(_OWORD *)&v152[48] = v130;
        *(_OWORD *)BOOL v152 = v130;
        *(_OWORD *)&v152[16] = v130;
        sub_10001047C((uint64_t)v152, (uint64_t)a1, a2, *(_DWORD *)(v129 + 1044), *(void *)(*(void *)(a2 + 48) + 1048));
        unsigned int v131 = sub_100035168((uint64_t)v152, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100033C4C, a7, 0, 1);
        unsigned int v137 = sub_100033AFC((uint64_t)a1, a2, 0, v132, v133, v134, v135, v136);
        if (v131) {
          uint64_t v20 = v131;
        }
        else {
          uint64_t v20 = v137;
        }
      }
      else
      {
        uint64_t v20 = 0;
      }
      goto LABEL_102;
    }
    goto LABEL_101;
  }
  uint64_t v20 = v119;
  BOOL v21 = 0;
LABEL_102:
  BOOL v73 = v143;
LABEL_103:
  free(v55);
  free(v47);
  if (!v73) {
    goto LABEL_20;
  }
  char v22 = 1;
LABEL_21:
  sub_10002C8E8(a2, v22);
  if (v20 == 92)
  {
    sub_10001F70C(1);
    sub_1000158D0(a2);
    sub_100007230();
    uint64_t v20 = 0;
    *(unsigned char *)(a2 + 11) = 1;
    *(unsigned char *)(a2 + 13) = 1;
  }
  uint64_t v23 = 0;
  char v24 = 1;
  do
  {
    char v25 = v24;
    uint64_t v26 = *(void *)(a2 + 8 * v23 + 24);
    if (v26) {
      sub_10001E424(v26);
    }
    char v24 = 0;
    uint64_t v23 = 1;
  }
  while ((v25 & 1) != 0);
  sub_10001E424(*a1);
  return v20;
}

BOOL sub_1000102B0(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    unint64_t v5 = *(void *)(v4 + 48);
    unint64_t v6 = *(void *)(v4 + 96);
  }
  else
  {
    unint64_t v5 = *(void *)(v3 + 40);
    if (*(unsigned char *)(v3 + 65)) {
      unint64_t v6 = *(void *)(v3 + 40);
    }
    else {
      unint64_t v6 = 0;
    }
  }
  unint64_t v7 = *(unsigned int *)(v3 + 36);
  if (a2)
  {
    BOOL v8 = v5 > a3 && v5 > a2;
    if (v8 && v5 - a3 >= a2) {
      return 1;
    }
  }
  unint64_t v10 = 0x4000000000000000uLL >> __clz(__rbit64(v7));
  if (v10 < a2 && ((v11 = v6 | v10, BOOL v8 = v6 > a3, v12 = v6 - a3, v8) ? (v13 = v11 > a2) : (v13 = 0), v13)) {
    return (v12 | v10) >= a2;
  }
  else {
    return 0;
  }
}

uint64_t sub_100010338(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a3 + 48);
  uint64_t v7 = v6;
  if (!v6) {
    uint64_t v7 = *(void *)(a3 + 40);
  }
  if ((*(unsigned char *)(v7 + 56) & 0x20) != 0) {
    int v8 = *(_DWORD *)(a3 + 16);
  }
  else {
    int v8 = 0;
  }
  if (!v6) {
    uint64_t v6 = *(void *)(a3 + 40);
  }
  if ((*(unsigned char *)(v6 + 56) & 0x20) != 0) {
    int v9 = *(_DWORD *)(a3 + 20);
  }
  else {
    int v9 = 0;
  }
  return sub_100038040(a1, a2, a3, a4 & 0xC0000000, (unsigned __int16)a4, a5, v8, *(_DWORD *)(*(void *)(a2 + 8) + 36), 0, 0, v9, a6, (uint64_t)sub_10003DD34);
}

uint64_t sub_1000103C8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100038040(a1, a2, a3, a4 & 0xC0000000, (unsigned __int16)a4, 31, 0, *(_DWORD *)(*(void *)(a2 + 8) + 36), 16, 16, 0, a5, (uint64_t)sub_10003DCD8);
}

uint64_t sub_100010424(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100038040(a1, a2, a3, a4 & 0xC0000000, (unsigned __int16)a4, 15, 0, *(_DWORD *)(*(void *)(a2 + 8) + 36), 0, 0, 0, a5, (uint64_t)sub_10003DD34);
}

uint64_t sub_10001047C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  return sub_100038040(a1, a2, a3, a4 & 0xC0000000, (unsigned __int16)a4, 32, 0, *(_DWORD *)(*(void *)(a2 + 8) + 36), 8, 24, 0, a5, (uint64_t)sub_1000306FC);
}

uint64_t sub_1000104DC()
{
  v1.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v1.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  clock_gettime(_CLOCK_REALTIME, &v1);
  return sub_100010514(&v1.tv_sec);
}

uint64_t sub_100010514(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v3 = v2 / 1000000000;
  uint64_t v4 = v2 % 1000000000;
  if (*a1 < 0 && v2 >= 1)
  {
    uint64_t v5 = v3 + 1;
    v4 -= 1000000000;
  }
  else
  {
    BOOL v6 = v2 >= 0;
    if (v2 < 0) {
      uint64_t v5 = v3 - 1;
    }
    else {
      uint64_t v5 = v2 / 1000000000;
    }
    if (v6) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = v4 + 1000000000;
    }
    if (v1 >= 1) {
      uint64_t v4 = v7;
    }
    else {
      uint64_t v5 = v3;
    }
  }
  uint64_t v8 = v1 + v5;
  if (__OFADD__(v1, v5)
    || (uint64_t v9 = 1000000000 * v8, (unsigned __int128)(v8 * (__int128)1000000000) >> 64 != (1000000000 * v8) >> 63)
    || (uint64_t result = v4 + v9, __OFADD__(v4, v9)))
  {
    if (v1 > 0) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      return 0x8000000000000000;
    }
  }
  return result;
}

BOOL sub_1000105B0(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return *(void *)(*(void *)(a1 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", a3, a4, a5, a6, a7, a8, a2 & ~(_BYTE)a3) != 0;
}

uint64_t sub_10001061C(uint64_t a1, uint64_t *a2, int a3, unint64_t *a4, int a5, int a6, _DWORD *a7)
{
  *a7 = 0;
  if ((a3 - 267) <= 0xFFFFFEFE)
  {
    if (a6)
    {
      char v9 = sub_10003D8BC((unint64_t)*a2 >> 60);
      sub_10004458C("%s (id %llu): invalid key length (%u)\n", v10, v11, v12, v13, v14, v15, v16, v9);
      uint64_t v17 = 330;
LABEL_37:
      uint64_t v61 = 92;
      sub_100048B34((char *)v17, 92);
      return v61;
    }
    return 92;
  }
  unint64_t v18 = *a2;
  if ((~*a2 & 0xFFFFFFFFFFFFFFFLL) != 0)
  {
    if (a6)
    {
      char v62 = sub_10003D8BC(v18 >> 60);
      sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v63, v64, v65, v66, v67, v68, v69, v62);
      uint64_t v17 = 331;
      goto LABEL_37;
    }
    return 92;
  }
  CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  if (v23 + 10 != a3 && a6 != 0)
  {
    char v25 = sub_10003D8BC(v18 >> 60);
    sub_100044674("%s (id %llu): invalid name_len (%u), given key length (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
    sub_100048B34((char *)0x14D, -9);
    *a7 |= 2u;
    CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  }
  if ((unsigned __int16)(v23 - 257) <= 0xFF00u && a6 != 0)
  {
    char v34 = sub_10003D8BC((unint64_t)*a2 >> 60);
    sub_100044674("%s (id %llu): invalid name_len (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    *a7 |= 2u;
    sub_100048B34((char *)0x14C, -9);
    CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  }
  if (*((unsigned char *)a2 + v23 + 9)) {
    BOOL v42 = a6 == 0;
  }
  else {
    BOOL v42 = 1;
  }
  if (!v42)
  {
    char v43 = sub_10003D8BC((unint64_t)*a2 >> 60);
    sub_10004458C("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v44, v45, v46, v47, v48, v49, v50, v43);
    *a7 |= 1u;
    sub_100048B34((char *)0x14E, -9);
    CFIndex v23 = *((unsigned __int16 *)a2 + 4);
  }
  if (sub_100010914((UInt8 *)a2 + 10, v23) && a6)
  {
    char v51 = sub_10003D8BC((unint64_t)*a2 >> 60);
    sub_100044674("%s (id %llu): invalid name (%.*s)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    *a7 |= 1u;
    sub_100048B34((char *)0x14F, -9);
  }
  if (a5 != 8)
  {
    if (a6)
    {
      char v70 = sub_10003D8BC((unint64_t)*a2 >> 60);
      sub_10004458C("%s (id %llu): invalid value length (%u)\n", v71, v72, v73, v74, v75, v76, v77, v70);
      uint64_t v17 = 336;
      goto LABEL_37;
    }
    return 92;
  }
  unint64_t v59 = *a4;
  if (!*a4)
  {
    if (!a6) {
      return 92;
    }
LABEL_36:
    char v78 = sub_10003D8BC((unint64_t)*a2 >> 60);
    sub_10004458C("%s (id %llu): invalid snap_xid (%llu)\n", v79, v80, v81, v82, v83, v84, v85, v78);
    uint64_t v17 = 337;
    goto LABEL_37;
  }
  unint64_t v60 = *(void *)(*(void *)(a1 + 40) + 16);
  if (v59 <= v60) {
    uint64_t v61 = 0;
  }
  else {
    uint64_t v61 = 92;
  }
  if (v59 > v60 && (a6 & 1) != 0) {
    goto LABEL_36;
  }
  return v61;
}

uint64_t sub_100010914(UInt8 *bytes, CFIndex numBytes)
{
  CFStringRef v2 = CFStringCreateWithBytesNoCopy(kCFAllocatorDefault, bytes, numBytes, 0x8000100u, 0, kCFAllocatorNull);
  if (v2)
  {
    CFRelease(v2);
    return 0;
  }
  else
  {
    uint64_t v3 = 92;
    sub_100048B34((char *)0xB7, 92);
  }
  return v3;
}

#error "100010B38: switch analysis failed: switch information is incomplete or incorrect (funcsize=114)"

uint64_t sub_100010B64(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v13 = *a3;
  if (a4 != 8)
  {
    char v23 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    uint64_t v22 = 313;
    goto LABEL_6;
  }
  if ((v13 & 0xFFFFFFFFFFFFFFFLL) == 0 || (v13 & 0xFFFFFFFFFFFFFFFLL) > *(void *)(*(void *)(a2 + 40) + 16))
  {
    char v14 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 314;
    goto LABEL_6;
  }
  if ((a6 - 307) <= 0xFFFFFEFE)
  {
    char v36 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v37, v38, v39, v40, v41, v42, v43, v36);
    uint64_t v22 = 315;
    goto LABEL_6;
  }
  if (!*(void *)(a5 + 8))
  {
    char v53 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid sblock_oid (%llu)\n", v54, v55, v56, v57, v58, v59, v60, v53);
    uint64_t v22 = 317;
    goto LABEL_6;
  }
  unint64_t v44 = *(void *)(a5 + 32);
  if (v44 <= 1)
  {
    char v45 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid inum (%llu)\n", v46, v47, v48, v49, v50, v51, v52, v45);
    uint64_t v22 = 320;
    goto LABEL_6;
  }
  if (v44 <= 0xF && (v44 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v64 = sub_10003D8BC(v13 >> 60);
    sub_100044674("%s (id %llu): invalid inum (%llu)\n", v65, v66, v67, v68, v69, v70, v71, v64);
    sub_100048B34((char *)0x141, -2);
    unint64_t v44 = *(void *)(a5 + 32);
  }
  if (*(void *)(a7 + 40) < v44 + 1) {
    *(void *)(a7 + 40) = v44 + 1;
  }
  if (!*(_WORD *)(a5 + 40))
  {
    char v88 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid extentref_tree_type (0x%x)\n", v89, v90, v91, v92, v93, v94, v95, v88);
    uint64_t v22 = 322;
    goto LABEL_6;
  }
  if (*(_DWORD *)(a5 + 44) >= 4u)
  {
    char v72 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_100044674("%s (id %llu): unknown flags (0x%x)\n", v73, v74, v75, v76, v77, v78, v79, v72);
    if (*(void *)(*(void *)(a1 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", v80, v81, v82, v83, v84, v85, *(unsigned char *)(a5 + 44) & 0xFC))
    {
      *(_DWORD *)(a5 + 44) &= 3u;
      *a8 = 1;
    }
    sub_100048B34((char *)0x143, -3);
  }
  CFIndex v86 = *(unsigned __int16 *)(a5 + 48);
  if (v86 + 50 == a6)
  {
    int v87 = 0;
  }
  else
  {
    char v96 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_100044674("%s (id %llu): invalid name_len (%u), given value length (%u)\n", v97, v98, v99, v100, v101, v102, v103, v96);
    sub_100048B34((char *)0x145, 92);
    CFIndex v86 = *(unsigned __int16 *)(a5 + 48);
    int v87 = 2 * (v86 + 50 > (unint64_t)a6);
  }
  if ((unsigned __int16)(v86 - 257) <= 0xFF00u)
  {
    char v104 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid name_len (%u)\n", v105, v106, v107, v108, v109, v110, v111, v104);
    sub_100048B34((char *)0x144, 92);
    CFIndex v86 = *(unsigned __int16 *)(a5 + 48);
    int v87 = 2;
  }
  if (*(unsigned char *)(a5 + 50 + v86 - 1))
  {
    char v112 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_100044674("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v113, v114, v115, v116, v117, v118, v119, v112);
    v87 |= 1u;
    sub_100048B34((char *)0x146, -9);
    CFIndex v86 = *(unsigned __int16 *)(a5 + 48);
  }
  if (sub_100010914((UInt8 *)(a5 + 50), v86))
  {
    char v120 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_100044674("%s (id %llu): invalid name (%.*s)\n", v121, v122, v123, v124, v125, v126, v127, v120);
    LOBYTE(v87) = v87 | 1;
    sub_100048B34((char *)0x147, -9);
  }
  else if (!v87)
  {
LABEL_42:
    uint64_t v31 = sub_10002BA78(a3, a5);
    if (v31) {
      goto LABEL_7;
    }
    ++*(void *)(a7 + 32);
    unint64_t v128 = *(void *)(a5 + 8);
    BOOL v129 = sub_1000102B0(a1, v128, 1uLL);
    unint64_t v130 = *a3;
    if (v129)
    {
      sub_100040DD0(a1, v128, 1, 0, 0x40000000, v128, v130 & 0xFFFFFFFFFFFFFFFLL, 0xDu, &_mh_execute_header, (unint64_t)&_mh_execute_header >> 32);
      return 0;
    }
    char v131 = sub_10003D8BC(v130 >> 60);
    sub_10004458C("%s (id %llu): invalid sblock_oid (%llu)\n", v132, v133, v134, v135, v136, v137, v138, v131);
    uint64_t v22 = 1244;
LABEL_6:
    uint64_t v31 = 92;
    sub_100048B34((char *)v22, 92);
LABEL_7:
    sub_100044868(a2, (uint64_t)a3, a4, a5, a6, v32, v33, v34, v139);
    return v31;
  }
  if (a6 == 50) {
    uint64_t v31 = 92;
  }
  else {
    uint64_t v31 = sub_10002B478(a1, a2, a3, a5, a6, v87, a8);
  }
  if ((v87 & 2) == 0 || !v31) {
    goto LABEL_42;
  }
  return v31;
}

uint64_t sub_100011088(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v12 = *a3;
  if (a4 != 8)
  {
    char v21 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v22, v23, v24, v25, v26, v27, v28, v21);
    sub_100044868(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v29, v30, v31, v107);
    uint64_t v32 = 92;
    uint64_t v33 = 205;
LABEL_7:
    int v45 = 92;
    goto LABEL_8;
  }
  if (a6 != 20)
  {
    char v34 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    sub_100044868(a2, (uint64_t)a3, 8, (uint64_t)a5, a6, v42, v43, v44, v108);
    uint64_t v32 = 92;
    uint64_t v33 = 206;
    goto LABEL_7;
  }
  unint64_t v14 = v12 & 0xFFFFFFFFFFFFFFFLL;
  unint64_t v15 = *a5 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v16 = *(void *)(a1 + 8);
  uint64_t v17 = *(void *)(a1 + 24);
  if (v17)
  {
    unint64_t v18 = *(void *)(v17 + 48);
    unint64_t v19 = *(void *)(v17 + 96);
  }
  else
  {
    unint64_t v18 = *(void *)(v16 + 40);
    if (*(unsigned char *)(v16 + 65)) {
      unint64_t v19 = *(void *)(v16 + 40);
    }
    else {
      unint64_t v19 = 0;
    }
  }
  unint64_t v47 = *(unsigned int *)(v16 + 36);
  uint64_t v48 = *a5 >> 60;
  if (!v14 || (v18 > v15 ? (v49 = v18 > v14) : (v49 = 0), v49 ? (BOOL v50 = v18 - v15 >= v14) : (BOOL v50 = 0), !v50))
  {
    unint64_t v51 = 0x4000000000000000uLL >> __clz(__rbit64(v47));
    BOOL v52 = v51 < v14 && v19 > v15;
    BOOL v53 = v52 && (v19 | v51) > v14;
    if (!v53 || ((v19 - v15) | v51) < v14)
    {
      char v54 = sub_10003D8BC(v12 >> 60);
      sub_10004458C("%s (id %llu): Bad phys_block_num + len (%llu) for physical extent record\n", v55, v56, v57, v58, v59, v60, v61, v54);
      sub_100048B34((char *)0x467, 92);
      uint64_t v62 = 1;
      if (v15) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
  }
  uint64_t v62 = 0;
  if (!v15)
  {
LABEL_29:
    char v63 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): length is 0\n", v64, v65, v66, v67, v68, v69, v70, v63);
    sub_100048B34((char *)0xCF, 92);
    uint64_t v62 = 1;
  }
LABEL_30:
  if ((v48 - 3) <= 0xFFFFFFFD)
  {
    char v71 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): unknown kind (%u)\n", v72, v73, v74, v75, v76, v77, v78, v71);
    sub_100048B34((char *)0x33A, 92);
    uint64_t v62 = v62 | 2;
  }
  unint64_t v79 = a5[1];
  if (!v79)
  {
    char v90 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): owning_obj_id is 0\n", v91, v92, v93, v94, v95, v96, v97, v90);
    sub_100048B34((char *)0xD0, 92);
    uint64_t v62 = v62 | 4;
LABEL_42:
    sub_100044868(a2, (uint64_t)a3, 8, (uint64_t)a5, 20, a6, a7, a8, v106);
    goto LABEL_43;
  }
  if (v48 == 2 && v79 != -1)
  {
    char v80 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid owning_obj_id (%llu) for update extent\n", v81, v82, v83, v84, v85, v86, v87, v80);
    uint64_t v88 = 1230;
    int v89 = 92;
LABEL_40:
    sub_100048B34((char *)v88, v89);
    goto LABEL_41;
  }
  if (v48 == 1 && v79 >= 0xFFFFFFFFFFFFFFFELL)
  {
    char v98 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_100044674("%s (id %llu): owning_obj_id is '%s'\n", v99, v100, v101, v102, v103, v104, v105, v98);
    uint64_t v88 = 988;
    int v89 = -2;
    goto LABEL_40;
  }
LABEL_41:
  if (v62) {
    goto LABEL_42;
  }
LABEL_43:
  uint64_t v32 = sub_1000215F8(a1, a2, a3, (uint64_t)a5, v62, a6, a7, a8);
  if (!v32) {
    return v32;
  }
  uint64_t v33 = 827;
  int v45 = v32;
LABEL_8:
  sub_100048B34((char *)v33, v45);
  return v32;
}

uint64_t sub_1000113FC(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, _DWORD *a8)
{
  unint64_t v13 = *a3;
  if (a4 != 8)
  {
    char v25 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v23 = 92;
    uint64_t v24 = 218;
    goto LABEL_5;
  }
  unint64_t v14 = (char *)(v13 & 0xFFFFFFFFFFFFFFFLL);
  if ((v13 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v15 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v16, v17, v18, v19, v20, v21, v22, v15);
    uint64_t v23 = 92;
    uint64_t v24 = 219;
LABEL_5:
    int v33 = 92;
LABEL_6:
    sub_100048B34((char *)v24, v33);
LABEL_7:
    sub_100044868(a2, (uint64_t)a3, a4, a5, a6, v34, v35, v36, v323);
    return v23;
  }
  unint64_t v41 = (unint64_t)(v14 - 4);
  if ((unint64_t)v14 <= 0xF && (unint64_t)(v14 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v43 = sub_10003D8BC(v13 >> 60);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v44, v45, v46, v47, v48, v49, v50, v43);
    sub_100048B34((char *)0xDC, -2);
  }
  if (a7[5] <= (unint64_t)v14) {
    a7[5] = v14 + 1;
  }
  if (a6 <= 0x5B)
  {
    char v51 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    uint64_t v23 = 92;
    uint64_t v24 = 221;
    goto LABEL_5;
  }
  unsigned int v59 = *(unsigned __int16 *)(a5 + 80) >> 12;
  if (v59 <= 0xE)
  {
    int v60 = 1 << v59;
    if ((v60 & 0x1556) != 0) {
      goto LABEL_20;
    }
    if ((v60 & 0x4001) != 0)
    {
      char v95 = sub_10003D8BC(*a3 >> 60);
      sub_10004458C("%s (id %llu): invalid type (0%o)\n", v96, v97, v98, v99, v100, v101, v102, v95);
      uint64_t v23 = 92;
      uint64_t v24 = 222;
      goto LABEL_5;
    }
  }
  char v160 = sub_10003D8BC(*a3 >> 60);
  sub_100044674("%s (id %llu): invalid type (0%o)\n", v161, v162, v163, v164, v165, v166, v167, v160);
  sub_100048B34((char *)0xDF, -5);
LABEL_20:
  if (!*(void *)a5)
  {
    char v87 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid parent_id (%llu)\n", v88, v89, v90, v91, v92, v93, v94, v87);
    uint64_t v23 = 92;
    uint64_t v24 = 224;
    goto LABEL_5;
  }
  if ((unint64_t)(*(void *)a5 - 16) >= 0xFFFFFFFFFFFFFFF4)
  {
    char v61 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid parent_id (%llu)\n", v62, v63, v64, v65, v66, v67, v68, v61);
    sub_100048B34((char *)0xE1, -2);
  }
  if (v41 <= 0xFFFFFFFFFFFFFFFDLL && *(void *)a5 == 1)
  {
    char v69 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid parent_id (%llu) for regular directory\n", v70, v71, v72, v73, v74, v75, v76, v69);
    sub_100048B34((char *)0xE2, 92);
    v332 = (const char *)0xAAAAAAAAAAAAAAAALL;
    unsigned __int16 v331 = -21846;
    int v77 = sub_10003EE64((unsigned __int16 *)(a5 + 92), (int)a6 - 92, 4, &v332, &v331, 0, 0);
    if ((*(_WORD *)(a5 + 80) & 0xF000) == 0x4000
      && !v77
      && !strncmp(v332, ".DocumentRevisions-V100", v331)
      && sub_10004641C(qword_100091B70, "Fix inode_val: parent_id (%llu)? ", (uint64_t)a3, a4, a5, a6, (uint64_t)a7, (uint64_t)a8, *(void *)a5))
    {
      *(void *)a5 = 2;
      *a8 = 1;
    }
    else
    {
      *(unsigned char *)(a2 + 13) = 1;
    }
  }
  if (v14 == (char *)2)
  {
    uint64_t v78 = *(void *)a5;
    if (*(void *)a5 != 1)
    {
      char v103 = sub_10003D8BC(*a3 >> 60);
      sub_10004458C("%s (id %llu): invalid parent_id (%llu) for root directory\n", v104, v105, v106, v107, v108, v109, v110, v103);
      uint64_t v23 = 92;
      uint64_t v24 = 227;
      goto LABEL_5;
    }
  }
  else if (v14 == (char *)3)
  {
    uint64_t v78 = *(void *)a5;
    if (*(void *)a5 != 1)
    {
      char v79 = sub_10003D8BC(*a3 >> 60);
      sub_10004458C("%s (id %llu): invalid parent_id (%llu) for private directory\n", v80, v81, v82, v83, v84, v85, v86, v79);
      uint64_t v23 = 92;
      uint64_t v24 = 228;
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v78 = *(void *)a5;
  }
  unint64_t v111 = v78 + 1;
  if (a7[5] < v111) {
    a7[5] = v111;
  }
  unint64_t v112 = *(void *)(a5 + 8);
  if (!v112)
  {
    LOBYTE(v332) = 0;
    uint64_t v121 = sub_10003E760(a1, a2, a7[7], *a3 & 0xFFFFFFFFFFFFFFFLL, &v332);
    if (v121)
    {
      uint64_t v23 = v121;
      uint64_t v24 = 1263;
      int v33 = v23;
      goto LABEL_6;
    }
    if (!(_BYTE)v332)
    {
      char v186 = sub_10003D8BC(*a3 >> 60);
      sub_10004458C("%s (id %llu): invalid private_id (%llu)\n", v187, v188, v189, v190, v191, v192, v193, v186);
      uint64_t v23 = 92;
      uint64_t v24 = 229;
      goto LABEL_5;
    }
    unint64_t v112 = *(void *)(a5 + 8);
    unint64_t v41 = (unint64_t)(v14 - 4);
  }
  if (v112 == 1)
  {
    char v113 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid private_id (%llu)\n", v114, v115, v116, v117, v118, v119, v120, v113);
    uint64_t v23 = 92;
    uint64_t v24 = 1264;
    goto LABEL_5;
  }
  if (v112 <= 0xF && (v112 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v122 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid private_id (%llu)\n", v123, v124, v125, v126, v127, v128, v129, v122);
    sub_100048B34((char *)0xE6, -2);
    unint64_t v112 = *(void *)(a5 + 8);
  }
  unint64_t v130 = v112 + 1;
  if (a7[5] < v130) {
    a7[5] = v130;
  }
  unint64_t v326 = v41;
  if ((*(_WORD *)(a5 + 80) & 0xF000) == 0x4000)
  {
    uint64_t v131 = a7[7];
    if (v131) {
      uint64_t v132 = 0;
    }
    else {
      uint64_t v132 = (_DWORD *)(a2 + 704);
    }
    sub_10002BFE8(a1, a2, v131, (uint64_t)v14, *(unsigned int *)(a5 + 68), v132, (uint64_t)a7, (uint64_t)a8);
    uint64_t v23 = v133;
    if (v133) {
      return v23;
    }
    int v134 = *(_DWORD *)(a5 + 56);
    if (v134 < 0)
    {
      char v135 = sub_10003D8BC(*a3 >> 60);
      sub_100044674("%s (id %llu): invalid nchildren (%d)\n", v136, v137, v138, v139, v140, v141, v142, v135);
      sub_100048B34((char *)0x4BE, -8);
      int v134 = *(_DWORD *)(a5 + 56);
    }
    sub_10002C1E0((uint64_t)v14, v134);
    if ((*(unsigned char *)(*(void *)(a2 + 40) + 57) & 2) != 0)
    {
      int v143 = *(_DWORD *)(a5 + 84);
      if (v143 < 0)
      {
        char v144 = sub_10003D8BC(*a3 >> 60);
        sub_100044674("%s (id %llu): invalid dir_nlink (%d)\n", v145, v146, v147, v148, v149, v150, v151, v144);
        sub_100048B34((char *)0x4BF, -8);
        int v143 = *(_DWORD *)(a5 + 84);
      }
      if (*(_DWORD *)(a5 + 56) < v143 && (*(unsigned char *)(a5 + 71) & 0x40) == 0)
      {
        char v152 = sub_10003D8BC(*a3 >> 60);
        sub_100044674("%s (id %llu): directory nlink value %d is greater than nchildren (%d)\n", v153, v154, v155, v156, v157, v158, v159, v152);
        sub_100048B34((char *)0x483, -8);
        int v143 = *(_DWORD *)(a5 + 84);
      }
      sub_10002C1F0((uint64_t)v14, v143);
    }
  }
  else if ((*(_DWORD *)(a5 + 56) & 0x80000000) != 0)
  {
    char v178 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid nlink (%d)\n", v179, v180, v181, v182, v183, v184, v185, v178);
    uint64_t v23 = 92;
    uint64_t v24 = 236;
    goto LABEL_5;
  }
  unint64_t v168 = *(void *)(a5 + 48);
  if (v168 >> 31)
  {
    char v169 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid internal_flags (0x%llx / valid-flags are: 0x%llx)\n", v170, v171, v172, v173, v174, v175, v176, v169);
    sub_100048B34((char *)0xED, -3);
    unint64_t v168 = *(void *)(a5 + 48);
  }
  if ((v168 & 0x800000) != 0)
  {
    if ((*(unsigned char *)(*(void *)(a2 + 40) + 56) & 0x40) == 0)
    {
      unint64_t v177 = v168 & 8;
      goto LABEL_81;
    }
    unint64_t v177 = v168 & 8;
    if ((v168 & 8) == 0 || (*(_WORD *)(a5 + 80) & 0xF000) != 0x8000)
    {
LABEL_81:
      char v194 = sub_10003D8BC(*a3 >> 60);
      if (v177) {
        sub_10004458C("%s (id %llu): invalid internal_flags (0x%llx), given type (0%o)\n", v195, v196, v197, v198, v199, v200, v201, v194);
      }
      else {
        sub_10004458C("%s (id %llu): invalid internal_flags (0x%llx), inconsistent protection class\n", v195, v196, v197, v198, v199, v200, v201, v194);
      }
      if (!sub_10004641C(qword_100091B70, "Fix inode_val: internal_flags (0x%llx)? ", v202, v203, v204, v205, v206, v207, *(void *)(a5 + 48)))
      {
        uint64_t v23 = 92;
        uint64_t v24 = 972;
        goto LABEL_5;
      }
      unint64_t v168 = *(void *)(a5 + 48) & 0xFFFFFFFFFF7FFFFFLL;
      *(void *)(a5 + 48) = v168;
      *a8 = 1;
      goto LABEL_86;
    }
    sub_100033A4C(v14, a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, (uint64_t)a8);
    unint64_t v168 = *(void *)(a5 + 48);
  }
LABEL_86:
  if ((*(_WORD *)(a5 + 80) & 0xF000) != 0x4000 && (v168 & 4) != 0)
  {
    char v208 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid internal_flags (0x%llx), given type (0%o)\n", v209, v210, v211, v212, v213, v214, v215, v208);
    if (!sub_10004641C(qword_100091B70, "Fix inode_val: internal_flags (0x%llx)? ", v216, v217, v218, v219, v220, v221, *(void *)(a5 + 48)))
    {
      uint64_t v23 = 92;
      uint64_t v24 = 238;
      goto LABEL_5;
    }
    unint64_t v168 = *(void *)(a5 + 48) & 0xFFFFFFFFFFFFFFFBLL;
    *(void *)(a5 + 48) = v168;
    *a8 = 1;
  }
  if ((v168 & 6) == 4)
  {
    char v222 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid internal_flags (0x%llx), (dir-stats origin but not dir-stats maintained)\n", v223, v224, v225, v226, v227, v228, v229, v222);
    sub_100048B34((char *)0x532, -3);
    unint64_t v168 = *(void *)(a5 + 48);
  }
  if ((v168 & 0x20000002) == 0x20000000)
  {
    char v230 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid internal_flags (0x%llx), (dir-stats SAF but not dir-stats maintained)\n", v231, v232, v233, v234, v235, v236, v237, v230);
    sub_100048B34((char *)0x533, -3);
  }
  if (*(_DWORD *)(a5 + 60) >= 8u)
  {
    char v238 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid default_protection_class (%u)\n", v239, v240, v241, v242, v243, v244, v245, v238);
    uint64_t v23 = 92;
    uint64_t v24 = 239;
    goto LABEL_5;
  }
  if ((*(_WORD *)(a5 + 70) & 0xBF60) != 0)
  {
    char v246 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid bsd_flags (0x%x)\n", v247, v248, v249, v250, v251, v252, v253, v246);
    sub_100048B34((char *)0xF0, -3);
  }
  if (*(_WORD *)(a5 + 82))
  {
    char v254 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid pad1 (0x%hx)\n", v255, v256, v257, v258, v259, v260, v261, v254);
    sub_100048B34((char *)0xF1, -10);
  }
  if ((*(unsigned char *)(*(void *)(a2 + 40) + 57) & 2) != 0
    && (*(_WORD *)(a5 + 80) & 0xB000 | 0x4000) == 0x6000
    && !*(_DWORD *)(a5 + 84))
  {
    char v262 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): zero rdev on char/block device (mode %u)\n", v263, v264, v265, v266, v267, v268, v269, v262);
    sub_100048B34((char *)0x4C0, 92);
  }
  if (*(void *)(a5 + 84) && (*(unsigned char *)(a5 + 50) & 4) == 0)
  {
    if ((*(unsigned char *)(*(void *)(a2 + 40) + 57) & 2) != 0)
    {
      int v284 = *(_WORD *)(a5 + 80) & 0xF000;
      if (v284 != 0x2000 && v284 != 0x4000 && v284 != 24576)
      {
        char v285 = sub_10003D8BC(*a3 >> 60);
        sub_100044674("%s (id %llu): uncompressed_size/rdev/dir_nlink union field is set (%llu) but inode flags and mode do not indicate it should (flags: 0x%llx, mode %u)\n", v286, v287, v288, v289, v290, v291, v292, v285);
        sub_100048B34((char *)0x4AC, 92);
        if (sub_10004641C(qword_100091B70, "Clear uncompressed size/rdev/dir_nlink? ", v293, v294, v295, v296, v297, v298, v325))
        {
          *(void *)(a5 + 84) = 0;
          *a8 = 1;
        }
      }
      if (*(_DWORD *)(a5 + 88))
      {
        char v299 = sub_10003D8BC(*a3 >> 60);
        sub_100044674("%s (id %llu): invalid pad2 (0x%x)\n", v300, v301, v302, v303, v304, v305, v306, v299);
        sub_100048B34((char *)0x4C1, -10);
      }
    }
    else
    {
      char v270 = sub_10003D8BC(*a3 >> 60);
      sub_100044674("%s (id %llu): uncompressed size is set (%llu) but has-uncompressed-size flag is not set (flags: 0x%llx)\n", v271, v272, v273, v274, v275, v276, v277, v270);
      sub_100048B34((char *)0xF2, 92);
      if (sub_10004641C(qword_100091B70, "Clear uncompressed size? ", v278, v279, v280, v281, v282, v283, v324))
      {
        *(void *)(a5 + 84) = 0;
        *a8 = 1;
      }
    }
  }
  long long v327 = 0u;
  long long v328 = 0u;
  uint64_t v329 = 0;
  uint64_t v330 = a5;
  uint64_t v307 = sub_100015A6C(a1, a2, (uint64_t)a3, (unsigned __int16 *)(a5 + 92), (a6 - 92), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100015C9C, (uint64_t)a7, a8, (uint64_t)&v327);
  if (v307 || (uint64_t v307 = sub_100016CE0(a1, a2, (uint64_t)a7, (uint64_t)&v327, a3, a8), v307))
  {
    uint64_t v23 = v307;
    char v309 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid xfields\n", v310, v311, v312, v313, v314, v315, v316, v309);
    goto LABEL_7;
  }
  if (a7[7]) {
    v317 = 0;
  }
  else {
    v317 = (_DWORD *)(a2 + 704);
  }
  uint64_t v23 = sub_100027A34(a1, a2, v317, (uint64_t)v14, a5, *((uint64_t *)&v327 + 1), v329, v308);
  if (v23) {
    goto LABEL_7;
  }
  uint64_t v318 = *(void *)(a5 + 48);
  if ((v318 & 0x10) != 0 && (*(_WORD *)(a5 + 80) & 0xF000) == 0x8000)
  {
    if ((unint64_t)v328 >= *((void *)&v328 + 1)) {
      uint64_t v319 = v328 - *((void *)&v328 + 1);
    }
    else {
      uint64_t v319 = 0;
    }
    if (BYTE5(v327)) {
      uint64_t v320 = v329;
    }
    else {
      uint64_t v320 = 0;
    }
    if (BYTE2(v327)) {
      uint64_t v321 = *((void *)&v327 + 1);
    }
    else {
      uint64_t v321 = 0;
    }
    uint64_t v23 = sub_1000038D4((unint64_t)v14, a5, a6, v319, v320, v321);
    if (v23) {
      goto LABEL_7;
    }
    uint64_t v318 = *(void *)(a5 + 48);
  }
  if (v318) {
    return 0;
  }
  int v322 = *(_WORD *)(a5 + 80) & 0xF000;
  if (v322 == 40960)
  {
    uint64_t v23 = 0;
    ++a7[2];
    return v23;
  }
  if (v322 == 0x8000)
  {
    uint64_t v23 = 0;
    ++*a7;
    return v23;
  }
  if (v322 != 0x4000)
  {
    uint64_t v23 = 0;
    ++a7[3];
    return v23;
  }
  if (v326 > 0xFFFFFFFFFFFFFFFDLL) {
    return 0;
  }
  uint64_t v23 = 0;
  ++a7[1];
  return v23;
}

uint64_t sub_100012158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, void *a7, _DWORD *a8)
{
  unint64_t v13 = *(void *)a3;
  char v210 = -86;
  if ((a4 - 777) <= 0xFFFFFD00)
  {
    char v14 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 92;
    uint64_t v23 = 257;
LABEL_20:
    int v70 = 92;
LABEL_21:
    sub_100048B34((char *)v23, v70);
LABEL_22:
    sub_100044868(a2, a3, a4, (uint64_t)a5, a6, v71, v72, v73, v204);
    return v22;
  }
  unint64_t v24 = v13 & 0xFFFFFFFFFFFFFFFLL;
  if ((v13 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v25 = sub_10003D8BC(v13 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v22 = 92;
    uint64_t v23 = 258;
    goto LABEL_20;
  }
  if (v24 <= 0xF && (v24 > 7 || ((1 << v13) & 0x8C) == 0))
  {
    char v37 = sub_10003D8BC(v13 >> 60);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v38, v39, v40, v41, v42, v43, v44, v37);
    sub_100048B34((char *)0x103, -2);
  }
  if (a7[5] <= v24) {
    a7[5] = v24 + 1;
  }
  CFIndex v45 = *(unsigned __int16 *)(a3 + 8);
  if ((unsigned __int16)(v45 - 767) <= 0xFD02u)
  {
    char v46 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid name_len (%u)\n", v47, v48, v49, v50, v51, v52, v53, v46);
    uint64_t v22 = 92;
    uint64_t v23 = 260;
    goto LABEL_20;
  }
  if (v45 + 10 != a4)
  {
    char v62 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u), given name_len (%u)\n", v63, v64, v65, v66, v67, v68, v69, v62);
    uint64_t v22 = 92;
    uint64_t v23 = 261;
    goto LABEL_20;
  }
  if (*(unsigned char *)(a3 + 10 + (v45 - 1)))
  {
    char v54 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v55, v56, v57, v58, v59, v60, v61, v54);
    uint64_t v22 = 92;
    uint64_t v23 = 262;
    goto LABEL_20;
  }
  if (sub_100010914((UInt8 *)(a3 + 10), v45))
  {
    char v77 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): invalid name (%.*s)\n", v78, v79, v80, v81, v82, v83, v84, v77);
    sub_100048B34((char *)0x107, -9);
  }
  if (a6 <= 3)
  {
    char v85 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v86, v87, v88, v89, v90, v91, v92, v85);
    uint64_t v22 = 92;
    uint64_t v23 = 264;
    goto LABEL_20;
  }
  __s1 = (char *)(a3 + 10);
  int v93 = *a5;
  if ((v93 & 0xFFE8) != 0)
  {
    char v94 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): invalid flags (0x%x)\n", v95, v96, v97, v98, v99, v100, v101, v94);
    if (*(void *)(*(void *)(a1 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", v102, v103, v104, v105, v106, v107, *(unsigned char *)a5 & 0xE8))
    {
      *a5 &= 0x17u;
      *a8 = 1;
    }
    sub_100048B34((char *)0x109, -3);
    int v93 = *a5;
  }
  if ((~v93 & 3) == 0)
  {
    char v108 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid flags (0x%x)\n", v109, v110, v111, v112, v113, v114, v115, v108);
    uint64_t v22 = 92;
    uint64_t v23 = 266;
    goto LABEL_20;
  }
  if ((v93 & 4) != 0)
  {
    size_t v205 = *(unsigned __int16 *)(a3 + 8);
    if (strncmp(__s1, "com.apple.fs.symlink", v205))
    {
      if (strncmp(__s1, "com.apple.fs.altlink", v205)
        && strncmp(__s1, "com.apple.fs.firmlink", v205)
        && strncmp(__s1, "com.apple.fs.cow-exempt-file-count", v205)
        && strncmp(__s1, "com.apple.fs.graft-vol-uuid", v205)
        && strncmp(__s1, "com.apple.fs.graft-jobj-id-base", v205)
        && strncmp(__s1, "com.apple.fs.graft-jobj-id-len", v205)
        && strncmp(__s1, "com.apple.system.fs.speculative_telemetry", v205))
      {
        char v116 = sub_10003D8BC(*(void *)a3 >> 60);
        sub_100044674("%s (id %llu): invalid flags (0x%x), given name (<%.*s> ; name_len %d)\n",
          v117,
          v118,
          v119,
          v120,
          v121,
          v122,
          v123,
          v116);
        sub_100048B34((char *)0x10B, -3);
        LOWORD(v93) = *a5;
      }
    }
  }
  if ((v93 & 1) != 0 && a5[1] != 48)
  {
    char v135 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid xdata_len (%u), given flags (0x%x)\n", v136, v137, v138, v139, v140, v141, v142, v135);
    uint64_t v22 = 92;
    uint64_t v23 = 268;
    goto LABEL_20;
  }
  uint64_t v124 = a5[1];
  if ((v93 & 2) != 0 && v124 >= 0xEDD)
  {
    char v125 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid xdata_len (%u), given flags (0x%x)\n", v126, v127, v128, v129, v130, v131, v132, v125);
    uint64_t v22 = 92;
    uint64_t v23 = 269;
    goto LABEL_20;
  }
  if (v124 + 4 != a6)
  {
    char v143 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid length (%u), given xdata_len (%u)\n", v144, v145, v146, v147, v148, v149, v150, v143);
    uint64_t v22 = 92;
    uint64_t v23 = 270;
    goto LABEL_20;
  }
  if (a7[7]) {
    uint64_t v133 = 0;
  }
  else {
    uint64_t v133 = (_DWORD *)(a2 + 704);
  }
  sub_100026E2C(a1, v133, a8, a3, (uint64_t)a5, (BOOL *)&v210, v75, v76);
  if (v134)
  {
    uint64_t v22 = v134;
    uint64_t v23 = 973;
LABEL_56:
    int v70 = v22;
    goto LABEL_21;
  }
  size_t v151 = *(unsigned __int16 *)(a3 + 8);
  int v152 = strncmp(__s1, "com.apple.ResourceFork", v151);
  __int16 v153 = *a5;
  if (!v152)
  {
    if ((v153 & 1) == 0)
    {
      char v165 = sub_10003D8BC(*(void *)a3 >> 60);
      sub_10004458C("%s (id %llu): com.apple.ResourceFork is expected to be stream based\n", v166, v167, v168, v169, v170, v171, v172, v165);
      uint64_t v22 = 92;
      uint64_t v23 = 1453;
      goto LABEL_20;
    }
LABEL_71:
    long long v173 = *(_OWORD *)(a5 + 10);
    long long __src = *(_OWORD *)(a5 + 2);
    long long v208 = v173;
    long long v209 = *(_OWORD *)(a5 + 18);
    if ((unint64_t)__src <= 1)
    {
      char v174 = sub_10003D8BC(*(void *)a3 >> 60);
      sub_10004458C("%s (id %llu): invalid xattr_obj_id (%llu)\n", v175, v176, v177, v178, v179, v180, v181, v174);
      uint64_t v22 = 92;
      uint64_t v23 = 271;
      goto LABEL_20;
    }
    if ((unint64_t)__src <= 0xF && (unint64_t)(__src - 4) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      char v182 = sub_10003D8BC(*(void *)a3 >> 60);
      sub_100044674("%s (id %llu): invalid xattr_obj_id (%llu)\n", v183, v184, v185, v186, v187, v188, v189, v182);
      sub_100048B34((char *)0x110, -2);
    }
    if (a7[5] < (unint64_t)(__src + 1)) {
      a7[5] = __src + 1;
    }
    uint64_t v190 = sub_10001726C(a1, a2, (uint64_t *)a3, 0, (void *)&__src + 1, (uint64_t)a7, a8);
    if (v190) {
      goto LABEL_79;
    }
    uint64_t v201 = *(void *)(a2 + 48);
    uint64_t v202 = v201;
    if (!v201) {
      uint64_t v202 = *(void *)(a2 + 40);
    }
    if ((*(unsigned char *)(v202 + 56) & 0x20) != 0)
    {
      uint64_t v203 = __src;
      a7[8] = v24;
      a7[9] = v203;
    }
    if (v210)
    {
      if (v201)
      {
LABEL_87:
        if ((*(unsigned char *)(v201 + 56) & 0x20) != 0 || v210 || (sub_100008EE4(v24, (uint64_t)&__src + 8), !v190))
        {
          if (*a8) {
            memcpy(a5 + 2, &__src, a5[1]);
          }
          return 0;
        }
LABEL_79:
        uint64_t v22 = v190;
        char v193 = sub_10003D8BC(*(void *)a3 >> 60);
        sub_10004458C("%s (id %llu): invalid dstream\n", v194, v195, v196, v197, v198, v199, v200, v193);
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v190 = sub_10000D454(v24, __src, v208, 0, 0, 0, v191, v192);
      if (v190) {
        goto LABEL_79;
      }
      uint64_t v201 = *(void *)(a2 + 48);
      if (v201) {
        goto LABEL_87;
      }
    }
    uint64_t v201 = *(void *)(a2 + 40);
    goto LABEL_87;
  }
  if (v153) {
    goto LABEL_71;
  }
  uint64_t v154 = *(void *)(a2 + 48);
  if (!v154) {
    uint64_t v154 = *(void *)(a2 + 40);
  }
  if ((*(unsigned char *)(v154 + 56) & 0x20) == 0) {
    return 0;
  }
  size_t v155 = v151;
  uint64_t v22 = 0;
  if (a6 == 20 && v24 == a7[8])
  {
    if (!strncmp(__s1, "com.apple.decmpfs", v155))
    {
      unint64_t v156 = *(unsigned int *)(*(void *)(a1 + 8) + 36);
      uint64_t v22 = sub_10000D814(a7[9], (*(void *)(a5 + 6) + v156 - 1) / v156 * v156);
      if (!v22) {
        return v22;
      }
      char v157 = sub_10003D8BC(*(void *)a3 >> 60);
      sub_10004458C("%s (id %llu): failed to update dstream (%llu)\n", v158, v159, v160, v161, v162, v163, v164, v157);
      uint64_t v23 = 953;
      goto LABEL_56;
    }
    return 0;
  }
  return v22;
}

uint64_t sub_1000129D4(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v12 = *a3;
  if (a4 != 16)
  {
    char v23 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    uint64_t v22 = 293;
    goto LABEL_34;
  }
  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
  if ((v12 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v14 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 294;
LABEL_34:
    uint64_t v111 = 92;
    sub_100048B34((char *)v22, 92);
    sub_100044868(a2, (uint64_t)a3, a4, a5, a6, v112, v113, v114, v124);
    return v111;
  }
  if (v13 <= 0xF && v13 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v33 = sub_10003D8BC(v12 >> 60);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v34, v35, v36, v37, v38, v39, v40, v33);
    sub_100048B34((char *)0x127, -2);
  }
  unint64_t v41 = *(void *)(a7 + 40);
  if (v41 <= v13)
  {
    unint64_t v41 = v13 + 1;
    *(void *)(a7 + 40) = v13 + 1;
  }
  unint64_t v42 = a3[1];
  if (v42 <= 1)
  {
    char v43 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid sibling_id (%llu)\n", v44, v45, v46, v47, v48, v49, v50, v43);
    uint64_t v22 = 296;
    goto LABEL_34;
  }
  if (v42 <= 0xF && (v42 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v51 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid sibling_id (%llu)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    sub_100048B34((char *)0x129, -2);
    unint64_t v42 = a3[1];
    unint64_t v41 = *(void *)(a7 + 40);
  }
  unint64_t v59 = v42 + 1;
  if (v41 < v59)
  {
    *(void *)(a7 + 40) = v59;
    unint64_t v41 = v59;
  }
  if ((a6 - 777) <= 0xFFFFFD00)
  {
    char v60 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v61, v62, v63, v64, v65, v66, v67, v60);
    uint64_t v22 = 298;
    goto LABEL_34;
  }
  unint64_t v68 = *(void *)a5;
  if (*(void *)a5 <= 1uLL)
  {
    char v69 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid parent_id (%llu)\n", v70, v71, v72, v73, v74, v75, v76, v69);
    uint64_t v22 = 299;
    goto LABEL_34;
  }
  if (v68 <= 0xF && (v68 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v77 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid parent_id (%llu)\n", v78, v79, v80, v81, v82, v83, v84, v77);
    sub_100048B34((char *)0x12C, -2);
    unint64_t v68 = *(void *)a5;
    unint64_t v41 = *(void *)(a7 + 40);
  }
  unint64_t v85 = v68 + 1;
  if (v41 < v85) {
    *(void *)(a7 + 40) = v85;
  }
  CFIndex v86 = *(unsigned __int16 *)(a5 + 8);
  if ((unsigned __int16)(v86 - 767) <= 0xFD02u)
  {
    char v87 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v88, v89, v90, v91, v92, v93, v94, v87);
    uint64_t v22 = 301;
    goto LABEL_34;
  }
  if (v86 + 10 != a6)
  {
    char v103 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u), given name_len (%u)\n", v104, v105, v106, v107, v108, v109, v110, v103);
    uint64_t v22 = 302;
    goto LABEL_34;
  }
  if (*(unsigned char *)(a5 + 10 + (v86 - 1)))
  {
    char v95 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v96, v97, v98, v99, v100, v101, v102, v95);
    uint64_t v22 = 303;
    goto LABEL_34;
  }
  if (sub_100010914((UInt8 *)(a5 + 10), v86))
  {
    char v116 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid name (%.*s)\n", v117, v118, v119, v120, v121, v122, v123, v116);
    sub_100048B34((char *)0x130, -9);
  }
  return 0;
}

void sub_100012DAC(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v12 = *a3;
  if (a4 != 8)
  {
    char v24 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v25, v26, v27, v28, v29, v30, v31, v24);
    sub_100044868(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v32, v33, v34, v56);
    uint64_t v22 = 210;
    goto LABEL_5;
  }
  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
  if ((v12 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v14 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 625;
LABEL_5:
    sub_100048B34((char *)v22, 92);
    return;
  }
  if (v13 <= 0xF && (v13 > 7 || ((1 << v12) & 0x8C) == 0))
  {
    char v37 = sub_10003D8BC(v12 >> 60);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v38, v39, v40, v41, v42, v43, v44, v37);
    sub_100048B34((char *)0x272, -2);
  }
  if (*(void *)(a7 + 40) <= v13) {
    *(void *)(a7 + 40) = v13 + 1;
  }
  if (a6 != 4)
  {
    char v45 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v46, v47, v48, v49, v50, v51, v52, v45);
    sub_100044868(a2, (uint64_t)a3, 8, (uint64_t)a5, a6, v53, v54, v55, v57);
    uint64_t v22 = 211;
    goto LABEL_5;
  }

  sub_10000D8E8(a3, a5, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8);
}

uint64_t sub_100012F68(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = *(void *)(a2 + 48);
  if (!v14) {
    uint64_t v14 = *(void *)(a2 + 40);
  }
  unint64_t v15 = *(void *)a3;
  if ((*(unsigned char *)(v14 + 56) & 0x20) != 0)
  {
    char v26 = sub_10003D8BC(v15 >> 60);
    sub_10004458C("%s (id %llu): present on sealed volume\n", v27, v28, v29, v30, v31, v32, v33, v26);
    uint64_t v25 = 922;
  }
  else if (a4 == 8)
  {
    unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFLL;
    if ((v15 & 0xFFFFFFFFFFFFFFFLL) > 1)
    {
      if (v16 <= 0xF && v16 - 6 <= 0xFFFFFFFFFFFFFFFBLL)
      {
        char v48 = sub_10003D8BC(v15 >> 60);
        sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v49, v50, v51, v52, v53, v54, v55, v48);
        sub_100048B34((char *)0xF6, -2);
      }
      if (*(void *)(a7 + 40) <= v16) {
        *(void *)(a7 + 40) = v16 + 1;
      }
      if (a6 > 0x17)
      {
        if (*(_WORD *)(a5 + 4) == 6) {
          unsigned int v64 = 280;
        }
        else {
          unsigned int v64 = 152;
        }
        if (v64 < a6)
        {
          char v65 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid value length (%u)\n", v66, v67, v68, v69, v70, v71, v72, v65);
        }
        if (*(void *)(a7 + 56)) {
          uint64_t v73 = 0;
        }
        else {
          uint64_t v73 = (_DWORD *)(a2 + 704);
        }
        sub_100008CAC(a2, a3, (_DWORD *)a5, v73, a5, a6, a7, a8);
        uint64_t v42 = v74;
        if (v74 || v16 == 4)
        {
          if (!v74) {
            return v42;
          }
          goto LABEL_10;
        }
        if ((*(void *)(*(void *)(a2 + 40) + 264) & 0x109) == 0x100) {
          int v75 = 6;
        }
        else {
          int v75 = 5;
        }
        if (v75 != *(unsigned __int16 *)(a5 + 4))
        {
          char v76 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.major_version (%u)\n", v77, v78, v79, v80, v81, v82, v83, v76);
          sub_100048B34((char *)0xF9, -6);
        }
        if (*(_WORD *)(a5 + 6))
        {
          char v84 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.minor_version (%u)\n", v85, v86, v87, v88, v89, v90, v91, v84);
          sub_100048B34((char *)0xFA, -6);
        }
        if (*(_DWORD *)(a5 + 8))
        {
          char v92 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.cpflags (%u)\n", v93, v94, v95, v96, v97, v98, v99, v92);
          sub_100048B34((char *)0xFB, -3);
        }
        if ((*(unsigned char *)(a5 + 12) & 0x18) != 0)
        {
          char v100 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.persistent_class (%u)\n", v101, v102, v103, v104, v105, v106, v107, v100);
          sub_100048B34((char *)0xFC, -6);
        }
        if (!*(_DWORD *)(a5 + 16) && *(_WORD *)(a5 + 4) != 6)
        {
          char v108 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.key_os_version (%u)\n", v109, v110, v111, v112, v113, v114, v115, v108);
          sub_100048B34((char *)0xFD, -6);
        }
        if (*(unsigned __int16 *)(a5 + 20) >= 2u)
        {
          char v116 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.key_revision (%u)\n", v117, v118, v119, v120, v121, v122, v123, v116);
          sub_100048B34((char *)0xFE, -6);
        }
        LODWORD(v124) = *(unsigned __int16 *)(a5 + 22);
        int v125 = *(unsigned __int16 *)(a5 + 4);
        unsigned int v126 = (v124 >> 8) + v124;
        if (v125 == 6) {
          unsigned int v127 = (v124 >> 8) + v124;
        }
        else {
          unsigned int v127 = *(unsigned __int16 *)(a5 + 22);
        }
        if (v125 == 6) {
          unsigned int v128 = 256;
        }
        else {
          unsigned int v128 = 128;
        }
        if (v127 > v128)
        {
          char v129 = sub_10003D8BC(*(void *)a3 >> 60);
          sub_100044674("%s (id %llu): invalid state.key_len (%u)\n", v130, v131, v132, v133, v134, v135, v136, v129);
          sub_100048B34((char *)0xFF, -11);
          LODWORD(v124) = *(unsigned __int16 *)(a5 + 22);
          int v125 = *(unsigned __int16 *)(a5 + 4);
          unsigned int v126 = (v124 >> 8) + v124;
        }
        if (v125 == 6) {
          uint64_t v124 = v126;
        }
        else {
          uint64_t v124 = v124;
        }
        if (v124 + 24 == a6) {
          return 0;
        }
        char v137 = sub_10003D8BC(*(void *)a3 >> 60);
        sub_10004458C("%s (id %llu): invalid length (%u), given state.key_len (%u)\n", v138, v139, v140, v141, v142, v143, v144, v137);
        uint64_t v25 = 256;
      }
      else
      {
        char v56 = sub_10003D8BC(*(void *)a3 >> 60);
        sub_10004458C("%s (id %llu): invalid value length (%u)\n", v57, v58, v59, v60, v61, v62, v63, v56);
        uint64_t v25 = 247;
      }
    }
    else
    {
      char v17 = sub_10003D8BC(v15 >> 60);
      sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v18, v19, v20, v21, v22, v23, v24, v17);
      uint64_t v25 = 245;
    }
  }
  else
  {
    char v34 = sub_10003D8BC(v15 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    uint64_t v25 = 244;
  }
  uint64_t v42 = 92;
  sub_100048B34((char *)v25, 92);
LABEL_10:
  sub_100044868(a2, (uint64_t)a3, a4, a5, a6, v43, v44, v45, v145);
  return v42;
}

uint64_t sub_100013410(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v15 = a2[6];
  if (!v15) {
    uint64_t v15 = a2[5];
  }
  if ((*(unsigned char *)(v15 + 56) & 0x20) != 0)
  {
    char v25 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): file extent record present on sealed volume\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v33 = 921;
LABEL_13:
    uint64_t v22 = 92;
    sub_100048B34((char *)v33, 92);
LABEL_14:
    sub_100044868((uint64_t)a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v19, v20, v21, v51);
    return v22;
  }
  if (a4 != 16)
  {
    char v34 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v35, v36, v37, v38, v39, v40, v41, v34);
    uint64_t v33 = 212;
    goto LABEL_13;
  }
  if (a6 != 24)
  {
    char v42 = sub_10003D8BC((unint64_t)*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v43, v44, v45, v46, v47, v48, v49, v42);
    uint64_t v33 = 213;
    goto LABEL_13;
  }
  uint64_t v22 = sub_100017AFC(a1, a2, a3, (uint64_t)a5, a7, a8);
  if (v22) {
    goto LABEL_14;
  }
  sub_10000D9C4(a3, a5, v16, v17, v18, v19, v20, v21);
  uint64_t v22 = v23;
  if (v23) {
    goto LABEL_14;
  }
  sub_10001811C((uint64_t)a2, a3, (uint64_t)a5, a7, a8);
  uint64_t v22 = v24;
  if (v24) {
    goto LABEL_14;
  }
  return v22;
}

uint64_t sub_100013594(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v9 = a5;
  unint64_t v13 = *(void *)(*(void *)(a2 + 40) + 56);
  if ((v13 & 9) != 0) {
    unint64_t v14 = 12;
  }
  else {
    unint64_t v14 = 10;
  }
  unint64_t v15 = *(void *)a3;
  uint64_t v16 = a4;
  if (v14 > a4 || v14 + 766 < a4)
  {
    char v18 = sub_10003D8BC(v15 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92;
    uint64_t v27 = 275;
LABEL_9:
    sub_100048B34((char *)v27, 92);
LABEL_27:
    sub_100044868(a2, a3, a4, v9, a6, v28, v29, v30, v194);
    return v26;
  }
  uint64_t v31 = a1;
  unint64_t v32 = v15 & 0xFFFFFFFFFFFFFFFLL;
  if ((v13 & 9) == 0)
  {
    uint64_t v33 = (UInt8 *)(a3 + 10);
    CFIndex v35 = *(unsigned __int16 *)(a3 + 8);
    int v36 = -1;
    if (v32) {
      goto LABEL_12;
    }
LABEL_20:
    char v46 = sub_10003D8BC(v15 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v47, v48, v49, v50, v51, v52, v53, v46);
    uint64_t v26 = 92;
    uint64_t v45 = 276;
    goto LABEL_25;
  }
  uint64_t v33 = (UInt8 *)(a3 + 12);
  unsigned int v34 = *(_DWORD *)(a3 + 8);
  CFIndex v35 = v34 & 0x3FF;
  int v36 = v34 >> 10;
  if (!v32) {
    goto LABEL_20;
  }
LABEL_12:
  if (v32 <= 0xF && (v32 > 7 || ((1 << v15) & 0x8E) == 0))
  {
    uint64_t v195 = v33;
    uint64_t v197 = a8;
    uint64_t v201 = a7;
    CFIndex v203 = v35;
    char v71 = sub_10003D8BC(v15 >> 60);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v72, v73, v74, v75, v76, v77, v78, v71);
    sub_100048B34((char *)0x115, -2);
    uint64_t v33 = v195;
    a8 = v197;
    a7 = v201;
    CFIndex v35 = v203;
    uint64_t v31 = a1;
  }
  if (*(void *)(a7 + 40) <= v32) {
    *(void *)(a7 + 40) = v32 + 1;
  }
  if ((unsigned __int16)(v35 - 767) <= 0xFD02u)
  {
    char v37 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid name_len (%u)\n", v38, v39, v40, v41, v42, v43, v44, v37);
    uint64_t v26 = 92;
    uint64_t v45 = 278;
LABEL_25:
    sub_100048B34((char *)v45, 92);
LABEL_26:
    uint64_t v9 = a5;
    goto LABEL_27;
  }
  if (v14 + v35 != v16)
  {
    char v62 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u), given name_len (%u)\n", v63, v64, v65, v66, v67, v68, v69, v62);
    uint64_t v26 = 92;
    uint64_t v45 = 279;
    goto LABEL_25;
  }
  if (v33[(v35 - 1)])
  {
    char v54 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid name (%.*s), given name_len (%u)\n", v55, v56, v57, v58, v59, v60, v61, v54);
    uint64_t v26 = 92;
    uint64_t v45 = 280;
    goto LABEL_25;
  }
  uint64_t v196 = (v35 - 1);
  uint64_t v198 = a8;
  uint64_t v200 = v31;
  uint64_t v202 = a7;
  unint64_t v79 = (unint64_t)v33;
  unsigned int v80 = v35;
  if (sub_100010914(v33, v35))
  {
    char v81 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): invalid name (%.*s)\n", v82, v83, v84, v85, v86, v87, v88, v81);
    sub_100048B34((char *)0x119, -9);
  }
  unsigned int v204 = v80;
  if ((v13 & 9) != 0)
  {
    int v206 = -1;
    if (!sub_1000053B0(v79, v196, (v13 >> 3) & 1, (void (*)(_OWORD *, uint64_t, uint64_t))sub_100018540, (uint64_t)&v206))
    {
      int v89 = v206 & 0x3FFFFF;
      if ((v206 & 0x3FFFFF) != v36)
      {
        char v90 = sub_10003D8BC(*(void *)a3 >> 60);
        sub_10004458C("%s (id %llu): invalid hash (0x%x, expected 0x%x) of name (%.*s)\n", v91, v92, v93, v94, v95, v96, v97, v90);
        sub_100048B34((char *)0x11A, 92);
        uint64_t v102 = sub_10002C3B4((long long *)a3, a4, v89, (_DWORD *)(a2 + 704), v98, v99, v100, v101);
        if (v102)
        {
          uint64_t v26 = v102;
          goto LABEL_26;
        }
      }
    }
  }
  if (a6 <= 0x11)
  {
    char v103 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v104, v105, v106, v107, v108, v109, v110, v103);
    uint64_t v26 = 92;
    uint64_t v45 = 283;
    goto LABEL_25;
  }
  uint64_t v9 = a5;
  unint64_t v111 = *(void *)a5;
  if (*(void *)a5 <= 1uLL)
  {
    char v112 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid file_id (%llu) (%s)\n", v113, v114, v115, v116, v117, v118, v119, v112);
    uint64_t v26 = 92;
    uint64_t v27 = 284;
    goto LABEL_9;
  }
  if (v111 <= 0xF && (v111 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v120 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): invalid file_id (%llu) (%s)\n", v121, v122, v123, v124, v125, v126, v127, v120);
    sub_100048B34((char *)0x11D, -2);
    unint64_t v111 = *(void *)a5;
  }
  unsigned int v128 = v80;
  if (*(void *)(v202 + 40) < v111 + 1)
  {
    *(void *)(v202 + 40) = v111 + 1;
    unint64_t v111 = *(void *)a5;
  }
  if (v111 == 2)
  {
    if (v80 == 5 && v32 == 1 && !(*(_DWORD *)v79 ^ 0x746F6F72 | *(unsigned __int8 *)(v79 + 4))) {
      goto LABEL_57;
    }
    char v129 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): file_id (%llu) and name (%.*s) mismatch for root directory\n", v130, v131, v132, v133, v134, v135, v136, v129);
    sub_100048B34((char *)0x11E, -9);
    unsigned int v128 = v80;
    unint64_t v111 = *(void *)a5;
  }
  if (v111 == 3)
  {
    if (v128 == 12 && v32 == 1 && !(*(void *)v79 ^ 0x2D65746176697270 | *(unsigned int *)(v79 + 8) ^ 0x726964)) {
      goto LABEL_57;
    }
    char v137 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): file_id (%llu) and name (%.*s) mismatch for private directory\n", v138, v139, v140, v141, v142, v143, v144, v137);
    sub_100048B34((char *)0x11F, -9);
  }
  if (v32 == 7) {
    goto LABEL_64;
  }
LABEL_57:
  unsigned int v145 = *(unsigned __int16 *)(a5 + 16);
  if (v145 >= 0x10)
  {
    char v146 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): unknown flags (0x%hx)\n", v147, v148, v149, v150, v151, v152, v153, v146);
    if (*(void *)(*(void *)(v200 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", v154, v155, v156, v157, v158, v159, *(unsigned char *)(a5 + 16) & 0xF0))
    {
      *(_WORD *)(a5 + 16) &= 0xFu;
      _DWORD *v198 = 1;
    }
    sub_100048B34((char *)0x121, -3);
    LOWORD(v145) = *(_WORD *)(a5 + 16);
  }
  unsigned int v160 = v145 & 0xF;
  if (v160 <= 0xE)
  {
    int v161 = 1 << v160;
    if ((v161 & 0x1556) != 0) {
      goto LABEL_64;
    }
    if ((v161 & 0x4001) != 0)
    {
      char v175 = sub_10003D8BC(*(void *)a3 >> 60);
      sub_10004458C("%s (id %llu): invalid type (%u)\n", v176, v177, v178, v179, v180, v181, v182, v175);
      uint64_t v26 = 92;
      uint64_t v27 = 290;
      goto LABEL_9;
    }
  }
  char v183 = sub_10003D8BC(*(void *)a3 >> 60);
  sub_100044674("%s (id %llu): invalid type (%u)\n", v184, v185, v186, v187, v188, v189, v190, v183);
  sub_100048B34((char *)0x123, -5);
LABEL_64:
  uint64_t v162 = v200;
  uint64_t v163 = (void *)v202;
  uint64_t v164 = sub_100015A6C(v200, a2, a3, (unsigned __int16 *)(a5 + 18), (a6 - 18), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100018580, v202, v198, 0);
  if (v164)
  {
    uint64_t v26 = v164;
    char v165 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): invalid xfields\n", v166, v167, v168, v169, v170, v171, v172, v165);
    goto LABEL_27;
  }
  if (v32 == 3)
  {
    if (v204 < 0xE || (uint64_t v162 = v200, v163 = (void *)v202, strncmp("tmp-ino-clone-", (const char *)v79, 0xEuLL)))
    {
      int v173 = *(_WORD *)(a5 + 16) & 0xF;
      if (v173 == 10)
      {
        char v174 = v163 + 2;
        goto LABEL_79;
      }
      char v174 = v163;
      if (v173 == 8)
      {
LABEL_79:
        --*v174;
        goto LABEL_80;
      }
      if (v173 != 4)
      {
        char v174 = v163 + 3;
        goto LABEL_79;
      }
      if ((*(void *)a5 & 0xFFFFFFFFFFFFFFFELL) != 2)
      {
        char v174 = v163 + 1;
        goto LABEL_79;
      }
    }
  }
LABEL_80:
  uint64_t v191 = v163[7];
  if (v191) {
    uint64_t v192 = 0;
  }
  else {
    uint64_t v192 = (_DWORD *)(a2 + 704);
  }
  sub_10002C200(v162, a2, v191, (long long *)a3, a4, a5, a6, v192);
  return v193;
}

uint64_t sub_100013DB0(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v13 = *(void *)(a2 + 48);
  if (!v13) {
    uint64_t v13 = *(void *)(a2 + 40);
  }
  unint64_t v14 = *a3;
  if ((*(unsigned char *)(v13 + 57) & 2) != 0)
  {
    char v25 = sub_10003D8BC(v14 >> 60);
    sub_10004458C("%s (id %llu): invalid key on expanded-records volume\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v24 = 1399;
  }
  else if (a4 == 8)
  {
    unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFFLL;
    if ((v14 & 0xFFFFFFFFFFFFFFFLL) > 1)
    {
      if (v15 <= 0xF && v15 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v42 = sub_10003D8BC(v14 >> 60);
        sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v43, v44, v45, v46, v47, v48, v49, v42);
        sub_100048B34((char *)0x133, -2);
      }
      unint64_t v50 = *(void *)(a7 + 40);
      if (v50 <= v15)
      {
        unint64_t v50 = v15 + 1;
        *(void *)(a7 + 40) = v15 + 1;
      }
      if (a6 == 32)
      {
        unint64_t v51 = a5[2];
        if (v51 == 1)
        {
          char v52 = sub_10003D8BC(*a3 >> 60);
          sub_10004458C("%s (id %llu): invalid chained_key (%llu)\n", v53, v54, v55, v56, v57, v58, v59, v52);
          uint64_t v24 = 310;
        }
        else
        {
          if (v51 <= 0xF && v51 > 3)
          {
            char v73 = sub_10003D8BC(*a3 >> 60);
            sub_100044674("%s (id %llu): invalid chained_key (%llu)\n", v74, v75, v76, v77, v78, v79, v80, v73);
            sub_100048B34((char *)0x137, -2);
            unint64_t v51 = a5[2];
            unint64_t v50 = *(void *)(a7 + 40);
          }
          unint64_t v81 = v51 + 1;
          if (v50 < v81) {
            *(void *)(a7 + 40) = v81;
          }
          if (a5[3])
          {
            sub_1000191D8(v15, a5);
            uint64_t v68 = v82;
            if (!v82) {
              return v68;
            }
            goto LABEL_21;
          }
          char v83 = sub_10003D8BC(*a3 >> 60);
          sub_10004458C("%s (id %llu): invalid gen_count (%llu)\n", v84, v85, v86, v87, v88, v89, v90, v83);
          uint64_t v24 = 312;
        }
      }
      else
      {
        char v60 = sub_10003D8BC(*a3 >> 60);
        sub_10004458C("%s (id %llu): invalid value length (%u)\n", v61, v62, v63, v64, v65, v66, v67, v60);
        uint64_t v24 = 308;
      }
    }
    else
    {
      char v16 = sub_10003D8BC(v14 >> 60);
      sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v17, v18, v19, v20, v21, v22, v23, v16);
      uint64_t v24 = 306;
    }
  }
  else
  {
    char v33 = sub_10003D8BC(v14 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v34, v35, v36, v37, v38, v39, v40, v33);
    uint64_t v24 = 305;
  }
  uint64_t v68 = 92;
  sub_100048B34((char *)v24, 92);
LABEL_21:
  sub_100044868(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v69, v70, v71, v91);
  return v68;
}

uint64_t sub_100014054(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  int v17 = 0;
  uint64_t v14 = sub_10001061C(a2, a3, a4, a5, a6, 1, &v17);
  if (v14 || (uint64_t v14 = sub_10002BBFC((uint64_t)a3, (uint64_t *)a5), v14)) {
    sub_100044868(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v11, v12, v13, v16);
  }
  return v14;
}

uint64_t sub_1000140F8(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7)
{
  unint64_t v12 = *a3;
  if (a4 != 8)
  {
    char v23 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    uint64_t v22 = 530;
    goto LABEL_7;
  }
  if (a6 != 8)
  {
    char v31 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v32, v33, v34, v35, v36, v37, v38, v31);
    uint64_t v22 = 531;
    goto LABEL_7;
  }
  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFFLL;
  if ((v12 & 0xFFFFFFFFFFFFFFFLL) <= 1)
  {
    char v14 = sub_10003D8BC(v12 >> 60);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v15, v16, v17, v18, v19, v20, v21, v14);
    uint64_t v22 = 532;
LABEL_7:
    uint64_t v39 = 92;
    sub_100048B34((char *)v22, 92);
    sub_100044868(a2, (uint64_t)a3, a4, (uint64_t)a5, a6, v40, v41, v42, v73);
    return v39;
  }
  if (v13 <= 0xF && v13 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v46 = sub_10003D8BC(v12 >> 60);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v47, v48, v49, v50, v51, v52, v53, v46);
    sub_100048B34((char *)0x215, -2);
  }
  unint64_t v54 = *(void *)(a7 + 40);
  if (v54 <= v13)
  {
    unint64_t v54 = v13 + 1;
    *(void *)(a7 + 40) = v13 + 1;
  }
  unint64_t v55 = *a5;
  if (*a5 <= 1)
  {
    char v56 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): invalid file_id (%llu)\n", v57, v58, v59, v60, v61, v62, v63, v56);
    uint64_t v22 = 534;
    goto LABEL_7;
  }
  if (v55 <= 0xF)
  {
    char v64 = sub_10003D8BC(*a3 >> 60);
    sub_100044674("%s (id %llu): invalid file_id (%llu)\n", v65, v66, v67, v68, v69, v70, v71, v64);
    sub_100048B34((char *)0x217, -2);
    unint64_t v55 = *a5;
    unint64_t v54 = *(void *)(a7 + 40);
  }
  unint64_t v72 = v55 + 1;
  uint64_t v39 = 0;
  if (v54 < v72) {
    *(void *)(a7 + 40) = v72;
  }
  return v39;
}

uint64_t sub_100014308(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v13 = *a3;
  if (a4 == 16)
  {
    unint64_t v16 = v13 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v17 = a3[1];
    unint64_t v18 = HIBYTE(v17);
    if (HIBYTE(v17) != 2)
    {
      if (v18 != 1)
      {
        unint64_t v19 = v13 >> 60;
        if (v18)
        {
          char v58 = sub_10003D8BC(v19);
          sub_100044674("%s (id %llu): Unknown type (0x%x)\n", v59, v60, v61, v62, v63, v64, v65, v58);
          sub_100048B34((char *)0x3AF, -5);
          return 0;
        }
        char v20 = sub_10003D8BC(v19);
        sub_10004458C("%s (id %llu): Invalid type (0x%x)\n", v21, v22, v23, v24, v25, v26, v27, v20);
        uint64_t v28 = 942;
        goto LABEL_7;
      }
      if (a6 <= 2)
      {
        char v50 = sub_10003D8BC(v13 >> 60);
        sub_10004458C("%s (id %llu): invalid value length (%u)\n", v51, v52, v53, v54, v55, v56, v57, v50);
        uint64_t v28 = 938;
        goto LABEL_7;
      }
      if (v16 <= 1)
      {
        char v76 = sub_10003D8BC(v13 >> 60);
        sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v77, v78, v79, v80, v81, v82, v83, v76);
        uint64_t v28 = 939;
        goto LABEL_7;
      }
      unint64_t v142 = *(unsigned int *)(*(void *)(a1 + 8) + 36);
      if (v16 <= 0xF && v16 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        char v143 = sub_10003D8BC(v13 >> 60);
        sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v144, v145, v146, v147, v148, v149, v150, v143);
        sub_100048B34((char *)0x3AC, -2);
      }
      if (*(void *)(a7 + 40) <= v16) {
        *(void *)(a7 + 40) = v16 + 1;
      }
      if ((a3[1] & 0xFFFFFFFFFFFFFFLL) % v142)
      {
        char v151 = sub_10003D8BC(*a3 >> 60);
        sub_10004458C("%s (id %llu): Logical address %llu not a multiple of the block size (%u)\n", v152, v153, v154, v155, v156, v157, v158, v151);
        uint64_t v28 = 941;
        goto LABEL_7;
      }
      uint64_t v161 = sub_100018768(a1, a2, (uint64_t)a3, a5);
      goto LABEL_52;
    }
    if (a6 <= 0x19)
    {
      char v42 = sub_10003D8BC(v13 >> 60);
      sub_10004458C("%s (id %llu): invalid value length (%u)\n", v43, v44, v45, v46, v47, v48, v49, v42);
      uint64_t v28 = 1319;
      goto LABEL_7;
    }
    uint64_t v67 = v17 & 0x1FFFFFFFFFFFFFLL;
    if ((*(unsigned char *)(*(void *)(a2 + 40) + 48) & 8) == 0)
    {
      char v68 = sub_10003D8BC(v13 >> 60);
      sub_100044674("%s (id %llu): found attribution tag on a volume that doesn't support them\n", v69, v70, v71, v72, v73, v74, v75, v68);
      sub_100048B34((char *)0x528, -5);
    }
    if (v16 == 9)
    {
      if (*(void *)(a7 + 40) > 9uLL)
      {
        uint64_t v191 = 0;
        if (v67) {
          goto LABEL_25;
        }
        goto LABEL_24;
      }
      uint64_t v191 = 0;
      *(void *)(a7 + 40) = 10;
      if (!v67)
      {
LABEL_24:
        char v92 = sub_10003D8BC(*a3 >> 60);
        sub_100044674("%s (id %llu): invalid hash (0)\n", v93, v94, v95, v96, v97, v98, v99, v92);
        sub_100048B34((char *)0x52A, -7);
      }
    }
    else
    {
      char v84 = sub_10003D8BC(*a3 >> 60);
      sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v85, v86, v87, v88, v89, v90, v91, v84);
      sub_100048B34((char *)0x529, 92);
      uint64_t v191 = v16;
      if (!v67) {
        goto LABEL_24;
      }
    }
LABEL_25:
    unint64_t v100 = *(unsigned int *)(*(void *)(a1 + 8) + 36);
    if (*(void *)(a5 + 8) % v100)
    {
      char v101 = sub_10003D8BC(*a3 >> 60);
      sub_100044674("%s (id %llu): invalid physical size (%llu) for hash (%llu)\n", v102, v103, v104, v105, v106, v107, v108, v101);
      sub_100048B34((char *)0x52B, -11);
      unint64_t v100 = *(unsigned int *)(*(void *)(a1 + 8) + 36);
    }
    unint64_t v109 = *(void *)(a5 + 16);
    if (v109 % v100)
    {
      char v110 = sub_10003D8BC(*a3 >> 60);
      sub_100044674("%s (id %llu): invalid full clone size (%llu) for hash (%llu)\n", v111, v112, v113, v114, v115, v116, v117, v110);
      sub_100048B34((char *)0x53C, -11);
      unint64_t v109 = *(void *)(a5 + 16);
    }
    if (*(void *)(a5 + 8) < v109)
    {
      char v118 = sub_10003D8BC(*a3 >> 60);
      sub_100044674("%s (id %llu): physical size (%llu) is less than full clone size (%llu) for hash (%llu)\n", v119, v120, v121, v122, v123, v124, v125, v118);
      sub_100048B34((char *)0x53D, -11);
    }
    if (*(unsigned __int16 *)(a5 + 24) >= 2u)
    {
      char v126 = sub_10003D8BC(*a3 >> 60);
      sub_100044674("%s (id %llu): unknown flags (0x%x / valid-flags: 0x%x)\n", v127, v128, v129, v130, v131, v132, v133, v126);
      sub_100048B34((char *)0x52C, -3);
    }
    memset(v192, 0, sizeof(v192));
    uint64_t v134 = sub_100015A6C(a1, a2, (uint64_t)a3, (unsigned __int16 *)(a5 + 26), (a6 - 26), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100018920, a7, a8, (uint64_t)v192);
    if (v134)
    {
      uint64_t v37 = v134;
      char v188 = sub_10003D8BC(*a3 >> 60);
      sub_10004458C("%s (id %llu): invalid xfields\n", v135, v136, v137, v138, v139, v140, v141, v188);
      goto LABEL_59;
    }
    if (LOBYTE(v192[0]))
    {
      CC_LONG v159 = strlen((const char *)v192 + 1);
      uint64_t v160 = sub_10004E898((char *)v192 + 1, v159);
      if (v160 == v67)
      {
        uint64_t v67 = 0;
      }
      else
      {
        char v190 = sub_10003D8BC(*a3 >> 60);
        strlen((const char *)v192 + 1);
        sub_100044674("%s (id %llu): signing id hash (%llu) for signing id (%s) with length (%zu) does not match attribution tag hash (%llu)\n", v171, v172, v173, v174, v175, v176, v177, v190);
        sub_100048B34((char *)0x52E, 92);
      }
      if (*(void *)(a7 + 56)) {
        uint64_t v178 = 0;
      }
      else {
        uint64_t v178 = (_DWORD *)(a2 + 704);
      }
      sub_100007EA0(v178, v160, *(void *)a5, *(void *)(a5 + 8), *(void *)(a5 + 16), *(_WORD *)(a5 + 24), v191, v67);
      uint64_t v37 = v179;
      if (v179)
      {
        char v189 = sub_10003D8BC(*a3 >> 60);
        sub_10004458C("%s (id %llu): failed to register file info (hash %llu): %d\n", v180, v181, v182, v183, v184, v185, v186, v189);
      }
LABEL_59:
      if (!v37) {
        return v37;
      }
      goto LABEL_8;
    }
    char v162 = sub_10003D8BC(*a3 >> 60);
    sub_10004458C("%s (id %llu): signing id does not exist\n", v163, v164, v165, v166, v167, v168, v169, v162);
    sub_100048B34((char *)0x52D, 92);
    if (*(void *)(a7 + 56)) {
      uint64_t v170 = 0;
    }
    else {
      uint64_t v170 = (_DWORD *)(a2 + 704);
    }
    uint64_t v161 = sub_100007E08(v170, v16, v67, 1);
LABEL_52:
    uint64_t v37 = v161;
    goto LABEL_59;
  }
  char v29 = sub_10003D8BC(v13 >> 60);
  sub_10004458C("%s (id %llu): invalid key length (%u)\n", v30, v31, v32, v33, v34, v35, v36, v29);
  uint64_t v28 = 937;
LABEL_7:
  uint64_t v37 = 92;
  sub_100048B34((char *)v28, 92);
LABEL_8:
  sub_100044868(a2, (uint64_t)a3, a4, a5, a6, v38, v39, v40, v187);
  return v37;
}

uint64_t sub_1000149A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v16 = *(void *)a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v17 = *(void *)a3 >> 60;
  if (v17 == 14) {
    LODWORD(v17) = *(unsigned __int8 *)(a3 + 8);
  }
  if (a4 != 28)
  {
    char v28 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v29, v30, v31, v32, v33, v34, v35, v28);
    uint64_t v26 = 92;
    uint64_t v27 = 1168;
    goto LABEL_7;
  }
  if (a6 <= 0x17)
  {
    char v18 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92;
    uint64_t v27 = 1169;
LABEL_7:
    sub_100048B34((char *)v27, 92);
LABEL_8:
    sub_100044868(a2, a3, a4, a5, a6, v36, v37, v38, v124);
    return v26;
  }
  if (v16 <= 1)
  {
    char v40 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v41, v42, v43, v44, v45, v46, v47, v40);
    uint64_t v26 = 92;
    uint64_t v27 = 1170;
    goto LABEL_7;
  }
  if (v16 <= 0xF && (v16 > 7 || ((1 << *(unsigned char *)a3) & 0x8C) == 0))
  {
    char v49 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v50, v51, v52, v53, v54, v55, v56, v49);
    sub_100048B34((char *)0x493, -2);
  }
  if (*(void *)(a7 + 40) <= v16) {
    *(void *)(a7 + 40) = v16 + 1;
  }
  if (!*(void *)(a3 + 12))
  {
    char v57 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid atime (0)\n", v58, v59, v60, v61, v62, v63, v64, v57);
    sub_100048B34((char *)0x58E, -2);
  }
  unint64_t v65 = *(void *)(a3 + 20);
  if (v65 <= 1)
  {
    char v66 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid file_id (%llu)\n", v67, v68, v69, v70, v71, v72, v73, v66);
    uint64_t v26 = 92;
    uint64_t v27 = 1172;
    goto LABEL_7;
  }
  if (v65 <= 0xF && (v65 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v74 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid file_id (%llu)\n", v75, v76, v77, v78, v79, v80, v81, v74);
    sub_100048B34((char *)0x495, -2);
    unint64_t v65 = *(void *)(a3 + 20);
  }
  unint64_t v82 = *(void *)(a7 + 40);
  unint64_t v83 = v65 + 1;
  if (v82 < v83)
  {
    *(void *)(a7 + 40) = v83;
    unint64_t v82 = v83;
  }
  unint64_t v84 = *(void *)(a5 + 8);
  if (v84 <= 1)
  {
    char v85 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid dstream_id (%llu)\n", v86, v87, v88, v89, v90, v91, v92, v85);
    uint64_t v26 = 92;
    uint64_t v27 = 1175;
    goto LABEL_7;
  }
  if (v84 <= 0xF && (v84 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v93 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid dstream_id (%llu)\n", v94, v95, v96, v97, v98, v99, v100, v93);
    sub_100048B34((char *)0x498, -2);
    unint64_t v84 = *(void *)(a5 + 8);
    unint64_t v82 = *(void *)(a7 + 40);
  }
  unint64_t v101 = v84 + 1;
  if (v82 < v101) {
    *(void *)(a7 + 40) = v101;
  }
  if ((*(_WORD *)(a5 + 18) & 0xFFC3) != 0)
  {
    char v102 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): unknown flags (0x%x)\n", v103, v104, v105, v106, v107, v108, v109, v102);
    if (*(void *)(*(void *)(a1 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", v110, v111, v112, v113, v114, v115, 0))
    {
      *(_DWORD *)(a5 + 16) &= 0x3CFFFFu;
      *a8 = 1;
    }
    sub_100048B34((char *)0x499, -3);
  }
  uint64_t v26 = sub_100015A6C(a1, a2, a3, (unsigned __int16 *)(a5 + 24), (a6 - 24), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100018A80, a7, a8, 0);
  if (v26)
  {
    char v116 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid xfields\n", v117, v118, v119, v120, v121, v122, v123, v116);
    goto LABEL_8;
  }
  return v26;
}

uint64_t sub_100014D70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v14 = *(void *)a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v15 = *(void *)a3 >> 60;
  if (v15 == 14) {
    LODWORD(v15) = *(unsigned __int8 *)(a3 + 8);
  }
  if (a4 != 20)
  {
    char v25 = sub_10003D8BC(v15);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v24 = 1178;
    goto LABEL_27;
  }
  if (a6 != 8)
  {
    char v33 = sub_10003D8BC(v15);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v34, v35, v36, v37, v38, v39, v40, v33);
    uint64_t v24 = 1179;
    goto LABEL_27;
  }
  if (v14 <= 1)
  {
    char v16 = sub_10003D8BC(v15);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v17, v18, v19, v20, v21, v22, v23, v16);
    uint64_t v24 = 1180;
LABEL_27:
    uint64_t v78 = 92;
    sub_100048B34((char *)v24, 92);
LABEL_28:
    sub_100044868(a2, a3, a4, (uint64_t)a5, a6, v79, v80, v81, v92);
    return v78;
  }
  if (v14 <= 0xF && (v14 > 7 || ((1 << *(unsigned char *)a3) & 0x8C) == 0))
  {
    char v42 = sub_10003D8BC(v15);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v43, v44, v45, v46, v47, v48, v49, v42);
    sub_100048B34((char *)0x49D, -2);
  }
  unint64_t v50 = *(void *)(a7 + 40);
  if (v50 <= v14)
  {
    unint64_t v50 = v14 + 1;
    *(void *)(a7 + 40) = v14 + 1;
  }
  unint64_t v51 = *(void *)(a3 + 12);
  if (v51 <= 1)
  {
    char v52 = sub_10003D8BC(v15);
    sub_10004458C("%s (id %llu): invalid file_id (%llu)\n", v53, v54, v55, v56, v57, v58, v59, v52);
    uint64_t v24 = 1182;
    goto LABEL_27;
  }
  if (v51 <= 0xF && (v51 & 0xFFFFFFFFFFFFFFFELL) != 2)
  {
    char v60 = sub_10003D8BC(v15);
    sub_100044674("%s (id %llu): invalid file_id (%llu)\n", v61, v62, v63, v64, v65, v66, v67, v60);
    sub_100048B34((char *)0x49F, -2);
    unint64_t v51 = *(void *)(a3 + 12);
    unint64_t v50 = *(void *)(a7 + 40);
  }
  unint64_t v68 = v51 + 1;
  if (v50 < v68)
  {
    *(void *)(a7 + 40) = v68;
    unint64_t v50 = v68;
  }
  unint64_t v69 = *a5;
  if ((unint64_t)*a5 <= 1)
  {
    char v70 = sub_10003D8BC(v15);
    sub_10004458C("%s (id %llu): invalid dstream_id (%llu)\n", v71, v72, v73, v74, v75, v76, v77, v70);
    uint64_t v24 = 1184;
    goto LABEL_27;
  }
  if (v69 <= 0xF && (v69 > 7 || ((1 << v69) & 0x8C) == 0))
  {
    char v83 = sub_10003D8BC(v15);
    sub_100044674("%s (id %llu): invalid dstream_id (%llu)\n", v84, v85, v86, v87, v88, v89, v90, v83);
    sub_100048B34((char *)0x4A1, -2);
    unint64_t v69 = *a5;
    unint64_t v50 = *(void *)(a7 + 40);
  }
  unint64_t v91 = v69 + 1;
  if (v50 < v91) {
    *(void *)(a7 + 40) = v91;
  }
  uint64_t v78 = sub_10000DBA8((void *)a3, a5, a3, a4, (uint64_t)a5, a6, a7, a8);
  if (v78) {
    goto LABEL_28;
  }
  return v78;
}

uint64_t sub_100015020(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  unint64_t v16 = *(void *)a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v17 = *(void *)a3 >> 60;
  if (v17 == 14) {
    LODWORD(v17) = *(unsigned __int8 *)(a3 + 8);
  }
  if (a4 != 12)
  {
    char v28 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v29, v30, v31, v32, v33, v34, v35, v28);
    uint64_t v26 = 92;
    uint64_t v27 = 1186;
    goto LABEL_7;
  }
  if (a6 <= 0x33)
  {
    char v18 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92;
    uint64_t v27 = 1187;
LABEL_7:
    sub_100048B34((char *)v27, 92);
LABEL_8:
    sub_100044868(a2, a3, a4, a5, a6, v36, v37, v38, v126);
    return v26;
  }
  if (v16 <= 1)
  {
    char v40 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v41, v42, v43, v44, v45, v46, v47, v40);
    uint64_t v26 = 92;
    uint64_t v27 = 1188;
    goto LABEL_7;
  }
  if (v16 <= 0xF && v16 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v49 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v50, v51, v52, v53, v54, v55, v56, v49);
    sub_100048B34((char *)0x4A5, -2);
  }
  unint64_t v57 = *(void *)(a7 + 40);
  if (v57 <= v16)
  {
    unint64_t v57 = v16 + 1;
    *(void *)(a7 + 40) = v16 + 1;
  }
  unint64_t v58 = *(void *)(a5 + 32);
  if (v58 == 1)
  {
    char v59 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid chained_key (%llu)\n", v60, v61, v62, v63, v64, v65, v66, v59);
    uint64_t v26 = 92;
    uint64_t v27 = 1192;
    goto LABEL_7;
  }
  if (v58 <= 0xF && v58 > 3)
  {
    char v67 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid chained_key (%llu)\n", v68, v69, v70, v71, v72, v73, v74, v67);
    sub_100048B34((char *)0x4A9, -2);
    unint64_t v58 = *(void *)(a5 + 32);
    unint64_t v57 = *(void *)(a7 + 40);
  }
  unint64_t v75 = v58 + 1;
  if (v57 < v75) {
    *(void *)(a7 + 40) = v75;
  }
  if (!*(void *)(a5 + 40))
  {
    char v76 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): invalid gen_count (%llu)\n", v77, v78, v79, v80, v81, v82, v83, v76);
    sub_100048B34((char *)0x4AA, -8);
  }
  unsigned int v84 = *(_DWORD *)(a5 + 48);
  if (v84 >= 0x1000)
  {
    char v85 = sub_10003D8BC(v17);
    sub_100044674("%s (id %llu): unknown flags (0x%x)\n", v86, v87, v88, v89, v90, v91, v92, v85);
    if (*(void *)(*(void *)(a1 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", v93, v94, v95, v96, v97, v98, 0))
    {
      *(_DWORD *)(a5 + 48) &= 0xFFFu;
      *a8 = 1;
    }
    sub_100048B34((char *)0x4AB, -3);
    unsigned int v84 = *(_DWORD *)(a5 + 48);
  }
  if ((v84 & 0x200) != 0)
  {
    char v99 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): found dir-stats object (chained-key %llu) that is unexpectedly being moved\n", v100, v101, v102, v103, v104, v105, v106, v99);
    sub_100048B34((char *)0x5A8, 92);
  }
  long long v129 = 0u;
  long long v130 = 0u;
  long long v127 = 0u;
  long long v128 = 0u;
  uint64_t v107 = sub_100015A6C(a1, a2, a3, (unsigned __int16 *)(a5 + 52), (a6 - 52), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100018BC8, a7, a8, (uint64_t)&v127);
  if (v107)
  {
    uint64_t v26 = v107;
    char v108 = sub_10003D8BC(v17);
    sub_10004458C("%s (id %llu): invalid xfields\n", v109, v110, v111, v112, v113, v114, v115, v108);
    goto LABEL_8;
  }
  int v116 = v129;
  if ((~*(_DWORD *)(a5 + 48) & 0x801) == 0 && (_BYTE)v129)
  {
    if (*((void *)&v129 + 1) <= *(void *)(a5 + 16))
    {
      int v116 = 1;
    }
    else
    {
      char v117 = sub_10003D8BC(v17);
      sub_100044674("%s (id %llu): purgeable resource fork size (%llu) is larger than resource fork size (%llu)\n", v118, v119, v120, v121, v122, v123, v124, v117);
      sub_100048B34((char *)0x5B4, -3);
      int v116 = v129;
    }
  }
  sub_100019364(v16, a5, a6, v127, *((uint64_t *)&v127 + 1), v128, *((uint64_t *)&v128 + 1), v116 != 0, *((uint64_t *)&v129 + 1), v130, *((uint64_t *)&v130 + 1));
  uint64_t v26 = v125;
  if (v125) {
    goto LABEL_8;
  }
  return v26;
}

uint64_t sub_100015438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v16 = *(void *)a3 >> 60;
  if (v16 == 14) {
    LODWORD(v16) = *(unsigned __int8 *)(a3 + 8);
  }
  if (a4 != 28)
  {
    char v27 = sub_10003D8BC(v16);
    sub_10004458C("%s (id %llu): invalid key length (%u)\n", v28, v29, v30, v31, v32, v33, v34, v27);
    uint64_t v25 = 92;
    uint64_t v26 = 1299;
    goto LABEL_13;
  }
  if (a6 <= 7)
  {
    char v17 = sub_10003D8BC(v16);
    sub_10004458C("%s (id %llu): invalid value length (%u)\n", v18, v19, v20, v21, v22, v23, v24, v17);
    uint64_t v25 = 92;
    uint64_t v26 = 1300;
LABEL_13:
    sub_100048B34((char *)v26, 92);
    goto LABEL_14;
  }
  if ((*(void *)a3 & 0xFFFFFFFFFFFFFFFLL) != 9)
  {
    char v37 = sub_10003D8BC(v16);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v38, v39, v40, v41, v42, v43, v44, v37);
    uint64_t v25 = 92;
    uint64_t v26 = 1301;
    goto LABEL_13;
  }
  unint64_t v35 = *(void *)(a7 + 40);
  if (v35 <= 9)
  {
    unint64_t v35 = 10;
    *(void *)(a7 + 40) = 10;
  }
  unint64_t v36 = *(void *)(a3 + 12);
  if (v36 > 0xF)
  {
    unint64_t v49 = v36 + 1;
    if (v35 < v49) {
      *(void *)(a7 + 40) = v49;
    }
  }
  else
  {
    sub_100044674("clone mapping (private_id %llu, file_id %llu): invalid private_id\n", a2, a3, a4, a5, a6, a7, (uint64_t)a8, *(void *)(a3 + 12));
    sub_100048B34((char *)0x516, -2);
  }
  unint64_t v50 = *(void *)(a3 + 20);
  if (v50 > 0xF)
  {
    unint64_t v51 = v50 + 1;
    if (*(void *)(a7 + 40) < v51) {
      *(void *)(a7 + 40) = v51;
    }
  }
  else
  {
    sub_100044674("clone mapping (private_id %llu, file_id %llu): invalid file_id\n", a2, a3, a4, a5, a6, a7, (uint64_t)a8, *(void *)(a3 + 12));
    sub_100048B34((char *)0x517, -2);
  }
  uint64_t v52 = *(void *)a5;
  unint64_t v53 = *(void *)a5 & 0xFFFFFFFFFFFFFFLL;
  uint64_t v54 = HIBYTE(*(void *)a5);
  uint64_t v55 = *(void *)(a1 + 8);
  unint64_t v56 = *(unsigned int *)(v55 + 36);
  unint64_t v73 = v53;
  if (v53 % v56 || v53 / v56 > *(void *)(v55 + 40))
  {
    sub_100044674("clone mapping (private_id %llu, file_id %llu): invalid physical_size (%llu)\n", a2, a3, a4, a5, a6, a7, (uint64_t)a8, *(void *)(a3 + 12));
    sub_100048B34((char *)0x518, 92);
  }
  if (v54 >= 2)
  {
    sub_100044674("clone mapping (private_id %llu, file_id %llu): unknown flags (0x%x)\n", a2, a3, a4, a5, a6, a7, (uint64_t)a8, *(void *)(a3 + 12));
    if (*(void *)(*(void *)(a1 + 8) + 1384) <= 0x83B5A93981BC1uLL
      && sub_10004641C(qword_100091B70, "Unset invalid flags? (0x%llx) ", v57, v58, v59, v60, v61, v62, v54 & 0xFE))
    {
      *(void *)a5 = v52 & 0x1FFFFFFFFFFFFFFLL;
      *a8 = 1;
    }
    sub_100048B34((char *)0x554, -3);
  }
  uint64_t v74 = 0;
  uint64_t v75 = 0;
  uint64_t v63 = sub_100015A6C(a1, a2, a3, (unsigned __int16 *)(a5 + 8), (a6 - 8), (uint64_t (*)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t))sub_100018E30, a7, a8, (uint64_t)&v74);
  if (!v63)
  {
    if (v75)
    {
      uint64_t v25 = sub_100008170(v75, v73);
      if (v25) {
        goto LABEL_14;
      }
    }
    if (v74)
    {
      uint64_t v25 = sub_100019770(v74, v73);
      if (v25) {
        goto LABEL_14;
      }
      uint64_t v71 = v74;
    }
    else
    {
      uint64_t v71 = 0;
    }
    uint64_t v25 = sub_100003544(*(void *)(a3 + 12), *(void *)(a3 + 20), (void *)a5, v75, v71);
    if (!v25) {
      return v25;
    }
    goto LABEL_14;
  }
  uint64_t v25 = v63;
  sub_10004458C("clone mapping (private_id %llu, file_id %llu): invalid xfields\n", v64, v65, v66, v67, v68, v69, v70, *(void *)(a3 + 12));
LABEL_14:
  sub_100044868(a2, a3, a4, a5, a6, v45, v46, v47, v72);
  return v25;
}

uint64_t sub_10001578C(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v11 = a2[6];
  if (!v11) {
    uint64_t v11 = a2[5];
  }
  if ((*(unsigned char *)(v11 + 56) & 0x20) != 0)
  {
    if (!(*a3 >> 60))
    {
      uint64_t v29 = sub_100017AFC(a1, a2, a3, a5, a7, a8);
      if (!v29) {
        return v29;
      }
      goto LABEL_8;
    }
    char v21 = sub_10003D8BC(8u);
    sub_10004458C("%s (id %llu): ID larger than MAX_JOBJ_ID (%llu)\n", v22, v23, v24, v25, v26, v27, v28, v21);
    uint64_t v20 = 920;
  }
  else
  {
    char v12 = sub_10003D8BC(8u);
    sub_10004458C("%s (id %llu): fext tree record present on non-sealed volume\n", v13, v14, v15, v16, v17, v18, v19, v12);
    uint64_t v20 = 919;
  }
  uint64_t v29 = 92;
  sub_100048B34((char *)v20, 92);
LABEL_8:
  sub_1000447FC((uint64_t)a2, a3, a5, v30, v31, v32, v33, v34);
  return v29;
}

char *sub_100015870(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    sub_10000A8D8(a1);
  }
  sub_10000D224(a2);
  sub_100008B98(a2);
  sub_100027AA4(a2);
  sub_100019080(a2);
  sub_100007CFC();

  return sub_100002E10();
}

uint64_t sub_1000158D0(uint64_t a1)
{
  sub_10000D300();
  sub_100008C74();
  sub_10002C3F8();
  sub_10001914C();
  sub_100007DD0();
  sub_100002EF8();
  uint64_t result = sub_100020DF0();
  *(unsigned char *)(a1 + 10) = 0;
  return result;
}

uint64_t sub_100015910(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v11 = sub_10000D338(0xFFFFFFFFFFFFFFFFLL, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  LODWORD(result) = sub_1000273C8(a1, a2, a3, v12, v13, v14, v15, v16);
  if (result) {
    return result;
  }
  else {
    return v11;
  }
}

uint64_t sub_100015964(uint64_t *a1, void *a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3) {
    unsigned int v12 = 0;
  }
  else {
    unsigned int v12 = sub_10000B01C(a1, (uint64_t)a2, (uint64_t)a4);
  }
  unsigned int v13 = sub_10000DD5C(a1, (uint64_t)a2, a4, (uint64_t)a4, a5, a6, a7, a8);
  if (v13) {
    unsigned int v12 = v13;
  }
  unsigned int v14 = sub_1000090C0((uint64_t)a1, (uint64_t)a2, a4);
  if (v14) {
    unsigned int v12 = v14;
  }
  unsigned int v20 = sub_1000273C8((uint64_t)a1, (uint64_t)a2, a4, v15, v16, v17, v18, v19);
  if (v20) {
    unsigned int v25 = v20;
  }
  else {
    unsigned int v25 = v12;
  }
  sub_10002C39C((uint64_t)a1, (uint64_t)a2, a3, a4, v21, v22, v23, v24);
  unsigned int v27 = v26;
  if (!(sub_100002F30((uint64_t)a1, (uint64_t)a2, a4) | v26)) {
    unsigned int v27 = v25;
  }
  unsigned int v28 = sub_1000198F0((uint64_t)a1, a2, a4);
  if (v28) {
    unsigned int v29 = v28;
  }
  else {
    unsigned int v29 = v27;
  }
  LODWORD(result) = sub_100008290((uint64_t)a1, a2, a3);
  if (result) {
    return result;
  }
  else {
    return v29;
  }
}

uint64_t sub_100015A6C(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 *a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, unsigned __int16 *, unint64_t, uint64_t, uint64_t, _DWORD *, uint64_t), uint64_t a7, _DWORD *a8, uint64_t a9)
{
  if (a5 >= 4)
  {
    uint64_t v11 = *a4;
    if ((unint64_t)a4[1] + 4 * v11 + 4 <= a5)
    {
      if (!*a4)
      {
        unsigned int v20 = 0;
LABEL_15:
        if (v20 < a4[1])
        {
          sub_100044674("xf: xf_used_data (%u) is larger than expected (%u)\n", a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, (uint64_t)a8, a4[1]);
          sub_100048B34((char *)0x44C, -11);
          if (sub_10004641C(qword_100091B70, "Fix xf_used_data? ", v25, v26, v27, v28, v29, v30, v40))
          {
            uint64_t v9 = 0;
            a4[1] = v20;
            *a8 = 1;
            return v9;
          }
        }
        return 0;
      }
      unint64_t v18 = 0;
      unsigned int v19 = 0;
      unsigned int v20 = 0;
      uint64_t v41 = (uint64_t)&a4[2 * v11 + 2];
      uint64_t v21 = a4 + 3;
      do
      {
        if ((int)(a4[1] - v19) < *v21)
        {
          uint64_t v31 = *(void *)a3 >> 60;
          if (v31 == 14) {
            LODWORD(v31) = *(unsigned __int8 *)(a3 + 8);
          }
          char v32 = sub_10003D8BC(v31);
          sub_10003D8EC(a3, *((unsigned __int8 *)v21 - 2));
          sub_10004458C("%s (id %llu): xf %u/%u: %s: extended field at offset %u+%u extends beyond xf_used_data (%u)\n", v33, v34, v35, v36, v37, v38, v39, v32);
          uint64_t v9 = 92;
          uint64_t v12 = 899;
          goto LABEL_5;
        }
        uint64_t v22 = a6(a1, a2, a3, a4, v18, v41 + v19, a7, a8, a9);
        if (v22) {
          return v22;
        }
        int v23 = *v21;
        v21 += 2;
        int v24 = (v23 + 7) & 0x1FFF8;
        v20 += v24;
        ++v18;
        v19 += v24;
      }
      while (v18 < *a4);
      if (v20 < 0x10000) {
        goto LABEL_15;
      }
      sub_10004458C("xf: xf total size (%u) is larger than UINT16_MAX\n", a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, (uint64_t)a8, v20);
      uint64_t v9 = 92;
      uint64_t v12 = 1099;
    }
    else
    {
      sub_10004458C("xf: xf_num_exts (%u) extended fields do not fit in the given xf_used_data (%u)\n", a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, (uint64_t)a8, *a4);
      uint64_t v9 = 92;
      uint64_t v12 = 191;
    }
LABEL_5:
    sub_100048B34((char *)v12, 92);
    return v9;
  }
  return 0;
}

uint64_t sub_100015C9C(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, int a5, UInt8 *bytes, uint64_t a7, _DWORD *a8, uint64_t a9)
{
  uint64_t v14 = a4 + 4 * a5;
  uint64_t v15 = *(void *)(a9 + 40);
  unsigned int v18 = *(unsigned __int8 *)(v14 + 4);
  uint64_t v17 = (unsigned __int8 *)(v14 + 4);
  uint64_t v16 = v18;
  CFIndex v19 = *((unsigned __int16 *)v17 + 1);
  if (v18 > 0x14 || ((0x251uLL >> v16) & 1) != 0 || word_10006F1E0[v16] == v19)
  {
    uint64_t v29 = 0;
    switch((int)v16)
    {
      case 1:
      case 2:
      case 6:
      case 7:
      case 9:
        char v32 = a2;
        uint64_t v33 = a7;
        uint64_t v34 = *(void *)a3 >> 60;
        if (v34 == 14) {
          LODWORD(v34) = *(unsigned __int8 *)(a3 + 8);
        }
        char v35 = sub_10003D8BC(v34);
        sub_10003D8EC(a3, *v17);
        sub_100044674("%s (id %llu): xf %u/%u: %s: extended field type is no longer used\n", v36, v37, v38, v39, v40, v41, v42, v35);
        uint64_t v43 = 987;
        goto LABEL_12;
      case 3:
        *(_DWORD *)uu = *(_DWORD *)bytes;
        uint64_t v352 = a7;
        int v354 = *(_DWORD *)uu;
        v351 = a2;
        if (*(_DWORD *)uu <= 2u)
        {
          uint64_t v72 = *(void *)a3 >> 60;
          if (v72 == 14) {
            LODWORD(v72) = *(unsigned __int8 *)(a3 + 8);
          }
          char v349 = sub_10003D8BC(v72);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: invalid doc_id (%u), less than MIN_DOC_ID (%u)\n", v73, v74, v75, v76, v77, v78, v79, v349);
          sub_100048B34((char *)0xC2, -2);
          a2 = v351;
          a7 = v352;
        }
        int v80 = *(_DWORD *)(v15 + 68);
        if ((v80 & 0x40) != 0) {
          goto LABEL_35;
        }
        int v350 = v80 | 0x40;
        uint64_t v81 = *(void *)a3 >> 60;
        if (v81 == 14) {
          LODWORD(v81) = *(unsigned __int8 *)(a3 + 8);
        }
        char v348 = sub_10003D8BC(v81);
        sub_10003D8EC(a3, *v17);
        sub_10004458C("%s (id %llu): xf %u/%u: %s: doc_id exists (%u), despite bsd_flags (0x%x)\n", v82, v83, v84, v85, v86, v87, v88, v348);
        uint64_t v29 = 92;
        sub_100048B34((char *)0x44D, 92);
        if (sub_10004641C(qword_100091B70, "Set bsd_flags to 0x%x? ", v89, v90, v91, v92, v93, v94, v350))
        {
          *(_DWORD *)(v15 + 68) = v350;
          *a8 = 1;
          a2 = v351;
          a7 = v352;
LABEL_35:
          if (*(_DWORD *)(a7 + 48) < (v354 + 1)) {
            *(_DWORD *)(a7 + 48) = v354 + 1;
          }
          uint64_t v95 = sub_10000725C(a1, a2, *(void *)a3 & 0xFFFFFFFFFFFFFFFLL, uu, a7, a8);
          if (v95)
          {
            uint64_t v29 = v95;
            uint64_t v96 = *(void *)a3 >> 60;
            if (v96 == 14) {
              LODWORD(v96) = *(unsigned __int8 *)(a3 + 8);
            }
            char v97 = sub_10003D8BC(v96);
            sub_10003D8EC(a3, *v17);
            sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid doc_id index\n", v98, v99, v100, v101, v102, v103, v104, v97);
          }
          else
          {
            if (*a8) {
              *(_DWORD *)bytes = *(_DWORD *)uu;
            }
            uint64_t v29 = 0;
            *(unsigned char *)a9 = 1;
          }
        }
        return v29;
      case 4:
        if (bytes[v19 - 1])
        {
          uint64_t v105 = *(void *)a3 >> 60;
          if (v105 == 14) {
            LODWORD(v105) = *(unsigned __int8 *)(a3 + 8);
          }
          char v106 = sub_10003D8BC(v105);
          sub_10003D8EC(a3, *v17);
          sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid name (%.*s), given name_len (%u)\n", v107, v108, v109, v110, v111, v112, v113, v106);
          uint64_t v29 = 92;
          uint64_t v30 = 196;
          goto LABEL_7;
        }
        if (!sub_100010914(bytes, v19)) {
          return 0;
        }
        uint64_t v261 = *(void *)a3 >> 60;
        if (v261 == 14) {
          LODWORD(v261) = *(unsigned __int8 *)(a3 + 8);
        }
        char v262 = sub_10003D8BC(v261);
        sub_10003D8EC(a3, *v17);
        sub_100044674("%s (id %llu): xf %u/%u: %s: invalid name (%s)\n", v263, v264, v265, v266, v267, v268, v269, v262);
        uint64_t v70 = 197;
        int v71 = -9;
        goto LABEL_25;
      case 5:
      case 12:
      case 15:
      case 16:
      case 18:
        return v29;
      case 8:
        long long v114 = *((_OWORD *)bytes + 1);
        *(_OWORD *)uu = *(_OWORD *)bytes;
        long long v356 = v114;
        uint64_t v357 = *((void *)bytes + 4);
        if ((*(_WORD *)(v15 + 80) & 0xF000) == 0x8000)
        {
          uint64_t v353 = a7;
          uint64_t v115 = (uint64_t *)a2;
          uint64_t v116 = sub_10001726C((uint64_t)a1, (uint64_t)a2, (uint64_t *)a3, v15, uu, a7, a8);
          if (v116)
          {
            uint64_t v29 = v116;
            uint64_t v119 = *(void *)a3 >> 60;
            if (v119 == 14) {
              LODWORD(v119) = *(unsigned __int8 *)(a3 + 8);
            }
            char v120 = sub_10003D8BC(v119);
            sub_10003D8EC(a3, *v17);
            sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid dstream\n", v121, v122, v123, v124, v125, v126, v127, v120);
            return v29;
          }
          uint64_t v291 = *(void *)(v15 + 8);
          uint64_t v292 = *(void *)&uu[8];
          if (v291)
          {
            uint64_t v293 = *(void *)&uu[8];
            uint64_t v294 = sub_10000D454(*(void *)a3 & 0xFFFFFFFFFFFFFFFLL, v291, *(uint64_t *)&uu[8], 1, (*(void *)(v15 + 48) >> 7) & 1, (*(void *)(v15 + 48) >> 22) & 1, v117, v118);
            uint64_t v292 = v293;
            if (v294)
            {
              uint64_t v29 = v294;
              uint64_t v295 = *(void *)a3 >> 60;
              if (v295 == 14) {
                LODWORD(v295) = *(unsigned __int8 *)(a3 + 8);
              }
              char v296 = sub_10003D8BC(v295);
              sub_10003D8EC(a3, *v17);
              sub_10004458C("%s (id %llu): xf %u/%u: %s: failed to register dstream: %d\n", v297, v298, v299, v300, v301, v302, v303, v296);
              return v29;
            }
          }
          *(void *)(a9 + 16) = v292;
          uint64_t v322 = v115[6];
          if (!v322) {
            uint64_t v322 = v115[5];
          }
          if ((*(unsigned char *)(v322 + 56) & 0x20) == 0)
          {
            sub_100008EE4(*(void *)a3 & 0xFFFFFFFFFFFFFFFLL, (uint64_t)uu);
            if (v323)
            {
              uint64_t v29 = v323;
              uint64_t v328 = *(void *)a3 >> 60;
              if (v328 == 14) {
                LODWORD(v328) = *(unsigned __int8 *)(a3 + 8);
              }
              char v329 = sub_10003D8BC(v328);
              sub_10003D8EC(a3, *v17);
              sub_10004458C("%s (id %llu): xf %u/%u: %s: failed to register dstream for crypto state tracking: %d\n", v330, v331, v332, v333, v334, v335, v336, v329);
              return v29;
            }
            unint64_t v346 = *(void *)(v15 + 8);
            if (v346 < (*(void *)a3 & 0xFFFFFFFFFFFFFFFuLL)
              && (*(unsigned char *)(v15 + 50) & 0x40) != 0
              && *(void *)(v353 + 56))
            {
              sub_1000179E0((uint64_t)a1, v115, v346, v353, v324, v325, v326, v327);
            }
          }
          if (*a8)
          {
            long long v347 = v356;
            *(_OWORD *)bytes = *(_OWORD *)uu;
            *((_OWORD *)bytes + 1) = v347;
            *((void *)bytes + 4) = v357;
          }
        }
        else
        {
          int v206 = a2;
          uint64_t v207 = a7;
          uint64_t v208 = *(void *)a3 >> 60;
          if (v208 == 14) {
            LODWORD(v208) = *(unsigned __int8 *)(a3 + 8);
          }
          char v209 = sub_10003D8BC(v208);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found unexpected dstream associated with non-regular file\n", v210, v211, v212, v213, v214, v215, v216, v209);
          if (*(void *)(v207 + 56)) {
            uint64_t v223 = 0;
          }
          else {
            uint64_t v223 = v206 + 44;
          }
          uint64_t v224 = sub_10000D770(v223, *(void *)a3, v217, v218, v219, v220, v221, v222);
          if (v224)
          {
            uint64_t v29 = v224;
            uint64_t v225 = *(void *)a3 >> 60;
            if (v225 == 14) {
              LODWORD(v225) = *(unsigned __int8 *)(a3 + 8);
            }
            char v226 = sub_10003D8BC(v225);
            sub_10003D8EC(a3, *v17);
            sub_100044674("%s (id %llu): xf %u/%u: %s: unable to remove dstream of non-regular inode\n", v227, v228, v229, v230, v231, v232, v233, v226);
            return v29;
          }
        }
        uint64_t v29 = 0;
        *(unsigned char *)(a9 + 3) = 1;
        return v29;
      case 10:
        uint64_t v128 = *(void *)bytes;
        if (*(void *)bytes <= 0xFuLL && (unint64_t)(v128 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v129 = a7;
          uint64_t v130 = *(void *)a3 >> 60;
          if (v130 == 14) {
            LODWORD(v130) = *(unsigned __int8 *)(a3 + 8);
          }
          char v131 = sub_10003D8BC(v130);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: invalid dir_stats_key (%llu)\n", v132, v133, v134, v135, v136, v137, v138, v131);
          sub_100048B34((char *)0xC7, -2);
          a7 = v129;
        }
        uint64_t v139 = *(void *)(v15 + 48);
        if ((v139 & 4) != 0
          && (uint64_t v140 = a7, sub_100019630(v128, *(void *)a3 & 0xFFFFFFFFFFFFFFFLL, v139), a7 = v140, v141))
        {
          uint64_t v29 = v141;
          uint64_t v142 = *(void *)a3 >> 60;
          if (v142 == 14) {
            LODWORD(v142) = *(unsigned __int8 *)(a3 + 8);
          }
          char v143 = sub_10003D8BC(v142);
          sub_10003D8EC(a3, *v17);
          sub_10004458C("%s (id %llu): xf %u/%u: %s: failed to register dir-stats (%llu) origin: %d\n", v144, v145, v146, v147, v148, v149, v150, v143);
        }
        else
        {
          if (*(void *)(a7 + 40) < (unint64_t)(v128 + 1)) {
            *(void *)(a7 + 40) = v128 + 1;
          }
          uint64_t v29 = 0;
          *(unsigned char *)(a9 + 2) = 1;
          *(void *)(a9 + 8) = v128;
        }
        return v29;
      case 11:
        *(_OWORD *)uu = *(_OWORD *)bytes;
        if (!uuid_is_null(uu)) {
          return 0;
        }
        uint64_t v151 = *(void *)a3 >> 60;
        if (v151 == 14) {
          LODWORD(v151) = *(unsigned __int8 *)(a3 + 8);
        }
        char v152 = sub_10003D8BC(v151);
        sub_10003D8EC(a3, *v17);
        sub_10004458C("%s (id %llu): xf %u/%u: %s: uuid is NULL\n", v153, v154, v155, v156, v157, v158, v159, v152);
        uint64_t v29 = 92;
        uint64_t v30 = 200;
        goto LABEL_7;
      case 13:
        if ((*(unsigned char *)(v15 + 49) & 2) == 0)
        {
          uint64_t v160 = *(void *)a3 >> 60;
          if (v160 == 14) {
            LODWORD(v160) = *(unsigned __int8 *)(a3 + 8);
          }
          char v161 = sub_10003D8BC(v160);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: sparse_bytes set even though inode is not sparse\n", v162, v163, v164, v165, v166, v167, v168, v161);
          sub_100048B34((char *)0xC9, -5);
        }
        uint64_t v29 = 0;
        *(void *)(a9 + 24) = *(void *)bytes;
        *(unsigned char *)(a9 + 4) = 1;
        return v29;
      case 14:
        *(unsigned char *)(a9 + 1) = 1;
        if ((*(unsigned char *)(a2[2].i64[1] + 57) & 2) != 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v234 = *(void *)a3 >> 60;
          if (v234 == 14) {
            LODWORD(v234) = *(unsigned __int8 *)(a3 + 8);
          }
          char v235 = sub_10003D8BC(v234);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found rdev x-field but volume has rdev in core-inode\n", v236, v237, v238, v239, v240, v241, v242, v235);
          uint64_t v43 = 1156;
          goto LABEL_12;
        }
        if ((*(_WORD *)(v15 + 80) & 0xB000 | 0x4000) != 0x6000)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v304 = *(void *)a3 >> 60;
          if (v304 == 14) {
            LODWORD(v304) = *(unsigned __int8 *)(a3 + 8);
          }
          char v305 = sub_10003D8BC(v304);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found rdev x-field even though inode is not a char/block device\n", v306, v307, v308, v309, v310, v311, v312, v305);
          uint64_t v43 = 1157;
          goto LABEL_12;
        }
        if (!*(_DWORD *)bytes)
        {
          uint64_t v169 = *(void *)a3 >> 60;
          if (v169 == 14) {
            LODWORD(v169) = *(unsigned __int8 *)(a3 + 8);
          }
          char v170 = sub_10003D8BC(v169);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found zero rdev on char/block device (mode %u)\n", v171, v172, v173, v174, v175, v176, v177, v170);
          uint64_t v70 = 1212;
          int v71 = 92;
LABEL_25:
          sub_100048B34((char *)v70, v71);
        }
        return 0;
      case 17:
        uint64_t v178 = a2[2].i64[1];
        if ((*(unsigned char *)(v178 + 57) & 2) != 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v243 = *(void *)a3 >> 60;
          if (v243 == 14) {
            LODWORD(v243) = *(unsigned __int8 *)(a3 + 8);
          }
          char v244 = sub_10003D8BC(v243);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found nlink x-field but volume has dir-nlink in core-inode\n", v245, v246, v247, v248, v249, v250, v251, v244);
          uint64_t v43 = 1154;
          goto LABEL_12;
        }
        if ((*(unsigned char *)(v178 + 48) & 2) == 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v179 = *(void *)a3 >> 60;
          if (v179 == 14) {
            LODWORD(v179) = *(unsigned __int8 *)(a3 + 8);
          }
          char v180 = sub_10003D8BC(v179);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found nlink field but volume doesn't support it\n", v181, v182, v183, v184, v185, v186, v187, v180);
          uint64_t v43 = 984;
          goto LABEL_12;
        }
        if ((*(_WORD *)(v15 + 80) & 0xF000) != 0x4000)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v313 = *(void *)a3 >> 60;
          if (v313 == 14) {
            LODWORD(v313) = *(unsigned __int8 *)(a3 + 8);
          }
          char v314 = sub_10003D8BC(v313);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found nlink field even though inode is not a directory\n", v315, v316, v317, v318, v319, v320, v321, v314);
          uint64_t v43 = 985;
          goto LABEL_12;
        }
        unint64_t v270 = *(void *)bytes;
        if (*(void *)bytes <= (unint64_t)*(int *)(v15 + 56) || (*(unsigned char *)(v15 + 71) & 0x40) != 0)
        {
          if (!(v270 >> 31)) {
            goto LABEL_153;
          }
          uint64_t v337 = *(void *)a3 >> 60;
          if (v337 == 14) {
            LODWORD(v337) = *(unsigned __int8 *)(a3 + 8);
          }
          char v338 = sub_10003D8BC(v337);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: directory nlink value is invalid (%llu)\n", v339, v340, v341, v342, v343, v344, v345, v338);
          LODWORD(v270) = 0;
          uint64_t v280 = 1211;
        }
        else
        {
          uint64_t v271 = *(void *)a3 >> 60;
          if (v271 == 14) {
            LODWORD(v271) = *(unsigned __int8 *)(a3 + 8);
          }
          char v272 = sub_10003D8BC(v271);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: directory nlink value %lld is greater than nchildren (%d)\n", v273, v274, v275, v276, v277, v278, v279, v272);
          uint64_t v280 = 986;
        }
        sub_100048B34((char *)v280, -8);
LABEL_153:
        sub_10002C1F0(*(void *)a3 & 0xFFFFFFFFFFFFFFFLL, v270);
        return 0;
      case 19:
        if ((*(unsigned char *)(v15 + 51) & 0x20) != 0)
        {
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v252 = *(void *)a3 >> 60;
          if (v252 == 14) {
            LODWORD(v252) = *(unsigned __int8 *)(a3 + 8);
          }
          char v253 = sub_10003D8BC(v252);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found attribution tag on an inode with unsupported flags\n", v254, v255, v256, v257, v258, v259, v260, v253);
          uint64_t v43 = 1336;
        }
        else
        {
          if ((*(unsigned char *)(a2[2].i64[1] + 48) & 8) != 0)
          {
            uint64_t v281 = *(void *)bytes;
            *(void *)(a9 + 32) = *(void *)bytes;
            if (!v281)
            {
              uint64_t v282 = *(void *)a3 >> 60;
              if (v282 == 14) {
                LODWORD(v282) = *(unsigned __int8 *)(a3 + 8);
              }
              char v283 = sub_10003D8BC(v282);
              sub_10003D8EC(a3, *v17);
              sub_100044674("%s (id %llu): xf %u/%u: %s: invalid hash: (0)\n", v284, v285, v286, v287, v288, v289, v290, v283);
              sub_100048B34((char *)0x524, -7);
            }
            uint64_t v29 = 0;
            *(unsigned char *)(a9 + 5) = 1;
            return v29;
          }
          char v32 = a2;
          uint64_t v33 = a7;
          uint64_t v188 = *(void *)a3 >> 60;
          if (v188 == 14) {
            LODWORD(v188) = *(unsigned __int8 *)(a3 + 8);
          }
          char v189 = sub_10003D8BC(v188);
          sub_10003D8EC(a3, *v17);
          sub_100044674("%s (id %llu): xf %u/%u: %s: found attribution tag on a volume that doesn't support them\n", v190, v191, v192, v193, v194, v195, v196, v189);
          uint64_t v43 = 1315;
        }
LABEL_12:
        int v44 = -5;
LABEL_13:
        sub_100048B34((char *)v43, v44);
        if (*(void *)(v33 + 56)) {
          unint64_t v50 = 0;
        }
        else {
          unint64_t v50 = v32 + 44;
        }
        uint64_t v29 = sub_100026DD0(v50, *(void *)a3, *v17, v45, v46, v47, v48, v49);
        if (v29)
        {
          uint64_t v51 = *(void *)a3 >> 60;
          if (v51 == 14) {
            LODWORD(v51) = *(unsigned __int8 *)(a3 + 8);
          }
          char v52 = sub_10003D8BC(v51);
          sub_10003D8EC(a3, *v17);
          strerror(v29);
          sub_10004458C("%s (id %llu): xf %u/%u: %s: unable to add repair for unexpected xfield: %s\n", v53, v54, v55, v56, v57, v58, v59, v52);
          uint64_t v30 = 1213;
          int v31 = v29;
          goto LABEL_20;
        }
        return v29;
      case 20:
        if ((~*(_DWORD *)(v15 + 48) & 0x20000004) == 0) {
          return 0;
        }
        char v32 = a2;
        uint64_t v33 = a7;
        uint64_t v197 = *(void *)a3 >> 60;
        if (v197 == 14) {
          LODWORD(v197) = *(unsigned __int8 *)(a3 + 8);
        }
        char v198 = sub_10003D8BC(v197);
        sub_10003D8EC(a3, *v17);
        sub_10004458C("%s (id %llu): xf %u/%u: %s: inode is expected to be an SAF dir-stats origin\n", v199, v200, v201, v202, v203, v204, v205, v198);
        uint64_t v43 = 1470;
        int v44 = 92;
        goto LABEL_13;
      default:
        uint64_t v61 = *(void *)a3 >> 60;
        if (v61 == 14) {
          LODWORD(v61) = *(unsigned __int8 *)(a3 + 8);
        }
        char v62 = sub_10003D8BC(v61);
        sub_10003D8EC(a3, *v17);
        sub_100044674("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v63, v64, v65, v66, v67, v68, v69, v62);
        uint64_t v70 = 202;
        int v71 = -5;
        goto LABEL_25;
    }
  }
  uint64_t v20 = *(void *)a3 >> 60;
  if (v20 == 14) {
    LODWORD(v20) = *(unsigned __int8 *)(a3 + 8);
  }
  char v21 = sub_10003D8BC(v20);
  sub_10003D8EC(a3, *v17);
  sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid extended field size %u, expected %u\n", v22, v23, v24, v25, v26, v27, v28, v21);
  uint64_t v29 = 92;
  uint64_t v30 = 983;
LABEL_7:
  int v31 = 92;
LABEL_20:
  sub_100048B34((char *)v30, v31);
  return v29;
}

uint64_t sub_100016CE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, _DWORD *a6)
{
  uint64_t v12 = *(void *)(a4 + 40);
  char v147 = 0;
  uint64_t v13 = *(void *)(v12 + 48);
  if ((v13 & 6) != 0 && !*(unsigned char *)(a4 + 2))
  {
    unint64_t v14 = v13 & 0xFFFFFFFFFFFFFFF9;
    char v15 = sub_10003D8BC(*a5 >> 60);
    sub_100044674("%s (id %llu): dir-stats key xf does not exist, despite internal_flags (0x%llx)\n", v16, v17, v18, v19, v20, v21, v22, v15);
    sub_100048B34((char *)0x4CD, -3);
    if (sub_10004641C(qword_100091B70, "Set internal_flags to 0x%llx? ", v23, v24, v25, v26, v27, v28, v14))
    {
      *(void *)(v12 + 48) = v14;
      *a6 = 1;
    }
  }
  if (*(unsigned char *)(a4 + 4) && !*(unsigned char *)(a4 + 3))
  {
    char v29 = sub_10003D8BC(*a5 >> 60);
    sub_10004458C("%s (id %llu): dstream xf does not exist, despite existence of sparse bytes xf\n", v30, v31, v32, v33, v34, v35, v36, v29);
    sub_100048B34((char *)0x4EA, -5);
    *(void *)(a4 + 16) = 0;
    *(void *)(a4 + 24) = 0;
  }
  uint64_t v146 = a3;
  if (!*(unsigned char *)(a4 + 2))
  {
    unint64_t v39 = *(void *)(a4 + 24);
    unint64_t v41 = *(void *)(a4 + 16);
    if (v39 > v41 && v41 != 0)
    {
      uint64_t v37 = a6;
      BOOL v40 = 0;
      goto LABEL_25;
    }
    goto LABEL_33;
  }
  uint64_t v37 = a6;
  unint64_t v38 = *(void *)(v12 + 48);
  unint64_t v39 = *(void *)(a4 + 24);
  BOOL v40 = (v38 & 6) == 2;
  unint64_t v41 = *(void *)(a4 + 16);
  if (v39 <= v41 || v41 == 0)
  {
    if ((v38 & 6) == 2)
    {
      BOOL v43 = v41 >= v39;
      uint64_t v44 = v41 - v39;
      if (v43) {
        uint64_t v45 = v44;
      }
      else {
        uint64_t v45 = 0;
      }
      sub_100019574(*(void *)(a4 + 8), v45, (v38 >> 29) & 1);
      if (v46)
      {
        uint64_t v47 = v46;
        char v48 = sub_10003D8BC(*a5 >> 60);
        sub_10004458C("%s (id %llu): failed to register dir-stats (%llu) descendant: %d\n", v49, v50, v51, v52, v53, v54, v55, v48);
        return v47;
      }
      if ((*(_WORD *)(v12 + 80) & 0xF000) == 0x8000)
      {
        a6 = v37;
        if (*(_DWORD *)(v12 + 56) == 1
          && (*(void *)(v12 + 48) & 0x180000) == 0x80000
          && (*(_DWORD *)(v12 + 68) & 0x40000020) != 0x20)
        {
          sub_1000197F8(*(void *)(a4 + 8), v45);
          if (v122)
          {
            uint64_t v47 = v122;
            char v123 = sub_10003D8BC(*a5 >> 60);
            sub_10004458C("%s (id %llu): failed to register dir-stats (%llu) purgeable_size: %d\n", v124, v125, v126, v127, v128, v129, v130, v123);
            return v47;
          }
        }
      }
      else
      {
        a6 = v37;
      }
      goto LABEL_37;
    }
    a6 = v37;
LABEL_33:
    if (!*(unsigned char *)(a4 + 5))
    {
LABEL_40:
      char v60 = 0;
      goto LABEL_41;
    }
    BOOL v43 = v41 >= v39;
    uint64_t v61 = v41 - v39;
    if (v43) {
      uint64_t v45 = v61;
    }
    else {
      uint64_t v45 = 0;
    }
LABEL_37:
    if (*(unsigned char *)(a4 + 5))
    {
      sub_100008084(*a5 & 0xFFFFFFFFFFFFFFFLL, *(void *)(a4 + 32), v45);
      if (v62)
      {
        uint64_t v47 = v62;
        char v63 = sub_10003D8BC(*a5 >> 60);
        sub_10004458C("%s (id %llu): failed to register attribution tag: %d\n", v64, v65, v66, v67, v68, v69, v70, v63);
        return v47;
      }
    }
    goto LABEL_40;
  }
LABEL_25:
  uint64_t v57 = sub_10003E760(a1, a2, *(void *)(v146 + 56), *a5 & 0xFFFFFFFFFFFFFFFLL, &v147);
  if (v57)
  {
    uint64_t v47 = v57;
    uint64_t v58 = 1333;
    int v59 = v47;
LABEL_27:
    sub_100048B34((char *)v58, v59);
    return v47;
  }
  if (!v147)
  {
    char v114 = sub_10003D8BC(*a5 >> 60);
    sub_10004458C("%s (id %llu): number of sparse bytes (%llu) is larger than alloced_size (%llu)\n", v115, v116, v117, v118, v119, v120, v121, v114);
    uint64_t v47 = 92;
    uint64_t v58 = 1259;
    int v59 = 92;
    goto LABEL_27;
  }
  if (v40 || (*(unsigned char *)(v12 + 51) & 0x10) != 0)
  {
    char v99 = sub_10003D8BC(*a5 >> 60);
    sub_100044674("%s (id %llu): sparse bytes mismatch for a file in the purgatory\n", v100, v101, v102, v103, v104, v105, v106, v99);
    unint64_t v107 = *(void *)(v12 + 48) & 0xFFFFFFFFEFFFFFFDLL;
    char v60 = 1;
    if (sub_10004641C(qword_100091B70, "Set internal_flags to 0x%llx? ", v108, v109, v110, v111, v112, v113, *(unsigned char *)(v12 + 48) & 0xFD))
    {
      *(void *)(v12 + 48) = v107;
      a6 = v37;
      *uint64_t v37 = 1;
      goto LABEL_41;
    }
  }
  else
  {
    char v60 = 1;
  }
  a6 = v37;
LABEL_41:
  int v71 = *(_DWORD *)(v12 + 68);
  if ((v71 & 0x40) != 0 && !*(unsigned char *)a4)
  {
    unsigned int v72 = v71 & 0xFFFFFFBF;
    char v73 = sub_10003D8BC(*a5 >> 60);
    sub_10004458C("%s (id %llu): doc_id xf does not exist, despite bsd_flags (0x%x)\n", v74, v75, v76, v77, v78, v79, v80, v73);
    uint64_t v47 = 92;
    sub_100048B34((char *)0x44E, 92);
    if (!sub_10004641C(qword_100091B70, "Set bsd_flags to 0x%x? ", v81, v82, v83, v84, v85, v86, v72)) {
      return v47;
    }
    *(_DWORD *)(v12 + 68) = v72;
    *a6 = 1;
  }
  if ((*(_WORD *)(v12 + 80) & 0xB000 | 0x4000) == 0x6000 && !*(unsigned char *)(a4 + 1))
  {
    char v87 = sub_10003D8BC(*a5 >> 60);
    sub_100044674("%s (id %llu): no rdev xf on char/block device (mode %u)\n", v88, v89, v90, v91, v92, v93, v94, v87);
  }
  unint64_t v95 = *(void *)(v12 + 48);
  if (*(unsigned char *)(a4 + 5) == ((v95 >> 28) & 1)) {
    return 0;
  }
  if (!*(unsigned char *)(a4 + 5) || (v95 & 0x10000000) != 0)
  {
    unint64_t v96 = v95 & 0xFFFFFFFFEFFFFFFFLL;
    uint64_t v97 = 1318;
    uint64_t v98 = "%s (id %llu): attribution tag xf does not exist, despite internal_flags (0x%llx)\n";
    goto LABEL_69;
  }
  if (v60)
  {
    if (v147) {
      return 0;
    }
    goto LABEL_68;
  }
  uint64_t v47 = sub_10003E760(a1, a2, *(void *)(v146 + 56), *a5 & 0xFFFFFFFFFFFFFFFLL, &v147);
  if (!v47 && !v147)
  {
    unint64_t v95 = *(void *)(v12 + 48);
LABEL_68:
    unint64_t v96 = v95 | 0x10000000;
    uint64_t v97 = 1317;
    uint64_t v98 = "%s (id %llu): attribution tag xf exists, despite internal_flags (0x%llx)\n";
LABEL_69:
    char v131 = sub_10003D8BC(*a5 >> 60);
    sub_100044674(v98, v132, v133, v134, v135, v136, v137, v138, v131);
    sub_100048B34((char *)v97, -3);
    if (sub_10004641C(qword_100091B70, "Set internal_flags to 0x%llx? ", v139, v140, v141, v142, v143, v144, v96))
    {
      uint64_t v47 = 0;
      *(void *)(v12 + 48) = v96;
      *a6 = 1;
      return v47;
    }
    return 0;
  }
  return v47;
}

uint64_t sub_10001726C(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t v9 = a3;
  unint64_t v12 = *(unsigned int *)(*(void *)(a1 + 8) + 36);
  uint64_t v13 = *(void *)(a2 + 40);
  unint64_t v14 = a5[1];
  if (v14 % v12)
  {
    uint64_t v186 = a4;
    char v15 = a5;
    char v16 = sub_10003D8BC((unint64_t)*a3 >> 60);
    uint64_t v17 = v9;
    sub_10004458C("%s (id %llu): dstream.alloced_size (%llu) is not a multiple of the block size (%u)\n", v18, v19, v20, v21, v22, v23, v24, v16);
    uint64_t v25 = 92;
    sub_100048B34((char *)0x381, 92);
    if (!sub_10004641C(qword_100091B70, "Truncate alloced_size to block size? ", v26, v27, v28, v29, v30, v31, v181))return v25; {
    unint64_t v14 = v15[1] / v12 * v12;
    }
    v15[1] = v14;
    *a7 = 1;
    uint64_t v9 = v17;
    a4 = v186;
    a5 = v15;
  }
  uint64_t v32 = *(void *)(a6 + 56);
  uint64_t v184 = a6;
  uint64_t v185 = a2;
  uint64_t v188 = a7;
  if (v32) {
    BOOL v33 = (*(unsigned char *)(*(void *)(a2 + 40) + 264) & 9) == 0;
  }
  else {
    BOOL v33 = 1;
  }
  BOOL v34 = 0;
  uint64_t v187 = v13;
  uint64_t v35 = *(void *)(v13 + 264);
  uint64_t v36 = a5[2];
  uint64_t v37 = v35 & 0x109;
  unint64_t v38 = *a5;
  if (v37) {
    BOOL v39 = v36 != -1;
  }
  else {
    BOOL v39 = 1;
  }
  if (v33 && v36 == -1 && a4 && !v37) {
    BOOL v34 = (*(unsigned char *)(a4 + 48) & 0x10) == 0;
  }
  unsigned __int8 v189 = 0;
  if (v38 > v14 || !v39 || (int v40 = 0, v34))
  {
    BOOL v41 = v33;
    BOOL v42 = v34;
    BOOL v43 = a5;
    uint64_t v44 = a4;
    uint64_t v45 = sub_10003E760(a1, v185, v32, *v9 & 0xFFFFFFFFFFFFFFFLL, &v189);
    uint64_t v46 = v9;
    uint64_t v25 = v45;
    if (v45) {
      return v25;
    }
    int v40 = v189;
    uint64_t v9 = v46;
    a4 = v44;
    a5 = v43;
    BOOL v34 = v42;
    BOOL v33 = v41;
  }
  if (v38 <= v14)
  {
    uint64_t v47 = v188;
  }
  else
  {
    uint64_t v47 = v188;
    if (!v40)
    {
      unint64_t v48 = *v9;
      if ((a4 || (v48 & 0xF000000000000000) != 0x4000000000000000) && (*(unsigned char *)(a4 + 48) & 0x80) != 0)
      {
        int v40 = 0;
      }
      else
      {
        uint64_t v49 = a4;
        uint64_t v50 = a5;
        char v51 = sub_10003D8BC(v48 >> 60);
        uint64_t v52 = v9;
        sub_10004458C("%s (id %llu): dstream.size (%llu) is greater than dstream.alloced_size (%llu)\n", v53, v54, v55, v56, v57, v58, v59, v51);
        uint64_t v25 = 92;
        sub_100048B34((char *)0xB8, 92);
        if (!sub_10004641C(qword_100091B70, "Truncate size to alloced size? ", v60, v61, v62, v63, v64, v65, v182))return v25; {
        *uint64_t v50 = v50[1];
        }
        *uint64_t v188 = 1;
        int v40 = v189;
        uint64_t v9 = v52;
        a4 = v49;
        a5 = v50;
      }
    }
  }
  if (v40) {
    char v66 = 1;
  }
  else {
    char v66 = v39;
  }
  if ((v66 & 1) == 0)
  {
    uint64_t v67 = a5;
    uint64_t v68 = a4;
    char v69 = sub_10003D8BC((unint64_t)*v9 >> 60);
    uint64_t v70 = v9;
    sub_10004458C("%s (id %llu): found dstream with unassigned default_crypto_id\n", v71, v72, v73, v74, v75, v76, v77, v69);
    uint64_t v25 = 92;
    sub_100048B34((char *)0x3F5, 92);
    if (!sub_10004641C(qword_100091B70, "Fix unassigned default_crypto_id? ", v78, v79, v80, v81, v82, v83, v183))return v25; {
    a5 = v67;
    }
    v67[2] = 4 * ((*(void *)(v187 + 264) & 0x108) != 0);
    *uint64_t v47 = 1;
    uint64_t v9 = v70;
    a4 = v68;
  }
  if (!v33) {
    return 0;
  }
  uint64_t v84 = *(void *)(v187 + 264);
  if (v84)
  {
    uint64_t v85 = a5[2];
    if (!*(void *)(v187 + 976))
    {
      if ((unint64_t)(v85 + 1) < 2) {
        return 0;
      }
      uint64_t v110 = a5;
      char v111 = sub_10003D8BC((unint64_t)*v9 >> 60);
      sub_10004458C("%s (id %llu): invalid dstream.default_crypto_id (%llu) on unencrypted volume, given apfs_fs_flags (0x%llx)\n", v112, v113, v114, v115, v116, v117, v118, v111);
      uint64_t v25 = 92;
      sub_100048B34((char *)0xBD, 92);
      if (!sub_10004641C(qword_100091B70, "Fix default_crypto_id (%llu)? ", v119, v120, v121, v122, v123, v124, v110[2]))return v25; {
      uint64_t v25 = 0;
      }
      v110[2] = 0;
LABEL_57:
      *uint64_t v47 = 1;
      return v25;
    }
  }
  else
  {
    uint64_t v85 = a5[2];
  }
  if (v85 == 1)
  {
    char v86 = sub_10003D8BC((unint64_t)*v9 >> 60);
    sub_10004458C("%s (id %llu): invalid dstream.default_crypto_id (%llu)\n", v87, v88, v89, v90, v91, v92, v93, v86);
    uint64_t v25 = 92;
    sub_100048B34((char *)0xB9, 92);
    return v25;
  }
  if (v36 == -1)
  {
    if (v189) {
      BOOL v125 = 0;
    }
    else {
      BOOL v125 = v34;
    }
    if (!v125) {
      return 0;
    }
    uint64_t v126 = a4;
    char v127 = sub_10003D8BC((unint64_t)*v9 >> 60);
    sub_10004458C("%s (id %llu): invalid internal_flags (0x%llx) given unassigned default_crypto_id\n", v128, v129, v130, v131, v132, v133, v134, v127);
    uint64_t v25 = 92;
    sub_100048B34((char *)0x534, 92);
    if (!sub_10004641C(qword_100091B70, "Fix internal flags (0x%llx)? ", v135, v136, v137, v138, v139, v140, *(void *)(v126 + 48)))return v25; {
    uint64_t v25 = 0;
    }
    *(void *)(v126 + 48) |= 0x10uLL;
    goto LABEL_57;
  }
  if ((*(void *)(v187 + 264) & 0x109) != 8)
  {
    if ((v84 & 1) == 0 && !(*(void *)(v187 + 976) | v85))
    {
      uint64_t v141 = a4;
      uint64_t v142 = a5;
      char v143 = sub_10003D8BC((unint64_t)*v9 >> 60);
      uint64_t v144 = v142;
      sub_10004458C("%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume, given apfs_fs_flags (0x%llx)\n", v145, v146, v147, v148, v149, v150, v151, v143);
      sub_100048B34((char *)0x34A, 92);
      uint64_t v158 = v185;
      if ((*(unsigned char *)(*(void *)(v185 + 40) + 57) & 2) == 0 || (~*(_DWORD *)(v141 + 68) & 0x40000020) != 0)
      {
        if ((*(void *)(v187 + 264) & 0x109) == 0x100
          && sub_10004641C(qword_100091B70, "Fix default_crypto_id (%llu)? ", v152, v153, v154, v155, v156, v157, v144[2]))
        {
          a5 = v144;
          v144[2] = 4;
          *uint64_t v47 = 1;
          uint64_t v169 = v184;
          goto LABEL_73;
        }
      }
      else
      {
        int v159 = sub_10000D770((_DWORD *)(v185 + 704), *v9, v152, v153, v154, v155, v156, v157);
        a5 = v144;
        if (!v159) {
          goto LABEL_68;
        }
        int v160 = v159;
        char v161 = sub_10003D8BC((unint64_t)*v9 >> 60);
        sub_100044674("%s (id %llu): unable to remove dstream of inode %llu\n", v162, v163, v164, v165, v166, v167, v168, v161);
        sub_100048B34((char *)0x58F, v160);
        uint64_t v158 = v185;
      }
      *(unsigned char *)(v158 + 13) = 1;
      a5 = v144;
    }
LABEL_68:
    unint64_t v170 = a5[2];
    if (v170 - 16 < 0xFFFFFFFFFFFFFFF1)
    {
      uint64_t v169 = v184;
      goto LABEL_79;
    }
    uint64_t v169 = v184;
    if (v170 - 2 < 2 || v170 == 5) {
      goto LABEL_80;
    }
    if (v170 != 4)
    {
LABEL_78:
      uint64_t v171 = a5;
      char v172 = sub_10003D8BC((unint64_t)*v9 >> 60);
      sub_100044674("%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume\n", v173, v174, v175, v176, v177, v178, v179, v172);
      sub_100048B34((char *)0xBC, -2);
      unint64_t v170 = v171[2];
LABEL_79:
      if (v170 == -1) {
        return 0;
      }
LABEL_80:
      if (*(void *)(v169 + 40) <= v170)
      {
        uint64_t v25 = 0;
        *(void *)(v169 + 40) = v170 + 1;
        return v25;
      }
      return 0;
    }
LABEL_73:
    if (*(void *)(v187 + 264))
    {
      unint64_t v170 = 4;
      if ((*(void *)(v187 + 264) & 0x109) == 0x100 || *(void *)(v187 + 976)) {
        goto LABEL_80;
      }
    }
    else if ((*(void *)(v187 + 264) & 0x109) == 0x100)
    {
      unint64_t v170 = 4;
      goto LABEL_80;
    }
    goto LABEL_78;
  }
  if (v84) {
    return 0;
  }
  uint64_t v94 = v9;
  uint64_t v25 = 0;
  if (v85 != 4 && !*(void *)(v187 + 976))
  {
    unint64_t v95 = a5;
    char v96 = sub_10003D8BC((unint64_t)*v94 >> 60);
    sub_10004458C("%s (id %llu): invalid dstream.default_crypto_id (%llu) on encrypted volume, given apfs_fs_flags (0x%llx)\n", v97, v98, v99, v100, v101, v102, v103, v96);
    uint64_t v25 = 92;
    sub_100048B34((char *)0xBA, 92);
    if (sub_10004641C(qword_100091B70, "Fix default_crypto_id (%llu)? ", v104, v105, v106, v107, v108, v109, v95[2]))
    {
      uint64_t v25 = 0;
      v95[2] = 4;
      goto LABEL_57;
    }
  }
  return v25;
}

uint64_t sub_1000179E0(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  memset(v16, 170, sizeof(v16));
  uint64_t result = sub_10003E25C(a1, a2, 8, &v18, a5, a6, a7, a8);
  if (!result)
  {
    v15[0] = a1;
    v15[1] = a2;
    v17[0] = a3 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000;
    v17[1] = 0;
    uint64_t v14 = 0;
    memset(v13, 0, sizeof(v13));
    uint64_t result = sub_10003889C((uint64_t)v13, v18, *(void *)(a4 + 56), v17, 0x10u, 0x10u, v16, 24);
    if (!result) {
      return sub_10002C46C((uint64_t)v13, (uint64_t (*)(void, void, void, void, uint64_t))sub_100017AA4, (uint64_t)v15, 0);
    }
  }
  return result;
}

uint64_t sub_100017AA4(void *a1, int a2, void *a3, int a4, uint64_t *a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a4 == 24 && a2 == 16 && (*a1 & 0xF000000000000000) == 0x8000000000000000)
  {
    unint64_t v7 = a3[1];
    if (v7) {
      return sub_100021248(a5[1], v7, (*a3 & 0xFFFFFFFFFFFFFFuLL) / *(unsigned int *)(*(void *)(*a5 + 8) + 36));
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100017AFC(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  unint64_t v6 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  if (v6 <= 1)
  {
    char v7 = sub_10003D8BC(8u);
    sub_10004458C("%s (id %llu): invalid hdr.obj_id\n", v8, v9, v10, v11, v12, v13, v14, v7);
    uint64_t v15 = 92;
    uint64_t v16 = 627;
LABEL_3:
    int v17 = 92;
LABEL_4:
    sub_100048B34((char *)v16, v17);
    return v15;
  }
  unint64_t v25 = *(unsigned int *)(*(void *)(a1 + 8) + 36);
  if (v6 <= 0xF && v6 - 4 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    char v27 = sub_10003D8BC(8u);
    sub_100044674("%s (id %llu): invalid hdr.obj_id\n", v28, v29, v30, v31, v32, v33, v34, v27);
    sub_100048B34((char *)0x274, -2);
  }
  if (*(void *)(a5 + 40) <= v6) {
    *(void *)(a5 + 40) = v6 + 1;
  }
  if (a3[1] % v25)
  {
    char v35 = sub_10003D8BC(8u);
    sub_10004458C("%s (id %llu): Logical address %llu of file extent not a multiple of the block size (%u)\n", v36, v37, v38, v39, v40, v41, v42, v35);
    uint64_t v15 = 92;
    sub_100048B34((char *)0x259, 92);
    if (!sub_10004641C(qword_100091B70, "Round down logical address (%llu) to block size? ", v43, v44, v45, v46, v47, v48, a3[1]))return v15; {
    a3[1] = a3[1] / v25 * v25;
    }
    *a6 = 1;
  }
  uint64_t v147 = a6;
  uint64_t v148 = a2;
  unint64_t v49 = *(void *)a4;
  unint64_t v50 = *(void *)a4 & 0xFFFFFFFFFFFFFFLL;
  if (v50 % v25)
  {
    char v51 = sub_10003D8BC(8u);
    sub_10004458C("%s (id %llu): Length %llu of file extent not a multiple of the block size (%u)\n", v52, v53, v54, v55, v56, v57, v58, v51);
    sub_100048B34((char *)0xD6, 92);
    v156[0] = 0xAAAAAAAAAAAAAAAALL;
    int v63 = sub_10003E25C(a1, a2, 8, v156, v59, v60, v61, v62);
    uint64_t v70 = a3[1];
    unint64_t v151 = v6;
    uint64_t v152 = v70;
    memset(v157, 170, 24);
    LODWORD(v149) = 16;
    v158[0] = 24;
    if (v63
      || sub_1000380B0(v156[0], *(void *)(a5 + 56), 2, &v151, (unsigned int *)&v149, 0x10u, v157, v158)|| v149 != 16|| v151 != v6)
    {
      if (sub_10004641C(qword_100091B70, "Round %s length (%llu) to block size? ", v64, v65, v66, v67, v68, v69, (char)"down"))
      {
LABEL_19:
        unint64_t v71 = v50 - v50 % v25;
LABEL_20:
        unint64_t v49 = v71 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(a4 + 7) << 56);
        *(void *)a4 = v49;
        *uint64_t v147 = 1;
        unint64_t v50 = v71;
        goto LABEL_21;
      }
    }
    else
    {
      unint64_t v71 = (v25 + v50 - 1) / v25 * v25;
      uint64_t v118 = "up";
      BOOL v146 = v152 - a3[1] == v71;
      if (v152 - a3[1] != v71) {
        uint64_t v118 = "down";
      }
      if (sub_10004641C(qword_100091B70, "Round %s length (%llu) to block size? ", v64, v65, v66, v67, v68, v69, (char)v118))
      {
        if (v146) {
          goto LABEL_20;
        }
        goto LABEL_19;
      }
    }
    return 92;
  }
LABEL_21:
  unint64_t v72 = HIBYTE(v49);
  if (HIBYTE(v49) >= 4)
  {
    char v88 = sub_10003D8BC(8u);
    sub_100044674("%s (id %llu): invalid flags: (0x%02x)\n", v89, v90, v91, v92, v93, v94, v95, v88);
    sub_100048B34((char *)0xD7, -3);
  }
  else
  {
    uint64_t v73 = v148[6];
    if (!v73) {
      uint64_t v73 = v148[5];
    }
    if ((v49 & 0x100000000000000) != 0 && (*(void *)(v73 + 56) & 0x20) != 0)
    {
      char v74 = sub_10003D8BC(8u);
      sub_10004458C("%s (id %llu): invalid flags: (0x%02x)\n", v75, v76, v77, v78, v79, v80, v81, v74);
      uint64_t v15 = 92;
      sub_100048B34((char *)0x396, 92);
      if (!sub_10004641C(qword_100091B70, "Remove invalid flags (0x%02x)? ", v82, v83, v84, v85, v86, v87, 1))return v15; {
      LOBYTE(v72) = HIBYTE(v49) & 0xFE;
      }
      *(unsigned char *)(a4 + 7) = (v49 & 0xFE00000000000000) >> 56;
      *uint64_t v147 = 1;
    }
  }
  uint64_t v96 = (uint64_t)v148;
  if ((v72 & 2) != 0)
  {
    uint64_t v97 = v148[6];
    if (!v97) {
      uint64_t v97 = v148[5];
    }
    if ((*(unsigned char *)(v97 + 56) & 0x80) == 0)
    {
      char v98 = sub_10003D8BC(8u);
      sub_10004458C("%s (id %llu): invalid flag: (0x%02x)\n", v99, v100, v101, v102, v103, v104, v105, v98);
      uint64_t v15 = 92;
      sub_100048B34((char *)0x3F6, 92);
      if (!sub_10004641C(qword_100091B70, "Remove invalid flag (0x%02x)? ", v106, v107, v108, v109, v110, v111, 2))return v15; {
      LOBYTE(v72) = v72 & 0xFD;
      }
      *(unsigned char *)(a4 + 7) = v72;
      uint64_t v96 = (uint64_t)v148;
      *uint64_t v147 = 1;
    }
  }
  unint64_t v112 = *(void *)(a4 + 8);
  if ((v72 & 2) != 0)
  {
    if (!v112)
    {
      char v136 = sub_10003D8BC(8u);
      sub_10004458C("%s (id %llu): expected physical block number for extent at offset %lld\n", v137, v138, v139, v140, v141, v142, v143, v136);
      uint64_t v15 = 92;
      uint64_t v16 = 1015;
      goto LABEL_3;
    }
  }
  else if (!v112)
  {
    goto LABEL_56;
  }
  uint64_t v113 = *(void *)(a1 + 8);
  uint64_t v114 = *(void *)(a1 + 24);
  unint64_t v115 = v50 / v25;
  if (v114)
  {
    unint64_t v116 = *(void *)(v114 + 48);
    unint64_t v117 = *(void *)(v114 + 96);
  }
  else
  {
    unint64_t v116 = *(void *)(v113 + 40);
    if (*(unsigned char *)(v113 + 65)) {
      unint64_t v117 = *(void *)(v113 + 40);
    }
    else {
      unint64_t v117 = 0;
    }
  }
  unint64_t v119 = *(unsigned int *)(v113 + 36);
  if (v116 <= v115 || v116 <= v112 || v116 - v115 < v112)
  {
    unint64_t v121 = 0x4000000000000000uLL >> __clz(__rbit64(v119));
    if (v121 >= v112
      || (BOOL v122 = v117 >= v115, v123 = v117 - v115, v123 == 0 || !v122)
      || (v117 | v121) <= v112
      || (v123 | v121) < v112)
    {
      char v124 = sub_10003D8BC(8u);
      sub_10004458C("%s (id %llu): Bad phys_block_num + len (%llu + %llu) for physical file extent record\n", v125, v126, v127, v128, v129, v130, v131, v124);
      uint64_t v15 = 92;
      uint64_t v16 = 216;
      goto LABEL_3;
    }
  }
LABEL_56:
  v156[0] = 0;
  v156[1] = 0;
  if (v96) {
    uint64_t v120 = *(void *)(*(void *)(v96 + 40) + 8);
  }
  else {
    uint64_t v120 = 0;
  }
  v157[0] = v120;
  v157[1] = 0xF000040000000;
  uint64_t v132 = *(void *)(a5 + 56);
  v157[2] = v112;
  v157[3] = v132;
  unsigned int v154 = 16;
  unsigned int v155 = 32;
  if (sub_1000380B0((uint64_t)dword_100091FF0, 0, 0, v157, &v155, 0x20u, v156, &v154)) {
    goto LABEL_78;
  }
  uint64_t v152 = 0;
  unint64_t v153 = 0;
  uint64_t v149 = 0;
  uint64_t v150 = 0;
  unint64_t v135 = v96 ? *(void *)(*(void *)(v96 + 40) + 8) : 0;
  uint64_t v144 = *(void *)(a4 + 8);
  unint64_t v151 = v135;
  uint64_t v152 = v144;
  unint64_t v153 = v6;
  uint64_t v145 = a3[1];
  uint64_t v149 = *(void *)(a5 + 56);
  uint64_t v150 = v145;
  uint64_t v15 = sub_100039A6C(dword_100092030, 0, &v151, 24, &v149, 16);
  if (!v15)
  {
LABEL_78:
    unint64_t v133 = *(void *)(a4 + 8);
    if (!v133) {
      return 0;
    }
    char v134 = sub_10000DCB0(a3);
    uint64_t v15 = sub_100020E6C(v96, v133, v50 / v25, v6, v134);
    if (v15)
    {
      uint64_t v16 = 828;
      int v17 = v15;
      goto LABEL_4;
    }
  }
  return v15;
}

double sub_10001811C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t v10 = *(void *)a3;
  if ((*(void *)a3 & 0x100000000000000) == 0)
  {
    unint64_t v11 = *(void *)(a3 + 16);
    if (v11 <= 0xF)
    {
      BOOL v12 = v11 > 5;
      uint64_t v13 = (1 << v11) & 0x2D;
      if (v12 || v13 == 0)
      {
        char v105 = sub_10003D8BC((unint64_t)*a2 >> 60);
        sub_100044674("%s (id %llu): invalid crypto_id (%llu)\n", v106, v107, v108, v109, v110, v111, v112, v105);
        sub_100048B34((char *)0xD9, -2);
      }
    }
  }
  if (*(void *)(a3 + 8))
  {
    unint64_t v15 = HIBYTE(v10);
    uint64_t v16 = *(void *)(a1 + 40);
    uint64_t v17 = *(void *)(v16 + 264);
    if (*(void *)(a4 + 56)) {
      BOOL v18 = (*(void *)(v16 + 264) & 9) == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18)
    {
      uint64_t v19 = *(void *)(v16 + 976);
      if (v17)
      {
        if (!v19)
        {
          if (*(void *)(a3 + 16))
          {
            char v77 = sub_10003D8BC((unint64_t)*a2 >> 60);
            sub_10004458C("%s (id %llu): invalid nonzero crypto_id (%llu) on unencrypted volume\n", v78, v79, v80, v81, v82, v83, v84, v77);
            sub_100048B34((char *)0x342, 92);
            if (!sub_10004641C(qword_100091B70, "Fix crypto_id (%llu)? ", v85, v86, v87, v88, v89, v90, *(void *)(a3 + 16)))return result; {
            *(void *)(a3 + 16) = 0;
            }
            *a5 = 1;
          }
          if ((v10 & 0x100000000000000) != 0)
          {
            char v91 = sub_10003D8BC((unint64_t)*a2 >> 60);
            sub_10004458C("%s (id %llu): extent crypto flag set on unencrypted volume\n", v92, v93, v94, v95, v96, v97, v98, v91);
            sub_100048B34((char *)0x3CF, 92);
            if (!sub_10004641C(qword_100091B70, "Clear invalid flag? ", v99, v100, v101, v102, v103, v104, v117))return result; {
            *(unsigned char *)(a3 + 7) = (v10 & 0xFE00000000000000) >> 56;
            }
            *a5 = 1;
            goto LABEL_32;
          }
        }
      }
      else if (!v19)
      {
        if (!*(void *)(a3 + 16))
        {
          char v20 = sub_10003D8BC((unint64_t)*a2 >> 60);
          sub_10004458C("%s (id %llu): invalid zero crypto_id on encrypted volume\n", v21, v22, v23, v24, v25, v26, v27, v20);
          sub_100048B34((char *)0x343, 92);
          if ((*(_WORD *)(*(void *)(a1 + 40) + 264) & 0x108) == 0
            || !sub_10004641C(qword_100091B70, "Fix crypto_id? ", v28, v29, v30, v31, v32, v33, v114))
          {
            return result;
          }
          *(void *)(a3 + 16) = *(void *)(a3 + 8);
          LOBYTE(v15) = HIBYTE(v10) | 1;
          *(unsigned char *)(a3 + 7) = HIBYTE(v10) | 1;
          *a5 = 1;
          uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 264);
        }
        if ((v15 & 1) == 0 && (v17 & 0x109) == 8)
        {
          char v34 = sub_10003D8BC((unint64_t)*a2 >> 60);
          sub_10004458C("%s (id %llu): extent crypto flag missing on encrypted volume\n", v35, v36, v37, v38, v39, v40, v41, v34);
          sub_100048B34((char *)0x3CE, 92);
          if (!sub_10004641C(qword_100091B70, "Set missing flag? ", v42, v43, v44, v45, v46, v47, v115)) {
            return result;
          }
          LOBYTE(v15) = v15 | 1;
          *(unsigned char *)(a3 + 7) = v15;
          *(void *)(a3 + 16) = *(void *)(a3 + 8);
          *a5 = 1;
        }
      }
    }
    if (v15)
    {
LABEL_34:
      return sub_100008F7C(a2, a3);
    }
LABEL_32:
    unint64_t v62 = *(void *)(a3 + 16) + 1;
    if (*(void *)(a4 + 40) < v62) {
      *(void *)(a4 + 40) = v62;
    }
    goto LABEL_34;
  }
  if (*(void *)(a3 + 16))
  {
    char v48 = sub_10003D8BC((unint64_t)*a2 >> 60);
    sub_100044674("%s (id %llu): invalid sparse extent with nonzero crypto_id (%llu)\n", v49, v50, v51, v52, v53, v54, v55, v48);
    sub_100048B34((char *)0x341, 92);
    if (sub_10004641C(qword_100091B70, "Fix crypto_id (%llu)? ", v56, v57, v58, v59, v60, v61, *(void *)(a3 + 16)))
    {
      *(void *)(a3 + 16) = 0;
      *a5 = 1;
    }
  }
  if ((v10 & 0x100000000000000) != 0 && (*(unsigned char *)(*(void *)(a1 + 40) + 264) & 9) == 0)
  {
    char v63 = sub_10003D8BC((unint64_t)*a2 >> 60);
    sub_100044674("%s (id %llu): extent crypto flag set on sparse extent\n", v64, v65, v66, v67, v68, v69, v70, v63);
    sub_100048B34((char *)0x3E8, 92);
    if (sub_10004641C(qword_100091B70, "Clear invalid flag? ", v71, v72, v73, v74, v75, v76, v116))
    {
      *(unsigned char *)(a3 + 7) = (v10 & 0xFE00000000000000) >> 56;
      *a5 = 1;
    }
  }
  return result;
}

uint64_t sub_100018540(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = off_100091690(*a3, a1, a2);
  *a3 = result;
  return result;
}

uint64_t sub_100018580(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v9 = (unsigned __int8 *)(a4 + 4 + 4 * a5);
  int v10 = *v9;
  if ((v10 - 1) > 1 || *(_WORD *)(a4 + 4 + 4 * a5 + 2) == 8)
  {
    if (v10 != 2)
    {
      if (v10 == 1)
      {
        uint64_t v11 = *a6;
        if ((unint64_t)*a6 <= 0xF && (unint64_t)(v11 - 4) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v12 = *(void *)a3 >> 60;
          if (v12 == 14) {
            LODWORD(v12) = *(unsigned __int8 *)(a3 + 8);
          }
          char v13 = sub_10003D8BC(v12);
          sub_10003D8EC(a3, *v9);
          sub_100044674("%s (id %llu): xf %u/%u: %s: invalid sibling_id (%llu)\n", v14, v15, v16, v17, v18, v19, v20, v13);
          sub_100048B34((char *)0xC0, -2);
        }
        if (*(void *)(a7 + 40) < (unint64_t)(v11 + 1))
        {
          uint64_t v21 = 0;
          *(void *)(a7 + 40) = v11 + 1;
          return v21;
        }
      }
      else
      {
        uint64_t v31 = *(void *)a3 >> 60;
        if (v31 == 14) {
          LODWORD(v31) = *(unsigned __int8 *)(a3 + 8);
        }
        char v32 = sub_10003D8BC(v31);
        sub_10003D8EC(a3, *v9);
        sub_100044674("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v33, v34, v35, v36, v37, v38, v39, v32);
        sub_100048B34((char *)0xC1, -5);
      }
    }
    return 0;
  }
  uint64_t v22 = *(void *)a3 >> 60;
  if (v22 == 14) {
    LODWORD(v22) = *(unsigned __int8 *)(a3 + 8);
  }
  char v23 = sub_10003D8BC(v22);
  sub_10003D8EC(a3, *v9);
  sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n", v24, v25, v26, v27, v28, v29, v30, v23);
  uint64_t v21 = 92;
  sub_100048B34((char *)0x3D6, 92);
  return v21;
}

uint64_t sub_100018768(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a2 + 48);
  if (!v8) {
    uint64_t v8 = *(void *)(a2 + 40);
  }
  if ((*(unsigned char *)(v8 + 56) & 0x20) == 0)
  {
    char v9 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_100044674("%s (id %llu): Found data hash on unsealed volume\n", v10, v11, v12, v13, v14, v15, v16, v9);
    sub_100048B34((char *)0x3A4, -5);
    return sub_100027E70((_DWORD *)(a2 + 704), 8u, 0, 0, 0, (long long *)a3, 0x10u, 0, 0);
  }
  if ((*(_WORD *)(a3 + 8) & 0x3FFF) != 0)
  {
    char v18 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): Logical address %llu of data hash not a multiple of the hash chunk size (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 92;
    uint64_t v27 = 933;
LABEL_11:
    int v50 = 92;
    goto LABEL_12;
  }
  uint64_t v28 = *(unsigned __int8 *)(a4 + 2);
  if (*(_DWORD *)(a2 + 20) != v28)
  {
    char v42 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): Unexpected hash size (%u != %u)\n", v43, v44, v45, v46, v47, v48, v49, v42);
    uint64_t v26 = 92;
    uint64_t v27 = 934;
    goto LABEL_11;
  }
  if (sub_10000A0DC(a4 + 3, 0, 8 * v28))
  {
    char v34 = sub_10003D8BC(*(void *)a3 >> 60);
    sub_10004458C("%s (id %llu): Invalid hash at offset %llu\n", v35, v36, v37, v38, v39, v40, v41, v34);
    uint64_t v26 = 92;
    uint64_t v27 = 935;
    goto LABEL_11;
  }
  uint64_t v26 = sub_10000DA64(a1, (void *)a3, (_WORD *)a4, v29, v30, v31, v32, v33);
  if (!v26) {
    return v26;
  }
  uint64_t v27 = 936;
  int v50 = v26;
LABEL_12:
  sub_100048B34((char *)v27, v50);
  return v26;
}

uint64_t sub_100018920(int a1, int a2, uint64_t a3, uint64_t a4, int a5, void *__src, int a7, int a8, unsigned char *a9)
{
  uint64_t v10 = (unsigned char *)(a4 + 4 + 4 * a5);
  if (*v10 == 1)
  {
    size_t v11 = *(unsigned __int16 *)(a4 + 4 + 4 * a5 + 2);
    if (v11 < 0x100)
    {
      memcpy(a9 + 1, __src, v11);
      uint64_t v21 = 0;
      *a9 = 1;
    }
    else
    {
      uint64_t v12 = *(void *)a3 >> 60;
      if (v12 == 14) {
        LODWORD(v12) = *(unsigned __int8 *)(a3 + 8);
      }
      char v13 = sub_10003D8BC(v12);
      sub_10003D8EC(a3, *v10);
      sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid extended field size %u, max %u\n", v14, v15, v16, v17, v18, v19, v20, v13);
      uint64_t v21 = 92;
      sub_100048B34((char *)0x521, 92);
    }
  }
  else
  {
    uint64_t v22 = *(void *)a3 >> 60;
    if (v22 == 14) {
      LODWORD(v22) = *(unsigned __int8 *)(a3 + 8);
    }
    char v23 = sub_10003D8BC(v22);
    sub_10003D8EC(a3, *v10);
    sub_100044674("%s (id %llu): xf %u/%u: %s: invalid x_type (%u)\n", v24, v25, v26, v27, v28, v29, v30, v23);
    sub_100048B34((char *)0x522, -5);
    return 0;
  }
  return v21;
}

uint64_t sub_100018A80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  unint64_t v6 = (unsigned __int8 *)(a4 + 4 + 4 * a5);
  if (*v6 - 1 > 1)
  {
    uint64_t v17 = *(void *)a3 >> 60;
    if (v17 == 14) {
      LODWORD(v17) = *(unsigned __int8 *)(a3 + 8);
    }
    char v18 = sub_10003D8BC(v17);
    sub_10003D8EC(a3, *v6);
    sub_100044674("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v19, v20, v21, v22, v23, v24, v25, v18);
    sub_100048B34((char *)0x50A, -5);
    return 0;
  }
  if (*(_WORD *)(a4 + 4 + 4 * a5 + 2) == 8) {
    return 0;
  }
  uint64_t v7 = *(void *)a3 >> 60;
  if (v7 == 14) {
    LODWORD(v7) = *(unsigned __int8 *)(a3 + 8);
  }
  char v8 = sub_10003D8BC(v7);
  sub_10003D8EC(a3, *v6);
  sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n", v9, v10, v11, v12, v13, v14, v15, v8);
  uint64_t v16 = 92;
  sub_100048B34((char *)0x509, 92);
  return v16;
}

uint64_t sub_100018BC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10 = a4 + 4 * a5;
  unsigned int v13 = *(unsigned __int8 *)(v10 + 4);
  uint64_t v12 = (unsigned __int8 *)(v10 + 4);
  uint64_t v11 = v13;
  if (v13 > 4 || (v11 ? (BOOL v14 = word_10006F20A[v11] == *((unsigned __int16 *)v12 + 1)) : (BOOL v14 = 1), v14))
  {
    switch((int)v11)
    {
      case 1:
        uint64_t v15 = 0;
        *(void *)(a9 + 8) = *a6;
        *(unsigned char *)a9 = 1;
        break;
      case 2:
        uint64_t v34 = *a6;
        if ((unint64_t)(*a6 - 1) > 0xE || (unint64_t)(*a6 - 4) > 0xFFFFFFFFFFFFFFFDLL)
        {
          if (*(void *)(a7 + 40) < (unint64_t)(v34 + 1)) {
            *(void *)(a7 + 40) = v34 + 1;
          }
        }
        else
        {
          uint64_t v36 = *(void *)a3 >> 60;
          if (v36 == 14) {
            LODWORD(v36) = *(unsigned __int8 *)(a3 + 8);
          }
          char v37 = sub_10003D8BC(v36);
          sub_10003D8EC(a3, *v12);
          sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid shadow_key (%llu)\n", v38, v39, v40, v41, v42, v43, v44, v37);
          sub_100048B34((char *)0x53B, -2);
        }
        uint64_t v15 = 0;
        *(void *)(a9 + 56) = v34;
        *(unsigned char *)(a9 + 48) = 1;
        break;
      case 3:
        uint64_t v15 = 0;
        *(void *)(a9 + 24) = *a6;
        *(unsigned char *)(a9 + 16) = 1;
        break;
      case 4:
        uint64_t v15 = 0;
        *(void *)(a9 + 40) = *a6;
        *(unsigned char *)(a9 + 32) = 1;
        break;
      default:
        uint64_t v25 = *(void *)a3 >> 60;
        if (v25 == 14) {
          LODWORD(v25) = *(unsigned __int8 *)(a3 + 8);
        }
        char v26 = sub_10003D8BC(v25);
        sub_10003D8EC(a3, *v12);
        sub_100044674("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v27, v28, v29, v30, v31, v32, v33, v26);
        sub_100048B34((char *)0x4E7, -5);
        uint64_t v15 = 0;
        break;
    }
  }
  else
  {
    uint64_t v16 = *(void *)a3 >> 60;
    if (v16 == 14) {
      LODWORD(v16) = *(unsigned __int8 *)(a3 + 8);
    }
    char v17 = sub_10003D8BC(v16);
    sub_10003D8EC(a3, *v12);
    sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid extended field size %u, expected %u\n", v18, v19, v20, v21, v22, v23, v24, v17);
    uint64_t v15 = 92;
    sub_100048B34((char *)0x4E6, 92);
  }
  return v15;
}

uint64_t sub_100018E30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6, uint64_t a7, uint64_t a8, void *a9)
{
  uint64_t v10 = (unsigned __int8 *)(a4 + 4 + 4 * a5);
  int v11 = *v10;
  if ((v11 - 1) > 1 || *(_WORD *)(a4 + 4 + 4 * a5 + 2) == 8)
  {
    if (v11 == 1)
    {
      if ((*a6 & 0x1FFFFFFFFFFFFFLL) == 0)
      {
        uint64_t v44 = *(void *)a3 >> 60;
        if (v44 == 14) {
          LODWORD(v44) = *(unsigned __int8 *)(a3 + 8);
        }
        char v45 = sub_10003D8BC(v44);
        sub_10003D8EC(a3, *v10);
        sub_100044674("%s (id %llu): xf %u/%u: %s: invalid attribution hash (%llu)\n", v46, v47, v48, v49, v50, v51, v52, v45);
        uint64_t v33 = 1297;
        goto LABEL_26;
      }
      uint64_t v14 = 0;
      a9[1] = *a6;
    }
    else
    {
      if (v11 != 2)
      {
        uint64_t v24 = *(void *)a3 >> 60;
        if (v24 == 14) {
          LODWORD(v24) = *(unsigned __int8 *)(a3 + 8);
        }
        char v25 = sub_10003D8BC(v24);
        sub_10003D8EC(a3, *v10);
        sub_100044674("%s (id %llu): xf %u/%u: %s: unknown x_type (%u)\n", v26, v27, v28, v29, v30, v31, v32, v25);
        uint64_t v33 = 1298;
        int v34 = -5;
        goto LABEL_27;
      }
      uint64_t v12 = *a6;
      if (*a6 <= 0xFuLL && v12 != 2)
      {
        uint64_t v35 = *(void *)a3 >> 60;
        if (v35 == 14) {
          LODWORD(v35) = *(unsigned __int8 *)(a3 + 8);
        }
        char v36 = sub_10003D8BC(v35);
        sub_10003D8EC(a3, *v10);
        sub_100044674("%s (id %llu): xf %u/%u: %s: invalid dir_stats_key (%llu)\n", v37, v38, v39, v40, v41, v42, v43, v36);
        uint64_t v33 = 1296;
LABEL_26:
        int v34 = -2;
LABEL_27:
        sub_100048B34((char *)v33, v34);
        return 0;
      }
      *a9 = v12;
      if (*(void *)(a7 + 40) >= (unint64_t)(v12 + 1)) {
        return 0;
      }
      uint64_t v14 = 0;
      *(void *)(a7 + 40) = v12 + 1;
    }
  }
  else
  {
    uint64_t v15 = *(void *)a3 >> 60;
    if (v15 == 14) {
      LODWORD(v15) = *(unsigned __int8 *)(a3 + 8);
    }
    char v16 = sub_10003D8BC(v15);
    sub_10003D8EC(a3, *v10);
    sub_10004458C("%s (id %llu): xf %u/%u: %s: invalid extended field size %u for type %u, expected %lu\n", v17, v18, v19, v20, v21, v22, v23, v16);
    uint64_t v14 = 92;
    sub_100048B34((char *)0x50F, 92);
  }
  return v14;
}

uint64_t sub_100019080(uint64_t a1)
{
  qword_100078C80 = a1;
  if (!sub_100038040((uint64_t)&unk_100078C88, 0, 0, 0x8000000, 2, 0, 0, 4096, 8, 160, 0, 0, (uint64_t)sub_1000306FC))sub_10003A18C((uint64_t)&unk_100078C88, 0, 0); {
  uint64_t result = sub_10001CF74((uint64_t)&unk_100078C88, (uint64_t)"dir stats", (uint64_t)sub_10001914C);
  }
  if (result)
  {
    sub_100044674("failed to register the dir stats tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
    uint64_t result = (uint64_t)sub_100048B34((char *)0x57C, 12);
  }
  byte_100078CC8 = 0;
  return result;
}

uint64_t sub_10001914C()
{
  if (qword_100078DB0) {
    uint64_t result = sub_10003A268((uint64_t)&unk_100078D78, 0);
  }
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    uint64_t result = sub_10001914C();
  }
  if (qword_100078CC0) {
    uint64_t result = sub_10003A268((uint64_t)&unk_100078C88, 0);
  }
  qword_100078CD0 = 0;
  return result;
}

uint64_t sub_1000191B8()
{
  if (qword_100078DB0) {
    return sub_10003A268((uint64_t)&unk_100078D78, 0);
  }
  return result;
}

void sub_1000191D8(uint64_t a1, uint64_t *a2)
{
}

void sub_10001922C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (qword_100078CC0)
  {
    sub_100019450(a1);
    if (!v23)
    {
      if (a1 == a3) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = a3;
      }
      qword_100078CE8 = v24;
      qword_100078CF0 = a2;
      if (a1 == a3) {
        __int16 v25 = 257;
      }
      else {
        __int16 v25 = 1;
      }
      if (a14) {
        __int16 v26 = 128;
      }
      else {
        __int16 v26 = 0;
      }
      *(void *)&xmmword_100078CD8 = a15;
      *((void *)&xmmword_100078CD8 + 1) = a3;
      qword_100078D00 = a4;
      qword_100078D10 = a5;
      dword_100078D70 = a7;
      qword_100078D20 = a6;
      if (a8) {
        __int16 v27 = 8;
      }
      else {
        __int16 v27 = 0;
      }
      qword_100078D30 = a9;
      if (a10) {
        __int16 v28 = 32;
      }
      else {
        __int16 v28 = 0;
      }
      __int16 v29 = v27 | v28;
      qword_100078D40 = a11;
      if (a12) {
        __int16 v30 = 64;
      }
      else {
        __int16 v30 = 0;
      }
      word_100078D74 = word_100078D74 & 0xFF16 | v25 | v26 | v29 | v30;
      qword_100078D50 = a13;
    }
  }
}

void sub_100019364(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, char a6, uint64_t a7, char a8, uint64_t a9, char a10, uint64_t a11)
{
}

void sub_1000193D4(uint64_t a1, uint64_t a2)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (a2 && qword_100078CC0)
  {
    sub_100019450(a1);
    if (!v8) {
      sub_1000194FC((char *)&qword_100078D28, a2, a1, (uint64_t)"resource fork size", v4, v5, v6, v7);
    }
  }
}

double sub_100019450(uint64_t a1)
{
  if (qword_100078CD0 != a1 && !sub_10001B2C0() && a1)
  {
    *(void *)&long long v3 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v3 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v12 = v3;
    long long v13 = v3;
    long long v10 = v3;
    long long v11 = v3;
    long long v8 = v3;
    long long v9 = v3;
    long long v6 = v3;
    long long v7 = v3;
    long long v4 = v3;
    long long v5 = v3;
    if (!sub_10001C180(a1, &v4))
    {
      qword_100078CD0 = a1;
      *(_OWORD *)&qword_100078D38 = v10;
      *(_OWORD *)&qword_100078D48 = v11;
      xmmword_100078D58 = v12;
      unk_100078D68 = v13;
      *(_OWORD *)&qword_100078CF8 = v6;
      *(_OWORD *)&qword_100078D08 = v7;
      *(_OWORD *)&qword_100078D18 = v8;
      *(_OWORD *)&qword_100078D28 = v9;
      double result = *(double *)&v4;
      xmmword_100078CD8 = v4;
      *(_OWORD *)&qword_100078CE8 = v5;
    }
  }
  return result;
}

char *sub_1000194FC(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = __OFADD__(*(void *)result, a2);
  *(void *)result += a2;
  if (v8)
  {
    long long v9 = result;
    sub_100044674("dir-stats object (id %llu): %s overflow\n", a2, a3, a4, a5, a6, a7, a8, a3);
    *(void *)long long v9 = 0x7FFFFFFFFFFFFFFFLL;
    return sub_100048B34((char *)0x56D, 84);
  }
  return result;
}

void sub_100019574(uint64_t a1, uint64_t a2, int a3)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (qword_100078CC0)
  {
    sub_100019450(a1);
    if (!v10)
    {
      if (a3) {
        sub_1000194FC((char *)&xmmword_100078D58 + 8, 1, a1, (uint64_t)"SAF descendants", v6, v7, v8, v9);
      }
      sub_1000194FC((char *)&qword_100078D08, 1, a1, (uint64_t)"descendants", v6, v7, v8, v9);
      sub_1000194FC((char *)&qword_100078D18, a2, a1, (uint64_t)"physical size", v11, v12, v13, v14);
    }
  }
}

void sub_100019630(uint64_t a1, uint64_t a2, int a3)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (!qword_100078CC0) {
    return;
  }
  sub_100019450(a1);
  if (v13) {
    return;
  }
  if ((unint64_t)(qword_100078CF8 - 1) > 0xFFFFFFFFFFFFFFFDLL)
  {
LABEL_11:
    qword_100078CF8 = a2;
    if ((a3 & 0x20000000) != 0) {
      word_100078D74 |= 4u;
    }
    if ((a3 & 0x80000) != 0) {
      word_100078D74 |= 0x10u;
    }
    return;
  }
  uint64_t v14 = qword_100078CF0;
  if (!qword_100078CF0)
  {
    sub_100044674("dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n", v6, v7, v8, v9, v10, v11, v12, a1);
    sub_100048B34((char *)0x4DE, -8);
    goto LABEL_11;
  }
  if (qword_100078CF0 == qword_100078CF8)
  {
    sub_100044674("dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n", v6, v7, v8, v9, v10, v11, v12, a1);
    sub_100048B34((char *)0x4DE, -8);
    return;
  }
  sub_100044674("dir_stats (id %llu) already has a registered origin (id %llu), but we found another one (id %llu)\n", v6, v7, v8, v9, v10, v11, v12, a1);
  sub_100048B34((char *)0x4DE, -8);
  if (v14 == a2) {
    goto LABEL_11;
  }
}

void sub_100019774(uint64_t a1, uint64_t a2)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (a2 && qword_100078CC0)
  {
    sub_100019450(a1);
    if (!v8) {
      sub_1000194FC((char *)&qword_100078D38, a2, a1, (uint64_t)"clone size", v4, v5, v6, v7);
    }
  }
}

void sub_1000197F0(uint64_t a1, uint64_t a2)
{
}

void sub_1000197F8(uint64_t a1, uint64_t a2)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (a2 && qword_100078CC0)
  {
    sub_100019450(a1);
    if (!v8) {
      sub_1000194FC((char *)&qword_100078D48, a2, a1, (uint64_t)"purgeable size", v4, v5, v6, v7);
    }
  }
}

void sub_100019874(uint64_t a1, uint64_t a2)
{
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  if (a2 && qword_100078CC0)
  {
    sub_100019450(a1);
    if (!v8) {
      sub_1000194FC((char *)&xmmword_100078D58, a2, a1, (uint64_t)"purgeable rsrc size", v4, v5, v6, v7);
    }
  }
}

uint64_t sub_1000198F0(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t v6 = &unk_100078000;
  if (byte_100078CC8 == 1)
  {
    byte_100078CC8 = 0;
    sub_10001914C();
  }
  uint64_t v7 = &unk_100078000;
  if (!qword_100078CC0) {
    return 0;
  }
  uint64_t v177 = 0;
  uint64_t v176 = 0;
  uint64_t v175 = 0;
  long long v173 = 0u;
  long long v174 = 0u;
  long long v171 = 0u;
  long long v172 = 0u;
  long long v169 = 0u;
  long long v170 = 0u;
  long long v167 = 0u;
  long long v168 = 0u;
  long long v165 = 0u;
  long long v166 = 0u;
  uint64_t v8 = a2[6];
  if (!v8) {
    uint64_t v8 = a2[5];
  }
  uint64_t v9 = *(void *)(v8 + 56);
  char v10 = sub_100003C30();
  uint64_t v11 = sub_10001B2C0();
  if (v11) {
    goto LABEL_291;
  }
  *(void *)&long long v180 = 0;
  sub_10003A064((uint64_t)dword_100078C88, 0, &v180);
  if (!(void)v180) {
    goto LABEL_102;
  }
  char v150 = v10;
  __int16 v152 = v9;
  unsigned int v154 = a3;
  int v164 = 8;
  unsigned int v163 = 160;
  if (!sub_100038610((uint64_t)dword_100078C88, 0, &v177, &v164, &v165, &v163))
  {
    do
    {
      if ((BYTE9(v174) & 4) != 0 || (WORD6(v174) & 0x100) != 0 || (void)v166 != *((void *)&v165 + 1))
      {
        uint64_t v12 = sub_10001B590(a1, a2, v177, (uint64_t)&v165);
        if (v12)
        {
LABEL_286:
          uint64_t v11 = v12;
          goto LABEL_291;
        }
      }
      unsigned int v162 = 8;
      unsigned int v161 = 160;
    }
    while (!sub_1000380B0((uint64_t)dword_100078C88, 0, 2, &v177, &v162, 8u, &v165, &v161));
  }
  int v160 = 8;
  unsigned int v159 = 160;
  if (sub_100038610((uint64_t)dword_100078C88, 0, &v177, &v160, &v165, &v159))
  {
LABEL_15:
    *(void *)uint64_t v194 = 0;
    long long v188 = 0u;
    long long v189 = 0u;
    long long v186 = 0u;
    long long v187 = 0u;
    long long v184 = 0u;
    long long v185 = 0u;
    long long v182 = 0u;
    long long v183 = 0u;
    long long v180 = 0u;
    long long v181 = 0u;
    if (!sub_100038040((uint64_t)dword_100078D78, 0, 0, 0x8000000, 2, 0, 0, 4096, 16, 0, 0, 0, (uint64_t)sub_100030730))sub_10003A18C((uint64_t)dword_100078D78, 0, 0); {
    if (sub_10001CF74((uint64_t)dword_100078D78, (uint64_t)"dir stats repairs", (uint64_t)sub_1000191B8))
    }
    {
      sub_100044674("failed to register the dir stats repair tree in the fsck memory storage\n", v17, v18, v19, v20, v21, v22, v23, v148);
      sub_100048B34((char *)0x59C, 12);
    }
    if (qword_100078DB0)
    {
      LODWORD(v155) = 8;
      LODWORD(v191) = 160;
      if (sub_100038610((uint64_t)dword_100078C88, 0, v194, &v155, &v180, (unsigned int *)&v191))
      {
LABEL_23:
        uint64_t v7 = &unk_100078000;
        if (qword_100078DB0)
        {
          if (v6[3272] == 1)
          {
            v6[3272] = 0;
            sub_10001914C();
          }
          if (qword_100078CC0)
          {
            *(void *)&long long v180 = 0;
            sub_10003A064((uint64_t)dword_100078D78, 0, &v180);
            uint64_t v32 = v180;
            *(void *)&long long v180 = 0;
            sub_10003A064((uint64_t)dword_100078C88, 0, &v180);
            if (v32 == (void)v180)
            {
              *(void *)&long long v180 = v176;
              LODWORD(v178) = 16;
              *(_DWORD *)uint64_t v194 = 0;
              unsigned int v33 = sub_1000380B0((uint64_t)dword_100078D78, 0, 2, &v175, (unsigned int *)&v178, 0x10u, &v192, (unsigned int *)v194);
              if (!v33)
              {
                *(void *)&long long v180 = v176;
                LODWORD(v155) = 8;
                LODWORD(v191) = 160;
                unsigned int v33 = sub_1000380B0((uint64_t)dword_100078C88, 0, 0, &v180, (unsigned int *)&v155, 8u, &v165, (unsigned int *)&v191);
              }
              char v34 = 1;
              goto LABEL_98;
            }
          }
        }
      }
      else
      {
        while (1)
        {
          unint64_t v178 = v189;
          unint64_t v179 = *(void *)v194;
          int v24 = sub_100039A6C(dword_100078D78, 0, &v178, 16, &v192, 0);
          if (v24) {
            break;
          }
          LODWORD(v190) = 8;
          unsigned int v193 = 160;
          if (sub_1000380B0((uint64_t)dword_100078C88, 0, 2, v194, (unsigned int *)&v190, 8u, &v180, &v193))goto LABEL_23; {
        }
          }
        int v65 = v24;
        sub_100044674("failed to insert dir-stats entry %llu into the repair tree\n", v25, v26, v27, v28, v29, v30, v31, v194[0]);
        sub_100048B34((char *)0x59F, v65);
        sub_10003A268((uint64_t)dword_100078D78, 0);
        uint64_t v7 = &unk_100078000;
      }
    }
    else
    {
      sub_100044674("failed to init the dir stats repair tree\n", v17, v18, v19, v20, v21, v22, v23, v148);
      sub_100048B34((char *)0x59E, 12);
    }
    if (v6[3272] == 1)
    {
      v6[3272] = 0;
      sub_10001914C();
    }
    if (v7[408])
    {
      *(void *)&long long v180 = v176;
      LODWORD(v190) = 8;
      unsigned int v193 = 160;
      unsigned int v33 = sub_1000380B0((uint64_t)dword_100078C88, 0, 2, &v180, (unsigned int *)&v190, 8u, &v165, &v193);
      char v34 = 0;
      uint64_t v175 = v174;
      uint64_t v176 = v180;
LABEL_98:
      if (v33)
      {
LABEL_99:
        if (v33 == 2) {
          uint64_t v11 = 0;
        }
        else {
          uint64_t v11 = v33;
        }
        goto LABEL_291;
      }
      if ((v152 & 0x200) != 0) {
        uint64_t v66 = (long long *)&v155;
      }
      else {
        uint64_t v66 = (long long *)&v190;
      }
      if ((v152 & 0x200) != 0) {
        int v67 = 12;
      }
      else {
        int v67 = 8;
      }
      unsigned int v153 = v67;
      char v151 = v150 ^ 1;
      while (1)
      {
        while (1)
        {
          uint64_t v190 = (uint64_t *)(v176 & 0xFFFFFFFFFFFFFFFLL | 0xA000000000000000);
          uint64_t v191 = v176;
          unint64_t v155 = v176 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000;
          int v156 = 18;
          long long v182 = 0u;
          long long v183 = 0u;
          long long v180 = 0u;
          long long v181 = 0u;
          unint64_t v179 = 0xAAAAAAAAAAAAAA00;
          unint64_t v178 = v176;
          sub_10003E098(a1, a2, qword_100078C80, 3, 1u, (uint64_t)sub_10001B940, (unint64_t)&v178);
          if ((_BYTE)v179) {
            goto LABEL_119;
          }
          sub_100044548("\ndir-stats %llu (has dir-stats? %d)%s:\nflags: 0x%x\nchained-key: %llu (computed: %llu)\norigin-id: %llu (computed: %llu)\nshadow-key: %llu (exists? %d)\ndescendants: %llu (computed: %llu)\nSAF descendants: %llu\ndir-stats descendants: %llu\nphysical size: %llu (computed: %llu)\nresource fork size: %llu (computed: %llu)\nclone size: %llu (exists? %d; computed: %llu)\n"
            "purgeable size: %llu (exists? %d; computed: %llu)\n"
            "purgeable resource fork size: %llu (exists? %d; computed: %llu)\n"
            "has calculating dir-stats? %d\n"
            "origin is SAF? %d (parent is SAF? %d)\n"
            "origin is purgeable? %d\n"
            "\n",
            *((uint64_t *)&v171 + 1),
            v172,
            (WORD6(v174) >> 1) & 1,
            (WORD6(v174) >> 2) & 1,
            *((uint64_t *)&v172 + 1),
            v173,
            (WORD6(v174) >> 10) & 1,
            v191);
          if ((BYTE12(v174) & 1) == 0 || (void)v167 || (void)v168) {
            break;
          }
          sub_100044674("found orphan dir-stats object (id %llu)\n", v68, v69, v70, v71, v72, v73, v74, v191);
          sub_100048B34((char *)0x576, -8);
          uint64_t v12 = sub_10001CA70(v154, 0, 0, v66, v153, 0, 0, v75);
          if (v12) {
            goto LABEL_286;
          }
LABEL_119:
          *(void *)&long long v180 = v176;
          if ((v34 & 1) == 0) {
            goto LABEL_282;
          }
LABEL_120:
          LODWORD(v178) = 16;
          *(_DWORD *)uint64_t v194 = 0;
          unsigned int v33 = sub_1000380B0((uint64_t)dword_100078D78, 0, 2, &v175, (unsigned int *)&v178, 0x10u, &v192, (unsigned int *)v194);
          if (!v33)
          {
            *(void *)&long long v180 = v176;
            LODWORD(v155) = 8;
            LODWORD(v191) = 160;
            unsigned int v33 = sub_1000380B0((uint64_t)dword_100078C88, 0, 0, &v180, (unsigned int *)&v155, 8u, &v165, (unsigned int *)&v191);
          }
          if (v33) {
            goto LABEL_99;
          }
        }
        int v76 = DWORD2(v174);
        if ((~DWORD2(v174) & 0x30) == 0)
        {
          sub_100044674("found dir-stats object (id %llu) that is both shadow and calculating\n", v68, v69, v70, v71, v72, v73, v74, v191);
          sub_100048B34((char *)0x573, 92);
          int v76 = DWORD2(v174);
        }
        if ((v76 & 0x120) != 0) {
          goto LABEL_119;
        }
        if (BYTE12(v174)) {
          break;
        }
        sub_100044674("missing dir-stats object (id %llu) referenced by %s%llu files / directories\n", v68, v69, v70, v71, v72, v73, v74, v191);
        sub_100048B34((char *)0x4E1, 92);
        if ((unint64_t)(v167 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v12 = sub_10001B9D0(a1, a2, v154, v66, (uint64_t)&v165, v77, v78, v79);
          if (v12) {
            goto LABEL_286;
          }
        }
LABEL_278:
        if (v34)
        {
          uint64_t v12 = sub_10001C0E8((uint64_t)&v165, (uint64_t *)&v180);
          if (v12) {
            goto LABEL_286;
          }
          *(void *)&long long v180 = v176;
          goto LABEL_120;
        }
        *(void *)&long long v180 = v176;
LABEL_282:
        LODWORD(v190) = 8;
        unsigned int v193 = 160;
        unsigned int v33 = sub_1000380B0((uint64_t)dword_100078C88, 0, 2, &v180, (unsigned int *)&v190, 8u, &v165, &v193);
        uint64_t v175 = v174;
        uint64_t v176 = v180;
        if (v33) {
          goto LABEL_99;
        }
      }
      if ((v76 & 0x10) == 0)
      {
        if ((v76 & 0x80) != 0)
        {
          if (*((void *)&v166 + 1) && (void)v167 == *((void *)&v166 + 1)) {
            goto LABEL_155;
          }
          if ((unint64_t)(v167 + 1) < 2 || (void)v167 == *((void *)&v166 + 1))
          {
            if (!*((void *)&v166 + 1))
            {
              sub_100044674("dir-stats object (id %llu) unexpectedly marked as having origin-id\n", v68, v69, v70, v71, v72, v73, v74, v191);
              sub_100048B34((char *)0x579, -3);
              DWORD2(v174) &= ~0x80u;
            }
            goto LABEL_155;
          }
          sub_100044674("origin_id (%llu) of dir-stats object (id %llu) is not as expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v166));
          uint64_t v81 = 1400;
        }
        else
        {
          if ((void)v167) {
            BOOL v80 = *((void *)&v166 + 1) == 0;
          }
          else {
            BOOL v80 = 0;
          }
          if (v80) {
            goto LABEL_155;
          }
          if (!(void)v167) {
            goto LABEL_155;
          }
          if (!*((void *)&v166 + 1)) {
            goto LABEL_155;
          }
          sub_100044674("dir-stats object (id %llu) unexpectedly unmarked as having origin-id\n", v68, v69, v70, v71, v72, v73, v74, v191);
          sub_100048B34((char *)0x57A, -3);
          DWORD2(v174) |= 0x80u;
          if ((unint64_t)(v167 - 1) > 0xFFFFFFFFFFFFFFFDLL || *((void *)&v166 + 1) == (void)v167) {
            goto LABEL_155;
          }
          sub_100044674("origin_id (%llu) of dir-stats object (id %llu) is not as expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v166));
          uint64_t v81 = 1407;
        }
        sub_100048B34((char *)v81, -2);
        uint64_t v12 = sub_10001CA70(v154, 1, 4, v66, v153, &v167, 8, v82);
        if (v12) {
          goto LABEL_286;
        }
LABEL_155:
        int v84 = (BYTE12(v174) & 2) >> 1;
        if ((BYTE8(v174) & 0x10) == 0) {
          LOBYTE(v84) = (BYTE12(v174) & 2) == 0;
        }
        if ((v84 & 1) == 0)
        {
          if ((BYTE8(v174) & 0x10) != 0)
          {
            sub_100044674("found shadow dir-stats object (id %llu) but did not find its calculating dir-stats (%llu)\n", v68, v69, v70, v71, v72, v73, v74, v191);
            uint64_t v85 = 1396;
          }
          else
          {
            sub_100044674("found non-shadow dir-stats object (id %llu) that has calculating dir-stats\n", v68, v69, v70, v71, v72, v73, v74, v191);
            uint64_t v85 = 1408;
          }
          sub_100048B34((char *)v85, 92);
        }
        if ((void)v165)
        {
          sub_100044674("found shadow key (%llu) on non-calculating dir-stats object (id %llu)\n", v68, v69, v70, v71, v72, v73, v74, v165);
          sub_100048B34((char *)0x575, -2);
          v194[0] = 2;
          uint64_t v12 = sub_10001CA70(v154, 1, 6, v66, v153, v194, 1, v86);
          if (v12) {
            goto LABEL_286;
          }
        }
        char v87 = BYTE8(v174);
        if ((BYTE8(v174) & 0x12) == 2 && (BYTE12(v174) & 4) == 0)
        {
          sub_100044674("dir-stats object (id %llu) is SAF, but its origin isn't\n", v68, v69, v70, v71, v72, v73, v74, v191);
          sub_100048B34((char *)0x52F, 92);
          char v87 = BYTE8(v174);
        }
        if ((v87 & 2) != 0 || (BYTE12(v174) & 4) != 0)
        {
          if ((void)v168 == *((void *)&v173 + 1)) {
            goto LABEL_189;
          }
          sub_100044674("SAF descendants (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v173));
          sub_100048B34((char *)0x530, 92);
          int v88 = DWORD2(v174);
          if ((uint64_t)v168 >= 1 && !*((void *)&v173 + 1))
          {
            if ((BYTE8(v174) & 2) != 0) {
              DWORD2(v174) &= ~2u;
            }
            if ((BYTE12(v174) & 4) == 0) {
              goto LABEL_189;
            }
            uint64_t v68 = v167;
            if (!(void)v167 || (void)v167 == -1) {
              goto LABEL_189;
            }
            uint64_t v12 = sub_100026D94(v154, v167, 0x20000000, v70, v71, v72, v73, v74);
            if (v12) {
              goto LABEL_286;
            }
            uint64_t v89 = -1;
            goto LABEL_187;
          }
        }
        else
        {
          if ((void)v174 || !*((void *)&v173 + 1) || (WORD6(v174) & 0x200) != 0) {
            goto LABEL_189;
          }
          sub_100044674("SAF descendants (%llu) of dir-stats object (id %llu) is greater than expected (0)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v173));
          sub_100048B34((char *)0x59B, 92);
          int v88 = DWORD2(v174);
          if ((uint64_t)v168 >= 1 && *((void *)&v173 + 1) == (void)v168)
          {
            DWORD2(v174) |= 2u;
            uint64_t v68 = v167;
            if ((unint64_t)(v167 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
            {
              uint64_t v12 = sub_100026D04(v154, v167, 0x20000000, v70, v71, v72, v73, v74);
              if (v12) {
                goto LABEL_286;
              }
              uint64_t v89 = 1;
LABEL_187:
              *((void *)&v180 + 1) = v89;
            }
LABEL_189:
            if ((void)v168 != *((void *)&v167 + 1))
            {
              sub_100044674("descendants (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v167));
              sub_100048B34((char *)0x4E2, 92);
              uint64_t v12 = sub_10001CA70(v154, 1, 2, v66, v153, &v168, 8, v90);
              if (v12) {
                goto LABEL_286;
              }
            }
            if ((void)v169 != *((void *)&v168 + 1))
            {
              sub_100044674("physical_size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v168));
              sub_100048B34((char *)0x4E3, 92);
              uint64_t v12 = sub_10001CA70(v154, 1, 5, v66, v153, &v169, 8, v91);
              if (v12) {
                goto LABEL_286;
              }
            }
            char v92 = v151;
            if ((BYTE12(v174) & 8) == 0) {
              char v92 = 1;
            }
            if ((v92 & 1) == 0)
            {
              sub_100044548("skipping dir stats clone sizes repair because the clone mapping repairs were aborted\n", v68, v69, v70, v71, v72, v73, v74, v149);
              goto LABEL_204;
            }
            if ((BYTE12(v174) & 8) != 0 && (*((void *)&v170 + 1) & 0x8000000000000000) != 0)
            {
              sub_100044674("skipping dir stats clone sizes repair: present clone size %llu > %llu\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v170));
              uint64_t v93 = 1417;
              int v94 = 84;
LABEL_203:
              sub_100048B34((char *)v93, v94);
              goto LABEL_204;
            }
            if ((BYTE12(v174) & 8) != 0 && (v171 & 0x8000000000000000) != 0)
            {
              sub_100044548("skipping dir stats clone sizes repair because the computed clone size is negative\n", v68, v69, v70, v71, v72, v73, v74, v149);
              uint64_t v93 = 1418;
              int v94 = 92;
              goto LABEL_203;
            }
            if ((BYTE12(v174) & 8) != 0 && (BYTE8(v174) & 4) != 0) {
              goto LABEL_241;
            }
            if (!(BYTE12(v174) & 8 | BYTE8(v174) & 4)) {
              goto LABEL_204;
            }
            if ((BYTE8(v174) & 4) == 0)
            {
              if ((BYTE12(v174) & 8) == 0) {
                goto LABEL_204;
              }
              sub_100044674("clone size xfield of dir-stats object (id %llu) exists unexpectedly\n", v68, v69, v70, v71, v72, v73, v74, v191);
              sub_100048B34((char *)0x562, -3);
              v194[0] = 1;
              uint64_t v118 = v154;
              uint64_t v119 = 6;
              uint64_t v120 = v66;
              uint64_t v121 = v153;
              uint64_t v122 = 1;
LABEL_244:
              uint64_t v12 = sub_10001CA70(v118, 1, v119, v120, v121, v194, v122, v117);
              if (v12) {
                goto LABEL_286;
              }
LABEL_204:
              char v95 = BYTE8(v174);
              if ((WORD4(v174) & 0x800) != 0)
              {
                if ((~DWORD2(v174) & 9) == 0 && (BYTE12(v174) & 0x40) != 0 && (void)v173 == *((void *)&v172 + 1)) {
                  goto LABEL_220;
                }
                if ((BYTE8(v174) & 8) == 0)
                {
                  sub_100044674("purgeable resource forks are maintained on dir-stats object (id %llu) but not purgeable data forks\n", v68, v69, v70, v71, v72, v73, v74, v191);
                  sub_100048B34((char *)0x5AF, -3);
                  char v95 = BYTE8(v174) | 8;
                  DWORD2(v174) |= 8u;
                }
                if ((v95 & 1) == 0)
                {
                  sub_100044674("purgeable resource forks are maintained on dir-stats object (id %llu) but not rsrc forks\n", v68, v69, v70, v71, v72, v73, v74, v191);
                  sub_100048B34((char *)0x5B0, -3);
                  DWORD2(v174) |= 1u;
                }
                if ((BYTE12(v174) & 0x40) != 0)
                {
                  if ((void)v173 == *((void *)&v172 + 1)) {
                    goto LABEL_220;
                  }
                  sub_100044674("purgeable resource fork size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v172));
                  uint64_t v102 = 1458;
                  int v103 = 92;
                }
                else
                {
                  sub_100044674("purgeable resource fork size xfield is missing from dir-stats object (id %llu)\n", v68, v69, v70, v71, v72, v73, v74, v191);
                  uint64_t v102 = 1457;
                  int v103 = -3;
                }
                sub_100048B34((char *)v102, v103);
                *(_DWORD *)uint64_t v194 = 524292;
                *(void *)&v194[4] = v173;
                uint64_t v97 = v154;
                uint64_t v98 = 8;
                uint64_t v99 = v66;
                uint64_t v100 = v153;
                uint64_t v101 = 12;
              }
              else
              {
                if ((BYTE12(v174) & 0x40) == 0) {
                  goto LABEL_220;
                }
                sub_100044674("purgeable resource fork size xfield of dir-stats object (id %llu) exists unexpectedly\n", v68, v69, v70, v71, v72, v73, v74, v191);
                sub_100048B34((char *)0x5B3, -3);
                v194[0] = 4;
                uint64_t v97 = v154;
                uint64_t v98 = 6;
                uint64_t v99 = v66;
                uint64_t v100 = v153;
                uint64_t v101 = 1;
              }
              uint64_t v12 = sub_10001CA70(v97, 1, v98, v99, v100, v194, v101, v96);
              if (v12) {
                goto LABEL_286;
              }
LABEL_220:
              char v104 = BYTE8(v174);
              if ((BYTE8(v174) & 0x50) == 0x40)
              {
                if ((BYTE8(v174) & 8) == 0)
                {
                  sub_100044674("dir-stats object (id %llu) is purgeable, but it doesn't track purgeable size\n", v68, v69, v70, v71, v72, v73, v74, v191);
                  sub_100048B34((char *)0x568, 92);
                  goto LABEL_224;
                }
                if ((BYTE12(v174) & 0x10) == 0)
                {
LABEL_224:
                  if ((unint64_t)(v167 - 1) > 0xFFFFFFFFFFFFFFFDLL || (BYTE12(v174) & 0x10) != 0)
                  {
                    int v105 = DWORD2(v174);
                    if ((v104 & 8) != 0) {
                      goto LABEL_228;
                    }
                  }
                  else
                  {
                    sub_100044674("dir-stats object (id %llu) is purgeable, but its origin isn't\n", v68, v69, v70, v71, v72, v73, v74, v191);
                    sub_100048B34((char *)0x569, 92);
                    int v105 = DWORD2(v174);
                  }
                  __int16 v114 = v105;
                  v105 &= ~0x40u;
                  DWORD2(v174) = v105;
                  *(void *)&long long v183 = v172 - v169;
                  if ((v114 & 0x800) != 0) {
                    *((void *)&v183 + 1) = v173 - v170;
                  }
LABEL_228:
                  if ((v105 & 8) != 0 && (BYTE12(v174) & 0x20) != 0)
                  {
                    uint64_t v106 = *((void *)&v171 + 1);
                    uint64_t v107 = v172;
                    if ((void)v172 == *((void *)&v171 + 1)) {
                      goto LABEL_259;
                    }
                  }
                  else
                  {
                    if (!(v105 & 8 | BYTE12(v174) & 0x20)) {
                      goto LABEL_259;
                    }
                    if ((v105 & 8) == 0)
                    {
                      if ((BYTE12(v174) & 0x20) == 0) {
                        goto LABEL_259;
                      }
                      sub_100044674("purgeable size xfield of dir-stats object (id %llu) exists unexpectedly\n", v68, v69, v70, v71, v72, v73, v74, v191);
                      sub_100048B34((char *)0x56A, -3);
                      v194[0] = 3;
                      uint64_t v109 = v154;
                      uint64_t v110 = 6;
                      uint64_t v111 = v66;
                      uint64_t v112 = v153;
                      uint64_t v113 = 1;
                      goto LABEL_258;
                    }
                    if ((BYTE12(v174) & 0x20) == 0)
                    {
                      sub_100044674("purgeable size xfield is missing from dir-stats object (id %llu)\n", v68, v69, v70, v71, v72, v73, v74, v191);
                      uint64_t v123 = 1387;
                      int v124 = -3;
LABEL_257:
                      sub_100048B34((char *)v123, v124);
                      *(_DWORD *)uint64_t v194 = 524291;
                      *(void *)&v194[4] = v172;
                      uint64_t v109 = v154;
                      uint64_t v110 = 8;
                      uint64_t v111 = v66;
                      uint64_t v112 = v153;
                      uint64_t v113 = 12;
LABEL_258:
                      uint64_t v12 = sub_10001CA70(v109, 1, v110, v111, v112, v194, v113, v108);
                      if (v12) {
                        goto LABEL_286;
                      }
LABEL_259:
                      if (BYTE8(v174))
                      {
                        if ((void)v170 != *((void *)&v169 + 1))
                        {
                          sub_100044674("resource fork size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v169));
                          sub_100048B34((char *)0x558, 92);
                          uint64_t v127 = v154;
                          uint64_t v128 = v66;
                          uint64_t v129 = v153;
                          uint64_t v126 = &v170;
LABEL_264:
                          uint64_t v12 = sub_10001CA70(v127, 1, 7, v128, v129, v126, 8, v125);
                          if (v12) {
                            goto LABEL_286;
                          }
                        }
                      }
                      else if (*((void *)&v169 + 1))
                      {
                        sub_100044674("resource fork size (%llu) of dir-stats object (id %llu) exists unexpectedly\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v169));
                        sub_100048B34((char *)0x566, 92);
                        *(void *)uint64_t v194 = 0;
                        uint64_t v126 = (long long *)v194;
                        uint64_t v127 = v154;
                        uint64_t v128 = v66;
                        uint64_t v129 = v153;
                        goto LABEL_264;
                      }
                      unsigned int v130 = DWORD2(v174);
                      if ((WORD4(v174) & 0x400) != 0
                        || (WORD6(v174) & 0x100) != 0
                        || (void)v166 != *((void *)&v165 + 1))
                      {
                        sub_100044674("found dir-stats object (id %llu; flags 0x%x) with bad chained key (%llu/%llu)\n",
                          v68,
                          v69,
                          v70,
                          v71,
                          v72,
                          v73,
                          v74,
                          v191);
                        sub_100048B34((char *)0x591, 92);
                        if (*((void *)&v165 + 1) != (void)v166)
                        {
                          uint64_t v12 = sub_10001CA70(v154, 1, 1, v66, v153, &v166, 8, v74);
                          if (v12) {
                            goto LABEL_286;
                          }
                        }
                        unsigned int v130 = DWORD2(v174);
                        if ((WORD4(v174) & 0x400) != 0)
                        {
                          unsigned int v130 = DWORD2(v174) & 0xFFFFFBFF;
                          DWORD2(v174) &= ~0x400u;
                        }
                        if ((v152 & 0x200) != 0)
                        {
                          DWORD2(v174) = v130 | 0x100;
                          uint64_t v12 = sub_10001BE28(a1, a2, v154, v191, v166);
                          if (v12) {
                            goto LABEL_286;
                          }
                          unsigned int v130 = DWORD2(v174);
                        }
                      }
                      if (v76 != v130)
                      {
                        uint64_t v12 = sub_10001CA70(v154, 1, 3, v66, v153, (unsigned char *)&v174 + 8, 4, v74);
                        if (v12) {
                          goto LABEL_286;
                        }
                        uint64_t v12 = sub_100039A6C(dword_100078C88, 0, &v191, 8, &v165, 160);
                        if (v12) {
                          goto LABEL_286;
                        }
                      }
                      goto LABEL_278;
                    }
                    uint64_t v106 = *((void *)&v171 + 1);
                    uint64_t v107 = v172;
                  }
                  if (v107 == v106) {
                    goto LABEL_259;
                  }
                  sub_100044674("purgeable size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, v106);
                  uint64_t v123 = 1388;
                  int v124 = 92;
                  goto LABEL_257;
                }
              }
              LOBYTE(v105) = BYTE8(v174);
              goto LABEL_228;
            }
            if ((BYTE12(v174) & 8) != 0)
            {
LABEL_241:
              if ((void)v171 == *((void *)&v170 + 1)) {
                goto LABEL_204;
              }
              sub_100044674("clone size (%llu) of dir-stats object (id %llu) is %s than expected (%llu)\n", v68, v69, v70, v71, v72, v73, v74, SBYTE8(v170));
              uint64_t v115 = 1380;
              int v116 = 92;
            }
            else
            {
              sub_100044674("clone size xfield is missing from dir-stats object (id %llu)\n", v68, v69, v70, v71, v72, v73, v74, v191);
              uint64_t v115 = 1379;
              int v116 = -3;
            }
            sub_100048B34((char *)v115, v116);
            *(_DWORD *)uint64_t v194 = 524289;
            *(void *)&v194[4] = v171;
            uint64_t v118 = v154;
            uint64_t v119 = 8;
            uint64_t v120 = v66;
            uint64_t v121 = v153;
            uint64_t v122 = 12;
            goto LABEL_244;
          }
        }
        DWORD2(v174) = v88 | 0x100;
        goto LABEL_189;
      }
      if ((v76 & 0x80) != 0)
      {
        sub_100044674("shadow dir-stats object (id %llu) unexpectedly marked as having origin-id\n", v68, v69, v70, v71, v72, v73, v74, v191);
        sub_100048B34((char *)0x57D, -3);
        DWORD2(v174) &= ~0x80u;
      }
      else if (!(void)v167)
      {
        if (!*((void *)&v166 + 1)) {
          goto LABEL_155;
        }
        goto LABEL_152;
      }
      if (!*((void *)&v166 + 1))
      {
LABEL_153:
        if ((void)v167)
        {
          sub_100044674("found shadow dir-stats object (id %llu) with origin (id %llu)\n", v68, v69, v70, v71, v72, v73, v74, v191);
          sub_100048B34((char *)0x572, -2);
        }
        goto LABEL_155;
      }
LABEL_152:
      sub_100044674("shadow dir-stats object (id %llu) unexpectedly has origin-id\n", v68, v69, v70, v71, v72, v73, v74, v191);
      sub_100048B34((char *)0x57E, -2);
      *(void *)uint64_t v194 = 0;
      uint64_t v12 = sub_10001CA70(v154, 1, 4, v66, v153, v194, 8, v83);
      if (v12) {
        goto LABEL_286;
      }
      goto LABEL_153;
    }
LABEL_102:
    uint64_t v11 = 0;
    goto LABEL_291;
  }
  while (1)
  {
    char v35 = BYTE12(v174);
    if ((BYTE12(v174) & 1) == 0) {
      break;
    }
LABEL_88:
    if ((v35 & 1) == 0)
    {
      uint64_t v12 = sub_10001B590(a1, a2, v177, (uint64_t)&v165);
      if (v12) {
        goto LABEL_286;
      }
    }
    unsigned int v158 = 8;
    unsigned int v157 = 160;
    if (sub_1000380B0((uint64_t)dword_100078C88, 0, 2, &v177, &v158, 8u, &v165, &v157)) {
      goto LABEL_15;
    }
  }
  uint64_t v36 = a1;
  uint64_t v37 = v177;
  *(void *)uint64_t v194 = v177;
  uint64_t v38 = a2[6];
  if (!v38) {
    uint64_t v38 = a2[5];
  }
  uint64_t v39 = *(void *)(v38 + 56);
  unint64_t v155 = v177 & 0xFFFFFFFFFFFFFFFLL | 0xA000000000000000;
  unint64_t v178 = v177 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000;
  if ((v39 & 0x200) != 0) {
    int v40 = 18;
  }
  else {
    int v40 = 10;
  }
  LODWORD(v179) = 18;
  if ((v39 & 0x200) != 0) {
    uint64_t v41 = &v178;
  }
  else {
    uint64_t v41 = &v155;
  }
  if ((v39 & 0x200) != 0) {
    unsigned int v42 = 12;
  }
  else {
    unsigned int v42 = 8;
  }
  unsigned int v193 = v42;
  long long v180 = 0u;
  long long v181 = 0u;
  if ((v39 & 0x200) != 0)
  {
    unsigned int v45 = 3808;
    uint64_t v46 = (long long *)malloc_type_calloc(1uLL, 0xEE0uLL, 0x795FFC9AuLL);
    if (!v46)
    {
      sub_10004458C("failed to allocate memory for dir-stats lookup\n", v47, v48, v49, v13, v14, v15, v16, v147);
      uint64_t v11 = 12;
      sub_100048B34((char *)0x560, 12);
      uint64_t v43 = 0;
      goto LABEL_290;
    }
    uint64_t v44 = v46;
    uint64_t v43 = v46;
  }
  else
  {
    uint64_t v43 = 0;
    uint64_t v44 = &v180;
    unsigned int v45 = 32;
  }
  unsigned int v192 = v45;
  uint64_t v191 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v50 = sub_10003E25C(v36, a2, v40, &v191, v13, v14, v15, v16);
  if (!v50)
  {
    uint64_t v51 = sub_1000380B0(v191, qword_100078C80, 0, v41, &v193, v42, v44, &v192);
    if (v51)
    {
      uint64_t v11 = v51;
      a1 = v36;
      uint64_t v6 = (unsigned char *)&unk_100078000;
      uint64_t v7 = (void *)&unk_100078000;
      if (v51 != 2)
      {
        strerror(v51);
        sub_10004458C("failed to look up dir-stats object (id %llu): %s\n", v138, v139, v140, v141, v142, v143, v144, v37);
        uint64_t v145 = 1247;
        goto LABEL_289;
      }
      goto LABEL_87;
    }
    WORD6(v174) |= 1u;
    a1 = v36;
    uint64_t v6 = (unsigned char *)&unk_100078000;
    uint64_t v7 = (void *)&unk_100078000;
    if ((v39 & 0x200) == 0)
    {
      uint64_t v59 = *((void *)&v180 + 1);
      BOOL v60 = __OFADD__((void)v168, (void)v180);
      *((void *)&v167 + 1) = v180;
      *(void *)&long long v168 = v168 + v180;
      *((void *)&v168 + 1) = *((void *)&v180 + 1);
      if (v60)
      {
        sub_100044674("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v37);
        *(void *)&long long v168 = 0x7FFFFFFFFFFFFFFFLL;
        sub_100048B34((char *)0x56D, 84);
        uint64_t v59 = *((void *)&v180 + 1);
      }
      BOOL v60 = __OFADD__((void)v169, v59);
      *(void *)&long long v169 = v169 + v59;
      if (v60)
      {
        sub_100044674("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v37);
        *(void *)&long long v169 = 0x7FFFFFFFFFFFFFFFLL;
        sub_100048B34((char *)0x56D, 84);
      }
      *(void *)&long long v167 = -1;
      goto LABEL_86;
    }
    DWORD2(v174) = *((_DWORD *)v43 + 12);
    uint64_t v61 = ((DWORD2(v174) >> 4) & 1) - 1;
    if (*((void *)v43 + 3)) {
      uint64_t v61 = *((void *)v43 + 3);
    }
    *((void *)&v166 + 1) = *((void *)v43 + 3);
    *(void *)&long long v167 = v61;
    uint64_t v62 = *((void *)v43 + 1);
    BOOL v60 = __OFADD__((void)v168, *(void *)v43);
    uint64_t v63 = v168 + *(void *)v43;
    *((void *)&v167 + 1) = *(void *)v43;
    *(void *)&long long v168 = v63;
    *((void *)&v168 + 1) = v62;
    if (v60)
    {
      sub_100044674("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v37);
      *(void *)&long long v168 = 0x7FFFFFFFFFFFFFFFLL;
      sub_100048B34((char *)0x56D, 84);
      uint64_t v62 = *((void *)v43 + 1);
    }
    BOOL v60 = __OFADD__((void)v169, v62);
    *(void *)&long long v169 = v169 + v62;
    if (v60)
    {
      sub_100044674("dir-stats object (id %llu): %s overflow\n", v52, v53, v54, v55, v56, v57, v58, v37);
      *(void *)&long long v169 = 0x7FFFFFFFFFFFFFFFLL;
      sub_100048B34((char *)0x56D, 84);
    }
    __int16 v64 = WORD4(v174);
    if (BYTE8(v174))
    {
      *((void *)&v169 + 1) = *((void *)v43 + 2);
      sub_1000194FC((char *)&v170, *((uint64_t *)&v169 + 1), v37, (uint64_t)"resource fork size", v55, v56, v57, v58);
      __int16 v64 = WORD4(v174);
      if ((BYTE8(v174) & 4) == 0)
      {
LABEL_70:
        if ((v64 & 8) == 0)
        {
LABEL_80:
          if ((v64 & 0x800) != 0)
          {
            uint64_t v190 = 0;
            if (!sub_10003EE64((unsigned __int16 *)v43 + 26, v192 - 52, 4, &v190, 0, 0, 0))
            {
              WORD6(v174) |= 0x40u;
              *((void *)&v172 + 1) = *v190;
              sub_1000194FC((char *)&v173, *v190, *(uint64_t *)v194, (uint64_t)"purgeable rsrc size", v55, v56, v57, v58);
            }
            LOBYTE(v64) = BYTE8(v174);
          }
          if ((v64 & 2) != 0)
          {
            WORD6(v174) |= 4u;
            sub_1000194FC((char *)&v173 + 8, *(void *)v43, *(uint64_t *)v194, (uint64_t)"SAF descendants", v55, v56, v57, v58);
          }
LABEL_86:
          WORD6(v174) |= 0x200u;
          uint64_t v12 = sub_100039A6C(dword_100078C88, 0, v194, 8, &v165, 160);
          if (v12) {
            goto LABEL_286;
          }
LABEL_87:
          free(v43);
          char v35 = BYTE12(v174);
          goto LABEL_88;
        }
LABEL_76:
        uint64_t v190 = 0;
        if (!sub_10003EE64((unsigned __int16 *)v43 + 26, v192 - 52, 3, &v190, 0, 0, 0))
        {
          WORD6(v174) |= 0x20u;
          *((void *)&v171 + 1) = *v190;
          sub_1000194FC((char *)&v172, *v190, *(uint64_t *)v194, (uint64_t)"purgeable size", v55, v56, v57, v58);
        }
        __int16 v64 = WORD4(v174);
        if ((BYTE8(v174) & 0x40) != 0) {
          WORD6(v174) |= 0x10u;
        }
        goto LABEL_80;
      }
    }
    else if ((BYTE8(v174) & 4) == 0)
    {
      goto LABEL_70;
    }
    uint64_t v190 = 0;
    if (!sub_10003EE64((unsigned __int16 *)v43 + 26, v192 - 52, 1, &v190, 0, 0, 0))
    {
      WORD6(v174) |= 8u;
      *((void *)&v170 + 1) = *v190;
      sub_1000194FC((char *)&v171, *v190, *(uint64_t *)v194, (uint64_t)"clone size", v55, v56, v57, v58);
    }
    __int16 v64 = WORD4(v174);
    if ((BYTE8(v174) & 8) == 0) {
      goto LABEL_80;
    }
    goto LABEL_76;
  }
  uint64_t v11 = v50;
  strerror(v50);
  sub_10004458C("failed to get fsroot tree for jobj type %d: %s\n", v131, v132, v133, v134, v135, v136, v137, v40);
  uint64_t v145 = 1447;
LABEL_289:
  sub_100048B34((char *)v145, v11);
LABEL_290:
  free(v43);
LABEL_291:
  sub_10001914C();
  return v11;
}

uint64_t sub_10001B2C0()
{
  if (!qword_100078CD0) {
    return 0;
  }
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v0 = xmmword_100078CD8;
  uint64_t result = sub_10001C220((uint64_t)&xmmword_100078CD8, &v55, &v54);
  if (result) {
    return result;
  }
  uint64_t v2 = v54;
  uint64_t v3 = v55;
  if (!v55 && !v0 && v54 == 0)
  {
    uint64_t v5 = 0;
LABEL_10:
    uint64_t result = sub_10001C948(v2, v5);
    if (!result)
    {
      uint64_t result = sub_10001C4E4(qword_100078CD0, &xmmword_100078CD8);
      if (!result) {
        qword_100078CD0 = 0;
      }
    }
    return result;
  }
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v52 = v6;
  long long v53 = v6;
  long long v50 = v6;
  long long v51 = v6;
  long long v48 = v6;
  long long v49 = v6;
  long long v46 = v6;
  long long v47 = v6;
  long long v44 = v6;
  long long v45 = v6;
  long long v42 = 0u;
  long long v43 = 0u;
  long long __s2 = 0u;
  long long v41 = 0u;
  unsigned int v38 = 160;
  unsigned int v39 = 8;
  uint64_t result = sub_1000380B0((uint64_t)dword_100078C88, 0, 0, &qword_100078CD0, &v39, 8u, &v44, &v38);
  if (result) {
    return result;
  }
  if (qword_100078CE8) {
    BOOL v7 = (void)v45 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  int v8 = v7;
  unsigned int v9 = (unint64_t)(qword_100078CF8 - 1) < 0xFFFFFFFFFFFFFFFELL;
  if (v8 == 1)
  {
    unsigned int v10 = ((unsigned __int16)word_100078D74 >> 2) & 1;
  }
  else
  {
    unsigned int v9 = (unint64_t)(qword_100078CF8 - 1) < 0xFFFFFFFFFFFFFFFELL && (unint64_t)(v46 + 1) < 2;
    unsigned int v10 = ((BYTE12(v53) & 4) == 0) & ((unsigned __int16)word_100078D74 >> 2);
  }
  sub_10001C2C0((uint64_t)&v44, v8, word_100078D74 & ((BYTE12(v53) & 1) == 0), v9, v10, (uint64_t)&__s2);
  if (!v0) {
    goto LABEL_53;
  }
  *(void *)&long long v18 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v18 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v36 = v18;
  long long v37 = v18;
  long long v34 = v18;
  long long v35 = v18;
  long long v32 = v18;
  long long v33 = v18;
  v30[2] = v18;
  long long v31 = v18;
  v30[0] = v18;
  v30[1] = v18;
  if ((void)xmmword_100078CD8) {
    BOOL v19 = (void)v44 == 0;
  }
  else {
    BOOL v19 = 0;
  }
  int v20 = v19;
  sub_10001C2C0((uint64_t)&v44, v20, 0, 0, 0, (uint64_t)v28);
  uint64_t result = sub_10001C180(v0, v30);
  if (!result)
  {
    if (v20) {
      uint64_t v29 = v29 - v37 - (BYTE12(v37) & 1);
    }
    sub_10001C3E8(v0, (char *)v30, v28, v21, v22, v23, v24, v25);
    if (word_100078D74) {
      WORD6(v37) |= 2u;
    }
    uint64_t result = sub_10001C4E4(v0, v30);
    char v26 = v8 ^ 1;
    if (result) {
      char v26 = 1;
    }
    if (v26)
    {
      if (result) {
        return result;
      }
      goto LABEL_53;
    }
    *(void *)&long long __s2 = v31 + v9;
    *((void *)&__s2 + 1) = *((void *)&v36 + 1) + v10;
    uint64_t v27 = v33;
    *((void *)&v41 + 1) = v32;
    *(void *)&long long v42 = v33;
    *((void *)&v42 + 1) = v34;
    if ((BYTE8(v37) & 0x40) != 0)
    {
      *(void *)&long long v43 = v32;
      if ((WORD4(v37) & 0x800) != 0) {
        goto LABEL_52;
      }
    }
    else
    {
      *(void *)&long long v43 = v35;
      if ((WORD4(v37) & 0x800) != 0)
      {
        uint64_t v27 = v36;
LABEL_52:
        *((void *)&v43 + 1) = v27;
      }
    }
LABEL_53:
    uint64_t result = sub_10001C790(v3, (uint64_t *)&__s2, v12, v13, v14, v15, v16, v17);
    if (result) {
      return result;
    }
    uint64_t v5 = v41;
    goto LABEL_10;
  }
  return result;
}

uint64_t sub_10001B590(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v81 = a3;
  if ((~*(_DWORD *)(a4 + 152) & 0x410) == 0 && (*(_WORD *)(a4 + 156) & 0x100) == 0)
  {
    int v7 = 0;
    uint64_t v8 = *(void *)(a4 + 8);
    goto LABEL_9;
  }
  uint64_t v9 = *(void *)(a4 + 32);
  if ((unint64_t)(v9 + 1) <= 1) {
    uint64_t v9 = *(void *)(a4 + 24);
  }
  if ((unint64_t)(v9 - 1) > 0xFFFFFFFFFFFFFFFDLL) {
    return 0;
  }
  if (v9 == 2)
  {
    uint64_t v8 = 0;
    int v7 = 0;
    goto LABEL_9;
  }
  uint64_t v74 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v85 = v9 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  unsigned int v84 = 8;
  char v26 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x7D96CC06uLL);
  int v83 = 3808;
  uint64_t v82 = 0;
  if (!v26)
  {
    sub_10004458C("unable to allocate memory to repair dir-stats chained key\n", v19, v20, v21, v22, v23, v24, v25, v73);
    uint64_t v10 = 12;
    uint64_t v35 = 1430;
    int v36 = 12;
    goto LABEL_24;
  }
  uint64_t v27 = sub_10003E25C(a1, a2, 3, &v74, v22, v23, v24, v25);
  if (v27)
  {
    uint64_t v10 = v27;
    sub_10004458C("failed to init fsroot tree to repair dir-stats chained key\n", v28, v29, v30, v31, v32, v33, v34, v73);
    uint64_t v35 = 1431;
LABEL_19:
    int v36 = v10;
LABEL_24:
    sub_100048B34((char *)v35, v36);
    free(v26);
    return v10;
  }
  uint64_t v45 = sub_1000380B0(v74, qword_100078C80, 0, &v85, &v84, 8u, v26, (unsigned int *)&v83);
  if (v45)
  {
    uint64_t v10 = v45;
    if (v45 == 2)
    {
      free(v26);
      return 0;
    }
    strerror(v45);
    sub_10004458C("unable to load inode (id %llu) to repair dir-stats chained key: %s\n", v58, v59, v60, v61, v62, v63, v64, v9);
    sub_100048B34((char *)0x598, v10);
    int v7 = 0;
    goto LABEL_32;
  }
  uint64_t v46 = *(void *)v26;
  uint64_t v85 = *(void *)v26 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  int v83 = 3808;
  uint64_t v47 = sub_1000380B0(v74, qword_100078C80, 0, &v85, &v84, v84, v26, (unsigned int *)&v83);
  if (v47)
  {
    uint64_t v10 = v47;
    strerror(v47);
    sub_10004458C("unable to load inode (id %llu) to repair dir-stats chained key: %s\n", v51, v52, v53, v54, v55, v56, v57, v46);
    uint64_t v35 = 1433;
    goto LABEL_19;
  }
  int v7 = (v26[12] >> 29) & 1;
  uint64_t v65 = sub_10003F4CC((uint64_t)v26, v83, 10, 8, &v82, v48, v49, v50);
  if (v65)
  {
    uint64_t v10 = v65;
    if (v65 != 2)
    {
      strerror(v65);
      sub_10004458C("unable to get dir-stats key of inode (id %llu) to repair dir-stats chained key: %s\n", v66, v67, v68, v69, v70, v71, v72, v46);
      sub_100048B34((char *)0x59A, v10);
LABEL_32:
      free(v26);
      if (v10) {
        return v10;
      }
LABEL_10:
      if (!v7) {
        return 0;
      }
      goto LABEL_11;
    }
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = *v82;
  }
  free(v26);
LABEL_9:
  if (v8 == *(void *)(a4 + 16)) {
    goto LABEL_10;
  }
  unint64_t v11 = -*(void *)(a4 + 136) - (((unint64_t)*(unsigned __int16 *)(a4 + 156) >> 2) & 1);
  uint64_t v12 = ~*(void *)(a4 + 144);
  uint64_t v13 = -*(void *)(a4 + 64);
  uint64_t v14 = -*(void *)(a4 + 80);
  uint64_t v15 = -*(void *)(a4 + 96);
  uint64_t v16 = -*(void *)(a4 + 112);
  uint64_t v17 = -*(void *)(a4 + 128);
  uint64_t v74 = ~*(void *)(a4 + 48);
  v75.i64[0] = v11;
  v75.i64[1] = v12;
  uint64_t v76 = v13;
  uint64_t v77 = v14;
  uint64_t v78 = v15;
  uint64_t v79 = v16;
  uint64_t v80 = v17;
  uint64_t v18 = sub_10001C0E8(a4, &v74);
  if (v18) {
    return v18;
  }
  *(void *)(a4 + 16) = v8;
  unint64_t v37 = ((unint64_t)*(unsigned __int16 *)(a4 + 156) >> 2) & 1;
  uint64_t v38 = *(void *)(a4 + 64);
  uint64_t v39 = *(void *)(a4 + 80);
  uint64_t v40 = *(void *)(a4 + 96);
  uint64_t v41 = *(void *)(a4 + 112);
  uint64_t v42 = *(void *)(a4 + 128);
  uint64_t v74 = *(void *)(a4 + 48) + 1;
  int64x2_t v43 = vdupq_n_s64(1uLL);
  v43.i64[0] = v37;
  int64x2_t v75 = vaddq_s64(*(int64x2_t *)(a4 + 136), v43);
  uint64_t v76 = v38;
  uint64_t v77 = v39;
  uint64_t v78 = v40;
  uint64_t v79 = v41;
  uint64_t v80 = v42;
  uint64_t v10 = sub_10001C0E8(a4, &v74);
  if (v10) {
    return v10;
  }
  if (v7) {
LABEL_11:
  }
    *(_WORD *)(a4 + 156) |= 0x400u;
  uint64_t v10 = sub_100039A6C(dword_100078C88, 0, &v81, 8, (const void *)a4, 160);
  if (!v10) {
    return 0;
  }
  return v10;
}

uint64_t sub_10001B940(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = (a4 & 0xFFFFFFFC) == 0x5C || (*(void *)(a3 + 48) & 2) == 0;
  if (v8) {
    return 0;
  }
  unint64_t v11 = 0;
  LODWORD(result) = sub_10003F4CC(a3, a4, 10, 8, &v11, a6, a7, a8);
  if (result)
  {
    if (result == 2) {
      return 0;
    }
    else {
      return result;
    }
  }
  else
  {
    BOOL v8 = *v11 == *(void *)a5;
    *(unsigned char *)(a5 + 8) = v8;
    if (v8) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
}

uint64_t sub_10001B9D0(uint64_t a1, void *a2, _DWORD *a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = a2[6];
  uint64_t v13 = v12;
  if (!v12) {
    uint64_t v13 = a2[5];
  }
  if ((*(unsigned char *)(v13 + 57) & 2) != 0)
  {
    uint64_t v17 = *(void *)(a5 + 16);
    if (!v17) {
      goto LABEL_9;
    }
    if (!v12) {
      uint64_t v12 = a2[5];
    }
    if ((*(unsigned char *)(v12 + 57) & 2) == 0)
    {
LABEL_9:
      unsigned int v18 = 0;
      goto LABEL_10;
    }
    uint64_t v95 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v96 = v17 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000;
    LODWORD(v97) = 18;
    unsigned int v93 = 3808;
    unsigned int v94 = 12;
    uint64_t v34 = sub_10003E25C(a1, a2, 18, &v95, a5, a6, a7, a8);
    if (v34)
    {
      uint64_t v16 = v34;
      strerror(v34);
      sub_10004458C("failed to get fsroot tree to find expanded dir-stats %llu: %s\n", v35, v36, v37, v38, v39, v40, v41, v17);
      sub_100048B34((char *)0x5A1, v16);
      uint64_t v42 = 0;
    }
    else
    {
      uint64_t v42 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x76402777uLL);
      if (v42)
      {
        uint64_t v61 = sub_1000380B0(v95, a2[7], 0, &v96, &v94, 0xCu, v42, &v93);
        if (!v61)
        {
          unsigned int v18 = v42[12];
          free(v42);
          if (v18 <= 0xFFF)
          {
LABEL_10:
            int v19 = ((int)(v18 << 29) >> 31) & 0xC;
            if ((v18 & 8) != 0) {
              int v19 = (((int)(v18 << 29) >> 31) & 0xC) + 12;
            }
            if (v18 >= 0x800) {
              v19 += 12;
            }
            if (v19) {
              uint64_t v20 = (v19 + 4);
            }
            else {
              uint64_t v20 = 0;
            }
            uint64_t v21 = malloc_type_calloc(1uLL, (v20 + 52), 0xB6DF1EDFuLL);
            uint64_t v29 = v21;
            if (v21)
            {
              *uint64_t v21 = *(void *)(a5 + 48);
              v21[1] = *(void *)(a5 + 64);
              v21[4] = v17;
              v21[5] = (random() << 32) | 0x80000000;
              uint64_t v29[3] = *(void *)(a5 + 32);
              int v32 = *((_DWORD *)v29 + 12);
              int v33 = v32 | 0x80;
              *((_DWORD *)v29 + 12) = v32 | 0x80;
              if ((v18 & 1) != 0 || !*(void *)(a5 + 144))
              {
                v29[2] = *(void *)(a5 + 80);
                int v33 = v32 | 0x81;
                *((_DWORD *)v29 + 12) = v32 | 0x81;
                if ((v18 & 4) == 0)
                {
LABEL_21:
                  if ((v18 & 8) == 0) {
                    goto LABEL_37;
                  }
                  goto LABEL_34;
                }
              }
              else if ((v18 & 4) == 0)
              {
                goto LABEL_21;
              }
              uint64_t v43 = sub_10003EF1C((unsigned __int16 *)v29 + 26, v20, 1, (const void *)(a5 + 96), 8, 0, v30, v31);
              if (!v43)
              {
                int v33 = *((_DWORD *)v29 + 12) | 4;
                *((_DWORD *)v29 + 12) = v33;
                if ((v18 & 8) == 0) {
                  goto LABEL_37;
                }
LABEL_34:
                uint64_t v71 = sub_10003EF1C((unsigned __int16 *)v29 + 26, v20, 3, (const void *)(a5 + 112), 8, 0, v30, v31);
                if (v71)
                {
                  uint64_t v16 = v71;
                  char v72 = strerror(v71);
                  sub_10004458C("can't add purgeable size for dir-stats: %s (%d)\n", v73, v74, v75, v76, v77, v78, v79, v72);
                  uint64_t v80 = 1446;
LABEL_40:
                  sub_100048B34((char *)v80, v16);
                  goto LABEL_52;
                }
                int v33 = *((_DWORD *)v29 + 12) | 8;
                *((_DWORD *)v29 + 12) = v33;
LABEL_37:
                if (v18 >= 0x800)
                {
                  uint64_t v81 = sub_10003EF1C((unsigned __int16 *)v29 + 26, v20, 4, (const void *)(a5 + 128), 8, 0, v30, v31);
                  if (v81)
                  {
                    uint64_t v16 = v81;
                    char v82 = strerror(v81);
                    sub_10004458C("can't add purgeable resource fork size for dir-stats: %s (%d)\n", v83, v84, v85, v86, v87, v88, v89, v82);
                    uint64_t v80 = 1454;
                    goto LABEL_40;
                  }
                  int v33 = *((_DWORD *)v29 + 12) | 0x800;
                  *((_DWORD *)v29 + 12) = v33;
                }
                int v90 = *(_WORD *)(a5 + 156) & 0x404;
                if ((v18 & 0x100) != 0 || v90 == 4)
                {
                  if (v90 == 4) {
                    v33 |= 2u;
                  }
                  *((_DWORD *)v29 + 12) = v33 | v18 & 0x100;
                }
                uint64_t v16 = sub_10001CA70(a3, 2, 0, a4, 12, v29, (v20 + 52), v31);
                goto LABEL_52;
              }
              uint64_t v16 = v43;
              char v44 = strerror(v43);
              sub_10004458C("can't add clone size for dir-stats: %s (%d)\n", v45, v46, v47, v48, v49, v50, v51, v44);
              uint64_t v52 = 1445;
              int v53 = v16;
            }
            else
            {
              sub_10004458C("failed to allocate memory for insertion of dir-stats\n", v22, v23, v24, v25, v26, v27, v28, v92);
              uint64_t v16 = 12;
              uint64_t v52 = 1444;
              int v53 = 12;
            }
            sub_100048B34((char *)v52, v53);
LABEL_52:
            free(v29);
            return v16;
          }
          uint64_t v16 = 0;
LABEL_44:
          uint64_t v29 = 0;
          goto LABEL_52;
        }
        uint64_t v16 = v61;
        strerror(v61);
        sub_10004458C("unable to load dir-stats %llu to retrieve attributes: %s\n", v62, v63, v64, v65, v66, v67, v68, v17);
        uint64_t v69 = 1443;
        int v70 = v16;
      }
      else
      {
        sub_10004458C("failed to allocate memory to find dir-stats %llu\n", v54, v55, v56, v57, v58, v59, v60, v17);
        uint64_t v16 = 12;
        uint64_t v69 = 1442;
        int v70 = 12;
      }
      sub_100048B34((char *)v69, v70);
    }
    free(v42);
    goto LABEL_44;
  }
  uint64_t v14 = *(void *)(a5 + 64);
  unint64_t v96 = *(void *)(a5 + 48);
  uint64_t v97 = v14;
  uint64_t v98 = *(void *)(a5 + 16);
  uint64_t v99 = (random() << 32) | 0x80000000;
  return sub_10001CA70(a3, 2, 0, a4, 8, &v96, 32, v15);
}

BOOL sub_10001BDE8(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 152);
  if ((v1 & 0x800) != 0)
  {
    if ((~v1 & 9) != 0 || (*(_WORD *)(a1 + 156) & 0x40) == 0) {
      return 0;
    }
    return *(void *)(a1 + 128) == *(void *)(a1 + 120);
  }
  else
  {
    return (*(_WORD *)(a1 + 156) & 0x40) == 0;
  }
}

uint64_t sub_10001BE28(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  *(void *)uint64_t v56 = a5;
  if (!a5) {
    return 0;
  }
  uint64_t v5 = a5;
  uint64_t v55 = 0xAAAAAAAAAAAAAAAALL;
  DWORD2(v54) = 18;
  *(void *)&long long v54 = 0;
  unsigned int v53 = 12;
  uint64_t v16 = malloc_type_calloc(1uLL, 0xEE0uLL, 0xFBCF800FuLL);
  unsigned int v52 = 3808;
  if (!v16)
  {
    sub_10004458C("failed to allocate memory to mark dir-stats chain as inconsistent\n", v9, v10, v11, v12, v13, v14, v15, v46);
    uint64_t v25 = 12;
    uint64_t v26 = 1426;
    int v27 = 12;
    goto LABEL_7;
  }
  uint64_t v17 = sub_10003E25C(a1, a2, 18, &v55, v12, v13, v14, v15);
  if (v17)
  {
    uint64_t v25 = v17;
    sub_10004458C("failed to init fsroot tree to mark dir-stats chain as inconsistent\n", v18, v19, v20, v21, v22, v23, v24, v46);
    uint64_t v26 = 1427;
    int v27 = v25;
LABEL_7:
    sub_100048B34((char *)v26, v27);
    goto LABEL_8;
  }
  int v29 = 513;
  while (1)
  {
    if (!--v29)
    {
      sub_100044674("performed too many chained-key iterations (current id %llu); can't mark the entire chain as needing reconciliation\n",
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v5);
      sub_100048B34((char *)0x594, 92);
LABEL_24:
      uint64_t v25 = 0;
      goto LABEL_8;
    }
    int v51 = 0;
    *(void *)&long long v54 = v5 & 0xFFFFFFFFFFFFFFFLL | 0xE000000000000000;
    *(void *)&long long v30 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v30 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v49[8] = v30;
    long long v50 = v30;
    v49[6] = v30;
    v49[7] = v30;
    v49[4] = v30;
    v49[5] = v30;
    v49[2] = v30;
    v49[3] = v30;
    v49[0] = v30;
    v49[1] = v30;
    unsigned int v47 = 160;
    unsigned int v48 = 8;
    uint64_t v31 = sub_1000380B0((uint64_t)dword_100078C88, 0, 0, v56, &v48, 8u, v49, &v47);
    if (v31) {
      break;
    }
    int v34 = DWORD2(v50);
    if ((WORD4(v50) & 0x100) != 0) {
      goto LABEL_20;
    }
    DWORD2(v50) |= 0x100u;
    int v51 = v34 | 0x100;
    uint64_t v35 = sub_100039A6C(dword_100078C88, 0, v56, 8, v49, 160);
    if (v35) {
      goto LABEL_27;
    }
LABEL_19:
    sub_100044674("need to mark dir-stats %llu as needing reconciliation, due to an issue with dir-stats %llu\n", v18, v19, v20, v21, v22, v23, v24, v56[0]);
    uint64_t v35 = sub_10001CA70(a3, 1, 3, &v54, v53, &v51, 4, v36);
    if (v35)
    {
LABEL_27:
      uint64_t v25 = v35;
      goto LABEL_8;
    }
LABEL_20:
    uint64_t v5 = v16[4];
    if (v5 != *(void *)v56)
    {
      *(void *)uint64_t v56 = v16[4];
      if (v5) {
        continue;
      }
    }
    goto LABEL_24;
  }
  uint64_t v25 = v31;
  if (v31 != 2) {
    goto LABEL_8;
  }
  unsigned int v52 = 3808;
  uint64_t v32 = sub_1000380B0(v55, qword_100078C80, 0, &v54, &v53, v53, v16, &v52);
  if (!v32)
  {
    int v33 = *((_DWORD *)v16 + 12);
    int v51 = v33 | 0x100;
    if ((v33 & 0x100) != 0) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v37 = v32;
  uint64_t v25 = 0;
  if (v32 != 2)
  {
    char v38 = v56[0];
    strerror(v32);
    sub_10004458C("failed to look up dir-stats object (id %llu): %s\n", v39, v40, v41, v42, v43, v44, v45, v38);
    sub_100048B34((char *)0x595, v37);
    uint64_t v25 = v37;
  }
LABEL_8:
  free(v16);
  return v25;
}

uint64_t sub_10001C0E8(uint64_t a1, uint64_t *a2)
{
  uint64_t v12 = 0;
  *(void *)uint64_t v13 = 0;
  memset(__s1, 0, sizeof(__s1));
  uint64_t result = memcmp(__s1, a2, 0x40uLL);
  if (result)
  {
    uint64_t result = sub_10001C220(a1, (uint64_t *)v13, &v12);
    if (!result)
    {
      uint64_t result = sub_10001C948(v12, a2[2]);
      if (!result)
      {
        uint64_t v11 = *(void *)v13;
        return sub_10001C790(v11, a2, v5, v6, v7, v8, v9, v10);
      }
    }
  }
  return result;
}

uint64_t sub_10001C180(uint64_t a1, _OWORD *a2)
{
  uint64_t v6 = a1;
  unsigned int v4 = 160;
  unsigned int v5 = 8;
  uint64_t result = sub_1000380B0((uint64_t)dword_100078C88, 0, 0, &v6, &v5, 8u, a2, &v4);
  if (result == 2)
  {
    a2[8] = 0u;
    a2[9] = 0u;
    a2[6] = 0u;
    a2[7] = 0u;
    a2[4] = 0u;
    a2[5] = 0u;
    a2[2] = 0u;
    a2[3] = 0u;
    *a2 = 0u;
    a2[1] = 0u;
    return sub_100039A6C(dword_100078C88, 0, &v6, 8, a2, 160);
  }
  return result;
}

uint64_t sub_10001C220(uint64_t a1, uint64_t *a2, void *a3)
{
  *a3 = 0;
  *a2 = 0;
  uint64_t v4 = *(void *)(a1 + 16);
  if (!v4) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 152) & 0x10) != 0)
  {
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v18 = v8;
    long long v19 = v8;
    long long v16 = v8;
    long long v17 = v8;
    long long v14 = v8;
    long long v15 = v8;
    long long v12 = v8;
    long long v13 = v8;
    long long v10 = v8;
    long long v11 = v8;
    uint64_t v6 = sub_10001C180(v4, &v10);
    if (!v6)
    {
      *a3 = *(void *)(a1 + 16);
      *a2 = v11;
    }
  }
  else
  {
    uint64_t v6 = 0;
    *a2 = v4;
  }
  return v6;
}

uint64_t sub_10001C2C0@<X0>(uint64_t result@<X0>, int a2@<W1>, unsigned int a3@<W2>, unsigned int a4@<W3>, unsigned int a5@<W4>, uint64_t a6@<X8>)
{
  *(_OWORD *)(a6 + 32) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  __int16 v6 = dword_100078D70;
  if (a2)
  {
    uint64_t v7 = unk_100078D68;
    uint64_t v8 = *((void *)&xmmword_100078D58 + 1) + a5;
    *(void *)a6 = qword_100078D08 + a4;
    *(void *)(a6 + 8) = v8;
    uint64_t v9 = qword_100078D18;
    *(void *)(a6 + 16) = v7 + a3;
    *(void *)(a6 + 24) = v9;
    uint64_t v10 = qword_100078D28;
    uint64_t v11 = qword_100078D38;
    *(void *)(a6 + 32) = qword_100078D28;
    *(void *)(a6 + 40) = v11;
    if ((v6 & 0x40) == 0)
    {
      *(void *)(a6 + 48) = qword_100078D48;
      if ((v6 & 0x800) == 0) {
        return result;
      }
      uint64_t v10 = xmmword_100078D58;
      goto LABEL_11;
    }
LABEL_10:
    *(void *)(a6 + 48) = v9;
    if ((v6 & 0x800) == 0) {
      return result;
    }
    goto LABEL_11;
  }
  uint64_t v12 = unk_100078D68;
  uint64_t v13 = *(void *)(result + 144);
  uint64_t v14 = *((void *)&xmmword_100078D58 + 1) + a5 - *(void *)(result + 136);
  *(void *)a6 = qword_100078D08 + a4 - *(void *)(result + 48);
  *(void *)(a6 + 8) = v14;
  uint64_t v15 = v12 + a3 - v13;
  uint64_t v16 = qword_100078D18;
  uint64_t v17 = qword_100078D18 - *(void *)(result + 64);
  *(void *)(a6 + 16) = v15;
  *(void *)(a6 + 24) = v17;
  uint64_t v10 = qword_100078D28 - *(void *)(result + 80);
  uint64_t v18 = qword_100078D38 - *(void *)(result + 96);
  *(void *)(a6 + 32) = v10;
  *(void *)(a6 + 40) = v18;
  if ((v6 & 0x40) == 0)
  {
    *(void *)(a6 + 48) = qword_100078D48 - *(void *)(result + 112);
    if ((v6 & 0x800) == 0) {
      return result;
    }
    uint64_t v10 = xmmword_100078D58 - *(void *)(result + 128);
    goto LABEL_11;
  }
  if ((*(unsigned char *)(result + 152) & 0x40) == 0)
  {
    uint64_t v9 = v16 - *(void *)(result + 112);
    goto LABEL_10;
  }
  *(void *)(a6 + 48) = v17;
  if ((v6 & 0x800) == 0) {
    return result;
  }
LABEL_11:
  *(void *)(a6 + 56) = v10;
  return result;
}

char *sub_10001C3E8(uint64_t a1, char *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000194FC(a2 + 48, *a3, a1, (uint64_t)"descendants", a5, a6, a7, a8);
  sub_1000194FC(a2 + 136, a3[1], a1, (uint64_t)"SAF descendants", v11, v12, v13, v14);
  sub_1000194FC(a2 + 144, a3[2], a1, (uint64_t)"dir-stats descendants", v15, v16, v17, v18);
  sub_1000194FC(a2 + 64, a3[3], a1, (uint64_t)"physical size", v19, v20, v21, v22);
  sub_1000194FC(a2 + 80, a3[4], a1, (uint64_t)"resource fork size", v23, v24, v25, v26);
  sub_1000194FC(a2 + 96, a3[5], a1, (uint64_t)"clone size", v27, v28, v29, v30);
  sub_1000194FC(a2 + 112, a3[6], a1, (uint64_t)"purgeable size", v31, v32, v33, v34);
  uint64_t v39 = a3[7];

  return sub_1000194FC(a2 + 128, v39, a1, (uint64_t)"purgeable rsrc size", v35, v36, v37, v38);
}

uint64_t sub_10001C4E4(uint64_t result, void *a2)
{
  uint64_t v16 = result;
  if (!result) {
    return result;
  }
  uint64_t v3 = result;
  memset(__s1, 0, sizeof(__s1));
  if (!memcmp(__s1, a2, 0xA0uLL))
  {
    uint64_t v18 = v3;
    if (qword_100078DB0)
    {
      *(void *)&__s1[0] = a2[18];
      *((void *)&__s1[0] + 1) = v3;
      unsigned int v7 = sub_10003A048((uint64_t)&unk_100078D78, 0, (uint64_t)__s1, 16);
    }
    else
    {
      unsigned int v7 = 0;
    }
    LODWORD(result) = sub_10003A048((uint64_t)dword_100078C88, 0, (uint64_t)&v18, 8);
    if (result) {
      return result;
    }
    else {
      return v7;
    }
  }
  __int16 v4 = *((_WORD *)a2 + 78);
  if ((v4 & 1) == 0) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  int v5 = *((_DWORD *)a2 + 38);
  if ((v5 & 0x20) != 0) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  if ((v5 & 0x10) != 0)
  {
    if ((v5 & 0x80) != 0 || a2[4] || a2[3]) {
      return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
    }
  }
  else
  {
    uint64_t v6 = a2[3];
    if ((v5 & 0x80) != 0)
    {
      if (!v6 || a2[4] != v6) {
        return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
      }
    }
    else if (v6 || !a2[4])
    {
      return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
    }
  }
  int v8 = (v4 & 2) >> 1;
  if ((v5 & 0x10) == 0) {
    int v8 = (v4 & 2) == 0;
  }
  if (v8 != 1 || *a2 || (v4 & 4) == 0 && (a2[19] & 0x12) == 2) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  if (v4 & 4 | a2[19] & 2)
  {
    uint64_t v10 = a2 + 6;
    uint64_t v9 = a2[17];
  }
  else
  {
    if (a2[18]) {
      goto LABEL_33;
    }
    uint64_t v9 = 0;
    uint64_t v10 = a2 + 17;
  }
  if (*v10 != v9) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
LABEL_33:
  if (a2[6] != a2[5] || a2[8] != a2[7]) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  if (v5)
  {
    uint64_t v12 = a2 + 10;
    uint64_t v11 = a2[9];
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = a2 + 9;
  }
  if (*v12 != v11) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  if ((v4 & 8) != 0 && (v5 & 4) != 0)
  {
    if (a2[12] != a2[11]) {
      return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
    }
  }
  else if (v4 & 8 | a2[19] & 4)
  {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  if ((a2[19] & 0x50) == 0x40 && ((v4 & 0x10) == 0 || (v5 & 8) == 0)) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
  int v15 = *((_DWORD *)a2 + 38);
  if ((v4 & 0x20) != 0 && (v5 & 8) != 0)
  {
    if (a2[14] != a2[13]) {
      return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
    }
    goto LABEL_52;
  }
  if (v4 & 0x20 | a2[19] & 8) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }
LABEL_52:
  __int16 v13 = *((_WORD *)a2 + 78);
  BOOL v14 = sub_10001BDE8((uint64_t)a2);
  if ((v13 & 0x100) != 0 || (v15 & 0x400) != 0 || !v14 || a2[2] != a2[1]) {
    return sub_100039A6C(dword_100078C88, 0, &v16, 8, a2, 160);
  }

  return sub_10001C9F0(v3, (uint64_t)a2);
}

uint64_t sub_10001C790(uint64_t a1, uint64_t *__s2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v36 = v10;
  long long v37 = v10;
  long long v34 = v10;
  long long v35 = v10;
  long long v32 = v10;
  long long v33 = v10;
  long long v30 = v10;
  long long v31 = v10;
  int v11 = 513;
  long long v28 = v10;
  long long v29 = v10;
  while (1)
  {
    if (!a1) {
      return 0;
    }
    uint64_t v12 = a1;
    if (!--v11) {
      break;
    }
    long long v40 = 0u;
    long long v41 = 0u;
    long long __s1 = 0u;
    long long v39 = 0u;
    uint64_t result = memcmp(&__s1, __s2, 0x40uLL);
    if (!result) {
      return result;
    }
    uint64_t result = sub_10001C180(a1, &v28);
    if (result) {
      return result;
    }
    sub_10001C3E8(a1, (char *)&v28, __s2, v14, v15, v16, v17, v18);
    uint64_t result = sub_10001C4E4(a1, &v28);
    if (result) {
      return result;
    }
    a1 = v29;
    if ((void)v29 && (BYTE8(v37) & 0x10) != 0)
    {
      *(void *)&long long v20 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v20 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v46 = v20;
      long long v47 = v20;
      long long v44 = v20;
      long long v45 = v20;
      long long v42 = v20;
      long long v43 = v20;
      long long v40 = v20;
      long long v41 = v20;
      long long __s1 = v20;
      long long v39 = v20;
      uint64_t result = sub_10001C180(v29, &__s1);
      if (result) {
        return result;
      }
      uint64_t v19 = v29;
      a1 = v39;
    }
    else
    {
      uint64_t v19 = 0;
    }
    uint64_t result = sub_10001C948(v19, __s2[2]);
    if (result) {
      return result;
    }
    uint64_t v21 = v28;
    if ((void)v28)
    {
      uint64_t result = sub_10001C180(v28, &v28);
      if (result) {
        return result;
      }
      sub_10001C3E8(v21, (char *)&v28, __s2, v22, v23, v24, v25, v26);
      uint64_t result = sub_10001C4E4(v21, &v28);
      if (result) {
        return result;
      }
    }
    __int16 v27 = WORD4(v37);
    if ((BYTE8(v37) & 0x40) != 0)
    {
      __s2[6] = __s2[3];
      if ((v27 & 0x800) != 0) {
        __s2[7] = __s2[4];
      }
    }
    if (v12 == a1)
    {
      sub_100044674("detected chained-key loop involving dir-stats %llu\n", (uint64_t)__s2, a3, a4, a5, a6, a7, a8, v12);
      sub_100048B34((char *)0x59D, 92);
      return 0;
    }
  }
  sub_100044674("performed too many chained-key iterations (current id %llu); aborting dir-stats repairs\n",
    (uint64_t)__s2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a1);
  sub_100048B34((char *)0x590, 92);
  uint64_t result = 0;
  byte_100078CC8 = 1;
  return result;
}

uint64_t sub_10001C948(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
      v14[8] = v5;
      long long v15 = v5;
      v14[6] = v5;
      v14[7] = v5;
      v14[4] = v5;
      v14[5] = v5;
      v14[2] = v5;
      v14[3] = v5;
      v14[0] = v5;
      v14[1] = v5;
      uint64_t result = sub_10001C180(a1, v14);
      if (!result)
      {
        BOOL v13 = __OFADD__((void)v15, a2);
        *(void *)&long long v15 = v15 + a2;
        if (v13)
        {
          sub_100044674("dir-stats object (id %llu): %s overflow\n", v6, v7, v8, v9, v10, v11, v12, a1);
          *(void *)&long long v15 = 0x7FFFFFFFFFFFFFFFLL;
          sub_100048B34((char *)0x56D, 84);
        }
        return sub_10001C4E4(a1, v14);
      }
    }
  }
  return result;
}

uint64_t sub_10001C9F0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = a1;
  if (qword_100078DB0)
  {
    v4[0] = *(void *)(a2 + 144);
    v4[1] = a1;
    unsigned int v2 = sub_10003A048((uint64_t)&unk_100078D78, 0, (uint64_t)v4, 16);
  }
  else
  {
    unsigned int v2 = 0;
  }
  LODWORD(result) = sub_10003A048((uint64_t)dword_100078C88, 0, (uint64_t)&v5, 8);
  if (result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_10001CA70(_DWORD *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, a2, a3, 0, a4, a5, a6, a7);
  }
  sub_100027AD0(0, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  return 0;
}

uint64_t sub_10001CAC4(char *__s, uint64_t a2, long long *a3, io_connect_t *a4, uint64_t a5)
{
  size_t outputStructCnt = 100;
  uint64_t result = 22;
  if (__s && a4)
  {
    uint64_t v11 = sub_10002E110(__s, 0, a4, 0, 0);
    if (v11)
    {
      return sub_10004E710(v11);
    }
    else
    {
      memset((char *)v20 + 8, 170, 0x950uLL);
      long long v12 = a3[1];
      long long outputStruct = *a3;
      long long v19 = v12;
      *(void *)&v20[0] = a2;
      uint64_t v13 = IOConnectCallStructMethod(*a4, 0x32u, &outputStruct, 0x28uLL, &outputStruct, &outputStructCnt);
      if (v13) {
        IOServiceClose(*a4);
      }
      if (a5)
      {
        long long v14 = v20[3];
        *(_OWORD *)(a5 + 64) = v20[2];
        *(_OWORD *)(a5 + 80) = v14;
        *(_DWORD *)(a5 + 96) = v20[4];
        long long v15 = v19;
        *(_OWORD *)a5 = outputStruct;
        *(_OWORD *)(a5 + 16) = v15;
        long long v16 = v20[1];
        *(_OWORD *)(a5 + 32) = v20[0];
        *(_OWORD *)(a5 + 48) = v16;
      }
      if (v13) {
        return sub_10004E710(v13);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10001CBE8(io_connect_t *a1)
{
  size_t outputStructCnt = 0;
  if (!a1) {
    return 22;
  }
  mach_port_t v2 = *a1;
  if (!v2) {
    return 22;
  }
  uint64_t v3 = IOConnectCallStructMethod(v2, 0x33u, 0, 0, 0, &outputStructCnt);
  if (v3) {
    return sub_10004E710(v3);
  }
  IOServiceClose(*a1);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t sub_10001CC5C(char *a1, unsigned __int8 *uu, _OWORD *a3, char a4, uint64_t a5)
{
  size_t outputStructCnt = 0;
  if (!a1) {
    return 22;
  }
  int is_null = uuid_is_null(uu);
  uint64_t result = 22;
  if (a5 && !is_null)
  {
    io_connect_t v16 = -1431655766;
    memset(__b, 170, sizeof(__b));
    uint64_t v12 = sub_10002E110(a1, 0, &v16, 0, 0);
    if (v12) {
      return sub_10004E710(v12);
    }
    uuid_copy(__b, uu);
    long long v13 = a3[1];
    *(_OWORD *)&__b[16] = *a3;
    *(_OWORD *)&__b[32] = v13;
    *(void *)&__b[56] = a5;
    __b[48] = a4;
    uint64_t v12 = IOConnectCallStructMethod(v16, 0x3Bu, __b, 0x40uLL, 0, &outputStructCnt);
    IOServiceClose(v16);
    if (v12) {
      return sub_10004E710(v12);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001CD60(char *a1, io_connect_t *a2)
{
  uint64_t result = 22;
  if (a1 && a2)
  {
    if (*a2)
    {
      return 37;
    }
    else
    {
      if (*a1 == 114) {
        __int16 v4 = a1 + 1;
      }
      else {
        __int16 v4 = a1;
      }
      int v6 = 0;
      uint64_t v5 = sub_10002E110(v4, &v6, a2, 0, 0);
      return sub_10004E710(v5);
    }
  }
  return result;
}

uint64_t sub_10001CDCC(char *a1, mach_port_t a2, unsigned int a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v18 = 8;
  unsigned int v16 = sub_10002DE14(a1, 0);
  uint64_t result = 22;
  if (a3 - 6 >= 0xFFFFFFFB && a2 && v16 <= 0x63)
  {
    memset(&outputStruct[4], 170, 0x958uLL);
    outputStruct[0] = __PAIR64__(v16, a3);
    outputStruct[1] = a4;
    outputStruct[2] = a5;
    outputStruct[3] = *a6;
    LOBYTE(outputStruct[4]) = *(void *)(a7 + 64);
    outputStruct[5] = a8;
    LOBYTE(outputStruct[6]) = a9;
    uint64_t result = IOConnectCallStructMethod(a2, 0x40u, outputStruct, 0x38uLL, outputStruct, &v18);
    if (a3 <= 4 && ((1 << a3) & 0x1A) != 0) {
      *a6 = outputStruct[0];
    }
    if (result) {
      return sub_10004E710(result);
    }
  }
  return result;
}

uint64_t sub_10001CEDC(uint64_t connect)
{
  if (connect) {
    return IOServiceClose(connect);
  }
  return connect;
}

unint64_t sub_10001CEE8(unsigned int a1, unint64_t a2, unint64_t a3)
{
  size_t v8 = 8;
  unint64_t v9 = 0xAAAAAAAAAAAAAAAALL;
  if (sysctlbyname("hw.memsize", &v9, &v8, 0, 0) == -1) {
    unint64_t v6 = 0x4000000;
  }
  else {
    unint64_t v6 = v9 / a1;
  }
  if (v6 >= a2) {
    unint64_t v6 = a2;
  }
  if (v6 <= a3) {
    return a3;
  }
  else {
    return v6;
  }
}

uint64_t sub_10001CF74(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (dword_100078DB8)
  {
    unint64_t v6 = (void *)qword_100078DC0;
    uint64_t v7 = dword_100078DB8;
    do
    {
      if (*v6 == a1) {
        return 0;
      }
      v6 += 3;
      --v7;
    }
    while (v7);
    size_t v8 = (char *)qword_100078DC0;
    if ((dword_100078DB8 & (dword_100078DB8 - 1)) != 0) {
      goto LABEL_9;
    }
    size_t v8 = (char *)malloc_type_realloc((void *)qword_100078DC0, 24 * (2 * dword_100078DB8), 0xF0040613C4080uLL);
    if (v8)
    {
      qword_100078DC0 = (uint64_t)v8;
      goto LABEL_9;
    }
    return 12;
  }
  size_t v8 = (char *)malloc_type_malloc(0x18uLL, 0xF0040613C4080uLL);
  qword_100078DC0 = (uint64_t)v8;
  if (!v8) {
    return 12;
  }
LABEL_9:
  uint64_t v9 = 0;
  int v10 = dword_100078DB8;
  uint64_t v11 = &v8[24 * dword_100078DB8];
  *((void *)v11 + 1) = a2;
  *((void *)v11 + 2) = a3;
  *(void *)uint64_t v11 = a1;
  dword_100078DB8 = v10 + 1;
  return v9;
}

uint64_t sub_10001D070(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!qword_100078DD0 || qword_100078DD8 < (unint64_t)qword_100078DD0) {
    return 0;
  }
  if (qword_100078DD8 >= (unint64_t)qword_100078DC8)
  {
    qword_100078DC8 = qword_100078DD8 + 52428800;
    sub_100044548("Allocated (%llu) MB for cached btrees in %u blocks, limit is (%llu) MB\n", a2, a3, a4, a5, a6, a7, a8, (unint64_t)qword_100078DD8 >> 20);
    if (dword_100078DB8)
    {
      sub_100044548("Node counts:", v9, v10, v11, v12, v13, v14, v15, v39);
      if (dword_100078DB8)
      {
        uint64_t v16 = 0;
        unint64_t v17 = 0;
        do
        {
          uint64_t v18 = *(void *)(qword_100078DC0 + v16 + 8);
          unint64_t v40 = 0;
          sub_10003A0F8(*(void *)(qword_100078DC0 + v16), 0, &v40);
          sub_100044548(" %s tree (%llu)%s", v19, v20, v21, v22, v23, v24, v25, v18);
          ++v17;
          v16 += 24;
        }
        while (v17 < dword_100078DB8);
      }
    }
  }
  uint64_t result = 1;
  if (qword_100078DC0 && dword_100078DB8)
  {
    uint64_t v26 = 0;
    unint64_t v27 = 0;
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    do
    {
      uint64_t v30 = qword_100078DC0 + v26;
      unint64_t v40 = 0;
      sub_10003A0F8(*(void *)(qword_100078DC0 + v26), 0, &v40);
      if (v40 > v29)
      {
        unint64_t v29 = v40;
        uint64_t v28 = v30;
      }
      ++v27;
      v26 += 24;
    }
    while (v27 < dword_100078DB8);
    if (v28)
    {
      uint64_t v38 = sub_100044548("Disabling fsck cross checks of %s tree\n", v31, v32, v33, v34, v35, v36, v37, *(void *)(v28 + 8));
      (*(void (**)(char *))(v28 + 16))(v38);
      qword_100078DC8 = 0;
    }
    return 1;
  }
  return result;
}

uint64_t sub_10001D240(size_t size, void *a2, void *a3)
{
  unsigned int v5 = size;
  if (!qword_100078DD0) {
    qword_100078DD0 = sub_10001CEE8(0x10u, 0x80000000uLL, 0);
  }
  if (dword_100078DE0)
  {
    if ((dword_100078DE0 & (dword_100078DE0 - 1)) != 0) {
      goto LABEL_8;
    }
    unint64_t v6 = malloc_type_realloc((void *)qword_100078DE8, 8 * (2 * dword_100078DE0), 0x10040436913F5uLL);
    if (v6)
    {
      qword_100078DE8 = (uint64_t)v6;
      goto LABEL_8;
    }
    return 12;
  }
  qword_100078DE8 = (uint64_t)malloc_type_malloc(8uLL, 0x10040436913F5uLL);
  if (!qword_100078DE8) {
    return 12;
  }
LABEL_8:
  *a2 = ++dword_100078DE0;
  uint64_t v7 = malloc_type_calloc(1uLL, v5, 0x62E0A448uLL);
  *(void *)(qword_100078DE8 + 8 * *a2 - 8) = v7;
  qword_100078DD8 += v5;
  if (!v7) {
    return 12;
  }
  if (!a3) {
    return 0;
  }
  size_t v8 = v7;
  uint64_t result = 0;
  *a3 = v8;
  return result;
}

uint64_t sub_10001D368(unsigned int a1, uint64_t a2)
{
  uint64_t result = 14;
  if (a2)
  {
    if (dword_100078DE0 >= a2)
    {
      uint64_t v4 = qword_100078DE8 + 8 * a2;
      free(*(void **)(v4 - 8));
      uint64_t result = 0;
      qword_100078DD8 -= a1;
      *(void *)(v4 - 8) = 0;
    }
  }
  return result;
}

uint64_t sub_10001D3CC(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = 14;
  if (a2 && dword_100078DE0 >= a2)
  {
    uint64_t v4 = *(void *)(qword_100078DE8 + 8 * a2 - 8);
    if (v4)
    {
      uint64_t result = 0;
      *a3 = v4;
    }
  }
  return result;
}

uint64_t sub_10001D404(size_t __n, uint64_t a2, void *__src)
{
  uint64_t v3 = 14;
  if (a2 && dword_100078DE0 >= a2)
  {
    uint64_t v4 = *(void **)(qword_100078DE8 + 8 * a2 - 8);
    if (v4)
    {
      if (v4 != __src) {
        memcpy(*(void **)(qword_100078DE8 + 8 * a2 - 8), __src, __n);
      }
      return 0;
    }
    else
    {
      return 14;
    }
  }
  return v3;
}

uint64_t sub_10001D474(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t sub_10001D4A8(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  if (a4 != 8)
  {
    sub_10004458C("fusion middle tree: invalid key length %u (expected %lu)\n", a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, a8, a4);
    uint64_t v22 = 92;
    uint64_t v23 = 875;
    goto LABEL_28;
  }
  if (a6 != 16)
  {
    sub_10004458C("fusion middle tree: invalid value length %u (expected %lu)\n", a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, a8, a6);
    uint64_t v22 = 92;
    uint64_t v23 = 876;
    goto LABEL_28;
  }
  unint64_t v10 = *a3;
  unint64_t v11 = *(void *)a5;
  unint64_t v12 = *(unsigned int *)(a5 + 8);
  uint64_t v13 = *(void *)(a1 + 8);
  int64_t v14 = *(void *)(v13 + 1368);
  unint64_t v15 = *(void *)(v13 + 1376);
  unint64_t v16 = *(void *)a5 - v14;
  BOOL v18 = v16 < v15 && v15 >= v12 && v16 <= v15 - v12;
  BOOL v19 = (uint64_t)v11 >= v14 && v18;
  uint64_t v20 = *(void *)(a1 + 24);
  if (v20)
  {
    uint64_t v21 = (unint64_t *)(v20 + 96);
  }
  else
  {
    if ((*(unsigned char *)(v13 + 65) & 1) == 0)
    {
      unint64_t v24 = 0;
      goto LABEL_20;
    }
    uint64_t v21 = (unint64_t *)(v13 + 40);
  }
  unint64_t v24 = *v21;
LABEL_20:
  unint64_t v25 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v13 + 36)));
  BOOL v27 = v25 < v10 && v24 > v12 && (v24 | v25) > v10;
  if (v27 && ((v24 - v12) | v25) >= v10)
  {
    if (v11)
    {
      unint64_t v29 = (unint64_t *)(v13 + 40);
      if (v20) {
        unint64_t v29 = (unint64_t *)(v20 + 48);
      }
      unint64_t v30 = *v29;
      BOOL v31 = v30 > v12 && v30 > v11;
      if (v31 && v30 - v12 >= v11)
      {
        int v33 = *(_DWORD *)(a5 + 12);
        if ((v33 & 3) == 3)
        {
          sub_10004458C("fusion middle tree: bogus combination of flags. Dirty (0x%x) and Tenant (0x%x) flags are mutually exclusive (0x%llx -> 0x%llx:%llu Flags:0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, a8, 1);
          sub_100048B34((char *)0x24E, 92);
        }
        char v34 = !v19;
        if ((v33 & 3) == 1) {
          char v34 = 1;
        }
        if ((v34 & 1) == 0)
        {
          sub_10004458C("fusion middle tree: WBC mapping must have only the Dirty (0x%x) flag set (0x%llx -> 0x%llx:%llu Flags:0x%x)\n", a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, a8, 1);
          sub_100048B34((char *)0x24F, 92);
        }
        if (!v19)
        {
          if (v33) {
            *a7 += v12;
          }
          if ((v33 & 3) != 0)
          {
            sub_10000A1C0(a7[2], v11, v12);
            uint64_t v22 = 0;
            a7[1] += v12;
            return v22;
          }
          a7[1] += v12;
          sub_100040DD0(a1, v11, v12, 0, 0x40000000, v11, 0, 0, 0x15u, 2u);
        }
        return 0;
      }
    }
    sub_10004458C("fusion middle tree: invalid \"to\" range 0x%llx:%llu\n", a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, a8, *(void *)a5);
    uint64_t v22 = 92;
    uint64_t v23 = 169;
  }
  else
  {
    sub_10004458C("fusion middle tree: invalid \"from\" range 0x%llx:%llu\n", a2, (uint64_t)a3, a4, a5, a6, (uint64_t)a7, a8, *a3);
    uint64_t v22 = 92;
    uint64_t v23 = 168;
  }
LABEL_28:
  sub_100048B34((char *)v23, 92);
  return v22;
}

uint64_t sub_10001D734(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a3;
  uint64_t result = sub_100040D7C(*a3, *(unsigned int *)(a5 + 8), 0);
  if (result == 17)
  {
    sub_100044674("MT mapping (0x%llx -> 0x%llx, %llu, %c%s) is not completely referenced\n", v7, v8, v9, v10, v11, v12, v13, v5);
    return 0;
  }
  return result;
}

uint64_t sub_10001D7C4(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a2 + 24);
  uint64_t v65 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  uint64_t v64 = 0;
  unint64_t v9 = *(void *)(v8 + 56);
  if (v9 > *(void *)(v8 + 64))
  {
    sub_10004458C("fusion wbc: stable head offset (%llu) is greater than tail (%llu)\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 56));
    uint64_t v10 = 92;
    uint64_t v11 = 171;
    goto LABEL_13;
  }
  uint64_t v13 = *(void *)(v8 + 40);
  uint64_t v12 = *(void *)(v8 + 48);
  if ((v12 != 0) == (v13 == 0))
  {
    sub_10004458C("fusion wbc: WBC list OIDs are not consistent: Head: 0x%llx, Tail: 0x%llx\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 40));
    uint64_t v10 = 92;
    uint64_t v11 = 172;
    goto LABEL_13;
  }
  int64_t v14 = (unint64_t *)a2;
  uint64_t v16 = a1[1];
  int64_t v17 = *(void *)(v16 + 1368);
  unint64_t v18 = *(void *)(v16 + 1376);
  if (v13)
  {
    unint64_t v19 = v13 - v17;
    if (v13 < v17 || (v19 < v18 ? (BOOL v20 = v19 > v18 - 1) : (BOOL v20 = 1), v20))
    {
      sub_10004458C("fusion wbc: WBC list head OID 0x%llx is not in the WBC range\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 40));
      uint64_t v10 = 92;
      uint64_t v11 = 173;
      goto LABEL_13;
    }
  }
  if (v12)
  {
    unint64_t v22 = v12 - v17;
    if (v12 < v17 || ((unint64_t v23 = v18 - 1, v22 < v18) ? (v24 = v22 > v23) : (v24 = 1), v24))
    {
      sub_10004458C("fusion wbc: WBC list tail OID 0x%llx is not in the WBC range\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 48));
      uint64_t v10 = 92;
      uint64_t v11 = 174;
      goto LABEL_13;
    }
    uint64_t v32 = 0;
    unint64_t v33 = 0;
    int v34 = 0;
    uint64_t v60 = v18 + v17;
    while (1)
    {
      unint64_t v35 = v13 - v17;
      if (v13 < v17 || v35 >= v18 || v35 > v23) {
        break;
      }
      int v59 = v34;
      if (v32)
      {
        free(v32);
        uint64_t v65 = 0;
      }
      uint64_t v36 = sub_1000257B4(a1, 0, 0x40000000, v13, 0, 0, 23, 0, &v65, (uint64_t)&v62, 0);
      if (v36)
      {
        uint64_t v10 = v36;
        goto LABEL_14;
      }
      unint64_t v37 = ((unint64_t)v63 - 64) / 0x18;
      uint64_t v32 = v65;
      if (*((_DWORD *)v65 + 14) != v37)
      {
        sub_10004458C("fusion wbc: WBC list chunk (oid 0x%llx) has max entries %u != %u\n", a2, a3, a4, a5, a6, a7, a8, v13);
        uint64_t v10 = 92;
        uint64_t v11 = 176;
        goto LABEL_13;
      }
      unint64_t v38 = *((unsigned int *)v65 + 12);
      if (v38 >= v37 || (uint64_t v39 = *(void *)(v8 + 40), v38) && v13 != v39)
      {
        sub_10004458C("fusion wbc: WBC list chunk (oid 0x%llx) has invalid first index %u\n", a2, a3, a4, a5, a6, a7, a8, v13);
        uint64_t v10 = 92;
        uint64_t v11 = 177;
        goto LABEL_13;
      }
      unsigned int v40 = *((_DWORD *)v65 + 13);
      if (v40 > v37 || v13 != v39 && !v40)
      {
        sub_10004458C("fusion wbc: WBC list chunk (oid 0x%llx) has invalid last index %u\n", a2, a3, a4, a5, a6, a7, a8, v13);
        uint64_t v10 = 92;
        uint64_t v11 = 178;
        goto LABEL_13;
      }
      if (v38 > v40)
      {
        sub_10004458C("fusion wbc: bogus index combination in WBC list chunk (oid 0x%llx): %u starts after %u\n", a2, a3, a4, a5, a6, a7, a8, v13);
        uint64_t v10 = 92;
        uint64_t v11 = 712;
        goto LABEL_13;
      }
      unint64_t v61 = v33;
      if (v38 < v40)
      {
        uint64_t v41 = 3 * v38;
        do
        {
          uint64_t v42 = a1[1];
          uint64_t v43 = a1[3];
          if (v43)
          {
            long long v44 = (unint64_t *)(v43 + 96);
          }
          else
          {
            if ((*(unsigned char *)(v42 + 65) & 1) == 0)
            {
              unint64_t v45 = 0;
              goto LABEL_67;
            }
            long long v44 = (unint64_t *)(v42 + 40);
          }
          unint64_t v45 = *v44;
LABEL_67:
          long long v46 = &v32[v41];
          unint64_t v47 = v32[v41 + 9];
          a3 = v32[v41 + 10];
          unint64_t v48 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v42 + 36)));
          if (v48 >= v47) {
            goto LABEL_99;
          }
          unint64_t v49 = v45 | v48;
          BOOL v20 = v45 > a3;
          unint64_t v50 = v45 - a3;
          BOOL v51 = v20 && v49 > v47;
          if (!v51 || (v50 | v48) < v47)
          {
            if (a3 + v47 <= v48)
            {
LABEL_99:
              sub_10004458C("fusion wbc: WBC list entry has invalid target range (0x%llx->0x%llx+%llu), Tier2: 0x%llx+%llu\n", a2, a3, a4, a5, a6, a7, a8, v47);
              uint64_t v10 = 92;
              uint64_t v11 = 180;
              goto LABEL_13;
            }
            sub_100044674("fusion wbc: WBC list entry has target range 0x%llx+%llu which is outside of Tier2 size\n", a2, a3, a4, a5, a6, a7, a8, v32[v41 + 9]);
            a3 = v46[10];
          }
          a2 = v46[8];
          int64_t v52 = a3 + a2;
          BOOL v54 = a2 < v17 || v52 > v60;
          BOOL v56 = v60 <= a2 || v52 <= v17;
          if (v54 && !v56)
          {
            sub_10004458C("fusion wbc: WBC list entry 0x%llx+%llu is intersecting the WBC range 0x%llx+%llu\n", a2, a3, a4, a5, a6, a7, a8, a2);
            uint64_t v10 = 92;
            uint64_t v11 = 179;
            goto LABEL_13;
          }
          if (v54 && v56)
          {
            v61 += a3;
            sub_10000A2A8(v14[2], a2, a3);
            sub_100040DD0((uint64_t)a1, v46[8], v46[10], 0, 0x40000000, v46[8], 0, 0, 0x17u, 2u);
          }
          ++v38;
          uint64_t v32 = v65;
          v41 += 3;
        }
        while (v38 < *((unsigned int *)v65 + 13));
      }
      unint64_t v57 = v32[5];
      if (v57 <= v9 || v57 < *(void *)(v8 + 56) || v57 > *(void *)(v8 + 64))
      {
        sub_10004458C("fusion wbc: WBC list chunk (oid 0x%llx) has incorrect tailOffset %llu, should be >%llu, >=%llu, and <=%llu\n", a2, a3, a4, a5, a6, a7, a8, v13);
        uint64_t v10 = 92;
        uint64_t v11 = 181;
        goto LABEL_13;
      }
      int v34 = v59 + 1;
      unint64_t v9 = v32[5];
      BOOL v58 = v13 == *(void *)(v8 + 48);
      uint64_t v13 = v57 % v18 + v17;
      unint64_t v33 = v61;
      unint64_t v23 = v18 - 1;
      if (v58) {
        goto LABEL_26;
      }
    }
    sub_10004458C("fusion wbc: WBC list object OID 0x%llx is not in the WBC range\n", a2, a3, a4, a5, a6, a7, a8, v13);
    uint64_t v10 = 92;
    uint64_t v11 = 175;
LABEL_13:
    sub_100048B34((char *)v11, 92);
    goto LABEL_14;
  }
  int v34 = 0;
  unint64_t v33 = 0;
LABEL_26:
  if (v34 != *(_DWORD *)(v8 + 72))
  {
    sub_100044674("fusion wbc: expected %u list chunks but found %u\n", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 72));
    sub_100048B34((char *)0xB6, -8);
  }
  if (v33 != *(void *)(v8 + 88))
  {
    sub_100044674("fusion wbc: expected %llu W2RC dirty blocks but found %llu\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 88));
    sub_100048B34((char *)0x250, -8);
    unint64_t v33 = *(void *)(v8 + 88);
  }
  if (*v14 > v33)
  {
    sub_100044674("fusion mt: W2RC dirty blocks count (%llu) is smaller than number of dirty blocks found in MT (%llu)\n", a2, a3, a4, a5, a6, a7, a8, v33);
    sub_100048B34((char *)0x331, -8);
  }
  if (v14[1] > *(void *)(v8 + 80))
  {
    sub_100044674("fusion mt: total RC blocks count (%llu) is smaller than number of blocks found in MT (%llu)\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 80));
    sub_100048B34((char *)0x332, -8);
  }
  unint64_t v25 = *(void *)(v8 + 104);
  if (v25)
  {
    unint64_t v26 = *(void *)(v8 + 96);
    if (!v26) {
      goto LABEL_44;
    }
    uint64_t v27 = a1[3];
    uint64_t v28 = (unint64_t *)(a1[1] + 40);
    if (v27) {
      uint64_t v28 = (unint64_t *)(v27 + 48);
    }
    unint64_t v29 = *v28;
    BOOL v30 = *v28 >= v25;
    unint64_t v31 = *v28 - v25;
    if (v31 == 0 || !v30 || v29 <= v26 || v31 < v26)
    {
LABEL_44:
      sub_10004458C("RCStash: The stashed range is invalid: 0x%llx+%llu\n", v26, v25, a4, a5, a6, a7, a8, *(void *)(v8 + 96));
      uint64_t v10 = 92;
      uint64_t v11 = 742;
      goto LABEL_13;
    }
    sub_100040DD0((uint64_t)a1, v26, v25, 0, 0x40000000, v26, 0, 0, 0x16u, 2u);
  }
  uint64_t v10 = 0;
LABEL_14:
  if (v65) {
    free(v65);
  }
  return v10;
}

uint64_t sub_10001DDD8(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t a4, int64_t *a5, uint64_t a6, int8x16_t *a7, _DWORD *a8)
{
  uint64_t v11 = *a3;
  int64_t v12 = *a5;
  unint64_t v13 = *((unsigned int *)a5 + 2);
  uint64_t v14 = a1[1];
  uint64_t v15 = *(void *)(v14 + 1368);
  BOOL v16 = __OFSUB__(*a5, v15);
  uint64_t v17 = *a5 - v15;
  if (v17 < 0 != v16
    || ((unint64_t v18 = *(void *)(v14 + 1376), v17 < v18) ? (v19 = v18 >= v13) : (v19 = 0),
        v19 ? (BOOL v20 = v17 > v18 - v13) : (BOOL v20 = 1),
        v20))
  {
    int v21 = *((_DWORD *)a5 + 3) & 3;
    if ((*((_DWORD *)a5 + 3) & 3) != 0 && v21 != 3)
    {
      int64_t v23 = v12 + v13;
      if (v12 < (uint64_t)(v12 + v13))
      {
        int v76 = *((_DWORD *)a5 + 3);
        BOOL v24 = "Unknown";
        if (v21 == 2) {
          BOOL v24 = "Tenant";
        }
        if (v21 == 1) {
          unint64_t v25 = "Dirty";
        }
        else {
          LOBYTE(v25) = (_BYTE)v24;
        }
        char v77 = (char)v25;
        uint64_t v74 = a7 + 2;
        uint64_t v26 = *a5;
        do
        {
          unint64_t v80 = 0xAAAAAAAAAAAAAAAALL;
          if (!sub_10000A370(1, a7[1].i64[0], v26, v23 - v26, &v80)) {
            return 0;
          }
          unint64_t v32 = v80;
          uint64_t v33 = v80 + 1;
          unint64_t v34 = v12 + v13;
          uint64_t v35 = v23 - (v80 + 1);
          if (v23 > (uint64_t)(v80 + 1))
          {
            if (sub_10000A370(0, a7[1].i64[0], v33, v35, &v80)) {
              unint64_t v34 = v80;
            }
            else {
              unint64_t v34 = v12 + v13;
            }
          }
          char v36 = v32 - v12 + v11;
          if (v32 == v12 && v34 - v32 == v13)
          {
            if (sub_10004641C(qword_100091B70, "Fix an orphaned %s MT mapping [0x%llx -> 0x%llx, %llu]? ", v33, v35, v28, v29, v30, v31, v77))
            {
              if (v76)
              {
                sub_100044548("...Elevating a Dirty mapping [0x%llx -> 0x%llx, %llu]\n", v37, v38, v39, v40, v41, v42, v43, v32 - v12 + v11);
                uint64_t v44 = sub_100031594(a1, v12, v32 - v12 + v11, v13);
                if (v44)
                {
                  uint64_t v55 = v44;
                  strerror(v44);
                  sub_10004458C("Failed to elevate the content for Dirty mapping [0x%llx -> 0x%llx, %llu]: %s\n", v57, v58, v59, v60, v61, v62, v63, v36);
                  uint64_t v64 = 813;
                  int v65 = 92;
LABEL_39:
                  sub_100048B34((char *)v64, v65);
                  return v55;
                }
                a7->i64[0] -= v13;
                *(void *)(a7[1].i64[1] + 88) -= v13;
                sub_100044548("...Decrementing fwp_dirtyInRC by %llu, new value: %llu\n", v45, v46, v47, v48, v49, v50, v51, v13);
                uint64_t v52 = a7[1].i64[1];
                int8x16_t v78 = *v74;
                uint64_t v79 = v74[1].i64[0];
                uint64_t v54 = sub_100026BA0(a1, 0, v52, (uint64_t)&v78, v78, v53);
                if (v54)
                {
                  uint64_t v55 = v54;
                  uint64_t v66 = v74->i64[0];
                  strerror(v54);
                  sub_10004458C("Unable to write WBC Instance object (LBA 0x%llx): %s\n", v67, v68, v69, v70, v71, v72, v73, v66);
                  uint64_t v64 = 814;
                  int v65 = v55;
                  goto LABEL_39;
                }
              }
              *((_DWORD *)a5 + 3) &= 0xFFFFFFFC;
              *a8 = 1;
              sub_100040DD0((uint64_t)a1, v12, v13, 0, 0x40000000, v12, 0, 0, 0x15u, 2u);
            }
          }
          else
          {
            sub_100044674("Found a partially orphaned %s mapping [0x%llx -> 0x%llx, %llu], where [0x%llx -> 0x%llx, %llu] region is not backed by WBCL.\nThis is currently not supported, skipping\n", v27, v33, v35, v28, v29, v30, v31, v77);
          }
          uint64_t v26 = v34 + 1;
        }
        while ((uint64_t)(v34 + 1) < v23);
      }
    }
  }
  return 0;
}

BOOL sub_10001E0AC(uint64_t a1, int64_t a2, uint64_t a3)
{
  if (!*(void *)(a1 + 448)) {
    return 0;
  }
  uint64_t v5 = a1 + 392;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  int64_t v12 = a2;
  unint64_t v10 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v8 = 16;
  unsigned int v9 = 8;
  if (sub_1000380B0(a1 + 392, 0, 0xFFFFFFFFLL, &v12, &v9, 8u, &v10, &v8)) {
    return 0;
  }
  int64_t v7 = v12;
  if (v12 + v11 > a2) {
    return v7 < a3 + a2;
  }
  if (!sub_1000380B0(v5, 0, 2, &v12, &v9, 8u, &v10, &v8))
  {
    int64_t v7 = v12;
    return v7 < a3 + a2;
  }
  return 0;
}

uint64_t sub_10001E180(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004435C("fsck cache stats:\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  sub_10001E1C8(1);
  sub_10004435C("\n", v8, v9, v10, v11, v12, v13, v14, vars0a);

  return sub_10001E1C8(0);
}

uint64_t sub_10001E1C8(int a1)
{
  if (a1) {
    int v1 = "hit";
  }
  else {
    int v1 = "miss";
  }
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uint64_t v42 = v2;
  long long v43 = v2;
  __sprintf_chk(v42, 0, 0x20uLL, "Cache %s count:", v1);
  sub_10004435C("\t%-32s %u\n", v3, v4, v5, v6, v7, v8, v9, (char)v42);
  __sprintf_chk(v42, 0, 0x20uLL, "Cache %s time:", v1);
  sub_10004435C("\t%-32s %.2lf [usec]\n", v10, v11, v12, v13, v14, v15, v16, (char)v42);
  __sprintf_chk(v42, 0, 0x20uLL, "Cache average %s time:", v1);
  sub_10004435C("\t%-32s %.2lf [usec]\n", v17, v18, v19, v20, v21, v22, v23, (char)v42);
  sub_10004435C("\tCache %s histogram:\n", v24, v25, v26, v27, v28, v29, v30, (char)v1);
  unint64_t v31 = 0;
  unint64_t v32 = 0;
  do
  {
    unint64_t v40 = (unint64_t)__exp10((double)(int)v31);
    if (v31 >= 4)
    {
      if (v31 > 6) {
        v32 /= 0xF4240uLL;
      }
      else {
        v32 /= 0x3E8uLL;
      }
    }
    uint64_t result = sub_10004435C("\t\t[%4llu - %4llu) [%4s] = %d\n", v33, v34, v35, v36, v37, v38, v39, v32);
    ++v31;
    unint64_t v32 = v40;
  }
  while (v31 != 8);
  return result;
}

void *sub_10001E3F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = *(void **)(a1 + 16);
  if (result) {
    return sub_1000473A0(result, a2, a3, a4);
  }
  return result;
}

uint64_t sub_10001E404(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 24))();
}

uint64_t sub_10001E414(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 64))();
}

uint64_t sub_10001E424(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 16);
  if (result) {
    return sub_1000488B0(result);
  }
  return result;
}

uint64_t sub_10001E434(uint64_t a1)
{
  return sub_100048124(*(void *)(a1 + 16));
}

uint64_t sub_10001E43C(uint64_t a1)
{
  return sub_100048154(*(void *)(a1 + 16));
}

uint64_t sub_10001E444(uint64_t a1)
{
  return sub_1000473B8(*(void *)(a1 + 16));
}

uint64_t sub_10001E44C(uint64_t a1)
{
  return sub_1000481F0(*(void *)(a1 + 16));
}

uint64_t sub_10001E454(uint64_t *a1, long long *a2, int a3, unsigned int a4)
{
  uint64_t v38 = 0;
  uint64_t v8 = *(void *)(*a1 + 72);
  if (v8 && *(uint64_t (**)(uint64_t))(v8 + 112) == sub_10001E6F8) {
    return 0;
  }
  uint64_t v9 = malloc_type_malloc(0xA0uLL, 0x8004002E5ACC5uLL);
  if (!v9) {
    return 12;
  }
  uint64_t v17 = v9;
  if (a4) {
    vm_size_t v18 = a4;
  }
  else {
    vm_size_t v18 = dword_100074044;
  }
  if (v18 > 0x100000
    || v18 % *(_DWORD *)(*a1 + 100)
    || vm_page_size < v18 && v18 % vm_page_size
    || vm_page_size > v18 && vm_page_size % v18)
  {
    uint64_t v19 = 34;
  }
  else
  {
    uint64_t v21 = *(long long **)(*a1 + 72);
    long long v23 = v21[8];
    long long v22 = v21[9];
    long long v24 = v21[6];
    v9[7] = v21[7];
    long long v25 = *v21;
    v9[1] = v21[1];
    long long v27 = v21[4];
    long long v26 = v21[5];
    long long v28 = v21[3];
    v9[2] = v21[2];
    v9[3] = v28;
    v9[4] = v27;
    v9[5] = v26;
    v9[6] = v24;
    v9[8] = v23;
    v9[9] = v22;
    *uint64_t v9 = v25;
    *((void *)v9 + 14) = sub_10001E6F8;
    *((void *)v9 + 3) = sub_10001E754;
    *((void *)v9 + 5) = sub_10001E784;
    *((void *)v9 + 4) = sub_10001E9B4;
    *((void *)v9 + 6) = sub_10001E9BC;
    *((void *)v9 + 8) = sub_10001EB00;
    *((void *)v9 + 9) = sub_10001EB7C;
    *((void *)v9 + 11) = sub_10001EC04;
    *((void *)v9 + 16) = sub_10001EC84;
    if (*(unsigned char *)(qword_100091B78 + 36))
    {
      unint64_t v29 = 0x4000000;
    }
    else
    {
      if (a3) {
        unsigned __int8 v30 = a3;
      }
      else {
        unsigned __int8 v30 = 8;
      }
      unint64_t v29 = sub_10001CEE8(v30, (unint64_t)&_mh_execute_header, 0);
    }
    char v31 = a4 != 0;
    unint64_t v32 = *(unsigned int *)(*a1 + 100);
    unint64_t v33 = v29 / v32;
    unint64_t v34 = *(void *)(*a1 + 128);
    unint64_t v35 = v34 * v32;
    if (v33 <= v34) {
      unint64_t v36 = v29;
    }
    else {
      unint64_t v36 = v35;
    }
    vm_size_t v37 = v36 / v18;
    sub_100044548("Requested cache size: %lluMB (%uk blocks * %ukB)\n", v10, v11, v12, v13, v14, v15, v16, v36 >> 20);
    uint64_t v19 = sub_100046F64(&v38, *a1, a2, *(void *)(*a1 + 72), v18, v37, 0x101u, 0, v31);
    if (!v19)
    {
      *(void *)(*a1 + 16) = v38;
      *(void *)(*a1 + 72) = v17;
      return v19;
    }
  }
  free(v17);
  sub_10002F0E0(*a1);
  *a1 = 0;
  return v19;
}

uint64_t sub_10001E6F8(uint64_t a1)
{
  if (*(void *)(a1 + 16))
  {
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = sub_1000473AC(*(void *)(a1 + 16));
    sub_100047230(*(unsigned int **)(a1 + 16));
    *(void *)(a1 + 16) = 0;
  }

  return sub_10002F0E0(a1);
}

double sub_10001E754(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6)
{
  LODWORD(v7) = a6;
  return sub_10001E784(a1, a2, a3, a4, a5, 0, 0, 0, v7);
}

double sub_10001E784(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a6)
  {
    sub_10001EDF8(a1, a2, a3, a4, a5, a9, a7, a8);
  }
  else
  {
    unsigned int v16 = sub_10002F088(a1);
    unsigned __int8 v24 = 1;
    uint64_t v23 = 0;
    if ((a9 & 0x10000) != 0)
    {
      uint64_t v21 = *(void (**)(uint64_t, uint64_t, unint64_t, void *, uint64_t, void, void, uint64_t, uint64_t, void))(sub_1000473AC(*(void *)(a1 + 16)) + 40);
      LODWORD(a9) = a9 & 0xFFFEFFFF;
      v21(a1, a2, a3, a4, a5, 0, 0, a8, a9, 0);
    }
    else
    {
      unint64_t v17 = v16 * a2;
      size_t v18 = v16 * a3;
      if (byte_100091B68)
      {
        __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
        __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
        __darwin_time_t tv_sec = __tp.tv_sec;
        int v20 = SLODWORD(__tp.tv_nsec) / 1000;
      }
      else
      {
        __darwin_time_t tv_sec = 0;
        int v20 = 0;
      }
      if (!sub_1000475E8(*(void *)(a1 + 16), v17, v18, &v23, a5, a9, &v24, 0, a8))
      {
        if (byte_100091B68)
        {
          __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
          __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          sub_10001EFFC(v24, tv_sec, v20, __tp.tv_sec, SLODWORD(__tp.tv_nsec) / 1000, 0);
        }
        long long v22 = (uint64_t *)v23;
        memcpy(a4, *(const void **)(v23 + 40), v18);
        return sub_1000482D4(*(void *)(a1 + 16), v22, 0);
      }
    }
  }
  return result;
}

void sub_10001E9B4(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7)
{
}

uint64_t sub_10001E9BC(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 112)) {
    return 0;
  }
  unsigned int v4 = sub_10002F088(a1);
  unint64_t v5 = *(void *)(a2 + 120);
  uint64_t v6 = *(void *)(a2 + 128);
  uint64_t v7 = *(void *)(a2 + 112);
  uint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  if (byte_100091B68)
  {
    __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    int v9 = SLODWORD(__tp.tv_nsec) / 1000;
  }
  else
  {
    __darwin_time_t tv_sec = 0;
    int v9 = 0;
  }
  uint64_t result = sub_100047474(*(void *)(a1 + 16), v5, &v11);
  if (!result)
  {
    if (byte_100091B68)
    {
      __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
      __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      sub_10001EFFC(0, tv_sec, v9, __tp.tv_sec, SLODWORD(__tp.tv_nsec) / 1000, *(void *)(a2 + 136));
    }
    memcpy(*(void **)(a2 + 104), (const void *)(v7 + v6), v4);
    return sub_100047548(*(void **)(a1 + 16), v11);
  }
  return result;
}

uint64_t sub_10001EB00(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  unsigned int v12 = sub_10002F088(a1);
  return sub_100047D24(*(_DWORD **)(a1 + 16), a4, v12 * a2, v12 * a3, 0, 0, a5, a6, 0);
}

uint64_t sub_10001EB7C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v14 = sub_10002F088(a1);
  return sub_100047D24(*(_DWORD **)(a1 + 16), a4, v14 * a2, v14 * a3, 0, 0, a5, a7, a6);
}

uint64_t sub_10001EC04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v6 = sub_10002F088(a1);
  uint64_t v7 = sub_1000473AC(*(void *)(a1 + 16));
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v7 + 88))(a1, a2, a3);
  if (!v8) {
    sub_1000485EC(*(void *)(a1 + 16), 0, v6 * a2, v6 * a3);
  }
  return v8;
}

uint64_t sub_10001EC84(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100047360(*(void *)(a1 + 16), a2);
  if (!result)
  {
    unint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(sub_1000473AC(*(void *)(a1 + 16)) + 128);
    return v5(a1, a2);
  }
  return result;
}

uint64_t sub_10001ECE4(int a1, uint64_t *a2)
{
  uint64_t result = sub_10002F920(a1, a2);
  if (!result)
  {
    return sub_10001E454(a2, 0, 0, 0);
  }
  return result;
}

uint64_t sub_10001ED38(char *a1, int a2, uint64_t *a3, long long *a4, int a5, unsigned int a6)
{
  uint64_t result = sub_10002FBF4(a1, a2, a3);
  if (!result)
  {
    return sub_10001E454(a3, a4, a5, a6);
  }
  return result;
}

uint64_t sub_10001EDA4(char *a1, int a2, uint64_t *a3)
{
  uint64_t result = sub_10002FBF4(a1, a2, a3);
  if (!result)
  {
    return sub_10001E454(a3, 0, 0, 0);
  }
  return result;
}

void sub_10001EDF8(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8)
{
  if (a3 <= 1 && (a6 & 0x10000) == 0)
  {
    uint64_t v15 = *(void *)(a1 + 16);
    unsigned int v16 = sub_10002F088(a1);
    unint64_t v17 = v16 * a2;
    uint64_t v25 = 0;
    char v24 = 1;
    unsigned int v22 = sub_100047358(v15);
    if (byte_100091B68)
    {
      __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
      __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      __darwin_time_t tv_sec = __tp.tv_sec;
      int v18 = SLODWORD(__tp.tv_nsec) / 1000;
    }
    else
    {
      __darwin_time_t tv_sec = 0;
      int v18 = 0;
    }
    if (!sub_1000475E8(*(void *)(a1 + 16), v17, v16, &v25, a5, a6, &v24, (long long *)a7, a8))
    {
      if (byte_100091B68)
      {
        __tp.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
        __tp.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
        __darwin_time_t v19 = __tp.tv_sec;
        int v20 = SLODWORD(__tp.tv_nsec) / 1000;
      }
      else
      {
        __darwin_time_t v19 = 0;
        int v20 = 0;
      }
      if (v24)
      {
        if (byte_100091B68) {
          sub_10001EFFC(1, tv_sec, v18, v19, v20, 0);
        }
        uint64_t v21 = (uint64_t *)v25;
        memcpy(a4, *(const void **)(v25 + 40), v16);
        sub_1000482D4(*(void *)(a1 + 16), v21, 0);
        *(void *)(a7 + 112) = 0;
      }
      else
      {
        if (byte_100091B68) {
          *(void *)(a7 + 136) = 1000000 * (v19 - tv_sec) - v18 + v20;
        }
        *(void *)(a7 + 104) = a4;
        *(void *)(a7 + 120) = v17 / v22 * v22;
        *(void *)(a7 + 128) = v17 % v22;
      }
    }
  }
}

uint64_t sub_10001EFFC(uint64_t result, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  int v6 = result;
  uint64_t v7 = a6 - a3 + a5 + 1000000 * (a4 - a2);
  if (v7)
  {
    uint64_t result = sub_10004E540(a6 - a3 + a5 + 1000000 * (a4 - a2));
    int v8 = result + 1;
  }
  else
  {
    int v8 = 0;
  }
  if (v8 >= 7) {
    int v8 = 7;
  }
  if (v6) {
    int v9 = (double *)&unk_100078DF0;
  }
  else {
    int v9 = (double *)&unk_100078E20;
  }
  ++*((_DWORD *)v9 + 2);
  *int v9 = *v9 + (double)(unint64_t)v7;
  uint64_t v10 = &unk_100078E2C;
  if (v6) {
    uint64_t v10 = &unk_100078DFC;
  }
  ++v10[v8];
  return result;
}

uint64_t sub_10001F0A4(void *a1, const char *a2, uint64_t a3)
{
  int v6 = sub_100005E48();
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)__str = v7;
  long long v12 = v7;
  snprintf(__str, 0x20uLL, "%s (%s)", a2, v6);
  uint64_t v8 = 0;
  int v9 = (const char *)(a1 + 40);
  do
  {
    if (!strncmp(v9, __str, 0x20uLL)) {
      break;
    }
    ++v8;
    v9 += 48;
  }
  while (v8 != 7);
  memmove(a1 + 46, a1 + 40, 48 * v8);
  __strlcpy_chk();
  uint64_t result = sub_1000104DC();
  a1[44] = result;
  a1[45] = a3;
  return result;
}

char *sub_10001F194(unint64_t a1, char *__str, int a3)
{
  uint64_t v6 = 0;
  LODWORD(v7) = 1;
  do
  {
    if (__ROR8__(0x1CAC083126E978D5 * (a1 / *((void *)&unk_10006F218 + v6 + 1)), 3) >= 0x4189374BC6A7F0uLL) {
      uint64_t v7 = (v6 + 2);
    }
    else {
      uint64_t v7 = v7;
    }
    ++v6;
  }
  while (v6 != 4);
  int v8 = snprintf(__str, a3, "%llu", a1 / 0xE8D4A51000);
  uint64_t result = 0;
  if ((v8 & 0x80000000) == 0 && v8 <= a3)
  {
    if ((int)v7 < 2)
    {
      return __str;
    }
    else
    {
      uint64_t v10 = v7 - 1;
      uint64_t v11 = &qword_10006F220;
      while (1)
      {
        unint64_t v12 = *v11++;
        int v13 = snprintf(&__str[v8], a3 - v8, ".%llu", a1 / v12 % 0x3E8);
        if (v13 < 0) {
          break;
        }
        v8 += v13;
        if (v8 > a3) {
          break;
        }
        if (!--v10) {
          return __str;
        }
      }
      return 0;
    }
  }
  return result;
}

void *sub_10001F308()
{
  return &unk_100078E50;
}

char *sub_10001F314(uint64_t a1, unsigned int a2)
{
  if (a1 && (uint64_t v2 = *(void *)(a1 + 8)) != 0) {
    unsigned int v3 = *(_DWORD *)(v2 + 180);
  }
  else {
    unsigned int v3 = 100;
  }
  if (v3 <= a2) {
    return 0;
  }
  else {
    return (char *)&unk_100079058 + 960 * a2;
  }
}

char *sub_10001F348(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 180);
  if (!v3) {
    return 0;
  }
  unsigned int v4 = (uint64_t *)(v2 + 184);
  for (uint64_t result = (char *)&unk_100079058; ; result += 960)
  {
    uint64_t v6 = *v4++;
    if (v6 == a2) {
      break;
    }
    if (!--v3) {
      return 0;
    }
  }
  return result;
}

void *sub_10001F380(uint64_t a1, unsigned __int8 *uu1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(_DWORD *)(v2 + 180))
  {
    unint64_t v5 = 0;
    uint64_t v6 = &unk_100079058;
    do
    {
      uint64_t v7 = v6[5];
      if (v7)
      {
        if (!uuid_compare(uu1, (const unsigned __int8 *)(v7 + 240))) {
          return v6;
        }
        uint64_t v2 = *(void *)(a1 + 8);
      }
      ++v5;
      v6 += 120;
    }
    while (v5 < *(unsigned int *)(v2 + 180));
  }
  return 0;
}

uint64_t sub_10001F3FC(uint64_t result, _DWORD *a2, int *a3)
{
  uint64_t v3 = qword_100091B78;
  int v4 = *(_DWORD *)(qword_100091B78 + 20);
  if (v4 == -1)
  {
    *a2 = 0;
    if (result && (uint64_t v6 = *(void *)(result + 8)) != 0) {
      int v5 = *(_DWORD *)(v6 + 180);
    }
    else {
      int v5 = 100;
    }
  }
  else
  {
    *a2 = v4;
    int v5 = *(_DWORD *)(v3 + 20) + 1;
  }
  *a3 = v5;
  return result;
}

void sub_10001F444()
{
  uint64_t v0 = (void **)&unk_100079058;
  uint64_t v1 = 100;
  do
  {
    sub_10002C798(v0);
    v0 += 120;
    --v1;
  }
  while (v1);
}

void sub_10001F480()
{
  sub_100044F50();
  uint64_t v0 = (void **)&unk_100079058;
  uint64_t v1 = 100;
  do
  {
    sub_10002C798(v0);
    v0 += 120;
    --v1;
  }
  while (v1);
  sub_10002C6C4(qword_100078E50);
  sub_100044EF8();
  sub_10004392C();
  uint64_t v2 = qword_100091B78;
  if (qword_100091B78)
  {
    if (*(void *)(qword_100091B78 + 56))
    {
      time_t v8 = time(0);
      sub_100048CA8(*(FILE **)(qword_100091B78 + 56), *(_DWORD *)(qword_100091B78 + 28));
      uint64_t v3 = *(FILE **)(qword_100091B78 + 56);
      int v4 = ctime(&v8);
      fprintf(v3, "fsck_apfs completed at %s", v4);
      fclose(*(FILE **)(qword_100091B78 + 56));
      uint64_t v2 = qword_100091B78;
    }
    int v5 = *(FILE **)(v2 + 64);
    if (v5)
    {
      sub_100048CA8(v5, *(_DWORD *)(v2 + 28));
      fclose(*(FILE **)(qword_100091B78 + 64));
    }
  }
  sub_100048AC0();
  if (qword_100091B70) {
    sub_100046348((FILE **)qword_100091B70);
  }
  uint64_t v6 = (void *)qword_100091B78;
  if (qword_100091B78)
  {
    uint64_t v7 = *(void **)(qword_100091B78 + 8);
    if (v7)
    {
      if (*(unsigned char *)(qword_100091B78 + 49))
      {
        sub_100044FC0(*(const char **)(qword_100091B78 + 8));
        uint64_t v7 = *(void **)(qword_100091B78 + 8);
      }
      free(v7);
      uint64_t v6 = (void *)qword_100091B78;
    }
    free(v6);
  }
}

void (__cdecl *sub_10001F5A8())(int)
{
  signal(2, (void (__cdecl *)(int))sub_10001F640);
  signal(1, (void (__cdecl *)(int))sub_10001F640);
  signal(15, (void (__cdecl *)(int))sub_10001F640);
  signal(3, (void (__cdecl *)(int))sub_10001F640);
  signal(10, (void (__cdecl *)(int))sub_10001F640);
  signal(11, (void (__cdecl *)(int))sub_10001F640);
  signal(4, (void (__cdecl *)(int))sub_10001F640);

  return signal(6, (void (__cdecl *)(int))sub_10001F640);
}

void sub_10001F640(int a1)
{
  sub_100044F50();
  uint64_t v2 = (char *)&unk_100079058;
  uint64_t v3 = 100;
  do
  {
    sub_10002C89C((uint64_t)v2);
    v2 += 960;
    --v3;
  }
  while (v3);
  sub_10002C780(qword_100078E50);
  sub_100044EF8();
  if (qword_100091B78)
  {
    int v4 = *(const char **)(qword_100091B78 + 8);
    if (v4)
    {
      if (*(unsigned char *)(qword_100091B78 + 49)) {
        sub_100044FC0(v4);
      }
    }
  }
  _exit(a1 + 128);
}

void sub_10001F6B4(int a1, uint64_t a2, uint64_t a3)
{
  if (a1) {
    unint64_t v4 = 52428800;
  }
  else {
    unint64_t v4 = 10485760;
  }
  if (a1) {
    int v5 = &unk_1000907D8;
  }
  else {
    int v5 = &unk_100090758;
  }
  sub_10001FDE8((uint64_t)v5, a2, v4);
  v5[14] = a3;
  *((unsigned char *)v5 + 120) = 1;
}

void sub_10001F70C(int a1)
{
  if (a1) {
    uint64_t v1 = &unk_1000907D8;
  }
  else {
    uint64_t v1 = &unk_100090758;
  }
  sub_10001FF20((uint64_t)v1);
  v1[13] = 0;
  v1[14] = 0;
}

uint64_t sub_10001F74C(int a1, unint64_t a2, int a3)
{
  if (a1) {
    uint64_t v6 = &unk_1000907D8;
  }
  else {
    uint64_t v6 = &unk_100090758;
  }
  if (!sub_10001FF7C((uint64_t)v6)) {
    return 0;
  }
  uint64_t v7 = a1 ? &unk_1000907D8 : &unk_100090758;
  if (v7[80]) {
    return 0;
  }
  uint64_t v10 = sub_1000203D4((uint64_t)v6, a2, 1uLL, a3 == 0);
  if (v10 == 17) {
    return 0;
  }
  uint64_t v8 = v10;
  if (!v10)
  {
    if (a1) {
      uint64_t v11 = &unk_1000907D8;
    }
    else {
      uint64_t v11 = &unk_100090758;
    }
    if (v11[13] < a2)
    {
      uint64_t v8 = 0;
      v11[13] = a2;
      return v8;
    }
    return 0;
  }
  if (v7[80]) {
    return 0;
  }
  sub_10001FF20((uint64_t)v6);
  if (a1) {
    unint64_t v12 = &unk_1000907D8;
  }
  else {
    unint64_t v12 = &unk_100090758;
  }
  v12[13] = 0;
  v12[14] = 0;
  return v8;
}

uint64_t sub_10001F830(unint64_t a1, int a2)
{
  char v2 = a1;
  int v3 = sub_10001F74C(a2 != 13, a1, 1);
  if (v3)
  {
    int v11 = v3;
    sub_100044674("object (oid 0x%llx): Unable to mark omap entry in usefor omap space verification \n", v4, v5, v6, v7, v8, v9, v10, v2);
    sub_100048B34((char *)0x3D1, v11);
  }
  return 0;
}

uint64_t sub_10001F894(uint64_t *a1, uint64_t a2, int a3, int a4, uint64_t (*a5)(void))
{
  if (a3) {
    uint64_t v9 = &unk_1000907D8;
  }
  else {
    uint64_t v9 = &unk_100090758;
  }
  if (a3) {
    uint64_t v10 = &unk_100090828;
  }
  else {
    uint64_t v10 = &unk_1000907A8;
  }
  if (sub_10001FF7C((uint64_t)v9) && *v10 == 0)
  {
    if (a2) {
      uint64_t v13 = *(void *)(*(void *)(a2 + 40) + 8);
    }
    else {
      uint64_t v13 = 0;
    }
    uint64_t v40 = 0;
    BOOL v14 = sub_100024070(v13);
    uint64_t v15 = (unint64_t *)&unk_1000907C8;
    if (a3) {
      uint64_t v15 = (unint64_t *)&unk_100090848;
    }
    unint64_t v16 = *v15;
    if (a3) {
      unint64_t v17 = &unk_1000907D8;
    }
    else {
      unint64_t v17 = &unk_100090758;
    }
    if (v14) {
      unint64_t v18 = v16;
    }
    else {
      unint64_t v18 = 0;
    }
    uint64_t v12 = sub_10001FAB0(a1, a2, (uint64_t)v9, v18, v17[13] + 1, *((unsigned char *)v17 + 120) == 0, &v40, a4, a5);
    uint64_t v19 = v40;
    if (v12) {
      BOOL v20 = 1;
    }
    else {
      BOOL v20 = v40 == 0;
    }
    if (v20) {
      goto LABEL_43;
    }
    uint64_t v41 = 0;
    if (v13) {
      asprintf(&v41, "volume omap (fs_oid 0x%llx)");
    }
    else {
      asprintf(&v41, "container omap");
    }
    long long v28 = v41;
    if (!*((unsigned char *)v17 + 120)) {
      goto LABEL_35;
    }
    uint64_t v29 = sub_100023560(a1, a2, 1);
    if (v29)
    {
      uint64_t v12 = v29;
      sub_100044674("%s: could not iterate reaper for omap space verification\n", v30, v31, v32, v33, v34, v35, v36, (char)v28);
      uint64_t v37 = 978;
      goto LABEL_40;
    }
    if (sub_10001FF7C((uint64_t)v9))
    {
      uint64_t v12 = sub_10001FAB0(a1, a2, (uint64_t)v9, v18, v17[13] + 1, 1, &v40, a4, a5);
      uint64_t v19 = v40;
    }
    else
    {
LABEL_35:
      uint64_t v12 = 0;
    }
    if (v12 || !v19 || !a4)
    {
LABEL_41:
      if (v28) {
        free(v28);
      }
LABEL_43:
      *((unsigned char *)v17 + 120) = 0;
      return v12;
    }
    sub_100044674("%s: %llu orphan mappings found\n", v21, v22, v23, v24, v25, v26, v27, (char)v28);
    uint64_t v12 = 0;
    uint64_t v37 = 979;
LABEL_40:
    sub_100048B34((char *)v37, -7);
    goto LABEL_41;
  }
  return 0;
}

uint64_t sub_10001FAB0(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, char a6, void *a7, int a8, uint64_t (*a9)(void))
{
  unint64_t v49 = 0;
  unint64_t v50 = 0;
  *a7 = 0;
  if (a4 < a5)
  {
    unint64_t v13 = a4;
    while (sub_100020178(a3, v13, a5 - v13, &v50))
    {
      if ((a6 & 1) == 0)
      {
        uint64_t v26 = 0;
        *a7 = 1;
        return v26;
      }
      if ((sub_10002029C(a3, v50, a5 - v50, &v49) & 1) == 0) {
        unint64_t v49 = a5;
      }
      if (a8)
      {
        if (v50 == v49 - 1) {
          sub_100044674("orphan omap mapping found for oid %llu\n", v15, v16, v17, v18, v19, v20, v21, v50);
        }
        else {
          sub_100044674("orphan omap mappings found for oid range %llu --> %llu\n", v15, v16, v17, v18, v19, v20, v21, v50);
        }
      }
      unint64_t v13 = v49;
      if (*(unsigned char *)(qword_100091B78 + 41))
      {
        unint64_t v22 = v50;
        uint64_t v57 = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&long long v23 = 0xAAAAAAAAAAAAAAAALL;
        *((void *)&v23 + 1) = 0xAAAAAAAAAAAAAAAALL;
        long long v55 = v23;
        long long v56 = v23;
        long long v53 = v23;
        long long v54 = v23;
        long long v52 = v23;
        uint64_t v24 = sub_10002CD48(a1, a2, &v57);
        if (v24) {
          return v24;
        }
        v51[0] = v22;
        v51[1] = 0;
        uint64_t v25 = sub_100038D78((uint64_t)&v52, v57, 0, v51, 0x10u);
        if (v25)
        {
          uint64_t v26 = v25;
          char v39 = strerror(v25);
          sub_10004458C("unable to initialize omap tree iterator for repair: %s\n", v40, v41, v42, v43, v44, v45, v46, v39);
          sub_100048B34((char *)0x3DF, v26);
          return v26;
        }
        if (!BYTE8(v54))
        {
          uint64_t v27 = (unint64_t *)v53;
          while (*v27 < v13)
          {
            ++*a7;
            uint64_t v28 = a9();
            if (v28)
            {
              uint64_t v26 = v28;
              goto LABEL_16;
            }
            uint64_t v29 = (*((uint64_t (**)(long long *))&v52 + 1))(&v52);
            if (v29)
            {
              uint64_t v26 = v29;
              char v30 = strerror(v29);
              sub_10004458C("error iterating omap tree for repair: %s\n", v31, v32, v33, v34, v35, v36, v37, v30);
              sub_100048B34((char *)0x3E1, v26);
              goto LABEL_16;
            }
            uint64_t v27 = (unint64_t *)v53;
            if (BYTE8(v54)) {
              break;
            }
          }
        }
        uint64_t v26 = 0;
LABEL_16:
        if ((void)v52) {
          ((void (*)(long long *))v52)(&v52);
        }
        if (v26) {
          return v26;
        }
        unint64_t v13 = v49;
      }
      if (v13 >= a5) {
        return 0;
      }
    }
  }
  return 0;
}

uint64_t sub_10001FCEC(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v4 = sub_10001F894(a1, a2, a3, 1, (uint64_t (*)(void))sub_10001FD60);
  if (a3) {
    uint64_t v5 = &unk_1000907D8;
  }
  else {
    uint64_t v5 = &unk_100090758;
  }
  sub_10001FF20((uint64_t)v5);
  v5[13] = 0;
  v5[14] = 0;
  return v4;
}

uint64_t sub_10001FD60(long long *a1, uint64_t a2, unsigned char *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v6 = sub_100027E70(a5, 3u, 0, 0, 0, a1, 0x10u, a3, 0x10u);
  uint64_t v7 = v6;
  if (v6)
  {
    uint64_t v8 = *(void *)a1;
    strerror(v6);
    sub_10004458C("object (oid 0x%llx): unable to add omap repair: %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
    sub_100048B34((char *)0x3E0, v7);
  }
  return v7;
}

void sub_10001FDE8(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!sub_100038040(a1, 0, 0, 0x8000000, 2, 0, 0, 4096, 8, 128, 0, 0, (uint64_t)sub_1000306FC)) {
    sub_10003A18C(a1, 0, 0);
  }
  unint64_t v6 = *(unsigned int *)(a1 + 24);
  if (a2) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = -1;
  }
  if (v6 > a3) {
    uint64_t v8 = -1;
  }
  else {
    uint64_t v8 = a3 / v6;
  }
  *(void *)(a1 + 64) = v7;
  *(void *)(a1 + 72) = v8;
  *(void *)(a1 + 96) = 1024;
  uint64_t v9 = malloc_type_calloc(0x80uLL, 1uLL, 0x100004077774924uLL);
  *(void *)(a1 + 88) = v9;
  if (v9)
  {
    uint64_t v10 = v9;
    int v11 = *(_DWORD *)(a1 + 96);
    int v12 = v11 - 1;
    if ((v11 - 1) > 7)
    {
      int v14 = v12 >> 3;
      *uint64_t v9 = 0;
      if (v12 >= 16)
      {
        uint64_t v15 = v9 + 1;
        if (v14 <= 2) {
          int v16 = 2;
        }
        else {
          int v16 = v12 >> 3;
        }
        bzero(v15, (v16 - 1));
      }
      int v13 = 510 << (v12 & 7);
      v10 += v14;
    }
    else
    {
      int v13 = 255 << v11;
    }
    *v10 &= v13;
  }
}

void sub_10001FF20(uint64_t a1)
{
  char v2 = *(void **)(a1 + 88);
  if (v2)
  {
    free(v2);
    *(void *)(a1 + 88) = 0;
  }
  if (*(void *)(a1 + 56))
  {
    sub_10003A268(a1, 0);
  }
}

BOOL sub_10001FF7C(uint64_t a1)
{
  return *(void *)(a1 + 56) != 0;
}

uint64_t sub_10001FF8C(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  if (!a3) {
    return 0;
  }
  unint64_t v5 = a3;
  uint64_t v8 = 0;
  v9.i64[0] = 0xAAAAAAAAAAAAAAAALL;
  v9.i64[1] = 0xAAAAAAAAAAAAAAAALL;
  v12[6] = v9;
  v12[7] = v9;
  v12[4] = v9;
  v12[5] = v9;
  v12[2] = v9;
  void v12[3] = v9;
  v12[0] = v9;
  v12[1] = v9;
  while (1)
  {
    uint64_t result = sub_100020078(a1, a2, v12);
    if (result) {
      break;
    }
    if (v5 >= 1024 - (a2 & 0x3FF)) {
      unint64_t v11 = 1024 - (a2 & 0x3FF);
    }
    else {
      unint64_t v11 = v5;
    }
    memcpy((void *)(a4 + 8 * v8), (char *)v12 + ((a2 >> 3) & 0x78), v11 >> 3);
    a2 += v11;
    v8 += v11 >> 6;
    v5 -= v11;
    if (!v5) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100020078(uint64_t a1, unint64_t a2, int8x16_t *a3)
{
  unint64_t v6 = a2 >> 10;
  unint64_t v23 = a2 >> 10;
  unsigned int v21 = 128;
  unsigned int v22 = 8;
  uint64_t v7 = sub_1000380B0(a1, 0, 0, &v23, &v22, 8u, a3, &v21);
  uint64_t v8 = v7;
  if ((v7 & 0xFFFFFFFD) != 0)
  {
    char v9 = v23;
    strerror(v7);
    sub_10004458C("failed to find node at segment (%llu) : error %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
    sub_100048B34((char *)0x363, v8);
  }
  if (v8 == 2)
  {
    uint64_t v17 = *(void *)(a1 + 88);
    if (v17
      && *(void *)(a1 + 96) > v6
      && ((*(unsigned __int8 *)(v17 + (a2 >> 13)) >> ((a2 >> 10) & 7)) & 1) != 0)
    {
      unsigned int v18 = 255;
    }
    else
    {
      unsigned int v18 = 0;
    }
    uint64_t v8 = 0;
    int8x16_t v19 = vdupq_n_s8(v18);
    a3[6] = v19;
    a3[7] = v19;
    a3[4] = v19;
    a3[5] = v19;
    a3[2] = v19;
    a3[3] = v19;
    *a3 = v19;
    a3[1] = v19;
  }
  return v8;
}

uint64_t sub_100020178(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v6 = a2;
  memset(&v12, 0, 128);
  sub_100020078(a1, a2, &v12);
  if (!a3) {
    return 0;
  }
  for (unint64_t i = (v6 >> 6) & 0xF; ; ++i)
  {
    if (i >= 0x10)
    {
      sub_100020078(a1, v6, &v12);
      unint64_t i = (v6 >> 6) & 0xF;
    }
    unint64_t v9 = 64 - (v6 & 0x3F);
    if (a3 < v9) {
      unint64_t v9 = a3;
    }
    unint64_t v10 = (0xFFFFFFFFFFFFFFFFLL >> -(char)((v6 & 0x3F) + v9)) & (-1 << v6) & v12.i64[i];
    if (v10) {
      break;
    }
    v6 += v9;
    a3 -= v9;
    if (!a3) {
      return 0;
    }
  }
  *a4 = __clz(__rbit64(v10)) | v6 & 0xFFFFFFFFFFFFFFC0;
  return 1;
}

uint64_t sub_10002029C(uint64_t a1, unint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v6 = a2;
  memset(&v16, 0, 128);
  sub_100020078(a1, a2, &v16);
  if (!a3) {
    return 0;
  }
  for (unint64_t i = (v6 >> 6) & 0xF; ; ++i)
  {
    if (i >= 0x10)
    {
      sub_100020078(a1, v6, &v16);
      unint64_t i = (v6 >> 6) & 0xF;
    }
    unint64_t v9 = 64 - (v6 & 0x3F);
    if (a3 < v9) {
      unint64_t v9 = a3;
    }
    unint64_t v10 = (0xFFFFFFFFFFFFFFFFLL >> (-(v6 & 0x3F) - v9)) & (-1 << v6);
    uint64_t v11 = v16.i64[i] & v10;
    if (v11 != v10) {
      break;
    }
    v6 += v9;
    a3 -= v9;
    if (!a3) {
      return 0;
    }
  }
  unint64_t v13 = v11 ^ v10;
  unint64_t v14 = __clz(__rbit64(v11 ^ v10));
  if (v13) {
    unint64_t v15 = v14 + 1;
  }
  else {
    unint64_t v15 = 0;
  }
  *a4 = (v6 & 0xFFFFFFFFFFFFFFC0) + v15 - 1;
  return 1;
}

uint64_t sub_1000203D4(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unint64_t v6 = a2;
  memset(&v22, 0, 128);
  uint64_t result = sub_100020078(a1, a2, &v22);
  if (!result)
  {
    if (a3)
    {
      unint64_t v14 = (v6 >> 6) & 0xF;
      unint64_t v15 = v6;
      while (1)
      {
        if (v14 >= 0x10)
        {
          uint64_t result = sub_100020534(a1, v6, &v22, v9, v10, v11, v12, v13);
          if (result) {
            return result;
          }
          uint64_t result = sub_100020078(a1, v15, &v22);
          if (result) {
            return result;
          }
          unint64_t v14 = (v15 >> 6) & 0xF;
          unint64_t v6 = v15;
        }
        unint64_t v16 = 64 - (v15 & 0x3F);
        if (a3 < v16) {
          unint64_t v16 = a3;
        }
        unint64_t v17 = (0xFFFFFFFFFFFFFFFFLL >> (-(v15 & 0x3F) - v16)) & (-1 << v15);
        uint64_t v18 = v22.i64[v14];
        unint64_t v19 = a4 ? 0 : (0xFFFFFFFFFFFFFFFFLL >> (-(v15 & 0x3F) - v16)) & (-1 << v15);
        if ((v18 & v17) != v19) {
          break;
        }
        unint64_t v20 = v18 & ~v17;
        uint64_t v21 = v18 | v17;
        if (!a4) {
          uint64_t v21 = v20;
        }
        v22.i64[v14] = v21;
        v15 += v16;
        ++v14;
        a3 -= v16;
        if (!a3) {
          return sub_100020534(a1, v6, &v22, v9, v10, v11, v12, v13);
        }
      }
      return 17;
    }
    else
    {
      return sub_100020534(a1, v6, &v22, v9, v10, v11, v12, v13);
    }
  }
  return result;
}

uint64_t sub_100020534(uint64_t a1, unint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 64) <= a2)
  {
    sub_100044674("bitmap store: address %llu is beyond maximum allowed %llu\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a2);
    return 34;
  }
  uint64_t v10 = a1;
  unint64_t v40 = 0;
  sub_10003A0F8(a1, 0, &v40);
  if (v40 >= *(void *)(v10 + 72))
  {
    if (!*(unsigned char *)(v10 + 80)) {
      sub_100044674("bitmap store: reached limit of %llu B-tree nodes\n", v11, v12, v13, v14, v15, v16, v17, *(void *)(v10 + 72));
    }
    *(unsigned char *)(v10 + 80) = 1;
    return 12;
  }
  else
  {
    if (sub_100009FFC((uint64_t)a3, 0, 1024) && *(void *)(v10 + 88) && !sub_100020844(v10, a2 >> 10))
    {
      uint64_t v27 = *(void *)(v10 + 88);
      unint64_t v28 = a2 >> 13;
      int v29 = *(unsigned __int8 *)(v27 + (a2 >> 13)) | (1 << ((a2 >> 10) & 7));
    }
    else
    {
      if (!sub_10000A0DC((uint64_t)a3, 0, 1024)
        || !*(void *)(v10 + 88)
        || sub_100020844(v10, a2 >> 10))
      {
        unint64_t v40 = a2 >> 10;
        uint64_t v18 = sub_100039A6C((_DWORD *)v10, 0, &v40, 8, a3, 128);
        uint64_t v10 = v18;
        if (v18)
        {
          char v19 = v40;
          strerror(v18);
          sub_10004458C("failed to insert node at segment (%llu) error : %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
          sub_100048B34((char *)0x1C9, v10);
        }
        return v10;
      }
      uint64_t v27 = *(void *)(v10 + 88);
      unint64_t v28 = a2 >> 13;
      int v29 = *(unsigned __int8 *)(v27 + (a2 >> 13)) & ~(1 << ((a2 >> 10) & 7));
    }
    *(unsigned char *)(v27 + v28) = v29;
    unint64_t v40 = a2 >> 10;
    int v30 = sub_10003A048(v10, 0, (uint64_t)&v40, 8);
    LODWORD(v10) = v30;
    if ((v30 & 0xFFFFFFFD) != 0)
    {
      char v31 = v40;
      strerror(v30);
      sub_10004458C("failed to remove node at segment (%llu) error : %s\n", v32, v33, v34, v35, v36, v37, v38, v31);
      sub_100048B34((char *)0x1CA, v10);
    }
    if (v10 == 2) {
      return 0;
    }
    else {
      return v10;
    }
  }
}

uint64_t sub_100020720(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unint64_t v6 = a2;
  memset(&v13, 0, 128);
  uint64_t result = sub_100020078(a1, a2, &v13);
  if (!result)
  {
    unint64_t v9 = (v6 >> 6) & 0xF;
    while (a3)
    {
      if (v9 >= 0x10)
      {
        uint64_t result = sub_100020078(a1, v6, &v13);
        if (result) {
          return result;
        }
        unint64_t v9 = (v6 >> 6) & 0xF;
      }
      unint64_t v10 = 64 - (v6 & 0x3F);
      if (a3 < v10) {
        unint64_t v10 = a3;
      }
      unint64_t v11 = (0xFFFFFFFFFFFFFFFFLL >> (-(v6 & 0x3F) - v10)) & (-1 << v6);
      uint64_t v12 = v13.i64[v9] & v11;
      if (!a4) {
        unint64_t v11 = 0;
      }
      a3 -= v10;
      v6 += v10;
      ++v9;
      if (v12 != v11) {
        return 17;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_100020844(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = *(void *)(a1 + 96);
  if (v2 > a2) {
    return 0;
  }
  unint64_t v5 = *(void **)(a1 + 88);
  uint64_t v6 = 1 << -(char)__clz(a2);
  uint64_t v7 = malloc_type_realloc(v5, (unint64_t)(v6 + 7) >> 3, 0x5D986598uLL);
  if (v7)
  {
    uint64_t v8 = v7;
    int v9 = v6 - 1;
    int v10 = (int)v2 >> 3;
    unsigned int v11 = 0xFFu >> (8 - (v2 & 7));
    if ((int)v2 >> 3 == ((int)v6 - 1) >> 3)
    {
      int v12 = v11 | (510 << (v9 & 7));
    }
    else
    {
      v7[v10] &= v11;
      if (v10 + 1 < v9 >> 3) {
        bzero(&v7[v10 + 1], ((v9 >> 3) - v10 - 2) + 1);
      }
      int v12 = 510 << (v9 & 7);
      int v10 = v9 >> 3;
    }
    uint64_t v3 = 0;
    v8[v10] &= v12;
    *(void *)(a1 + 88) = v8;
    *(void *)(a1 + 96) = v6;
  }
  else
  {
    free(v5);
    sub_10004458C("failed to allocate memory for bitmap store\n", v13, v14, v15, v16, v17, v18, v19, v21);
    uint64_t v3 = 12;
    sub_100048B34((char *)0x3B2, 12);
  }
  return v3;
}

uint64_t sub_10002097C(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t sub_1000209D8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  if (a4) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = -1;
  }
  uint64_t v14 = a3;
  uint64_t v15 = v7;
  unint64_t v12 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v10 = 16;
  unsigned int v11 = 16;
  uint64_t result = sub_10002CD48(a1, a2, &v16);
  if (!result)
  {
    uint64_t result = sub_1000380B0(v16, 0, 0xFFFFFFFFLL, &v14, &v11, 0x10u, &v12, &v10);
    if (!result)
    {
      uint64_t result = 92;
      if (v11 == 16 && v10 == 16)
      {
        if (v14 != a3) {
          return 2;
        }
        int v9 = v12;
        if (v12)
        {
          return 2;
        }
        else
        {
          uint64_t result = 0;
          *(void *)a5 = v13;
          *(_DWORD *)(a5 + 8) = HIDWORD(v12);
          *(_DWORD *)(a5 + 12) = v9;
          *(void *)(a5 + 16) = v15;
        }
      }
    }
  }
  return result;
}

uint64_t sub_100020AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int32x2_t *a5)
{
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  v7[0] = a3;
  v7[1] = a4;
  v6[0] = vrev64_s32(a5[1]);
  v6[1] = *a5;
  uint64_t result = sub_10002CD48(a1, a2, &v8);
  if (!result) {
    return sub_100039A6C(v8, 0, v7, 16, v6, 16);
  }
  return result;
}

uint64_t sub_100020B14(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v25 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v24 = a3;
  *((void *)&v24 + 1) = a4;
  unint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v20 = 16;
  unsigned int v21 = 16;
  uint64_t result = sub_10002CB10(a1, a2, &v26);
  if (!result)
  {
    uint64_t result = sub_10002CD48(a1, a2, &v25);
    if (!result)
    {
      uint64_t result = sub_1000380B0(v25, 0, 0, &v24, &v21, 0x10u, &v22, &v20);
      if (!result)
      {
        uint64_t result = 92;
        if (v21 == 16 && v20 == 16)
        {
          int v11 = v22;
          if (v22) {
            return 2;
          }
          if (a5)
          {
            *(void *)a5 = v23;
            *(_DWORD *)(a5 + 8) = HIDWORD(v22);
            *(_DWORD *)(a5 + 12) = v11;
            *(void *)(a5 + 16) = *((void *)&v24 + 1);
          }
          unint64_t v12 = *(void *)(v26 + 64);
          if (v12) {
            BOOL v13 = v12 >= a4;
          }
          else {
            BOOL v13 = 0;
          }
          int v14 = !v13;
          if (v14 != 1) {
            goto LABEL_22;
          }
          long long v19 = v24;
          v18[0] = 0xAAAAAAAAAAAAAAAALL;
          v18[1] = 0xAAAAAAAAAAAAAAAALL;
          uint64_t result = sub_1000380B0(v25, 0, 4294967294, &v19, &v21, 0x10u, v18, &v20);
          if ((result & 0xFFFFFFFD) == 0)
          {
            int v15 = result;
            uint64_t result = 92;
            if (v21 == 16 && v20 == 16)
            {
              if (v15 == 2 || (void)v19 != a3)
              {
                LODWORD(result) = sub_10003A048(v25, 0, (uint64_t)&v24, 16);
                BOOL v16 = result == 0;
                goto LABEL_23;
              }
LABEL_22:
              *((void *)&v24 + 1) = *(void *)(*(void *)(a1 + 8) + 16);
              LODWORD(v22) = 1;
              LODWORD(result) = sub_100039A6C(v25, 0, &v24, 16, &v22, 16);
              BOOL v16 = result == 0;
              if (!v14)
              {
                unsigned int v17 = 17;
LABEL_26:
                if (v16) {
                  return v17;
                }
                else {
                  return result;
                }
              }
LABEL_23:
              unsigned int v17 = 0;
              goto LABEL_26;
            }
          }
        }
      }
    }
  }
  return result;
}

char *sub_100020D04(char *result)
{
  if (result[10]) {
    BOOL v1 = qword_100090890 == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1)
  {
    if (!sub_100038040((uint64_t)&xmmword_100090858, 0, 0, 0x8000000, 2, 0, 0, 4096, 8, 21, 0, 0, (uint64_t)sub_1000306FC))sub_10003A18C((uint64_t)&xmmword_100090858, 0, 0); {
    uint64_t result = (char *)sub_10001CF74((uint64_t)&xmmword_100090858, (uint64_t)"phys extent", (uint64_t)sub_100020DF0);
    }
    if (result)
    {
      sub_100044674("failed to register the phys extent tree in the fsck memory storage\n", v2, v3, v4, v5, v6, v7, v8, v9);
      return sub_100048B34((char *)0x587, 12);
    }
  }
  return result;
}

uint64_t sub_100020DF0()
{
  xmmword_100074168 = 0u;
  unk_100074178 = 0u;
  xmmword_100074148 = 0u;
  unk_100074158 = 0u;
  xmmword_100074128 = 0u;
  unk_100074138 = 0u;
  xmmword_100074108 = 0u;
  unk_100074118 = 0u;
  xmmword_1000740E8 = 0u;
  unk_1000740F8 = 0u;
  xmmword_1000740C8 = 0u;
  unk_1000740D8 = 0u;
  xmmword_1000740A8 = 0u;
  unk_1000740B8 = 0u;
  xmmword_100074088 = 0u;
  unk_100074098 = 0u;
  xmmword_100074068 = 0u;
  unk_100074078 = 0u;
  xmmword_100074048 = 0u;
  *(_OWORD *)&qword_100074058 = 0u;
  BYTE8(xmmword_100074068) = 1;
  sub_10003A268((uint64_t)&xmmword_100090858, 0);

  return sub_10003A268((uint64_t)&xmmword_100090898, 0);
}

uint64_t sub_100020E6C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v6 = a4;
  unint64_t v7 = 0xAAAAAAAAAAAAAAAALL;
  LOBYTE(v7) = a5;
  return sub_100020EB0(a1, a2, a3, 1, (void (*)(unsigned char *, uint64_t))sub_10002121C, (uint64_t)&v6);
}

uint64_t sub_100020EB0(uint64_t a1, unint64_t a2, uint64_t a3, int a4, void (*a5)(unsigned char *, uint64_t), uint64_t a6)
{
  if (!qword_100090890) {
    return 0;
  }
  unint64_t v10 = a2;
  uint64_t v29 = 0;
  memset(v28, 0, sizeof(v28));
  unint64_t v27 = a2;
  memset(v26, 0, sizeof(v26));
  uint64_t result = sub_100021FB8((uint64_t *)&v27, v26, 4294967294);
  if (result == 2 && (uint64_t result = sub_100021FB8((uint64_t *)&v27, v26, 1), result == 2) && a4)
  {
    unint64_t v27 = -1;
  }
  else
  {
    if (result == 2) {
      return 0;
    }
    if (result)
    {
LABEL_59:
      if (result == 12)
      {
        xmmword_100074168 = 0u;
        unk_100074178 = 0u;
        xmmword_100074148 = 0u;
        unk_100074158 = 0u;
        xmmword_100074128 = 0u;
        unk_100074138 = 0u;
        xmmword_100074108 = 0u;
        unk_100074118 = 0u;
        xmmword_1000740E8 = 0u;
        unk_1000740F8 = 0u;
        xmmword_1000740C8 = 0u;
        unk_1000740D8 = 0u;
        xmmword_1000740A8 = 0u;
        unk_1000740B8 = 0u;
        xmmword_100074088 = 0u;
        unk_100074098 = 0u;
        xmmword_100074068 = 0u;
        unk_100074078 = 0u;
        xmmword_100074048 = 0u;
        *(_OWORD *)&qword_100074058 = 0u;
        BYTE8(xmmword_100074068) = 1;
        sub_10003A268((uint64_t)&xmmword_100090858, 0);
        sub_10003A268((uint64_t)&xmmword_100090898, 0);
        uint64_t result = 0;
        *(unsigned char *)(a1 + 10) = 0;
      }
      return result;
    }
  }
  unint64_t v13 = a3 + v10;
  if (a3 + v10 < v10) {
    return 0;
  }
  while (1)
  {
    uint64_t v14 = v27;
    if (a4)
    {
      unint64_t v15 = v27 - v10;
      if (v27 > v10)
      {
        uint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFLL | 0x1000000000000000;
        *(void *)unint64_t v26 = v16;
        unint64_t v17 = v15 & 0xFFFFFFFFFFFFFFFLL;
        *(_DWORD *)&v26[16] = 0;
        unint64_t v27 = v10;
        uint64_t v14 = v10;
LABEL_17:
        BOOL v20 = v13 <= v14 || v13 - v14 >= v17;
        uint64_t v19 = v13;
        if (v20) {
          goto LABEL_25;
        }
        goto LABEL_21;
      }
    }
    uint64_t v16 = *(void *)v26;
    unint64_t v17 = *(void *)v26 & 0xFFFFFFFFFFFFFFFLL;
    BOOL v18 = v10 <= v27 || v10 - v27 >= v17;
    uint64_t v19 = v10;
    if (v18) {
      goto LABEL_17;
    }
LABEL_21:
    uint64_t v31 = v19;
    v30[1] = *(void *)&v26[8];
    *(void *)((char *)&v30[1] + 5) = *(void *)&v26[13];
    uint64_t v21 = (v14 + v16 - v19) & 0xFFFFFFFFFFFFFFFLL;
    v30[0] = v16 & 0xF000000000000000 | v21;
    *(void *)unint64_t v26 = (v17 - v21) | v16 & 0xF000000000000000;
    if (*(_DWORD *)&v26[16])
    {
      uint64_t result = sub_1000220D0(&xmmword_100090858, (uint64_t *)&v27, v26);
      if (result) {
        goto LABEL_59;
      }
      uint64_t result = sub_1000220D0(&xmmword_100090858, &v31, v30);
      if (result) {
        goto LABEL_59;
      }
      uint64_t v14 = v27;
    }
LABEL_25:
    unint64_t v22 = v14 - v10;
    if (v14 >= (uint64_t)v10)
    {
      BOOL v23 = v22 < v13 - v10 && v13 - v10 >= (*(void *)v26 & 0xFFFFFFFFFFFFFFFuLL);
      if (v23 && v22 <= v13 - v10 - (*(void *)v26 & 0xFFFFFFFFFFFFFFFLL))
      {
        a5(v26, a6);
        if ((a4 & 1) != 0 || *(_DWORD *)&v26[16]) {
          uint64_t result = sub_1000220D0(&xmmword_100090858, (uint64_t *)&v27, v26);
        }
        else {
          uint64_t result = sub_100022060((uint64_t)&xmmword_100090858, (uint64_t *)&v27);
        }
        if (result) {
          goto LABEL_59;
        }
        uint64_t v14 = v27;
      }
    }
    if (v29
      && (*(void *)v28 & 0xFFFFFFFFFFFFFFFLL) + v29 == v14
      && *(_DWORD *)&v28[16] == *(_DWORD *)&v26[16]
      && v28[20] == v26[20])
    {
      *(void *)unint64_t v28 = ((*(void *)v26 & 0xFFFFFFFFFFFFFFFLL) + (*(void *)v28 & 0xFFFFFFFFFFFFFFFLL)) | *(void *)v28 & 0xF000000000000000;
      if (*(_DWORD *)&v28[16])
      {
        if (sub_100022060((uint64_t)&xmmword_100090858, (uint64_t *)&v27)) {
          return 1;
        }
        uint64_t result = sub_1000220D0(&xmmword_100090858, &v29, v28);
        if (result) {
          goto LABEL_59;
        }
        uint64_t v14 = v27;
      }
    }
    else
    {
      uint64_t v29 = v14;
      *(_OWORD *)unint64_t v28 = *(_OWORD *)v26;
      *(void *)&v28[13] = *(void *)&v26[13];
    }
    unint64_t v25 = (*(void *)v26 & 0xFFFFFFFFFFFFFFFLL) + v14;
    if (v25 > v10) {
      unint64_t v10 = v25;
    }
    uint64_t result = sub_100021FB8((uint64_t *)&v27, v26, 2);
    if (result != 2 || (a4 & 1) == 0) {
      break;
    }
    unint64_t v27 = -1;
LABEL_54:
    if (v10 > v13) {
      return 0;
    }
  }
  if (!result) {
    goto LABEL_54;
  }
  if (result != 2) {
    goto LABEL_59;
  }
  return 0;
}

uint64_t sub_10002121C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = *(void *)a2;
  ++*(_DWORD *)(result + 16);
  if (!*(unsigned char *)(result + 20)) {
    *(unsigned char *)(result + 20) = *(unsigned char *)(a2 + 8);
  }
  return result;
}

uint64_t sub_100021248(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return sub_100020EB0(a1, a2, a3, 0, (void (*)(unsigned char *, uint64_t))sub_100021264, 0);
}

uint64_t sub_100021264(uint64_t result)
{
  *(unsigned char *)(result + 20) = 1;
  return result;
}

uint64_t sub_100021270(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return sub_100020EB0(a1, a2, a3, 0, (void (*)(unsigned char *, uint64_t))sub_10002128C, 0);
}

uint64_t sub_10002128C(uint64_t result)
{
  return result;
}

uint64_t sub_10002129C(uint64_t a1)
{
  uint64_t v2 = sub_100021370(a1 + 48, (uint64_t)&xmmword_100090858);
  if (v2 || (uint64_t v2 = sub_100021370(a1 + 168, (uint64_t)&xmmword_100090898), v2))
  {
    char v3 = strerror(v2);
    sub_10004458C("unable to init physical extent tree iterator for repairs: %s\n", v4, v5, v6, v7, v8, v9, v10, v3);
    sub_100048B34((char *)0x461, v2);
    return v2;
  }
  else
  {
    *(void *)(a1 + 8) = sub_100021434;
    *(void *)(a1 + --*(_DWORD *)(result + 16) = a1 + 288;
    *(void *)(a1 + 24) = a1 + 296;
    *(void *)(a1 + 32) = 0x1500000008;
    *(unsigned char *)(a1 + 317) = 1;
    return sub_100021434(a1);
  }
}

uint64_t sub_100021370(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a2 + 56))
  {
    uint64_t v4 = 0;
    goto LABEL_5;
  }
  uint64_t v3 = sub_10003889C(a1, a2, 0, (void *)(a1 + 72), 8u, 8u, (void *)(a1 + 80), 21);
  if (v3)
  {
    uint64_t v4 = v3;
    char v5 = strerror(v3);
    sub_10004458C("unable to init physical extent tree iterator for repairs: %s\n", v6, v7, v8, v9, v10, v11, v12, v5);
    sub_100048B34((char *)0x460, v4);
LABEL_5:
    *(unsigned char *)(a1 + 40) = 1;
    goto LABEL_6;
  }
  if (a1 && !*(unsigned char *)(a1 + 40))
  {
    uint64_t v4 = 0;
    uint64_t v15 = *(void *)(a1 + 80);
    *(void *)(a1 + 104) = *(void *)(a1 + 72);
    uint64_t v13 = v15 & 0xFFFFFFFFFFFFFFFLL;
    goto LABEL_7;
  }
  uint64_t v4 = 0;
LABEL_6:
  uint64_t v13 = 0;
  *(void *)(a1 + 104) = -1;
LABEL_7:
  *(void *)(a1 + 112) = v13;
  return v4;
}

uint64_t sub_100021434(uint64_t a1)
{
  uint64_t result = sub_10002215C(a1 + 48);
  if (!result)
  {
    uint64_t result = sub_10002215C(a1 + 168);
    if (!result)
    {
      if (*(unsigned char *)(a1 + 208))
      {
        int v3 = *(unsigned __int8 *)(a1 + 88);
        *(unsigned char *)(a1 + 40) = v3;
        if (v3) {
          return 0;
        }
        uint64_t v5 = 0;
        uint64_t v4 = *(void *)(a1 + 72);
      }
      else
      {
        *(unsigned char *)(a1 + 40) = 0;
        if (*(unsigned char *)(a1 + 88)) {
          uint64_t v4 = 0;
        }
        else {
          uint64_t v4 = *(void *)(a1 + 72);
        }
        uint64_t v5 = *(void *)(a1 + 192);
      }
      uint64_t v7 = *(void **)(a1 + 16);
      uint64_t v6 = *(void *)(a1 + 24);
      unint64_t v8 = *(void *)(a1 + 152);
      unint64_t v9 = *(void *)(a1 + 272);
      unint64_t v10 = v8 - v9;
      if (v8 >= v9) {
        uint64_t v11 = *(void *)(a1 + 272);
      }
      else {
        uint64_t v11 = *(void *)(a1 + 152);
      }
      if (v8 >= v9)
      {
        if (v8 <= v9)
        {
          unint64_t v16 = *(void *)(a1 + 160);
          unint64_t v17 = *(void *)(a1 + 280);
          if (v16 >= v17) {
            unint64_t v10 = *(void *)(a1 + 280);
          }
          else {
            unint64_t v10 = *(void *)(a1 + 160);
          }
          *(void *)(a1 + 152) = v10 + v8;
          *(void *)(a1 + 160) = v16 - v10;
          *(void *)(a1 + 272) = v10 + v9;
          *(void *)(a1 + 280) = v17 - v10;
          *(void *)(v6 + 8) = -1;
          int v13 = *(_DWORD *)(v4 + 16) - *(_DWORD *)(v5 + 16);
          uint64_t v14 = 0x2000000000000000;
        }
        else
        {
          unint64_t v15 = *(void *)(a1 + 280);
          if (v15 < v10) {
            unint64_t v10 = *(void *)(a1 + 280);
          }
          *(void *)(a1 + 272) = v10 + v9;
          *(void *)(a1 + 280) = v15 - v10;
          *(void *)(v6 + 8) = -1;
          int v13 = -*(_DWORD *)(v5 + 16);
          uint64_t v14 = 0x2000000000000000;
          uint64_t v4 = v5;
        }
      }
      else
      {
        unint64_t v12 = *(void *)(a1 + 160);
        unint64_t v10 = v9 - v8;
        if (v12 < v9 - v8) {
          unint64_t v10 = *(void *)(a1 + 160);
        }
        *(void *)(a1 + 152) = v10 + v8;
        *(void *)(a1 + 160) = v12 - v10;
        *(void *)(v6 + 8) = *(void *)(v4 + 8);
        int v13 = *(_DWORD *)(v4 + 16);
        uint64_t v14 = 0x1000000000000000;
      }
      uint64_t result = 0;
      *(_DWORD *)(v6 + --*(_DWORD *)(result + 16) = v13;
      *(unsigned char *)(v6 + 20) = *(unsigned char *)(v4 + 20);
      *uint64_t v7 = v11;
      *(void *)uint64_t v6 = v10 & 0xFFFFFFFFFFFFFFFLL | v14;
    }
  }
  return result;
}

uint64_t sub_100021590(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4, int a5)
{
  if (a5 == 1)
  {
    if (a2) {
      unint64_t v5 = *(void *)(*(void *)(a2 + 40) + 8);
    }
    else {
      unint64_t v5 = 0;
    }
    return sub_100040DD0(result, a3, a4, v5, 0x40000000, a3, *(void *)(a2 + 56), 0, 0xFu, 2u);
  }
  return result;
}

uint64_t sub_1000215F8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a5;
  unint64_t v11 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v12 = *(void *)a4;
  unint64_t v13 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v14 = *(void *)a4 >> 60;
  if (!qword_100090890 || *(unsigned char *)(a2 + 14))
  {
    if ((a5 & 3) != 0) {
      return 92;
    }
    sub_100021590(a1, a2, *a3 & 0xFFFFFFFFFFFFFFFLL, *(void *)a4 & 0xFFFFFFFFFFFFFFFLL, v14);
    return 0;
  }
  if (byte_100074185)
  {
    uint64_t v61 = *(void *)a4 >> 60;
    char v17 = a5;
    uint64_t v59 = a1;
    uint64_t v63 = a3;
    BOOL v18 = qword_100074060;
    uint64_t v60 = (unint64_t *)qword_100074058;
    unint64_t v19 = *(void *)qword_100074058;
    unint64_t v20 = *qword_100074060 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v21 = *qword_100074060 >> 60;
  }
  else
  {
    uint64_t v15 = sub_10002129C((uint64_t)&xmmword_100074048);
    if (v15) {
      return v15;
    }
    LODWORD(v61) = v14;
    char v17 = v8;
    uint64_t v59 = a1;
    uint64_t v63 = a3;
    BOOL v18 = qword_100074060;
    uint64_t v60 = (unint64_t *)qword_100074058;
    unint64_t v19 = *(void *)qword_100074058;
    unint64_t v20 = *qword_100074060 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v21 = *qword_100074060 >> 60;
    if (!BYTE8(xmmword_100074068)) {
      sub_100021590(v59, a2, v19, v20, v21);
    }
  }
  unint64_t v67 = 0;
  unint64_t v68 = 0;
  int v69 = 0;
  if (v17) {
    return sub_100021CC4((_DWORD *)(a2 + 704), v63, 0, *(void *)(a2 + 56), 0, 0);
  }
  unsigned __int8 v65 = v21;
  if (!v13)
  {
LABEL_113:
    uint64_t v15 = 0;
    goto LABEL_114;
  }
  uint64_t v66 = 0;
  uint64_t v62 = (_DWORD *)(a2 + 704);
  unint64_t v22 = &off_100074000;
  unint64_t v58 = v12 & 0xF000000000000000;
  do
  {
    while (1)
    {
      if (*((unsigned char *)v22 + 112)) {
        unint64_t v19 = -1;
      }
      unint64_t v23 = v19 >= v11 ? v11 : v19;
      if (*((unsigned char *)v18 + 20))
      {
        uint64_t v24 = *(void *)(a2 + 56);
        if (v19 < v11)
        {
          if (v20 >= v11 - v19) {
            unint64_t v25 = v11 - v19;
          }
          else {
            unint64_t v25 = v20;
          }
          v19 += v25;
          v20 -= v25;
          if (v24) {
            goto LABEL_89;
          }
          goto LABEL_28;
        }
        if (v11 < v19)
        {
          if (v13 >= v19 - v11) {
            unint64_t v25 = v19 - v11;
          }
          else {
            unint64_t v25 = v13;
          }
          v11 += v25;
          v13 -= v25;
          if (v24) {
            goto LABEL_89;
          }
          goto LABEL_43;
        }
        if (v13 >= v20) {
          unint64_t v25 = v20;
        }
        else {
          unint64_t v25 = v13;
        }
        v19 += v25;
        v20 -= v25;
        v11 += v25;
        v13 -= v25;
        if (v24)
        {
LABEL_57:
          int v37 = -1;
          goto LABEL_65;
        }
      }
      else
      {
        if (v19 < v11)
        {
          if (v20 >= v11 - v19) {
            unint64_t v25 = v11 - v19;
          }
          else {
            unint64_t v25 = v20;
          }
          v19 += v25;
          v20 -= v25;
LABEL_28:
          if (!*((_DWORD *)v18 + 4)) {
            goto LABEL_89;
          }
          sub_100048B34((char *)0x462, 92);
          int v26 = *((_DWORD *)v18 + 4);
          HIDWORD(v66) |= v26 > 0;
          unint64_t v27 = (void (*)(const char *, ...))sub_100044674;
          if ((v66 & 0x100000000) != 0) {
            unint64_t v27 = (void (*)(const char *, ...))sub_10004458C;
          }
          v27("mismatch between extentref entry reference count (0) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n", v26, v23, v25);
          goto LABEL_79;
        }
        if (v11 < v19)
        {
          if (v13 >= v19 - v11) {
            unint64_t v25 = v19 - v11;
          }
          else {
            unint64_t v25 = v13;
          }
          v11 += v25;
          v13 -= v25;
LABEL_43:
          sub_100048B34((char *)0x463, 92);
          int v35 = *(_DWORD *)(a4 + 16);
          if (v35)
          {
            HIDWORD(v66) |= v35 < 0;
            uint64_t v36 = (void (*)(const char *, ...))sub_100044674;
            if ((v66 & 0x100000000) != 0) {
              uint64_t v36 = (void (*)(const char *, ...))sub_10004458C;
            }
            v36("mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (0) for extent (%llu + %llu)\n", v35, v23, v25);
          }
          else
          {
            sub_100044674("invalid extent (%llu + %llu) with reference count (0)\n", v28, v29, v30, v31, v32, v33, v34, v23);
          }
LABEL_74:
          int v37 = 0;
          goto LABEL_80;
        }
        unint64_t v25 = v13 >= v20 ? v20 : v13;
        v19 += v25;
        v20 -= v25;
        v11 += v25;
        v13 -= v25;
      }
      if (*((_DWORD *)v18 + 4) == *(_DWORD *)(a4 + 16)) {
        goto LABEL_57;
      }
      sub_100048B34((char *)0x464, 92);
      int v38 = *(_DWORD *)(a4 + 16);
      int v39 = *((_DWORD *)v18 + 4);
      if ((v66 & 0x100000000) != 0 || v38 < v39)
      {
        HIDWORD(v66) = 1;
        ((void (*)(const char *, ...))sub_10004458C)("mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n", v38, v39, v23, v25);
      }
      else
      {
        HIDWORD(v66) = 0;
        ((void (*)(const char *, ...))sub_100044674)("mismatch between extentref entry reference count (%d) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n", v38, v39, v23, v25);
      }
      if (!*((_DWORD *)v18 + 4)) {
        goto LABEL_74;
      }
      int v37 = 2;
LABEL_65:
      if (v65 != v61)
      {
        if ((v17 & 2) == 0) {
          sub_100048B34((char *)0x465, 92);
        }
        sub_10004458C("invalid kind (expected %u, actual %u) for extent (%llu + %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v65);
        int v37 = 2;
        HIDWORD(v66) = 1;
      }
      if ((v17 & 4) != 0)
      {
LABEL_78:
        HIDWORD(v66) = 1;
LABEL_79:
        int v37 = 2;
        goto LABEL_80;
      }
      if (v65 == 1)
      {
        unint64_t v40 = *(void *)(a4 + 8);
        HIDWORD(v66) |= v40 > 0xFFFFFFFFFFFFFFFDLL;
        if (v40 > 0xFFFFFFFFFFFFFFFDLL) {
          int v37 = 2;
        }
      }
      else if (v65 == 2 && *(void *)(a4 + 8) != -1)
      {
        goto LABEL_78;
      }
      if ((v66 & (v37 == -1)) != 0) {
        goto LABEL_78;
      }
      if (v37 == -1)
      {
LABEL_82:
        unint64_t v22 = &off_100074000;
        goto LABEL_89;
      }
LABEL_80:
      if (v66) {
        goto LABEL_81;
      }
      uint64_t v41 = *v63;
      unint64_t v42 = *v63 & 0xFFFFFFFFFFFFFFFLL;
      if (v23 >= v42)
      {
        if (v23 == v42)
        {
          if (v25 == (*(void *)a4 & 0xFFFFFFFFFFFFFFFLL)) {
            goto LABEL_84;
          }
          HIDWORD(v66) = 1;
        }
        else
        {
          v70[0] = *v63;
          unint64_t v47 = *(void *)(a4 + 8);
          unint64_t v67 = (v23 - v41) & 0xFFFFFFFFFFFFFFFLL | v58;
          unint64_t v68 = v47;
          int v69 = *(_DWORD *)(a4 + 16);
          HIDWORD(v66) = 1;
          uint64_t v45 = sub_100021CC4(v62, v70, &v67, *(void *)(a2 + 56), 2, 1);
          if (v45) {
            return v45;
          }
        }
LABEL_81:
        LOBYTE(v66) = 1;
        if (v37 != 2) {
          goto LABEL_82;
        }
        goto LABEL_85;
      }
LABEL_84:
      LOBYTE(v66) = 0;
LABEL_85:
      v70[0] = v23 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
      unint64_t v43 = v18[1];
      unint64_t v67 = v25 & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v65 << 60);
      unint64_t v68 = v43;
      int v69 = *((_DWORD *)v18 + 4);
      if (v37) {
        uint64_t v44 = &v67;
      }
      else {
        uint64_t v44 = 0;
      }
      uint64_t v45 = sub_100021CC4(v62, v70, v44, *(void *)(a2 + 56), v37, BYTE4(v66) & 1);
      unint64_t v22 = &off_100074000;
      if (v45) {
        return v45;
      }
LABEL_89:
      if (!v20) {
        break;
      }
LABEL_94:
      if (!v13) {
        goto LABEL_111;
      }
    }
    if (*((unsigned char *)v22 + 112)) {
      goto LABEL_93;
    }
    uint64_t v46 = (*((uint64_t (**)(long long *))&xmmword_100074048 + 1))(&xmmword_100074048);
    if (v46)
    {
      uint64_t v15 = v46;
      char v50 = strerror(v46);
      sub_10004458C("error iterating physical extent tree: %s\n", v51, v52, v53, v54, v55, v56, v57, v50);
      sub_100048B34((char *)0x466, v15);
      return v15;
    }
    if (*((unsigned char *)v22 + 112))
    {
LABEL_93:
      unint64_t v20 = 0;
      goto LABEL_94;
    }
    BOOL v18 = qword_100074060;
    uint64_t v60 = (unint64_t *)qword_100074058;
    unint64_t v19 = *(void *)qword_100074058;
    unint64_t v20 = *qword_100074060 & 0xFFFFFFFFFFFFFFFLL;
    uint64_t v48 = *qword_100074060 >> 60;
    sub_100021590(v59, a2, *(void *)qword_100074058, v20, v48);
    unsigned __int8 v65 = v48;
    unint64_t v22 = &off_100074000;
  }
  while (v13);
LABEL_111:
  if ((v66 & 1) == 0) {
    goto LABEL_113;
  }
  v70[0] = *v63;
  uint64_t v15 = sub_100021CC4(v62, v70, 0, *(void *)(a2 + 56), 0, BYTE4(v66) & 1);
LABEL_114:
  *uint64_t v60 = v19;
  *BOOL v18 = v20 & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v65 << 60);
  return v15;
}

uint64_t sub_100021CC4(_DWORD *a1, uint64_t *a2, unsigned char *a3, uint64_t a4, int a5, char a6)
{
  uint64_t v6 = *a2;
  *(void *)&long long v19 = a4;
  *((void *)&v19 + 1) = v6;
  if (a3) {
    unsigned int v7 = 20;
  }
  else {
    unsigned int v7 = 0;
  }
  uint64_t v8 = sub_100027E70(a1, 6u, a5, 0, a6, &v19, 0x10u, a3, v7);
  uint64_t v9 = v8;
  if (v8)
  {
    char v10 = BYTE8(v19);
    strerror(v8);
    sub_10004458C("could not cache physical extent repair at %llu error: %s\n", v11, v12, v13, v14, v15, v16, v17, v10);
    sub_100048B34((char *)0x336, v9);
  }
  return v9;
}

uint64_t sub_100021D5C(uint64_t a1, uint64_t a2)
{
  if (!qword_100090890) {
    return 0;
  }
  int v3 = (_DWORD *)(a1 + 704);
  while (!BYTE8(xmmword_100074068))
  {
    uint64_t v4 = (void *)qword_100074058;
    unint64_t v5 = (long long *)unk_100074060;
    if ((!*(unsigned char *)(unk_100074060 + 20) || !*(void *)(a1 + 56)) && *(_DWORD *)(unk_100074060 + 16))
    {
      sub_100048B34((char *)0x47D, 92);
      int v6 = *((_DWORD *)v5 + 4);
      char v7 = v6 > 0;
      uint64_t v8 = (void (*)(const char *, ...))sub_100044674;
      if (v6 > 0) {
        uint64_t v8 = (void (*)(const char *, ...))sub_10004458C;
      }
      v8("mismatch between extentref entry reference count (0) and calculated fsroot entry reference count (%d) for extent (%llu + %llu)\n", v6, *v4, *(void *)v5 & 0xFFFFFFFFFFFFFFFLL);
      uint64_t v33 = *v4 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
      int v32 = -1431655766;
      *(void *)&long long v31 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v31 + 1) = 0xAAAAAAAAAAAAAAAALL;
      long long v9 = *v5;
      int v32 = *((_DWORD *)v5 + 4);
      long long v31 = v9;
      uint64_t v10 = sub_100021CC4(v3, &v33, &v31, *(void *)(a1 + 56), 2, v7);
      if (v10) {
        return v10;
      }
    }
    uint64_t v11 = (*((uint64_t (**)(long long *))&xmmword_100074048 + 1))(&xmmword_100074048);
    if (v11)
    {
      uint64_t v12 = v11;
      char v13 = strerror(v11);
      sub_10004458C("error iterating physical extent tree: %s\n", v14, v15, v16, v17, v18, v19, v20, v13);
      sub_100048B34((char *)0x47E, v12);
      return v12;
    }
  }
  xmmword_100074168 = 0u;
  unk_100074178 = 0u;
  xmmword_100074148 = 0u;
  unk_100074158 = 0u;
  xmmword_100074128 = 0u;
  unk_100074138 = 0u;
  xmmword_100074108 = 0u;
  unk_100074118 = 0u;
  xmmword_1000740E8 = 0u;
  unk_1000740F8 = 0u;
  xmmword_1000740C8 = 0u;
  unk_1000740D8 = 0u;
  xmmword_1000740A8 = 0u;
  unk_1000740B8 = 0u;
  xmmword_100074088 = 0u;
  unk_100074098 = 0u;
  xmmword_100074068 = 0u;
  unk_100074078 = 0u;
  xmmword_100074048 = 0u;
  *(_OWORD *)&qword_100074058 = 0u;
  BYTE8(xmmword_100074068) = 1;
  if (!a2)
  {
    sub_10003A268((uint64_t)&xmmword_100090858, 0);
    sub_10003A268((uint64_t)&xmmword_100090898, 0);
    return 0;
  }
  sub_10003A268((uint64_t)&xmmword_100090898, 0);
  xmmword_100090898 = xmmword_100090858;
  unk_1000908A8 = unk_100090868;
  xmmword_1000908B8 = xmmword_100090878;
  unk_1000908C8 = unk_100090888;
  if (sub_10001CF74((uint64_t)&xmmword_100090898, (uint64_t)"prev phys extent", (uint64_t)sub_100020DF0))
  {
    sub_100044674("failed to register the prev phys extent tree in the fsck memory storage\n", v21, v22, v23, v24, v25, v26, v27, v29);
    sub_100048B34((char *)0x588, 12);
  }
  uint64_t v12 = 0;
  xmmword_100090878 = 0u;
  unk_100090888 = 0u;
  xmmword_100090858 = 0u;
  unk_100090868 = 0u;
  return v12;
}

uint64_t sub_100021FB8(uint64_t *a1, void *a2, uint64_t a3)
{
  if (!qword_100090890) {
    return 2;
  }
  unsigned int v16 = 8;
  unsigned int v15 = 21;
  uint64_t v4 = sub_1000380B0((uint64_t)&xmmword_100090858, 0, a3, a1, &v16, 8u, a2, &v15);
  uint64_t v5 = v4;
  if ((v4 & 0xFFFFFFFD) != 0)
  {
    uint64_t v6 = *a1;
    strerror(v4);
    sub_10004458C("could not lookup extent at %llu for physical extent repair: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
    sub_100048B34((char *)0x335, v5);
  }
  return v5;
}

BOOL sub_100022060(uint64_t a1, uint64_t *a2)
{
  int v3 = sub_10003A048(a1, 0, (uint64_t)a2, 8);
  BOOL v4 = v3 != 0;
  if (v3)
  {
    uint64_t v5 = *a2;
    strerror(v3 != 0);
    sub_10004458C("could not remove extent at %llu for physical extent repair: %s\n", v6, v7, v8, v9, v10, v11, v12, v5);
    sub_100048B34((char *)0x2B1, v4);
  }
  return v4;
}

uint64_t sub_1000220D0(_DWORD *a1, uint64_t *a2, const void *a3)
{
  uint64_t v4 = sub_100039A6C(a1, 0, a2, 8, a3, 21);
  uint64_t v5 = v4;
  if (v4)
  {
    uint64_t v6 = *a2;
    strerror(v4);
    sub_10004458C("could not insert extent with range (%llu + %llu) for physical extent repair: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
    sub_100048B34((char *)0x34F, v5);
  }
  return v5;
}

uint64_t sub_10002215C(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 40) || *(void *)(result + 112))
    {
      return 0;
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(result + 8))(result);
      if (!result)
      {
        if (*(unsigned char *)(v1 + 40))
        {
          uint64_t v2 = 0;
          uint64_t v3 = -1;
        }
        else
        {
          uint64_t v3 = *(void *)(v1 + 72);
          uint64_t v2 = *(void *)(v1 + 80) & 0xFFFFFFFFFFFFFFFLL;
        }
        uint64_t result = 0;
        *(void *)(v1 + 104) = v3;
        *(void *)(v1 + 112) = v2;
      }
    }
  }
  return result;
}

uint64_t sub_1000221D0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[1];
  size_t v10 = *(void *)(v9 + 1400);
  if (v10)
  {
    uint64_t result = sub_1000222C0(a1, 0x6D6B6579uLL, *(void *)(v9 + 1392), v10, (unsigned __int8 *)(v9 + 72), a6, a7, a8);
    if (result) {
      return result;
    }
    uint64_t v9 = a1[1];
  }
  size_t v12 = *(void *)(v9 + 1304);
  if (!v12 || *(unsigned char *)(qword_100091B78 + 43)) {
    goto LABEL_6;
  }
  uint64_t result = sub_1000222C0(a1, 0x6B657973uLL, *(void *)(v9 + 1296), v12, (unsigned __int8 *)(v9 + 72), a6, a7, a8);
  if (!result)
  {
    uint64_t v9 = a1[1];
LABEL_6:
    sub_100040DD0((uint64_t)a1, *(void *)(v9 + 1392), *(void *)(v9 + 1400), 0, 0x40000000, *(void *)(v9 + 1392), 0, 0, 1u, 1u);
    sub_100040DD0((uint64_t)a1, *(void *)(a1[1] + 1296), *(void *)(a1[1] + 1304), 0, 0x40000000, *(void *)(a1[1] + 1296), 0, 0, 1u, 1u);
    return 0;
  }
  return result;
}

uint64_t sub_1000222C0(uint64_t *a1, size_t a2, uint64_t a3, size_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = a2;
  uint64_t v127 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_10002319C(a1, a2, a3, a4, a5, &v127, a7, a8);
  if (v13) {
    return v13;
  }
  unsigned int v16 = v127;
  uint64_t v17 = sub_1000316F4((uint64_t)v127, 12, *(void *)(a1[1] + 16), v11, 0, *(_DWORD *)(a1[1] + 36) * (int)a4, v14, v15);
  if (v17)
  {
    uint64_t v13 = v17;
    if (v11 == 1835754873)
    {
      char v29 = "media";
    }
    else
    {
      if (v11 == 1919247219)
      {
        sub_100044674("%s keybag (%llu+%llu): block range isn't a valid keybag, skipping checks\n", v18, v19, v20, v21, v22, v23, v24, (char)"volume");
LABEL_34:
        uint64_t v13 = 0;
        goto LABEL_55;
      }
      char v29 = "unknown";
      if (v11 == 1801812339) {
        char v29 = "container";
      }
    }
    sub_10004458C("%s keybag (%llu+%llu): block range isn't a valid keybag, aborting\n", v18, v19, v20, v21, v22, v23, v24, (char)v29);
    goto LABEL_55;
  }
  uint64_t v27 = (char *)(v16 + 16);
  if (v16[16] != 2)
  {
    if (!v16[16])
    {
      if (v11 == 1835754873)
      {
        uint64_t v28 = "media";
      }
      else if (v11 == 1919247219)
      {
        uint64_t v28 = "volume";
      }
      else
      {
        uint64_t v28 = "unknown";
        if (v11 == 1801812339) {
          uint64_t v28 = "container";
        }
      }
      sub_10004458C("%s keybag (%llu+%llu): version cannot be 0\n", v18, v19, v20, v21, v22, v23, v24, (char)v28);
      uint64_t v13 = 92;
      uint64_t v35 = 1061;
      goto LABEL_54;
    }
    if (v11 == 1835754873)
    {
      int v32 = "media";
    }
    else if (v11 == 1919247219)
    {
      int v32 = "volume";
    }
    else
    {
      int v32 = "unknown";
      if (v11 == 1801812339) {
        int v32 = "container";
      }
    }
    sub_100044674("%s keybag (%llu+%llu): unknown version %u\n, skipping checks\n", v18, v19, v20, v21, v22, v23, v24, (char)v32);
    sub_100048B34((char *)0x426, -6);
    goto LABEL_34;
  }
  unsigned int v30 = *(_DWORD *)(a1[1] + 36) * a4;
  if (v30 / 0x18 < (unsigned __int16)v16[17])
  {
    if (v11 == 1835754873)
    {
      long long v31 = "media";
    }
    else if (v11 == 1919247219)
    {
      long long v31 = "volume";
    }
    else
    {
      long long v31 = "unknown";
      if (v11 == 1801812339) {
        long long v31 = "container";
      }
    }
    sub_10004458C("%s keybag (%llu+%llu): number of entries %u exceeds object capacity %lu\n", v18, v19, v20, v21, v22, v23, v24, (char)v31);
    uint64_t v13 = 92;
    uint64_t v35 = 1063;
    goto LABEL_54;
  }
  unsigned int v33 = *((_DWORD *)v16 + 9);
  if (v33 > v30)
  {
    if (v11 == 1835754873)
    {
      uint64_t v34 = "media";
    }
    else if (v11 == 1919247219)
    {
      uint64_t v34 = "volume";
    }
    else
    {
      uint64_t v34 = "unknown";
      if (v11 == 1801812339) {
        uint64_t v34 = "container";
      }
    }
    sub_10004458C("%s keybag (%llu+%llu): number of bytes %u exceeds object size %u\n", v18, v19, v20, v21, v22, v23, v24, (char)v34);
    uint64_t v13 = 92;
    uint64_t v35 = 1064;
    goto LABEL_54;
  }
  if (*((unsigned char *)v16 + 40)
    || *((unsigned char *)v16 + 41)
    || *((unsigned char *)v16 + 42)
    || *((unsigned char *)v16 + 43)
    || *((unsigned char *)v16 + 44)
    || *((unsigned char *)v16 + 45)
    || *((unsigned char *)v16 + 46)
    || *((unsigned char *)v16 + 47))
  {
    if (v11 == 1835754873)
    {
      uint64_t v36 = "media";
    }
    else if (v11 == 1919247219)
    {
      uint64_t v36 = "volume";
    }
    else
    {
      uint64_t v36 = "unknown";
      if (v11 == 1801812339) {
        uint64_t v36 = "container";
      }
    }
    sub_100044674("%s keybag (%llu+%llu): invalid padding\n", v18, v19, v20, v21, v22, v23, v24, (char)v36);
    sub_100048B34((char *)0x429, -10);
    unsigned int v33 = *((_DWORD *)v16 + 9);
  }
  int v38 = (char *)(v16 + 24);
  unint64_t v39 = (unint64_t)&v27[v33];
  if ((unint64_t)(v16 + 24) >= v39)
  {
    LOBYTE(v122) = 0;
    int v121 = 0;
    LODWORD(v42) = 16;
LABEL_130:
    if (v121 == (unsigned __int16)v16[17])
    {
      if (*((_DWORD *)v16 + 9) == v42)
      {
        if (!(_BYTE)v122) {
          goto LABEL_34;
        }
LABEL_158:
        uint64_t v80 = sub_10002340C(a1, v11, a3, a4, a5, (uint64_t)v127, v25, v26);
LABEL_159:
        uint64_t v13 = v80;
        goto LABEL_55;
      }
    }
    else
    {
      if (v11 == 1835754873)
      {
        int v91 = v42;
        char v92 = "media";
      }
      else
      {
        int v91 = v42;
        if (v11 == 1919247219)
        {
          char v92 = "volume";
        }
        else
        {
          char v92 = "unknown";
          if (v11 == 1801812339) {
            char v92 = "container";
          }
        }
      }
      sub_10004458C("%s keybag (%llu+%llu): number of keys %u does not match number of entries found %u\n", v18, v19, v20, v21, v22, v23, v24, (char)v92);
      uint64_t v13 = 92;
      sub_100048B34((char *)0x444, 92);
      if (!sub_10004641C(qword_100091B70, "Fix the number of keys? ", v96, v97, v98, v99, v100, v101, v113))goto LABEL_55; {
      v16[17] = v121;
      }
      LODWORD(v42) = v91;
      if (*((_DWORD *)v16 + 9) == v91) {
        goto LABEL_158;
      }
    }
    if (v11 == 1835754873)
    {
      uint64_t v102 = "media";
    }
    else if (v11 == 1919247219)
    {
      uint64_t v102 = "volume";
    }
    else
    {
      uint64_t v102 = "unknown";
      if (v11 == 1801812339) {
        uint64_t v102 = "container";
      }
    }
    int v103 = v42;
    sub_10004458C("%s keybag (%llu+%llu): number of bytes %u does not match sum of all entries %u\n", v18, v19, v20, v21, v22, v23, v24, (char)v102);
    uint64_t v13 = 92;
    sub_100048B34((char *)0x432, 92);
    if (!sub_10004641C(qword_100091B70, "Fix the number of bytes? ", v104, v105, v106, v107, v108, v109, v114))goto LABEL_55; {
    *((_DWORD *)v16 + 9) = v103;
    }
    goto LABEL_158;
  }
  int v40 = 0;
  int v121 = 0;
  int v122 = 0;
  uint64_t v41 = "unknown";
  if (v11 == 1801812339) {
    uint64_t v41 = "container";
  }
  char v119 = (char)v41;
  uint64_t v42 = 16;
  int v116 = (char *)(v16 + 16);
  unsigned int v117 = v30;
  uint64_t v115 = v16;
  while (1)
  {
    uint64_t v43 = *((unsigned __int16 *)v38 + 9);
    unsigned int v44 = v43 + 24;
    if (((v43 + 24) & 0xF) != 0) {
      unsigned int v44 = v43 - ((v43 + 24) & 0xF) + 40;
    }
    unsigned int v126 = v44;
    unint64_t v123 = v39;
    unsigned int v124 = v39 - v38;
    if (v44 > (int)v39 - (int)v38)
    {
      uint64_t v45 = v42;
      if (v11 == 1835754873)
      {
        uint64_t v46 = "media";
      }
      else
      {
        LOBYTE(v46) = v119;
        if (v11 == 1919247219) {
          uint64_t v46 = "volume";
        }
      }
      sub_10004458C("%s keybag (%llu+%llu): entry %u has size %u > remaining size %u (keybag size %u)\n", v18, v19, v20, v21, v22, v23, v24, (char)v46);
      sub_100048B34((char *)0x4EE, -11);
      LODWORD(v43) = *((unsigned __int16 *)v38 + 9);
      uint64_t v42 = v45;
      uint64_t v27 = v116;
    }
    if (v43 >= 0x201) {
      break;
    }
    if (v42 + v126 > v30)
    {
      if (v11 == 1835754873)
      {
        uint64_t v95 = "media";
      }
      else
      {
        LOBYTE(v95) = v119;
        if (v11 == 1919247219) {
          uint64_t v95 = "volume";
        }
      }
      sub_10004458C("%s keybag (%llu+%llu): entry %u with size %u brings total size %u beyond object size %u\n", v18, v19, v20, v21, v22, v23, v24, (char)v95);
      uint64_t v13 = 92;
      uint64_t v35 = 1067;
      goto LABEL_54;
    }
    uint64_t v120 = v42 + v126;
    uint64_t v118 = v42;
    if (uuid_is_null((const unsigned __int8 *)v38))
    {
      char v47 = v119;
      if (v11 == 1835754873)
      {
        uint64_t v48 = "media";
      }
      else
      {
        LOBYTE(v48) = v119;
        if (v11 == 1919247219) {
          uint64_t v48 = "volume";
        }
      }
      sub_100044674("%s keybag (%llu+%llu): UUID of entry %u is null\n", v18, v19, v20, v21, v22, v23, v24, (char)v48);
      sub_100048B34((char *)0x42C, -2);
      int v55 = sub_10004641C(qword_100091B70, "Remove entry with null UUID? ", v49, v50, v51, v52, v53, v54, v111);
      BOOL v125 = v55 != 0;
      int v56 = v122;
      if (v55) {
        int v56 = 1;
      }
      int v122 = v56;
    }
    else
    {
      BOOL v125 = 0;
      char v47 = v119;
    }
    if (v11 == 1835754873
      && !uuid_is_null((const unsigned __int8 *)v38)
      && uuid_compare((const unsigned __int8 *)v38, (const unsigned __int8 *)(a1[1] + 72)))
    {
      *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
      *(void *)&long long v57 = 0xAAAAAAAAAAAAAAAALL;
      *((void *)&v57 + 1) = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)uuid_string_t out = v57;
      *(_OWORD *)&out[16] = v57;
      *(void *)&v128[29] = 0xAAAAAAAAAAAAAAAALL;
      *(_OWORD *)uuid_string_t v128 = v57;
      *(_OWORD *)&v128[16] = v57;
      uuid_unparse((const unsigned __int8 *)v38, out);
      uuid_unparse((const unsigned __int8 *)(a1[1] + 72), v128);
      sub_100044674("%s keybag (%llu+%llu): UUID %s of entry %u (tag %u) is not the container UUID %s\n", v58, v59, v60, v61, v62, v63, v64, (char)"media");
      sub_100048B34((char *)0x42D, -2);
    }
    if (!*((_WORD *)v38 + 8))
    {
      if (v11 == 1835754873)
      {
        unsigned __int8 v65 = "media";
      }
      else
      {
        LOBYTE(v65) = v47;
        if (v11 == 1919247219) {
          unsigned __int8 v65 = "volume";
        }
      }
      sub_100044674("%s keybag (%llu+%llu): entry %u has 'unknown' tag type\n", v18, v19, v20, v21, v22, v23, v24, (char)v65);
      sub_100048B34((char *)0x42E, -5);
    }
    if (v38[20] || v38[21] || v38[22] || v38[23])
    {
      if (v11 == 1835754873)
      {
        uint64_t v66 = "media";
      }
      else
      {
        LOBYTE(v66) = v47;
        if (v11 == 1919247219) {
          uint64_t v66 = "volume";
        }
      }
      sub_100044674("%s keybag (%llu+%llu): entry %u has invalid padding\n", v18, v19, v20, v21, v22, v23, v24, (char)v66);
      sub_100048B34((char *)0x42F, -10);
    }
    if (v11 == 1801812339 && *((_WORD *)v38 + 8) == 3)
    {
      if (*((_WORD *)v38 + 9) != 16)
      {
        sub_10004458C("%s keybag (%llu+%llu): unlock records entry %u does not contain a range (size %u)\n", v18, v19, v20, v21, v22, v23, v24, (char)"container");
        uint64_t v13 = 92;
        uint64_t v35 = 1072;
        goto LABEL_54;
      }
      if (!sub_1000102B0((uint64_t)a1, *((void *)v38 + 3), *((void *)v38 + 4)))
      {
        sub_10004458C("%s keybag (%llu+%llu): unlock records entry %u contains invalid range %llu+%llu\n", v67, v68, v69, v70, v71, v72, v73, (char)"container");
        sub_100048B34((char *)0x431, 92);
        if (!v125)
        {
          if (!sub_10004641C(qword_100091B70, "Remove entry with invalid range? ", v74, v75, v76, v77, v78, v79, v112))
          {
            uint64_t v13 = 92;
            goto LABEL_55;
          }
          int v122 = 1;
        }
        BOOL v125 = 1;
      }
      uint64_t v80 = sub_1000222C0(a1, 1919247219, *((void *)v38 + 3), *((void *)v38 + 4), v38);
      if (v80) {
        goto LABEL_159;
      }
      sub_100040DD0((uint64_t)a1, *((void *)v38 + 3), *((void *)v38 + 4), 0, 0x40000000, *((void *)v38 + 3), 0, 0, 0xDu, 1u);
      uint64_t v27 = v116;
    }
    if (v126 > v124)
    {
      if (!v125
        && !sub_10004641C(qword_100091B70, "Fix the keybag size? ", v19, v20, v21, v22, v23, v24, v110))
      {
LABEL_124:
        uint64_t v88 = *((unsigned __int16 *)v38 + 9);
        uint64_t v89 = v88 + 24;
        uint64_t v42 = v120;
        ++v121;
        uint64_t v90 = v88 - ((v88 + 24) & 0xF) + 40;
        if ((v89 & 0xF) == 0) {
          uint64_t v90 = v89;
        }
        v38 += v90;
        unint64_t v39 = v123;
        goto LABEL_127;
      }
      unsigned int v81 = *((_DWORD *)v16 + 9) + v126 - v124;
      *((_DWORD *)v16 + 9) = v81;
      unsigned int v82 = (unsigned __int16)v16[17];
      if (v121 + 1 > v82) {
        v16[17] = v82 + 1;
      }
      unint64_t v123 = (unint64_t)&v27[v81];
      int v122 = 1;
    }
    if (!v125) {
      goto LABEL_124;
    }
    uint64_t v83 = *((unsigned __int16 *)v38 + 9);
    rsize_t v84 = v83 + 24;
    uint64_t v85 = v83 - ((v83 + 24) & 0xF) + 40;
    if ((v84 & 0xF) != 0) {
      rsize_t v86 = v85;
    }
    else {
      rsize_t v86 = v84;
    }
    memmove(v38, &v38[v86], v123 - (void)&v38[v86]);
    unsigned int v16 = v115;
    memset_s((void *)(v123 - v86), v86, 0, v86);
    uint64_t v87 = (*((_DWORD *)v115 + 9) - v86);
    *((_DWORD *)v115 + 9) = v87;
    --v115[17];
    unint64_t v39 = (unint64_t)&v27[v87];
    uint64_t v42 = v118;
LABEL_127:
    ++v40;
    unsigned int v30 = v117;
    if ((unint64_t)v38 >= v39) {
      goto LABEL_130;
    }
  }
  unsigned int v93 = "media";
  unsigned int v94 = "volume";
  if (v11 != 1919247219) {
    LOBYTE(v94) = v119;
  }
  if (v11 != 1835754873) {
    LOBYTE(v93) = (_BYTE)v94;
  }
  sub_10004458C("%s keybag (%llu+%llu): entry %u has size %u > maximum size %u\n", v18, v19, v20, v21, v22, v23, v24, (char)v93);
  uint64_t v13 = 92;
  uint64_t v35 = 1066;
LABEL_54:
  sub_100048B34((char *)v35, 92);
LABEL_55:
  free(v127);
  return v13;
}

uint64_t sub_100022F38(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[1];
  size_t v9 = *(void *)(v8 + 1304);
  if (!v9 || *(unsigned char *)(qword_100091B78 + 43)) {
    return 0;
  }
  uint64_t v13 = *(void *)(v8 + 1296);
  unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v10 = sub_10002319C(a1, 0x6B657973uLL, v13, v9, (unsigned __int8 *)(v8 + 72), &v45, a7, a8);
  if (!v10)
  {
    uint64_t v14 = v45;
    unint64_t v15 = v45 + 32;
    unint64_t v16 = v45 + 48;
    unint64_t v17 = v45 + 32 + *(unsigned int *)(v45 + 36);
    if (v45 + 48 >= v17)
    {
LABEL_22:
      uint64_t v10 = 0;
    }
    else
    {
      int v18 = 0;
      char v19 = 0;
      do
      {
        while (!uuid_is_null((const unsigned __int8 *)v16))
        {
          if (sub_10001F380((uint64_t)a1, (unsigned __int8 *)v16)) {
            break;
          }
          *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
          *(void *)&long long v22 = 0xAAAAAAAAAAAAAAAALL;
          *((void *)&v22 + 1) = 0xAAAAAAAAAAAAAAAALL;
          *(_OWORD *)uuid_string_t out = v22;
          *(_OWORD *)&out[16] = v22;
          uuid_unparse((const unsigned __int8 *)v16, out);
          sub_100044674("%s keybag (%llu+%llu): UUID %s of entry %u (tag %u) does not reference any volume\n", v23, v24, v25, v26, v27, v28, v29, (char)"container");
          sub_100048B34((char *)0x445, -2);
          if (!sub_10004641C(qword_100091B70, "Remove orphan entry? ", v30, v31, v32, v33, v34, v35, v44)) {
            break;
          }
          uint64_t v39 = *(unsigned __int16 *)(v16 + 18);
          rsize_t v40 = v39 + 24;
          uint64_t v41 = v39 - ((v39 + 24) & 0xF) + 40;
          if ((v40 & 0xF) != 0) {
            rsize_t v42 = v41;
          }
          else {
            rsize_t v42 = v40;
          }
          memmove((void *)v16, (const void *)(v16 + v42), v17 - (v16 + v42));
          memset_s((void *)(v17 - v42), v42, 0, v42);
          uint64_t v43 = (*(_DWORD *)(v14 + 36) - v42);
          *(_DWORD *)(v14 + 36) = v43;
          --*(_WORD *)(v14 + 34);
          unint64_t v17 = v15 + v43;
          ++v18;
          char v19 = 1;
          if (v16 >= v15 + v43)
          {
            uint64_t v14 = v45;
            goto LABEL_21;
          }
        }
        uint64_t v36 = *(unsigned __int16 *)(v16 + 18);
        uint64_t v37 = v36 + 24;
        uint64_t v38 = v36 - ((v36 + 24) & 0xF) + 40;
        if ((v37 & 0xF) == 0) {
          uint64_t v38 = v37;
        }
        v16 += v38;
        ++v18;
      }
      while (v16 < v17);
      uint64_t v14 = v45;
      if ((v19 & 1) == 0) {
        goto LABEL_22;
      }
LABEL_21:
      uint64_t v10 = sub_10002340C(a1, 1801812339, v13, v9, (unsigned __int8 *)(a1[1] + 72), v14, v20, v21);
    }
    free((void *)v14);
  }
  return v10;
}

uint64_t sub_10002319C(uint64_t *a1, size_t a2, uint64_t a3, size_t count, unsigned __int8 *a5, void *a6, uint64_t a7, uint64_t a8)
{
  int v10 = a2;
  if (HIDWORD(count) || (a2 = *(unsigned int *)(a1[1] + 36), (count * a2) >> 32))
  {
    uint64_t v24 = "media";
    uint64_t v25 = "volume";
    uint64_t v26 = "unknown";
    if (v10 == 1801812339) {
      uint64_t v26 = "container";
    }
    if (v10 != 1919247219) {
      LOBYTE(v25) = (_BYTE)v26;
    }
    if (v10 != 1835754873) {
      LOBYTE(v24) = (_BYTE)v25;
    }
    sub_10004458C("%s keybag (%llu+%llu): size is too large\n", a2, a3, count, (uint64_t)a5, (uint64_t)a6, a7, a8, (char)v24);
    uint64_t v27 = 92;
    uint64_t v28 = 1058;
    int v29 = 92;
    goto LABEL_13;
  }
  uint64_t v14 = malloc_type_calloc(count, a2, 0x71384E9CuLL);
  if (!v14)
  {
    uint64_t v31 = "media";
    uint64_t v32 = "volume";
    uint64_t v33 = "unknown";
    if (v10 == 1801812339) {
      uint64_t v33 = "container";
    }
    if (v10 != 1919247219) {
      LOBYTE(v32) = (_BYTE)v33;
    }
    if (v10 != 1835754873) {
      LOBYTE(v31) = (_BYTE)v32;
    }
    sub_10004458C("%s keybag (%llu+%llu): failed to allocate memory\n", v15, v16, v17, v18, v19, v20, v21, (char)v31);
    uint64_t v27 = 12;
    uint64_t v28 = 1059;
    int v29 = 12;
LABEL_13:
    sub_100048B34((char *)v28, v29);
    return v27;
  }
  long long v22 = v14;
  if (v10 == 1835754873)
  {
    uint64_t v23 = sub_10002F148(*a1, a3);
  }
  else
  {
    uint64_t v34 = a1[1];
    uint64_t v35 = *(char **)(qword_100091B78 + 8);
    *(void *)&v44[0] = a3;
    *((void *)&v44[0] + 1) = count;
    v44[1] = *(_OWORD *)(v34 + 1392);
    uint64_t v23 = sub_10001CC5C(v35, a5, v44, 1, (uint64_t)v22);
  }
  uint64_t v27 = v23;
  if (v23)
  {
    switch(v10)
    {
      case 1835754873:
        uint64_t v36 = "media";
        break;
      case 1919247219:
        uint64_t v36 = "volume";
        break;
      case 1801812339:
        uint64_t v36 = "container";
        break;
      default:
        uint64_t v36 = "unknown";
        break;
    }
    strerror(v23);
    sub_10004458C("%s keybag (%llu+%llu): failed to get keybag: %s\n", v37, v38, v39, v40, v41, v42, v43, (char)v36);
    sub_100048B34((char *)0x424, v27);
    free(v22);
  }
  else
  {
    *a6 = v22;
  }
  return v27;
}

uint64_t sub_10002340C(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, int8x16_t a7, int8x16_t a8)
{
  sub_10003D7D8((unint64_t *)a6, (uint32x4_t *)(a6 + 8), (*(_DWORD *)(a1[1] + 36) * a4 - 8), 0, a7, a8);
  if (a2 == 1835754873)
  {
    uint64_t v14 = sub_10002F2C4(*a1, a3);
  }
  else
  {
    uint64_t v15 = a1[1];
    uint64_t v16 = *(char **)(qword_100091B78 + 8);
    *(void *)&v28[0] = a3;
    *((void *)&v28[0] + 1) = a4;
    v28[1] = *(_OWORD *)(v15 + 1392);
    uint64_t v14 = sub_10001CC5C(v16, a5, v28, 0, a6);
  }
  uint64_t v17 = v14;
  if (v14)
  {
    if (a2 == 1835754873)
    {
      uint64_t v19 = "media";
    }
    else
    {
      uint64_t v18 = "unknown";
      if (a2 == 1801812339) {
        uint64_t v18 = "container";
      }
      if (a2 == 1919247219) {
        uint64_t v19 = "volume";
      }
      else {
        LOBYTE(v19) = (_BYTE)v18;
      }
    }
    strerror(v14);
    sub_10004458C("%s keybag (%llu+%llu): failed to put keybag: %s\n", v20, v21, v22, v23, v24, v25, v26, (char)v19);
    sub_100048B34((char *)0x443, v17);
  }
  return v17;
}

uint64_t sub_100023560(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = a1[2];
  int v7 = *(_DWORD *)(v6 + 104);
  uint64_t v8 = *(void *)(v6 + 96);
  int v27 = 0;
  *(_DWORD *)uint64_t v28 = v7;
  *(void *)&void v28[4] = *(void *)(v6 + 72);
  long long v29 = *(_OWORD *)(v6 + 80);
  uint64_t v30 = v8;
  uint64_t v31 = 0;
  uint64_t v9 = sub_1000236F4(a1, a2, (uint64_t)&v27, a3);
  if (v9) {
    return v9;
  }
  uint64_t v11 = *(void *)(v6 + 48);
  if (!v11) {
    return 0;
  }
  size_t v12 = 0;
  while (2)
  {
    if (v12)
    {
      free(v12);
      uint64_t v31 = 0;
    }
    memset(v26, 170, sizeof(v26));
    uint64_t v13 = sub_1000257B4(a1, 0, 0x80000000, v11, 0, 0, 18, 0, (uint64_t **)&v31, (uint64_t)v26, 0);
    if (!v13)
    {
      size_t v12 = v31;
      for (uint64_t i = *((unsigned int *)v31 + 13); i != -1; uint64_t i = *((unsigned int *)v31 + 10 * i + 16))
      {
        uint64_t v15 = &v12[5 * i];
        int v16 = *((_DWORD *)v15 + 19);
        uint64_t v17 = v15[12];
        int v27 = 0;
        *(void *)uint64_t v28 = *(void *)((char *)v15 + 68);
        *(_DWORD *)&v28[8] = v16;
        long long v29 = *((_OWORD *)v15 + 5);
        uint64_t v30 = v17;
        uint64_t v18 = sub_1000236F4(a1, a2, (uint64_t)&v27, a3);
        if (v18)
        {
          uint64_t v9 = v18;
          goto LABEL_15;
        }
        size_t v12 = v31;
      }
      uint64_t v11 = v12[4];
      if (v11) {
        continue;
      }
      uint64_t v9 = 0;
      goto LABEL_16;
    }
    break;
  }
  uint64_t v9 = v13;
  strerror(v13);
  sub_10004458C("Could not read nx_reaper_list object (oid (0x%llx)): %s\n", v19, v20, v21, v22, v23, v24, v25, v11);
LABEL_15:
  size_t v12 = v31;
  if (v31) {
LABEL_16:
  }
    free(v12);
  return v9;
}

uint64_t sub_1000236F4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = 0;
  memset(v36, 170, sizeof(v36));
  int v9 = *(_DWORD *)(a3 + 4);
  int v8 = *(_DWORD *)(a3 + 8);
  if ((v9 & 0x10) == 0 || (unsigned __int16)v8 != 11) {
    goto LABEL_12;
  }
  uint64_t v10 = *(void *)(a3 + 16);
  if (!byte_100091B80[0])
  {
    uint64_t v14 = 0;
LABEL_11:
    ++byte_100091B80[0];
    *(void *)&byte_100091B80[8 * v14 + 8] = v10;
    goto LABEL_12;
  }
  if (qword_100091B88 != v10)
  {
    uint64_t v11 = 0;
    do
    {
      uint64_t v12 = v11;
      if (byte_100091B80[0] - 1 == v11) {
        break;
      }
      uint64_t v13 = *(void *)&byte_100091B80[8 * v11++ + 16];
    }
    while (v13 != v10);
    uint64_t v14 = byte_100091B80[0];
    if (v12 + 1 >= (unint64_t)byte_100091B80[0]) {
      goto LABEL_11;
    }
  }
LABEL_12:
  uint64_t v15 = *(void *)(a3 + 24);
  if ((v9 & 0x1A) != 0 || v15 == 0) {
    goto LABEL_17;
  }
  unsigned int v19 = v8 & 0xC0000000;
  if (a4 == 1)
  {
    if (v19) {
      goto LABEL_17;
    }
    uint64_t v21 = a2 ? *(void *)(*(void *)(a2 + 40) + 8) : 0;
    if (v21 != *(void *)(a3 + 16)) {
      goto LABEL_17;
    }
    BOOL v20 = (v8 & 0xFFFE) == 2;
  }
  else
  {
    BOOL v20 = 1;
    if (!a4 && !v19 && (unsigned __int16)v8 != 13) {
      goto LABEL_17;
    }
  }
  uint64_t v22 = sub_1000257B4(a1, a2, v19, v15, 0, v8 & 0x3FFF0000, (unsigned __int16)v8, 0, (uint64_t **)&v37, (uint64_t)v36, 0);
  if (v22)
  {
    uint64_t v17 = v22;
    sub_10004458C("failed to read object (oid (0x%llx)) being reaped from disk \n", v23, v24, v25, v26, v27, v28, v29, *(void *)(a3 + 24));
    sub_100048B34((char *)0x22A, v17);
    goto LABEL_18;
  }
  if (v20)
  {
    unsigned int v30 = *((unsigned __int16 *)v37 + 12);
    if (v30 > 0xC)
    {
      if (v30 == 13)
      {
        long long v35 = *(_OWORD *)(a3 + 16);
        long long v40 = *(_OWORD *)a3;
        long long v41 = v35;
        uint64_t v42 = *(void *)(a3 + 32);
        uint64_t v32 = sub_100024604((uint64_t)a1, (uint64_t *)&v40, (uint64_t)v37);
LABEL_44:
        uint64_t v17 = v32;
        if (v32) {
          goto LABEL_18;
        }
        goto LABEL_45;
      }
      if (v30 == 25)
      {
        long long v33 = *(_OWORD *)(a3 + 16);
        long long v40 = *(_OWORD *)a3;
        long long v41 = v33;
        uint64_t v42 = *(void *)(a3 + 32);
        uint64_t v32 = sub_1000248E0((uint64_t)a1, &v40, (uint64_t)v37);
        goto LABEL_44;
      }
    }
    else
    {
      if (v30 - 2 < 2)
      {
        long long v31 = *(_OWORD *)(a3 + 16);
        long long v40 = *(_OWORD *)a3;
        long long v41 = v31;
        uint64_t v42 = *(void *)(a3 + 32);
        long long v38 = *(_OWORD *)v36;
        uint64_t v39 = *(void *)&v36[16];
        uint64_t v32 = sub_1000240DC((uint64_t)a1, a2, (uint64_t)&v40, (uint64_t)v37, (uint64_t)&v38, a4, v28, v29);
        goto LABEL_44;
      }
      if (v30 == 11)
      {
        long long v34 = *(_OWORD *)(a3 + 16);
        long long v40 = *(_OWORD *)a3;
        long long v41 = v34;
        uint64_t v42 = *(void *)(a3 + 32);
        uint64_t v32 = sub_1000243EC((uint64_t)a1, &v40, (uint64_t)v37);
        goto LABEL_44;
      }
    }
  }
LABEL_45:
  if (v19 == 0x40000000)
  {
    sub_100040DD0((uint64_t)a1, *(unint64_t *)v36, (*(_DWORD *)&v36[8] / *(_DWORD *)(a1[1] + 36)), *(void *)(a3 + 16), 0x40000000, *(void *)(a3 + 24), 0, *((unsigned __int16 *)v37 + 12), *((_DWORD *)v37 + 7), 5u);
LABEL_17:
    uint64_t v17 = 0;
    goto LABEL_18;
  }
  uint64_t v17 = 0;
  if (a4 == 1 && !v19)
  {
    sub_10001F830(*(void *)(a3 + 24), *(_DWORD *)(a3 + 8));
    goto LABEL_17;
  }
LABEL_18:
  if (v37) {
    free(v37);
  }
  return v17;
}

uint64_t sub_100023A08(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v54 = 0;
  memset(v55, 170, sizeof(v55));
  uint64_t v8 = a1[2];
  if (*(void *)(v8 + 40) >= *(void *)(v8 + 32))
  {
    sub_10004458C("reaper completed ID 0x%llx not less than next reap ID 0x%llx\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 40));
    uint64_t v9 = 92;
    uint64_t v10 = 96;
    goto LABEL_62;
  }
  if ((*(_DWORD *)(v8 + 64) & 1) == 0)
  {
    sub_10004458C("reaper needs more cowbell, flags 0x%x\n", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 64));
    uint64_t v9 = 92;
    uint64_t v10 = 97;
    goto LABEL_62;
  }
  uint64_t v11 = *(void *)(v8 + 48);
  if ((v11 != 0) == (*(void *)(v8 + 56) == 0))
  {
    sub_10004458C("reaper head (0x%llx) and tail (0x%llx) should be both valid or both invalid\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(v8 + 48));
    uint64_t v9 = 92;
    uint64_t v10 = 98;
    goto LABEL_62;
  }
  if (!v11)
  {
LABEL_60:
    uint64_t v9 = sub_100023560(a1, 0, 0);
    goto LABEL_63;
  }
  uint64_t v13 = 0;
  int v14 = *(_DWORD *)(v8 + 68);
  while (1)
  {
    if (v13) {
      free(v13);
    }
    uint64_t v15 = sub_1000257B4(a1, 0, 0x80000000, v11, 0, 0, 18, 0, &v54, (uint64_t)v55, 0);
    if (v15)
    {
      uint64_t v9 = v15;
      sub_10004458C("verification/reading of the nx_reaper object failed\n", v16, v17, v18, v19, v20, v21, v22, v53[0]);
      goto LABEL_63;
    }
    uint64_t v23 = *((unsigned int *)v54 + 11);
    if (((unint64_t)LODWORD(v55[1]) - 64) / 0x28 != v23)
    {
      sub_10004458C("reap list object 0x%llx max record count %u different than expected %lu\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v9 = 92;
      uint64_t v10 = 642;
      goto LABEL_62;
    }
    if (*((_DWORD *)v54 + 12) > v23)
    {
      sub_10004458C("reap list object 0x%llx record count %u larger than max %u\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v9 = 92;
      uint64_t v10 = 99;
      goto LABEL_62;
    }
    unsigned int v24 = *((_DWORD *)v54 + 13);
    if (v24 != -1 && v24 > v23)
    {
      sub_10004458C("reap list object 0x%llx first index %u larger than max %u\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v9 = 92;
      uint64_t v10 = 100;
      goto LABEL_62;
    }
    unsigned int v26 = *((_DWORD *)v54 + 14);
    if (v26 != -1 && v26 > v23)
    {
      sub_10004458C("reap list object 0x%llx last index %u larger than max %u\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v9 = 92;
      uint64_t v10 = 101;
      goto LABEL_62;
    }
    unsigned int v28 = *((_DWORD *)v54 + 15);
    if (v28 != -1 && v28 > v23)
    {
      sub_10004458C("reap list object 0x%llx free index %u larger than max %u\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v9 = 92;
      uint64_t v10 = 102;
      goto LABEL_62;
    }
    uint64_t v30 = v54[4];
    uint64_t v31 = *(void *)(v8 + 56);
    if (v30)
    {
      if (v31 == v11)
      {
        sub_10004458C("reap list tail 0x%llx is not last reap list object, next 0x%llx\n", v16, v17, v18, v19, v20, v21, v22, v11);
        uint64_t v9 = 92;
        uint64_t v10 = 104;
        goto LABEL_62;
      }
      goto LABEL_29;
    }
    if (v31 != v11) {
      break;
    }
LABEL_29:
    if (*(_DWORD *)(v8 + 68))
    {
      --v14;
      if (v30 && !v14)
      {
        sub_10004458C("reap list expected %u objects, but haven't seen last reap list object yet\n", v16, v17, v18, v19, v20, v21, v22, *(_DWORD *)(v8 + 68));
        uint64_t v9 = 92;
        uint64_t v10 = 105;
        goto LABEL_62;
      }
      if (!v30 && v14)
      {
        sub_10004458C("reap list expected %u objects, but got last reap list object with %u more objects left\n", v16, v17, v18, v19, v20, v21, v22, *(_DWORD *)(v8 + 68));
        uint64_t v9 = 92;
        uint64_t v10 = 106;
        goto LABEL_62;
      }
    }
    size_t v32 = 2 * v23;
    __chkstk_darwin(v15);
    long long v33 = &v53[-((v32 + 15) & 0x3FFFFFFF0)];
    if (v34) {
      memset(&v53[-((v32 + 15) & 0x3FFFFFFF0)], 170, v32);
    }
    else {
      size_t v32 = 0;
    }
    bzero(v33, v32);
    uint64_t v42 = v54;
    unsigned int v43 = *((_DWORD *)v54 + 13);
    if (v43 != -1)
    {
      int v44 = 0;
      while (1)
      {
        if (v43 >= *((_DWORD *)v42 + 11))
        {
          sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : index not less than nrl_max (%u)\n", v35, v36, v37, v38, v39, v40, v41, v43);
          uint64_t v51 = 556;
          goto LABEL_74;
        }
        if (*(_WORD *)&v33[2 * v43] == 1)
        {
          sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : cycle detected\n", v35, v36, v37, v38, v39, v40, v41, v43);
          uint64_t v51 = 643;
          goto LABEL_74;
        }
        *(_WORD *)&v33[2 * v43] = 1;
        unsigned int v45 = HIDWORD(v42[5 * v43 + 8]);
        if (v45 >= 0x20)
        {
          sub_100044674("reaper list entry (index (%u) list oid (0x%llx)) : invalid flags (0x%x) set\n", v35, v36, v37, v38, v39, v40, v41, v43);
          sub_100048B34((char *)0x22D, -3);
          uint64_t v42 = v54;
          unsigned int v45 = HIDWORD(v54[5 * v43 + 8]);
        }
        if ((v45 & 1) == 0)
        {
          sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : is not valid as per flags(0x%x)\n", v35, v36, v37, v38, v39, v40, v41, v43);
          uint64_t v51 = 572;
          goto LABEL_74;
        }
        if ((unint64_t)(v42[5 * v43 + 10] - 1) <= 0x3FE) {
          break;
        }
        ++v44;
        unsigned int v43 = v42[5 * v43 + 8];
        if (v43 == -1) {
          goto LABEL_48;
        }
      }
      sub_100044674("reaper list entry (index (%u) list oid (0x%llx)) : invalid nrle_fs_oid (0x%llx)\n", v35, v36, v37, v38, v39, v40, v41, v43);
      uint64_t v51 = 558;
      int v52 = -2;
      goto LABEL_75;
    }
    int v44 = 0;
LABEL_48:
    if (v44 != *((_DWORD *)v42 + 12))
    {
      sub_10004458C("reap list object (oid 0x%llx) expected %u entries, found %u\n", v35, v36, v37, v38, v39, v40, v41, v11);
      uint64_t v51 = 644;
      goto LABEL_74;
    }
    unsigned int v46 = *((_DWORD *)v42 + 15);
    uint64_t v47 = *((unsigned int *)v42 + 11);
    if (v46 != -1)
    {
      while (1)
      {
        if (v46 >= v47)
        {
          sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : index not less than nrl_max (%u)\n", v35, v36, v37, v38, v39, v40, v41, v46);
          uint64_t v51 = 645;
          goto LABEL_74;
        }
        int v48 = *(unsigned __int16 *)&v33[2 * v46];
        if (v48 == 2)
        {
          sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : cycle detected\n", v35, v36, v37, v38, v39, v40, v41, v46);
          uint64_t v51 = 647;
          goto LABEL_74;
        }
        if (v48 == 1) {
          break;
        }
        *(_WORD *)&v33[2 * v46] = 2;
        unsigned int v46 = v42[5 * v46 + 8];
        if (v46 == -1) {
          goto LABEL_56;
        }
      }
      sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : entry is both occupied and free!\n", v35, v36, v37, v38, v39, v40, v41, v46);
      uint64_t v51 = 646;
LABEL_74:
      int v52 = 92;
LABEL_75:
      sub_100048B34((char *)v51, v52);
      uint64_t v9 = 92;
      goto LABEL_63;
    }
    if (v47)
    {
LABEL_56:
      uint64_t v49 = 0;
      while (*(_WORD *)&v33[2 * v49])
      {
        if (v47 == ++v49) {
          goto LABEL_59;
        }
      }
      sub_10004458C("reaper list entry (index (%u) list oid (0x%llx)) : entry is not referenced\n", v35, v36, v37, v38, v39, v40, v41, v49);
      uint64_t v51 = 648;
      goto LABEL_74;
    }
LABEL_59:
    uint64_t v13 = v54;
    uint64_t v11 = v54[4];
    if (!v11) {
      goto LABEL_60;
    }
  }
  sub_10004458C("last reap list object 0x%llx doesn't match tail 0x%llx\n", v16, v17, v18, v19, v20, v21, v22, v11);
  uint64_t v9 = 92;
  uint64_t v10 = 103;
LABEL_62:
  sub_100048B34((char *)v10, 92);
LABEL_63:
  if (v54) {
    free(v54);
  }
  return v9;
}

BOOL sub_100024070(uint64_t a1)
{
  if (!byte_100091B80[0]) {
    return 0;
  }
  if (qword_100091B88 == a1) {
    return 1;
  }
  uint64_t v2 = 0;
  do
  {
    uint64_t v3 = v2;
    if (byte_100091B80[0] - 1 == v2) {
      break;
    }
    uint64_t v4 = *(void *)&byte_100091B80[8 * v2++ + 16];
  }
  while (v4 != a1);
  return v3 + 1 < (unint64_t)byte_100091B80[0];
}

uint64_t sub_1000240DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v58 = 0u;
  int v56 = 0;
  uint64_t v57 = 0;
  __int16 v8 = *(_WORD *)(a4 + 32);
  if ((v8 & 2) != 0) {
    return 0;
  }
  uint64_t v10 = *(void *)(a3 + 24);
  if ((v8 & 8) != 0)
  {
    sub_10004458C("btree node (oid (0%llx)) being reaped is hashed\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(a3 + 24));
    uint64_t v18 = 22;
    uint64_t v19 = 916;
    int v20 = 22;
    goto LABEL_11;
  }
  unsigned int v51 = *(_DWORD *)(*(void *)(a1 + 8) + 36);
  int v15 = *(_DWORD *)(a3 + 8);
  if (v8)
  {
    uint64_t v21 = a4 + *(unsigned int *)(a5 + 8);
    long long v22 = *(_OWORD *)(v21 - 24);
    long long v58 = *(_OWORD *)(v21 - 40);
    long long v59 = v22;
    *(void *)&long long v60 = *(void *)(v21 - 8);
  }
  else
  {
    uint64_t v16 = *(unsigned int *)(a4 + 28);
    if v16 > 0x24 || ((0x87BD631FFuLL >> v16))
    {
      sub_100044674("object (oid (0%llx)) being reaped : Invalid tree subtype (%u)\n", a2, a3, a4, a5, a6, a7, a8, v10);
      sub_100048B34((char *)0x233, -5);
      return 22;
    }
    int v17 = ((0x100001C000uLL >> v16) & 1) != 0 ? 0 : dword_10006F248[v16];
    DWORD1(v58) = *(_DWORD *)(*(void *)(a1 + 8) + 36);
    DWORD2(v58) = v17;
  }
  if (!*(_DWORD *)(a4 + 36)) {
    return 0;
  }
  unsigned int v23 = 0;
  unsigned int v24 = v15 & 0xC0000000;
  __int16 v55 = -21846;
  __int16 v54 = -21846;
  unsigned int v25 = v15 & 0xC0000000 | 3;
  BOOL v27 = a6 == 1 && v24 == 0;
  BOOL v50 = v27;
  while (1)
  {
    sub_100033F78(a4, (uint64_t)&v58, v23, &v57, &v55, (uint64_t *)&v56, &v54);
    if (v54 != 8)
    {
      sub_10004458C("btree node (oid (0%llx)) being reaped has invalid val_len (%u) at index (%d) \n", v28, v29, v30, v31, v32, v33, v34, v10);
      uint64_t v18 = 92;
      uint64_t v19 = 559;
      goto LABEL_57;
    }
    unint64_t v35 = *v56;
    *(void *)(a3 + 24) = *v56;
    *(_DWORD *)(a3 + 8) = v25;
    if (*(unsigned __int16 *)(a4 + 34) < 2u) {
      break;
    }
    long long v36 = *(_OWORD *)(a3 + 16);
    v52[0] = *(_OWORD *)a3;
    v52[1] = v36;
    uint64_t v53 = *(void *)(a3 + 32);
    uint64_t v37 = sub_1000236F4(a1, a2, v52, a6);
    if (v37) {
      return v37;
    }
LABEL_51:
    if (++v23 >= *(_DWORD *)(a4 + 36)) {
      return 0;
    }
  }
  if (v24 != 0x40000000)
  {
    if (v50) {
      sub_10001F830(v35, v24 | 3);
    }
    goto LABEL_51;
  }
  uint64_t v38 = *(void *)(a1 + 8);
  uint64_t v39 = *(void *)(a1 + 24);
  if (v39)
  {
    unint64_t v40 = *(void *)(v39 + 48);
    unint64_t v41 = *(void *)(v39 + 96);
  }
  else
  {
    unint64_t v40 = *(void *)(v38 + 40);
    if (*(unsigned char *)(v38 + 65)) {
      unint64_t v41 = *(void *)(v38 + 40);
    }
    else {
      unint64_t v41 = 0;
    }
  }
  unint64_t v42 = *(unsigned int *)(v38 + 36);
  unint64_t v43 = DWORD1(v58) / v51;
  if (v35 && (v40 > v43 ? (BOOL v44 = v40 > v35) : (BOOL v44 = 0), v44 ? (v45 = v40 - v43 >= v35) : (v45 = 0), v45)
    || ((unint64_t v46 = 0x4000000000000000uLL >> __clz(__rbit64(v42)), v46 < v35) ? (v47 = v41 > v43) : (v47 = 0),
        v47 ? (BOOL v48 = (v41 | v46) > v35) : (BOOL v48 = 0),
        v48 && ((v41 - v43) | v46) >= v35))
  {
    sub_100040DD0(a1, v35, v43, *(void *)(a3 + 16), 0x40000000, v35, 0, 3u, *(_DWORD *)(a4 + 28), 5u);
    goto LABEL_51;
  }
  sub_10004458C("invalid btree node address range (0x%llx+%llu)\n", v35, v43, v30, v31, v32, v33, v34, v35);
  uint64_t v18 = 92;
  uint64_t v19 = 1238;
LABEL_57:
  int v20 = 92;
LABEL_11:
  sub_100048B34((char *)v19, v20);
  return v18;
}

uint64_t sub_1000243EC(uint64_t a1, long long *a2, uint64_t a3)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[2] = v6;
  v41[3] = v6;
  v41[0] = v6;
  v41[1] = v6;
  v39[2] = v6;
  v39[3] = v6;
  v39[0] = v6;
  v39[1] = v6;
  long long v7 = a2[1];
  long long v35 = *a2;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  memset(v38, 170, sizeof(v38));
  v34[1] = 0;
  v34[2] = 0;
  v34[0] = a1;
  long long v36 = v7;
  uint64_t v37 = *((void *)a2 + 4);
  if (*(void *)(a3 + 48))
  {
    uint64_t v8 = sub_100038040((uint64_t)v41, a1, 0, *(_DWORD *)(a3 + 40) & 0xC0000000, (unsigned __int16)*(_DWORD *)(a3 + 40), 11, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 16, 16, 0, *(void *)(a3 + 48), (uint64_t)sub_10002097C);
    if (v8)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a3 + 48);
      strerror(v8);
      sub_10004458C("Could not initialize omap tree (oid 0x%llx): %s\n", v11, v12, v13, v14, v15, v16, v17, v10);
      uint64_t v18 = 566;
LABEL_7:
      sub_100048B34((char *)v18, v9);
      return v9;
    }
    void v38[2] = 0;
    v38[3] = 0;
    uint64_t v9 = sub_10003889C((uint64_t)v39, (uint64_t)v41, 0, &v38[2], 0x10u, 0x10u, v38, 16);
    if (v9
      || (uint64_t v9 = sub_10002C46C((uint64_t)v39, (uint64_t (*)(void, void, void, void, uint64_t))sub_100024AA8, (uint64_t)v34, 0), v9))
    {
      uint64_t v19 = *(void *)(a3 + 48);
      strerror(v9);
      sub_10004458C("Could not iterate omap tree to read reaper objects (oid 0x%llx): %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
      uint64_t v18 = 567;
      goto LABEL_7;
    }
    *((_DWORD *)a2 + 2) = *(_DWORD *)(a3 + 40);
    *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36);
    *((void *)a2 + 3) = *(void *)(a3 + 48);
    *((void *)a2 + 4) = 0;
    long long v27 = a2[1];
    long long v31 = *a2;
    long long v32 = v27;
    uint64_t v33 = 0;
    uint64_t v9 = sub_1000236F4(a1, 0, &v31, 0);
    if (v9) {
      return v9;
    }
  }
  uint64_t v28 = *(void *)(a3 + 56);
  if (!v28) {
    return 0;
  }
  *((_DWORD *)a2 + 2) = *(_DWORD *)(a3 + 44);
  *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36);
  *((void *)a2 + 3) = v28;
  *((void *)a2 + 4) = 0;
  long long v29 = a2[1];
  long long v31 = *a2;
  long long v32 = v29;
  uint64_t v33 = 0;
  uint64_t v9 = sub_1000236F4(a1, 0, &v31, 0);
  if (!v9) {
    return 0;
  }
  return v9;
}

uint64_t sub_100024604(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  bzero(v38, 0x3C0uLL);
  uint64_t v39 = a3;
  uint64_t v6 = *(void *)(a3 + 152);
  if (!v6)
  {
LABEL_16:
    uint64_t v30 = *(void *)(a3 + 144);
    int v31 = *(_DWORD *)(a3 + 120);
    long long v32 = *((_OWORD *)a2 + 1);
    long long v48 = *(_OWORD *)a2;
    long long v49 = v32;
    *(void *)&long long v50 = a2[4];
    uint64_t v10 = sub_100024BE0(a1, (uint64_t)v38, &v48, 0, v30, v31);
    if (!v10)
    {
      *((_DWORD *)a2 + 2) = 1073741835;
      *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36);
      a2[3] = *(void *)(a3 + 128);
      a2[4] = 0;
      long long v33 = *((_OWORD *)a2 + 1);
      long long v48 = *(_OWORD *)a2;
      long long v49 = v33;
      *(void *)&long long v50 = 0;
      return sub_1000236F4(a1, 0, &v48, 0);
    }
    return v10;
  }
  uint64_t v7 = *a2;
  uint64_t v8 = a2[2];
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v53[2] = v9;
  v53[3] = v9;
  v53[0] = v9;
  v53[1] = v9;
  unint64_t v52 = 0xAAAAAAAAAAAAAAAALL;
  long long v50 = v9;
  long long v51 = v9;
  long long v48 = v9;
  long long v49 = v9;
  v46[0] = a1;
  v46[1] = v38;
  v46[2] = 0;
  v46[3] = v7;
  void v46[4] = a2[1];
  v46[5] = v8;
  long long v47 = *(_OWORD *)(a2 + 3);
  LODWORD(v10) = sub_100038040((uint64_t)v53, a1, (uint64_t)v38, *(_DWORD *)(a3 + 124) & 0xC0000000, (unsigned __int16)*(_DWORD *)(a3 + 124), 16, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, 0, v6, (uint64_t)sub_10003DD34);
  uint64_t v11 = malloc_type_calloc(1uLL, 0x340uLL, 0x44D763ABuLL);
  uint64_t v12 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x3FB5543CuLL);
  uint64_t v13 = v12;
  if (!v10 && v11 && v12)
  {
    uint64_t v10 = sub_10003889C((uint64_t)&v48, (uint64_t)v53, 0, v11, 8u, 0x340u, v12, 3808);
    if (v10
      || (uint64_t v10 = sub_10002C46C((uint64_t)&v48, (uint64_t (*)(void, void, void, void, uint64_t))sub_100024D88, (uint64_t)v46, 0), v10))
    {
      uint64_t v14 = *(void *)(v39 + 152);
      strerror(v10);
      sub_10004458C("Could not iterate snap meta tree to read reaper objects (oid 0x%llx): %s\n", v15, v16, v17, v18, v19, v20, v21, v14);
      sub_100048B34((char *)0x23A, v10);
    }
    else
    {
      int v35 = *(_DWORD *)(v39 + 124);
      int v36 = *(_DWORD *)(*(void *)(a1 + 8) + 36);
      uint64_t v37 = *(void *)(v39 + 152);
      uint64_t v40 = v7;
      int v41 = v35;
      int v42 = v36;
      uint64_t v43 = v8;
      uint64_t v44 = v37;
      uint64_t v45 = 0;
      uint64_t v10 = sub_1000236F4(a1, 0, &v40, 0);
    }
LABEL_12:
    free(v11);
    goto LABEL_13;
  }
  if (v10) {
    uint64_t v10 = v10;
  }
  else {
    uint64_t v10 = 12;
  }
  uint64_t v22 = *(void *)(v39 + 152);
  strerror(v10);
  sub_10004458C("Could not initialize snap meta tree (oid 0x%llx): %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
  sub_100048B34((char *)0x239, v10);
  if (v11) {
    goto LABEL_12;
  }
LABEL_13:
  if (v13) {
    free(v13);
  }
  if (!v10) {
    goto LABEL_16;
  }
  return v10;
}

uint64_t sub_1000248E0(uint64_t a1, long long *a2, uint64_t a3)
{
  long long v3 = a2[1];
  long long v32 = *a2;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  v31[1] = 0;
  v31[2] = 0;
  v31[0] = a1;
  long long v33 = v3;
  uint64_t v34 = *((void *)a2 + 4);
  if ((*(unsigned char *)(a3 + 27) & 0x40) != 0)
  {
    *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v39[2] = v8;
    v39[3] = v8;
    v39[0] = v8;
    v39[1] = v8;
    int v37[2] = v8;
    v37[3] = v8;
    unint64_t v38 = 0xAAAAAAAAAAAAAAAALL;
    v37[0] = v8;
    v37[1] = v8;
    uint64_t v9 = sub_100038040((uint64_t)v39, a1, 0, 0x40000000, 2, 26, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 8, 0, *(void *)(a3 + 32), (uint64_t)sub_1000306FC);
    if (v9)
    {
      uint64_t v4 = v9;
      uint64_t v10 = *(void *)(a3 + 32);
      strerror(v9);
      sub_10004458C("Could not initialize gbitmap tree (oid 0x%llx): %s\n", v11, v12, v13, v14, v15, v16, v17, v10);
      uint64_t v18 = 553;
    }
    else
    {
      uint64_t v4 = sub_10003889C((uint64_t)v37, (uint64_t)v39, 0, &v36, 8u, 8u, &v35, 8);
      if (!v4)
      {
        uint64_t v4 = sub_10002C46C((uint64_t)v37, (uint64_t (*)(void, void, void, void, uint64_t))sub_100024FE4, (uint64_t)v31, 0);
        if (!v4)
        {
          *((_DWORD *)a2 + 2) = 0x40000000;
          *((_DWORD *)a2 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36);
          *((void *)a2 + 3) = *(void *)(a3 + 32);
          long long v28 = a2[1];
          v29[0] = *a2;
          v29[1] = v28;
          uint64_t v30 = *((void *)a2 + 4);
          uint64_t v4 = sub_1000236F4(a1, 0, v29, 0);
          if (v4) {
            return v4;
          }
          return 0;
        }
      }
      uint64_t v19 = *(void *)(a3 + 32);
      strerror(v4);
      sub_10004458C("Could not iterate gbitmap tree to read reaper objects (oid 0x%llx): %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
      uint64_t v18 = 571;
    }
    sub_100048B34((char *)v18, v4);
    return v4;
  }
  return 0;
}

uint64_t sub_100024AA8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a3) {
    return 0;
  }
  uint64_t v10 = *a5;
  uint64_t v11 = *(void *)(*a5 + 8);
  unint64_t v12 = *(unsigned int *)(v11 + 36);
  if ((*(_DWORD *)a3 & 0xE0) == 0x20) {
    int v13 = 36;
  }
  else {
    int v13 = 14;
  }
  unint64_t v14 = ((int)v12 + *(_DWORD *)(a3 + 4) - 1) / v12;
  unint64_t v15 = *(void *)(a3 + 8);
  uint64_t v16 = *(void *)(v10 + 24);
  if (v16)
  {
    unint64_t v17 = *(void *)(v16 + 48);
    unint64_t v18 = *(void *)(v16 + 96);
    if (!v15) {
      goto LABEL_19;
    }
  }
  else
  {
    unint64_t v17 = *(void *)(v11 + 40);
    if (*(unsigned char *)(v11 + 65)) {
      unint64_t v18 = *(void *)(v11 + 40);
    }
    else {
      unint64_t v18 = 0;
    }
    if (!v15) {
      goto LABEL_19;
    }
  }
  if (v17 > v14 && v17 > v15 && v17 - v14 >= v15) {
    goto LABEL_28;
  }
LABEL_19:
  unint64_t v21 = 0x4000000000000000uLL >> __clz(__rbit64(v12));
  BOOL v23 = v21 < v15 && v18 > v14 && (v18 | v21) > v15;
  if (v23 && ((v18 - v14) | v21) >= v15)
  {
LABEL_28:
    unint64_t v25 = a5[5];
    uint64_t v26 = *a1;
    uint64_t v27 = a1[1];
    if (v25) {
      unsigned int v28 = 3;
    }
    else {
      unsigned int v28 = 13;
    }
    if (v25) {
      unsigned int v29 = v13;
    }
    else {
      unsigned int v29 = 0;
    }
    sub_100040DD0(v10, v15, v14, v25, 0, v26, v27, v28, v29, 5u);
    return 0;
  }
  sub_10004458C("omap entry (oid 0x%llx): invalid ov_range (0x%llx+%llu)\n", v15, v14, a4, (uint64_t)a5, a6, a7, a8, *a1);
  uint64_t v24 = 92;
  sub_100048B34((char *)0x4D7, 92);
  return v24;
}

uint64_t sub_100024BE0(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v41[2] = v10;
  v41[3] = v10;
  v41[0] = v10;
  v41[1] = v10;
  v39[2] = v10;
  v39[3] = v10;
  v39[0] = v10;
  v39[1] = v10;
  long long v11 = a3[1];
  long long v34 = *a3;
  unint64_t v40 = 0xAAAAAAAAAAAAAAAALL;
  memset(v37, 170, 20);
  v33[0] = a1;
  v33[1] = a2;
  void v33[2] = a4;
  long long v35 = v11;
  uint64_t v36 = *((void *)a3 + 4);
  uint64_t v12 = sub_100038040((uint64_t)v41, a1, a2, a6 & 0xC0000000, (unsigned __int16)a6, 15, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, 0, a5, (uint64_t)sub_10003DD34);
  if (v12)
  {
    uint64_t v13 = v12;
    strerror(v12);
    sub_10004458C("Could not initialize extentref tree (oid 0x%llx): %s\n", v14, v15, v16, v17, v18, v19, v20, a5);
    uint64_t v21 = 548;
  }
  else
  {
    uint64_t v38 = 0;
    uint64_t v13 = sub_10003889C((uint64_t)v39, (uint64_t)v41, 0, &v38, 8u, 0x340u, v37, 20);
    if (!v13)
    {
      uint64_t v13 = sub_10002C46C((uint64_t)v39, (uint64_t (*)(void, void, void, void, uint64_t))sub_100024ED8, (uint64_t)v33, 0);
      if (!v13)
      {
        *((_DWORD *)a3 + 2) = a6;
        *((_DWORD *)a3 + 3) = *(_DWORD *)(*(void *)(a1 + 8) + 36);
        *((void *)a3 + 3) = a5;
        *((void *)a3 + 4) = 0;
        long long v30 = a3[1];
        v31[0] = *a3;
        v31[1] = v30;
        uint64_t v32 = 0;
        return sub_1000236F4(a1, 0, v31, 0);
      }
    }
    strerror(v13);
    sub_10004458C("Could not iterate extentref tree to read reaper objects(oid 0x%llx): %s\n", v22, v23, v24, v25, v26, v27, v28, a5);
    uint64_t v21 = 568;
  }
  sub_100048B34((char *)v21, v13);
  return v13;
}

uint64_t sub_100024D88(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *a1;
  if ((unint64_t)*a1 >> 60 != 1) {
    return 0;
  }
  uint64_t v9 = *(void *)a5;
  uint64_t v10 = *(void *)(a5 + 8);
  uint64_t v11 = *(void *)a3;
  int v12 = *(_DWORD *)(a3 + 40);
  long long v13 = *(_OWORD *)(a5 + 40);
  v33[0] = *(_OWORD *)(a5 + 24);
  v33[1] = v13;
  uint64_t v34 = *(void *)(a5 + 56);
  uint64_t v20 = sub_100024BE0(v9, v10, v33, v5 & 0xFFFFFFFFFFFFFFFLL, v11, v12);
  if (!v20)
  {
    unint64_t v21 = *(void *)(a3 + 8);
    uint64_t v22 = *(void *)(*(void *)a5 + 8);
    uint64_t v23 = *(void *)(*(void *)a5 + 24);
    if (v23)
    {
      unint64_t v24 = *(void *)(v23 + 48);
      unint64_t v25 = *(void *)(v23 + 96);
    }
    else
    {
      unint64_t v24 = *(void *)(v22 + 40);
      if (*(unsigned char *)(v22 + 65)) {
        unint64_t v25 = *(void *)(v22 + 40);
      }
      else {
        unint64_t v25 = 0;
      }
    }
    unint64_t v26 = *(unsigned int *)(v22 + 36);
    if (v21 && (v24 >= 2 ? (BOOL v27 = v24 > v21) : (BOOL v27 = 0), v27 ? (v28 = v24 - 1 >= v21) : (v28 = 0), v28)
      || ((unint64_t v29 = 0x4000000000000000uLL >> __clz(__rbit64(v26)), v29 < v21) ? (v30 = v25 >= 2) : (v30 = 0),
          v30 ? (BOOL v31 = (v25 | v29) > v21) : (BOOL v31 = 0),
          v31 && ((v25 - 1) | v29) >= v21))
    {
      sub_100040DD0(*(void *)a5, v21, 1, *(void *)(a5 + 40), 0x40000000, v21, *a1 & 0xFFFFFFFFFFFFFFFLL, 0xDu, 0, 5u);
      return 0;
    }
    sub_10004458C("invalid sblock_oid (%llu)\n", v21, v14, v15, v16, v17, v18, v19, *(void *)(a3 + 8));
    uint64_t v20 = 92;
    sub_100048B34((char *)0x4D9, 92);
  }
  return v20;
}

uint64_t sub_100024ED8(char *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a3 >> 60 != 1) {
    return 0;
  }
  unint64_t v8 = *(void *)a1 & 0xFFFFFFFFFFFFFFFLL;
  unint64_t v9 = *a3 & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v10 = *(void *)(*(void *)a5 + 8);
  uint64_t v11 = *(void *)(*(void *)a5 + 24);
  if (v11)
  {
    unint64_t v12 = *(void *)(v11 + 48);
    unint64_t v13 = *(void *)(v11 + 96);
  }
  else
  {
    unint64_t v12 = *(void *)(v10 + 40);
    if (*(unsigned char *)(v10 + 65)) {
      unint64_t v13 = *(void *)(v10 + 40);
    }
    else {
      unint64_t v13 = 0;
    }
  }
  unint64_t v14 = *(unsigned int *)(v10 + 36);
  if (v8 && (v12 > v9 ? (BOOL v15 = v12 > v8) : (BOOL v15 = 0), v15 ? (v16 = v12 - v9 >= v8) : (v16 = 0), v16)
    || ((unint64_t v17 = 0x4000000000000000uLL >> __clz(__rbit64(v14)), v17 < v8) ? (v18 = v13 > v9) : (v18 = 0),
        v18 ? (BOOL v19 = (v13 | v17) > v8) : (BOOL v19 = 0),
        v19 && ((v13 - v9) | v17) >= v8))
  {
    sub_100040DD0(*(void *)a5, v8, v9, *(void *)(a5 + 40), 0x40000000, v8, *(void *)(a5 + 16), 0, 0xFu, 6u);
    return 0;
  }
  sub_10004458C("invalid extent address range (0x%llx+%llu)\n", *(void *)a1 & 0xFFFFFFFFFFFFFFFLL, v9, a4, a5, a6, a7, a8, *a1);
  uint64_t v20 = 92;
  sub_100048B34((char *)0x4D8, 92);
  return v20;
}

uint64_t sub_100024FE4(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)a3 & 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v9 = *(void *)(*(void *)a5 + 8);
  uint64_t v10 = *(void *)(*(void *)a5 + 24);
  if (v10)
  {
    unint64_t v11 = *(void *)(v10 + 48);
    unint64_t v12 = *(void *)(v10 + 96);
  }
  else
  {
    unint64_t v11 = *(void *)(v9 + 40);
    if (*(unsigned char *)(v9 + 65)) {
      unint64_t v12 = *(void *)(v9 + 40);
    }
    else {
      unint64_t v12 = 0;
    }
  }
  unint64_t v13 = *(unsigned int *)(v9 + 36);
  if (v8 && (v11 >= 2 ? (BOOL v14 = v11 > v8) : (BOOL v14 = 0), v14 ? (v15 = v11 - 1 >= v8) : (v15 = 0), v15)
    || ((unint64_t v16 = 0x4000000000000000uLL >> __clz(__rbit64(v13)), v16 < v8) ? (v17 = v12 >= 2) : (v17 = 0),
        v17 ? (BOOL v18 = (v12 | v16) > v8) : (BOOL v18 = 0),
        v18 && ((v12 - 1) | v16) >= v8))
  {
    sub_100040DD0(*(void *)a5, v8, 1, *(void *)(a5 + 40), 0x40000000, v8, 0, 0x1Bu, 0, 5u);
    return 0;
  }
  else
  {
    sub_10004458C("invalid gbitmap block oid 0x%llx\n", v8, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
    uint64_t v19 = 92;
    sub_100048B34((char *)0x4DA, 92);
  }
  return v19;
}

uint64_t sub_1000250DC(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9)
{
  char v11 = a4;
  unsigned int v13 = *(_DWORD *)(a1[1] + 36);
  long long v108 = 0uLL;
  uint64_t v109 = 0;
  if (a3 == 0x80000000)
  {
    uint64_t v14 = sub_100030DD0(a1, a4, a6, a7, (uint64_t)&v108);
    if (v14)
    {
      uint64_t v15 = v14;
      sub_1000254D8(a7, a8);
      strerror(v15);
      sub_10004458C("(oid 0x%llx) %s: _xp_lookup_obj(0x%llx): %s\n", v16, v17, v18, v19, v20, v21, v22, v11);
      uint64_t v23 = 341;
LABEL_10:
      int v33 = v15;
LABEL_38:
      sub_100048B34((char *)v23, v33);
      return v15;
    }
LABEL_34:
    if (DWORD2(v108) && (unint64_t v82 = DWORD2(v108) / v13, !(DWORD2(v108) % v13)))
    {
      uint64_t v91 = a1[1];
      uint64_t v92 = a1[3];
      if (v92)
      {
        unint64_t v93 = *(void *)(v92 + 48);
        unint64_t v94 = *(void *)(v92 + 96);
      }
      else
      {
        unint64_t v93 = *(void *)(v91 + 40);
        if (*(unsigned char *)(v91 + 65)) {
          unint64_t v94 = *(void *)(v91 + 40);
        }
        else {
          unint64_t v94 = 0;
        }
      }
      unint64_t v95 = *(unsigned int *)(v91 + 36);
      if ((void)v108
        && (v93 > v82 ? (BOOL v96 = v93 > (unint64_t)v108) : (BOOL v96 = 0),
            v96 ? (BOOL v97 = v93 - v82 >= (unint64_t)v108) : (BOOL v97 = 0),
            v97)
        || ((unint64_t v98 = 0x4000000000000000uLL >> __clz(__rbit64(v95)), v98 < (unint64_t)v108)
          ? (BOOL v99 = v94 > v82)
          : (BOOL v99 = 0),
            v99 ? (BOOL v100 = (v94 | v98) > (unint64_t)v108) : (BOOL v100 = 0),
            v100 && ((v94 - v82) | v98) >= (unint64_t)v108))
      {
        uint64_t v15 = 0;
        *(_OWORD *)a9 = v108;
        *(void *)(a9 + --*(_DWORD *)(result + 16) = v109;
        return v15;
      }
      sub_1000254D8(a7, a8);
      sub_10004458C("(oid 0x%llx) %s: invalid object address (0x%llx)\n", v101, v102, v103, v104, v105, v106, v107, v11);
      uint64_t v15 = 92;
      uint64_t v23 = 346;
    }
    else
    {
      sub_1000254D8(a7, a8);
      sub_10004458C("(oid 0x%llx) %s: invalid object size (0x%x)\n", v83, v84, v85, v86, v87, v88, v89, v11);
      uint64_t v15 = 92;
      uint64_t v23 = 345;
    }
    int v33 = 92;
    goto LABEL_38;
  }
  if (a3 == 0x40000000)
  {
    *(void *)&long long v108 = a4;
    DWORD2(v108) = v13;
    goto LABEL_34;
  }
  uint64_t v25 = sub_1000209D8(a1, a2, a4, a5, &v108);
  if (!v25)
  {
    __int16 v34 = WORD6(v108);
    if (HIDWORD(v108) >= 0x800)
    {
      sub_1000254D8(a7, a8);
      sub_100044674("(oid 0x%llx) %s: invalid ov_flags (0x%x)\n", v35, v36, v37, v38, v39, v40, v41, v11);
      sub_100048B34((char *)0x1DF, -3);
      __int16 v34 = WORD6(v108);
    }
    if ((v34 & 4) == 0 && (v34 & 0xE0) != 0)
    {
      sub_1000254D8(a7, a8);
      sub_100044674("(oid 0x%llx) %s: invalid ov_flags (0x%x), crypto key index set for unencrypted object\n", v42, v43, v44, v45, v46, v47, v48, v11);
      sub_100048B34((char *)0x481, -3);
      __int16 v34 = WORD6(v108);
    }
    if ((v34 & 4) == 0 && (v34 & 0x700) != 0)
    {
      sub_1000254D8(a7, a8);
      sub_100044674("(oid 0x%llx) %s: invalid ov_flags (0x%x), tweak type set for unencrypted object\n", v49, v50, v51, v52, v53, v54, v55, v11);
      sub_100048B34((char *)0x4D0, -3);
    }
    if (!a2)
    {
      if ((BYTE12(v108) & 4) == 0) {
        goto LABEL_34;
      }
      sub_1000254D8(a7, a8);
      sub_100044674("(oid 0x%llx) %s: invalid encryption type ov_flags (0x%x)\n", v60, v61, v62, v63, v64, v65, v66, v11);
      uint64_t v67 = 480;
      goto LABEL_33;
    }
    uint64_t v56 = *(void *)(a2 + 40);
    uint64_t v57 = *(void *)(v56 + 264);
    if ((BYTE12(v108) & 4) != 0)
    {
      if ((v57 & 1) == 0 || *(void *)(v56 + 976)) {
        goto LABEL_30;
      }
      uint64_t v58 = 854;
      long long v59 = "(oid 0x%llx) %s: should not be encrypted (ov_flags 0x%x)\n";
    }
    else
    {
      if ((v57 & 1) != 0 || *(void *)(v56 + 976)) {
        goto LABEL_30;
      }
      uint64_t v58 = 855;
      long long v59 = "(oid 0x%llx) %s: should be encrypted (ov_flags 0x%x)\n";
    }
    sub_1000254D8(a7, a8);
    sub_100044674(v59, v68, v69, v70, v71, v72, v73, v74, v11);
    sub_100048B34((char *)v58, -3);
LABEL_30:
    if ((BYTE12(v108) & 4) == 0 || BYTE12(v108) >> 5 == (a8 == 36)) {
      goto LABEL_34;
    }
    sub_1000254D8(a7, a8);
    sub_100044674("(oid 0x%llx) %s: invalid crypto key index (%u) given obj_subtype\n", v75, v76, v77, v78, v79, v80, v81, v11);
    uint64_t v67 = 1201;
LABEL_33:
    sub_100048B34((char *)v67, -3);
    goto LABEL_34;
  }
  uint64_t v15 = v25;
  if (a7 != 29 || v25 != 2)
  {
    sub_1000254D8(a7, a8);
    strerror(v15);
    sub_10004458C("(oid 0x%llx) %s: _omap_lookup_obj(0x%llx, 0x%llx): %s\n", v26, v27, v28, v29, v30, v31, v32, v11);
    uint64_t v23 = 344;
    goto LABEL_10;
  }
  return v15;
}

const char *sub_1000254D8(int a1, int a2)
{
  uint64_t v2 = "nx";
  switch(a1)
  {
    case 1:
      return v2;
    case 2:
    case 3:
      long long v3 = "extent_list: ";
      switch(a2)
      {
        case 10:
          break;
        case 11:
          long long v3 = "om: ";
          break;
        case 12:
        case 13:
        case 17:
        case 18:
        case 20:
        case 22:
        case 23:
        case 24:
        case 25:
          goto LABEL_25;
        case 14:
          long long v3 = "apfs_root: ";
          break;
        case 15:
          long long v3 = "apfs_extentref: ";
          break;
        case 16:
          long long v3 = "apfs_snap_meta: ";
          break;
        case 19:
          long long v3 = "oms: ";
          break;
        case 21:
          long long v3 = "fusion_mid_tree: ";
          break;
        case 26:
          long long v3 = "gbitmap: ";
          break;
        default:
          if (a2 == 33)
          {
            long long v3 = "evict_mapping_tree: ";
          }
          else if (a2 == 36)
          {
            long long v3 = "apfs_sec_root: ";
          }
          else
          {
LABEL_25:
            long long v3 = "";
          }
          break;
      }
      uint64_t v4 = "btn";
      if (a1 == 2) {
        uint64_t v4 = "bt";
      }
      uint64_t v2 = byte_1000908D8;
      snprintf(byte_1000908D8, 0x28uLL, "%s%s", v3, v4);
      break;
    case 5:
      uint64_t v2 = "sm";
      break;
    case 6:
      uint64_t v2 = "cab";
      break;
    case 7:
      uint64_t v2 = "cib";
      break;
    case 8:
      uint64_t v2 = "sm_ip";
      break;
    case 11:
      uint64_t v2 = "om";
      break;
    case 12:
      uint64_t v2 = "cpm";
      break;
    case 13:
      uint64_t v2 = "apfs";
      break;
    case 15:
      uint64_t v2 = "extent";
      break;
    case 17:
      uint64_t v2 = "nr";
      break;
    case 18:
      uint64_t v2 = "nrl";
      break;
    case 20:
      uint64_t v2 = "efi_jumpstart";
      break;
    case 22:
      uint64_t v2 = "wbc";
      break;
    case 23:
      uint64_t v2 = "wbcl";
      break;
    case 24:
      uint64_t v2 = "er_state";
      break;
    case 25:
      uint64_t v2 = "gbitmap";
      break;
    case 27:
      uint64_t v2 = "gbitmap_blk";
      break;
    case 29:
      uint64_t v2 = "snap_meta_ext";
      break;
    default:
      uint64_t v2 = "?";
      break;
  }
  return v2;
}

uint64_t sub_1000257B4(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t **a9, uint64_t a10, char a11)
{
  if (a9) {
    return sub_1000257F8(a1, a2, a3, a4, a5, a6, a7, a8, 0, a9, a10, a11);
  }
  else {
    return 22;
  }
}

uint64_t sub_1000257F8(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t a9, uint64_t **a10, uint64_t a11, char a12)
{
  unsigned int v12 = a7;
  unint64_t v15 = a4;
  int v16 = a3;
  unsigned int v17 = *(_DWORD *)(a1[1] + 36);
  long long v383 = 0uLL;
  unint64_t v384 = 0;
  if (a9 && a10)
  {
    uint64_t v371 = a5;
    long long v383 = *(_OWORD *)(a9 + 144);
    uint64_t v18 = *(uint64_t **)(a9 + 168);
    unint64_t v384 = *(void *)(a9 + 160);
  }
  else
  {
    unint64_t v24 = a1;
    uint64_t v25 = sub_1000250DC(a1, a2, a3, a4, a5, a6, a7, a8, (uint64_t)&v383);
    if (v25) {
      return v25;
    }
    uint64_t v371 = a5;
    uint64_t v18 = (uint64_t *)malloc_type_malloc(DWORD2(v383), 0xA18FBEC4uLL);
    a1 = v24;
    if (!v18)
    {
      sub_1000254D8(v12, a8);
      sub_10004458C("(oid 0x%llx) %s: malloc(%u)\n", v26, v27, v28, v29, v30, v31, v32, v15);
      uint64_t v25 = 12;
      sub_100048B34((char *)0x15B, 12);
      return v25;
    }
  }
  v379 = a1;
  unint64_t v19 = v384;
  uint64_t v20 = *a1;
  if ((BYTE12(v383) & 4) == 0)
  {
    unsigned int v21 = HIDWORD(v383);
    unint64_t v22 = 0;
    int v23 = 0;
    goto LABEL_25;
  }
  if ((WORD6(v383) & 0x700) == 0x100) {
    unint64_t v22 = v15 ^ HIDWORD(v384) | v15 & 0xFFFFFFFF00000000 ^ (v384 << 32);
  }
  else {
    unint64_t v22 = 0;
  }
  if ((WORD6(v383) & 0x700) == 0x100) {
    int v23 = 4;
  }
  else {
    int v23 = 0;
  }
  if (!a2)
  {
    unsigned int v21 = HIDWORD(v383);
LABEL_25:
    uint64_t v34 = 0;
    if (a9) {
      goto LABEL_26;
    }
LABEL_22:
    uint64_t v372 = DWORD2(v383);
    uint64_t v377 = v383;
    uint64_t v35 = sub_10002F238(v20, v383, DWORD2(v383) / v17, (uint64_t)v18, v34, 0, 0, v22, v23);
    if (v35)
    {
      uint64_t v25 = v35;
LABEL_31:
      sub_1000254D8(v12, a8);
      strerror(v25);
      sub_10004458C("(oid 0x%llx) %s: %s(%llu, %u): %s\n", v40, v41, v42, v43, v44, v45, v46, v15);
      sub_100048B34((char *)0x15C, v25);
LABEL_32:
      if (!v25 || !v18) {
        goto LABEL_232;
      }
      free(v18);
      return v25;
    }
    if (a10) {
      goto LABEL_37;
    }
LABEL_41:
    uint64_t v25 = 0;
    *(_OWORD *)(a9 + 144) = v383;
    *(void *)(a9 + 160) = v384;
    *(void *)(a9 + 168) = v18;
    return v25;
  }
  unsigned int v21 = HIDWORD(v383);
  uint64_t v33 = *(void *)(a2 + 8 * (BYTE12(v383) >> 5) + 24);
  if (v33) {
    uint64_t v34 = a2 + 96 * (BYTE12(v383) >> 5) + 768;
  }
  else {
    uint64_t v34 = 0;
  }
  if (v33) {
    uint64_t v20 = *(void *)(a2 + 8 * (BYTE12(v383) >> 5) + 24);
  }
  if (!a9) {
    goto LABEL_22;
  }
LABEL_26:
  if (!a10)
  {
    uint64_t v39 = sub_10002F238(v20, v383, DWORD2(v383) / v17, (uint64_t)v18, v34, 1, a9, v22, v23);
    if (v39)
    {
      uint64_t v25 = v39;
      goto LABEL_31;
    }
    goto LABEL_41;
  }
  uint64_t v38 = sub_10002F2B8(v20);
  uint64_t v377 = v383;
  if (v38)
  {
    uint64_t v25 = v38;
    goto LABEL_31;
  }
  uint64_t v372 = DWORD2(v383);
LABEL_37:
  if (a2)
  {
    uint64_t v47 = *(void *)(a2 + 40);
    BOOL v48 = (*(unsigned char *)(v47 + 264) & 1) == 0;
    BOOL v49 = *(void *)(v47 + 976) == 0;
    if (*(void *)(v47 + 976)) {
      BOOL v48 = 1;
    }
    LODWORD(v369) = *(void *)(v47 + 1096) != 0;
    HIDWORD(v369) = v48;
  }
  else
  {
    uint64_t v369 = 0;
    BOOL v49 = 1;
  }
  unsigned int v50 = v21;
  uint64_t v51 = v372;
  int v375 = v16;
  if ((a6 & 0x20000000) != 0) {
    goto LABEL_218;
  }
  BOOL v357 = v49;
  int v363 = 0;
  int v376 = 0;
  int v360 = 0;
  int v374 = 0;
  int v366 = (v50 & 4) != 0;
  int v378 = v50 >> 5;
  unint64_t v52 = v19;
  int v53 = a6 | ((v50 & 4) << 26);
  uint64_t v54 = (uint32x4_t *)(v18 + 1);
  int v55 = a8;
  unint64_t v368 = (v372 - 8);
  uint64_t v367 = (8 * v372);
  unint64_t v56 = v372 - 8;
  unint64_t v373 = v52;
  uint64_t v361 = 8 * v372;
  unint64_t v362 = v15 ^ HIDWORD(v52) | v15 & 0xFFFFFFFF00000000 ^ (v52 << 32);
  unint64_t v365 = v56;
LABEL_45:
  int v364 = v53;
  while (1)
  {
    unint64_t v382 = sub_10003D848(v18, v54, v368, 0, v36, v37);
    if (v382)
    {
      sub_1000254D8(v12, v55);
      sub_100044674("(oid 0x%llx) %s: invalid o_cksum (0x%llx)\n", v57, v58, v59, v60, v61, v62, v63, v15);
      sub_100048B34((char *)0x15E, 92);
    }
    if (sub_10000A0DC((uint64_t)v18, 0, v367))
    {
      sub_1000254D8(v12, v55);
      sub_10004458C("(oid 0x%llx) %s: found zeroed-out block\n", v233, v234, v235, v236, v237, v238, v239, v15);
      uint64_t v25 = 92;
      uint64_t v240 = 845;
      int v241 = 92;
LABEL_217:
      sub_100048B34((char *)v240, v241);
      goto LABEL_227;
    }
    uint64_t v66 = v54->i64[0];
    if (v54->i64[0] == v15)
    {
      unsigned int v67 = 0;
      int v68 = v376;
    }
    else
    {
      int v69 = v376;
      if (!v382)
      {
        sub_1000254D8(v12, v55);
        sub_10004458C("(oid 0x%llx) %s: invalid o_oid (0x%llx)\n", v70, v71, v72, v73, v74, v75, v76, v15);
        sub_100048B34((char *)0x15F, 92);
        int v69 = v376;
        uint64_t v66 = v54->i64[0];
      }
      *(int8x8_t *)v64.i8 = vcnt_s8((int8x8_t)(v66 ^ v15));
      v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
      int v68 = v69 + v64.i32[0];
      unsigned int v67 = 92;
    }
    unint64_t v77 = v18[2];
    if (v77)
    {
      unint64_t v78 = *(void *)(v379[1] + 16);
      if (v77 <= v78) {
        uint64_t v25 = v67;
      }
      else {
        uint64_t v25 = 92;
      }
      if (!v382 && v77 > v78)
      {
LABEL_63:
        uint64_t v79 = v51;
        int v80 = v68;
        sub_1000254D8(v12, v55);
        sub_10004458C("(oid 0x%llx) %s: invalid o_xid (0x%llx)\n", v81, v82, v83, v84, v85, v86, v87, v15);
        uint64_t v25 = 92;
        sub_100048B34((char *)0x160, 92);
        int v68 = v80;
        uint64_t v51 = v79;
        uint64_t v54 = (uint32x4_t *)(v18 + 1);
      }
    }
    else
    {
      if (!v382) {
        goto LABEL_63;
      }
      uint64_t v25 = 92;
    }
    if (v373)
    {
      uint64_t v88 = v18[2];
      if (v88 != v373)
      {
        if (!v382)
        {
          uint64_t v89 = v51;
          int v90 = v68;
          sub_1000254D8(v12, v55);
          sub_10004458C("(oid 0x%llx) %s: invalid o_xid (0x%llx, expected 0x%llx)\n", v91, v92, v93, v94, v95, v96, v97, v15);
          sub_100048B34((char *)0x371, 92);
          int v68 = v90;
          uint64_t v51 = v89;
          uint64_t v54 = (uint32x4_t *)(v18 + 1);
          uint64_t v88 = v18[2];
        }
        *(int8x8_t *)v64.i8 = vcnt_s8((int8x8_t)(v88 ^ v373));
        v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
        v68 += v64.i32[0];
        uint64_t v25 = 92;
      }
    }
    if (v12)
    {
      int v98 = *((unsigned __int16 *)v18 + 12);
      if (v98 != v12)
      {
        if (!v382)
        {
          uint64_t v99 = v51;
          int v100 = v68;
          sub_1000254D8(v12, v55);
          sub_10004458C("(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n", v101, v102, v103, v104, v105, v106, v107, v15);
          sub_100048B34((char *)0x161, 92);
          int v68 = v100;
          uint64_t v51 = v99;
          uint64_t v54 = (uint32x4_t *)(v18 + 1);
          int v98 = *((unsigned __int16 *)v18 + 12);
        }
        v64.i32[0] = v98 ^ v12;
        *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
        v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
        v68 += v64.i32[0];
        uint64_t v25 = 92;
      }
    }
    if (v55)
    {
      int v108 = *((_DWORD *)v18 + 7);
      if (v108 != v55)
      {
        if (v382)
        {
          v64.i32[0] = (unsigned __int16)*((_DWORD *)v18 + 7) ^ v55;
          *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
          v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
          v68 += v64.i32[0];
          int v109 = *((_DWORD *)v18 + 6);
          if ((v109 & 0xC0000000) == v375) {
            goto LABEL_90;
          }
          goto LABEL_89;
        }
        uint64_t v372 = v51;
        int v110 = v68;
        if (v55 != 33 || v108)
        {
          sub_1000254D8(v12, v55);
          sub_10004458C("(oid 0x%llx) %s: invalid o_subtype (0x%x, expected 0x%x)\n", v124, v125, v126, v127, v128, v129, v130, v15);
          uint64_t v25 = 92;
          sub_100048B34((char *)0x164, 92);
          v64.i32[0] = *((unsigned __int16 *)v18 + 14) ^ v55;
          *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
          v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
          int v68 = v64.i32[0] + v110;
        }
        else
        {
          sub_1000254D8(v12, 33);
          sub_100044674("(oid 0x%llx) %s: using old subtype (0x%x, expected 0x%x)\n", v111, v112, v113, v114, v115, v116, v117, v15);
          if (!v25) {
            v363 |= sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) subtype? ", v118, v119, v120, v121, v122, v123, v15) != 0;
          }
          int v68 = v110;
        }
        uint64_t v51 = v372;
      }
    }
    int v109 = *((_DWORD *)v18 + 6);
    if ((v109 & 0xC0000000) == v375) {
      goto LABEL_91;
    }
    if (!v382)
    {
      uint64_t v131 = v51;
      int v132 = v68;
      sub_1000254D8(v12, v55);
      sub_10004458C("(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n", v133, v134, v135, v136, v137, v138, v139, v15);
      sub_100048B34((char *)0x162, 92);
      int v68 = v132;
      uint64_t v51 = v131;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
      int v109 = *((_DWORD *)v18 + 6);
    }
LABEL_89:
    v64.i32[0] = *((_DWORD *)v18 + 7) & 0xC0000000 ^ v375;
    *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
    v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
    v68 += v64.i32[0];
LABEL_90:
    uint64_t v25 = 92;
LABEL_91:
    int v140 = v109 & 0x3FFF0000;
    if (v140 != v53)
    {
      if (v382 && v25) {
        goto LABEL_96;
      }
      uint64_t v141 = v51;
      int v142 = v68;
      sub_1000254D8(v12, v55);
      sub_10004458C("(oid 0x%llx) %s: invalid o_type (0x%x, expected 0x%x)\n", v143, v144, v145, v146, v147, v148, v149, v15);
      sub_100048B34((char *)0x163, 92);
      if (v25)
      {
        int v140 = v18[3] & 0x3FFF0000;
        int v68 = v142;
        uint64_t v51 = v141;
        uint64_t v54 = (uint32x4_t *)(v18 + 1);
LABEL_96:
        v64.i32[0] = v140 ^ v53;
        *(int8x8_t *)v64.i8 = vcnt_s8(*(int8x8_t *)v64.i8);
        v64.i16[0] = vaddlv_u8(*(uint8x8_t *)v64.i8);
        v68 += v64.i32[0];
        goto LABEL_97;
      }
      int v211 = sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) flags? ", v150, v151, v152, v153, v154, v155, v15);
      if (v211) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = 92;
      }
      v363 |= v211 != 0;
      int v68 = v142;
      uint64_t v51 = v141;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
    }
LABEL_97:
    int v376 = v68;
    if (v55)
    {
      if (v12 && v68 == 1) {
        break;
      }
    }
    if (!v382)
    {
LABEL_168:
      if (v25) {
        goto LABEL_227;
      }
      goto LABEL_173;
    }
    if (v68)
    {
      uint64_t v175 = 1005;
      goto LABEL_109;
    }
    uint64_t v385 = 0;
    if (!v51)
    {
      uint64_t v175 = 1004;
      goto LABEL_109;
    }
    int v359 = v12;
    unsigned int v370 = v50;
    unint64_t v358 = v15;
    uint64_t v184 = 0;
    int v185 = 0;
    LODWORD(v186) = -1431655766;
    long long v187 = v54;
    do
    {
      uint64_t v188 = v184 >> 3;
      int v189 = 1 << (v184 & 7);
      *((unsigned char *)v18 + v188) ^= v189;
      uint64_t v190 = *v18;
      sub_10003D7D8((unint64_t *)&v385, v187, v56, 0, v64, v65);
      if (v190 == v385) {
        unint64_t v186 = v184;
      }
      else {
        unint64_t v186 = v186;
      }
      if (v190 == v385) {
        ++v185;
      }
      *((unsigned char *)v18 + v188) ^= v189;
      ++v184;
    }
    while (v361 != v184);
    unsigned int v12 = v359;
    if (!v185)
    {
      uint64_t v175 = 1004;
      unint64_t v15 = v358;
      int v55 = a8;
      unsigned int v50 = v370;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
      uint64_t v51 = v372;
      int v53 = v364;
      uint64_t v25 = v25;
      goto LABEL_109;
    }
    int v55 = a8;
    uint64_t v54 = (uint32x4_t *)(v18 + 1);
    uint64_t v25 = v25;
    if (v185 != 1)
    {
      sub_1000254D8(v359, a8);
      unint64_t v15 = v358;
      sub_10004458C("(oid 0x%llx) %s: could not repair object to match checksum: too many bit flip candidates (%d)\n", v212, v213, v214, v215, v216, v217, v218, v358);
      uint64_t v175 = 1003;
      unsigned int v50 = v370;
      uint64_t v51 = v372;
      int v53 = v364;
LABEL_109:
      sub_100048B34((char *)v175, 92);
      if (!v25) {
        goto LABEL_171;
      }
      goto LABEL_110;
    }
    sub_1000254D8(v359, a8);
    unint64_t v15 = v358;
    sub_10004458C("(oid 0x%llx) %s: found a bit flip at index 0x%x\n", v191, v192, v193, v194, v195, v196, v197, v358);
    uint64_t v25 = 92;
    sub_100048B34((char *)0x3EA, 92);
    uint64_t v51 = v372;
    if (sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) bit flip? ", v198, v199, v200, v201, v202, v203, v358))
    {
      LOBYTE(v363) = 1;
      *((unsigned char *)v18 + (v186 >> 3)) ^= 1 << (v186 & 7);
      unsigned int v50 = v370;
      goto LABEL_173;
    }
LABEL_103:
    unsigned int v50 = v370;
    int v53 = v364;
    if (!v382) {
      goto LABEL_168;
    }
    if (!v25) {
      goto LABEL_171;
    }
LABEL_110:
    BOOL v176 = v378;
    int v177 = v369;
    if (v378 == 1) {
      int v177 = 1;
    }
    if ((HIDWORD(v369) & ~v374 & v366) != 1 || !v177)
    {
      if ((v360 & 1) != 0 || ((HIDWORD(v369) | v366) & 1) == 0) {
        goto LABEL_227;
      }
      int v219 = v50 ^ 4;
      if (((v50 ^ 4) & 4) != 0)
      {
        BOOL v176 = a8 == 36;
        unsigned int v50 = v219 & 0xFFFFF81F | ((*(void *)(*(void *)(a2 + 40) + 1096) != 0) << 8) | (32 * v176);
      }
      else
      {
        unsigned int v50 = v219 & 0xFFFFFF1F;
      }
      uint64_t v220 = v379;
      uint64_t v221 = *v379;
      int v378 = v176;
      if ((v50 & 4) != 0)
      {
        int v223 = 4 * ((v50 & 0x700) == 256);
        uint64_t v224 = (v50 & 0x700) == 0x100 ? v362 : 0;
        if (a2)
        {
          if (*(void *)(a2 + 8 * (v50 >> 5) + 24))
          {
            uint64_t v221 = *(void *)(a2 + 8 * (v50 >> 5) + 24);
            uint64_t v222 = a2 + 96 * (v50 >> 5) + 768;
          }
          else
          {
            uint64_t v222 = 0;
          }
          uint64_t v220 = v379;
        }
        else
        {
          uint64_t v222 = 0;
        }
      }
      else
      {
        uint64_t v222 = 0;
        int v223 = 0;
        uint64_t v224 = 0;
      }
      if (sub_10002F238(v221, v377, v51 / *(_DWORD *)(v220[1] + 36), (uint64_t)v18, v222, 0, 0, v224, v223))goto LABEL_227; {
      v53 ^= 0x10000000u;
      }
      if (v366) {
        uint64_t v232 = "encrypted";
      }
      else {
        uint64_t v232 = "unencrypted";
      }
      sub_100044674("failed to validate %s object, retrying as %s\n", v225, v226, v227, v228, v229, v230, v231, (char)v232);
      int v360 = 1;
      v366 ^= 1u;
      uint64_t v54 = (uint32x4_t *)(v18 + 1);
      int v55 = a8;
      unint64_t v56 = v365;
      goto LABEL_45;
    }
    v378 ^= 1u;
    BOOL v178 = !v176;
    unint64_t v179 = v379;
    uint64_t v180 = *v379;
    if ((v50 & 4) != 0)
    {
      int v182 = 4 * ((v50 & 0x700) == 256);
      if ((v50 & 0x700) == 0x100) {
        uint64_t v183 = v362;
      }
      else {
        uint64_t v183 = 0;
      }
      if (a2)
      {
        if (*(void *)(a2 + 8 * (!v176 & 7) + 24))
        {
          uint64_t v180 = *(void *)(a2 + 8 * (!v176 & 7) + 24);
          uint64_t v181 = a2 + 96 * (!v176 & 7) + 768;
        }
        else
        {
          uint64_t v181 = 0;
        }
        unint64_t v179 = v379;
      }
      else
      {
        uint64_t v181 = 0;
      }
    }
    else
    {
      uint64_t v181 = 0;
      int v182 = 0;
      uint64_t v183 = 0;
    }
    if (sub_10002F238(v180, v377, v51 / *(_DWORD *)(v179[1] + 36), (uint64_t)v18, v181, 0, 0, v183, v182))goto LABEL_227; {
    unsigned int v50 = v50 & 0xFFFFFF1F | (32 * (v378 & 7));
    }
    sub_100044674("failed to validate object with crypto key index (%u), retrying with (%u)\n", v204, v205, v206, v207, v208, v209, v210, !v178);
    int v374 = 1;
    unint64_t v56 = v365;
  }
  unsigned int v370 = v50;
  sub_1000254D8(v12, v55);
  sub_10004458C("(oid 0x%llx) %s: found a bit flip in the header\n", v156, v157, v158, v159, v160, v161, v162, v15);
  sub_100048B34((char *)0x3E9, 92);
  if (!sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) header bit flip? ", v163, v164, v165, v166, v167, v168, v15))goto LABEL_103; {
  v54->i64[0] = v15;
  }
  if (!v373)
  {
    uint64_t v25 = 0;
    int v363 = 1;
    goto LABEL_103;
  }
  void v18[2] = v373;
  if (v382)
  {
LABEL_171:
    if (!sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) checksum? ", v169, v170, v171, v172, v173, v174, v15))
    {
      uint64_t v25 = 92;
      goto LABEL_227;
    }
  }
  LOBYTE(v363) = 1;
LABEL_173:
  if (a2)
  {
    int v16 = v375;
    BOOL v242 = (v375 | *(unsigned char *)(*(void *)(a2 + 40) + 264) & 1) == 0;
  }
  else
  {
    BOOL v242 = 0;
    int v16 = v375;
  }
  int v243 = v55;
  unint64_t v244 = v373;
  if (!v55) {
    int v243 = *((_DWORD *)v18 + 7);
  }
  int v245 = v243 == 36;
  if (((v360 | v374) & 1) == 0)
  {
    if (v357)
    {
      unsigned int v260 = v50;
      BOOL v259 = v378 != v245;
      if (v378 != v245)
      {
        sub_1000254D8(v12, a8);
        sub_100044674("(oid 0x%llx) %s: invalid crypto key index (%u), expected (%u)\n", v261, v262, v263, v264, v265, v266, v267, v15);
        uint64_t v25 = 92;
        sub_100048B34((char *)0x4B4, 92);
        if (!sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) crypto key index? ", v268, v269, v270, v271, v272, v273, v15))goto LABEL_227; {
        unsigned int v260 = (v50 & 0xFFFFFF1F | (32 * (v378 & 7))) ^ 0x20;
        }
        LOBYTE(v363) = 1;
        int v16 = v375;
        unint64_t v244 = v373;
      }
      if ((v366 & 1) == v242)
      {
        unsigned int v50 = v260;
      }
      else
      {
        sub_1000254D8(v12, a8);
        sub_100044674("(oid 0x%llx) %s: object is %s but should be %s\n", v274, v275, v276, v277, v278, v279, v280, v15);
        sub_100048B34((char *)0x374, -3);
        unsigned int v50 = v260;
        if (sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) encryption and omap flags? ", v281, v282, v283, v284, v285, v286, v15))
        {
          char v287 = v260 ^ 4;
          unsigned int v50 = (v260 ^ 4) & 0xFFFFFF1F;
          BOOL v259 = 1;
          LODWORD(v51) = v372;
          if ((v287 & 4) == 0) {
            goto LABEL_191;
          }
          goto LABEL_190;
        }
      }
      LODWORD(v51) = v372;
    }
    else
    {
      BOOL v259 = 0;
    }
    goto LABEL_205;
  }
  if (v374)
  {
    if (v378 == v245)
    {
      sub_1000254D8(v12, v55);
      sub_10004458C("(oid 0x%llx) %s: object is encrypted with crypto key index (%u)but omap says it's encrypted with crypto key index (%u)\n", v246, v247, v248, v249, v250, v251, v252, v15);
      uint64_t v25 = 92;
      sub_100048B34((char *)0x4B3, 92);
      if (!sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) omap flags? ", v253, v254, v255, v256, v257, v258, v15))goto LABEL_227; {
      BOOL v259 = 1;
      }
    }
    else
    {
      sub_1000254D8(v12, v55);
      sub_10004458C("(oid 0x%llx) %s: object is encrypted with crypto key index (%u) but should be encrypted with crypto key index (%u)\n", v289, v290, v291, v292, v293, v294, v295, v15);
      uint64_t v25 = 92;
      sub_100048B34((char *)0x4B2, 92);
      if (!sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) crypto key index? ", v296, v297, v298, v299, v300, v301, v15))goto LABEL_227; {
      BOOL v259 = 0;
      }
      unsigned int v50 = (v50 & 0xFFFFFF1F | (32 * (v378 & 7))) ^ 0x20;
      LOBYTE(v363) = 1;
      int v16 = v375;
      unint64_t v244 = v373;
    }
    LODWORD(v51) = v372;
  }
  else
  {
    BOOL v259 = 0;
  }
  if ((v360 & 1) == 0)
  {
LABEL_205:
    char v288 = v363;
    goto LABEL_206;
  }
  sub_1000254D8(v12, a8);
  if ((v366 & 1) != v242)
  {
    sub_10004458C("(oid 0x%llx) %s: object is %s but should be %s\n", v302, v303, v304, v305, v306, v307, v308, v15);
    uint64_t v25 = 92;
    sub_100048B34((char *)0x372, 92);
    if (!sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) encryption? ", v309, v310, v311, v312, v313, v314, v15))goto LABEL_227; {
    char v315 = v50 ^ 4;
    }
    unsigned int v50 = (v50 ^ 4) & 0xFFFFFF1F;
    int v16 = v375;
    if ((v315 & 4) == 0)
    {
LABEL_191:
      v364 ^= 0x10000000u;
      char v288 = 1;
      goto LABEL_206;
    }
LABEL_190:
    v50 |= 32 * (*(void *)(*(void *)(a2 + 40) + 1096) != 0);
    goto LABEL_191;
  }
  sub_10004458C("(oid 0x%llx) %s: object is %s but omap says it's %s\n", v302, v303, v304, v305, v306, v307, v308, v15);
  uint64_t v25 = 92;
  sub_100048B34((char *)0x373, 92);
  int v356 = sub_10004641C(qword_100091B70, "Fix object (oid 0x%llx) omap flags? ", v350, v351, v352, v353, v354, v355, v15);
  char v288 = v363;
  if (v356)
  {
    BOOL v259 = 1;
    int v16 = v375;
LABEL_206:
    unsigned int v316 = v12;
    if (!v12) {
      unsigned int v316 = *((unsigned __int16 *)v18 + 12);
    }
    unsigned int v317 = a8;
    if (!a8) {
      unsigned int v317 = *((_DWORD *)v18 + 7);
    }
    if (v288)
    {
      *((_DWORD *)v18 + 6) = v364 | v316 | v16;
      *((_DWORD *)v18 + 7) = v317;
      uint64_t v385 = v377;
      int v386 = v51;
      unsigned int v387 = v50;
      unint64_t v388 = v244;
      uint64_t v318 = sub_100026BA0(v379, a2, (uint64_t)v18, (uint64_t)&v385, v64, v65);
      if (v318)
      {
        uint64_t v25 = v318;
        char v319 = strerror(v318);
        sub_10004458C("error writing object: %s\n", v320, v321, v322, v323, v324, v325, v326, v319);
        uint64_t v240 = 880;
LABEL_216:
        int v241 = v25;
        goto LABEL_217;
      }
    }
    if (v259)
    {
      uint64_t v327 = v18[1];
      uint64_t v328 = v18[2];
      uint64_t v385 = v377;
      int v386 = v51;
      unsigned int v387 = v50;
      unint64_t v388 = v244;
      uint64_t v329 = sub_100020AB0((uint64_t)v379, a2, v327, v328, (int32x2_t *)&v385);
      if (v329)
      {
        uint64_t v25 = v329;
        char v330 = strerror(v329);
        sub_10004458C("error updating omap entry: %s\n", v331, v332, v333, v334, v335, v336, v337, v330);
        uint64_t v240 = 885;
        goto LABEL_216;
      }
    }
LABEL_218:
    uint64_t v25 = 0;
    if (v16 && a12)
    {
      if (v12 - 6 >= 3) {
        unsigned int v338 = 1;
      }
      else {
        unsigned int v338 = 9;
      }
      if (a2) {
        unint64_t v339 = *(void *)(*(void *)(a2 + 40) + 8);
      }
      else {
        unint64_t v339 = 0;
      }
      sub_100040DD0((uint64_t)v379, v383, (DWORD2(v383) / *(_DWORD *)(v379[1] + 36)), v339, v375, v15, v371, v12, a8, v338);
      uint64_t v25 = 0;
    }
  }
LABEL_227:
  if (v12 - 4 > 0xFFFFFFFD || v25 | v375) {
    goto LABEL_32;
  }
  int v340 = sub_10001F74C(a2 != 0, v15, 1);
  if (v340)
  {
    int v348 = v340;
    sub_100044674("object (oid 0x%llx): Unable to mark omap entry in use for omap space verification \n", v341, v342, v343, v344, v345, v346, v347, v15);
    sub_100048B34((char *)0x3D4, v348);
  }
  uint64_t v25 = 0;
LABEL_232:
  if (v18)
  {
    *a10 = v18;
    if (a11)
    {
      *(_OWORD *)a11 = v383;
      *(void *)(a11 + --*(_DWORD *)(result + 16) = v384;
    }
  }
  return v25;
}

uint64_t sub_100026B34(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t a9)
{
  if (a9) {
    return sub_1000257F8(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0, 0, 0);
  }
  else {
    return 22;
  }
}

uint64_t sub_100026B70(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, unsigned int a8, uint64_t a9, uint64_t **a10, uint64_t a11, char a12)
{
  if (a9) {
    BOOL v12 = a10 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    return 22;
  }
  else {
    return sub_1000257F8(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
  }
}

uint64_t sub_100026BA0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int8x16_t a5, int8x16_t a6)
{
  sub_10003D7D8((unint64_t *)a3, (uint32x4_t *)(a3 + 8), (*(_DWORD *)(a4 + 8) - 8), 0, a5, a6);
  int v10 = *(_DWORD *)(a4 + 12);
  uint64_t v11 = *a1;
  if ((v10 & 4) != 0)
  {
    if ((*(_DWORD *)(a4 + 12) & 0x700) == 0x100) {
      int v13 = 4;
    }
    else {
      int v13 = 0;
    }
    if ((*(_DWORD *)(a4 + 12) & 0x700) == 0x100) {
      unint64_t v14 = *(void *)(a3 + 8) ^ HIDWORD(*(void *)(a4 + 16)) | *(void *)(a3 + 8) & 0xFFFFFFFF00000000 ^ (*(void *)(a4 + 16) << 32);
    }
    else {
      unint64_t v14 = 0;
    }
    if (a2)
    {
      uint64_t v15 = v10 >> 5;
      uint64_t v16 = *(void *)(a2 + 8 * v15 + 24);
      uint64_t v17 = a2 + 96 * v15 + 768;
      if (v16)
      {
        uint64_t v11 = v16;
        uint64_t v12 = v17;
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 0;
    int v13 = 0;
    unint64_t v14 = 0;
  }
  uint64_t v18 = sub_10002F308(v11, *(void *)a4, (*(_DWORD *)(a4 + 8) / *(_DWORD *)(a1[1] + 36)), a3, v12, v14, v13);
  if (v18)
  {
    uint64_t v19 = *(void *)(a3 + 8);
    sub_1000254D8(*(_DWORD *)(a3 + 24), *(_DWORD *)(a3 + 28));
    strerror(v18);
    sub_10004458C("(oid 0x%llx) %s: dev_write(%llu, %u): %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
    sub_100048B34((char *)0x166, v18);
  }
  if (a2) {
    *(unsigned char *)(a2 + 12) = 1;
  }
  return v18;
}

uint64_t sub_100026D04(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  *(void *)&long long var8 = a2 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  return sub_100026D40(a1, &var8, &v9, 8, 17, a6, a7, a8);
}

uint64_t sub_100026D40(_DWORD *a1, long long *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, 1, a5, 0, a2, 8u, a3, a4);
  }
  return sub_100027AD0(0, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100026D94(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  *(void *)&long long var8 = a2 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  return sub_100026D40(a1, &var8, &v9, 8, 18, a6, a7, a8);
}

uint64_t sub_100026DD0(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&long long var8 = a2;
  char v9 = a3;
  if (a1) {
    return sub_100027E70(a1, 8u, 1, 0xFu, 0, &var8, 8u, &v9, 1u);
  }
  sub_100027AD0(0, a2, a3, a4, a5, a6, a7, a8);
  return 0;
}

void sub_100026E2C(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, BOOL *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  if (v10 != (void)xmmword_100090900)
  {
    sub_100044674("extended attribute (id %llu, name %.*s) is orphan\n", (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)a6, a7, a8, *(unsigned char *)a4);
    sub_100048B34((char *)0x3C1, -2);
    sub_1000272F4(a2, (long long *)a4, *(unsigned __int16 *)(a4 + 8) + 10, v33, v34, v35, v36, v37);
    goto LABEL_47;
  }
  unint64_t v14 = (const char *)(a4 + 10);
  size_t v15 = *(unsigned __int16 *)(a4 + 8);
  if (!strncmp((const char *)(a4 + 10), "com.apple.decmpfs", v15) && (dword_100090944 & 0x40000020) != 0)
  {
    LOBYTE(xmmword_100090930) = 1;
    unsigned int v38 = *(unsigned __int16 *)(a5 + 2);
    dword_100090940 = v38;
    if ((*(_WORD *)a5 & 2) != 0)
    {
      if (v38 > 0xF)
      {
        if (*(_DWORD *)(a5 + 4) == 1668116582)
        {
          int v55 = *(_DWORD *)(a5 + 8);
          BYTE8(xmmword_100090930) = sub_100027348(v55, v16, v17, v18, v19, v20, v21, v22);
          BYTE9(xmmword_100090930) = (v55 + 0x7FFFFFFF) < 2;
          HIDWORD(xmmword_100090930) = v55;
          goto LABEL_47;
        }
        sub_100044674("compression xattr (id %llu): compression magic is unknown: 0x%x\n", v16, v17, v18, v19, v20, v21, v22, v10);
        uint64_t v31 = 1220;
      }
      else
      {
        sub_100044674("compression xattr (id %llu): size is too small, actual: %u, minimum: %lu\n", v16, v17, v18, v19, v20, v21, v22, v10);
        uint64_t v31 = 1219;
      }
      int v39 = 92;
      goto LABEL_46;
    }
    if (!*(_WORD *)a5 || (*(_WORD *)a5 & 1) != 0) {
      goto LABEL_47;
    }
    sub_100044674("compression xattr (id %llu): internal flags are invalid (0x%x)\n", v16, v17, v18, v19, v20, v21, v22, v10);
    uint64_t v31 = 1221;
    goto LABEL_13;
  }
  if (strncmp(v14, "com.apple.ResourceFork", v15))
  {
    if (strncmp(v14, "com.apple.system.fs.speculative_telemetry", v15)) {
      goto LABEL_47;
    }
    uint64_t v23 = sub_1000104DC();
    if ((BYTE11(xmmword_100090910) & 0x20) != 0)
    {
      unint64_t v46 = v23;
      __int16 v47 = *(_WORD *)a5;
      if ((*(_WORD *)a5 & 4) == 0)
      {
        sub_100044674("speculative download xattr (id %llu): invalid flags: 0x%x\n", v24, v25, v26, v27, v28, v29, v30, v10);
        sub_100048B34((char *)0x5B6, -3);
        int v54 = sub_10004641C(qword_100091B70, "set missing flag? (0x%x) ", v48, v49, v50, v51, v52, v53, 4);
        __int16 v47 = *(_WORD *)a5;
        if (v54)
        {
          v47 |= 4u;
          *(_WORD *)a5 = v47;
          *a3 = 1;
        }
      }
      if (v47)
      {
        unint64_t v56 = *(void *)(a5 + 12);
        sub_100044674("speculative download xattr (id %llu): shouldn't be stream based\n", v24, v25, v26, v27, v28, v29, v30, v10);
        sub_100048B34((char *)0x5B7, -5);
        if (v56 > 0xB) {
          goto LABEL_47;
        }
        sub_100044674("speculative download xattr (id %llu): size is too small, actual: %u, minimum: %lu\n", v57, v58, v59, v60, v61, v62, v63, v10);
        uint64_t v31 = 1464;
      }
      else
      {
        if (*(unsigned __int16 *)(a5 + 2) > 0xBu)
        {
          char v64 = *(unsigned char *)(a5 + 4);
          if (v64)
          {
            sub_100044674("speculative download xattr (id %llu): unknown version: %u\n", v24, v25, v26, v27, v28, v29, v30, v10);
            uint64_t v31 = 1466;
            int v39 = -6;
          }
          else
          {
            unsigned int v65 = *(unsigned __int8 *)(a5 + 5);
            unsigned int v66 = *(unsigned __int16 *)(a5 + 6);
            unint64_t v67 = *(void *)(a5 + 8);
            unint64_t v74 = v67;
            if (v65 >= 6)
            {
              sub_100044674("speculative download xattr (id %llu): unknown purge reason: %u\n", v24, v25, v26, v27, v28, v29, v30, v10);
              sub_100048B34((char *)0x5BB, -3);
              unint64_t v67 = v74;
            }
            if (v66 >= 0x40)
            {
              sub_100044674("speculative download xattr (id %llu): unknown flags: %x\n", v24, v25, v26, v27, v28, v29, v30, v10);
              sub_100048B34((char *)0x5BC, -3);
              BOOL v73 = sub_1000105B0(a1, v66, 63, v68, v69, v70, v71, v72);
              unint64_t v67 = v74;
              if (v73)
              {
                *a3 = 1;
                *(unsigned char *)a5 = v64;
                *(unsigned char *)(a5 + 1) = v65;
                *(_WORD *)(a5 + 2) = v66 & 0x3F;
                *(void *)(a5 + 4) = v74;
              }
            }
            if (v67 <= v46) {
              goto LABEL_47;
            }
            sub_100044674("speculative download xattr (id %llu): pristine time (%llu) is greater than current time (%llu)\n", v24, v25, v26, v27, v28, v29, v30, v10);
            uint64_t v31 = 1469;
            int v39 = -4;
          }
          goto LABEL_46;
        }
        sub_100044674("speculative download xattr (id %llu): size is too small, actual: %u, minimum: %lu\n", v24, v25, v26, v27, v28, v29, v30, v10);
        uint64_t v31 = 1465;
      }
      int v39 = -11;
LABEL_46:
      sub_100048B34((char *)v31, v39);
LABEL_47:
      if (a6) {
        *a6 = v10 != (void)xmmword_100090900;
      }
      return;
    }
    sub_100044674("speculative download xattr (id %llu): found outside of an SAF dir stats hierarchy\n", v24, v25, v26, v27, v28, v29, v30, v10);
    uint64_t v31 = 1461;
LABEL_13:
    int v39 = -3;
    goto LABEL_46;
  }
  if ((*(_WORD *)a5 & 2) != 0)
  {
    uint64_t v40 = *(unsigned __int16 *)(a5 + 2);
LABEL_27:
    if (v40) {
      int v45 = 2;
    }
    else {
      int v45 = 1;
    }
    DWORD1(xmmword_100090930) = v45;
    goto LABEL_47;
  }
  uint64_t v40 = *(void *)(a5 + 12);
  uint64_t v41 = *(void *)(a5 + 20);
  *((void *)&xmmword_100090920 + 1) = v41;
  if (!*((void *)&xmmword_100090900 + 1)
    || (sub_1000193D4(*((uint64_t *)&xmmword_100090900 + 1), v41), !v42)
    && ((word_10009094C & 0xF000) != 0x8000
     || (BYTE8(xmmword_100090910) & 2) == 0
     || (DWORD2(xmmword_100090910) & 0x180000) != 0x80000
     || dword_100090948 != 1
     || (dword_100090944 & 0x40000020) != 0x20
     || (sub_100019874(*((uint64_t *)&xmmword_100090900 + 1), v41), !v43)))
  {
    if (!(void)xmmword_100090910) {
      goto LABEL_27;
    }
    sub_10000820C(xmmword_100090910, v41);
    if (!v44) {
      goto LABEL_27;
    }
  }
}

uint64_t sub_1000272F4(_DWORD *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, 0, 0, 0, a2, a3, 0, 0);
  }
  return sub_100027AD0(0, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
}

BOOL sub_100027348(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 2 && (a1 - 1) <= 0xD) {
    return (a1 & 1) == 0;
  }
  if ((a1 + 0x7FFFFFFF) >= 2)
  {
    sub_100044674("inode (id %llu): unknown compression type: %u\n", a2, a3, a4, a5, a6, a7, a8, xmmword_100090900);
    sub_100048B34((char *)0x4C2, 92);
  }
  return 0;
}

uint64_t sub_1000273C8(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = xmmword_100090900;
  if (!(void)xmmword_100090900) {
    return 0;
  }
  int v12 = dword_100090944;
  if ((dword_100090944 & 0x20) == 0) {
    goto LABEL_3;
  }
  if (!(_BYTE)xmmword_100090930)
  {
    if (qword_100090958 == (void)xmmword_100090900)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = sub_10003E760(a1, a2, qword_100090950, xmmword_100090900, &byte_100090960);
      qword_100090958 = v8;
    }
    if (v13 || byte_100090960) {
      return v13;
    }
    sub_100044674("inode (id %llu): has the compression bsdflag, but doesn't have the compression xattr\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
    sub_100048B34((char *)0x4C8, -3);
  }
  if (BYTE8(xmmword_100090930)) {
    BOOL v21 = DWORD1(xmmword_100090930) == 2;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    uint64_t v25 = xmmword_100090900;
    if (qword_100090958 == (void)xmmword_100090900)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = sub_10003E760(a1, a2, qword_100090950, xmmword_100090900, &byte_100090960);
      qword_100090958 = v25;
    }
    if (v13 || byte_100090960) {
      return v13;
    }
    sub_100044674("inode (id %llu): Resource Fork xattr is missing or empty for compressed file\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
    sub_100048B34((char *)0x4C6, 92);
    *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
    LODWORD(v58) = 32;
    uint64_t v13 = sub_100026D40(a3, v59, &v58, 4, 20, v26, v27, v28);
    if (!v13 && dword_100090940 == 16)
    {
      *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x4000000000000000;
      WORD4(v59[0]) = 18;
      strcpy((char *)v59 + 10, "com.apple.decmpfs");
      uint64_t v13 = sub_1000272F4(a3, v59, 28, a4, a5, a6, a7, a8);
    }
    if (v13)
    {
LABEL_44:
      sub_10004458C("inode (id %llu): failed to enqueue to the repairs\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
      sub_100048B34((char *)0x4D2, v13);
      goto LABEL_45;
    }
  }
  int v12 = dword_100090944;
  if ((dword_100090944 & 0x40000000) == 0 && BYTE9(xmmword_100090930))
  {
    sub_100044674("inode (id %llu): compression type is dataless, but the dataless bsd_flag is not set\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
    sub_100048B34((char *)0x4FD, -3);
    *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
    LODWORD(v58) = 0x40000000;
    uint64_t v13 = sub_100026D40(a3, v59, &v58, 4, 19, v22, v23, v24);
    if (v13) {
      goto LABEL_44;
    }
    int v12 = dword_100090944;
  }
LABEL_3:
  if ((v12 & 0x40000000) == 0)
  {
    if ((BYTE8(xmmword_100090910) & 0x10) == 0) {
      goto LABEL_5;
    }
LABEL_4:
    uint64_t v13 = 0;
    int v19 = DWORD1(xmmword_100090930);
    if ((dword_100090944 & 0x20) == 0 || DWORD1(xmmword_100090930) != 2)
    {
LABEL_46:
      if (v19)
      {
        if (v19 == 1)
        {
LABEL_58:
          xmmword_100090930 = 0u;
          *(_OWORD *)&dword_100090940 = 0u;
          xmmword_100090910 = 0u;
          xmmword_100090920 = 0u;
          xmmword_100090900 = 0u;
          *(void *)((char *)&xmmword_100090930 + 12) = -1;
          return v13;
        }
        uint64_t v29 = WORD4(xmmword_100090910) & 0x8000;
        uint64_t v30 = ~DWORD2(xmmword_100090910) & 0x4000;
        if (v13) {
          goto LABEL_54;
        }
      }
      else
      {
        uint64_t v30 = ~DWORD2(xmmword_100090910) & 0x8000;
        uint64_t v29 = WORD4(xmmword_100090910) & 0x4000;
        if (v13) {
          goto LABEL_54;
        }
      }
      if (v30)
      {
        sub_100044674("inode (id %llu): need to set internal_flags 0x%llx\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
        sub_100048B34((char *)0x5A9, 92);
        uint64_t v58 = v30;
        *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
        uint64_t v34 = sub_100026D40(a3, v59, &v58, 8, 17, v31, v32, v33);
        uint64_t v13 = v34;
        if (v34)
        {
          char v35 = xmmword_100090900;
          strerror(v34);
          sub_10004458C("inode (id %llu): can't add internal flags repair: %d (%s)\n", v36, v37, v38, v39, v40, v41, v42, v35);
          sub_100048B34((char *)0x5AA, v13);
          goto LABEL_58;
        }
      }
LABEL_54:
      if (v29)
      {
        if (!v13)
        {
          sub_100044674("inode (id %llu): need to clear internal_flags 0x%llx\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
          sub_100048B34((char *)0x5AB, 92);
          uint64_t v58 = v29;
          *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
          uint64_t v46 = sub_100026D40(a3, v59, &v58, 8, 18, v43, v44, v45);
          uint64_t v13 = v46;
          if (v46)
          {
            char v47 = xmmword_100090900;
            strerror(v46);
            sub_10004458C("inode (id %llu): can't add internal flags repair: %d (%s)\n", v48, v49, v50, v51, v52, v53, v54, v47);
            sub_100048B34((char *)0x5AC, v13);
          }
        }
      }
      goto LABEL_58;
    }
    if (sub_100027348(SHIDWORD(xmmword_100090930), a2, (uint64_t)a3, a4, a5, a6, a7, a8)) {
      uint64_t v13 = sub_100003940(xmmword_100090920, xmmword_100090900, *((uint64_t *)&xmmword_100090920 + 1));
    }
    else {
LABEL_5:
    }
      uint64_t v13 = 0;
LABEL_45:
    int v19 = DWORD1(xmmword_100090930);
    goto LABEL_46;
  }
  if ((v12 & 0x20) == 0)
  {
    sub_100044674("inode (id %llu): dataless bsd_flag is set, but compression bsd_flag is not\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
    sub_100048B34((char *)0x4D3, -3);
    if ((_BYTE)xmmword_100090930 && BYTE9(xmmword_100090930))
    {
      *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
      LODWORD(v58) = 32;
      uint64_t v17 = a3;
      uint64_t v18 = 19;
    }
    else
    {
      *(void *)&v59[0] = xmmword_100090900 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
      LODWORD(v58) = 0x40000000;
      uint64_t v17 = a3;
      uint64_t v18 = 20;
    }
    uint64_t v13 = sub_100026D40(v17, v59, &v58, 4, v18, v14, v15, v16);
    if (v13)
    {
      sub_10004458C("inode (id %llu): failed to enqueue to the repairs\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
      sub_100048B34((char *)0x4D4, v13);
      return v13;
    }
    goto LABEL_4;
  }
  if ((_BYTE)xmmword_100090930)
  {
    if (BYTE9(xmmword_100090930)) {
      goto LABEL_4;
    }
    uint64_t v20 = xmmword_100090900;
    if (qword_100090958 == (void)xmmword_100090900)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = sub_10003E760(a1, a2, qword_100090950, xmmword_100090900, &byte_100090960);
      qword_100090958 = v20;
    }
    if (!v13 && !byte_100090960)
    {
      sub_100044674("inode (id %llu): dataless bsd_flag is set, but the compression type is different: 0x%x\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
      uint64_t v57 = 1226;
      goto LABEL_73;
    }
  }
  else
  {
    uint64_t v56 = xmmword_100090900;
    if (qword_100090958 == (void)xmmword_100090900)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = sub_10003E760(a1, a2, qword_100090950, xmmword_100090900, &byte_100090960);
      qword_100090958 = v56;
    }
    if (!v13 && !byte_100090960)
    {
      sub_100044674("inode (id %llu): dataless bsd_flag is set, but the compression xattr is missing\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, xmmword_100090900);
      uint64_t v57 = 1237;
LABEL_73:
      sub_100048B34((char *)v57, -3);
      goto LABEL_4;
    }
  }
  return v13;
}

uint64_t sub_100027A34(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = sub_1000273C8(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!result)
  {
    *(void *)&xmmword_100090900 = a4;
    *((void *)&xmmword_100090900 + 1) = a6;
    dword_100090944 = *(_DWORD *)(a5 + 68);
    uint64_t v13 = *(void *)(a5 + 48);
    *(void *)&xmmword_100090910 = a7;
    *((void *)&xmmword_100090910 + 1) = v13;
    *(void *)&xmmword_100090920 = *(void *)(a5 + 8);
    dword_100090948 = *(_DWORD *)(a5 + 56);
    word_10009094C = *(_WORD *)(a5 + 80);
  }
  return result;
}

double sub_100027AA4(uint64_t a1)
{
  qword_100090950 = a1;
  xmmword_100090930 = 0u;
  *(_OWORD *)&dword_100090940 = 0u;
  xmmword_100090900 = 0u;
  xmmword_100090910 = 0u;
  xmmword_100090920 = 0u;
  double result = NAN;
  *(void *)((char *)&xmmword_100090930 + 12) = -1;
  return result;
}

uint64_t sub_100027AD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_100090964 & 1) == 0)
  {
    sub_100044674("snapshot fsroot / file key rolling / doc-id tree corruptions are not repaired; they'll go away once the snapshot is deleted\n",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      v9);
    byte_100090964 = 1;
  }
  return 0;
}

uint64_t sub_100027B10(uint64_t a1, uint64_t a2)
{
  uint64_t result = sub_100038040(a1, 0, a2, 0x8000000, 2, 0, 0, 4096, 0, 0, 0, 0, (uint64_t)sub_100027BA0);
  if (!result)
  {
    return sub_10003A18C(a1, 0, 0x42u);
  }
  return result;
}

uint64_t sub_100027BA0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 >= 2 && a5 >= 2)
  {
    int v13 = sub_100028A60((unsigned __int16 *)a2, a3, (unsigned __int16 *)a4, a5);
    *a6 = v13;
    if (v13) {
      return 0;
    }
    switch(*(_WORD *)a2 & 0xF)
    {
      case 0:
      case 1:
      case 2:
        uint64_t result = 22;
        if (a3 == 18 && a5 == 18)
        {
          long long v34 = *(_OWORD *)(a2 + 2);
          long long v33 = *(_OWORD *)(a4 + 2);
          return sub_100003E9C(a1, &v34, 16, &v33, 16, a6);
        }
        return result;
      case 3:
        uint64_t result = 22;
        if (a3 == 18 && a5 == 18)
        {
          long long v25 = *(_OWORD *)(a2 + 2);
          long long v31 = *(_OWORD *)(a4 + 2);
          long long v32 = v25;
          return sub_10002097C(a1, &v32, 16, &v31, 16, a6);
        }
        return result;
      case 4:
        uint64_t result = 22;
        if (a3 != 10 || a5 != 10) {
          return result;
        }
        uint64_t v26 = *(void *)(a2 + 2);
        uint64_t v29 = *(void *)(a4 + 2);
        uint64_t v30 = v26;
        uint64_t v23 = &v30;
        uint64_t v24 = &v29;
        return sub_1000306FC(a1, v23, 8, v24, 8, a6);
      case 5:
      case 7:
      case 8:
        uint64_t result = 22;
        if (a3 < 0xD || a5 < 0xD) {
          return result;
        }
        uint64_t v14 = (unint64_t *)(a2 + 5);
        unsigned int v15 = a3 - 5;
        uint64_t v16 = (unint64_t *)(a4 + 5);
        unsigned int v17 = a5 - 5;
        uint64_t v18 = a1;
        goto LABEL_13;
      case 6:
        uint64_t result = 22;
        if (a3 != 18 || a5 != 18) {
          return result;
        }
        unint64_t v19 = *(void *)(a2 + 2);
        unint64_t v20 = *(void *)(a4 + 2);
        if (v19 < v20)
        {
          uint64_t result = 0;
          int v21 = -1;
LABEL_38:
          *a6 = v21;
          return result;
        }
        if (v19 > v20)
        {
          uint64_t result = 0;
          int v21 = 1;
          goto LABEL_38;
        }
        uint64_t v14 = (unint64_t *)(a2 + 10);
        uint64_t v16 = (unint64_t *)(a4 + 10);
        uint64_t v18 = a1;
        unsigned int v15 = 8;
        unsigned int v17 = 8;
LABEL_13:
        uint64_t result = sub_10003DD34(v18, v14, v15, v16, v17, a6);
        break;
      case 9:
        uint64_t result = 22;
        if (a3 != 10 || a5 != 10) {
          return result;
        }
        uint64_t v22 = *(void *)(a2 + 2);
        uint64_t v27 = *(void *)(a4 + 2);
        uint64_t v28 = v22;
        uint64_t v23 = &v28;
        uint64_t v24 = &v27;
        return sub_1000306FC(a1, v23, 8, v24, 8, a6);
      case 0xA:
        uint64_t result = 22;
        if (a3 == 6 && a5 == 6)
        {
          return sub_1000306C8(a1, (_DWORD *)(a2 + 2), 4, (_DWORD *)(a4 + 2), 4, a6);
        }
        return result;
      default:
        return 0;
    }
  }
  return result;
}

uint64_t sub_100027E70(_DWORD *a1, unsigned int a2, int a3, unsigned int a4, char a5, long long *a6, unsigned int a7, unsigned char *a8, unsigned int a9)
{
  if (a5)
  {
    __int16 v13 = 2048;
  }
  else
  {
    __int16 v13 = 0;
    uint64_t result = 0;
    int v15 = dword_100090968++;
    if (v15 > 999998) {
      return result;
    }
  }
  uint64_t v16 = a9;
  if (!a3 && (a2 > 7 || ((1 << a2) & 0xB8) == 0))
  {
    a8 = 0;
    uint64_t v16 = 0;
  }
  __int16 v17 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
  switch(a2)
  {
    case 0u:
    case 1u:
    case 2u:
      uint64_t result = 22;
      if (a7 == 16 && 8 * (a3 != 0) == v16)
      {
        __int16 v37 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
        long long v38 = *a6;
        uint64_t v18 = &v37;
        goto LABEL_26;
      }
      return result;
    case 3u:
      uint64_t result = 22;
      if (a7 == 16 && v16 == 16)
      {
        __int16 v35 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
        long long v36 = *a6;
        uint64_t v18 = &v35;
        unint64_t v20 = a1;
        uint64_t v21 = 18;
        goto LABEL_23;
      }
      return result;
    case 4u:
      uint64_t result = 22;
      if (a7 == 8 && v16 == 16)
      {
        __int16 v33 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
        uint64_t v34 = *(void *)a6;
        uint64_t v18 = &v33;
        unint64_t v20 = a1;
        uint64_t v21 = 10;
LABEL_23:
        uint64_t v22 = a8;
        uint64_t v23 = 16;
        return sub_100039A6C(v20, 0, v18, v21, v22, v23);
      }
      return result;
    case 5u:
    case 7u:
    case 8u:
      if (a7 - 833 < 0xFFFFFCC7) {
        return 22;
      }
      if (a3 == 1)
      {
        char v19 = 0;
        if (a4 <= 0xF && ((1 << a4) & 0x8140) != 0)
        {
          if (!v16) {
            return 22;
          }
          char v19 = *a8;
        }
      }
      else
      {
        char v19 = 0;
      }
      uint64_t v24 = (char *)malloc_type_malloc(a7 + 5, 0x64F090CBuLL);
      if (!v24) {
        return 12;
      }
      long long v25 = v24;
      *(_WORD *)uint64_t v24 = v17;
      *((_WORD *)v24 + 1) = a7;
      v24[4] = v19;
      memcpy(v24 + 5, a6, a7);
      uint64_t v26 = sub_100039A6C(a1, 0, v25, a7 + 5, a8, v16);
      free(v25);
      return v26;
    case 6u:
      if (a7 != 16) {
        return 22;
      }
      __int16 v31 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
      long long v32 = *a6;
      uint64_t v18 = &v31;
LABEL_26:
      unint64_t v20 = a1;
      uint64_t v21 = 18;
      goto LABEL_27;
    case 9u:
      uint64_t result = 22;
      if (a7 != 8 || v16 != 24) {
        return result;
      }
      __int16 v29 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
      uint64_t v30 = *(void *)a6;
      uint64_t v18 = &v29;
      unint64_t v20 = a1;
      uint64_t v21 = 10;
      uint64_t v22 = a8;
      uint64_t v23 = 24;
      break;
    case 0xAu:
      uint64_t result = 22;
      if (a7 != 4 || 8 * (a3 != 0) != v16) {
        return result;
      }
      __int16 v27 = a2 & 0xF | (16 * (a3 & 3)) & 0x3F | ((a4 & 0x1F) << 6) | v13 | 0xA000;
      int v28 = *(_DWORD *)a6;
      uint64_t v18 = &v27;
      unint64_t v20 = a1;
      uint64_t v21 = 6;
LABEL_27:
      uint64_t v22 = a8;
      uint64_t v23 = v16;
      break;
    default:
      return 22;
  }
  return sub_100039A6C(v20, 0, v18, v21, v22, v23);
}

uint64_t sub_1000281AC(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, void *a5, void *a6, void *a7, void *a8)
{
  *(void *)&long long v15 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v15 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v81 = v15;
  long long v80 = v15;
  *(_OWORD *)&v79[8] = v15;
  v78[0] = a2;
  v78[1] = a3;
  LOBYTE(v80) = 0;
  if (a4) {
    uint64_t v16 = sub_1000285C4;
  }
  else {
    uint64_t v16 = sub_100028A44;
  }
  *((void *)&v80 + 1) = 0;
  *(void *)&long long v81 = 0;
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  *(void *)uint64_t v79 = -1;
  *(void *)&v79[5] = -1;
  uint64_t v82 = 0;
  uint64_t v17 = sub_10003A064(a1, 0, (void *)&v81 + 1);
  if (v17)
  {
    uint64_t v18 = v17;
    char v19 = strerror(v17);
    sub_10004458C("unable to access the tree repairs structure: %s\n", v20, v21, v22, v23, v24, v25, v26, v19);
    sub_100048B34((char *)0x2C4, v18);
    goto LABEL_6;
  }
  if (!*((void *)&v81 + 1))
  {
    uint64_t v18 = 0;
    goto LABEL_6;
  }
  unint64_t v86 = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v85[2] = v28;
  v85[3] = v28;
  v85[0] = v28;
  v85[1] = v28;
  __int16 v29 = malloc_type_calloc(1uLL, 0x345uLL, 0x1549E4EBuLL);
  uint64_t v30 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x99A32C8uLL);
  uint64_t v76 = v29;
  unint64_t v77 = v30;
  if (!v29 || !v30)
  {
    sub_10004458C("unable to allocate memory for tree repairs\n", v31, v32, v33, v34, v35, v36, v37, v75);
    uint64_t v18 = 12;
    uint64_t v49 = 701;
    int v50 = 12;
LABEL_27:
    sub_100048B34((char *)v49, v50);
    uint64_t v48 = v76;
    goto LABEL_36;
  }
  if (a3)
  {
    uint64_t v38 = *(void *)(a3 + 40);
    if ((*(unsigned char *)(v38 + 264) & 1) == 0 || *(void *)(v38 + 976))
    {
      if (*(unsigned char *)(a3 + 8))
      {
        uint64_t v39 = sub_100045184((const char **)a3, a2, 2);
        if (v39)
        {
          uint64_t v18 = v39;
          char v40 = strerror(v39);
          sub_10004458C("unable to open the volume for repairs: %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
          sub_100048B34((char *)0x2C5, v18);
LABEL_24:
          uint64_t v48 = v76;
LABEL_37:
          sub_100045320(a3);
LABEL_38:
          uint64_t v60 = v77;
          if (!v77) {
            goto LABEL_40;
          }
          goto LABEL_39;
        }
      }
    }
  }
  uint64_t v48 = v29;
  uint64_t v51 = sub_10003889C((uint64_t)v85, a1, 0, v29, 2u, 0x345u, v77, 3808);
  if (v51)
  {
    uint64_t v18 = v51;
    LOBYTE(v80) = 0;
    *((void *)&v80 + 1) = 0;
    *(void *)&long long v81 = 0;
    goto LABEL_36;
  }
  uint64_t v18 = sub_10002C46C((uint64_t)v85, (uint64_t (*)(void, void, void, void, uint64_t))v16, (uint64_t)v78, 1);
  if (*((void *)&v80 + 1) >= 2uLL)
  {
    if ((_BYTE)v80) {
      uint64_t v59 = "Applied";
    }
    else {
      uint64_t v59 = "Skipped";
    }
    sub_10004435C("%s %llu/%llu repairs of this type in total.\n", v52, v53, v54, v55, v56, v57, v58, (char)v59);
  }
  LOBYTE(v80) = 0;
  *((void *)&v80 + 1) = 0;
  *(void *)&long long v81 = 0;
  if (v18)
  {
LABEL_36:
    if (!a3) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  if (v83)
  {
    uint64_t v61 = sub_10001E444(*a2);
    uint64_t v18 = v61;
    if (a3 && !v61)
    {
      uint64_t v62 = 0;
      char v63 = 1;
      while (1)
      {
        char v64 = v63;
        uint64_t v65 = *(void *)(a3 + 8 * v62 + 24);
        if (v65)
        {
          uint64_t v66 = sub_10001E444(v65);
          if (v66) {
            break;
          }
        }
        char v63 = 0;
        uint64_t v62 = 1;
        if ((v64 & 1) == 0) {
          goto LABEL_52;
        }
      }
      uint64_t v18 = v66;
      goto LABEL_59;
    }
    if (v61)
    {
LABEL_59:
      char v67 = strerror(v18);
      sub_10004458C("unable to flush deferred repairs: %s\n", v68, v69, v70, v71, v72, v73, v74, v67);
      uint64_t v49 = 900;
      int v50 = v18;
      goto LABEL_27;
    }
  }
  if (a3)
  {
LABEL_52:
    if (*(unsigned char *)(a3 + 12))
    {
      if (v83 == *((void *)&v81 + 1)) {
        *(void *)(*(void *)(a3 + 40) + 264) &= ~4uLL;
      }
      sub_100045D54(a2, (int8x16_t *)a3);
      uint64_t v18 = 0;
      *(unsigned char *)(a3 + 12) = 0;
    }
    else
    {
      uint64_t v18 = 0;
    }
    goto LABEL_24;
  }
  uint64_t v18 = 0;
  uint64_t v48 = v76;
  uint64_t v60 = v77;
LABEL_39:
  free(v60);
LABEL_40:
  if (v48) {
    free(v48);
  }
LABEL_6:
  if (a5) {
    *a5 += *((void *)&v81 + 1);
  }
  if (a6) {
    *a6 += v82;
  }
  if (a7) {
    *a7 += v83;
  }
  if (a8) {
    *a8 += v84;
  }
  sub_10003A268(a1, 0);
  return v18;
}

uint64_t sub_1000285C4(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *(uint64_t **)a5;
  uint64_t v10 = *(void **)(a5 + 8);
  int v12 = (void *)(a5 + 16);
  int v20 = sub_100028A60(a1, a2, (unsigned __int16 *)(a5 + 16), *(_DWORD *)(a5 + 36));
  if (v20)
  {
    sub_100028B7C(a5, v13, v14, v15, v16, v17, v18, v19);
    unsigned int v21 = *a1 & 0xF;
    if (v21 >= 0xB) {
      return 22;
    }
    goto LABEL_6;
  }
  unsigned int v21 = *a1 & 0xF;
  if (v21 >= 0xB) {
    return 22;
  }
  if (*(unsigned char *)(a5 + 40))
  {
LABEL_6:
    uint64_t v94 = off_1000705C8[v21];
    int v29 = sub_10001E434(*v11);
    if (v29)
    {
LABEL_7:
      char v30 = strerror(v29);
      sub_100044674("error starting transaction: %s\n", v31, v32, v33, v34, v35, v36, v37, v30);
      sub_100048B34((char *)0x36E, v29);
      LODWORD(v38) = 0;
      if (v20)
      {
        if (!v10) {
          goto LABEL_17;
        }
LABEL_8:
        uint64_t v39 = v10[6];
        if (!v39) {
          uint64_t v39 = v10[5];
        }
        if ((*(unsigned char *)(v39 + 56) & 0x20) != 0 && (*a1 & 0xF) == 8)
        {
          if ((byte_10009096D & 1) == 0)
          {
            sub_100044674("sealed volume fsroot corruptions cannot be repaired and will automatically be skipped\n", v22, v23, v24, v25, v26, v27, v28, v91);
            byte_10009096D = 1;
          }
          uint64_t v40 = 2;
        }
        else
        {
LABEL_17:
          uint64_t v40 = 0;
        }
LABEL_25:
        uint64_t v46 = ((uint64_t (*)(uint64_t *, void *, unsigned __int16 *, uint64_t, uint64_t, uint64_t, uint64_t))v94)(v11, v10, a1, a2, a3, a4, v40);
        uint64_t v41 = v46;
        *(unsigned char *)(a5 + 40) = v46 != 89;
        if (v46)
        {
          if (v46 == 89)
          {
            int v47 = 0;
            uint64_t v41 = (*a1 << 20 >> 31) & 0x5C;
          }
          else
          {
            ++*(void *)(a5 + 88);
            ++*(void *)(a5 + 56);
            int v47 = 1;
          }
        }
        else
        {
          ++*(void *)(a5 + 80);
          sub_100048AE4();
          int v47 = 0;
        }
        if ((*a1 & 0x800) != 0) {
          ++*(void *)(a5 + 72);
        }
        if (!v38) {
          goto LABEL_98;
        }
        uint64_t v48 = *v11;
        if (v47)
        {
          unsigned int v49 = sub_10001E44C(v48);
          if (!v49) {
            unsigned int v49 = sub_10002C928(v11);
          }
          if (v10)
          {
            int v50 = v12;
            uint64_t v51 = 0;
            unsigned int v52 = 0;
            char v53 = 1;
            do
            {
              char v54 = v53;
              uint64_t v55 = v10[v51 + 3];
              if (v55)
              {
                unsigned int v56 = sub_10001E44C(v55);
                if (!v52) {
                  unsigned int v52 = v56;
                }
              }
              char v53 = 0;
              uint64_t v51 = 1;
            }
            while ((v54 & 1) != 0);
            int v12 = v50;
            if (!v52) {
              unsigned int v52 = sub_10002CBD8(v11, (uint64_t)v10);
            }
          }
          else
          {
            unsigned int v52 = 0;
          }
          if (!v49) {
            unsigned int v49 = v52;
          }
          if (v49)
          {
            char v67 = strerror(v49);
            sub_10004458C("error aborting transaction: %s\n", v68, v69, v70, v71, v72, v73, v74, v67);
            sub_100048B34((char *)0x385, v49);
          }
          goto LABEL_95;
        }
        uint64_t v93 = v12;
        unsigned int v57 = sub_10001E43C(v48);
        BOOL v58 = v57 == 84;
        if (v10)
        {
          unsigned int v95 = v57;
          uint64_t v59 = 0;
          unsigned int v60 = 0;
          char v61 = 1;
          do
          {
            char v62 = v61;
            uint64_t v63 = v10[v59 + 3];
            if (v63)
            {
              unsigned int v64 = sub_10001E43C(v63);
              if (v64)
              {
                if (v64 == 84) {
                  BOOL v58 = 1;
                }
                if (v60 == 84 || !v60) {
                  unsigned int v60 = v64;
                }
              }
            }
            char v61 = 0;
            uint64_t v59 = 1;
          }
          while ((v62 & 1) != 0);
          if (v95 == 84) {
            unsigned int v49 = 0;
          }
          else {
            unsigned int v49 = v95;
          }
          if (v60 == 84) {
            unsigned int v65 = 0;
          }
          else {
            unsigned int v65 = v60;
          }
          if (v49) {
            goto LABEL_86;
          }
        }
        else
        {
          unsigned int v65 = 0;
          if (v57 == 84) {
            unsigned int v49 = 0;
          }
          else {
            unsigned int v49 = v57;
          }
          if (v49) {
            goto LABEL_86;
          }
        }
        if (v58 && !v65)
        {
          unsigned int v75 = sub_10001E444(*v11);
          unsigned int v49 = v75;
          if (!v10 || v75)
          {
            if (!v75) {
              goto LABEL_94;
            }
          }
          else
          {
            uint64_t v76 = 0;
            char v77 = 1;
            while (1)
            {
              char v78 = v77;
              uint64_t v79 = v10[v76 + 3];
              if (v79)
              {
                unsigned int v80 = sub_10001E444(v79);
                if (v80) {
                  break;
                }
              }
              char v77 = 0;
              uint64_t v76 = 1;
              if ((v78 & 1) == 0)
              {
                unsigned int v49 = 0;
                goto LABEL_94;
              }
            }
            unsigned int v49 = v80;
          }
LABEL_93:
          char v81 = strerror(v49);
          sub_10004458C("error ending transaction: %s\n", v82, v83, v84, v85, v86, v87, v88, v81);
          sub_100048B34((char *)0x36F, v49);
LABEL_94:
          int v12 = v93;
LABEL_95:
          if (v41) {
            uint64_t v41 = v41;
          }
          else {
            uint64_t v41 = v49;
          }
          goto LABEL_98;
        }
LABEL_86:
        if (!v49)
        {
          unsigned int v49 = v65;
          if (!v65) {
            goto LABEL_94;
          }
        }
        goto LABEL_93;
      }
    }
    else
    {
      uint64_t v92 = v12;
      uint64_t v38 = 0;
      char v42 = 1;
      do
      {
        char v43 = v42;
        if (v10)
        {
          uint64_t v44 = v10[v38 + 3];
          if (v44)
          {
            int v45 = sub_10001E434(v44);
            if (v45)
            {
              int v29 = v45;
              if ((v43 & 1) == 0)
              {
                uint64_t v66 = v10[3];
                if (v66) {
                  sub_10001E43C(v66);
                }
              }
              sub_10001E43C(*v11);
              int v12 = v92;
              goto LABEL_7;
            }
          }
        }
        char v42 = 0;
        uint64_t v38 = 1;
      }
      while ((v43 & 1) != 0);
      int v12 = v92;
      if (v20) {
        goto LABEL_8;
      }
    }
    uint64_t v40 = 1;
    goto LABEL_25;
  }
  if ((*a1 & 0x800) != 0)
  {
    ++*(void *)(a5 + 72);
    uint64_t v41 = 92;
  }
  else
  {
    uint64_t v41 = 0;
  }
LABEL_98:
  if (a2 >= 0x11) {
    size_t v89 = 17;
  }
  else {
    size_t v89 = a2;
  }
  *(_DWORD *)(a5 + 36) = v89;
  memcpy(v12, a1, v89);
  ++*(void *)(a5 + 48);
  return v41;
}

uint64_t sub_100028A44(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((*a1 & 0x800) != 0) {
    ++*(void *)(a5 + 72);
  }
  return 0;
}

uint64_t sub_100028A60(unsigned __int16 *a1, unsigned int a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v4 = *a1;
  unsigned int v5 = v4 & 0xF;
  unsigned int v6 = *a3;
  if (v5 < (v6 & 0xF)) {
    return 0xFFFFFFFFLL;
  }
  if (v5 > (v6 & 0xF)) {
    return 1;
  }
  if (v5 != 5)
  {
    uint64_t v8 = 0;
    if (a4 >= 0xD && a2 >= 0xD)
    {
      char v9 = 0;
      if (v5 != 8) {
        goto LABEL_23;
      }
      goto LABEL_12;
    }
LABEL_22:
    char v9 = 0;
    goto LABEL_23;
  }
  uint64_t v8 = 0;
  if (a2 < 0xD) {
    goto LABEL_22;
  }
  char v9 = 0;
  if (a4 < 0xD) {
    goto LABEL_23;
  }
LABEL_12:
  uint64_t v10 = *(void *)((char *)a1 + 5) >> 60;
  uint64_t v11 = *(void *)((char *)a3 + 5) >> 60;
  if (a4 >= 0x11 && a2 >= 0x11 && v10 == 14 && v11 == 14)
  {
    LODWORD(v10) = *((unsigned __int8 *)a1 + 13);
    LODWORD(v11) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v8 = a1;
  char v9 = a3;
  if (v10 < v11) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    uint64_t result = 1;
  }
  if (v10 == v11)
  {
LABEL_23:
    unsigned int v12 = (v4 >> 4) & 3;
    unsigned int v13 = (v6 >> 4) & 3;
    if (v12 >= v13)
    {
      if (v12 > v13) {
        return 1;
      }
      if (v12 != 1) {
        return 0;
      }
      unsigned int v14 = (v4 >> 6) & 0x1F;
      unsigned int v15 = (v6 >> 6) & 0x1F;
      if (v14 >= v15)
      {
        if (v14 > v15) {
          return 1;
        }
        if (!v8 || !v9) {
          return 0;
        }
        unsigned int v16 = *((unsigned __int8 *)v8 + 4);
        unsigned int v17 = *((unsigned __int8 *)v9 + 4);
        if (v16 >= v17) {
          return v16 > v17;
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_100028B7C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  char v9 = (void *)(result + 48);
  if (*(void *)(result + 48) >= 2uLL)
  {
    if (*(unsigned char *)(result + 40)) {
      uint64_t v10 = "Applied";
    }
    else {
      uint64_t v10 = "Skipped";
    }
    uint64_t result = sub_10004435C("%s %llu/%llu repairs of this type in total.\n", a2, a3, a4, a5, a6, a7, a8, (char)v10);
  }
  *(unsigned char *)(v8 + 40) = 0;
  *char v9 = 0;
  v9[1] = 0;
  return result;
}

uint64_t sub_100028BF4(uint64_t *a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  unsigned int v10 = *a3 & 0xF;
  unsigned int v21 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002CC40(a1, v10, (uint64_t *)&v21);
  if (!result)
  {
    uint64_t v12 = *(void *)(a3 + 1);
    uint64_t v13 = *(void *)(a3 + 5);
    v20[0] = v12;
    v20[1] = v13;
    unsigned int v14 = *a3;
    int v15 = (v14 >> 4) & 3;
    if (v15 == 2)
    {
      BOOL v16 = (v14 & 0x800) == 0;
      uint64_t v19 = (void (*)(const char *, ...))sub_10004458C;
      if (v16) {
        uint64_t v19 = (void (*)(const char *, ...))sub_100044674;
      }
      v19("need to insert spaceman free queue tree entry (0x%llx+%llu, xid %llu) to replace existing overlapping ranges\n", v13, *a5, v12);
      return sub_100029400(v21, 0, v20, 16, a5, 8, (uint64_t)"free queue tree entry", a7);
    }
    else if (v15)
    {
      return 22;
    }
    else
    {
      BOOL v16 = (v14 & 0x800) == 0;
      unsigned int v17 = (void (*)(const char *, ...))sub_10004458C;
      if (v16) {
        unsigned int v17 = (void (*)(const char *, ...))sub_100044674;
      }
      v17("found spaceman free queue tree entry (0x%llx, xid %llu) which overlaps with existing range\n", v13, v12);
      return sub_1000294DC((uint64_t)v21, 0, (uint64_t)v20, 16, 0, (uint64_t)"free queue tree entry", a7 != 0, v18);
    }
  }
  return result;
}

uint64_t sub_100028D38(uint64_t *a1, int8x16_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v18 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002CD48(a1, (uint64_t)a2, &v18);
  if (!result)
  {
    uint64_t v13 = *(void *)(a3 + 2);
    uint64_t v14 = *(void *)(a3 + 10);
    v17[0] = v13;
    v17[1] = v14;
    int v15 = (void (*)(const char *, ...))sub_10004458C;
    if ((*(_WORD *)a3 & 0x800) == 0) {
      int v15 = (void (*)(const char *, ...))sub_100044674;
    }
    v15("found orphan omap mapping (oid %llu xid %llu)\n", v13, v14);
    uint64_t result = sub_1000294DC(v18, 0, (uint64_t)v17, 16, 0, (uint64_t)"omap mapping", a7 != 0, v16);
    if (!result)
    {
      if (*(unsigned char *)a5) {
        return 0;
      }
      else {
        return sub_1000051A0(a1, a2, *(void *)(a5 + 8), (*(_DWORD *)(a5 + 4) / *(_DWORD *)(a1[1] + 36)));
      }
    }
  }
  return result;
}

uint64_t sub_100028E34(int8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, int a7)
{
  int v7 = *(_WORD *)a3 & 0xF;
  if (v7 == 5) {
    return sub_100006AF8((uint64_t)a1, a2, (char *)(a3 + 5), (uint64_t)a5, a7 != 0);
  }
  if (v7 == 4) {
    return sub_1000069B8(a1, a2, *(void *)(a3 + 2), *a5, a5[1], a7 != 0);
  }
  return 22;
}

#error "100028EC0: switch analysis failed: switch information is incomplete or incorrect (funcsize=17)"

uint64_t sub_100028ECC(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v10 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v10 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[2] = v10;
  void v26[3] = v10;
  v26[0] = v10;
  v26[1] = v10;
  uint64_t v11 = *(void *)(a3 + 1);
  uint64_t result = sub_10003EC9C((uint64_t)v26, a1, a2, v11);
  if (!result)
  {
    uint64_t v13 = a3 + 5;
    unsigned int v14 = *a3;
    int v15 = (v14 >> 4) & 3;
    if (v15 == 2)
    {
      BOOL v16 = (v14 & 0x800) == 0;
      uint64_t v19 = sub_10004458C;
      if (v16) {
        uint64_t v19 = sub_100044674;
      }
      if (v11) {
        int v20 = "missing/invalid physical extent (%llu + %llu) with refcnt %d at snapshot %llu\n";
      }
      else {
        int v20 = "missing/invalid physical extent (%llu + %llu) with refcnt %d\n";
      }
      ((void (*)(const char *))v19)(v20);
      uint64_t v24 = *v13 >> 60;
      if (v24 == 14) {
        LODWORD(v24) = *((unsigned __int8 *)a3 + 18);
      }
      uint64_t v25 = sub_10003D8BC(v24);
      return sub_100029400(v26, v11, a3 + 5, 8, a5, 20, (uint64_t)v25, a7);
    }
    else if (v15)
    {
      return 22;
    }
    else
    {
      BOOL v16 = (v14 & 0x800) == 0;
      unsigned int v17 = sub_10004458C;
      if (v16) {
        unsigned int v17 = sub_100044674;
      }
      if (v11) {
        uint64_t v18 = "orphan/invalid physical extent (%llu) at snapshot %llu\n";
      }
      else {
        uint64_t v18 = "orphan/invalid physical extent (%llu)\n";
      }
      ((void (*)(const char *))v17)(v18);
      uint64_t v21 = *v13 >> 60;
      if (v21 == 14) {
        LODWORD(v21) = *((unsigned __int8 *)a3 + 18);
      }
      uint64_t v22 = sub_10003D8BC(v21);
      return sub_1000294DC((uint64_t)v26, v11, (uint64_t)(a3 + 5), 8, 0, (uint64_t)v22, a7 != 0, v23);
    }
  }
  return result;
}

uint64_t sub_100029088(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, _WORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_10009096C & 1) == 0)
  {
    sub_100044674("detected invalid fsroot tree nodes (& thus data loss), pruning the nodes to make the system usable\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v24);
    byte_10009096C = 1;
  }
  uint64_t v25 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002D3D4(a1, a2, (uint64_t *)&v25);
  if (!result)
  {
    uint64_t v15 = a3[1];
    BOOL v16 = (void *)((char *)a3 + 5);
    unsigned int v17 = *a3;
    int v18 = (v17 >> 4) & 3;
    if (v18 == 2)
    {
      BOOL v20 = (v17 & 0x800) == 0;
      uint64_t v23 = (void (*)(const char *, ...))sub_10004458C;
      if (v20) {
        uint64_t v23 = (void (*)(const char *, ...))sub_100044674;
      }
      v23("need to insert key at id (%llu) to repair invalid internal node\n", *v16 & 0xFFFFFFFFFFFFFFFLL);
      return sub_100029400(v25, 0, (char *)a3 + 5, v15, a5, a6, (uint64_t)"btree node", a7);
    }
    else if (v18)
    {
      return 22;
    }
    else
    {
      unsigned __int16 v19 = *a5 + 1;
      BOOL v20 = (v17 & 0x800) == 0;
      uint64_t v21 = (void (*)(const char *, ...))sub_10004458C;
      if (v20) {
        uint64_t v21 = (void (*)(const char *, ...))sub_100044674;
      }
      v21("found invalid fsroot btree node key id (%llu)\n", *v16 & 0xFFFFFFFFFFFFFFFLL);
      return sub_1000294DC((uint64_t)v25, 0, (uint64_t)a3 + 5, v15, v19, (uint64_t)"btree node", a7, v22);
    }
  }
  return result;
}

uint64_t sub_100029210(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v16 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002CFD8(a1, a2, (uint64_t *)&v16, a4, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    uint64_t v13 = *(void *)(a3 + 2);
    uint64_t v15 = v13;
    unsigned int v14 = (void (*)(const char *, ...))sub_10004458C;
    if ((*(_WORD *)a3 & 0x800) == 0) {
      unsigned int v14 = (void (*)(const char *, ...))sub_100044674;
    }
    v14("no file key rolling entry found for inode object (%llu)\n", v13);
    return sub_100029400(v16, 0, &v15, 8, a5, a6, (uint64_t)"file key rolling", a7);
  }
  return result;
}

uint64_t sub_1000292C8(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  BOOL v20 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002D0B4(a1, a2, (uint64_t *)&v20);
  if (!result)
  {
    int v12 = *(_DWORD *)(a3 + 1);
    int v19 = v12;
    unsigned int v13 = *a3;
    int v14 = (v13 >> 4) & 3;
    if (v14 == 2)
    {
      BOOL v15 = (v13 & 0x800) == 0;
      int v18 = (void (*)(const char *, ...))sub_10004458C;
      if (v15) {
        int v18 = (void (*)(const char *, ...))sub_100044674;
      }
      v18("inode with file-id %llu has doc-id %u but doc-id tree record is missing or points to another inode\n", *a5, v12);
      return sub_100029400(v20, 0, &v19, 4, a5, a6, (uint64_t)"doc-id tree entry", a7);
    }
    else if (v14)
    {
      return 22;
    }
    else
    {
      BOOL v15 = (v13 & 0x800) == 0;
      BOOL v16 = (void (*)(const char *, ...))sub_10004458C;
      if (v15) {
        BOOL v16 = (void (*)(const char *, ...))sub_100044674;
      }
      v16("doc-id tree record exists for doc-id %u, but no inode references this doc-id\n", v12);
      return sub_1000294DC((uint64_t)v20, 0, (uint64_t)&v19, 4, 0, (uint64_t)"doc-id tree entry", a7 != 0, v17);
    }
  }
  return result;
}

uint64_t sub_100029400(_DWORD *a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a7;
  if (a8 != 1
    && (a8 == 2
     || !sub_10004641C(qword_100091B70, "Insert missing %s objects? ", (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a7)))
  {
    return 89;
  }
  uint64_t v15 = sub_100039A6C(a1, a2, a3, a4, a5, a6);
  uint64_t v16 = v15;
  if (v15)
  {
    strerror(v15);
    sub_10004458C("failed to insert %s object: %s\n", v17, v18, v19, v20, v21, v22, v23, v8);
    sub_100048B34((char *)0x28F, v16);
  }
  return v16;
}

uint64_t sub_1000294DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a6;
  unsigned int v9 = a5;
  if (a7 != 1
    && (a7 == 2
     || !sub_10004641C(qword_100091B70, "Remove orphan/invalid %s objects? ", a3, a4, a5, a6, a7, a8, a6)))
  {
    return 89;
  }
  uint64_t v14 = sub_100039D3C(a1, a2, a3, a4, v9);
  uint64_t v22 = v14;
  if (v14)
  {
    if (v14 == 2)
    {
      sub_100044674("tried to remove %s object but it wasn't there!\n", v15, v16, v17, v18, v19, v20, v21, v8);
      return 0;
    }
    else
    {
      strerror(v14);
      sub_10004458C("failed to remove %s object: %s\n", v23, v24, v25, v26, v27, v28, v29, v8);
      sub_100048B34((char *)0x28D, v22);
    }
  }
  return v22;
}

uint64_t sub_1000295C8(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E25C(a1, a2, 3, &v19, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    unsigned int v12 = *a3;
    uint64_t v13 = a3[1];
    switch((v12 >> 6) & 0x1F)
    {
      case 0xCu:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "nchildren of inode object (id %llu) does not match expected value (%d)\n";
        goto LABEL_35;
      case 0xDu:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "alloced_size of dstream (object-id %llu) does not match minimum found size (%llu)\n";
        goto LABEL_35;
      case 0xEu:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "need to update default_crypto_id (%llu) of dstream (object-id %llu) with missing crypto state\n";
        goto LABEL_35;
      case 0xFu:
        if ((v12 & 0x800) != 0) {
          uint64_t v17 = (void (*)(const char *, ...))sub_10004458C;
        }
        else {
          uint64_t v17 = (void (*)(const char *, ...))sub_100044674;
        }
        uint64_t v18 = sub_10003D8EC((uint64_t)a3 + 5, *a5);
        v17("found unexpected %s xfield associated with inode (object-id %llu)\n", v18, *(void *)((unsigned char *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL);
        goto LABEL_36;
      case 0x10u:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "need to update inode (object-id %llu) sparse bytes with (%llu)\n";
        goto LABEL_35;
      case 0x11u:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "need to set flags (0x%llx) in inode (object-id %llu)\n";
        goto LABEL_35;
      case 0x12u:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "need to clear flags (0x%llx) in inode (object-id %llu)\n";
        goto LABEL_35;
      case 0x13u:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "need to set bsd flags (0x%x) in inode (object-id %llu)\n";
        goto LABEL_35;
      case 0x14u:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "need to clear bsd flags (0x%x) in inode (object-id %llu)\n";
        goto LABEL_35;
      case 0x15u:
        BOOL v14 = (v12 & 0x800) == 0;
        uint64_t v15 = sub_10004458C;
        if (v14) {
          uint64_t v15 = sub_100044674;
        }
        uint64_t v16 = "dir_nlink of inode object (id %llu) does not match expected value (%d)\n";
LABEL_35:
        ((void (*)(const char *))v15)(v16);
LABEL_36:
        uint64_t result = sub_10002AAA8(v19, (*a3 >> 6) & 0x1F, (uint64_t)a3 + 5, v13, a5, v8);
        break;
      default:
        uint64_t result = 22;
        break;
    }
  }
  return result;
}

uint64_t sub_100029938(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E25C(a1, a2, 4, &v22, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    uint64_t v12 = a3[1];
    unsigned int v13 = *a3;
    int v14 = (v13 >> 4) & 3;
    if (v14 == 1)
    {
      BOOL v15 = (v13 & 0x800) == 0;
      uint64_t v21 = (void (*)(const char *, ...))sub_10004458C;
      if (v15) {
        uint64_t v21 = (void (*)(const char *, ...))sub_100044674;
      }
      v21("found xattr dstream (id %llu, name %.*s) that references a missing crypto state\n", *(void *)((unsigned char *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)((char *)a3 + 13), (const char *)a3 + 15);
      return sub_10002AAA8(v22, 25, (uint64_t)a3 + 5, v12, a5, v8);
    }
    else if (v14)
    {
      return 22;
    }
    else
    {
      BOOL v15 = (v13 & 0x800) == 0;
      uint64_t v16 = (void (*)(const char *, ...))sub_10004458C;
      if (v15) {
        uint64_t v16 = (void (*)(const char *, ...))sub_100044674;
      }
      v16("found orphan/invalid xattr (id %llu, name %.*s)\n", *(void *)((unsigned char *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)((char *)a3 + 13), (const char *)a3 + 15);
      uint64_t v17 = v22;
      uint64_t v18 = *(void *)((char *)a3 + 5) >> 60;
      if (v18 == 14) {
        LODWORD(v18) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v19 = sub_10003D8BC(v18);
      return sub_1000294DC(v17, 0, (uint64_t)a3 + 5, v12, 0, (uint64_t)v19, v8 != 0, v20);
    }
  }
  return result;
}

uint64_t sub_100029AA8(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v39 = 0;
  uint64_t v12 = (unint64_t *)((char *)a3 + 5);
  uint64_t v13 = a3[1];
  uint64_t v14 = *(void *)((char *)a3 + 5) >> 60;
  uint64_t result = sub_10003E25C(a1, a2, v14, (uint64_t *)&v39, (uint64_t)a5, a6, a7, a8);
  if (result) {
    return result;
  }
  if (v14 != 8)
  {
    if (v14 != 6) {
      return 22;
    }
    unsigned int v16 = *a3;
    int v17 = (v16 >> 4) & 3;
    switch(v17)
    {
      case 2:
        BOOL v18 = (v16 & 0x800) == 0;
        uint64_t v35 = (void (*)(const char *, ...))sub_10004458C;
        if (v18) {
          uint64_t v35 = (void (*)(const char *, ...))sub_100044674;
        }
        v35("dstream (id %llu) does not have an associated dstream id object\n", *v12 & 0xFFFFFFFFFFFFFFFLL);
        uint64_t v31 = v39;
        unint64_t v32 = *v12;
        goto LABEL_34;
      case 1:
        BOOL v18 = (v16 & 0x800) == 0;
        uint64_t v38 = sub_10004458C;
        if (v18) {
          uint64_t v38 = sub_100044674;
        }
        uint64_t v34 = "refcnt of dstream id object (id %llu) less than expected\n";
        goto LABEL_43;
      case 0:
        BOOL v18 = (v16 & 0x800) == 0;
        uint64_t v19 = (void (*)(const char *, ...))sub_10004458C;
        if (v18) {
          uint64_t v19 = (void (*)(const char *, ...))sub_100044674;
        }
        v19("found orphan dstream id object (id %llu)\n", *v12 & 0xFFFFFFFFFFFFFFFLL);
        uint64_t v20 = (uint64_t)v39;
        unint64_t v21 = *v12;
LABEL_21:
        unint64_t v27 = v21 >> 60;
        if (v21 >> 60 == 14) {
          LODWORD(v27) = *((unsigned __int8 *)a3 + 13);
        }
        uint64_t v28 = sub_10003D8BC(v27);
        return sub_1000294DC(v20, 0, (uint64_t)v12, v13, 0, (uint64_t)v28, a7 != 0, v29);
    }
  }
  if (a6) {
    uint64_t v22 = *(void *)a5 & 0xFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v22 = 0;
  }
  unsigned int v23 = *a3;
  int v24 = (v23 >> 4) & 3;
  if (v24 != 2)
  {
    if (v24 != 1)
    {
      if (!v24)
      {
        uint64_t v25 = (void (*)(const char *, ...))sub_10004458C;
        if ((v23 & 0x800) == 0) {
          uint64_t v25 = (void (*)(const char *, ...))sub_100044674;
        }
        uint64_t v26 = "invalid";
        if ((v23 & 0x800) == 0) {
          uint64_t v26 = "orphan";
        }
        v25("found %s file extent object (id %llu) at logical address %llu\n", v26, *(void *)((unsigned char *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL, *(void *)((char *)a3 + 13));
        uint64_t v20 = (uint64_t)v39;
        unint64_t v21 = *(void *)((char *)a3 + 5);
        goto LABEL_21;
      }
      return 22;
    }
    int v33 = (v23 >> 6) & 0x1F;
    if (v33 == 10)
    {
      uint64_t v34 = "found file extent overlap (id %llu) with next extent / end of dstream at logical address %llu+%llu\n";
    }
    else
    {
      if (v33 != 11) {
        return 22;
      }
      uint64_t v34 = "need to make file extent with missing crypto state (id %llu) at logical address %llu+%llu sparse\n";
    }
    uint64_t v38 = sub_10004458C;
    if ((v23 & 0x800) == 0) {
      uint64_t v38 = sub_100044674;
    }
LABEL_43:
    ((void (*)(const char *))v38)(v34);
    return sub_10002AAA8((uint64_t)v39, (*a3 >> 6) & 0x1F, (uint64_t)v12, v13, a5, a7);
  }
  char v30 = (void (*)(const char *, ...))sub_10004458C;
  if ((v23 & 0x800) == 0) {
    char v30 = (void (*)(const char *, ...))sub_100044674;
  }
  v30("found file extent gap (id %llu) at logical address %llu+%llu\n", *(void *)((unsigned char *)a3 + 5) & 0xFFFFFFFFFFFFFFFLL, *(void *)((char *)a3 + 13), v22);
  uint64_t v31 = v39;
  unint64_t v32 = *(void *)((char *)a3 + 5);
LABEL_34:
  unint64_t v36 = v32 >> 60;
  if (v32 >> 60 == 14) {
    LODWORD(v36) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v37 = sub_10003D8BC(v36);
  return sub_100029400(v31, 0, v12, v13, a5, a6, (uint64_t)v37, a7);
}

uint64_t sub_100029DF0(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v24 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E25C(a1, a2, 7, &v24, (uint64_t)a5, a6, a7, a8);
  if (result) {
    return result;
  }
  uint64_t v12 = a3[1];
  uint64_t v13 = (void *)((char *)a3 + 5);
  unsigned int v14 = *a3;
  int v15 = (v14 >> 4) & 3;
  if (v15 == 1)
  {
    int v21 = (v14 >> 6) & 0x1F;
    if (v21 == 23)
    {
      uint64_t v22 = sub_10004458C;
      if ((v14 & 0x800) == 0) {
        uint64_t v22 = sub_100044674;
      }
      unsigned int v23 = "need to increment crypto state object (id %llu) refcount (%u)\n";
    }
    else
    {
      if (v21 != 22) {
        return 22;
      }
      uint64_t v22 = sub_10004458C;
      if ((v14 & 0x800) == 0) {
        uint64_t v22 = sub_100044674;
      }
      unsigned int v23 = "refcnt of crypto state object (id %llu) is %s than expected (%u)\n";
    }
    ((void (*)(const char *))v22)(v23);
    return sub_10002AAA8(v24, (*a3 >> 6) & 0x1F, (uint64_t)a3 + 5, v12, a5, v8);
  }
  if (v15) {
    return 22;
  }
  unsigned int v16 = (void (*)(const char *, ...))sub_10004458C;
  if ((v14 & 0x800) == 0) {
    unsigned int v16 = (void (*)(const char *, ...))sub_100044674;
  }
  v16("found orphan/unexpected crypto state object (id %llu)\n", *v13 & 0xFFFFFFFFFFFFFFFLL);
  uint64_t v17 = v24;
  uint64_t v18 = *v13 >> 60;
  if (v18 == 14) {
    LODWORD(v18) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v19 = sub_10003D8BC(v18);
  return sub_1000294DC(v17, 0, (uint64_t)a3 + 5, v12, 0, (uint64_t)v19, v8 != 0, v20);
}

uint64_t sub_100029FB8(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E25C(a1, a2, 9, &v23, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    uint64_t v12 = a3[1];
    uint64_t v13 = (void *)((char *)a3 + 5);
    unsigned int v14 = *a3;
    int v15 = (v14 >> 4) & 3;
    if (v15 == 1)
    {
      BOOL v16 = (v14 & 0x800) == 0;
      uint64_t v22 = (void (*)(const char *, ...))sub_10004458C;
      if (v16) {
        uint64_t v22 = (void (*)(const char *, ...))sub_100044674;
      }
      v22("found invalid directory record object (id %llu)\n", *v13 & 0xFFFFFFFFFFFFFFFLL);
      return sub_10002AAA8(v23, 24, (uint64_t)a3 + 5, v12, a5, v8);
    }
    else if (v15)
    {
      return 22;
    }
    else
    {
      BOOL v16 = (v14 & 0x800) == 0;
      uint64_t v17 = (void (*)(const char *, ...))sub_10004458C;
      if (v16) {
        uint64_t v17 = (void (*)(const char *, ...))sub_100044674;
      }
      v17("found orphan directory record object (id %llu)\n", *v13 & 0xFFFFFFFFFFFFFFFLL);
      uint64_t v18 = v23;
      uint64_t v19 = *v13 >> 60;
      if (v19 == 14) {
        LODWORD(v19) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v20 = sub_10003D8BC(v19);
      return sub_1000294DC(v18, 0, (uint64_t)a3 + 5, v12, 0, (uint64_t)v20, v8 != 0, v21);
    }
  }
  return result;
}

uint64_t sub_10002A110(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v32 = 0;
  uint64_t v12 = (void *)((char *)a3 + 5);
  uint64_t v13 = *(void *)((char *)a3 + 5) >> 60;
  if (v13 == 14) {
    LODWORD(v13) = *((unsigned __int8 *)a3 + 13);
  }
  uint64_t v14 = *(unsigned __int16 *)((char *)v12 - 3);
  uint64_t result = sub_10003E25C(a1, a2, v13, (uint64_t *)&v32, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    unsigned int v16 = *a3;
    int v17 = (v16 >> 4) & 3;
    if (v17 == 2)
    {
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v24 = (void (*)(const char *, ...))sub_10004458C;
      if (v18) {
        uint64_t v24 = (void (*)(const char *, ...))sub_100044674;
      }
      v24("dir-stats (id %llu) is missing\n", *v12 & 0xFFFFFFFFFFFFFFFLL);
      uint64_t v25 = v32;
      uint64_t v26 = *v12 >> 60;
      if (v26 == 14) {
        LODWORD(v26) = *((unsigned __int8 *)a3 + 13);
      }
      unint64_t v27 = sub_10003D8BC(v26);
      return sub_100029400(v25, 0, v12, v14, a5, a6, (uint64_t)v27, a7);
    }
    else if (v17 == 1)
    {
      switch((v16 >> 6) & 0x1F)
      {
        case 1u:
          BOOL v18 = (v16 & 0x800) == 0;
          uint64_t v28 = sub_10004458C;
          if (v18) {
            uint64_t v28 = sub_100044674;
          }
          uint64_t v29 = "chained key of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_41;
        case 2u:
          BOOL v18 = (v16 & 0x800) == 0;
          uint64_t v28 = sub_10004458C;
          if (v18) {
            uint64_t v28 = sub_100044674;
          }
          uint64_t v29 = "descendants of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_41;
        case 3u:
          BOOL v18 = (v16 & 0x800) == 0;
          uint64_t v28 = sub_10004458C;
          if (v18) {
            uint64_t v28 = sub_100044674;
          }
          uint64_t v29 = "flags of dir-stats object (id %llu) does not match expected value (0x%x)\n";
          goto LABEL_41;
        case 4u:
          BOOL v18 = (v16 & 0x800) == 0;
          uint64_t v28 = sub_10004458C;
          if (v18) {
            uint64_t v28 = sub_100044674;
          }
          uint64_t v29 = "origin_id of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_41;
        case 5u:
          BOOL v18 = (v16 & 0x800) == 0;
          uint64_t v28 = sub_10004458C;
          if (v18) {
            uint64_t v28 = sub_100044674;
          }
          uint64_t v29 = "physical size of dir-stats object (id %llu) does not match expected value (%llu)\n";
          goto LABEL_41;
        case 6u:
          if ((v16 & 0x800) != 0) {
            char v30 = sub_10004458C;
          }
          else {
            char v30 = sub_100044674;
          }
          sub_10003D8EC((uint64_t)v12, *a5);
          uint64_t v31 = "%s xfield of dir-stats object (id %llu) exists unexpectedly\n";
          goto LABEL_46;
        case 7u:
          BOOL v18 = (v16 & 0x800) == 0;
          uint64_t v28 = sub_10004458C;
          if (v18) {
            uint64_t v28 = sub_100044674;
          }
          uint64_t v29 = "resource fork size of dir-stats object (id %llu) does not match expected value (%llu)\n";
LABEL_41:
          ((void (*)(const char *))v28)(v29);
          break;
        case 8u:
          if ((v16 & 0x800) != 0) {
            char v30 = sub_10004458C;
          }
          else {
            char v30 = sub_100044674;
          }
          sub_10003D8EC((uint64_t)v12, *a5);
          uint64_t v31 = "%s xfield of dir-stats object (id %llu) does not match expected value (%llu)\n";
LABEL_46:
          ((void (*)(const char *))v30)(v31);
          break;
        default:
          return 22;
      }
      return sub_10002AAA8((uint64_t)v32, (*a3 >> 6) & 0x1F, (uint64_t)v12, v14, a5, a7);
    }
    else if (v17)
    {
      return 22;
    }
    else
    {
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v19 = (void (*)(const char *, ...))sub_10004458C;
      if (v18) {
        uint64_t v19 = (void (*)(const char *, ...))sub_100044674;
      }
      v19("found invalid dir-stats object (id %llu)\n", *v12 & 0xFFFFFFFFFFFFFFFLL);
      uint64_t v20 = (uint64_t)v32;
      uint64_t v21 = *v12 >> 60;
      if (v21 == 14) {
        LODWORD(v21) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v22 = sub_10003D8BC(v21);
      return sub_1000294DC(v20, 0, (uint64_t)v12, v14, 0, (uint64_t)v22, a7 != 0, v23);
    }
  }
  return result;
}

uint64_t sub_10002A53C(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v24 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10002D180(a1, a2, (uint64_t *)&v24);
  if (!result)
  {
    uint64_t v11 = a3[1];
    unsigned int v12 = *a3;
    int v13 = (v12 >> 4) & 3;
    if (v13 == 2)
    {
      BOOL v14 = (v12 & 0x800) == 0;
      uint64_t v20 = (void (*)(const char *, ...))sub_10004458C;
      if (v14) {
        uint64_t v20 = (void (*)(const char *, ...))sub_100044674;
      }
      v20("no snap_name entry found for snap_meta entry with xid %llu and name %.*s\n", *a5, *(unsigned __int16 *)((char *)a3 + 13), (const char *)a3 + 15);
      uint64_t v21 = v24;
      uint64_t v22 = *(void *)((char *)a3 + 5) >> 60;
      if (v22 == 14) {
        LODWORD(v22) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v23 = sub_10003D8BC(v22);
      return sub_100029400(v21, 0, (char *)a3 + 5, v11, a5, 8, (uint64_t)v23, a7);
    }
    else if (v13)
    {
      return 22;
    }
    else
    {
      BOOL v14 = (v12 & 0x800) == 0;
      int v15 = (void (*)(const char *, ...))sub_10004458C;
      if (v14) {
        int v15 = (void (*)(const char *, ...))sub_100044674;
      }
      v15("no snap_meta entry found for snap_name entry with name %.*s\n", *(unsigned __int16 *)((char *)a3 + 13), (const char *)a3 + 15);
      uint64_t v16 = (uint64_t)v24;
      uint64_t v17 = *(void *)((char *)a3 + 5) >> 60;
      if (v17 == 14) {
        LODWORD(v17) = *((unsigned __int8 *)a3 + 13);
      }
      BOOL v18 = sub_10003D8BC(v17);
      return sub_1000294DC(v16, 0, (uint64_t)a3 + 5, v11, 0, (uint64_t)v18, a7 != 0, v19);
    }
  }
  return result;
}

uint64_t sub_10002A6BC(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a7;
  uint64_t v11 = (void *)((char *)a3 + 5);
  uint64_t v12 = a3[1];
  uint64_t v13 = *(void *)((char *)a3 + 5) >> 60;
  unint64_t v14 = v11[1];
  uint64_t v27 = 0;
  uint64_t result = sub_10003E25C(a1, a2, v13, &v27, (uint64_t)a5, a6, a7, a8);
  if (result) {
    return result;
  }
  unsigned int v16 = *a3;
  int v17 = (v16 >> 4) & 3;
  if (v17 != 1)
  {
    if (!v17)
    {
      if (HIBYTE(v14) == 2)
      {
        BOOL v18 = (v16 & 0x800) == 0;
        uint64_t v19 = sub_10004458C;
        if (v18) {
          uint64_t v19 = sub_100044674;
        }
        uint64_t v20 = "file info: found orphan attribution tag with hash (%llu)\n";
        goto LABEL_17;
      }
      if (HIBYTE(v14) == 1)
      {
        BOOL v18 = (v16 & 0x800) == 0;
        uint64_t v19 = sub_10004458C;
        if (v18) {
          uint64_t v19 = sub_100044674;
        }
        uint64_t v20 = "file info: found orphan data hash (id %llu) at logical address %llu\n";
LABEL_17:
        ((void (*)(const char *))v19)(v20);
        uint64_t v23 = v27;
        uint64_t v24 = *v11 >> 60;
        if (v24 == 14) {
          LODWORD(v24) = *((unsigned __int8 *)a3 + 13);
        }
        uint64_t v25 = sub_10003D8BC(v24);
        return sub_1000294DC(v23, 0, (uint64_t)v11, v12, 0, (uint64_t)v25, v8 != 0, v26);
      }
    }
    return 22;
  }
  switch((v16 >> 6) & 0x1F)
  {
    case 0x1Au:
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v21 = sub_10004458C;
      if (v18) {
        uint64_t v21 = sub_100044674;
      }
      uint64_t v22 = "file info: attribution tag (hash %llu) with invalid jobj_id (%llu)\n";
      break;
    case 0x1Bu:
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v21 = sub_10004458C;
      if (v18) {
        uint64_t v21 = sub_100044674;
      }
      uint64_t v22 = "file info: attribution tag with invalid hash (%llu)\n";
      break;
    case 0x1Cu:
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v21 = sub_10004458C;
      if (v18) {
        uint64_t v21 = sub_100044674;
      }
      uint64_t v22 = "file info: attribution tag (hash %llu): total count does not match expected value (%llu)\n";
      break;
    case 0x1Du:
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v21 = sub_10004458C;
      if (v18) {
        uint64_t v21 = sub_100044674;
      }
      uint64_t v22 = "file info: attribution tag (hash %llu): physical size does not match expected value (%llu)\n";
      break;
    case 0x1Eu:
      BOOL v18 = (v16 & 0x800) == 0;
      uint64_t v21 = sub_10004458C;
      if (v18) {
        uint64_t v21 = sub_100044674;
      }
      uint64_t v22 = "file info: attribution tag (hash %llu): full clone size does not match expected value (%llu)\n";
      break;
    default:
      return 22;
  }
  ((void (*)(const char *))v21)(v22);
  return sub_10002AAA8(v27, (*a3 >> 6) & 0x1F, (uint64_t)v11, v12, a5, v8);
}

uint64_t sub_10002A998(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003E25C(a1, a2, 19, (uint64_t *)&v23, (uint64_t)a5, a6, a7, a8);
  if (!result)
  {
    uint64_t v13 = a3[1];
    unint64_t v14 = (void *)((char *)a3 + 5);
    int v15 = (*a3 >> 4) & 3;
    if (v15 == 2)
    {
      uint64_t v20 = v23;
      uint64_t v21 = *v14 >> 60;
      if (v21 == 14) {
        LODWORD(v21) = *((unsigned __int8 *)a3 + 13);
      }
      uint64_t v22 = sub_10003D8BC(v21);
      return sub_100029400(v20, 0, (char *)a3 + 5, v13, a5, a6, (uint64_t)v22, a7);
    }
    else if (v15)
    {
      return 22;
    }
    else
    {
      uint64_t v16 = (uint64_t)v23;
      uint64_t v17 = *v14 >> 60;
      if (v17 == 14) {
        LODWORD(v17) = *((unsigned __int8 *)a3 + 13);
      }
      BOOL v18 = sub_10003D8BC(v17);
      return sub_1000294DC(v16, 0, (uint64_t)a3 + 5, v13, 0, (uint64_t)v18, a7 != 0, v19);
    }
  }
  return result;
}

uint64_t sub_10002AAA8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, int a6)
{
  uint64_t v12 = *(void *)a3 >> 60;
  if (v12 == 14) {
    LODWORD(v12) = *(unsigned __int8 *)(a3 + 8);
  }
  char v111 = sub_10003D8BC(v12);
  uint64_t v13 = malloc_type_calloc(1uLL, 0x340uLL, 0xEF55EA28uLL);
  unsigned int v117 = -1431655766;
  unint64_t v14 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x4E2D581AuLL);
  uint64_t v22 = v14;
  unsigned int v116 = 3808;
  if (v13 && v14)
  {
    if (a6 == 1
      || a6 != 2
      && sub_10004641C(qword_100091B70, "Update %s objects? ", v16, v17, v18, v19, v20, v21, v111))
    {
      __memcpy_chk();
      unsigned int v117 = a4;
      uint64_t v23 = sub_1000380B0(a1, 0, 0, v13, &v117, 0x340u, v22, &v116);
      if (v23)
      {
        uint64_t v24 = v23;
        strerror(v23);
        sub_10004458C("failed to lookup %s object: %s\n", v25, v26, v27, v28, v29, v30, v31, v111);
        uint64_t v32 = 819;
LABEL_10:
        sub_100048B34((char *)v32, v24);
        goto LABEL_16;
      }
      unint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
      uint64_t v115 = 0;
      memset(v114, 170, sizeof(v114));
      if ((a2 - 13) > 1)
      {
        uint64_t v43 = 0;
        unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v45 = 0xAAAAAAAAAAAAAAAALL;
      }
      else
      {
        uint64_t v24 = sub_10003EE64((unsigned __int16 *)v22 + 46, v116 - 92, 8, &v115, v114, 0, 0);
        if (v24)
        {
LABEL_22:
          uint64_t v35 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
          strerror(v24);
          sub_10004458C("failed to get inode (id %llu) dstream: %s\n", v36, v37, v38, v39, v40, v41, v42, v35);
          uint64_t v32 = 892;
          goto LABEL_10;
        }
        if (v114[0] < 0x28u)
        {
          uint64_t v24 = 34;
          goto LABEL_22;
        }
        uint64_t v43 = v115;
        unint64_t v34 = *(void *)v115;
        unint64_t v44 = *(void *)(v115 + 8);
        unint64_t v45 = *(void *)(v115 + 16);
        *(_OWORD *)&v114[1] = *(_OWORD *)(v115 + 24);
      }
      switch(a2)
      {
        case 1:
          uint64_t v47 = *(void *)a5;
          if (v12 == 10) {
            goto LABEL_69;
          }
          v22[4] = v47;
          goto LABEL_70;
        case 2:
        case 10:
        case 28:
          *uint64_t v22 = *(void *)a5;
          goto LABEL_70;
        case 3:
          *((_DWORD *)v22 + 12) = *(_DWORD *)a5;
          goto LABEL_70;
        case 4:
          v22[3] = *(void *)a5;
          goto LABEL_70;
        case 5:
          uint64_t v48 = *(void *)a5;
          goto LABEL_67;
        case 6:
          int v49 = *a5;
          LODWORD(v113) = v116 - 52;
          uint64_t v50 = sub_10003F0F8((unsigned __int16 *)v22 + 26, (unsigned int *)&v113, v49);
          if (v50)
          {
            uint64_t v24 = v50;
            uint64_t v51 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
            sub_10003D8EC((uint64_t)v13, v49);
            strerror(v24);
            sub_10004458C("failed to remove dir stats (id %llu) %s xfield: %s (%d)", v52, v53, v54, v55, v56, v57, v58, v51);
            uint64_t v32 = 1377;
            goto LABEL_10;
          }
          unsigned int v116 = v113 + 52;
          goto LABEL_70;
        case 7:
          uint64_t v47 = *(void *)a5;
          goto LABEL_69;
        case 8:
          uint64_t v113 = 0;
          uint64_t v59 = sub_10003F63C(v22, (int *)&v116, *a5, a5 + 4, *((unsigned __int16 *)a5 + 1), &v113);
          uint64_t v24 = v59;
          if (!v59)
          {
            uint64_t v60 = v113;
            if (v113)
            {
              free(v22);
              uint64_t v22 = (void *)v60;
              goto LABEL_70;
            }
          }
          if (!v59) {
            goto LABEL_70;
          }
          goto LABEL_16;
        case 9:
        case 22:
          int v46 = *(_DWORD *)a5;
          goto LABEL_59;
        case 11:
          v22[1] = 0;
          int v22[2] = 0;
          goto LABEL_70;
        case 12:
          *((_DWORD *)v22 + 14) = *((_DWORD *)a5 + 14);
          goto LABEL_70;
        case 13:
          unint64_t v44 = *((void *)a5 + 1);
          goto LABEL_44;
        case 14:
          unint64_t v45 = *((void *)a5 + 2);
          if (v45 == -1) {
            v22[6] |= 0x10uLL;
          }
LABEL_44:
          *(void *)uint64_t v43 = v34;
          *(void *)(v43 + 8) = v44;
          *(void *)(v43 + --*(_DWORD *)(result + 16) = v45;
          *(_OWORD *)(v43 + 24) = *(_OWORD *)&v114[1];
          goto LABEL_70;
        case 15:
          int v61 = *a5;
          LODWORD(v113) = v116 - 92;
          uint64_t v62 = sub_10003F0F8((unsigned __int16 *)v22 + 46, (unsigned int *)&v113, v61);
          unsigned int v116 = v113 + 92;
          if (!v62) {
            goto LABEL_70;
          }
          uint64_t v24 = v62;
          uint64_t v63 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
          strerror(v62);
          sub_10004458C("failed to remove inode (oid 0x%llx) xfield (type %u): %s\n", v64, v65, v66, v67, v68, v69, v70, v63);
          uint64_t v32 = 893;
          goto LABEL_10;
        case 16:
          v22[6] |= 0x200uLL;
          uint64_t v113 = 0;
          uint64_t v71 = sub_10003F584(v22, (int *)&v116, *(void *)a5, &v113);
          if (!v71) {
            goto LABEL_78;
          }
          uint64_t v24 = v71;
          uint64_t v72 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
          strerror(v71);
          sub_10004458C("failed to repair inode sparse bytes (id %llu): %s\n", v73, v74, v75, v76, v77, v78, v79, v72);
          uint64_t v32 = 1205;
          goto LABEL_10;
        case 17:
          uint64_t v80 = v22[6] | *(void *)a5;
          goto LABEL_51;
        case 18:
          uint64_t v80 = v22[6] & ~*(void *)a5;
LABEL_51:
          v22[6] = v80;
          goto LABEL_70;
        case 19:
          int v81 = *((_DWORD *)v22 + 17) | *(_DWORD *)a5;
          goto LABEL_54;
        case 20:
          int v81 = *((_DWORD *)v22 + 17) & ~*(_DWORD *)a5;
LABEL_54:
          *((_DWORD *)v22 + 17) = v81;
          goto LABEL_70;
        case 21:
          uint64_t v82 = *(void *)(*(void *)(a1 + 8) + 40);
          if ((*(unsigned char *)(v82 + 57) & 2) != 0)
          {
            *((_DWORD *)v22 + 21) = *((_DWORD *)a5 + 21);
          }
          else
          {
            if ((*(unsigned char *)(v82 + 48) & 2) == 0)
            {
LABEL_57:
              uint64_t v24 = 22;
              goto LABEL_16;
            }
            uint64_t v112 = *((int *)a5 + 21);
            uint64_t v113 = 0;
            uint64_t v100 = sub_10003F2FC(v22, (int *)&v116, 17, &v112, 8, &v113);
            if (v100)
            {
              uint64_t v24 = v100;
              uint64_t v101 = *(void *)v13 & 0xFFFFFFFFFFFFFFFLL;
              strerror(v100);
              sub_10004458C("failed to repair inode nlink (id %llu): %s\n", v102, v103, v104, v105, v106, v107, v108, v101);
              uint64_t v32 = 1206;
              goto LABEL_10;
            }
LABEL_78:
            uint64_t v109 = v113;
            if (v113)
            {
              free(v22);
              uint64_t v22 = (void *)v109;
            }
          }
LABEL_70:
          uint64_t v92 = sub_100039A6C((_DWORD *)a1, 0, v13, v117, v22, v116);
          uint64_t v24 = v92;
          if (!v92) {
            goto LABEL_16;
          }
          strerror(v92);
          sub_10004458C("failed to update %s object: %s\n", v93, v94, v95, v96, v97, v98, v99, v111);
          uint64_t v32 = 706;
          break;
        case 23:
          int v46 = *(_DWORD *)v22 + 1;
LABEL_59:
          *(_DWORD *)uint64_t v22 = v46;
          goto LABEL_70;
        case 24:
          __int16 v83 = v13[2];
          v13[2] &= 0x3FFu;
          int v13[2] = v83 & 0x3FF | (*(_DWORD *)a5 << 10);
          goto LABEL_64;
        case 25:
          *(void *)((char *)v22 + 28) = *(void *)a5;
          goto LABEL_70;
        case 26:
          *(void *)uint64_t v13 = 0xD000000000000009;
          goto LABEL_64;
        case 27:
          *((void *)v13 + 1) = *(void *)a5 & 0xFFFFFFFFFFFFFFLL | 0x200000000000000;
LABEL_64:
          uint64_t v84 = sub_10003A048(a1, 0, a3, a4);
          if (!v84) {
            goto LABEL_70;
          }
          uint64_t v24 = v84;
          strerror(v84);
          sub_10004458C("failed to remove %s object (id %llu): %s\n", v85, v86, v87, v88, v89, v90, v91, v111);
          uint64_t v32 = 950;
          goto LABEL_10;
        case 29:
          uint64_t v48 = *((void *)a5 + 1);
LABEL_67:
          v22[1] = v48;
          goto LABEL_70;
        case 30:
          uint64_t v47 = *((void *)a5 + 2);
LABEL_69:
          int v22[2] = v47;
          goto LABEL_70;
        default:
          goto LABEL_57;
      }
      goto LABEL_10;
    }
    uint64_t v24 = 89;
LABEL_16:
    free(v13);
    if (!v22) {
      return v24;
    }
    goto LABEL_13;
  }
  sub_10004458C("unable to allocate memory for tree repairs\n", v15, v16, v17, v18, v19, v20, v21, v110);
  uint64_t v24 = 12;
  sub_100048B34((char *)0x34B, 12);
  if (v13) {
    goto LABEL_16;
  }
  if (v22) {
LABEL_13:
  }
    free(v22);
  return v24;
}

const char *sub_10002B178(const char *result, ...)
{
  va_start(va, result);
  if (dword_1000745E8 >= 5) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

const char *sub_10002B1C4(const char *result, ...)
{
  va_start(va, result);
  if (dword_1000745E8 >= 2) {
    return (const char *)vfprintf(__stderrp, result, va);
  }
  return result;
}

void *sub_10002B210(size_t a1, size_t a2)
{
  uint64_t result = malloc_type_calloc(a1, a2, 0x284387B2uLL);
  if (result) {
    atomic_fetch_add_explicit(&qword_100091EB0, a2 * a1, memory_order_relaxed);
  }
  return result;
}

void sub_10002B254(void *a1, uint64_t a2)
{
  if (a1)
  {
    free(a1);
    atomic_fetch_add_explicit(&qword_100091EB0, -a2, memory_order_relaxed);
  }
}

void *sub_10002B290(size_t a1)
{
  uint64_t result = malloc_type_malloc(a1, 0x1CC27423uLL);
  if (result) {
    atomic_fetch_add_explicit(&qword_100091EB0, a1, memory_order_relaxed);
  }
  return result;
}

uint64_t sub_10002B2CC(_DWORD *a1, unsigned int a2, const void *a3, uint64_t a4)
{
  unsigned int v11 = -1431655766;
  long long v10 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v6 = sub_10002B364(a2, a3, &v10, &v11);
  if (!v6)
  {
    uint64_t v9 = a4;
    int v7 = v10;
    uint64_t v6 = sub_100039A6C(a1, 0, v10, v11, &v9, 8);
    free(v7);
  }
  return v6;
}

uint64_t sub_10002B364(unsigned int a1, const void *a2, void *a3, unsigned int *a4)
{
  unsigned int v8 = a1 + 10;
  uint64_t v9 = malloc_type_malloc(a1 + 10, 0xB9C4B0DBuLL);
  if (!v9) {
    return 12;
  }
  long long v10 = v9;
  *(void *)uint64_t v9 = 0xBFFFFFFFFFFFFFFFLL;
  v9[4] = a1;
  memcpy(v9 + 5, a2, a1);
  *a3 = v10;
  uint64_t result = 0;
  if (a4) {
    *a4 = v8;
  }
  return result;
}

uint64_t sub_10002B3F0(uint64_t a1, unsigned int a2, const void *a3)
{
  unsigned int v8 = -1431655766;
  int v7 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = sub_10002B364(a2, a3, &v7, &v8);
  if (!v4)
  {
    unsigned int v5 = v7;
    uint64_t v4 = sub_10003A048(a1, 0, (uint64_t)v7, v8);
    free(v5);
  }
  return v4;
}

uint64_t sub_10002B478(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned int a5, char a6, _DWORD *a7)
{
  uint64_t v13 = *a3;
  unint64_t v14 = (char *)malloc_type_calloc(1uLL, 0x10AuLL, 0xF16E3641uLL);
  uint64_t v15 = (unint64_t *)malloc_type_calloc(1uLL, 0x132uLL, 0x1EAE2623uLL);
  if (v14 && (uint64_t v23 = v15) != 0)
  {
    unint64_t v76 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v77 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v24 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v24 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v73[0] = v24;
    v73[1] = v24;
    long long v74 = v24;
    long long v75 = v24;
    __src[14] = v24;
    __src[15] = v24;
    __src[12] = v24;
    __src[13] = v24;
    __src[10] = v24;
    __src[11] = v24;
    __src[8] = v24;
    __src[9] = v24;
    __src[6] = v24;
    __src[7] = v24;
    __src[4] = v24;
    __src[5] = v24;
    __src[3] = v24;
    __src[1] = v24;
    __src[2] = v24;
    __src[0] = v24;
    *(void *)unint64_t v14 = 0xBFFFFFFFFFFFFFFFLL;
    uint64_t v25 = sub_10002D180(a1, a2, &v77);
    if (v25 || (uint64_t v25 = sub_10003889C((uint64_t)v73, v77, 0, v14, 0xAu, 0x10Au, v23, 306), v25))
    {
      char v26 = strerror(v25);
      sub_10004458C("unable to setup snapshot tree iteration: %s\n", v27, v28, v29, v30, v31, v32, v33, v26);
      uint64_t v34 = 1266;
LABEL_6:
      sub_100048B34((char *)v34, v25);
    }
    else if (BYTE8(v74))
    {
      uint64_t v25 = 2;
    }
    else
    {
      unsigned __int16 v68 = 0;
      uint64_t v36 = v13 & 0xFFFFFFFFFFFFFFFLL;
      size_t v37 = a5 - 50;
      uint64_t v70 = (void *)(a4 + 50);
      uint64_t v71 = v14 + 10;
      unsigned int v69 = -1;
      do
      {
        if (*(void *)v14 >> 60 == 11 && *v23 == v36)
        {
          int v72 = -1431655766;
          int v38 = sub_10001061C(a2, (uint64_t *)v14, v74, v23, SDWORD1(v74), 0, &v72);
          if (!(v38 | v72))
          {
            size_t v39 = *((unsigned __int16 *)v14 + 4);
            if (v37 >= v39) {
              size_t v40 = *((unsigned __int16 *)v14 + 4);
            }
            else {
              size_t v40 = v37;
            }
            if ((a6 & 2) != 0 && !strncmp((const char *)v70, v71, v40))
            {
              if (sub_10004641C(qword_100091B70, "Fix snapshot meta name_len (%u) from snap name entry? ", v41, v42, v43, v44, v45, v46, v39))
              {
                *(_WORD *)(a4 + 48) = v40;
                bzero(v70, v37);
                uint64_t v57 = (void *)(a4 + 50);
                uint64_t v56 = v14 + 10;
                size_t v58 = v40;
                goto LABEL_29;
              }
              goto LABEL_34;
            }
            if (a6)
            {
              unsigned int v47 = sub_10002B7FC((uint64_t)v70, *(unsigned __int16 *)(a4 + 48), (unsigned __int8 *)v71, v39);
              if (v47 < v69)
              {
                unsigned int v48 = v47;
                __memcpy_chk();
                unsigned int v69 = v48;
                unsigned __int16 v68 = v40;
              }
            }
          }
        }
        uint64_t v49 = (*((uint64_t (**)(_OWORD *))&v73[0] + 1))(v73);
        if (v49)
        {
          uint64_t v25 = v49;
          char v59 = strerror(v49);
          sub_10004458C("error iterating snapshot tree: %s\n", v60, v61, v62, v63, v64, v65, v66, v59);
          uint64_t v34 = 1267;
          goto LABEL_6;
        }
      }
      while (!BYTE8(v74));
      if (v69 == -1)
      {
        uint64_t v25 = 0;
        goto LABEL_7;
      }
      if (sub_10004641C(qword_100091B70, "Fix snapshot meta name (%.*s) from snap name entry? ", v50, v51, v52, v53, v54, v55, v68))
      {
        *(_WORD *)(a4 + 48) = v68;
        bzero(v70, v68);
        uint64_t v56 = __src;
        uint64_t v57 = (void *)(a4 + 50);
        size_t v58 = v68;
LABEL_29:
        memcpy(v57, v56, v58);
        uint64_t v25 = 0;
        *a7 = 1;
        goto LABEL_7;
      }
LABEL_34:
      uint64_t v25 = 92;
    }
LABEL_7:
    free(v14);
    free(v23);
  }
  else
  {
    sub_10004458C("failed to allocate memory for snapshot repair\n", v16, v17, v18, v19, v20, v21, v22, v67);
    uint64_t v25 = 12;
    sub_100048B34((char *)0x4F1, 12);
  }
  return v25;
}

uint64_t sub_10002B7FC(uint64_t a1, int a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v7 = a4;
  uint64_t v8 = a4 + 1;
  __chkstk_darwin(a1);
  long long v10 = (_DWORD *)((char *)&v25 - v9);
  memset((char *)&v25 - v9, 170, v11);
  uint64_t v12 = 0;
  do
  {
    v10[v12] = v12;
    ++v12;
  }
  while (v8 != v12);
  if (a2)
  {
    uint64_t v13 = 1;
    do
    {
      int v14 = v13;
      if (v7)
      {
        unsigned __int16 v15 = v13 - 1;
        int v16 = *(unsigned __int8 *)(a1 + v13 - 1);
        uint64_t v17 = a3;
        uint64_t v18 = v10 + 1;
        uint64_t v19 = v7;
        LOWORD(v20) = v13;
        do
        {
          int v21 = *v17++;
          if (v16 != v21) {
            ++v15;
          }
          unsigned int v22 = *v18;
          LOWORD(v20) = v20 + 1;
          if ((unsigned __int16)(*v18 + 1) >= (unsigned __int16)v20) {
            unsigned int v20 = (unsigned __int16)v20;
          }
          else {
            unsigned int v20 = (unsigned __int16)(v22 + 1);
          }
          if (v20 >= v15) {
            unsigned int v20 = v15;
          }
          *v18++ = v20;
          unsigned __int16 v15 = v22;
          --v19;
        }
        while (v19);
      }
    }
    while (v13++ != a2);
    *long long v10 = v14;
  }
  return v10[v7];
}

uint64_t sub_10002B948()
{
  uint64_t result = sub_100038040((uint64_t)&unk_100090970, 0, 0, 0x8000000, 2, 0, 0, 4096, 0, 2, 0, 0, (uint64_t)sub_10002B9CC);
  if (!result)
  {
    uint64_t result = sub_10003A18C((uint64_t)&unk_100090970, 0, 0);
    if (result) {
      qword_1000909A8 = 0;
    }
  }
  return result;
}

uint64_t sub_10002B9CC(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 >= 0x10 && a5 >= 0x10)
  {
    if (*(void *)a2 >= *(void *)a4)
    {
      if (*(void *)a2 > *(void *)a4)
      {
        int v8 = 1;
LABEL_11:
        uint64_t result = 0;
        *a6 = v8;
        return result;
      }
      unsigned int v9 = *(unsigned __int16 *)(a2 + 8);
      unsigned int v10 = *(unsigned __int16 *)(a4 + 8);
      if (v9 >= v10) {
        size_t v11 = *(unsigned __int16 *)(a4 + 8);
      }
      else {
        size_t v11 = *(unsigned __int16 *)(a2 + 8);
      }
      int v12 = memcmp((const void *)(a2 + 10), (const void *)(a4 + 10), v11);
      if ((v12 & 0x80000000) == 0)
      {
        if (v12) {
          int v8 = 1;
        }
        else {
          int v8 = -1;
        }
        if (v12) {
          BOOL v13 = 0;
        }
        else {
          BOOL v13 = v9 >= v10;
        }
        if (v13) {
          int v8 = v9 > v10;
        }
        goto LABEL_11;
      }
    }
    int v8 = -1;
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_10002BA78(void *a1, uint64_t a2)
{
  return sub_10002BA94(*a1 & 0xFFFFFFFFFFFFFFFLL, *(unsigned __int16 *)(a2 + 48), a2 + 50, 0);
}

uint64_t sub_10002BA94(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (!qword_1000909A8) {
    return 0;
  }
  __int16 v5 = a2;
  unsigned int v22 = a2 + 16;
  uint64_t v7 = malloc_type_calloc(1uLL, 0x110uLL, 0x80BFF959uLL);
  if (v7)
  {
    unsigned __int16 v15 = v7;
    unsigned int v21 = 2;
    __int16 v20 = 0;
    *(void *)uint64_t v7 = a1;
    v7[4] = v5;
    __memcpy_chk();
    uint64_t v16 = sub_1000380B0((uint64_t)dword_100090970, 0, 0, v15, &v22, 0x110u, &v20, &v21);
    if (v16)
    {
      uint64_t v17 = v16;
      if (v16 != 2)
      {
LABEL_12:
        free(v15);
        return v17;
      }
      *(void *)unsigned __int16 v15 = a1;
      v15[4] = v5;
      __memcpy_chk();
    }
    if (a4) {
      HIBYTE(v20) = 1;
    }
    else {
      LOBYTE(v20) = 1;
    }
    uint64_t v17 = sub_100039A6C(dword_100090970, 0, v15, v22, &v20, v21);
    goto LABEL_12;
  }
  sub_10004458C("failed to allocate memory for snapshot tracking\n", v8, v9, v10, v11, v12, v13, v14, v19);
  uint64_t v17 = 12;
  sub_100048B34((char *)0x153, 12);
  return v17;
}

uint64_t sub_10002BBFC(uint64_t a1, uint64_t *a2)
{
  return sub_10002BA94(*a2, *(unsigned __int16 *)(a1 + 8), a1 + 10, 1);
}

uint64_t sub_10002BC14(_DWORD *a1)
{
  if (qword_1000909A8)
  {
    unint64_t v53 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v51 = v2;
    long long v52 = v2;
    v50[0] = v2;
    v50[1] = v2;
    long long v3 = (unsigned __int16 *)malloc_type_calloc(1uLL, 0x110uLL, 0xA7946EFuLL);
    if (!v3)
    {
      sub_10004458C("failed to allocate memory for snapshot validation\n", v4, v5, v6, v7, v8, v9, v10, v45);
      uint64_t v20 = 12;
      sub_100048B34((char *)0x368, 12);
LABEL_9:
      sub_10003A268((uint64_t)&unk_100090970, 0);
      return v20;
    }
    uint64_t v11 = v3;
    __int16 v49 = 0;
    unsigned int v48 = -1431655766;
    uint64_t v46 = 0;
    unsigned int v47 = 0;
    uint64_t v12 = sub_10003889C((uint64_t)v50, (uint64_t)&unk_100090970, 0, v3, 0x10u, 0x110u, &v49, 2);
    if (v12)
    {
      uint64_t v20 = v12;
      char v21 = strerror(v12);
      sub_10004458C("unable to initialize iterator for snapshot validation: %s\n", v22, v23, v24, v25, v26, v27, v28, v21);
      uint64_t v29 = 873;
LABEL_5:
      sub_100048B34((char *)v29, v20);
LABEL_6:
      free(v11);
      goto LABEL_9;
    }
    while (1)
    {
      if (BYTE8(v51))
      {
        uint64_t v20 = 0;
        goto LABEL_6;
      }
      if (HIBYTE(v49) && v49 == 0) {
        break;
      }
      if (HIBYTE(v49)) {
        BOOL v32 = 1;
      }
      else {
        BOOL v32 = v49 == 0;
      }
      if (!v32)
      {
        sub_10004458C("no snap_name entry found for snap_meta entry with xid %llu and name %.*s\n", v13, v14, v15, v16, v17, v18, v19, *(void *)v11);
        sub_100048B34((char *)0x28E, 92);
        uint64_t v33 = sub_10002B364(v11[4], v11 + 5, &v47, &v48);
        if (v33) {
          goto LABEL_28;
        }
        uint64_t v46 = *(void *)v11;
        uint64_t v34 = v47;
        uint64_t v35 = sub_100027E70(a1, 5u, 2, 0, 1, v47, v48, &v46, 8u);
LABEL_24:
        uint64_t v20 = v35;
        free(v34);
        if (v20) {
          goto LABEL_6;
        }
      }
      uint64_t v36 = (*((uint64_t (**)(_OWORD *))&v50[0] + 1))(v50);
      if (v36)
      {
        uint64_t v20 = v36;
        char v37 = strerror(v36);
        sub_10004458C("error iterating snapshot tree: %s\n", v38, v39, v40, v41, v42, v43, v44, v37);
        uint64_t v29 = 874;
        goto LABEL_5;
      }
    }
    sub_10004458C("no snap_meta entry found for snap_name entry with xid %llu and name %.*s\n", v13, v14, v15, v16, v17, v18, v19, *(void *)v11);
    sub_100048B34((char *)0x28C, 92);
    uint64_t v33 = sub_10002B364(v11[4], v11 + 5, &v47, &v48);
    if (v33)
    {
LABEL_28:
      uint64_t v20 = v33;
      goto LABEL_6;
    }
    uint64_t v46 = *(void *)v11;
    uint64_t v34 = v47;
    uint64_t v35 = sub_100027E70(a1, 5u, 0, 0, 1, v47, v48, 0, 0);
    goto LABEL_24;
  }
  return 0;
}

uint64_t sub_10002BEA4(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5, void *a6)
{
  if (!a4) {
    return 28;
  }
  unint64_t v6 = a1;
  if (a1 <= a2 || a4 < a1)
  {
    if (0x180000000 * (a2 >> 12) > a4) {
      return 28;
    }
    if (a4 >> 34)
    {
      uint64_t v9 = 0x1000000000;
      if (a4 >= 0x1000000000) {
        unint64_t v10 = 0x1000000000;
      }
      else {
        unint64_t v10 = a4;
      }
      uint64_t v8 = v10 >> 5;
      if (a4 >= 0x1000000001)
      {
        if (a4 - 0x1000000000 < 0x1000000000) {
          uint64_t v9 = a4 - 0x1000000000;
        }
        v8 += ((unint64_t)v9 * (unsigned __int128)0x666666666666667uLL) >> 64;
        if (a4 >= 0x2000000001)
        {
          unint64_t v11 = a4 - 0x2000000000;
          if (a4 - 0x2000000000 >= 0x2000000000) {
            unint64_t v11 = 0x2000000000;
          }
          v8 += v11 >> 7;
          if (a4 >= 0x4000000001) {
            v8 += (a4 - 0x4000000000) / 0xA0;
          }
        }
      }
    }
    else
    {
      uint64_t v8 = 0x20000000;
    }
    unint64_t v6 = v8 * (a2 >> 12);
    if (v6 >= a4 >> 2) {
      unint64_t v6 = a4 >> 2;
    }
  }
  uint64_t result = 0;
  unint64_t v12 = v6 / a2;
  *a5 = v12 * a2;
  *a6 = a3 - v12;
  return result;
}

unint64_t sub_10002BFAC(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  if (a5) {
    *a5 = (a2 >> 1) / result + a3;
  }
  if (a6)
  {
    unint64_t v6 = (a2 >> 4) / result;
    if (v6 >= 0x8000000 / result) {
      unint64_t v6 = 0x8000000 / result;
    }
    *a6 = a4 - v6;
  }
  return result;
}

void sub_10002BFE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  if (!(void)xmmword_1000909B0 || (sub_10002C044(a1, a2, a3, a6, a5, (uint64_t)a6, a7, a8), !v10))
  {
    if ((v8 & 0x40000000) != 0) {
      byte_1000909C8 = 1;
    }
    *(void *)&xmmword_1000909B0 = a4;
  }
}

double sub_10002C044(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v29 = 0;
  int v10 = DWORD2(xmmword_1000909B0);
  int v9 = HIDWORD(xmmword_1000909B0);
  uint64_t v11 = *(void *)(a2 + 40);
  if ((*(unsigned char *)(v11 + 57) & 2) != 0) {
    int v12 = 1;
  }
  else {
    int v12 = (*(unsigned __int8 *)(v11 + 48) >> 1) & 1;
  }
  if (unk_1000909C4 == dword_1000909C0) {
    int v13 = 0;
  }
  else {
    int v13 = v12;
  }
  if (HIDWORD(xmmword_1000909B0) != DWORD2(xmmword_1000909B0) || v13 != 0)
  {
    if (byte_1000909C8) {
      goto LABEL_18;
    }
    if (sub_10003E760(a1, a2, a3, xmmword_1000909B0, &v29)) {
      return result;
    }
    if (v29) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = xmmword_1000909B0 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  if (v9 == v10) {
    goto LABEL_21;
  }
  sub_10004458C("directory valence check: directory (oid 0x%llx): nchildren (%d) does not match drec count (%d)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, xmmword_1000909B0);
  sub_100048B34((char *)0x330, 92);
  *(void *)uint64_t v28 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v25 = 0u;
  *(_DWORD *)&v28[8] = DWORD2(xmmword_1000909B0);
  memset(&v28[12], 0, 32);
  if (!sub_10002C404(a4, 12, v16, &v25, v17, v18, v19, v20))
  {
LABEL_21:
    if (!v13
      || (sub_10004458C("directory valence check: directory (oid 0x%llx): nlink (%d) does not match subdirectory count (%d)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, xmmword_1000909B0), sub_100048B34((char *)0x4B7, 92), memset(v28, 0, 36), v26 = 0u, v27 = 0u, long long v25 = 0u, *(void *)&v28[36] = dword_1000909C0, !sub_10002C404(a4, 21, v16, &v25, v21, v22, v23, v24)))
    {
LABEL_18:
      double result = 0.0;
      xmmword_1000909B0 = 0u;
      *(_OWORD *)&dword_1000909C0 = 0u;
    }
  }
  return result;
}

void sub_10002C1E0(uint64_t a1, int a2)
{
  DWORD2(xmmword_1000909B0) = 0;
  HIDWORD(xmmword_1000909B0) = a2;
}

void sub_10002C1F0(uint64_t a1, int a2)
{
  dword_1000909C0 = 0;
  unk_1000909C4 = a2;
}

void sub_10002C200(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v8 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  if (v8 != 1 && v8 != 7)
  {
    if (v8 == (void)xmmword_1000909B0)
    {
      BOOL v11 = __OFADD__(DWORD2(xmmword_1000909B0), 1);
      char v12 = BYTE8(xmmword_1000909B0) + 1;
      ++DWORD2(xmmword_1000909B0);
      if (v11)
      {
        sub_100044674("drec count overflow (%d)\n", a2, a3, (uint64_t)a4, a5, a6, a7, (uint64_t)a8, v12);
        sub_100048B34((char *)0x4B8, 92);
        DWORD2(xmmword_1000909B0) = 0x7FFFFFFF;
      }
      if ((*(_WORD *)(a6 + 16) & 0xF) == 4)
      {
        BOOL v11 = __OFADD__(dword_1000909C0, 1);
        char v13 = ++dword_1000909C0;
        if (v11)
        {
          sub_100044674("subdir count overflow (%d)\n", a2, a3, (uint64_t)a4, a5, a6, a7, (uint64_t)a8, v13);
          sub_100048B34((char *)0x4B9, 92);
          dword_1000909C0 = 0x7FFFFFFF;
        }
      }
    }
    else
    {
      sub_10002C044(a1, a2, a3, a8, a5, a6, a7, (uint64_t)a8);
      if (!v25)
      {
        sub_100044674("directory valence check: directory (oid 0x%llx): orphan directory record\n", v18, v19, v20, v21, v22, v23, v24, v8);
        sub_100048B34((char *)0x34C, -8);
        sub_10002C344(a8, 0, 0, a4, a5, (unsigned char *)a6, a7, v26);
      }
    }
  }
}

uint64_t sub_10002C344(_DWORD *a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t a5, unsigned char *a6, uint64_t a7, uint64_t a8)
{
  if (a1) {
    return sub_100027E70(a1, 8u, a2, a3, 0, a4, a5, a6, a7);
  }
  return sub_100027AD0(0, a2, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
}

void sub_10002C39C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((void)xmmword_1000909B0) {
    sub_10002C044(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t sub_10002C3B4(long long *a1, uint64_t a2, int a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  return sub_10002C344(a4, 1, 24, a1, a2, &v9, 4, a8);
}

void sub_10002C3F8()
{
  *(void *)&xmmword_1000909B0 = 0;
}

uint64_t sub_10002C404(_DWORD *a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)&long long var8 = a3;
  if (a1) {
    return sub_100027E70(a1, 8u, 1, a2, 1, &var8, 8u, a4, 0x5Cu);
  }

  return sub_100027AD0(0, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
}

uint64_t sub_10002C46C(uint64_t a1, uint64_t (*a2)(void, void, void, void, uint64_t), uint64_t a3, int a4)
{
  uint64_t v8 = 0;
  while (1)
  {
    if (!a1) {
      return 0;
    }
    if (*(unsigned char *)(a1 + 40)) {
      break;
    }
    uint64_t v9 = a2(*(void *)(a1 + 16), *(unsigned int *)(a1 + 32), *(void *)(a1 + 24), *(unsigned int *)(a1 + 36), a3);
    if (v9) {
      BOOL v10 = a4 == 0;
    }
    else {
      BOOL v10 = 0;
    }
    if (!v10)
    {
      uint64_t v8 = v9 ? v9 : v8;
      uint64_t v9 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
      if (!v9) {
        continue;
      }
    }
    uint64_t v8 = v9;
    break;
  }
  if (*(void *)a1) {
    (*(void (**)(uint64_t))a1)(a1);
  }
  return v8;
}

uint64_t sub_10002C50C(uint64_t a1, uint64_t a2, uint64_t (*a3)(long long *, long long *, int *, uint64_t), uint64_t a4)
{
  int v24 = -1431655766;
  if (a1)
  {
    if (a2 && !*(unsigned char *)(a1 + 40))
    {
      while (1)
      {
        if (*(unsigned char *)(a2 + 40)) {
          goto LABEL_4;
        }
        int v24 = 3;
        long long v22 = *(_OWORD *)(a1 + 16);
        uint64_t v23 = *(void *)(a1 + 32);
        long long v20 = *(_OWORD *)(a2 + 16);
        uint64_t v21 = *(void *)(a2 + 32);
        uint64_t v8 = a3(&v22, &v20, &v24, a4);
        if (v8) {
          break;
        }
        char v12 = v24;
        if (v24)
        {
          uint64_t v8 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
          if (v8) {
            break;
          }
          char v12 = v24;
        }
        if ((v12 & 2) != 0)
        {
          uint64_t v8 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a2);
          if (v8) {
            break;
          }
        }
        if (*(unsigned char *)(a1 + 40)) {
          goto LABEL_4;
        }
      }
LABEL_7:
      uint64_t v9 = v8;
      goto LABEL_15;
    }
LABEL_4:
    while (!*(unsigned char *)(a1 + 40))
    {
      long long v18 = *(_OWORD *)(a1 + 16);
      uint64_t v19 = *(void *)(a1 + 32);
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v8 = a3(&v18, (long long *)&v15, &v24, a4);
      if (!v8)
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t))(a1 + 8))(a1);
        if (!v8) {
          continue;
        }
      }
      goto LABEL_7;
    }
  }
  if (a2)
  {
    while (!*(unsigned char *)(a2 + 40))
    {
      long long v13 = *(_OWORD *)(a2 + 16);
      uint64_t v14 = *(void *)(a2 + 32);
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      uint64_t v10 = a3((long long *)&v15, &v13, &v24, a4);
      if (!v10)
      {
        uint64_t v10 = (*(uint64_t (**)(uint64_t))(a2 + 8))(a2);
        if (!v10) {
          continue;
        }
      }
      uint64_t v9 = v10;
      if (a1) {
        goto LABEL_15;
      }
      goto LABEL_17;
    }
  }
  uint64_t v9 = 0;
  if (a1)
  {
LABEL_15:
    if (*(void *)a1) {
      (*(void (**)(uint64_t))a1)(a1);
    }
  }
LABEL_17:
  if (a2 && *(void *)a2) {
    (*(void (**)(uint64_t))a2)(a2);
  }
  return v9;
}

void sub_10002C6C4(uint64_t *a1)
{
  if (a1[64]) {
    sub_10003A268((uint64_t)(a1 + 57), 0);
  }
  for (uint64_t i = 24; i != 48; i += 8)
  {
    if (a1[i]) {
      a1[i] = 0;
    }
  }
  if (a1[48]) {
    a1[48] = 0;
  }
  if (a1[56]) {
    a1[56] = 0;
  }
  long long v3 = (void *)a1[4];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)a1[3];
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[2];
  if (v5) {
    free(v5);
  }
  unint64_t v6 = (void *)a1[1];
  if (v6) {
    free(v6);
  }
  if (*a1) {
    sub_10002F0E0(*a1);
  }

  bzero(a1, 0x208uLL);
}

uint64_t sub_10002C780(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    *a1 = 0;
    return sub_10002F0E0(result);
  }
  return result;
}

void sub_10002C798(void **a1)
{
  if (a1[95]) {
    sub_10003A268((uint64_t)(a1 + 88), 0);
  }
  if (a1[71]) {
    a1[71] = 0;
  }
  if (a1[63]) {
    a1[63] = 0;
  }
  if (a1[55]) {
    a1[55] = 0;
  }
  if (a1[47]) {
    a1[47] = 0;
  }
  if (a1[39]) {
    a1[39] = 0;
  }
  if (a1[79]) {
    a1[79] = 0;
  }
  if (a1[31]) {
    a1[31] = 0;
  }
  if (a1[23]) {
    a1[23] = 0;
  }
  long long v2 = a1[9];
  if (v2) {
    free(v2);
  }
  long long v3 = a1[6];
  if (v3) {
    free(v3);
  }
  uint64_t v4 = a1[5];
  if (v4) {
    free(v4);
  }
  uint64_t v5 = 0;
  char v6 = 1;
  do
  {
    char v7 = v6;
    uint64_t v8 = (uint64_t)a1[v5 + 3];
    if (v8) {
      sub_10002F0E0(v8);
    }
    char v6 = 0;
    uint64_t v5 = 1;
  }
  while ((v7 & 1) != 0);
  if (*a1) {
    free(*a1);
  }

  bzero(a1, 0x3C0uLL);
}

uint64_t sub_10002C89C(uint64_t a1)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = a1 + 8 * v2;
    uint64_t v8 = *(void *)(v5 + 24);
    char v7 = (void *)(v5 + 24);
    uint64_t result = v8;
    if (v8)
    {
      *char v7 = 0;
      uint64_t result = sub_10002F0E0(result);
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

void sub_10002C8E8(uint64_t a1, char a2)
{
  char v4 = *(void **)(a1 + 48);
  if (v4)
  {
    free(v4);
    *(void *)(a1 + 48) = 0;
  }
  *(unsigned char *)(a1 + 14) = a2;
  uint64_t v5 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = v5;
}

uint64_t sub_10002C928(uint64_t *a1)
{
  uint64_t result = sub_10002F148(*a1, a1[5]);
  if (!result)
  {
    char v3 = (void *)a1[2];
    if (!v3 || (free(v3), a1[2] = 0, uint64_t result = sub_10002C9D0(a1, 0), !result))
    {
      char v4 = (void *)a1[3];
      if (!v4 || (free(v4), a1[3] = 0, uint64_t result = sub_10002CA70(a1, 0), !result))
      {
        uint64_t v5 = (void *)a1[4];
        if (!v5) {
          return 0;
        }
        free(v5);
        a1[4] = 0;
        uint64_t result = sub_10002CB10(a1, 0, 0);
        if (!result) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10002C9D0(uint64_t *a1, void *a2)
{
  char v3 = a1 + 2;
  if (a1[2]
    || (uint64_t v5 = sub_1000257B4(a1, 0, 0x80000000, *(void *)(a1[1] + 168), 0, 0, 17, 0, (uint64_t **)a1 + 2, (uint64_t)(a1 + 8), 0), !v5))
  {
    uint64_t v4 = 0;
    if (a2) {
      *a2 = *v3;
    }
  }
  else
  {
    uint64_t v4 = v5;
    char v6 = strerror(v5);
    sub_10004458C("verification/reading of the nx_reaper object failed: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  }
  return v4;
}

uint64_t sub_10002CA70(uint64_t *a1, void *a2)
{
  char v3 = a1 + 3;
  if (a1[3]
    || (uint64_t v5 = sub_1000257B4(a1, 0, 0x80000000, *(void *)(a1[1] + 152), 0, 0, 5, 0, (uint64_t **)a1 + 3, (uint64_t)(a1 + 11), 0), !v5))
  {
    uint64_t v4 = 0;
    if (a2) {
      *a2 = *v3;
    }
  }
  else
  {
    uint64_t v4 = v5;
    char v6 = strerror(v5);
    sub_10004458C("verification/reading of the spaceman object failed: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  }
  return v4;
}

uint64_t sub_10002CB10(uint64_t *a1, uint64_t a2, uint64_t **a3)
{
  if (a2) {
    uint64_t v4 = (uint64_t *)(*(void *)(a2 + 40) + 128);
  }
  else {
    uint64_t v4 = (uint64_t *)(a1[1] + 160);
  }
  if (a2) {
    uint64_t v5 = (uint64_t **)(a2 + 72);
  }
  else {
    uint64_t v5 = (uint64_t **)(a1 + 4);
  }
  if (*v5) {
    goto LABEL_8;
  }
  uint64_t v7 = (uint64_t)(a1 + 14);
  if (a2) {
    uint64_t v7 = a2 + 104;
  }
  uint64_t v8 = sub_1000257B4(a1, a2, 0x40000000, *v4, 0, 0, 11, 0, v5, v7, 0);
  if (!v8)
  {
LABEL_8:
    uint64_t v6 = 0;
    if (a3) {
      *a3 = *v5;
    }
  }
  else
  {
    uint64_t v6 = v8;
    char v9 = strerror(v8);
    sub_10004458C("verification/reading of the omap object failed: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
  }
  return v6;
}

uint64_t sub_10002CBD8(uint64_t *a1, uint64_t a2)
{
  uint64_t result = sub_10002F148(*a1, *(void *)(a2 + 80));
  if (!result)
  {
    uint64_t v5 = *(void **)(a2 + 72);
    if (!v5) {
      return 0;
    }
    free(v5);
    *(void *)(a2 + 72) = 0;
    uint64_t result = sub_10002CB10(a1, a2, 0);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10002CC40(uint64_t *a1, unsigned int a2, uint64_t *a3)
{
  if (a2 > 2) {
    return 22;
  }
  char v5 = a2;
  uint64_t v8 = &a1[8 * (unint64_t)a2];
  uint64_t v9 = (uint64_t)(v8 + 17);
  if (!v8[24])
  {
    unint64_t v19 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v3 = sub_10002CA70(a1, &v19);
    if (v3) {
      return v3;
    }
    uint64_t v10 = sub_100038040(v9, (uint64_t)a1, 0, 0x80000000, 2, 9, 0, *(_DWORD *)(a1[1] + 36), 16, 8, 0, *(void *)(v19 + 40 * a2 + 208), (uint64_t)sub_100003E9C);
    if (v10)
    {
      uint64_t v3 = v10;
      strerror(v10);
      sub_10004458C("failed to initialize the spaceman free queue tree %d: %s\n", v11, v12, v13, v14, v15, v16, v17, v5);
      return v3;
    }
  }
  uint64_t v3 = 0;
  if (a3) {
    *a3 = v9;
  }
  return v3;
}

uint64_t sub_10002CD48(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  if (a2) {
    uint64_t v4 = a2 + 128;
  }
  else {
    uint64_t v4 = (uint64_t)(a1 + 41);
  }
  if (!*(void *)(v4 + 56))
  {
    long long v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v5 = sub_10002CB10(a1, a2, &v18);
    if (v5) {
      return v5;
    }
    uint64_t v8 = sub_100038040(v4, (uint64_t)a1, a2, v18[5] & 0xC0000000, (unsigned __int16)*((_DWORD *)v18 + 10), 11, 0, *(_DWORD *)(a1[1] + 36), 16, 16, 0, v18[6], (uint64_t)sub_10002097C);
    if (v8)
    {
      uint64_t v5 = v8;
      char v9 = strerror(v8);
      sub_10004458C("failed to initialize the omap tree: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
      return v5;
    }
  }
  uint64_t v5 = 0;
  if (a3) {
    *a3 = v4;
  }
  return v5;
}

uint64_t sub_10002CE38(uint64_t *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 192;
  if (!*(void *)(a2 + 248))
  {
    long long v18 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v5 = sub_10002CB10(a1, a2, &v18);
    if (v5) {
      return v5;
    }
    uint64_t v8 = sub_100038040(v4, (uint64_t)a1, a2, *((_DWORD *)v18 + 11) & 0xC0000000, (unsigned __int16)*((_DWORD *)v18 + 11), 19, 0, *(_DWORD *)(a1[1] + 36), 8, 16, 0, v18[7], (uint64_t)sub_1000306FC);
    if (v8)
    {
      uint64_t v5 = v8;
      char v9 = strerror(v8);
      sub_10004458C("failed to initialize the omap snap tree: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
      return v5;
    }
  }
  uint64_t v5 = 0;
  if (a3) {
    *a3 = v4;
  }
  return v5;
}

uint64_t sub_10002CF20(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = a1 + 392;
  if (*(void *)(a1 + 448)
    || (uint64_t v5 = sub_100038040(a1 + 392, a1, 0, 0x40000000, 2, 21, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 16, 0, *(void *)(*(void *)(a1 + 8) + 1352), (uint64_t)sub_10001D474), !v5))
  {
    uint64_t v4 = 0;
    if (a2) {
      *a2 = v3;
    }
  }
  else
  {
    uint64_t v4 = v5;
    char v6 = strerror(v5);
    sub_10004458C("failed to initialize the fusion middle tree: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  }
  return v4;
}

uint64_t sub_10002CFD8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a2 + 40);
  if ((*(unsigned char *)(v9 + 56) & 0x40) != 0)
  {
    uint64_t v11 = a2 + 576;
    if (*(void *)(a2 + 632)
      || (uint64_t v12 = sub_100038040(a2 + 576, a1, a2, *(_DWORD *)(v9 + 1044) & 0xC0000000, (unsigned __int16)*(_DWORD *)(v9 + 1044), 32, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 24, 0, *(void *)(v9 + 1048), (uint64_t)sub_1000306FC), !v12))
    {
      uint64_t v10 = 0;
      if (a3) {
        *a3 = v11;
      }
    }
    else
    {
      uint64_t v10 = v12;
      char v13 = strerror(v12);
      sub_10004458C("failed to initialize the pfkur tree: %s\n", v14, v15, v16, v17, v18, v19, v20, v13);
    }
  }
  else
  {
    sub_10004458C("get_pfkur_tree() called on non-pfk volume\n", a2, a2, a4, a5, a6, a7, a8, v22);
    return 22;
  }
  return v10;
}

uint64_t sub_10002D0B4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = *(void *)(a2 + 40);
  uint64_t v5 = *(void *)(v4 + 1072);
  if (!v5) {
    return 2;
  }
  uint64_t v6 = a2 + 640;
  if (*(void *)(a2 + 696)
    || (uint64_t v8 = sub_100038040(a2 + 640, a1, a2, *(_DWORD *)(v4 + 1068) & 0xC0000000, (unsigned __int16)*(_DWORD *)(v4 + 1068), 34, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 4, 8, 0, v5, (uint64_t)sub_1000306C8), !v8))
  {
    uint64_t v7 = 0;
    if (a3) {
      *a3 = v6;
    }
  }
  else
  {
    uint64_t v7 = v8;
    char v9 = strerror(v8);
    sub_10004458C("failed to initialize the doc-id tree: %s\n", v10, v11, v12, v13, v14, v15, v16, v9);
  }
  return v7;
}

uint64_t sub_10002D180(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 256;
  if (*(void *)(a2 + 312)
    || (uint64_t v6 = sub_100038040(v4, a1, a2, *(_DWORD *)(*(void *)(a2 + 40) + 124) & 0xC0000000, (unsigned __int16)*(_DWORD *)(*(void *)(a2 + 40) + 124), 16, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, 0, *(void *)(*(void *)(a2 + 40) + 152), (uint64_t)sub_10003DD34), !v6))
  {
    uint64_t v5 = 0;
    if (a3) {
      *a3 = v4;
    }
  }
  else
  {
    uint64_t v5 = v6;
    char v7 = strerror(v6);
    sub_10004458C("failed to initialize the snap meta tree: %s\n", v8, v9, v10, v11, v12, v13, v14, v7);
  }
  return v5;
}

uint64_t sub_10002D238(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 320;
  if (*(void *)(a2 + 376)
    || (uint64_t v6 = sub_100038040(v4, a1, a2, *(_DWORD *)(*(void *)(a2 + 40) + 120) & 0xC0000000, (unsigned __int16)*(_DWORD *)(*(void *)(a2 + 40) + 120), 15, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, 0, *(void *)(*(void *)(a2 + 40) + 144), (uint64_t)sub_10003DD34), !v6))
  {
    uint64_t v5 = 0;
    if (a3) {
      *a3 = v4;
    }
  }
  else
  {
    uint64_t v5 = v6;
    char v7 = strerror(v6);
    sub_10004458C("failed to initialize the extentref tree: %s\n", v8, v9, v10, v11, v12, v13, v14, v7);
  }
  return v5;
}

uint64_t sub_10002D2F0(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2[6];
  if (!v9) {
    uint64_t v9 = a2[5];
  }
  if ((*(unsigned char *)(v9 + 56) & 0x20) != 0)
  {
    uint64_t v11 = a2 + 48;
    if (a2[55]
      || (uint64_t v12 = sub_100038040((uint64_t)(a2 + 48), a1, (uint64_t)a2, *(_DWORD *)(a2[5] + 1040) & 0xC0000000, (unsigned __int16)*(_DWORD *)(a2[5] + 1040), 31, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 16, 16, 0, *(void *)(a2[5] + 1032), (uint64_t)sub_10003DCD8), !v12))
    {
      uint64_t v10 = 0;
      if (a3) {
        *a3 = v11;
      }
    }
    else
    {
      uint64_t v10 = v12;
      char v13 = strerror(v12);
      sub_10004458C("failed to initialize the fext tree: %s\n", v14, v15, v16, v17, v18, v19, v20, v13);
    }
  }
  else
  {
    sub_10004458C("get_fext_tree() called on unsealed volume\n", a1, (uint64_t)a2, a4, a5, a6, a7, a8, v22);
    return 22;
  }
  return v10;
}

uint64_t sub_10002D3D4(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 448;
  if (*(void *)(a2 + 504)) {
    goto LABEL_2;
  }
  uint64_t v6 = *(void *)(a2 + 40);
  int v7 = *(_DWORD *)(v6 + 116);
  uint64_t v8 = *(void *)(v6 + 136);
  if (*(void *)(a2 + 48)) {
    uint64_t v6 = *(void *)(a2 + 48);
  }
  if ((*(unsigned char *)(v6 + 56) & 0x20) != 0)
  {
    int v9 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
  }
  else
  {
    int v9 = 0;
    int v10 = 0;
  }
  uint64_t v11 = sub_100038040(v4, a1, a2, v7 & 0xC0000000, (unsigned __int16)v7, 14, v9, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, v10, v8, (uint64_t)sub_10003DD34);
  if (!v11)
  {
LABEL_2:
    uint64_t v5 = 0;
    if (a3) {
      *a3 = v4;
    }
  }
  else
  {
    uint64_t v5 = v11;
    char v12 = strerror(v11);
    sub_10004458C("failed to initialize the fsroot tree: %s\n", v13, v14, v15, v16, v17, v18, v19, v12);
  }
  return v5;
}

uint64_t sub_10002D4A8(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v4 = a2 + 512;
  if (*(void *)(a2 + 568)) {
    goto LABEL_2;
  }
  uint64_t v6 = *(void *)(a2 + 40);
  int v7 = *(_DWORD *)(v6 + 1104);
  uint64_t v8 = *(void *)(v6 + 1096);
  if (*(void *)(a2 + 48)) {
    uint64_t v6 = *(void *)(a2 + 48);
  }
  if ((*(unsigned char *)(v6 + 56) & 0x20) != 0)
  {
    int v9 = *(_DWORD *)(a2 + 16);
    int v10 = *(_DWORD *)(a2 + 20);
  }
  else
  {
    int v9 = 0;
    int v10 = 0;
  }
  uint64_t v11 = sub_100038040(v4, a1, a2, v7 & 0xC0000000, (unsigned __int16)v7, 36, v9, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, v10, v8, (uint64_t)sub_10003DD34);
  if (!v11)
  {
LABEL_2:
    uint64_t v5 = 0;
    if (a3) {
      *a3 = v4;
    }
  }
  else
  {
    uint64_t v5 = v11;
    char v12 = strerror(v11);
    sub_10004458C("failed to initialize the secondary fsroot tree: %s\n", v13, v14, v15, v16, v17, v18, v19, v12);
  }
  return v5;
}

uint64_t sub_10002D57C(int a1, dev_t *a2, _DWORD *a3, int *a4, dev_t *a5)
{
  if (a2)
  {
    v42.dev_t st_dev = -1431655766;
    if (ioctl(a1, 0x4004644CuLL, &v42))
    {
      if (*__error() != 25)
      {
        int v10 = __error();
        uint64_t v11 = strerror(*v10);
        sub_10002B1C4("%s:%d: can't get features for device (%s)\n", "io_get_device_features", 182, v11);
      }
      dev_t st_dev = 0;
    }
    else
    {
      dev_t st_dev = v42.st_dev;
    }
    *a2 = st_dev;
  }
  if (a3) {
    *a3 = (fcntl(a1, 3) & 3) != 0;
  }
  if (!a4) {
    goto LABEL_14;
  }
  v13.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v13.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v42.st_blksize = v13;
  *(timespec *)v42.st_qspare = v13;
  v42.st_birthtimespec = v13;
  *(timespec *)&v42.st_size = v13;
  v42.st_mtimespec = v13;
  v42.st_ctimespec = v13;
  *(timespec *)&v42.st_uid = v13;
  v42.st_atimespec = v13;
  *(timespec *)&v42.dev_t st_dev = v13;
  if (fstat(a1, &v42) || (v42.st_mode & 0xB000 | 0x4000) != 0x6000 || (CFMutableDictionaryRef v18 = IOServiceMatching("IOMedia")) == 0)
  {
LABEL_12:
    int v14 = 0;
    goto LABEL_13;
  }
  uint64_t v19 = v18;
  int v40 = v42.st_rdev & 0xFFFFFF;
  unsigned int valuePtr = HIBYTE(v42.st_rdev);
  CFNumberRef v20 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v20)
  {
    CFNumberRef v21 = v20;
    CFDictionarySetValue(v19, @"BSD Major", v20);
    CFRelease(v21);
  }
  CFNumberRef v22 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v40);
  if (v22)
  {
    CFNumberRef v23 = v22;
    CFDictionarySetValue(v19, @"BSD Minor", v22);
    CFRelease(v23);
  }
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v19);
  if (!MatchingService)
  {
    sub_10002B178("%s:%d: fd %d is type %o rdev %d (%d, %d): I/O registry entry not found\n", "io_get_device_features", 230, a1, v42.st_mode & 0xF000, v42.st_rdev, HIBYTE(v42.st_rdev), v42.st_rdev & 0xFFFFFF);
    goto LABEL_12;
  }
  io_object_t v25 = MatchingService;
  IOObjectRetain(MatchingService);
  iterator[0] = -1431655766;
  io_object_t v26 = v25;
  while (1)
  {
    io_registry_entry_t parent = -1431655766;
    if (IOObjectConformsTo(v26, "AppleAPFSContainerScheme")) {
      break;
    }
    if (IOObjectConformsTo(v26, "IOBlockStorageDevice")) {
      goto LABEL_43;
    }
    if (IORegistryEntryGetParentEntry(v26, "IOService", &parent)) {
      io_registry_entry_t parent = 0;
    }
    IOObjectRelease(v26);
    io_object_t v26 = parent;
    if (!parent)
    {
      int v14 = 0;
      goto LABEL_45;
    }
  }
  CFDictionaryRef v28 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(v26, "IOService", @"Device Characteristics", kCFAllocatorDefault, 3u);
  if (v28)
  {
    CFDictionaryRef v29 = v28;
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v28, @"Target Disk Mode");
    if (Value)
    {
      int v31 = CFBooleanGetValue(Value);
      CFRelease(v29);
      if (v31)
      {
LABEL_43:
        int v14 = 0;
        goto LABEL_44;
      }
    }
    else
    {
      CFRelease(v29);
    }
  }
  if (IORegistryEntryGetParentIterator(v26, "IOService", iterator)) {
    goto LABEL_43;
  }
  while (1)
  {
    io_object_t v32 = IOIteratorNext(iterator[0]);
    if (!v32) {
      break;
    }
    io_registry_entry_t v33 = v32;
    if (sub_10002E274(v32, @"image-format-read-only"))
    {
      BOOL v34 = 0;
    }
    else
    {
      if (!sub_10002E274(v33, @"Removable"))
      {
        CFTypeRef v35 = IORegistryEntrySearchCFProperty(v33, "IOService", @"Protocol Characteristics", kCFAllocatorDefault, 3u);
        if (v35)
        {
          uint64_t v36 = v35;
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(v36)) {
            goto LABEL_56;
          }
          uint64_t v38 = CFDictionaryGetValue((CFDictionaryRef)v36, @"Physical Interconnect Location");
          if (!v38) {
            goto LABEL_57;
          }
          CFTypeID v39 = CFStringGetTypeID();
          if (v39 == CFGetTypeID(v38)) {
            LODWORD(v38) = CFEqual(v38, @"Internal") == 0;
          }
          else {
LABEL_56:
          }
            LODWORD(v38) = 0;
LABEL_57:
          CFRelease(v36);
        }
        else
        {
          LODWORD(v38) = 0;
        }
        BOOL v34 = v38 != 0;
        goto LABEL_60;
      }
      BOOL v34 = 1;
    }
LABEL_60:
    IOObjectRelease(v33);
    if (v34)
    {
      int v14 = 1;
      goto LABEL_63;
    }
  }
  int v14 = 0;
LABEL_63:
  IOObjectRelease(iterator[0]);
LABEL_44:
  IOObjectRelease(v26);
LABEL_45:
  IOObjectRelease(v25);
LABEL_13:
  *a4 = v14;
LABEL_14:
  if (a5)
  {
    v42.dev_t st_dev = -1431655766;
    if (ioctl(a1, 0x4004644FuLL, &v42))
    {
      if (*__error() != 25)
      {
        uint64_t v15 = __error();
        uint64_t v16 = strerror(*v15);
        sub_10002B1C4("%s:%d: can't get solidstate for device (%s)\n", "io_get_device_features", 246, v16);
      }
      dev_t v17 = 1;
    }
    else
    {
      dev_t v17 = v42.st_dev;
    }
    *a5 = v17;
  }
  return 0;
}

uint64_t sub_10002DA48(io_object_t *a1, unsigned char *a2)
{
  if (a2) {
    *a2 = 0;
  }
  BOOLean_t v4 = IOObjectConformsTo(*a1, "AppleAPFSSnapshot");
  io_registry_entry_t v5 = *a1;
  if (v4)
  {
    io_registry_entry_t parent = -1431655766;
    if (IORegistryEntryGetParentEntry(v5, "IOService", &parent)) {
      return 0;
    }
    IOObjectRelease(*a1);
    io_registry_entry_t v5 = parent;
    *a1 = parent;
    if (a2) {
      *a2 = 1;
    }
  }
  uint64_t result = IOObjectConformsTo(v5, "AppleAPFSVolume");
  if (result) {
    return *a1;
  }
  return result;
}

const char *sub_10002DAEC(const char *a1)
{
  uint64_t v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114) {
      ++v1;
    }
  }
  return v1;
}

unint64_t sub_10002DB30(char *a1, _DWORD *a2)
{
  if (!sub_10002DBB4(a1)) {
    return 0;
  }
  unint64_t result = (unint64_t)strrchr(a1, 115);
  if (result)
  {
    unint64_t v5 = result;
    unint64_t result = strtoul((const char *)(result + 1), 0, 10);
    if (result)
    {
      int v6 = result;
      unint64_t result = (unint64_t)strndup(a1, v5 - (void)a1);
      if (result)
      {
        if (a2) {
          *a2 = v6 - 1;
        }
      }
    }
  }
  return result;
}

BOOL sub_10002DBB4(const char *a1)
{
  uint64_t v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114) {
      ++v1;
    }
  }
  CFDictionaryRef v3 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v3);
  if (!MatchingService) {
    return 0;
  }
  io_object_t v5 = MatchingService;
  BOOL v6 = IOObjectConformsTo(MatchingService, "AppleAPFSVolume") != 0;
  IOObjectRelease(v5);
  return v6;
}

BOOL sub_10002DC4C(const char *a1)
{
  return sub_10002DC58(a1, "Encrypted");
}

BOOL sub_10002DC58(const char *a1, const char *a2)
{
  CFBooleanRef v2 = (CFBooleanRef)sub_10002DCAC(a1, a2);
  if (!v2) {
    return 0;
  }
  BOOL v3 = v2 == kCFBooleanTrue;
  CFRelease(v2);
  return v3;
}

BOOL sub_10002DCA0(const char *a1)
{
  return sub_10002DC58(a1, "multiKeyEncryption");
}

CFTypeRef sub_10002DCAC(const char *a1, const char *a2)
{
  BOOL v3 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v4 = *((unsigned __int8 *)v3 + 5);
    v3 += 5;
    if (v4 == 114) {
      ++v3;
    }
  }
  if (*v3 == 114) {
    io_object_t v5 = v3 + 1;
  }
  else {
    io_object_t v5 = v3;
  }
  CFDictionaryRef v6 = IOBSDNameMatching(kIOMasterPortDefault, 0, v5);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
  if (!MatchingService) {
    return 0;
  }
  io_registry_entry_t v8 = MatchingService;
  CFStringRef v9 = CFStringCreateWithCString(0, a2, 0x8000100u);
  if (v9)
  {
    CFStringRef v10 = v9;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v8, v9, kCFAllocatorDefault, 0);
    CFRelease(v10);
  }
  else
  {
    CFTypeRef CFProperty = 0;
  }
  IOObjectRelease(v8);
  return CFProperty;
}

uint64_t sub_10002DD94(io_registry_entry_t a1, const char *a2)
{
  io_iterator_t iterator = -1431655766;
  if (IORegistryEntryGetChildIterator(a1, "IOService", &iterator)) {
    return 0;
  }
  while (1)
  {
    uint64_t v4 = IOIteratorNext(iterator);
    uint64_t v3 = v4;
    if (!v4 || IOObjectConformsTo(v4, a2)) {
      break;
    }
    IOObjectRelease(v3);
  }
  IOObjectRelease(iterator);
  return v3;
}

uint64_t sub_10002DE14(char *a1, int a2)
{
  uint64_t v4 = strrchr(a1, 115);
  if (!v4) {
    return 0xFFFFFFFFLL;
  }
  if (a2)
  {
    io_object_t v5 = v4 - 1;
    while (v5 > a1)
    {
      int v7 = *v5--;
      char v6 = v7;
      if ((v7 - 48) >= 0xA)
      {
        if (v6 != 115) {
          return 0xFFFFFFFFLL;
        }
        uint64_t v4 = v5 + 1;
        goto LABEL_8;
      }
    }
    return 0xFFFFFFFFLL;
  }
LABEL_8:
  if (v4 <= a1 || *(v4 - 1) == 47) {
    return 0xFFFFFFFFLL;
  }
  return strtoul(v4 + 1, 0, 10) - 1;
}

const char *sub_10002DEA4(const char *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (!strncmp(result, "/dev/", 5uLL))
    {
      int v2 = *((unsigned __int8 *)v1 + 5);
      v1 += 5;
      if (v2 == 114) {
        ++v1;
      }
    }
    CFDictionaryRef v3 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
    return (const char *)IOServiceGetMatchingService(kIOMasterPortDefault, v3);
  }
  return result;
}

const char *sub_10002DF20(const char *a1, unsigned char *a2)
{
  unint64_t result = sub_10002DEA4(a1);
  io_object_t object = result;
  if (result)
  {
    int v4 = sub_10002DA48(&object, a2);
    unint64_t result = (const char *)object;
    if (!v4)
    {
      IOObjectRelease(object);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10002DF74(io_registry_entry_t a1)
{
  io_iterator_t v9 = -1431655766;
  io_iterator_t iterator = -1431655766;
  io_iterator_t object = -1431655766;
  if (IORegistryEntryGetChildIterator(a1, "IOService", &iterator)) {
    return 0;
  }
  io_object_t v2 = IOIteratorNext(iterator);
  if (!v2)
  {
LABEL_19:
    uint64_t v1 = 0;
    io_iterator_t v5 = iterator;
    goto LABEL_21;
  }
  io_object_t v3 = v2;
  while (1)
  {
    if (!IOObjectConformsTo(v3, "AppleAPFSContainerScheme") || IORegistryEntryGetChildIterator(v3, "IOService", &v9)) {
      goto LABEL_18;
    }
    io_object_t v4 = IOIteratorNext(v9);
    if (v4) {
      break;
    }
LABEL_17:
    IOObjectRelease(v9);
LABEL_18:
    IOObjectRelease(v3);
    io_object_t v3 = IOIteratorNext(iterator);
    if (!v3) {
      goto LABEL_19;
    }
  }
  io_iterator_t v5 = v4;
  while (1)
  {
    if (!IOObjectConformsTo(v5, "AppleAPFSMedia") || IORegistryEntryGetChildIterator(v5, "IOService", &object)) {
      goto LABEL_16;
    }
    uint64_t v6 = IOIteratorNext(object);
    if (v6) {
      break;
    }
LABEL_15:
    IOObjectRelease(object);
LABEL_16:
    IOObjectRelease(v5);
    io_iterator_t v5 = IOIteratorNext(v9);
    if (!v5) {
      goto LABEL_17;
    }
  }
  uint64_t v1 = v6;
  while (!IOObjectConformsTo(v1, "AppleAPFSContainer"))
  {
    IOObjectRelease(v1);
    uint64_t v1 = IOIteratorNext(object);
    if (!v1) {
      goto LABEL_15;
    }
  }
  IOObjectRelease(iterator);
  IOObjectRelease(v9);
  IOObjectRelease(object);
  IOObjectRelease(v3);
LABEL_21:
  IOObjectRelease(v5);
  return v1;
}

uint64_t sub_10002E110(char *__s, _DWORD *a2, io_connect_t *a3, io_registry_entry_t *a4, int a5)
{
  io_registry_entry_t parent = -1431655766;
  if (a2)
  {
    io_iterator_t v9 = strrchr(__s, 47);
    if (v9) {
      CFStringRef v10 = v9 + 1;
    }
    else {
      CFStringRef v10 = __s;
    }
    unsigned __int8 v20 = 0;
    io_registry_entry_t v11 = sub_10002DF20(v10, &v20);
    if (v11)
    {
      io_object_t v12 = v11;
      if (IORegistryEntryGetParentEntry(v11, "IOService", &parent))
      {
        uint64_t v13 = 49158;
LABEL_24:
        IOObjectRelease(v12);
        return v13;
      }
      if (IOObjectConformsTo(parent, "AppleAPFSContainer"))
      {
        int v17 = sub_10002DE14(v10, v20);
        *a2 = v17;
        if (v17 != -1)
        {
          io_service_t v16 = parent;
LABEL_17:
          uint64_t v13 = IOServiceOpen(v16, mach_task_self_, 0, a3);
          io_object_t v18 = parent;
          if (a4 && !v13)
          {
            *a4 = parent;
            goto LABEL_24;
          }
LABEL_23:
          IOObjectRelease(v18);
          goto LABEL_24;
        }
        uint64_t v13 = 49154;
      }
      else
      {
        uint64_t v13 = 49231;
      }
      io_object_t v18 = parent;
      goto LABEL_23;
    }
  }
  else
  {
    io_registry_entry_t v15 = sub_10002DEA4(__s);
    if (v15)
    {
      io_object_t v12 = v15;
      io_service_t v16 = sub_10002DD94(v15, "AppleAPFSContainer");
      io_registry_entry_t parent = v16;
      if (!v16)
      {
        if (!a5 || (io_service_t v16 = sub_10002DF74(v12), (parent = v16) == 0))
        {
          uint64_t v13 = 49231;
          goto LABEL_24;
        }
      }
      goto LABEL_17;
    }
  }
  return 49154;
}

BOOL sub_10002E274(io_registry_entry_t a1, CFStringRef key)
{
  CFBooleanRef v2 = (CFBooleanRef)IORegistryEntrySearchCFProperty(a1, "IOService", key, kCFAllocatorDefault, 3u);
  if (!v2) {
    return 0;
  }
  BOOL v3 = v2 == kCFBooleanTrue;
  CFRelease(v2);
  return v3;
}

uint64_t sub_10002E2D8(uint64_t a1, uint64_t a2)
{
  if (((*(_DWORD *)(*(void *)(a2 + 40) + 264) | 0x100u) & 0x109) == 0x100)
  {
    unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v3 = sub_10002E710(a1, a2, &v73, &v72);
    if (v3)
    {
      uint64_t v11 = v3;
      if (v3 != 2)
      {
        sub_10004458C("iOS encryption rolling state object: cannot get ierso xattr\n", v4, v5, v6, v7, v8, v9, v10, v71);
        uint64_t v12 = 1143;
LABEL_12:
        sub_100048B34((char *)v12, v11);
        return v11;
      }
      return 0;
    }
    CFNumberRef v21 = (void *)v73;
    if (v72 <= 4)
    {
      sub_10004458C("iOS encryption rolling state object: xattr record too small (%zu)\n", v4, v5, v6, v7, v8, v9, v10, v72);
      uint64_t v11 = 92;
      uint64_t v22 = 1136;
LABEL_19:
      int v25 = 92;
LABEL_20:
      sub_100048B34((char *)v22, v25);
LABEL_21:
      CFNumberRef v23 = v21;
      goto LABEL_22;
    }
    if ((*(_WORD *)v73 & 3) != 2)
    {
      sub_10004458C("iOS encryption rolling state object: xattr invalid storage type, flags (%hu)\n", v4, v5, v6, v7, v8, v9, v10, *(_WORD *)v73);
      uint64_t v11 = 92;
      uint64_t v22 = 1137;
      goto LABEL_19;
    }
    uint64_t v24 = *(unsigned __int16 *)(v73 + 2);
    if (v24 + 4 != v72)
    {
      sub_10004458C("iOS encryption rolling state object: xattr payload (%hu) does not match record size (%zu)\n", v4, v5, v6, v7, v8, v9, v10, *(_WORD *)(v73 + 2));
      uint64_t v11 = 92;
      uint64_t v22 = 1138;
      goto LABEL_19;
    }
    if (v24 <= 3)
    {
      sub_10004458C("iOS encryption rolling state object: xattr payload (%hu) is too small\n", v4, v5, v6, v7, v8, v9, v10, *(_WORD *)(v73 + 2));
      uint64_t v11 = 92;
      uint64_t v22 = 1139;
      goto LABEL_19;
    }
    uint64_t v27 = *(unsigned int *)(v73 + 4);
    if (v27 > 2)
    {
      sub_100044674("iOS encryption rolling state object: ierso version (%u) unrecognized\n", v4, v5, v6, v7, v8, v9, v10, *(_DWORD *)(v73 + 4));
      sub_100048B34((char *)0x474, -6);
      uint64_t v11 = 0;
      goto LABEL_21;
    }
    if (qword_10006F380[v27] != v24)
    {
      sub_10004458C("iOS encryption rolling state object: size (%u), version (%u) does not match expected size (%zu)\n", v4, v5, v6, v7, v8, v9, v10, v24);
      uint64_t v11 = 92;
      uint64_t v22 = 1141;
      goto LABEL_19;
    }
    CFDictionaryRef v28 = (char *)malloc_type_calloc(1uLL, 0x170uLL, 0x1000040BCF37258uLL);
    if (!v28)
    {
      sub_10004458C("iOS encryption rolling state object: failed to allocate ierso\n", v29, v30, v31, v32, v33, v34, v35, v71);
      uint64_t v11 = 12;
      uint64_t v22 = 1142;
      int v25 = 12;
      goto LABEL_20;
    }
    uint64_t v36 = v28;
    __memcpy_chk();
    int v44 = *(_DWORD *)v36;
    if (!*(_DWORD *)v36) {
      *((_DWORD *)v36 + 8) = 1;
    }
    uint64_t v45 = 48;
    if (!*(void *)(a2 + 56)) {
      uint64_t v45 = 40;
    }
    uint64_t v46 = *(void *)(a2 + v45);
    unint64_t v48 = *((void *)v36 + 1);
    unint64_t v47 = *((void *)v36 + 2);
    unint64_t v49 = *(void *)(v46 + 176);
    if (v47 > v48 || (v48 < v49 ? (BOOL v50 = v49 >> 60 == 0) : (BOOL v50 = 0), !v50))
    {
      sub_10004458C("iOS encryption rolling state object: epoch unordered: current_id (%llu) <= epoch (%llu) < apfs_next_obj_id (%llu) <= MAX_JOBJ_ID (%llu)\n", v37, v38, v39, v40, v41, v42, v43, v47);
      uint64_t v11 = 92;
      uint64_t v51 = 1128;
LABEL_38:
      sub_100048B34((char *)v51, 92);
LABEL_39:
      free(v36);
      goto LABEL_21;
    }
    if (*((void *)v36 + 3) >> 55)
    {
      sub_10004458C("iOS encryption rolling state object: current_offset (%llu) too large\n", v37, v38, v39, v40, v41, v42, v43, *((void *)v36 + 3));
      uint64_t v11 = 92;
      uint64_t v51 = 1129;
      goto LABEL_38;
    }
    int v52 = *((_DWORD *)v36 + 8);
    if ((v52 - 1) >= 2)
    {
      sub_10004458C("iOS encryption rolling state object: (version %u) invalid policy (%u)\n", v37, v38, v39, v40, v41, v42, v43, v44);
      uint64_t v11 = 92;
      uint64_t v51 = 1130;
      goto LABEL_38;
    }
    unsigned int v53 = *((_DWORD *)v36 + 9);
    if (v52 == 1)
    {
      if (v53 >= 2)
      {
        sub_10004458C("iOS encryption rolling state object: (version %u) lite rolling has invalid current_state (%u)\n", v37, v38, v39, v40, v41, v42, v43, v44);
        uint64_t v51 = 1131;
LABEL_64:
        uint64_t v11 = 92;
        goto LABEL_38;
      }
    }
    else if (v53 == 2)
    {
      if (!memchr(v36 + 40, 0, 0x80uLL))
      {
        sub_10004458C("iOS encryption rolling state object: current_xattr is unterminated\n", v54, v55, v56, v57, v58, v59, v60, v71);
        uint64_t v11 = 92;
        uint64_t v51 = 1134;
        goto LABEL_38;
      }
    }
    else if (v53 != 1)
    {
      if (v53)
      {
        sub_10004458C("iOS encryption rolling state object: (version %u) full rolling has unrecognized current_state (%u)\n", v37, v38, v39, v40, v41, v42, v43, v44);
        uint64_t v51 = 1133;
        goto LABEL_64;
      }
      if (v47)
      {
        sub_10004458C("iOS encryption rolling state object: (version %u) current_state unset, yet non-zero current_id (%llu)", v37, v38, v39, v40, v41, v42, v43, v44);
        uint64_t v51 = 1132;
        goto LABEL_64;
      }
    }
    uint64_t v61 = sub_1000104DC();
    uint64_t v69 = *((void *)v36 + 21);
    uint64_t v70 = *((void *)v36 + 22);
    if (!v69) {
      uint64_t v69 = v61;
    }
    if (!v70) {
      uint64_t v70 = v61;
    }
    if (v69 > v70 || v70 > v61)
    {
      sub_100044674("iOS encryption rolling state object: (version %u) timestamps unordered: start_time (%llu) <= end_time (%llu) <= current_time (%llu)\n", v62, v63, v64, v65, v66, v67, v68, *(_DWORD *)v36);
      sub_100048B34((char *)0x46F, -4);
    }
    uint64_t v11 = 0;
    goto LABEL_39;
  }
  unint64_t v73 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_10002E710(a1, a2, &v73, &v72);
  if (!v13)
  {
    sub_10004458C("iOS encryption rolling state object: non-iOS content protected volume unexpectedly has ierso\n", v14, v15, v16, v17, v18, v19, v20, v71);
    uint64_t v11 = 92;
    sub_100048B34((char *)0x479, 92);
    CFNumberRef v23 = (void *)v73;
LABEL_22:
    free(v23);
    return v11;
  }
  uint64_t v11 = v13;
  if (v13 != 2)
  {
    sub_10004458C("iOS encryption rolling state object: cannot determine absence of ierso xattr\n", v14, v15, v16, v17, v18, v19, v20, v71);
    uint64_t v12 = 1144;
    goto LABEL_12;
  }
  return 0;
}

uint64_t sub_10002E710(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unsigned int v23 = 38;
  unsigned int v22 = 3804;
  uint64_t v24 = 0x4000000000000003;
  __int16 v25 = 28;
  strcpy(v26, "com.apple.system.apfs.ierso");
  uint64_t v8 = malloc_type_malloc(0xEDCuLL, 0xFE272209uLL);
  if (!v8) {
    return 12;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void *)(a2 + 48);
  uint64_t v11 = 48;
  if (!*(void *)(a2 + 56)) {
    uint64_t v11 = 40;
  }
  uint64_t v12 = *(void *)(a2 + v11);
  uint64_t v13 = *(void *)(a2 + 48);
  if (!v10) {
    uint64_t v13 = *(void *)(a2 + 40);
  }
  int v14 = *(_DWORD *)(v12 + 116);
  uint64_t v15 = *(void *)(v12 + 136);
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v21[2] = v16;
  v21[3] = v16;
  v21[0] = v16;
  v21[1] = v16;
  if ((*(unsigned char *)(v13 + 56) & 0x20) != 0) {
    int v17 = *(_DWORD *)(a2 + 16);
  }
  else {
    int v17 = 0;
  }
  if (!v10) {
    uint64_t v10 = *(void *)(a2 + 40);
  }
  if ((*(unsigned char *)(v10 + 56) & 0x20) != 0) {
    int v19 = *(_DWORD *)(a2 + 20);
  }
  else {
    int v19 = 0;
  }
  uint64_t v18 = sub_100038040((uint64_t)v21, a1, a2, v14 & 0xC0000000, (unsigned __int16)v14, 14, v17, *(_DWORD *)(*(void *)(a1 + 8) + 36), 0, 0, v19, v15, (uint64_t)sub_10003DD34);
  if (v18
    || (uint64_t v18 = sub_1000380B0((uint64_t)v21, *(void *)(a2 + 56), 0, &v24, &v23, 0x26u, v9, &v22), v18))
  {
    free(v9);
  }
  else
  {
    *a3 = v9;
    *a4 = v22;
  }
  return v18;
}

uint64_t sub_10002E8D0(uint64_t **a1, void **a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  unint64_t v22 = 0;
  uint64_t v8 = 22;
  if (a3 <= 0x7FFFFFF)
  {
    if (a3 == 0x80000000)
    {
      uint64_t v9 = sub_100030DD0(*a1, a5, 0, 0, (uint64_t)&v20);
    }
    else
    {
      if (a3) {
        goto LABEL_17;
      }
      uint64_t v9 = sub_1000209D8(*a1, (uint64_t)a1[1], a5, a4, (uint64_t)&v20);
    }
    uint64_t v8 = v9;
    if (!v9)
    {
      int v12 = v21;
      int v13 = *((_DWORD *)a1 + 6);
      goto LABEL_14;
    }
LABEL_17:
    int v14 = *a2;
    if (!*a2)
    {
      int v14 = malloc_type_malloc(*((unsigned int *)a1 + 6), 0x81874D51uLL);
      *a2 = v14;
      if (!v14) {
        return 12;
      }
    }
    if (!v8)
    {
      uint64_t v15 = **a1;
      if ((v21 & 0x400000000) != 0)
      {
        int v19 = a1[1];
        if ((WORD2(v21) & 0x700) == 0x100) {
          int v17 = 4;
        }
        else {
          int v17 = 0;
        }
        if ((WORD2(v21) & 0x700) == 0x100) {
          unint64_t v18 = a5 ^ HIDWORD(v22) | a5 & 0xFFFFFFFF00000000 ^ (v22 << 32);
        }
        else {
          unint64_t v18 = 0;
        }
        if (v19)
        {
          if (v19[(BYTE4(v21) >> 5) + 3])
          {
            uint64_t v15 = v19[(BYTE4(v21) >> 5) + 3];
            uint64_t v16 = (uint64_t)&v19[12 * (BYTE4(v21) >> 5) + 96];
          }
          else
          {
            uint64_t v16 = 0;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
      }
      else
      {
        uint64_t v16 = 0;
        int v17 = 0;
        unint64_t v18 = 0;
      }
      return sub_10002F238(v15, v20, v21 / *(_DWORD *)((*a1)[1] + 36), (uint64_t)v14, v16, 0, 0, v18, v17);
    }
    return v8;
  }
  if (a3 == 0x40000000)
  {
    LODWORD(v21) = *((_DWORD *)a1 + 6);
    int v13 = v21;
    uint64_t v20 = a5;
    int v12 = v21;
LABEL_14:
    if (v12 == v13) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = 22;
    }
    goto LABEL_17;
  }
  if (a3 != 0x8000000) {
    goto LABEL_17;
  }
  uint64_t v10 = *((unsigned int *)a1 + 6);

  return sub_10001D3CC(v10, a5, a2);
}

uint64_t sub_10002EAB0(uint64_t **a1, void *__src, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  unint64_t v19 = 0;
  uint64_t result = 22;
  if (a3 <= 0x7FFFFFF)
  {
    if (a3 == 0x80000000)
    {
      uint64_t result = sub_100030DD0(*a1, a5, 0, 0, (uint64_t)&v17);
      if (result) {
        return result;
      }
    }
    else
    {
      if (a3) {
        return result;
      }
      uint64_t result = sub_1000209D8(*a1, a1[1], a5, a4, &v17);
      if (result) {
        return result;
      }
    }
    unsigned int v10 = *((_DWORD *)a1 + 6);
    if (v18 != v10) {
      return 22;
    }
    goto LABEL_15;
  }
  if (a3 == 0x40000000)
  {
    unsigned int v10 = *((_DWORD *)a1 + 6);
    LODWORD(v18) = v10;
    uint64_t v17 = a5;
LABEL_15:
    uint64_t v11 = **a1;
    if ((v18 & 0x400000000) != 0)
    {
      uint64_t v15 = a1[1];
      if ((WORD2(v18) & 0x700) == 0x100) {
        int v13 = 4;
      }
      else {
        int v13 = 0;
      }
      if ((WORD2(v18) & 0x700) == 0x100) {
        unint64_t v14 = a5 ^ HIDWORD(v19) | a5 & 0xFFFFFFFF00000000 ^ (v19 << 32);
      }
      else {
        unint64_t v14 = 0;
      }
      if (v15)
      {
        if (v15[(BYTE4(v18) >> 5) + 3])
        {
          uint64_t v11 = v15[(BYTE4(v18) >> 5) + 3];
          uint64_t v12 = (uint64_t)&v15[12 * (BYTE4(v18) >> 5) + 96];
        }
        else
        {
          uint64_t v12 = 0;
        }
      }
      else
      {
        uint64_t v12 = 0;
      }
    }
    else
    {
      uint64_t v12 = 0;
      int v13 = 0;
      unint64_t v14 = 0;
    }
    uint64_t result = sub_10002F308(v11, v17, v10 / *(_DWORD *)((*a1)[1] + 36), (uint64_t)__src, v12, v14, v13);
    if (!result)
    {
      uint64_t v16 = a1[1];
      uint64_t result = 0;
      if (v16) {
        *((unsigned char *)v16 + 12) = 1;
      }
    }
    return result;
  }
  if (a3 == 0x8000000)
  {
    size_t v9 = *((unsigned int *)a1 + 6);
    return sub_10001D404(v9, a5, __src);
  }
  return result;
}

uint64_t sub_10002EC6C(uint64_t **a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7 = a5;
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  if (a3 && a5) {
    return 22;
  }
  if (a3 && a3 != 0x40000000)
  {
    if (a3 != 0x8000000) {
      return 45;
    }
    uint64_t result = sub_10001D240(*((unsigned int *)a1 + 6), &v28, a2);
    if (!result) {
      *a6 = v28;
    }
    return result;
  }
  int v13 = *a1;
  if (!(*a1)[3]) {
    return 22;
  }
  unint64_t v14 = (int8x16_t *)a1[1];
  unint64_t v15 = (*((_DWORD *)a1 + 6) / *(_DWORD *)(v13[1] + 36));
  if (v14)
  {
    BOOL v16 = (*(void *)(v14[2].i64[1] + 264) & 1) == 0;
    if ((*(void *)(v14[2].i64[1] + 264) & 1) == 0 && !a3)
    {
      uint64_t result = sub_1000040C4(v13, v14, 0, v15, (uint64_t *)&v28);
      if (result) {
        return result;
      }
      BOOL v16 = 1;
      goto LABEL_28;
    }
  }
  else
  {
    BOOL v16 = 0;
  }
  if (*((_DWORD *)a1 + 12) == 11) {
    unsigned int v17 = 2;
  }
  else {
    unsigned int v17 = 1;
  }
  uint64_t result = sub_1000040C4(v13, v14, v17, v15, (uint64_t *)&v28);
  if (result) {
    return result;
  }
  if (a3)
  {
    uint64_t v7 = v28;
LABEL_24:
    *a6 = v7;
    if (!a2) {
      return 0;
    }
    if (*a2) {
      return 0;
    }
    uint64_t v18 = malloc_type_malloc(*((unsigned int *)a1 + 6), 0x4C153983uLL);
    *a2 = v18;
    if (v18) {
      return 0;
    }
    else {
      return 12;
    }
  }
LABEL_28:
  if (!v7)
  {
    uint64_t v19 = (*a1)[1];
    uint64_t v7 = *(void *)(v19 + 88);
    *(void *)(v19 + 88) = v7 + 1;
  }
  DWORD2(v28) = *((_DWORD *)a1 + 6);
  uint64_t v20 = (uint64_t)a1[1];
  if (v16)
  {
    int v21 = HIDWORD(v28) | 4;
    uint64_t v22 = *(void *)(v20 + 72);
    if (v22 && (*(unsigned char *)(v22 + 32) & 0x10) != 0) {
      int v21 = HIDWORD(v28) | 0x14;
    }
    HIDWORD(v28) = v21 & 0xFFFFFF1F | (32 * (*(void *)(*(void *)(v20 + 40) + 1096) != 0));
  }
  uint64_t v23 = (uint64_t)*a1;
  long long v26 = v28;
  uint64_t v27 = v29;
  uint64_t result = sub_100020AB0(v23, v20, v7, a4, (int32x2_t *)&v26);
  if (!result)
  {
    uint64_t result = sub_10003078C(*a1, v24, v25);
    if (!result) {
      goto LABEL_24;
    }
  }
  return result;
}

uint64_t sub_10002EE6C(uint64_t a1, int a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  memset(v18, 0, sizeof(v18));
  if (a2 != 0x8000000)
  {
    if ((a2 | 0x40000000) != 0x40000000) {
      return 45;
    }
    uint64_t v8 = *(uint64_t **)a1;
    if (!*(void *)(*(void *)a1 + 24)) {
      return 22;
    }
    unsigned int v9 = *(_DWORD *)(a1 + 24);
    unsigned int v10 = *(_DWORD *)(v8[1] + 36);
    if (a2)
    {
      v18[0] = a4;
    }
    else
    {
      LODWORD(result) = sub_100020B14((uint64_t)v8, *(void *)(a1 + 8), a4, a3, (uint64_t)v18);
      if (result == 2)
      {
        sub_100044674("tried to remove oid %llu from the omap but it wasn't there\n", v11, v12, v13, v14, v15, v16, v17, v4);
        return 0;
      }
      if (result)
      {
        if (result == 17) {
          return 0;
        }
        else {
          return result;
        }
      }
      uint64_t v8 = *(uint64_t **)a1;
      uint64_t v4 = v18[0];
    }
    return sub_1000051A0(v8, *(int8x16_t **)(a1 + 8), v4, v9 / v10);
  }
  unsigned int v6 = *(_DWORD *)(a1 + 24);

  return sub_10001D368(v6, a4);
}

uint64_t sub_10002EF80(int a1)
{
  unsigned int v7 = -1431655766;
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v6.st_blksize = v2;
  *(timespec *)v6.st_qspare = v2;
  v6.st_birthtimespec = v2;
  *(timespec *)&v6.st_size = v2;
  v6.st_mtimespec = v2;
  v6.st_ctimespec = v2;
  *(timespec *)&v6.st_uid = v2;
  v6.st_atimespec = v2;
  *(timespec *)&v6.dev_t st_dev = v2;
  memset(&__b, 170, sizeof(__b));
  if (!ioctl(a1, 0x40046418uLL, &v7)) {
    return v7;
  }
  if (!fstatfs(a1, &__b)) {
    return __b.f_bsize;
  }
  if (!fstat(a1, &v6)) {
    return v6.st_blksize;
  }
  uint64_t v3 = __error();
  uint64_t v4 = strerror(*v3);
  sub_10002B1C4("%s:%d: can't get the device block size (%s). assuming 512\n", "io_get_device_block_size", 56, v4);
  return 512;
}

uint64_t sub_10002F088(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 72))();
}

uint64_t sub_10002F094(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    uint64_t v2 = sub_10002F094();
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 8))(a1) + v2;
}

uint64_t sub_10002F0E0(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    unsigned int v2 = sub_10002F0E0();
  }
  else {
    unsigned int v2 = 0;
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 112))(a1);
  if (result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t sub_10002F130(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 128))();
}

uint64_t sub_10002F13C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 144))();
}

uint64_t sub_10002F148(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24))();
      }
    }
  }
  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24))();
}

uint64_t sub_10002F18C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }
  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 32);
  if (v12)
  {
    return v12();
  }
  else
  {
    uint64_t v14 = (*(uint64_t (**)(void))(v11 + 24))();
    uint64_t v15 = v14;
    uint64_t v16 = *(void (**)(uint64_t))a6;
    if (*(void *)a6)
    {
      *(_DWORD *)(a6 + 96) = v14;
      v16(a6);
    }
    return v15;
  }
}

uint64_t sub_10002F238(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = a1;
  uint64_t v10 = *(void *)(a1 + 80);
  if (v10)
  {
    while (1)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(v9 + 88);
      if ((v12 & a2) == 0) {
        break;
      }
      a2 &= ~v12;
      uint64_t v10 = *(void *)(v11 + 80);
      uint64_t v9 = v11;
      if (!v10)
      {
        if (!a9) {
          goto LABEL_8;
        }
        goto LABEL_5;
      }
    }
  }
  uint64_t v11 = v9;
  if (a9)
  {
LABEL_5:
    uint64_t v13 = *(uint64_t (**)(void))(*(void *)(v11 + 72) + 40);
    if (v13) {
      return v13();
    }
    else {
      return 45;
    }
  }
  else
  {
LABEL_8:
    if (a6) {
      return sub_10002F18C(v11, a2, a3, a4, a5, a7);
    }
    else {
      return (*(uint64_t (**)(void))(*(void *)(v11 + 72) + 24))();
    }
  }
}

uint64_t sub_10002F2B8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 48))();
}

uint64_t sub_10002F2C4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64))();
      }
    }
  }
  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64))();
}

uint64_t sub_10002F308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }
  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  if (!a7) {
    return (*(uint64_t (**)(void))(v11 + 64))();
  }
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 72);
  if (v12) {
    return v12();
  }
  else {
    return 45;
  }
}

uint64_t sub_10002F368(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16))();
}

uint64_t sub_10002F374(uint64_t a1, uint64_t a2)
{
  mach_port_t v3 = *(_DWORD *)(a1 + 68);
  if (v3 && (uint64_t v4 = *(void *)(a2 + 88)) != 0)
  {
    uint64_t v5 = *(void *)(a2 + 24);
    uint64_t v7 = *(void *)(a2 + 32);
    return sub_10001CDCC((char *)(a1 + 208), v3, 5u, v5, *(void *)(a2 + 16), &v7, v4, 0, 0);
  }
  else
  {
    uint64_t result = aio_error((const aiocb *)(a2 + 8));
    if (result == -1) {
      return *__error();
    }
  }
  return result;
}

uint64_t sub_10002F3E4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_10002F3EC(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

uint64_t sub_10002F3F4(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2) {
    *a2 = a1[26];
  }
  if (a3) {
    *a3 = a1[27];
  }
  if (a4) {
    *a4 = a1[28];
  }
  if (a5) {
    *a5 = a1[29];
  }
  return 0;
}

uint64_t sub_10002F42C(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, char a6)
{
  return sub_100030074(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t sub_10002F434(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7)
{
  return sub_1000303C8(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t sub_10002F43C(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if ((a9 & 0xFFFFFFFA) != 0)
  {
    uint64_t v9 = 45;
LABEL_9:
    sub_10002B1C4("%s:%d: failed to read blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n", "fd_dev_read_extended", 622, a2, a3, a9, v9, (const char *)(a1 + 208));
    return v9;
  }
  if (((a9 >> 2) ^ 1) != (a8 == 0))
  {
    uint64_t v9 = 22;
    goto LABEL_9;
  }
  if (a6)
  {
    return sub_1000303C8(a1, a2, a3, (uint64_t)a4, a5, a9, a7, a8);
  }
  else
  {
    return sub_100030074(a1, a2, a3, a4, a5, a9, a8);
  }
}

uint64_t sub_10002F510(uint64_t a1, uint64_t a2)
{
  mach_port_t v3 = (aiocb *)(a2 + 8);
  aiocblist = (aiocb *)(a2 + 8);
  mach_port_t v4 = *(_DWORD *)(a1 + 68);
  if (v4 && (uint64_t v5 = *(void *)(a2 + 88)) != 0)
  {
    uint64_t v6 = *(void *)(a2 + 24);
    uint64_t v11 = *(void *)(a2 + 32);
    uint64_t v7 = sub_10001CDCC((char *)(a1 + 208), v4, 3u, v6, *(void *)(a2 + 16), &v11, v5, 0, 0);
    if (!v7)
    {
      if (v11 == *(void *)(a2 + 32)) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = 5;
      }
    }
  }
  else if (aio_suspend((const aiocb *const *)&aiocblist, 1, 0) || (unint64_t v8 = aio_return(v3), v8 == -1))
  {
    uint64_t v7 = *__error();
  }
  else if (v8 >= *(void *)(a2 + 32))
  {
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 5;
  }
  uint64_t v9 = *(void (**)(uint64_t))a2;
  if (*(void *)a2)
  {
    *(_DWORD *)(a2 + 96) = v7;
    v9(a2);
  }
  return v7;
}

uint64_t sub_10002F5EC(uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, int a6)
{
  return sub_100030518(a1, a2, a3, a4, a5, a6, 0);
}

uint64_t sub_10002F5F4(uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  if ((a7 & 0xFFFFFFFA) != 0)
  {
    uint64_t v7 = 45;
LABEL_8:
    sub_10002B1C4("%s:%d: failed to write blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n", "fd_dev_write_extended", 866, a2, a3, a7, v7, (const char *)(a1 + 208));
    return v7;
  }
  if (((a7 >> 2) ^ 1) != (a6 == 0))
  {
    uint64_t v7 = 22;
    goto LABEL_8;
  }

  return sub_100030518(a1, a2, a3, a4, a5, a7, a6);
}

uint64_t sub_10002F6A4(uint64_t a1, int a2)
{
  mach_port_t v4 = *(void **)(a1 + 24);
  if (v4)
  {
    unint64_t v5 = *(unsigned int *)(a1 + 36);
    if (v5)
    {
      uint64_t result = sub_100030290(a1, *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, 0);
      if (result) {
        return result;
      }
      *(_DWORD *)(a1 + 36) = 0;
    }
  }
  fsync(*(_DWORD *)a1);
  int v7 = *(_DWORD *)(a1 + 4);
  if ((v7 & 0x80000000) == 0) {
    fsync(v7);
  }
  if (!a2 && (*(unsigned char *)(a1 + 104) & 2) != 0)
  {
    long long v10 = xmmword_10006F398;
    uint64_t v11 = 2;
    int v9 = ioctl(*(_DWORD *)a1, 0x80186416uLL, &v10);
  }
  else
  {
    int v8 = *(_DWORD *)a1;
    if ((*(_WORD *)(a1 + 64) & 0xF000) == 0x8000) {
      int v9 = fcntl(v8, 51, 0);
    }
    else {
      int v9 = ioctl(v8, 0x20006416uLL, 0);
    }
  }
  if (v9 == -1) {
    return *__error();
  }
  else {
    return 0;
  }
}

uint64_t sub_10002F79C()
{
  return 0;
}

uint64_t sub_10002F7A4()
{
  return 0;
}

uint64_t sub_10002F7AC(uint64_t a1)
{
  uint64_t v2 = (const char *)(a1 + 208);
  size_t v3 = strlen((const char *)(a1 + 208));
  mach_port_t v4 = *(void **)(a1 + 24);
  if (!v4)
  {
    uint64_t v7 = 0;
    goto LABEL_10;
  }
  unint64_t v5 = *(unsigned int *)(a1 + 36);
  if (!v5)
  {
    uint64_t v7 = 0;
LABEL_9:
    sub_10002B254(v4, (*(_DWORD *)(a1 + 100) * *(_DWORD *)(a1 + 32)));
    *(void *)(a1 + 24) = 0;
    goto LABEL_10;
  }
  uint64_t v6 = sub_100030290(a1, *(void *)(a1 + 40), v5, v4, *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, 0);
  uint64_t v7 = v6;
  if (v6) {
    sub_10002B1C4("%s:%d: Hit an error flushing the cache, %d dev_name = %s\n", "fd_dev_close", 370, v6, v2);
  }
  *(_DWORD *)(a1 + 36) = 0;
  mach_port_t v4 = *(void **)(a1 + 24);
  if (v4) {
    goto LABEL_9;
  }
LABEL_10:
  if (close(*(_DWORD *)a1)) {
    uint64_t v7 = *__error();
  }
  int v8 = *(_DWORD *)(a1 + 4);
  if ((v8 & 0x80000000) == 0 && close(v8)) {
    uint64_t v7 = *__error();
  }
  int v9 = *(_DWORD *)(a1 + 8);
  if ((v9 & 0x80000000) == 0 && close(v9)) {
    uint64_t v7 = *__error();
  }
  sub_10001CEDC(*(unsigned int *)(a1 + 68));
  sub_10002B254((void *)a1, v3 + 216);
  return v7;
}

uint64_t sub_10002F8CC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_10002F8D4(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 128) * (unint64_t)*(unsigned int *)(a1 + 100) / a2;
  *(_DWORD *)(a1 + 100) = a2;
  *(void *)(a1 + 128) = v2;
  return 0;
}

BOOL sub_10002F8F8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 108) != 0;
}

BOOL sub_10002F908(uint64_t a1)
{
  return *(_DWORD *)(a1 + 112) != 0;
}

uint64_t sub_10002F918(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_10002F920(int a1, void *a2)
{
  memset(__b, 170, sizeof(__b));
  *a2 = 0;
  if (fcntl(a1, 50, __b)) {
    LOBYTE(__b[0]) = 0;
  }
  uint64_t v4 = 5;
  if (__b[0] ^ 0x7665642F | LOBYTE(__b[1]) ^ 0x2F) {
    uint64_t v4 = 0;
  }
  unint64_t v5 = (char *)__b + v4;
  size_t v6 = strlen((const char *)__b + v4);
  uint64_t v7 = (char *)sub_10002B210(1uLL, v6 + 216);
  if (!v7) {
    return 12;
  }
  int v8 = v7;
  *(void *)(v7 + 4) = -1;
  *(_DWORD *)uint64_t v7 = a1;
  strlcpy(v7 + 208, v5, v6 + 1);
  uint64_t v9 = sub_10002FA5C((uint64_t)v8);
  if (v9) {
    sub_10002B254(v8, v6 + 216);
  }
  else {
    *a2 = v8;
  }
  return v9;
}

uint64_t sub_10002FA5C(uint64_t a1)
{
  dev_t v19 = -1431655766;
  int v17 = -1431655766;
  int v18 = -1431655766;
  dev_t v16 = -1431655766;
  v2.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v2.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v15.st_blksize = v2;
  *(timespec *)v15.st_qspare = v2;
  v15.st_birthtimespec = v2;
  *(timespec *)&v15.off_t st_size = v2;
  v15.st_mtimespec = v2;
  v15.st_ctimespec = v2;
  *(timespec *)&v15.st_uid = v2;
  v15.st_atimespec = v2;
  *(timespec *)&v15.dev_t st_dev = v2;
  if (fstat(*(_DWORD *)a1, &v15))
  {
    size_t v3 = __error();
    uint64_t v4 = *v3;
    sub_10002B1C4("%s:%d: Couldn't fstat dev_fd (%d), err %d dev_name = %s\n", "dev_init_common", 983, *(_DWORD *)a1, *v3, (const char *)(a1 + 208));
  }
  else
  {
    *(void *)(a1 + 72) = off_1000745F0;
    int v5 = sub_10002EF80(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 96) = v5;
    *(_DWORD *)(a1 + 100) = v5;
    int v6 = *(_DWORD *)a1;
    unint64_t v21 = 0xAAAAAAAAAAAAAAAALL;
    v7.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v7.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v20.st_blksize = v7;
    *(timespec *)v20.st_qspare = v7;
    v20.st_birthtimespec = v7;
    *(timespec *)&v20.off_t st_size = v7;
    v20.st_mtimespec = v7;
    v20.st_ctimespec = v7;
    *(timespec *)&v20.st_uid = v7;
    v20.st_atimespec = v7;
    *(timespec *)&v20.dev_t st_dev = v7;
    if (ioctl(v6, 0x40086419uLL, &v21))
    {
      if (fstat(v6, &v20))
      {
        int v8 = __error();
        uint64_t v9 = strerror(*v8);
        sub_10002B1C4("%s:%d: can't get block count (%s)\n", "io_get_num_device_blocks", 77, v9);
        unint64_t v10 = 0;
      }
      else
      {
        off_t st_size = v20.st_size;
        unint64_t v10 = st_size / (int)sub_10002EF80(v6);
      }
    }
    else
    {
      unint64_t v10 = v21;
    }
    *(void *)(a1 + 128) = v10;
    sub_10002D57C(*(_DWORD *)a1, &v19, &v18, &v17, &v16);
    uint64_t v4 = 0;
    int v12 = v18;
    *(_DWORD *)(a1 + 104) = v19;
    *(_DWORD *)(a1 + 108) = v12;
    dev_t v13 = v16;
    *(_DWORD *)(a1 + 112) = v17;
    *(_DWORD *)(a1 + 1--*(_DWORD *)(result + 16) = v13;
    *(_WORD *)(a1 + 64) = v15.st_mode;
    *(_DWORD *)(a1 + 120) = 0;
  }
  return v4;
}

uint64_t sub_10002FBF4(char *a1, int a2, uint64_t *a3)
{
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v6 = 5;
  }
  else {
    uint64_t v6 = 0;
  }
  timespec v7 = &a1[v6];
  size_t v8 = strlen(&a1[v6]);
  *a3 = 0;
  uint64_t v9 = sub_10002B210(1uLL, v8 + 216);
  if (v9)
  {
    uint64_t v10 = (uint64_t)v9;
    v11.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
    v11.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
    *(timespec *)&v38.st_blksize = v11;
    *(timespec *)v38.st_qspare = v11;
    v38.st_birthtimespec = v11;
    *(timespec *)&v38.off_t st_size = v11;
    v38.st_mtimespec = v11;
    v38.st_ctimespec = v11;
    *(timespec *)&v38.st_uid = v11;
    v38.st_atimespec = v11;
    *(timespec *)&v38.dev_t st_dev = v11;
    v9[17] = 0;
    int v12 = v9 + 17;
    if (stat(a1, &v38) || (v38.st_mode & 0xF000) != 0x4000)
    {
      unint64_t v15 = sub_10002DB30(a1, 0);
      if (v15)
      {
        dev_t v16 = (char *)v15;
        unsigned int v17 = a2 & 0xFFFFFFCF | 0x10;
        *(_DWORD *)(v10 + 8) = -1;
        int v18 = open(a1, v17);
        *(_DWORD *)(v10 + 4) = v18;
        if (v18 < 0)
        {
          long long v26 = __error();
          uint64_t v14 = *v26;
          uint64_t v27 = strerror(*v26);
          sub_10002B1C4("%s:%d: failed to open volume device %s: %s\n", "dev_init", 1107, a1, v27);
        }
        else
        {
          int v19 = open(v16, v17);
          *(_DWORD *)uint64_t v10 = v19;
          if ((v19 & 0x80000000) == 0)
          {
            if (sub_10002DCA0(v7))
            {
              uint64_t v20 = sub_10001CD60(v7, v12);
              if (v20)
              {
                uint64_t v14 = v20;
                unint64_t v21 = strerror(v20);
                sub_10002B1C4("%s:%d: failed to open connection for multikey crypto i/o on device %s: %s\n", "dev_init", 1121, v16, v21);
                close(*(_DWORD *)v10);
                close(*(_DWORD *)(v10 + 4));
LABEL_35:
                free(v16);
LABEL_42:
                sub_10002B254((void *)v10, v8 + 216);
                return v14;
              }
            }
            goto LABEL_33;
          }
          long long v28 = __error();
          uint64_t v14 = *v28;
          uint64_t v29 = strerror(*v28);
          sub_10002B1C4("%s:%d: failed to open container device %s: %s\n", "dev_init", 1113, v16, v29);
          close(*(_DWORD *)(v10 + 4));
        }
      }
      else
      {
        *(void *)(v10 + 4) = -1;
        int v22 = open(a1, a2);
        *(_DWORD *)uint64_t v10 = v22;
        if ((v22 & 0x80000000) == 0)
        {
LABEL_32:
          dev_t v16 = 0;
LABEL_33:
          uint64_t v34 = sub_10002FA5C(v10);
          if (v34)
          {
            uint64_t v14 = v34;
            goto LABEL_35;
          }
          strlcpy((char *)(v10 + 208), v7, v8 + 1);
          free(v16);
LABEL_43:
          uint64_t v14 = 0;
          *a3 = v10;
          return v14;
        }
        int v23 = 30;
        while (*__error() == 16 && v23 != 0)
        {
          sub_10002B1C4("%s:%d: open %s hit EBUSY, attempts remaining: %u dev_name = %s\n", "dev_init", 1133, a1, v23, v7);
          sleep(1u);
          int v25 = open(a1, a2);
          *(_DWORD *)uint64_t v10 = v25;
          --v23;
          if ((v25 & 0x80000000) == 0)
          {
            dev_t v16 = 0;
            goto LABEL_33;
          }
        }
        dev_t v16 = 0;
        uint64_t v14 = *__error();
      }
    }
    else
    {
      memset(__b, 170, sizeof(__b));
      memset(v40, 170, sizeof(v40));
      memset(__str, 170, sizeof(__str));
      snprintf(__b, 0x400uLL, "%s/apfs", a1);
      snprintf(__str, 0x400uLL, "%s/apfs_data", a1);
      snprintf(v40, 0x400uLL, "%s/nx", a1);
      int v13 = open(__b, a2);
      *(_DWORD *)(v10 + 4) = v13;
      if (v13 < 0) {
        uint64_t v14 = *__error();
      }
      else {
        uint64_t v14 = 0;
      }
      int v30 = open(__str, a2);
      *(_DWORD *)(v10 + 8) = v30;
      if (v30 < 0) {
        uint64_t v14 = *__error();
      }
      int v31 = open(v40, a2);
      int v32 = v31;
      *(_DWORD *)uint64_t v10 = v31;
      int v33 = *(_DWORD *)(v10 + 4);
      if ((v33 & 0x80000000) == 0 && (*(_DWORD *)(v10 + 8) & 0x80000000) == 0 && (v31 & 0x80000000) == 0) {
        goto LABEL_32;
      }
      if (!v14)
      {
        uint64_t v14 = *__error();
        int v32 = *(_DWORD *)v10;
        int v33 = *(_DWORD *)(v10 + 4);
      }
      int v35 = *(_DWORD *)(v10 + 8);
      uint64_t v36 = strerror(v14);
      sub_10002B1C4("%s:%d: failed to open apfs/nx special devices ['%s'(%d) / '%s'(%d) / '%s'(%d)] - err %d (%s) dev_name = '%s'\n", "dev_init", 1094, __b, v33, __str, v35, v40, v32, v14, v36, v7);
      close(*(_DWORD *)v10);
      close(*(_DWORD *)(v10 + 4));
      close(*(_DWORD *)(v10 + 8));
      dev_t v16 = 0;
    }
    free(v16);
    if (v14) {
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  return 12;
}

uint64_t sub_100030074(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, char a6, uint64_t a7)
{
  uint64_t v14 = sub_1000301FC(a1, a2, a3);
  if (!v14)
  {
    unint64_t v15 = *(unsigned int *)(a1 + 100);
    if ((a2 & 0x8000000000000000) == 0
      && is_mul_ok(a2, v15)
      && (uint64_t v16 = a2 * v15, ((a2 * v15) & 0x8000000000000000) == 0)
      && is_mul_ok(a3, v15))
    {
      unint64_t v18 = a3 * v15;
      if (a5 && (mach_port_t v19 = *(_DWORD *)(a1 + 68)) != 0)
      {
        char v20 = a7 == 0;
        if ((a6 & 4) != 0)
        {
          char v20 = 0;
          uint64_t v21 = 0;
        }
        else
        {
          uint64_t v21 = v16;
        }
        if (a7) {
          uint64_t v22 = a7;
        }
        else {
          uint64_t v22 = v21;
        }
        unint64_t v28 = v18;
        unsigned int v23 = sub_10001CDCC((char *)(a1 + 208), v19, 1u, (uint64_t)a4, v16, &v28, a5, v22, v20);
        if (v28 == v18) {
          unsigned int v24 = 0;
        }
        else {
          unsigned int v24 = 5;
        }
        if (v23) {
          return v23;
        }
        else {
          return v24;
        }
      }
      else
      {
        if (!a5 || (int v25 = *(_DWORD *)(a1 + 4), v25 < 0)) {
          int v25 = *(_DWORD *)a1;
        }
        ssize_t v26 = pread(v25, a4, a3 * v15, a2 * v15);
        if (v26 < 0)
        {
          uint64_t v27 = __error();
          uint64_t v14 = *v27;
          sub_10002B1C4("%s:%d: blknum 0x%llx size %zu, error %d dev_name = %s\n", "fd_dev_read_helper", 510, a2, a3, *v27, (const char *)(a1 + 208));
        }
        else if (v26 == v18)
        {
          return 0;
        }
        else
        {
          return 5;
        }
      }
    }
    else
    {
      sub_10002B1C4("%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n", "fd_dev_read_helper", 476, a2, a3, *(_DWORD *)(a1 + 100), (const char *)(a1 + 208));
      return 22;
    }
  }
  return v14;
}

uint64_t sub_1000301FC(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6)
  {
    unint64_t v7 = *(unsigned int *)(a1 + 36);
    if (v7)
    {
      unint64_t v8 = *(void *)(a1 + 40);
      if (a3 + a2 > v8 && v8 + v7 > a2)
      {
        uint64_t result = sub_100030290(a1, v8, v7, v6, *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, 0);
        if (result) {
          return result;
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  unint64_t v10 = *(void *)(a1 + 128);
  if (v10 - a2 >= a3 && v10 > a2) {
    return 0;
  }
  else {
    return 6;
  }
}

uint64_t sub_100030290(uint64_t a1, unint64_t a2, unint64_t a3, void *__buf, uint64_t a5, char a6, uint64_t a7)
{
  unint64_t v7 = *(void *)(a1 + 128);
  BOOL v8 = v7 > a2;
  unint64_t v9 = v7 - a2;
  if (!v8 || v9 < a3) {
    return 6;
  }
  unint64_t v12 = *(unsigned int *)(a1 + 100);
  if ((a2 & 0x8000000000000000) == 0
    && is_mul_ok(a2, v12)
    && (uint64_t v14 = a2 * v12, ((a2 * v12) & 0x8000000000000000) == 0)
    && is_mul_ok(a3, v12))
  {
    unint64_t v15 = a3 * v12;
    if (a5 && (mach_port_t v16 = *(_DWORD *)(a1 + 68)) != 0)
    {
      char v17 = a7 == 0;
      if ((a6 & 4) != 0)
      {
        char v17 = 0;
        uint64_t v18 = 0;
      }
      else
      {
        uint64_t v18 = v14;
      }
      if (a7) {
        uint64_t v19 = a7;
      }
      else {
        uint64_t v19 = v18;
      }
      unint64_t v23 = v15;
      LODWORD(result) = sub_10001CDCC((char *)(a1 + 208), v16, 4u, (uint64_t)__buf, v14, &v23, a5, v19, v17);
      if (v23 == v15) {
        unsigned int v20 = 0;
      }
      else {
        unsigned int v20 = 5;
      }
      if (result) {
        return result;
      }
      else {
        return v20;
      }
    }
    else
    {
      if (!a5 || (int v21 = *(_DWORD *)(a1 + 4), v21 < 0)) {
        int v21 = *(_DWORD *)a1;
      }
      ssize_t v22 = pwrite(v21, __buf, a3 * v12, v14);
      if (v22 < 0)
      {
        return *__error();
      }
      else if (v22 == v15)
      {
        return 0;
      }
      else
      {
        return 5;
      }
    }
  }
  else
  {
    sub_10002B1C4("%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n", "_fd_dev_write", 725, a2, a3, *(_DWORD *)(a1 + 100), (const char *)(a1 + 208));
    return 22;
  }
}

uint64_t sub_1000303C8(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = sub_1000301FC(a1, a2, a3);
  if (v16) {
    goto LABEL_2;
  }
  *(_OWORD *)(a7 + 8) = 0u;
  uint64_t v19 = (aiocb *)(a7 + 8);
  *(void *)(a7 + 88) = a5;
  *(_OWORD *)(a7 + 24) = 0u;
  *(_OWORD *)(a7 + 40) = 0u;
  *(_OWORD *)(a7 + 56) = 0u;
  *(_OWORD *)(a7 + 72) = 0u;
  uint64_t v20 = *(unsigned int *)(a1 + 100);
  uint64_t v21 = v20 * a2;
  *(void *)(a7 + --*(_DWORD *)(result + 16) = v20 * a2;
  *(void *)(a7 + 24) = a4;
  unint64_t v22 = v20 * a3;
  *(void *)(a7 + 32) = v22;
  if (!a5 || (mach_port_t v23 = *(_DWORD *)(a1 + 68)) == 0)
  {
    if (!a5 || (int v27 = *(_DWORD *)(a1 + 4), v27 < 0)) {
      int v27 = *(_DWORD *)a1;
    }
    v19->aio_fildes = v27;
    if (!aio_read(v19)) {
      return 0;
    }
    if (*__error() == 35)
    {
      uint64_t v16 = 16;
    }
    else
    {
      uint64_t v16 = *__error();
      if (!v16) {
        return v16;
      }
    }
    goto LABEL_2;
  }
  char v24 = (a6 & 4) == 0;
  uint64_t v25 = (a6 & 4) != 0 ? 0 : v21;
  if (a8)
  {
    char v24 = 0;
    uint64_t v26 = a8;
  }
  else
  {
    uint64_t v26 = v25;
  }
  unint64_t v28 = v22;
  uint64_t v16 = sub_10001CDCC((char *)(a1 + 208), v23, 2u, a4, v21, &v28, a5, v26, v24);
  if (v16)
  {
LABEL_2:
    char v17 = *(void (**)(uint64_t))a7;
    if (*(void *)a7)
    {
      *(_DWORD *)(a7 + 96) = v16;
      v17(a7);
    }
  }
  return v16;
}

uint64_t sub_100030518(uint64_t a1, unint64_t a2, unint64_t a3, char *__buf, uint64_t a5, int a6, uint64_t a7)
{
  unint64_t v10 = __buf;
  unint64_t v11 = a3;
  unint64_t v12 = a2;
  uint64_t v14 = *(void *)(a1 + 24);
  if (*(_DWORD *)(a1 + 60))
  {
    if (!v14)
    {
      unsigned int v15 = *(_DWORD *)(a1 + 100);
      unsigned int v16 = v15 <= 0x100000 ? 0x100000 / v15 : 1;
      *(_DWORD *)(a1 + 32) = v16;
      uint64_t v18 = sub_10002B290(v16 * v15);
      *(void *)(a1 + 24) = v18;
      *(_DWORD *)(a1 + 36) = 0;
      if (!v18) {
        return 12;
      }
    }
  }
  else if (!v14)
  {
    return sub_100030290(a1, a2, a3, __buf, a5, a6, a7);
  }
  if (!v11) {
    return 0;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 36);
  while (1)
  {
    while (1)
    {
      unint64_t v20 = v11 >= *(_DWORD *)(a1 + 32) - v19 ? *(_DWORD *)(a1 + 32) - v19 : v11;
      if ((a6 & 4) != 0 || ((*(_DWORD *)(a1 + 56) ^ a6) & 1) != 0 || v12 != *(void *)(a1 + 40) + v19) {
        break;
      }
      if (!v20 || *(void *)(a1 + 48) != a5) {
        break;
      }
      memcpy((void *)(*(void *)(a1 + 24) + *(_DWORD *)(a1 + 100) * v19), v10, (*(_DWORD *)(a1 + 100) * v20));
      unsigned int v19 = *(_DWORD *)(a1 + 36) + v20;
      *(_DWORD *)(a1 + 36) = v19;
      v12 += v20;
      v11 -= v20;
      v10 += (*(_DWORD *)(a1 + 100) * v20);
      if (!v11) {
        return 0;
      }
    }
    if (v19)
    {
      uint64_t result = sub_100030290(a1, *(void *)(a1 + 40), v19, *(void **)(a1 + 24), *(void *)(a1 + 48), *(_DWORD *)(a1 + 56) & 1, a7);
      if (result) {
        break;
      }
    }
    unsigned int v19 = 0;
    *(_DWORD *)(a1 + 36) = 0;
    *(void *)(a1 + 40) = v12;
    *(void *)(a1 + 48) = a5;
    *(_DWORD *)(a1 + 56) = a6;
  }
  return result;
}

uint64_t sub_1000306C8(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 4 && a5 == 4)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t sub_1000306FC(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t sub_100030730(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t sub_10003078C(uint64_t *a1, double a2, int8x16_t a3)
{
  uint64_t v4 = a1[1];
  unint64_t v5 = *(unsigned int *)(v4 + 36);
  v16.i64[0] = 0;
  uint64_t v17 = 0;
  v16.i64[1] = v5;
  int v6 = *(_DWORD *)(v4 + 104);
  uint64_t v7 = (*(_DWORD *)(v4 + 140) + *(_DWORD *)(v4 + 136) - 1) % (v6 & 0x7FFFFFFFu);
  uint64_t v8 = *(void *)(v4 + 112);
  if (v6 < 0)
  {
    uint64_t result = sub_100030FD4((uint64_t)a1, v8, v7, &v16, 0);
    if (result) {
      return result;
    }
  }
  else
  {
    v16.i64[0] = v8 + v7;
  }
  int8x16_t v14 = v16;
  uint64_t v15 = v17;
  uint64_t result = sub_100026BA0(a1, 0, v4, (uint64_t)&v14, v16, a3);
  if (!result)
  {
    v16.i64[0] = 0;
    int8x16_t v14 = v16;
    uint64_t v15 = v17;
    uint64_t result = sub_100026BA0(a1, 0, v4, (uint64_t)&v14, v16, v10);
    if (!result)
    {
      if (*(unsigned char *)(a1[1] + 65))
      {
        char v12 = *(unsigned char *)(v4 + 1295);
        char v13 = ~v12;
        *(unsigned char *)(v4 + 1295) = v12 | 1;
        v16.i64[0] = 0x4000000000000000uLL >> __clz(__rbit64(v5));
        int8x16_t v14 = v16;
        uint64_t v15 = v17;
        uint64_t result = sub_100026BA0(a1, 0, v4, (uint64_t)&v14, v16, v11);
        *(unsigned char *)(v4 + 1295) &= v13 | 0xFE;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1000308D4(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  int v4 = *(_DWORD *)(v3 + 104);
  if ((v4 & 0x7FFFFFFFu) <= a2) {
    return 22;
  }
  uint64_t v7 = *(void *)(v3 + 112);
  if (v4 < 0) {
    return sub_100030FD4(a1, v7, a2, a3, 0);
  }
  uint64_t result = 0;
  *a3 = v7 + a2;
  return result;
}

uint64_t sub_100030918(uint64_t *a1, int a2, int a3, size_t size, uint64_t a5, void *a6, uint64_t a7)
{
  uint64_t v7 = a1[1];
  int v8 = *(_DWORD *)(v7 + 140);
  int v9 = *(_DWORD *)(v7 + 148);
  size_t v10 = *(unsigned int *)(v7 + 36);
  uint64_t v70 = 0;
  char v71 = 0;
  v69.i64[0] = 0;
  v69.i64[1] = v10;
  unsigned int v11 = size / v10;
  if (size % v10) {
    return 22;
  }
  int v16 = size;
  int v66 = v9;
  unint64_t v20 = malloc_type_calloc(1uLL, size, 0x5FC030CAuLL);
  if (!v20) {
    return 12;
  }
  uint64_t v21 = (*(_DWORD *)(v7 + 140) + *(_DWORD *)(v7 + 136) - 2) % (*(_DWORD *)(v7 + 104) & 0x7FFFFFFFu);
  uint64_t v22 = a1[1];
  int v23 = *(_DWORD *)(v22 + 104);
  int v64 = v8;
  uint64_t v65 = v20;
  if ((v23 & 0x7FFFFFFFu) <= v21)
  {
    uint64_t v12 = 22;
    goto LABEL_21;
  }
  uint64_t v62 = a7;
  uint64_t v24 = *(void *)(v22 + 112);
  if (v23 < 0)
  {
    uint64_t v12 = sub_100030FD4((uint64_t)a1, v24, v21, &v69, 0);
    if (v12) {
      goto LABEL_21;
    }
    uint64_t v25 = v69.i64[0];
  }
  else
  {
    uint64_t v25 = v24 + v21;
    v69.i64[0] = v24 + v21;
  }
  uint64_t v12 = sub_1000257B4(a1, 0, 0x40000000, v25, 0, 0, 12, 0, &v71, 0, 0);
  if (!v12)
  {
    uint64_t v61 = v25;
    unint64_t v28 = v71;
    if (*((_DWORD *)v71 + 9) < ((v10 - 40) / 0x28))
    {
      uint64_t v29 = 0;
      uint64_t v30 = 0;
      uint64_t v31 = a1[1];
      int8x16_t v32 = (int8x16_t)v10;
      int v33 = 0;
      uint64_t v34 = v62;
      goto LABEL_11;
    }
    uint64_t v60 = v71;
    v26.i64[0] = v69.i64[1];
    int8x16_t v58 = v26;
    uint64_t v45 = v70;
    char v71 = 0;
    uint64_t v46 = sub_1000308D4((uint64_t)a1, (*(_DWORD *)(v7 + 140) + *(_DWORD *)(v7 + 136) - 1) % (*(_DWORD *)(v7 + 104) & 0x7FFFFFFFu), &v69);
    if (v46)
    {
      uint64_t v12 = v46;
    }
    else
    {
      unint64_t v28 = (uint64_t *)malloc_type_calloc(1uLL, v10, 0xB87E0F94uLL);
      char v71 = v28;
      if (v28)
      {
        v28[1] = v69.i64[0];
        uint64_t v31 = a1[1];
        _OWORD v28[2] = *(void *)(v31 + 16);
        v28[3] = 1073741836;
        *((_DWORD *)v28 + 8) |= 1u;
        int v33 = v60;
        *((_DWORD *)v60 + 8) &= ~1u;
        int v47 = *(_DWORD *)(v7 + 140);
        unsigned int v48 = *(_DWORD *)(v7 + 104) & 0x7FFFFFFF;
        unsigned int v49 = (*(_DWORD *)(v7 + 136) + v47) % v48;
        *(_DWORD *)(v7 + 140) = v47 + 1;
        if (*(_DWORD *)(v7 + 128) == v49) {
          *(_DWORD *)(v7 + 128) = (v48 + v49 + 1) % v48;
        }
        uint64_t v30 = v45;
        uint64_t v29 = v61;
        uint64_t v34 = v62;
        int8x16_t v32 = v58;
LABEL_11:
        unsigned int v35 = a2 | 0x80000000;
        uint64_t v36 = (uint64_t)&v28[5 * *((unsigned int *)v28 + 9) + 5];
        *(_DWORD *)uint64_t v36 = v35;
        *(_DWORD *)(v36 + 4) = a3;
        *(_DWORD *)(v36 + 8) = v16;
        *(void *)(v36 + --*(_DWORD *)(result + 16) = a5;
        uint64_t v37 = *(void *)(v7 + 88);
        *(void *)(v7 + 88) = v37 + 1;
        *(void *)(v36 + 24) = v37;
        LODWORD(v36) = *(_DWORD *)(v7 + 148);
        uint64_t v38 = (*(_DWORD *)(v7 + 144) + (int)v36) % (*(_DWORD *)(v7 + 108) & 0x7FFFFFFFu);
        *(_DWORD *)(v7 + 148) = v11 + v36;
        int v39 = *(_DWORD *)(v31 + 108);
        if ((v39 & 0x7FFFFFFFu) <= v38)
        {
          uint64_t v12 = 22;
        }
        else
        {
          uint64_t v40 = &v28[5 * *((unsigned int *)v28 + 9) + 9];
          uint64_t v41 = *(void *)(v31 + 120);
          if ((v39 & 0x80000000) == 0)
          {
            *uint64_t v40 = v41 + v38;
LABEL_14:
            if (*(_DWORD *)(v7 + 132) == v38) {
              *(_DWORD *)(v7 + 132) = (v38 + (*(_DWORD *)(v7 + 108) & 0x7FFFFFFF) + 1)
            }
                                    % (*(_DWORD *)(v7 + 108) & 0x7FFFFFFFu);
            uint64_t v42 = v71;
            ++*((_DWORD *)v71 + 9);
            if (v33)
            {
              v67.i64[0] = v29;
              v67.i64[1] = v32.i64[0];
              uint64_t v68 = v30;
              uint64_t v43 = v33;
              uint64_t v44 = sub_100026BA0(a1, 0, (uint64_t)v33, (uint64_t)&v67, v32, v27);
              if (v44)
              {
                uint64_t v12 = v44;
                int v33 = v43;
LABEL_46:
                free(v33);
                goto LABEL_21;
              }
              uint64_t v42 = v71;
            }
            else
            {
              uint64_t v43 = 0;
            }
            int8x16_t v67 = v69;
            uint64_t v68 = v70;
            uint64_t v12 = sub_100026BA0(a1, 0, (uint64_t)v42, (uint64_t)&v67, v69, v27);
            int v33 = v43;
            if (!v12)
            {
              uint64_t v56 = sub_10003078C(a1, v54, v55);
              int v33 = v43;
              uint64_t v12 = v56;
              if (!v56)
              {
                uint64_t v57 = v71;
                if (v34)
                {
                  *(void *)uint64_t v34 = v71[5 * (*((_DWORD *)v71 + 9) - 1) + 9];
                  *(_DWORD *)(v34 + 8) = v16;
                  *(_DWORD *)(v34 + 12) = 0;
                  *(void *)(v34 + --*(_DWORD *)(result + 16) = 0;
                }
                uint64_t v12 = 0;
                v65[1] = v57[5 * (*((_DWORD *)v57 + 9) - 1) + 8];
                v65[2] = *(void *)(v7 + 16);
                *((_DWORD *)v65 + 6) = v35;
                *((_DWORD *)v65 + 7) = a3;
                *a6 = v65;
              }
            }
            goto LABEL_45;
          }
          BOOL v50 = v33;
          uint64_t v51 = v29;
          uint64_t v52 = v30;
          int8x16_t v59 = v32;
          uint64_t v53 = sub_100030FD4((uint64_t)a1, v41, v38, v40, 0);
          int8x16_t v32 = v59;
          uint64_t v30 = v52;
          uint64_t v29 = v51;
          uint64_t v34 = v62;
          int v33 = v50;
          uint64_t v12 = v53;
          if (!v53) {
            goto LABEL_14;
          }
        }
LABEL_45:
        if (v33) {
          goto LABEL_46;
        }
        goto LABEL_21;
      }
      uint64_t v12 = 12;
    }
    int v33 = v60;
    goto LABEL_46;
  }
LABEL_21:
  if (v71) {
    free(v71);
  }
  if (v12)
  {
    free(v65);
    *(_DWORD *)(v7 + 140) = v64;
    *(_DWORD *)(v7 + 148) = v66;
  }
  return v12;
}

uint64_t sub_100030DD0(uint64_t *a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  size_t v10 = (unsigned int *)a1[1];
  size_t v11 = v10[9];
  uint64_t v12 = malloc_type_malloc(v11, 0x3A24A9C3uLL);
  if (!v12) {
    return 12;
  }
  char v13 = v12;
  if (v10[35] == 1)
  {
    unsigned int v14 = 0;
    int v15 = 0;
LABEL_4:
    uint64_t v16 = 2 * (v15 == v14);
  }
  else
  {
    int v15 = 0;
    unint64_t v29 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v17 = (v11 - 40) / 0x28;
    while (1)
    {
      uint64_t v18 = (v10[34] + v15) % (v10[26] & 0x7FFFFFFF);
      uint64_t v19 = a1[1];
      int v20 = *(_DWORD *)(v19 + 104);
      if ((v20 & 0x7FFFFFFFu) <= v18) {
        break;
      }
      uint64_t v21 = *(void *)(v19 + 112);
      if (v20 < 0)
      {
        uint64_t v23 = sub_100030FD4((uint64_t)a1, v21, v18, &v29, 0);
        if (v23) {
          goto LABEL_28;
        }
        uint64_t v22 = v29;
      }
      else
      {
        uint64_t v22 = v21 + v18;
        unint64_t v29 = v22;
      }
      uint64_t v23 = sub_10002F148(*a1, v22);
      if (v23)
      {
LABEL_28:
        uint64_t v16 = v23;
        goto LABEL_30;
      }
      if (v13[6] != 1073741836) {
        goto LABEL_27;
      }
      unint64_t v24 = v13[9];
      if (v17 < v24) {
        goto LABEL_27;
      }
      if (v24)
      {
        uint64_t v25 = 0;
        int8x16_t v26 = v13 + 18;
        while (*(v26 - 1) != a2)
        {
          ++v25;
          v26 += 5;
          if (v24 == v25) {
            goto LABEL_19;
          }
        }
        if (a4 && *((_DWORD *)v26 - 8) != (a3 | a4 | 0x80000000))
        {
LABEL_27:
          uint64_t v16 = 92;
          goto LABEL_30;
        }
        if (a5)
        {
          *(void *)a5 = *v26;
          *(_DWORD *)(a5 + 8) = *((_DWORD *)v26 - 6);
          LODWORD(v24) = v13[9];
        }
        unsigned int v27 = v10[35];
        if (v24 > v25)
        {
LABEL_26:
          unsigned int v14 = v27 - 1;
          goto LABEL_4;
        }
      }
      else
      {
LABEL_19:
        unsigned int v27 = v10[35];
      }
      if (++v15 >= v27 - 1) {
        goto LABEL_26;
      }
    }
    uint64_t v16 = 22;
  }
LABEL_30:
  free(v13);
  return v16;
}

uint64_t sub_100030FD4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t *a5)
{
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v16[2] = v8;
  void v16[3] = v8;
  v16[0] = v8;
  v16[1] = v8;
  unint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = a3;
  unint64_t v13 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v11 = 16;
  unsigned int v12 = 8;
  uint64_t result = sub_100038040((uint64_t)v16, a1, 0, 0x40000000, 2, 10, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 16, 0, a2, (uint64_t)sub_1000306FC);
  if (!result)
  {
    uint64_t result = sub_1000380B0((uint64_t)v16, 0, 0xFFFFFFFFLL, &v15, &v12, 8u, &v13, &v11);
    if (!result)
    {
      unint64_t v10 = v14 - (a3 - v15);
      if (v14 <= a3 - v15)
      {
        return 2;
      }
      else
      {
        *a4 = v13 + a3 - v15;
        uint64_t result = 0;
        if (a5) {
          *a5 = v10;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1000310DC(uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, void, void, uint64_t), uint64_t a4)
{
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v12[2] = v6;
  void v12[3] = v6;
  v12[0] = v6;
  v12[1] = v6;
  unint64_t v11 = 0xAAAAAAAAAAAAAAAALL;
  v10[2] = v6;
  v10[3] = v6;
  v10[0] = v6;
  v10[1] = v6;
  v8[1] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v9 = 0;
  v8[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_100038040((uint64_t)v12, a1, 0, 0x40000000, 2, 10, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 16, 0, a2, (uint64_t)sub_1000306FC);
  if (!result)
  {
    uint64_t result = sub_10003889C((uint64_t)v10, (uint64_t)v12, 0, &v9, 8u, 8u, v8, 16);
    if (!result) {
      return sub_10002C46C((uint64_t)v10, a3, a4, 0);
    }
  }
  return result;
}

uint64_t sub_1000311BC(int8x16_t *a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v46 = 0;
  int8x16_t v44 = 0uLL;
  uint64_t v45 = 0;
  int8x16_t v42 = 0uLL;
  uint64_t v43 = 0;
  uint64_t v14 = a1[1].i64[0];
  if (*(void *)(v14 + 48)) {
    uint64_t v15 = sub_1000257B4(a1->i64, 0, 0x80000000, *(void *)(v14 + 56), 0, 0, 18, 0, &v46, (uint64_t)&v44, 0);
  }
  else {
    uint64_t v15 = sub_100031484(a1->i64, 0, &v46, (uint64_t)&v44);
  }
  uint64_t v17 = v15;
  if (!v15)
  {
    uint64_t v18 = v46;
    if ((*((_DWORD *)v46 + 11) - *((_DWORD *)v46 + 12)) > 1)
    {
      int v20 = v46;
      uint64_t v18 = 0;
    }
    else
    {
      int8x16_t v42 = v44;
      uint64_t v43 = v45;
      uint64_t v46 = 0;
      uint64_t v19 = sub_100031484(a1->i64, (uint64_t)v18, &v46, (uint64_t)&v44);
      if (v19)
      {
LABEL_19:
        uint64_t v17 = v19;
LABEL_23:
        free(v18);
        goto LABEL_24;
      }
      int v20 = v46;
    }
    unsigned int v22 = *((_DWORD *)v20 + 14);
    unsigned int v21 = *((_DWORD *)v20 + 15);
    uint64_t v23 = &v20[5 * v21];
    int v25 = *((_DWORD *)v23 + 16);
    unint64_t v24 = v23 + 8;
    *((_DWORD *)v20 + 15) = v25;
    if (v22 != -1) {
      LODWORD(v20[5 * v22 + 8]) = v21;
    }
    int v26 = (8 * (_BYTE)a7) & 0x10;
    if (*((_DWORD *)v20 + 13) == -1) {
      *((_DWORD *)v20 + 13) = v21;
    }
    *((_DWORD *)v20 + 14) = v21;
    *unint64_t v24 = -1;
    ++*((_DWORD *)v20 + 12);
    unsigned int v27 = &v20[5 * v21];
    *((_DWORD *)v27 + 18) = a2;
    *((_DWORD *)v27 + 19) = a3;
    v27[10] = a4;
    v27[11] = a5;
    v27[12] = a6;
    *((_DWORD *)v27 + 17) = v26 | 5;
    unint64_t v28 = v46;
    uint64_t v29 = a1[1].i64[0];
    uint64_t v30 = *(void *)(v29 + 32);
    *(void *)(v29 + 32) = v30 + 1;
    unsigned int v32 = *((_DWORD *)v28 + 14);
    unsigned int v31 = *((_DWORD *)v28 + 15);
    int v33 = &v28[5 * v31];
    int v35 = *((_DWORD *)v33 + 16);
    uint64_t v34 = v33 + 8;
    *((_DWORD *)v28 + 15) = v35;
    if (v32 != -1) {
      LODWORD(v28[5 * v32 + 8]) = v31;
    }
    if (*((_DWORD *)v28 + 13) == -1) {
      *((_DWORD *)v28 + 13) = v31;
    }
    *((_DWORD *)v28 + 14) = v31;
    *uint64_t v34 = -1;
    ++*((_DWORD *)v28 + 12);
    uint64_t v36 = &v28[5 * v31];
    *((_DWORD *)v36 + 18) = a2;
    *((_DWORD *)v36 + 19) = a3;
    v36[10] = a4;
    v36[11] = a5;
    v36[12] = v30;
    *((_DWORD *)v36 + 17) = v26 | (a7 << 31 >> 31) & 0xC | 3;
    if (v18)
    {
      int8x16_t v40 = v42;
      uint64_t v41 = v43;
      uint64_t v19 = sub_100026BA0(a1->i64, 0, (uint64_t)v18, (uint64_t)&v40, v42, v16);
      if (v19) {
        goto LABEL_19;
      }
    }
    int8x16_t v40 = v44;
    uint64_t v41 = v45;
    uint64_t v17 = sub_100026BA0(a1->i64, 0, (uint64_t)v46, (uint64_t)&v40, v44, v16);
    if (!v17)
    {
      uint64_t v38 = a1[1].i64[0];
      int8x16_t v40 = a1[4];
      uint64_t v41 = a1[5].i64[0];
      uint64_t v17 = sub_100026BA0(a1->i64, 0, v38, (uint64_t)&v40, v40, v37);
    }
    if (v18) {
      goto LABEL_23;
    }
  }
LABEL_24:
  if (v46) {
    free(v46);
  }
  return v17;
}

uint64_t sub_100031484(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4)
{
  memset(v18, 170, sizeof(v18));
  uint64_t v7 = a1[2];
  uint64_t result = sub_100030918(a1, 18, 0, *(unsigned int *)(a1[1] + 36), 0, (void *)&v18[1] + 1, (uint64_t)v18);
  if (result) {
    return result;
  }
  uint64_t v9 = *((void *)&v18[1] + 1);
  *(void *)(*((void *)&v18[1] + 1) + 32) = 0;
  unint64_t v10 = ((unint64_t)DWORD2(v18[0]) - 64) / 0x28;
  *(_DWORD *)(v9 + 44) = v10;
  *(void *)(v9 + 52) = -1;
  *(_DWORD *)(v9 + 60) = 0;
  if (v10)
  {
    unint64_t v11 = 0;
    unsigned int v12 = (int *)(v9 + 64);
    do
    {
      unint64_t v13 = v11 + 1;
      if (v11 >= (v10 - 1)) {
        int v14 = -1;
      }
      else {
        int v14 = v11 + 1;
      }
      *unsigned int v12 = v14;
      v12 += 10;
      unint64_t v11 = v13;
    }
    while (v13 < v10);
  }
  uint64_t v15 = *(void *)(v9 + 8);
  *(void *)(v7 + 56) = v15;
  if (!a2)
  {
    *(void *)(v7 + 48) = v15;
    int v17 = 1;
    goto LABEL_12;
  }
  *(void *)(a2 + 32) = v15;
  int v16 = *(_DWORD *)(v7 + 68);
  if (v16)
  {
    int v17 = v16 + 1;
LABEL_12:
    *(_DWORD *)(v7 + 68) = v17;
  }
  if (a4)
  {
    *(_OWORD *)a4 = v18[0];
    *(void *)(a4 + --*(_DWORD *)(result + 16) = *(void *)&v18[1];
  }
  uint64_t result = 0;
  *a3 = v9;
  return result;
}

uint64_t sub_100031594(uint64_t *a1, char a2, char a3, unint64_t a4)
{
  unint64_t v4 = a4;
  if (*(unsigned int *)(a1[1] + 36) * a4 >= 0x100000) {
    size_t v8 = 0x100000;
  }
  else {
    size_t v8 = *(unsigned int *)(a1[1] + 36) * a4;
  }
  uint64_t v9 = malloc_type_malloc(v8, 0xFE5B9DEBuLL);
  if (v9)
  {
    int v17 = v9;
    if (v4)
    {
      unint64_t v18 = v8 / *(_DWORD *)(a1[1] + 36);
      while (1)
      {
        if (v4 >= v18) {
          unint64_t v19 = v18;
        }
        else {
          unint64_t v19 = v4;
        }
        uint64_t v20 = sub_10001E404(*a1);
        if (v20)
        {
          uint64_t v22 = v20;
          strerror(v20);
          sub_10004458C("blockcopy: unable to read paddr 0x%llx block_count 0x%llx: %s\n", v23, v24, v25, v26, v27, v28, v29, a2);
          uint64_t v30 = 611;
          goto LABEL_17;
        }
        uint64_t v21 = sub_10001E414(*a1);
        if (v21) {
          break;
        }
        a2 += v19;
        a3 += v19;
        v4 -= v19;
        if (!v4) {
          goto LABEL_13;
        }
      }
      uint64_t v22 = v21;
      strerror(v21);
      sub_10004458C("blockcopy: unable to write paddr 0x%llx block_count 0x%llx: %s\n", v31, v32, v33, v34, v35, v36, v37, a3);
      uint64_t v30 = 612;
LABEL_17:
      sub_100048B34((char *)v30, v22);
    }
    else
    {
LABEL_13:
      uint64_t v22 = 0;
    }
    free(v17);
  }
  else
  {
    sub_10004458C("blockcopy: unable to allocate memory for buffer_size 0x%zx.\n", v10, v11, v12, v13, v14, v15, v16, v8);
    uint64_t v22 = 12;
    sub_100048B34((char *)0x262, 12);
  }
  return v22;
}

uint64_t sub_1000316F4(uint64_t a1, char a2, unint64_t a3, int a4, int a5, int a6, int8x16_t a7, int8x16_t a8)
{
  uint64_t v13 = (void *)(a1 + 8);
  if (sub_10003D848((void *)a1, (uint32x4_t *)(a1 + 8), (a6 - 8), 0, a7, a8))
  {
    sub_10004458C("object (oid 0x%llx): o_cksum (0x%llx) is invalid for object\n", v14, v15, v16, v17, v18, v19, v20, *(void *)(a1 + 8));
    uint64_t v21 = 92;
    sub_100048B34((char *)5, 92);
    if ((a2 & 1) == 0)
    {
LABEL_6:
      if ((a2 & 2) == 0) {
        goto LABEL_12;
      }
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v21 = 0;
    if ((a2 & 1) == 0) {
      goto LABEL_6;
    }
  }
  if (*v13) {
    goto LABEL_6;
  }
  sub_10004458C("object (oid 0x%llx): o_oid invalid\n", v14, v15, v16, v17, v18, v19, v20, 0);
  uint64_t v21 = 92;
  sub_100048B34((char *)6, 92);
  if ((a2 & 2) == 0) {
    goto LABEL_12;
  }
LABEL_7:
  unint64_t v22 = *(void *)(a1 + 16);
  if (!v22)
  {
    sub_10004458C("object (oid 0x%llx): o_xid invalid, o_xid is 0\n", v14, v15, v16, v17, v18, v19, v20, *(void *)(a1 + 8));
    uint64_t v21 = 92;
    sub_100048B34((char *)7, 92);
    unint64_t v22 = *(void *)(a1 + 16);
  }
  if (v22 > a3)
  {
    sub_10004458C("object (oid 0x%llx): o_xid invalid, o_xid %llu is greater than nx_next_xid: %llu\n", v14, v15, v16, v17, v18, v19, v20, *v13);
    uint64_t v21 = 92;
    sub_100048B34((char *)8, 92);
  }
LABEL_12:
  if ((a2 & 4) != 0 && *(_DWORD *)(a1 + 24) != a4)
  {
    sub_10004458C("object (oid 0x%llx): o_type invalid, o_type 0x%x should be 0x%x\n", v14, v15, v16, v17, v18, v19, v20, *v13);
    uint64_t v21 = 92;
    sub_100048B34((char *)9, 92);
  }
  if ((a2 & 8) != 0 && *(_DWORD *)(a1 + 28) != a5)
  {
    sub_10004458C("object (oid 0x%llx): o_subtype invalid, o_subtype 0x%x should be 0x%x\n", v14, v15, v16, v17, v18, v19, v20, *v13);
    uint64_t v21 = 92;
    sub_100048B34((char *)0xA, 92);
  }
  return v21;
}

unsigned int *sub_100031898(uint64_t a1, int a2, unsigned char *a3)
{
  unsigned int v5 = sub_10002F088(a1);
  if (v5 <= 0x1000) {
    size_t v6 = 4096;
  }
  else {
    size_t v6 = v5;
  }
  unint64_t v7 = sub_10002F094(a1);
  size_t v8 = (unsigned int *)malloc_type_calloc(1uLL, v6, 0x3438CF90uLL);
  if (v8)
  {
    uint64_t v16 = v8;
    while (1)
    {
      unint64_t v17 = 0x4000000000000000uLL >> __clz(__rbit64(v6));
      if (a2) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 0;
      }
      sub_10002F088(a1);
      int v19 = sub_10002F148(a1, v18);
      if (v19)
      {
        int v40 = v19;
        sub_10004458C("failed to read container superblock\n", v20, v21, v22, v23, v24, v25, v26, v60);
        uint64_t v39 = 87;
        int v41 = v40;
        goto LABEL_32;
      }
      if (v16[8] != 1112758350)
      {
        sub_100037DA0((unsigned __int8 *)v16, v6);
        sub_10004458C("Device does not contain a valid APFS container.\n", v42, v43, v44, v45, v46, v47, v48, v60);
        uint64_t v39 = 88;
        goto LABEL_31;
      }
      v27.i32[0] = v16[9];
      if ((v27.i32[0] - 65537) < 0xFFFF0FFF
        || (v28 = v27.i32[0] % sub_10002F088(a1), int8x8_t v27 = (int8x8_t)v16[9], v28)
        || (uint8x8_t v29 = (uint8x8_t)vcnt_s8(v27), v29.i16[0] = vaddlv_u8(v29), v29.i32[0] >= 2u))
      {
        sub_10004458C("nx_block_size of %u is invalid\n", v20, v21, v22, v23, v24, v25, v26, v27.i8[0]);
        uint64_t v39 = 89;
        goto LABEL_31;
      }
      if (v27.i32[0] == sub_10002F088(a1)) {
        break;
      }
      sub_10002F130(a1);
      size_t v6 = v16[9];
      free(v16);
      unint64_t v7 = sub_10002F094(a1);
      uint64_t v16 = (unsigned int *)malloc_type_calloc(1uLL, v6, 0x3438CF90uLL);
      if (!v16) {
        goto LABEL_16;
      }
    }
    if (*((void *)v16 + 5) - 1 < v7) {
      goto LABEL_23;
    }
    if (*((unsigned char *)v16 + 65))
    {
      sub_10004458C("nx_block_count is %llu, while device block count is %llu\n", v30, v31, v32, v33, v34, v35, v36, *((void *)v16 + 5));
      uint64_t v39 = 1225;
      int v41 = 92;
      goto LABEL_32;
    }
    sub_100044674("nx_block_count is %llu, while device block count is %llu\n", v30, v31, v32, v33, v34, v35, v36, *((void *)v16 + 5));
    sub_100048B34((char *)0x1F9, -7);
    *((void *)v16 + 5) = v7;
    *a3 = 1;
LABEL_23:
    if (!sub_1000316F4((uint64_t)v16, 15, *((void *)v16 + 12), -2147483647, 0, v16[9], v37, v38)) {
      return v16;
    }
    uint64_t v95 = 0;
    long long v94 = 0u;
    long long v93 = 0u;
    long long v92 = 0u;
    long long v91 = 0u;
    long long v90 = 0u;
    long long v89 = 0u;
    long long v88 = 0u;
    long long v87 = 0u;
    long long v86 = 0u;
    long long v85 = 0u;
    long long v84 = 0u;
    long long v83 = 0u;
    long long v82 = 0u;
    long long v81 = 0u;
    long long v80 = 0u;
    long long v79 = 0u;
    long long v78 = 0u;
    long long v77 = 0u;
    long long v76 = 0u;
    long long v75 = 0u;
    long long v74 = 0u;
    long long v73 = 0u;
    long long v72 = 0u;
    long long v71 = 0u;
    long long v70 = 0u;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    long long v65 = 0u;
    long long v64 = 0u;
    v63[0] = a1;
    v63[1] = v16;
    v62[0] = v63;
    v62[1] = 0;
    unsigned int v56 = v16[26];
    if ((v56 & 0x7FFFFFF8) == 0
      || ((uint64_t v57 = *((void *)v16 + 14), (v56 & 0x80000000) != 0)
        ? (int v58 = sub_1000310DC((uint64_t)v63, v57, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048EBC, (uint64_t)v62)): (v96[1] = v16[26], v97 = 0, v96[0] = v57, int v58 = sub_100048EBC((uint64_t)&v97, 8, v96, 16, v62, v53, v54, v55)), v58))
    {
      sub_10004458C("cannot find checkpoint area because container superblock is too damaged\n", v49, v50, v51, v52, v53, v54, v55, v60);
      uint64_t v39 = 506;
LABEL_31:
      int v41 = 22;
LABEL_32:
      sub_100048B34((char *)v39, v41);
      free(v16);
      return 0;
    }
    *a3 = 1;
  }
  else
  {
LABEL_16:
    sub_10004458C("failed to allocate memory to read the container superblock\n", v9, v10, v11, v12, v13, v14, v15, v60);
    sub_100048B34((char *)0x56, 12);
    return 0;
  }
  return v16;
}

uint64_t sub_100031C60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 8) != 1)
  {
    sub_10004458C("nx_sb->nx_o.o_oid != OID_NX_SUPERBLOCK, %llu\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(a2 + 8));
    uint64_t v20 = 92;
    uint64_t v21 = 51;
    goto LABEL_12;
  }
  if (*(_DWORD *)(a2 + 32) != 1112758350)
  {
    sub_10004458C("nx_superblock magic number invalid: 0x%X\n", a2, a3, a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 32));
    uint64_t v20 = 92;
    uint64_t v21 = 52;
    goto LABEL_12;
  }
  char v9 = a3;
  if (*(void *)(a2 + 40) - 1 >= (unint64_t)sub_10002F094(a1))
  {
    sub_10004458C("nx_block_count is %llu, while device block count is %llu\n", v11, v12, v13, v14, v15, v16, v17, *(void *)(a2 + 40));
    uint64_t v23 = 53;
    int v24 = 92;
    goto LABEL_15;
  }
  if ((*(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFFCLL) != 0)
  {
    sub_100044674("nx_features has unsupported flags: (0x%llX)\n", v11, v12, v13, v14, v15, v16, v17, *(unsigned char *)(a2 + 48) & 0xFC);
    sub_100048B34((char *)0x36, -3);
  }
  if (*(void *)(a2 + 56))
  {
    sub_100044674("nx_read_only_compatible_features has unsupported flags: (0x%llX)\n", v11, v12, v13, v14, v15, v16, v17, *(void *)(a2 + 56));
    uint64_t v18 = qword_100091B78;
    *(_DWORD *)(qword_100091B78 + 28) = 1;
    *(unsigned char *)(v18 + 37) = 1;
    sub_100046400(qword_100091B70, 1);
    sub_100048B34((char *)0x37, -3);
  }
  uint64_t v19 = *(void *)(a2 + 64);
  if ((v19 & 0xFFFFFFFFFFFFFEFDLL) != 0)
  {
    sub_10004458C("nx_incompatible_features has unsupported flags: (0x%llX)\n", v11, v12, v13, v14, v15, v16, v17, v19 & 0xFD);
    uint64_t v20 = 92;
    uint64_t v21 = 56;
LABEL_12:
    sub_100048B34((char *)v21, 92);
    return v20;
  }
  if (uuid_is_null((const unsigned __int8 *)(a2 + 72)))
  {
    sub_10004458C("nx_uuid is NULL\n", v25, v26, v27, v28, v29, v30, v31, v82);
    uint64_t v20 = 92;
    uint64_t v21 = 57;
    goto LABEL_12;
  }
  if (*(void *)(a2 + 88) <= 0x3FFuLL)
  {
    sub_10004458C("nx_next_oid (%llu) is less than the minimum (%u)\n", v25, v26, v27, v28, v29, v30, v31, *(void *)(a2 + 88));
    uint64_t v20 = 92;
    uint64_t v21 = 58;
    goto LABEL_12;
  }
  uint64_t v118 = 0;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v110 = 0u;
  long long v111 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v102 = 0u;
  long long v103 = 0u;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  long long v92 = 0u;
  long long v93 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  long long v88 = 0u;
  long long v89 = 0u;
  long long v87 = 0u;
  uint64_t v85 = a1;
  uint64_t v86 = a2;
  unsigned int v32 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  long long v83 = &v85;
  uint64_t v84 = 0;
  if (v32 <= 7)
  {
    sub_10004458C("nx_xp_desc_blocks (%u) is less than 8\n", v25, v26, v27, v28, v29, v30, v31, v32);
    uint64_t v20 = 92;
    uint64_t v21 = 59;
    goto LABEL_12;
  }
  if (sub_10003259C((uint64_t)&v85, &v83, v26, v27, v28, v29, v30, v31))
  {
    sub_10004458C("NX checkpoint desc range is invalid: 0x%llx+0x%x\n", v33, v34, v35, v36, v37, v38, v39, *(void *)(a2 + 112));
    uint64_t v20 = 92;
    uint64_t v21 = 60;
    goto LABEL_12;
  }
  if (v84 != (*(_DWORD *)(a2 + 104) & 0x7FFFFFFF))
  {
    sub_10004458C("NX checkpoint desc blocks field is %u, but sum of ranges is %llu\n", v33, v34, v35, v36, v37, v38, v39, *(unsigned char *)(a2 + 104));
    uint64_t v20 = 92;
    uint64_t v21 = 574;
    goto LABEL_12;
  }
  if ((*(_DWORD *)(a2 + 108) & 0x7FFFFFFFu) <= 7)
  {
    sub_10004458C("nx_xp_data_blocks (%u) is less than 8\n", v33, v34, v35, v36, v37, v38, v39, *(unsigned char *)(a2 + 108));
    uint64_t v20 = 92;
    uint64_t v21 = 61;
    goto LABEL_12;
  }
  uint64_t v84 = 0;
  if (sub_100032618((uint64_t)&v85, (uint64_t (*)(void *, uint64_t, void *, uint64_t, uint64_t))sub_100048EBC, (uint64_t)&v83))
  {
    sub_10004458C("NX checkpoint data range is invalid: 0x%llx+0x%x\n", v40, v41, v42, v43, v44, v45, v46, *(void *)(a2 + 120));
    uint64_t v20 = 92;
    uint64_t v21 = 62;
    goto LABEL_12;
  }
  uint64_t v47 = *(_DWORD *)(a2 + 108) & 0x7FFFFFFF;
  if (v84 != v47)
  {
    sub_10004458C("NX checkpoint data blocks field is %u, but sum of ranges is %llu\n", v40, v41, v42, v43, v44, v45, v46, *(unsigned char *)(a2 + 108));
    uint64_t v20 = 92;
    uint64_t v21 = 575;
    goto LABEL_12;
  }
  unsigned int v48 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (*(_DWORD *)(a2 + 128) >= v48)
  {
    sub_10004458C("nx_xp_desc_next (%u) is larger than the # of nx_xp_desc_blocks (%u)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 128));
    uint64_t v20 = 92;
    uint64_t v21 = 63;
    goto LABEL_12;
  }
  if (*(_DWORD *)(a2 + 132) >= v47)
  {
    sub_10004458C("nx_xp_data_next (%u) is larger than the # of nx_xp_data_blocks (%u)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 132));
    uint64_t v20 = 92;
    uint64_t v21 = 64;
    goto LABEL_12;
  }
  if ((v9 & 1) != 0 || *(_DWORD *)(a2 + 140) || *(_DWORD *)(a2 + 148) || *(_DWORD *)(a2 + 136) || *(_DWORD *)(a2 + 144))
  {
    if (*(_DWORD *)(a2 + 136) >= v48)
    {
      sub_10004458C("nx_xp_desc_index (%u) is larger than nx_xp_desc_blocks (%u)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 136));
      uint64_t v20 = 92;
      uint64_t v21 = 65;
      goto LABEL_12;
    }
    unsigned int v49 = *(_DWORD *)(a2 + 140);
    if (v49 <= 1)
    {
      sub_10004458C("nx_xp_desc_len (%u) is less than 2\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 140));
      uint64_t v20 = 92;
      uint64_t v21 = 66;
      goto LABEL_12;
    }
    if (v49 >= v48)
    {
      sub_10004458C("nx_xp_desc_len (%u) is larger than nx_xp_desc_blocks (%u)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 140));
      uint64_t v20 = 92;
      uint64_t v21 = 67;
      goto LABEL_12;
    }
    if (*(_DWORD *)(a2 + 144) >= v47)
    {
      sub_10004458C("nx_xp_data_index (%u) is is larger than nx_xp_data_blocks (%u)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 144));
      uint64_t v20 = 92;
      uint64_t v21 = 68;
      goto LABEL_12;
    }
    unsigned int v50 = *(_DWORD *)(a2 + 148);
    if (v50 <= 1)
    {
      sub_10004458C("nx_xp_data_len (%u) is less than 2\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 148));
      uint64_t v20 = 92;
      uint64_t v21 = 69;
      goto LABEL_12;
    }
    if (v50 >= v47)
    {
      sub_10004458C("nx_xp_data_len (%u) is larger than nx_xp_data_blocks (%u)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 148));
      uint64_t v20 = 92;
      uint64_t v21 = 70;
      goto LABEL_12;
    }
  }
  if (!*(void *)(a2 + 152))
  {
    sub_10004458C("nx_spaceman_oid is invalid\n", v40, v41, v42, v43, v44, v45, v46, v82);
    uint64_t v20 = 92;
    uint64_t v21 = 71;
    goto LABEL_12;
  }
  if (!*(void *)(a2 + 160))
  {
    sub_10004458C("nx_omap_oid is invalid\n", v40, v41, v42, v43, v44, v45, v46, v82);
    uint64_t v20 = 92;
    uint64_t v21 = 72;
    goto LABEL_12;
  }
  if ((unint64_t)(*(void *)(a2 + 168) - 1) <= 0x3FE)
  {
    sub_10004458C("nx_reaper_oid (%llu) is less than minimum OID (%d)\n", v40, v41, v42, v43, v44, v45, v46, *(void *)(a2 + 168));
    uint64_t v20 = 92;
    uint64_t v21 = 73;
    goto LABEL_12;
  }
  if ((*(_DWORD *)(a2 + 180) - 101) < 0xFFFFFF9C)
  {
    sub_10004458C("nx_max_file_systems (%u) is invalid\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 180));
    uint64_t v20 = 92;
    uint64_t v21 = 74;
    goto LABEL_12;
  }
  uint64_t v51 = 0;
  unint64_t v52 = v19 & 0x100;
  do
  {
    uint64_t v53 = *(void *)(a2 + 184 + 8 * v51);
    if ((unint64_t)(v53 - 1) < 0x3FF)
    {
      sub_10004458C("nx_fs_oid (%llu) at index (%d) is less than minimum OID (%d)\n", v40, v41, v42, v43, v44, v45, v46, v53);
      uint64_t v20 = 92;
      uint64_t v21 = 75;
      goto LABEL_12;
    }
    ++v51;
  }
  while (v51 != 100);
  if (*(void *)(a2 + 1264) >= 8uLL)
  {
    sub_100044674("nx_flags (0x%llx) has an unknown flag set \n", v40, v41, v42, v43, v44, v45, v46, *(void *)(a2 + 1264));
    sub_100048B34((char *)0x4C, -3);
  }
  int v54 = *(_DWORD *)(a2 + 1316);
  int v55 = HIWORD(*(_DWORD *)(a2 + 1312));
  if ((unsigned __int16)*(_DWORD *)(a2 + 1312) != 1)
  {
    sub_100044674("nx_ephemeral_info 0: invalid version (%u), should be: (%d)\n", v40, v41, v42, v43, v44, v45, v46, *(_DWORD *)(a2 + 1312));
    sub_100048B34((char *)0x4D, -6);
  }
  if (v55 != 4)
  {
    sub_100044674("nx_ephemeral_info 0: invalid structures per fs (%u), should be: (%d)\n", v40, v41, v42, v43, v44, v45, v46, v55);
    sub_100048B34((char *)0x4E, -8);
  }
  if ((v54 - 9) <= 0xFFFFFFF7)
  {
    sub_100044674("nx_ephemeral_info 0: invalid minimum block count per structure (%u), should be less than: (%d)\n", v40, v41, v42, v43, v44, v45, v46, v55);
    sub_100048B34((char *)0x4F, -7);
  }
  for (uint64_t i = 0; i != 3; ++i)
  {
    if (*(void *)(a2 + 1320 + 8 * i))
    {
      sub_100044674("nx_ephemeral_info %d: invalid info (0x%llx)\n", v40, v41, v42, v43, v44, v45, v46, i + 1);
      sub_100048B34((char *)0x50, -10);
    }
  }
  if (*(void *)(a2 + 1400))
  {
    unint64_t v57 = *(void *)(a2 + 1392);
    if (!sub_1000102B0((uint64_t)&v85, v57, *(void *)(a2 + 1400)))
    {
      sub_10004458C("NX media keylocker data range is invalid: 0x%llx+%llu\n", v40, v41, v42, v43, v44, v45, v46, v57);
      uint64_t v20 = 92;
      uint64_t v21 = 949;
      goto LABEL_12;
    }
  }
  if (*(void *)(a2 + 1304))
  {
    unint64_t v58 = *(void *)(a2 + 1296);
    if (!sub_1000102B0((uint64_t)&v85, v58, *(void *)(a2 + 1304)))
    {
      sub_10004458C("NX keybag data range is invalid: 0x%llx+%llu\n", v40, v41, v42, v43, v44, v45, v46, v58);
      uint64_t v20 = 92;
      uint64_t v21 = 81;
      goto LABEL_12;
    }
  }
  if (*(void *)(a2 + 1248))
  {
    unint64_t v59 = *(void *)(a2 + 1240);
    if (!sub_1000102B0((uint64_t)&v85, v59, *(void *)(a2 + 1248)))
    {
      sub_10004458C("NX blocked out range is invalid: 0x%llx+%llu\n", v40, v41, v42, v43, v44, v45, v46, v59);
      uint64_t v20 = 92;
      uint64_t v21 = 82;
      goto LABEL_12;
    }
  }
  uint64_t v60 = *(void *)(a2 + 1352);
  if ((v60 != 0) != (v52 >> 8))
  {
    if (v52) {
      long long v67 = "nx_fusion_mt_oid is invalid\n";
    }
    else {
      long long v67 = "nx_fusion_mt_oid should be invalid but isn't\n";
    }
    sub_10004458C(v67, v40, v41, v42, v43, v44, v45, v46, v82);
    uint64_t v20 = 92;
    uint64_t v21 = 83;
    goto LABEL_12;
  }
  if ((*(void *)(a2 + 1360) == 0) == (v60 != 0))
  {
    if (v52) {
      long long v68 = "nx_fusion_wbc_oid is invalid\n";
    }
    else {
      long long v68 = "nx_fusion_wbc_oid should be invalid but isn't\n";
    }
    sub_10004458C(v68, v40, v41, v42, v43, v44, v45, v46, v82);
    uint64_t v20 = 92;
    uint64_t v21 = 84;
    goto LABEL_12;
  }
  if (v52)
  {
    unint64_t v61 = *(void *)(a2 + 1368);
    unint64_t v62 = *(void *)(a2 + 1376);
    if (!v61
      || (*((void *)&v87 + 1)
        ? (uint64_t v63 = (unint64_t *)(*((void *)&v87 + 1) + 48))
        : (uint64_t v63 = (unint64_t *)(v86 + 40)),
          (unint64_t v64 = *v63, v64 > v62) ? (v65 = v64 > v61) : (v65 = 0),
          v65 ? (BOOL v66 = v64 - v62 >= v61) : (BOOL v66 = 0),
          !v66))
    {
      sub_10004458C("nx_fusion_wbc range is invalid: 0x%llx+%llu\n", v40, v41, v42, v43, v44, v45, v46, *(void *)(a2 + 1368));
      uint64_t v20 = 92;
      uint64_t v21 = 85;
      goto LABEL_12;
    }
  }
  unint64_t v69 = *(void *)(a2 + 1384);
  unint64_t v70 = v69 / 0xE8D4A51000;
  if (v69 > 0x3B9AC9BB15066FFFLL || (uint64_t v20 = 0, v69) && v70 <= 0x538)
  {
    memset(v120, 170, 17);
    *(void *)__str = 0xAAAAAAAAAAAAAAAALL;
    long long v71 = sub_10001F194(v69, __str, 25);
    LOBYTE(v79) = (_BYTE)v71;
    if (!v71)
    {
      long long v79 = __str;
      snprintf(__str, 0x19uLL, "%llu", v69);
    }
    if (v69 <= 0x3B9AC9BB15066FFFLL)
    {
      if (v70)
      {
        if (v70 > 0x538) {
          return 0;
        }
        uint64_t v80 = 860;
        long long v81 = "nx_newest_mounted_version is less than expected: %s\n";
      }
      else
      {
        uint64_t v80 = 859;
        long long v81 = "nx_newest_mounted_version should not start with a 0: %s\n";
      }
    }
    else
    {
      uint64_t v80 = 858;
      long long v81 = "nx_newest_mounted_version is greater than expected: %s\n";
    }
    sub_100044674(v81, v72, v73, v74, v75, v76, v77, v78, (char)v79);
    uint64_t v23 = v80;
    int v24 = -6;
LABEL_15:
    sub_100048B34((char *)v23, v24);
    return 0;
  }
  return v20;
}

uint64_t sub_10003259C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 8);
  unint64_t v10 = *(unsigned int *)(v9 + 104);
  uint64_t v11 = *(void *)(v9 + 112);
  if ((v10 & 0x80000000) != 0)
  {
    return sub_1000310DC(a1, v11, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048EBC, (uint64_t)a2);
  }
  else
  {
    uint64_t v14 = 0;
    v13[0] = v11;
    v13[1] = v10;
    return sub_100048EBC((uint64_t)&v14, 8, v13, 16, a2, a6, a7, a8);
  }
}

uint64_t sub_100032618(uint64_t a1, uint64_t (*a2)(void *, uint64_t, void *, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = *(unsigned int *)(v4 + 108);
  uint64_t v6 = *(void *)(v4 + 120);
  if ((v5 & 0x80000000) != 0)
  {
    return sub_1000310DC(a1, v6, (uint64_t (*)(void, void, void, void, uint64_t))a2, a3);
  }
  else
  {
    uint64_t v9 = 0;
    v8[0] = v6;
    v8[1] = v5;
    return a2(&v9, 8, v8, 16, a3);
  }
}

uint64_t sub_10003268C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (a4) {
    uint64_t v11 = "tier2 superblock";
  }
  else {
    uint64_t v11 = "main superblock";
  }
  if (a3 && (unint64_t v12 = *(void *)(a2 + 16), *(void *)(a1 + 16) > v12))
  {
    sub_100044548("the checkpoint superblock has a lower o_xid (%lld) than the %s (%lld)\n", a2, a3, a4, a5, a6, a7, a8, v12);
  }
  else if (*(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 36))
  {
    if (*(void *)(a1 + 40) == *(void *)(a2 + 40))
    {
      if (uuid_compare((const unsigned __int8 *)(a1 + 72), (const unsigned __int8 *)(a2 + 72)))
      {
        sub_100044548("checkpoint<->%s mismatch on uuid\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
      }
      else
      {
        BOOL v20 = *(void *)(a1 + 1280) == *(void *)(a2 + 1280) && *(void *)(a1 + 1287) == *(void *)(a2 + 1287);
        if (v20 && (*(unsigned __int8 *)(a2 + 1295) ^ *(unsigned __int8 *)(a1 + 1295)) == v8)
        {
          if (*(_DWORD *)(a1 + 104) == *(_DWORD *)(a2 + 104))
          {
            if (*(_DWORD *)(a1 + 108) == *(_DWORD *)(a2 + 108))
            {
              if (*(void *)(a1 + 112) == *(void *)(a2 + 112))
              {
                if (*(void *)(a1 + 120) == *(void *)(a2 + 120)) {
                  return 0;
                }
                sub_100044548("checkpoint<->%s mismatch on nx_xp_data_base: %lld %lld\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
              }
              else
              {
                sub_100044548("checkpoint<->%s mismatch on nx_xp_desc_base: %lld %lld\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
              }
            }
            else
            {
              sub_100044548("checkpoint<->%s mismatch on nx_xp_data_blocks: %d %d\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
            }
          }
          else
          {
            sub_100044548("checkpoint<->%s mismatch on nx_xp_desc_blocks: %d %d\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
          }
        }
        else
        {
          sub_100044548("checkpoint<->%s mismatch on fusion uuid\n", v13, v14, v15, v16, v17, v18, v19, (char)v11);
        }
      }
    }
    else
    {
      sub_100044548("checkpoint<->%s mismatch on nx_block_count: %lld %lld\n", a2, a3, a4, a5, a6, a7, a8, (char)v11);
    }
  }
  else
  {
    sub_100044548("checkpoint<->%s mismatch on nx_block_size: %d %d\n", a2, a3, a4, a5, a6, a7, a8, (char)v11);
  }
  return 92;
}

uint64_t sub_100032850(uint64_t a1, uint64_t a2, void **a3, unint64_t *a4)
{
  uint64_t v170 = a4;
  uint64_t v171 = v165;
  __chkstk_darwin(a1);
  uint64_t v14 = &v165[-((v8 + 15) & 0x1FFFFFFF0)];
  if (v8) {
    memset(&v165[-((v8 + 15) & 0x1FFFFFFF0)], 170, v8);
  }
  unint64_t v208 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = *(void *)(a2 + 1264);
  long long v206 = 0u;
  long long v207 = 0u;
  long long v204 = 0u;
  long long v205 = 0u;
  long long v202 = 0u;
  long long v203 = 0u;
  long long v200 = 0u;
  long long v201 = 0u;
  long long v198 = 0u;
  long long v199 = 0u;
  long long v196 = 0u;
  long long v197 = 0u;
  long long v194 = 0u;
  long long v195 = 0u;
  long long v192 = 0u;
  long long v193 = 0u;
  long long v191 = 0u;
  long long v190 = 0u;
  long long v189 = 0u;
  long long v188 = 0u;
  long long v187 = 0u;
  long long v186 = 0u;
  long long v185 = 0u;
  long long v184 = 0u;
  long long v182 = 0u;
  long long v183 = 0u;
  long long v180 = 0u;
  long long v181 = 0u;
  long long v178 = 0u;
  long long v179 = 0u;
  long long v176 = 0u;
  long long v177 = 0u;
  uint64_t v175 = a1;
  *a3 = 0;
  int v16 = *(_DWORD *)(a2 + 140);
  uint64_t v172 = a3;
  if (!v16
    || !*(_DWORD *)(a2 + 148)
    || !*(_DWORD *)(a2 + 136)
    || !*(_DWORD *)(a2 + 144)
    || sub_10002F13C(a1)
    || (v15 & 2) == 0)
  {
    goto LABEL_136;
  }
  unsigned int v17 = (*(_DWORD *)(a2 + 140) + *(_DWORD *)(a2 + 136) - 1) % (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu);
  int v18 = 1;
  int v173 = 1;
  int v174 = v17;
  do
  {
    int v19 = 0;
    while (1)
    {
      int v20 = *(_DWORD *)(a2 + 104);
      unsigned int v21 = v174 - v19 + (v20 & 0x7FFFFFFF);
      uint64_t v22 = v21 % (v20 & 0x7FFFFFFFu);
      *(void *)&long long v176 = a2;
      uint64_t v23 = *(void *)(a2 + 112);
      if (v20 < 0)
      {
        int v38 = sub_100030FD4((uint64_t)&v175, v23, v21 % (v20 & 0x7FFFFFFFu), &v208, 0);
        if (v38)
        {
          int v28 = v38;
          char v39 = strerror(v38);
          sub_100044674("failed to look up checkpoint block address: %s\n", v40, v41, v42, v43, v44, v45, v46, v39);
          uint64_t v37 = 542;
          goto LABEL_17;
        }
        uint64_t v24 = v208;
      }
      else
      {
        uint64_t v24 = v23 + v22;
        unint64_t v208 = v24;
      }
      int v25 = sub_10002F148(a1, v24);
      if (v25)
      {
        int v28 = v25;
        char v29 = v208;
        strerror(v25);
        sub_10004458C("dev_read(%llu, 1): %s\n", v30, v31, v32, v33, v34, v35, v36, v29);
        uint64_t v37 = 127;
LABEL_17:
        int v47 = v28;
LABEL_18:
        sub_100048B34((char *)v37, v47);
        goto LABEL_19;
      }
      if (!*((void *)v14 + 1) && *a3) {
        return 0;
      }
      if (*((_DWORD *)v14 + 6) == -2147483647) {
        break;
      }
LABEL_19:
      if (++v19 == v18) {
        goto LABEL_134;
      }
    }
    if (sub_1000316F4((uint64_t)v14, 11, *((void *)v14 + 2), 0, 0, *(_DWORD *)(a2 + 36), v26, v27))
    {
      sub_100044674("checkpoint %d (xid %llu) fsck_obj_phys failed\n", v48, v49, v50, v51, v52, v53, v54, v22);
      goto LABEL_19;
    }
    if (sub_10003268C(a2, (uint64_t)v14, v19 == 0, 0, v51, v52, v53, v54))
    {
      sub_100044674("checkpoint %d (xid %llu) superblock disagrees with block 0\n", v7, v8, v9, v10, v11, v12, v13, v22);
      goto LABEL_19;
    }
    int v55 = *((_DWORD *)v14 + 35);
    unsigned int v56 = (v55 + *((_DWORD *)v14 + 34) - 1) % (*((_DWORD *)v14 + 26) & 0x7FFFFFFFu);
    if (v22 != v56)
    {
      sub_100044674("xp_sb->nx_xp_desc_index (%d) doesn't match index block (%d)\n", v7, v8, v9, v10, v11, v12, v13, v56);
      uint64_t v37 = 128;
      int v47 = -7;
      goto LABEL_18;
    }
    if (v55 + v19 > (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu)) {
      goto LABEL_19;
    }
    if (sub_100031C60(a1, (uint64_t)v14, 1, v9, v10, v11, v12, v13))
    {
      sub_100044674("checkpoint %d (xid %llu) superblock is invalid\n", v57, v58, v59, v60, v61, v62, v63, v22);
      goto LABEL_19;
    }
    *(void *)&long long v176 = v14;
    uint64_t v209 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v210 = 0;
    if (*((_DWORD *)v14 + 35) == 1) {
      goto LABEL_113;
    }
    int v64 = 0;
    while (1)
    {
      int v65 = *((_DWORD *)v14 + 34);
      int v166 = v64;
      uint64_t v66 = (v65 + v64) % (*((_DWORD *)v14 + 26) & 0x7FFFFFFFu);
      int v67 = *(_DWORD *)(v176 + 104);
      if ((v67 & 0x7FFFFFFFu) <= v66)
      {
        int v69 = 22;
LABEL_97:
        LODWORD(v169) = v69;
        strerror(v69);
        sub_10004458C("failed to look up checkpoint block address %d: %s\n", v97, v98, v99, v100, v101, v102, v103, v66);
        uint64_t v104 = 540;
        int v115 = (int)v169;
        int v105 = (int)v169;
        goto LABEL_104;
      }
      uint64_t v68 = *(void *)(v176 + 112);
      if (v67 < 0)
      {
        int v69 = sub_100030FD4((uint64_t)&v175, v68, v66, &v209, 0);
        if (v69) {
          goto LABEL_97;
        }
      }
      else
      {
        uint64_t v209 = v68 + v66;
      }
      if (v210)
      {
        free(v210);
        uint64_t v210 = 0;
      }
      int v70 = sub_1000257B4(&v175, 0, 0x40000000, v209, 0, 0, 12, 0, (uint64_t **)&v210, 0, 0);
      if (v70)
      {
        int v115 = v70;
        goto LABEL_109;
      }
      uint64_t v78 = (uint64_t *)v210;
      if (*((void *)v210 + 1) != v209)
      {
        sub_10004458C("cpm_o.o_oid (0x%llx) doesn't match the physical address (0x%llx)\n", v71, v72, v73, v74, v75, v76, v77, *((void *)v210 + 1));
        int v115 = 92;
        uint64_t v104 = 107;
        goto LABEL_103;
      }
      if (*((void *)v210 + 2) != *(void *)(v176 + 16))
      {
        sub_10004458C("checkpoint map o_xid (0x%llx) doesn't match checkpoint superblock o_xid (0x%llx)\n", v71, v72, v73, v74, v75, v76, v77, *((void *)v210 + 2));
        int v115 = 92;
        uint64_t v104 = 108;
        goto LABEL_103;
      }
      unint64_t v79 = v210[9];
      if (!v79)
      {
        sub_10004458C("cpm_count is 0\n", v71, v72, v73, v74, v75, v76, v77, v165[0]);
        int v115 = 92;
        uint64_t v104 = 109;
        goto LABEL_103;
      }
      uint64_t v80 = *(unsigned int *)(v176 + 36);
      uint64_t v167 = (_DWORD *)v176;
      uint64_t v168 = v80;
      if ((v80 - 40) / 0x28uLL < v79)
      {
        sub_10004458C("cpm_count (%u) is larger than the max that this block size can accommodate (%u)\n", v71, v72, v73, v74, v75, v76, v77, v79);
        int v115 = 92;
        uint64_t v104 = 110;
LABEL_103:
        int v105 = 92;
LABEL_104:
        sub_100048B34((char *)v104, v105);
        goto LABEL_109;
      }
      int v81 = *((_DWORD *)v14 + 35);
      unsigned int v82 = v210[8];
      uint64_t v169 = (uint64_t *)v210;
      if (v82 >= 2)
      {
        sub_100044674("cpm_flags has an unknown flag set 0x%x\n", v71, v72, v73, v74, v75, v76, v77, v82);
        sub_100048B34((char *)0x6F, -3);
        uint64_t v78 = v169;
        unsigned int v82 = *((_DWORD *)v169 + 8);
      }
      if (v166 == v81 - 2)
      {
        if ((v82 & 1) == 0)
        {
          sub_10004458C("cpm_flags has invalid flags set: 0x%x\n", v71, v72, v73, v74, v75, v76, v77, v82);
          int v115 = 92;
          uint64_t v116 = 112;
          goto LABEL_108;
        }
      }
      else if (v82)
      {
        sub_10004458C("cpm_flags has invalid flags set: 0x%x\n", v71, v72, v73, v74, v75, v76, v77, v82);
        int v115 = 92;
        uint64_t v116 = 113;
        goto LABEL_108;
      }
      if (*((_DWORD *)v78 + 9)) {
        break;
      }
LABEL_87:
      int v64 = v166 + 1;
      a3 = v172;
      if (v166 + 1 >= (*((_DWORD *)v14 + 35) - 1))
      {
        int v115 = 0;
        goto LABEL_109;
      }
    }
    unint64_t v83 = 0;
    uint64_t v84 = (uint64_t **)(v78 + 9);
    while (2)
    {
      int v85 = *((_DWORD *)v84 - 8);
      if ((v85 & 0xC0000000) != 0x80000000)
      {
        sub_10004458C("cpm_map[%d].cpm_type storage type (0x%x) != OBJ_EPHEMERAL\n", v71, v72, v73, v74, v75, v76, v77, v83);
        int v115 = 92;
        uint64_t v116 = 114;
        goto LABEL_108;
      }
      if ((unsigned __int16)*((_DWORD *)v84 - 8) > 0x17u || ((1 << v85) & 0xC6002C) == 0)
      {
        sub_100044674("cpm_map[%d].cpm_type object type (0x%x) is invalid!\n", v71, v72, v73, v74, v75, v76, v77, v83);
        sub_100048B34((char *)0x73, -5);
      }
      int v87 = *((_DWORD *)v84 - 7);
      if ((v87 & 0xC0000000) != 0)
      {
        sub_10004458C("cpm_map[%d].cpm_subtype has nonzero storage type (0x%x)\n", v71, v72, v73, v74, v75, v76, v77, v83);
        int v115 = 92;
        uint64_t v116 = 649;
        goto LABEL_108;
      }
      if (((unsigned __int16)*((_DWORD *)v84 - 7) > 0x24u || ((1 << v87) & 0x100029CA01) == 0)
        && (unsigned __int16)*((_DWORD *)v84 - 7) != 255)
      {
        sub_100044674("cmp_map[%d].cpm_subtype object type (0x%x) is invalid!\n", v71, v72, v73, v74, v75, v76, v77, v83);
        sub_100048B34((char *)0x28A, -5);
      }
      if ((unint64_t)*(v84 - 2) - 1 <= 0x3FE)
      {
        sub_10004458C("cpm_map[%d].cpm_fs_oid (%llu) is less than minimum oid (%u)!\n", v71, v72, v73, v74, v75, v76, v77, v83);
        int v115 = 92;
        uint64_t v116 = 515;
        goto LABEL_108;
      }
      if (!*(v84 - 1))
      {
        sub_10004458C("cpm_map[%d].cpm_oid object type is invalid!\n", v71, v72, v73, v74, v75, v76, v77, v83);
        int v115 = 92;
        uint64_t v116 = 116;
        goto LABEL_108;
      }
      unsigned int v88 = *((_DWORD *)v84 - 6);
      if (!v88)
      {
        sub_10004458C("xp_map->cpm_map[%d].cpm_size is 0\n", v71, v72, v73, v74, v75, v76, v77, v83);
        int v115 = 92;
        uint64_t v116 = 121;
        goto LABEL_108;
      }
      if (v88 % v168)
      {
        sub_10004458C("xp_map->cpm_map[%d].cpm_size (%u) is not a multiple of nx_block_size (%u)\n", v71, v72, v73, v74, v75, v76, v77, v83);
        int v115 = 92;
        uint64_t v116 = 122;
        goto LABEL_108;
      }
      v211[0] = *v84;
      v211[1] = (uint64_t *)(v88 / v168);
      uint64_t v89 = *(void *)(v176 + 120);
      if ((*(_DWORD *)(v176 + 108) & 0x80000000) != 0)
      {
        if (!sub_1000310DC((uint64_t)&v175, v89, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048FC0, (uint64_t)v211))
        {
LABEL_95:
          sub_10004458C("cpm_map[%d].cpm_paddr (%llu) + cpm_size (%u) is not in the checkpoint data area\n", v90, v72, v73, v74, v75, v76, v77, v83);
          uint64_t v116 = 538;
          goto LABEL_107;
        }
      }
      else
      {
        v212[1] = *(unsigned int *)(v176 + 108);
        uint64_t v213 = 0;
        v212[0] = v89;
        if (!sub_100048FC0((uint64_t)&v213, 8, v212, 16, v211, v75, v76, v77)) {
          goto LABEL_95;
        }
      }
      long long v91 = *v84;
      v212[0] = (uint64_t)*v84;
      unint64_t v92 = *(unsigned int *)(v176 + 108);
      uint64_t v71 = *(void *)(v176 + 120);
      if ((v92 & 0x80000000) != 0)
      {
        if (sub_1000310DC((uint64_t)&v175, v71, (uint64_t (*)(void, void, void, void, uint64_t))sub_1000339FC, (uint64_t)v212) != -1)goto LABEL_106; {
        unint64_t v93 = v212[0];
        }
LABEL_78:
        unint64_t v94 = v167[36];
        if (v93 >= v94)
        {
          BOOL v95 = v93 >= (v167[37] + v94);
          long long v96 = v169;
          if (v95)
          {
            sub_10004458C("nx_xp_data_index (%u) puts the checkpoint data outside of its range\n", v71, v72, v73, v74, v75, v76, v77, v167[36]);
            uint64_t v116 = 120;
            goto LABEL_107;
          }
        }
        else
        {
          BOOL v95 = v93 + (v167[27] & 0x7FFFFFFF) >= (v167[37] + v94);
          long long v96 = v169;
          if (v95)
          {
            sub_10004458C("nx_xp_data_index (%u) puts the checkpoint data outside of its range\n", v71, v72, v73, v74, v75, v76, v77, v167[36]);
            uint64_t v116 = 119;
            goto LABEL_107;
          }
        }
        ++v83;
        v84 += 5;
        if (v83 >= *((unsigned int *)v96 + 9)) {
          goto LABEL_87;
        }
        continue;
      }
      break;
    }
    unint64_t v93 = (unint64_t)v91 - v71;
    if ((uint64_t)v91 >= v71 && v93 < v92) {
      goto LABEL_78;
    }
LABEL_106:
    sub_10004458C("could not look up cpm_map[%d].cpm_paddr (%llu) in checkpoint data area\n", v71, v72, v73, v74, v75, v76, v77, v83);
    uint64_t v116 = 539;
LABEL_107:
    int v115 = 92;
LABEL_108:
    sub_100048B34((char *)v116, 92);
    a3 = v172;
LABEL_109:
    if (v210) {
      free(v210);
    }
    if (v115)
    {
      sub_100044674("checkpoint %d (xid %llu) checkpoint map is invalid\n", v71, v72, v73, v74, v75, v76, v77, v22);
      goto LABEL_19;
    }
LABEL_113:
    int v106 = sub_10002C9D0(&v175, 0);
    if (!v106)
    {
      int v106 = sub_10002CA70(&v175, 0);
      if (!v106)
      {
        int v106 = sub_10002CB10(&v175, 0, 0);
        if (!v106)
        {
          v212[0] = 0;
          int v106 = sub_10002CD48(&v175, 0, v212);
          if (!v106)
          {
            int v106 = sub_100035168(v212[0], 0, 0, 0, 0, 0);
            if (!v106)
            {
              v211[0] = 0;
              uint64_t v117 = v176;
              if (!*(_DWORD *)(v176 + 180))
              {
                int v106 = 0;
                goto LABEL_118;
              }
              for (unint64_t i = 0; i < *(unsigned int *)(v117 + 180); ++i)
              {
                uint64_t v119 = *(void *)(v117 + 8 * i + 184);
                if (v119)
                {
                  int v120 = sub_1000257B4(&v175, 0, 0, v119, 0, 0, 13, 0, v211, 0, 0);
                  if (v120)
                  {
                    int v106 = v120;
                    break;
                  }
                  free(v211[0]);
                  v211[0] = 0;
                  uint64_t v117 = v176;
                }
                int v106 = 0;
              }
            }
          }
        }
      }
    }
LABEL_118:
    uint64_t v107 = v175;
    uint64_t v175 = 0;
    *(void *)&long long v176 = 0;
    sub_10002C6C4(&v175);
    uint64_t v175 = v107;
    if (v106)
    {
      sub_100044674("checkpoint %d (xid %llu) failed consistency check\n", v108, v109, v110, v111, v112, v113, v114, v22);
      sub_100048B34((char *)0x3DE, -7);
      a3 = v172;
      goto LABEL_19;
    }
    a3 = v172;
    if (*v172) {
      free(*v172);
    }
    uint64_t v121 = malloc_type_malloc(*(unsigned int *)(a2 + 36), 0x9BD49D72uLL);
    *a3 = v121;
    if (!v121)
    {
      sub_10004458C("malloc(%u)\n", v122, v123, v124, v125, v126, v127, v128, *(_DWORD *)(a2 + 36));
      uint64_t v161 = 12;
      uint64_t v162 = 129;
      int v163 = 12;
      goto LABEL_168;
    }
    memcpy(v121, v14, 0x588uLL);
    uint64_t v129 = v170;
    unint64_t *v170 = v208;
    *((_DWORD *)v129 + 2) = *(_DWORD *)(a2 + 36);
LABEL_134:
    if (*a3) {
      return 0;
    }
    if ((v173 & 1) == 0) {
      goto LABEL_166;
    }
LABEL_136:
    int v130 = *(_DWORD *)(a2 + 104);
    if ((v130 & 0x7FFFFFFF) == 0)
    {
LABEL_165:
      sub_10004458C("no valid checkpoint found\n", v7, v8, v9, v10, v11, v12, v13, v165[0]);
      uint64_t v161 = 92;
      uint64_t v162 = 126;
      goto LABEL_167;
    }
    unint64_t v131 = 0;
    BOOL v132 = 0;
    int v174 = 0;
    unint64_t v133 = 0;
    while (2)
    {
      *(void *)&long long v176 = a2;
      uint64_t v134 = *(void *)(a2 + 112);
      if ((v130 & 0x80000000) == 0)
      {
        uint64_t v135 = v131 + v134;
        unint64_t v208 = v135;
        goto LABEL_140;
      }
      int v149 = sub_100030FD4((uint64_t)&v175, v134, v131, &v208, 0);
      if (v149)
      {
        int v139 = v149;
        strerror(v149);
        sub_100044674("failed to look up checkpoint block address %d: %s\n", v150, v151, v152, v153, v154, v155, v156, v131);
        uint64_t v148 = 541;
LABEL_144:
        int v157 = v139;
LABEL_145:
        sub_100048B34((char *)v148, v157);
      }
      else
      {
        uint64_t v135 = v208;
LABEL_140:
        int v136 = sub_10002F148(a1, v135);
        if (v136)
        {
          int v139 = v136;
          char v140 = v208;
          strerror(v136);
          sub_10004458C("dev_read(%llu, 1): %s\n", v141, v142, v143, v144, v145, v146, v147, v140);
          uint64_t v148 = 124;
          goto LABEL_144;
        }
        if (*((void *)v14 + 1))
        {
          if (sub_1000316F4((uint64_t)v14, 10, *((void *)v14 + 2), 0, 0, *(_DWORD *)(a2 + 36), v137, v138))
          {
            sub_100044674("checkpoint %d fsck_obj_phys failed\n", v7, v8, v9, v10, v11, v12, v13, v131);
            goto LABEL_146;
          }
          int v158 = *((_DWORD *)v14 + 6);
          if (v158 != -2147483647 && v158 != 1073741836)
          {
            sub_100044674("checkpoint %d obj->o_type is invalid: (0x%x)\n", v7, v8, v9, v10, v11, v12, v13, v131);
            uint64_t v148 = 125;
            int v157 = -5;
            goto LABEL_145;
          }
        }
        unint64_t v159 = *((void *)v14 + 2);
        if (v159 == v133 && v132)
        {
          int v160 = -2147483647;
          if (*((_DWORD *)v14 + 6) != -2147483647)
          {
            BOOL v132 = 1;
            goto LABEL_146;
          }
        }
        else
        {
          if (v159 < v133) {
            goto LABEL_146;
          }
          int v160 = *((_DWORD *)v14 + 6);
        }
        BOOL v132 = v160 == -2147483647;
        unint64_t v133 = *((void *)v14 + 2);
        int v174 = v131;
      }
LABEL_146:
      ++v131;
      int v130 = *(_DWORD *)(a2 + 104);
      int v18 = v130 & 0x7FFFFFFF;
      if (v131 < (v130 & 0x7FFFFFFFu)) {
        continue;
      }
      break;
    }
    if (!v133) {
      goto LABEL_165;
    }
    int v173 = 0;
    a3 = v172;
  }
  while (v18);
  if (*v172) {
    return 0;
  }
LABEL_166:
  sub_10004458C("no valid checkpoint\n", v7, v8, v9, v10, v11, v12, v13, v165[0]);
  uint64_t v161 = 92;
  uint64_t v162 = 130;
LABEL_167:
  int v163 = 92;
LABEL_168:
  sub_100048B34((char *)v162, v163);
  return v161;
}

uint64_t sub_1000335C8(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4 == 8 && a6 == 16)
  {
    unint64_t v8 = *a3;
    unint64_t v9 = *a5;
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(void *)(a1 + 24);
    if (v11)
    {
      unint64_t v12 = *(void *)(v11 + 48);
      unint64_t v13 = *(void *)(v11 + 96);
    }
    else
    {
      unint64_t v12 = *(void *)(v10 + 40);
      if (*(unsigned char *)(v10 + 65)) {
        unint64_t v13 = *(void *)(v10 + 40);
      }
      else {
        unint64_t v13 = 0;
      }
    }
    unint64_t v15 = a5[1];
    char v16 = __clz(__rbit64(*(unsigned int *)(v10 + 36)));
    if (!v8 || (v12 > v15 ? (BOOL v17 = v12 > v8) : (BOOL v17 = 0), v17 ? (v18 = v12 - v15 >= v8) : (v18 = 0), !v18))
    {
      BOOL v19 = 0x4000000000000000uLL >> v16 < v8 && v13 > v15;
      BOOL v20 = v19 && (v13 | (0x4000000000000000uLL >> v16)) > v8;
      if (!v20 || ((v13 - v15) | (0x4000000000000000uLL >> v16)) < v8)
      {
LABEL_43:
        sub_10004458C("evict mapping range is invalid: (0x%llx+%llu --> 0x%llx+%llu)\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v8);
        uint64_t v14 = 850;
        goto LABEL_44;
      }
    }
    if (v11)
    {
      unint64_t v21 = *(void *)(v11 + 48);
      unint64_t v22 = *(void *)(v11 + 96);
      if (!v9) {
        goto LABEL_36;
      }
    }
    else
    {
      unint64_t v21 = *(void *)(v10 + 40);
      if (*(unsigned char *)(v10 + 65)) {
        unint64_t v22 = *(void *)(v10 + 40);
      }
      else {
        unint64_t v22 = 0;
      }
      if (!v9)
      {
LABEL_36:
        unint64_t v23 = 0x4000000000000000uLL >> v16;
        BOOL v25 = v23 < v9 && v22 > v15 && (v22 | v23) > v9;
        if (v25 && ((v22 - v15) | v23) >= v9) {
          return 0;
        }
        goto LABEL_43;
      }
    }
    if (v21 > v15 && v21 > v9 && v21 - v15 >= v9) {
      return 0;
    }
    goto LABEL_36;
  }
  sub_10004458C("unexpected key (%u) / val (%u) size in evict mapping tree\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a4);
  uint64_t v14 = 849;
LABEL_44:
  uint64_t v26 = 92;
  sub_100048B34((char *)v14, 92);
  return v26;
}

uint64_t sub_100033730(uint64_t a1)
{
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  void v20[2] = v2;
  v20[3] = v2;
  v20[0] = v2;
  v20[1] = v2;
  v19[0] = a1;
  v19[1] = 0;
  uint64_t v3 = *(void *)(a1 + 8);
  if ((*(_DWORD *)(v3 + 104) & 0x80000000) != 0)
  {
    sub_100038040((uint64_t)v20, a1, 0, 0x40000000, 2, 10, 0, *(_DWORD *)(v3 + 36), 8, 16, 0, *(void *)(v3 + 112), (uint64_t)sub_1000306FC);
    uint64_t v6 = sub_100035168((uint64_t)v20, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000339C4, (uint64_t)v19, 0, 1);
    if (v6)
    {
      uint64_t v5 = v6;
      uint64_t v14 = "NX checkpoint descriptor area fragmented metadata tree is invalid\n";
LABEL_14:
      sub_10004458C(v14, v7, v8, v9, v10, v11, v12, v13, v18);
      return v5;
    }
    uint64_t v3 = *(void *)(a1 + 8);
  }
  if ((*(_DWORD *)(v3 + 108) & 0x80000000) != 0)
  {
    sub_100038040((uint64_t)v20, a1, 0, 0x40000000, 2, 10, 0, *(_DWORD *)(v3 + 36), 8, 16, 0, *(void *)(v3 + 120), (uint64_t)sub_1000306FC);
    uint64_t v15 = sub_100035168((uint64_t)v20, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000339C4, (uint64_t)v19, 0, 1);
    if (v15)
    {
      uint64_t v5 = v15;
      uint64_t v14 = "NX checkpoint data area fragmented metadata tree is invalid\n";
      goto LABEL_14;
    }
  }
  uint64_t v4 = *(void *)(a1 + 24);
  if ((*(_DWORD *)(v4 + 164) & 0x80000000) != 0)
  {
    sub_100038040((uint64_t)v20, a1, 0, 0x40000000, 2, 10, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 16, 0, *(void *)(v4 + 168), (uint64_t)sub_1000306FC);
    uint64_t v16 = sub_100035168((uint64_t)v20, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000339C4, (uint64_t)v19, 0, 1);
    if (v16)
    {
      uint64_t v5 = v16;
      uint64_t v14 = "Spaceman internal pool bitmap fragmented metadata tree is invalid\n";
      goto LABEL_14;
    }
    uint64_t v4 = *(void *)(a1 + 24);
  }
  if ((*(void *)(v4 + 152) & 0x8000000000000000) == 0) {
    return 0;
  }
  sub_100038040((uint64_t)v20, a1, 0, 0x40000000, 2, 10, 0, *(_DWORD *)(*(void *)(a1 + 8) + 36), 8, 16, 0, *(void *)(v4 + 176), (uint64_t)sub_1000306FC);
  uint64_t v5 = sub_100035168((uint64_t)v20, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000339C4, (uint64_t)v19, 0, 1);
  if (v5)
  {
    uint64_t v14 = "Spaceman internal pool fragmented metadata tree is invalid\n";
    goto LABEL_14;
  }
  return v5;
}

uint64_t sub_1000339C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t a6, void *a7, uint64_t a8)
{
  if (sub_100048EBC(a3, a4, a5, a6, a7, a6, (uint64_t)a7, a8)) {
    return 92;
  }
  else {
    return 0;
  }
}

uint64_t sub_1000339FC(void *a1, int a2, void *a3, int a4, void *a5)
{
  uint64_t result = 92;
  if (a2 == 8 && a4 == 16)
  {
    unint64_t v7 = *a5 - *a3;
    if (*a5 < *a3 || v7 >= a3[1])
    {
      return 0;
    }
    else
    {
      *a5 = *a1 + v7;
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

char *sub_100033A4C(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_1000909D0 & 1) == 0)
  {
    if (dword_1000909D4 <= 0xFF
      && (v8 = result, (uint64_t result = (char *)malloc_type_malloc(0x10uLL, 0x10200405730B0C9uLL)) != 0))
    {
      *(void *)uint64_t result = v8;
      *((void *)result + 1) = 0;
      *off_100074698 = result;
      off_100074698 = (_UNKNOWN **)(result + 8);
      ++dword_1000909D4;
    }
    else
    {
      uint64_t result = sub_100044548("more than %d inodes tracked as rolling, disabling pfkur tracking repairs\n", a2, a3, a4, a5, a6, a7, a8, 0);
      byte_1000909D0 = 1;
    }
  }
  return result;
}

uint64_t sub_100033AFC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((byte_1000909D0 & 1) == 0)
  {
    uint64_t v8 = (long long *)off_100074690;
    if (!off_100074690)
    {
      uint64_t v25 = 0;
      goto LABEL_19;
    }
    do
    {
      sub_100044674("missing upgrade-rolling entry for inode (%llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)v8);
      uint64_t v10 = sub_100048B34((char *)0x3C2, -2);
      memset(v26, 0, sizeof(v26));
      if (a3)
      {
        uint64_t v18 = sub_100027E70(a3, 9u, 2, 0, 1, v8, 8u, v26, 0x18u);
        if (v18)
        {
          uint64_t v25 = v18;
          goto LABEL_9;
        }
      }
      else
      {
        sub_100027AD0((uint64_t)v10, v11, v12, v13, v14, v15, v16, v17);
      }
      uint64_t v8 = (long long *)*((void *)v8 + 1);
    }
    while (v8);
  }
  uint64_t v25 = 0;
LABEL_9:
  BOOL v19 = off_100074690;
  if (!off_100074690) {
    goto LABEL_19;
  }
  BOOL v20 = &off_100074690;
  for (unint64_t i = off_100074690; ; unint64_t i = v22)
  {
    unint64_t v22 = (void *)i[1];
    if (v19 != i) {
      break;
    }
    off_100074690 = (_UNKNOWN *)i[1];
    if (!v22) {
      goto LABEL_17;
    }
LABEL_16:
    free(i);
    BOOL v19 = off_100074690;
  }
  do
  {
    unint64_t v23 = v19;
    BOOL v19 = (void *)v19[1];
  }
  while (v19 != i);
  v23[1] = v22;
  if (v22) {
    goto LABEL_16;
  }
  BOOL v20 = (_UNKNOWN **)(v23 + 1);
LABEL_17:
  off_100074698 = v20;
  free(i);
LABEL_19:
  dword_1000909D4 = 0;
  byte_1000909D0 = 0;
  return v25;
}

uint64_t sub_100033C4C(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(*(void *)(a2 + 40) + 56) & 0x40) == 0)
  {
    sub_10004458C("pfkur_tree_key : object (oid 0x%llx): pfkur tree record present on non-pfkur volume\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
    uint64_t v11 = 963;
    goto LABEL_26;
  }
  unint64_t v12 = *a3;
  if ((byte_1000909D0 & 1) == 0)
  {
    uint64_t v13 = off_100074690;
    if (off_100074690)
    {
      uint64_t v14 = off_100074690;
      while (*v14 != v12)
      {
        uint64_t v14 = (void *)v14[1];
        if (!v14) {
          goto LABEL_14;
        }
      }
      if (off_100074690 == (_UNKNOWN *)v14)
      {
        uint64_t v17 = &off_100074690;
        off_100074690 = (_UNKNOWN *)*((void *)off_100074690 + 1);
        if (off_100074690) {
          goto LABEL_13;
        }
      }
      else
      {
        do
        {
          uint64_t v15 = v13;
          uint64_t v13 = (void *)v13[1];
        }
        while (v13 != v14);
        uint64_t v16 = v14[1];
        v15[1] = v16;
        uint64_t v17 = (_UNKNOWN **)(v15 + 1);
        if (v16) {
          goto LABEL_13;
        }
      }
      off_100074698 = v17;
LABEL_13:
      --dword_1000909D4;
      free(v14);
      unint64_t v12 = *a3;
    }
  }
LABEL_14:
  if (v12 - 0x1000000000000000 > 0xF000000000000001)
  {
    if (v12 <= 0xF)
    {
      sub_10004458C("pfkur_key : object (oid 0x%llx): invalid oid (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
      sub_100048B34((char *)0x3C5, -2);
    }
    if (*(_DWORD *)a5)
    {
      sub_100044674("pfk_val : object (oid 0x%llx): unknown version (%u)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
      sub_100048B34((char *)0x3C6, -6);
    }
    if (*(_DWORD *)(a5 + 4) >= 0x10u)
    {
      sub_100044674("pfk_val : object (oid 0x%llx): unknown flags (%u)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
      sub_100048B34((char *)0x3C7, -3);
    }
    if (HIBYTE(*(void *)(a5 + 8)))
    {
      sub_10004458C("pfk_val : object (oid 0x%llx): invalid current_offset (%llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
      uint64_t v11 = 968;
    }
    else
    {
      if (!HIBYTE(*(void *)(a5 + 16))) {
        return 0;
      }
      sub_10004458C("pfk_val : object (oid 0x%llx): invalid current_ns_offset (%llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
      uint64_t v11 = 969;
    }
  }
  else
  {
    sub_10004458C("pfkur_key : object (oid 0x%llx): invalid oid (0x%llx)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
    uint64_t v11 = 964;
  }
LABEL_26:
  uint64_t v18 = 92;
  sub_100048B34((char *)v11, 92);
  sub_1000447BC(a2, a3, a5, v19, v20, v21, v22, v23);
  return v18;
}

uint64_t sub_100033E58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_100033E70(a1, a2, a3, 0, 0, 0, a4, 0);
}

uint64_t sub_100033E70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, uint64_t a7, char a8)
{
  unsigned int v14 = *(_DWORD *)(a1 + 48);
  int v15 = *(_DWORD *)(a1 + 52) != 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  long long v20 = 0uLL;
  uint64_t v16 = sub_1000257B4(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), *(void *)(a1 + 56), a3, v15 << 29, 2, v14, (uint64_t **)&v22, (uint64_t)&v20, a8);
  if (!v16)
  {
    uint64_t v18 = v22;
    uint64_t v19 = (char *)v22 + DWORD2(v20) - 40;
    if (a7)
    {
      *(_OWORD *)a7 = *v19;
      *(_DWORD *)(a7 + 40) = *(_DWORD *)(a1 + 52);
      *(_DWORD *)(a7 + 44) = *(_DWORD *)(a1 + 36);
      *(void *)(a7 + 64) = a2;
    }
    if (a4)
    {
      *(_OWORD *)a4 = v20;
      *(void *)(a4 + --*(_DWORD *)(result + 16) = v21;
    }
    if (a5)
    {
      *a5 = v18;
      if (a6) {
        *a6 = v19;
      }
    }
    else
    {
      free(v18);
    }
  }
  return v16;
}

unint64_t sub_100033F78(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, _WORD *a5, uint64_t *a6, _WORD *a7)
{
  unint64_t result = sub_100034048(a1, a2, a3);
  if ((unsigned __int16)result == 0xFFFFLL)
  {
    uint64_t v14 = 0;
    LOWORD(v15) = 0;
  }
  else
  {
    unint64_t v15 = result >> 16;
    uint64_t v14 = a1 + (unsigned __int16)result + *(unsigned __int16 *)(a1 + 42) + 56;
  }
  int v16 = *(unsigned __int16 *)(a1 + 32);
  int v17 = *(_DWORD *)(a2 + 4);
  *a4 = v14;
  *a5 = v15;
  if (a6)
  {
    unint64_t v18 = HIWORD(result);
    uint64_t v19 = a1 + v17 + ((v16 << 31 >> 31) & 0xFFFFFFD8) - 56 - WORD2(result) + 56;
    if ((result & 0xFFFE00000000) == 0xFFFE00000000)
    {
      uint64_t v19 = 0;
      LOWORD(v18) = 0;
    }
    *a6 = v19;
    *a7 = v18;
  }
  return result;
}

unint64_t sub_100034048(uint64_t a1, uint64_t a2, unsigned int a3)
{
  __int16 v3 = *(_WORD *)(a1 + 32);
  uint64_t v4 = a1 + 56;
  if ((v3 & 4) != 0)
  {
    uint64_t v10 = (unsigned __int16 *)(v4 + 4 * a3);
    unsigned int v6 = *v10;
    uint64_t v8 = v10[1];
    if (v6 == 0xFFFF) {
      LOWORD(v7) = 0;
    }
    else {
      int v7 = *(_DWORD *)(a2 + 8);
    }
    if (v8 == 0xFFFF)
    {
      uint64_t v9 = 0;
    }
    else if (v8 == 65534)
    {
      uint64_t v8 = 65534;
      uint64_t v9 = 65534;
    }
    else if ((v3 & 2) != 0)
    {
      uint64_t v9 = *(unsigned int *)(a2 + 12);
    }
    else if ((v3 & 8) != 0)
    {
      uint64_t v9 = *(unsigned __int16 *)(a2 + 44) + 8;
    }
    else
    {
      uint64_t v9 = 8;
    }
  }
  else
  {
    uint64_t v5 = (unsigned __int16 *)(v4 + 8 * a3);
    unsigned int v6 = *v5;
    LOWORD(v7) = v5[1];
    uint64_t v8 = v5[2];
    uint64_t v9 = v5[3];
  }
  return (v8 << 32) | (v9 << 48) | ((unint64_t)(unsigned __int16)v7 << 16) | v6;
}

unint64_t sub_1000340F4(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, _WORD *a5, unsigned int a6, uint64_t *a7, _WORD *a8)
{
  sub_100033F78(a1, a2, a3, a4, a5, 0, 0);

  return sub_100033F78(a1, a2, a6, a7, a8, 0, 0);
}

uint64_t sub_10003416C(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  unsigned int v12 = *(unsigned __int16 *)(a1 + 32);
  unint64_t v13 = 8;
  if ((v12 & 2) != 0) {
    unint64_t v13 = *(unsigned int *)(a2 + 12);
  }
  if ((v12 & 4) != 0) {
    unsigned int v14 = 4;
  }
  else {
    unsigned int v14 = 8;
  }
  if (v12) {
    int v15 = -96;
  }
  else {
    int v15 = -56;
  }
  int v16 = *(_DWORD *)a2;
  unint64_t v17 = *(unsigned int *)(a2 + 4);
  BOOL v18 = v12 < 0x20 || a3 == 0;
  int v19 = *(_DWORD *)a2;
  if (!v18)
  {
    sub_100044674("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: invalid btn_flags (0x%x)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
    sub_100048B34((char *)0x17A, -3);
    int v19 = *(_DWORD *)a2;
  }
  __int16 v20 = *(_WORD *)(a1 + 32);
  if ((v19 & 0x80) != 0)
  {
    if ((v20 & 0x18) != 0x18)
    {
      if (v9)
      {
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: missing btn_flags (expected 0x%x, actual 0x%x)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
        sub_100048B34((char *)0x390, 92);
      }
      if (!a4
        || !sub_10004641C(qword_100091B70, "Set missing flags? ", a3, (uint64_t)a4, a5, a6, a7, a8, v126))
      {
        return 92;
      }
      __int16 v20 = *(_WORD *)(a1 + 32) | 0x18;
      *(_WORD *)(a1 + 32) = v20;
      *a4 = 1;
    }
    unint64_t v13 = (*(_DWORD *)(a2 + 44) + v13);
  }
  else if ((v20 & 0x18) != 0)
  {
    if (v9)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unexpected btn_flags (0x%x)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
      sub_100048B34((char *)0x391, 92);
    }
    if (!a4
      || !sub_10004641C(qword_100091B70, "Clear unexpected flags? ", a3, (uint64_t)a4, a5, a6, a7, a8, v126))
    {
      return 92;
    }
    __int16 v20 = *(_WORD *)(a1 + 32) & 0xFFE7;
    *(_WORD *)(a1 + 32) = v20;
    *a4 = 1;
  }
  char v21 = v20;
  if ((v20 & 4) != 0)
  {
    if (!v13)
    {
      if (v9)
      {
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_val_size (%u), given btn_flags (0x%x)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
        uint64_t v22 = 92;
        uint64_t v23 = 380;
        goto LABEL_52;
      }
      return 92;
    }
  }
  else if (*(_DWORD *)(a2 + 8) && v13)
  {
    if (v9)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btn_btree.bt_fixed.bt_key_size (%u) and btn_btree.bt_fixed.bt_val_size (%u)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
      uint64_t v22 = 92;
      uint64_t v23 = 379;
LABEL_52:
      int v46 = 92;
LABEL_53:
      sub_100048B34((char *)v23, v46);
      return v22;
    }
    return 92;
  }
  unsigned int v24 = *(unsigned __int16 *)(a1 + 42);
  if (v14 > v24)
  {
    if (v9)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_table_space.len (%u), given toc_entry_size (%u) and btn_flags (0x%x)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
      uint64_t v22 = 92;
      uint64_t v23 = 381;
      goto LABEL_52;
    }
    return 92;
  }
  unsigned int v25 = *(_DWORD *)(a1 + 36);
  if ((v12 & 4) != 0) {
    char v26 = 2;
  }
  else {
    char v26 = 3;
  }
  if (v25 > v24 >> v26)
  {
    if (v9)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_nkeys (%u), given btn_table_space.len (%u) and toc_entry_size (%u)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
      uint64_t v22 = 92;
      uint64_t v23 = 382;
      goto LABEL_52;
    }
    return 92;
  }
  if (!(v25 | v21 & 1))
  {
    if (v9)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_nkeys (%u), given btn_flags (0x%x)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, *(void *)(a1 + 8));
      uint64_t v22 = 92;
      uint64_t v23 = 383;
      goto LABEL_52;
    }
    return 92;
  }
  int8x16_t v27 = malloc_type_calloc(1uLL, 0x10uLL, 0x10200405730B0C9uLL);
  if (!v27)
  {
LABEL_57:
    if (!v9) {
      return 12;
    }
    sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: validate_loc_ctx_alloc failed for btn_nkeys (%u)\n", v28, v29, v30, v31, v32, v33, v34, *(void *)(a1 + 8));
    uint64_t v22 = 12;
    uint64_t v23 = 384;
    int v46 = 12;
    goto LABEL_53;
  }
  uint64_t v35 = v27;
  size_t v36 = (2 * *(_DWORD *)(a1 + 36) + 7) & 0xFFFFFFF8;
  *(_DWORD *)uint64_t v35 = v36;
  uint64_t v37 = malloc_type_calloc(v36, 4uLL, 0x100004052888210uLL);
  v35[1] = v37;
  if (!v37)
  {
    free(v35);
    goto LABEL_57;
  }
  if (*(_WORD *)(a1 + 40))
  {
    int v45 = 0;
    goto LABEL_61;
  }
  int v45 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, *(_DWORD *)(a1 + 40), 0, (uint64_t)v35);
  if (!v45)
  {
    if ((*(_WORD *)(a1 + 32) & 4) != 0)
    {
      unint64_t v48 = *(unsigned __int16 *)(a1 + 42) >> v26;
      if (((((unint64_t)*(unsigned int *)(a2 + 4) - 56)
           / ((unint64_t)(*(_DWORD *)(a2 + 8) + v13) + 4)) & 0xFFFFFFFFFFFFFFFELL) > v48)
      {
        if (v9)
        {
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_table_space (%u, %u), given btn_flags (0x%x)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
          uint64_t v22 = 92;
          uint64_t v50 = 386;
LABEL_74:
          int v49 = 92;
LABEL_66:
          sub_100048B34((char *)v50, v49);
          goto LABEL_67;
        }
        goto LABEL_79;
      }
    }
    if (*(_WORD *)(a1 + 46))
    {
      int v52 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, *(_DWORD *)(a1 + 44), 5, (uint64_t)v35);
      if (v52)
      {
        if (v9)
        {
          int v53 = v52;
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_free_space (%u, %u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
          sub_100048B34((char *)0x183, v53);
        }
        goto LABEL_79;
      }
    }
    unsigned int v54 = *(unsigned __int16 *)(a1 + 48);
    uint64_t v134 = (uint64_t)v35;
    if (v54 == 0xFFFF)
    {
      unsigned int v55 = *(unsigned __int16 *)(a1 + 50);
LABEL_82:
      uint64_t v56 = (v15 + v17);
      unsigned int v57 = *(unsigned __int16 *)(a1 + 52);
      if (v57 != 0xFFFF)
      {
        uint64_t v128 = (v15 + v17);
        unsigned int v130 = v55;
        LODWORD(v17) = 0;
        unint64_t v131 = a1 + v56 + 56;
        while (1)
        {
          if ((*(_DWORD *)a2 & 0x40) != 0) {
            int v87 = 0x40000;
          }
          else {
            int v87 = 0x80000;
          }
          unint64_t v13 = v13 & 0xFFFFFFFF00000000 | v87 | v57;
          int v88 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, v13, 4, 0);
          if (v88)
          {
            if (!v9) {
              goto LABEL_146;
            }
            int v99 = v88;
            sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_val_free_list offset %u\n", v89, v90, v91, v92, v93, v94, v95, *(void *)(a1 + 8));
            uint64_t v100 = 391;
            goto LABEL_138;
          }
          long long v96 = (unsigned __int16 *)(v131 - v57);
          int v97 = v96[1];
          unint64_t v132 = v132 & 0xFFFFFFFF00000000 | v57 | (v97 << 16);
          int v98 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, v57 | (v97 << 16), 4, v134);
          if (v98) {
            break;
          }
          unint64_t v17 = (v97 + v17);
          unsigned int v57 = *v96;
          if (v57 == 0xFFFF)
          {
            unsigned int v58 = *(unsigned __int16 *)(a1 + 54);
            uint64_t v35 = (void *)v134;
            uint64_t v56 = v128;
            unsigned int v55 = v130;
            if (v58 >= (unsigned __int16)v17) {
              goto LABEL_84;
            }
            if (v9)
            {
              sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_val_free_list length (%u), given total value length (%u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
              uint64_t v22 = 92;
              uint64_t v50 = 393;
              goto LABEL_74;
            }
            goto LABEL_79;
          }
        }
        if (!v9) {
          goto LABEL_146;
        }
        int v99 = v98;
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_val_free_list entry (%u, %u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
        uint64_t v100 = 392;
LABEL_138:
        int v102 = v99;
        goto LABEL_145;
      }
      unsigned int v58 = *(unsigned __int16 *)(a1 + 54);
LABEL_84:
      if (*(_DWORD *)(a1 + 36))
      {
        uint64_t v127 = v56;
        unsigned int v129 = v58;
        unsigned int v59 = 0;
        unsigned int v60 = v55;
        while (1)
        {
          unsigned int v133 = v60;
          unint64_t v61 = sub_100034048(a1, a2, v59);
          unint64_t v17 = v17 & 0xFFFFFFFF00000000 | v61;
          int v62 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, v17, 1, v134);
          if (v62)
          {
            if (!v9) {
              goto LABEL_146;
            }
            int v104 = v62;
            sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key (%u, %u)\n", v63, v64, v65, v66, v67, v68, v69, *(void *)(a1 + 8));
            uint64_t v100 = 394;
            goto LABEL_144;
          }
          unint64_t v70 = HIWORD(v61);
          unint64_t v131 = v131 & 0xFFFFFFFF00000000 | WORD2(v61) | (HIWORD(v61) << 16);
          int v71 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, WORD2(v61) | (HIWORD(v61) << 16), 2, v134);
          if (v71) {
            break;
          }
          if (WORD1(v61) > *(_DWORD *)(a2 + 16)) {
            *(_DWORD *)(a2 + --*(_DWORD *)(result + 16) = WORD1(v61);
          }
          if ((*(_WORD *)(a1 + 32) & 2) != 0 && v70 != 65534 && *(_DWORD *)(a2 + 20) < v70) {
            *(_DWORD *)(a2 + 20) = v70;
          }
          unint64_t v72 = v61 >> 16;
          if ((v16 & 0x40) == 0) {
            LODWORD(v72) = ((v61 >> 16) + 7) & 0xFFFFFFF8;
          }
          if (v70 != 65534)
          {
            if ((v16 & 0x40) != 0) {
              v129 += v70;
            }
            else {
              v129 += (v70 + 7) & 0x1FFF8;
            }
          }
          unsigned int v60 = v72 + v133;
          ++v59;
          uint64_t v73 = *(unsigned int *)(a1 + 36);
          if (v59 >= v73)
          {
            uint64_t v35 = (void *)v134;
            uint64_t v56 = v127;
            LOWORD(v58) = v129;
            goto LABEL_128;
          }
        }
        if (!v9) {
          goto LABEL_146;
        }
        int v104 = v71;
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid value (%u, %u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
        uint64_t v100 = 395;
LABEL_144:
        int v102 = v104;
        goto LABEL_145;
      }
      uint64_t v73 = 0;
      LOWORD(v60) = v55;
LABEL_128:
      unsigned int v103 = *(unsigned __int16 *)(a1 + 44);
      if (v103 < (unsigned __int16)v60)
      {
        if (v9)
        {
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_free_space (%u, %u), given total key length (%u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
          uint64_t v22 = 92;
          uint64_t v50 = 396;
          goto LABEL_74;
        }
LABEL_79:
        uint64_t v22 = 92;
        goto LABEL_67;
      }
      if (*(unsigned __int16 *)(a1 + 46) + v103 < v56
                                                 - (*(unsigned __int16 *)(a1 + 42)
                                                  + (unsigned __int16)v58))
      {
        if (v9)
        {
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_free_space (%u, %u), given total value length (%u) (%d %d %d = %d)\n", v56, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
          uint64_t v22 = 92;
          uint64_t v50 = 397;
          goto LABEL_74;
        }
        goto LABEL_79;
      }
      int v105 = sub_1000350C8(a1, (unsigned int *)a2, (uint64_t)v35);
      if (v105)
      {
        if (!v9) {
          goto LABEL_146;
        }
        int v113 = v105;
        uint64_t v114 = *(void *)(a1 + 8);
        strerror(v105);
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list, btn_val_free_list, or btn_free_space: %s\n", v115, v116, v117, v118, v119, v120, v121, v114);
        uint64_t v100 = 398;
        int v102 = v113;
LABEL_145:
        sub_100048B34((char *)v100, v102);
LABEL_146:
        uint64_t v22 = 92;
        goto LABEL_147;
      }
      uint64_t v122 = *(void *)(a2 + 24);
      BOOL v123 = __CFADD__(v122, v73);
      uint64_t v124 = v122 + v73;
      if (v123)
      {
        if (!v9) {
          goto LABEL_146;
        }
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_key_count (overflow)\n", v106, v107, v108, v109, v110, v111, v112, *(void *)(a1 + 8));
        uint64_t v22 = 92;
        uint64_t v86 = 399;
      }
      else
      {
        uint64_t v125 = *(void *)(a2 + 32);
        if (v125 != -1)
        {
          if ((*(_WORD *)(a1 + 32) & 2) != 0) {
            *(void *)(a2 + 24) = v124;
          }
          *(void *)(a2 + 32) = v125 + 1;
          uint64_t v22 = 0;
          goto LABEL_147;
        }
        if (!v9) {
          goto LABEL_146;
        }
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_node_count (overflow)\n", v106, v107, v108, v109, v110, v111, v112, *(void *)(a1 + 8));
        uint64_t v22 = 92;
        uint64_t v86 = 400;
      }
    }
    else
    {
      unsigned __int16 v74 = 0;
      unint64_t v13 = a1 + 56;
      do
      {
        if ((*(_DWORD *)a2 & 0x40) != 0) {
          int v75 = 0x40000;
        }
        else {
          int v75 = 0x80000;
        }
        unint64_t v132 = v48 & 0xFFFFFFFF00000000 | v75 | v54;
        int v76 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, v75 | v54, 3, 0);
        if (v76)
        {
          if (!v9) {
            goto LABEL_146;
          }
          int v99 = v76;
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list offset %u\n", v77, v78, v79, v80, v81, v82, v83, *(void *)(a1 + 8));
          uint64_t v100 = 388;
          goto LABEL_138;
        }
        int v84 = *(unsigned __int16 *)(v13 + *(unsigned __int16 *)(a1 + 42) + v54 + 2);
        unint64_t v131 = v131 & 0xFFFFFFFF00000000 | v54 | (v84 << 16);
        int v85 = sub_100034D94((unsigned __int16 *)a1, (_DWORD *)a2, v54 | (v84 << 16), 3, v134);
        if (v85)
        {
          if (!v9) {
            goto LABEL_146;
          }
          int v101 = v85;
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list entry (%u, %u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
          uint64_t v100 = 389;
          int v102 = v101;
          goto LABEL_145;
        }
        v74 += v84;
        unsigned int v54 = *(unsigned __int16 *)(v13 + *(unsigned __int16 *)(a1 + 42) + v54);
        unint64_t v48 = v132;
      }
      while (v54 != 0xFFFF);
      unsigned int v55 = *(unsigned __int16 *)(a1 + 50);
      if (v55 >= v74)
      {
        uint64_t v35 = (void *)v134;
        goto LABEL_82;
      }
      if (!v9) {
        goto LABEL_146;
      }
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_key_free_list length (%u), given total key length (%u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
      uint64_t v22 = 92;
      uint64_t v86 = 390;
    }
    sub_100048B34((char *)v86, 92);
LABEL_147:
    uint64_t v35 = (void *)v134;
    goto LABEL_67;
  }
LABEL_61:
  uint64_t v22 = 92;
  if (v9)
  {
    sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_table_space (%u, %u)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a1 + 8));
    if (v45) {
      int v49 = v45;
    }
    else {
      int v49 = 92;
    }
    uint64_t v50 = 385;
    goto LABEL_66;
  }
LABEL_67:
  uint64_t v51 = (void *)v35[1];
  if (v51) {
    free(v51);
  }
  free(v35);
  return v22;
}

uint64_t sub_100034D94(unsigned __int16 *a1, _DWORD *a2, int a3, int a4, uint64_t a5)
{
  unsigned __int16 v6 = a3;
  unsigned __int16 v8 = HIWORD(a3);
  int v9 = a1[16];
  if ((v9 & 2) != 0)
  {
    int v11 = a2[3];
  }
  else
  {
    if ((v9 & 8) != 0) {
      int v10 = a2[11];
    }
    else {
      int v10 = 0;
    }
    int v11 = v10 + 8;
  }
  int v12 = *a2;
  if ((unsigned __int16)a3 == 0xFFFF || !HIWORD(a3))
  {
    uint64_t result = 22;
    if ((unsigned __int16)a3 == 0xFFFF)
    {
      if ((v12 & 4) != 0 && a4 == 2) {
        int v20 = 0;
      }
      else {
        int v20 = 22;
      }
      if ((v9 & 2) != 0) {
        unsigned int v21 = v20;
      }
      else {
        unsigned int v21 = 22;
      }
      if (HIWORD(a3)) {
        return 22;
      }
      else {
        return v21;
      }
    }
    return result;
  }
  unsigned int v13 = a2[1] + ((v9 << 31 >> 31) & 0xFFFFFFD8) - 56;
  unsigned int v14 = 8;
  unsigned int v15 = a1[22];
  int v16 = a1[23];
  switch(a4)
  {
    case 1:
      if (HIWORD(a3) > 0x340u) {
        return 7;
      }
      int v17 = a2[2];
      unsigned int v14 = 1;
      if (v17 && HIWORD(a3) != v17) {
        return 22;
      }
      goto LABEL_13;
    case 2:
      if ((unsigned __int16)a3 == 65534 || HIWORD(a3) == 65534)
      {
        uint64_t result = 22;
        if ((unsigned __int16)a3 == 65534 && HIWORD(a3) == 65534)
        {
          if ((v12 & 4) != 0) {
            unsigned int v22 = 0;
          }
          else {
            unsigned int v22 = 22;
          }
          if ((v9 & 2) != 0) {
            return v22;
          }
          else {
            return 22;
          }
        }
        return result;
      }
      if (HIWORD(a3) > 0xEE0u) {
        return 7;
      }
      unsigned int v14 = 1;
      if (v11 && HIWORD(a3) != v11) {
        return 22;
      }
LABEL_48:
      if ((unsigned __int16)a3 > v13 - (v16 + v15) || HIWORD(a3) > (unsigned __int16)a3) {
        return 84;
      }
      unsigned __int16 v6 = *((_WORD *)a2 + 2) + (((__int16)((_WORD)v9 << 15) >> 15) & 0xFFD8) - 56 - a3;
      if ((v12 & 0x40) == 0)
      {
LABEL_17:
        if ((v6 & 7) != 0 || HIWORD(a3) % v14) {
          return 14;
        }
      }
LABEL_53:
      if (v13 < v6 || HIWORD(a3) > v13 - v6) {
        return 84;
      }
      if (!a5) {
        return 0;
      }
      unsigned int v25 = *(_DWORD *)(a5 + 4);
      if (v25)
      {
        unsigned int v26 = 0;
        unsigned int v27 = *(_DWORD *)(a5 + 4);
        do
        {
          if (v6 < *(unsigned __int16 *)(*(void *)(a5 + 8) + 4 * ((v27 + v26) >> 1))) {
            unsigned int v27 = (v27 + v26) >> 1;
          }
          else {
            unsigned int v26 = ((v27 + v26) >> 1) + 1;
          }
        }
        while (v26 < v27);
        if (v26)
        {
          uint64_t v28 = (unsigned __int16 *)(*(void *)(a5 + 8) + 4 * (v26 - 1));
          unsigned int v29 = *v28;
          if (v28[1] + v29 > v6 && HIWORD(a3) + v6 > v29) {
            return 34;
          }
        }
      }
      else
      {
        unsigned int v26 = 0;
      }
      if (v26 < v25)
      {
        uint64_t v31 = (unsigned __int16 *)(*(void *)(a5 + 8) + 4 * v26);
        unsigned int v32 = *v31;
        if (v31[1] + v32 > v6 && HIWORD(a3) + v6 > v32) {
          return 34;
        }
      }
      if (v25 == *(_DWORD *)a5)
      {
        unsigned int v34 = v25 + 8;
        *(_DWORD *)a5 = v34;
        uint64_t v35 = reallocf(*(void **)(a5 + 8), 4 * v34);
        *(void *)(a5 + 8) = v35;
        if (!v35) {
          return 12;
        }
        unsigned int v25 = *(_DWORD *)(a5 + 4);
      }
      if (v25 > v26)
      {
        memmove((void *)(*(void *)(a5 + 8) + 4 * (v26 + 1)), (const void *)(*(void *)(a5 + 8) + 4 * v26), 4 * (v25 - v26));
        unsigned int v25 = *(_DWORD *)(a5 + 4);
      }
      uint64_t result = 0;
      size_t v36 = (unsigned __int16 *)(*(void *)(a5 + 8) + 4 * v26);
      *size_t v36 = v6;
      v36[1] = v8;
      *(_DWORD *)(a5 + 4) = v25 + 1;
      return result;
    case 3:
LABEL_13:
      uint64_t result = 84;
      if (v15 > (unsigned __int16)a3 && HIWORD(a3) <= (int)(v15 - (unsigned __int16)a3)) {
        goto LABEL_15;
      }
      return result;
    case 4:
      goto LABEL_48;
    case 5:
LABEL_15:
      unsigned __int16 v6 = a1[21] + a3;
      goto LABEL_16;
    default:
LABEL_16:
      if ((v12 & 0x40) == 0) {
        goto LABEL_17;
      }
      goto LABEL_53;
  }
}

uint64_t sub_1000350C8(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  unsigned int v3 = *a2;
  uint64_t v4 = *(unsigned int *)(a3 + 4);
  if (v4)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    int v7 = *(unsigned __int16 **)(a3 + 8);
    while (1)
    {
      if ((v3 & 0x40) != 0)
      {
        uint64_t v5 = *v7;
      }
      else
      {
        uint64_t v8 = ((v6 + 7) & 0x1FFF8) + v5;
        uint64_t v5 = *v7;
        if (v8 != v5) {
          return 22;
        }
      }
      int v6 = v7[1];
      v7 += 2;
      if (!--v4)
      {
        uint64_t v9 = (v6 + 7) & 0x1FFF8;
        goto LABEL_9;
      }
    }
  }
  uint64_t v9 = 0;
  uint64_t v5 = 0;
LABEL_9:
  int v10 = (v3 >> 6) & 1;
  if (v9 + v5 == a2[1] + ((*(unsigned __int16 *)(a1 + 32) << 31 >> 31) & 0xFFFFFFD8) - 56) {
    int v10 = 1;
  }
  if (v10) {
    return 0;
  }
  else {
    return 22;
  }
}

uint64_t sub_100035168(uint64_t a1, uint64_t a2, uint64_t (*a3)(void, void, const void *, void, void *, void, uint64_t, int *), uint64_t a4, void *a5, char a6)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 45;
  }
  uint64_t v12 = *(void *)(a1 + 56);
  unsigned int v103 = 0;
  memset(v104, 170, sizeof(v104));
  int v102 = 0;
  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  long long v97 = 0u;
  memset(v106, 0, sizeof(v106));
  uint64_t v105 = v12;
  __int16 v96 = -1;
  uint64_t v20 = sub_100033E70(a1, v12, a2, (uint64_t)v104, &v103, &v102, (uint64_t)&v97, a6);
  if (!v20)
  {
    unsigned int v21 = v102;
    unsigned int v22 = *v102;
    if ((*v102 & 0xFFFFFE20) != 0)
    {
      sub_100044674("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x)\n", v13, v14, v15, v16, v17, v18, v19, v103[1]);
      sub_100048B34((char *)0x19A, -3);
      unsigned int v21 = v102;
      unsigned int v22 = *v102;
    }
    if ((~v22 & 0x18) == 0)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x)\n", v13, v14, v15, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 411;
LABEL_38:
      int v32 = 92;
LABEL_39:
      sub_100048B34((char *)v24, v32);
      goto LABEL_40;
    }
    int v25 = *(_DWORD *)(a1 + 52);
    if ((v22 & 0x180) == 0x180)
    {
      if (!v25) {
        goto LABEL_13;
      }
    }
    else
    {
      if (v25 | v22 & 0x180)
      {
LABEL_13:
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unexpected btn_btree.bt_fixed.bt_flags (0x%x)\n", v13, v14, v15, v16, v17, v18, v19, v103[1]);
        uint64_t v20 = 92;
        uint64_t v24 = 914;
        goto LABEL_38;
      }
      int v25 = 0;
    }
    if (((v22 << 28) & 0x80000000 | (((v22 >> 4) & 1) << 30)) != *(_DWORD *)(a1 + 40))
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_flags (0x%x), given mt_btflags\n", v13, v14, v15, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 412;
      goto LABEL_38;
    }
    int v26 = *(_DWORD *)(a1 + 24);
    if (v26 && v21[1] != v26)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_node_size (%u), given mt_node_size (%u)\n", v13, v14, v15, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 415;
      goto LABEL_38;
    }
    unsigned int v27 = v21[2];
    uint64_t v28 = (uint64_t)v103;
    if (v27 > 0x340 || (v27 & 3) != 0)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u)\n", v13, v14, (uint64_t)v103, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 416;
      goto LABEL_38;
    }
    if (!v27 && (v103[4] & 4) != 0)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given btn_flags (0x%x)\n", v13, v14, (uint64_t)v103, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 417;
      goto LABEL_38;
    }
    if ((v22 & 1) != 0 && v27 != 8)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given btn_btree.bt_fixed.bt_flags (0x%x)\n", v13, v14, (uint64_t)v103, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 418;
      goto LABEL_38;
    }
    int v29 = *(_DWORD *)(a1 + 28);
    if (v29 && v27 != v29)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_key_size (%u), given mt_key_size (%u)\n", v13, v14, (uint64_t)v103, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 419;
      goto LABEL_38;
    }
    unsigned int v30 = v21[3];
    if (v30 > 0xEE0 || (v30 & 7) != 0)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_val_size (%u)\n", v13, v14, (uint64_t)v103, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 420;
      goto LABEL_38;
    }
    int v31 = *(_DWORD *)(a1 + 32);
    if (v31 && v30 != v31)
    {
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_fixed.bt_val_size (%u), given mt_val_size (%u)\n", v13, v14, (uint64_t)v103, v16, v17, v18, v19, v103[1]);
      uint64_t v20 = 92;
      uint64_t v24 = 421;
      goto LABEL_38;
    }
    if (v25)
    {
      uint64_t v20 = sub_10004AD8C(*(uint64_t **)a1, *(void *)(a1 + 8), a2, (BOOL *)&v101 + 8, &v100, (void *)&v100 + 1, v106, 0x40u);
      if (v20) {
        goto LABEL_40;
      }
      uint64_t v28 = (uint64_t)v103;
    }
    long long v94 = 0uLL;
    uint64_t v95 = 0;
    long long v92 = *(_OWORD *)v104;
    uint64_t v93 = *(void *)&v104[16];
    uint64_t v20 = sub_100035AC8(a1, 0, (uint64_t)&v94, v28, (uint64_t)&v92, (unint64_t *)&v105, a2, a3, a4, 0, 0, 0, 0, &v96, (uint64_t)&v97, 1u, a6);
    if (!v20)
    {
      if (BYTE11(v101))
      {
        while (1)
        {
          sub_10004435C("Restarting tree validation in case more minkey errors exist...\n", v33, v34, v35, v36, v37, v38, v39, v91);
          BYTE11(v101) = 0;
          BYTE9(v101) = 1;
          uint64_t v41 = v99;
          long long v94 = 0uLL;
          uint64_t v95 = 0;
          long long v92 = *(_OWORD *)v104;
          uint64_t v93 = *(void *)&v104[16];
          uint64_t v42 = sub_100035AC8(a1, 0, (uint64_t)&v94, (uint64_t)v103, (uint64_t)&v92, (unint64_t *)&v105, a2, 0, 0, 0, 0, 0, 0, &v96, (uint64_t)&v97, 1u, 0);
          if (v42) {
            break;
          }
          *(void *)&long long v99 = v41;
          if (!BYTE11(v101)) {
            goto LABEL_49;
          }
        }
        uint64_t v20 = v42;
        goto LABEL_40;
      }
LABEL_49:
      uint64_t v43 = v102;
      unsigned int v44 = v102[4];
      if (v44 > 0x340 || v44 < v98)
      {
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_key (expected %u, actual %u)\n", v33, v34, v35, v36, v37, v38, v39, v103[1]);
        uint64_t v20 = 92;
        sub_100048B34((char *)0x1AA, 92);
        if (!sub_10004641C(qword_100091B70, "Fix btree: bt_longest_key (%u)? ", v46, v47, v48, v49, v50, v51, v102[4]))goto LABEL_40; {
        unsigned int v44 = v98;
        }
        uint64_t v43 = v102;
        v102[4] = v98;
        int v45 = 1;
      }
      else
      {
        int v45 = 0;
      }
      if (*((void *)v43 + 3))
      {
        int v52 = v43[2];
        if (v52)
        {
          if (v44 != v52)
          {
            sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_key (%u), given btn_btree.bt_fixed.bt_key_size (%u)\n", v33, v34, v35, v36, v37, v38, v39, v103[1]);
            uint64_t v20 = 92;
            sub_100048B34((char *)0x1AB, 92);
            if (!sub_10004641C(qword_100091B70, "Fix btree: bt_longest_key (%u)? ", v53, v54, v55, v56, v57, v58, v102[4]))goto LABEL_40; {
            uint64_t v43 = v102;
            }
            v102[4] = v102[2];
            int v45 = 1;
          }
        }
      }
      unsigned int v59 = v43[5];
      if (v59 > 0xEE0 || (int v60 = v43[5], v59 < DWORD1(v98)))
      {
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_val (expected %u, actual %u)\n", v33, v34, v35, v36, v37, v38, v39, v103[1]);
        uint64_t v20 = 92;
        sub_100048B34((char *)0x1AC, 92);
        if (!sub_10004641C(qword_100091B70, "Fix btree: bt_longest_val (%u)? ", v61, v62, v63, v64, v65, v66, v102[5]))goto LABEL_40; {
        int v60 = DWORD1(v98);
        }
        uint64_t v43 = v102;
        v102[5] = DWORD1(v98);
        int v45 = 1;
      }
      uint64_t v67 = *((void *)v43 + 3);
      if (v67)
      {
        int v68 = v43[3];
        if (v68)
        {
          if (v60 != v68 && (v60 || (*(unsigned char *)v43 & 4) == 0))
          {
            sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_longest_val (%u), given btn_btree.bt_fixed.bt_val_size (%u)\n", v33, v34, v35, v36, v37, v38, v39, v103[1]);
            uint64_t v20 = 92;
            sub_100048B34((char *)0x1AD, 92);
            if (!sub_10004641C(qword_100091B70, "Fix btree: bt_longest_val (%u)? ", v69, v70, v71, v72, v73, v74, v102[5]))goto LABEL_40; {
            uint64_t v43 = v102;
            }
            v102[5] = v102[3];
            uint64_t v67 = *((void *)v43 + 3);
            int v45 = 1;
          }
        }
      }
      if (v67 == *((void *)&v98 + 1))
      {
        if (*((void *)v43 + 4) == (void)v99)
        {
          if (!v45) {
            goto LABEL_82;
          }
          goto LABEL_79;
        }
      }
      else
      {
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_key_count (expected %llu, actual %llu)\n", v33, v34, v35, v36, v37, v38, v39, v103[1]);
        uint64_t v20 = 92;
        sub_100048B34((char *)0x1AE, 92);
        if (!sub_10004641C(qword_100091B70, "Fix btree: bt_key_count (%llu)? ", v75, v76, v77, v78, v79, v80, *((void *)v102 + 3)))goto LABEL_40; {
        uint64_t v81 = v102;
        }
        *((void *)v102 + 3) = *((void *)&v98 + 1);
        if (*((void *)v81 + 4) == (void)v99)
        {
LABEL_79:
          int v88 = *(uint64_t **)a1;
          uint64_t v89 = *(void *)(a1 + 8);
          long long v94 = *(_OWORD *)v104;
          uint64_t v95 = *(void *)&v104[16];
          uint64_t v90 = sub_100026BA0(v88, v89, (uint64_t)v103, (uint64_t)&v94, *(int8x16_t *)v104, v40);
          if (v90)
          {
            uint64_t v20 = v90;
            uint64_t v24 = 434;
            int v32 = v20;
            goto LABEL_39;
          }
          sub_100048AE4();
LABEL_82:
          uint64_t v20 = 0;
          if (a5) {
            *a5 = *((void *)&v98 + 1);
          }
          goto LABEL_40;
        }
      }
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_btree.bt_node_count (expected %llu, actual %llu)\n", v33, v34, v35, v36, v37, v38, v39, v103[1]);
      uint64_t v20 = 92;
      sub_100048B34((char *)0x1AF, 92);
      if (sub_10004641C(qword_100091B70, "Fix btree: bt_node_count (%llu)? ", v82, v83, v84, v85, v86, v87, *((void *)v102 + 4)))
      {
        *((void *)v102 + 4) = v99;
        goto LABEL_79;
      }
    }
LABEL_40:
    if (v103) {
      free(v103);
    }
  }
  return v20;
}

uint64_t sub_100035AC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t *a6, uint64_t a7, uint64_t (*a8)(void, void, const void *, void, void *, void, uint64_t, int *), uint64_t a9, const void *a10, unsigned int a11, const void *a12, unsigned int a13, _WORD *a14, uint64_t a15, unsigned __int8 a16, char a17)
{
  uint64_t v18 = a14;
  unsigned __int16 v19 = a11;
  uint64_t v240 = a10;
  uint64_t v237 = 0;
  uint64_t v238 = 0;
  unsigned __int16 v236 = a11;
  __int16 v235 = -21846;
  int v234 = 0;
  int v232 = 0;
  if (*(_DWORD *)(a5 + 8) != *(_DWORD *)(a15 + 4))
  {
    sub_100044674("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: invalid cpm_size or ov_size (%u), given btn_btree.bt_fixed.bt_node_size (%u)\n", a2, a3, a4, a5, (uint64_t)a6, a7, (uint64_t)a8, *(void *)(a4 + 8));
    uint64_t v26 = 92;
    uint64_t v39 = 401;
LABEL_18:
    int v40 = 92;
LABEL_19:
    sub_100048B34((char *)v39, v40);
    goto LABEL_168;
  }
  unsigned __int16 v23 = *(_WORD *)(a4 + 32);
  if (((((v23 & 1) == 0) ^ a16) & 1) == 0)
  {
    uint64_t v24 = "not a root";
    if (a16) {
      uint64_t v24 = "a root";
    }
    unint64_t v215 = *(unsigned __int16 *)(a4 + 32);
    uint64_t v216 = v24;
    uint64_t v213 = (const char *)v215;
    uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
    if (a16) {
      int v25 = "Set";
    }
    else {
      int v25 = "Clear";
    }
    sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btree node is %s\n", a2, a3, a4, a5, (uint64_t)a6, a7, (uint64_t)a8, *(void *)(a4 + 8));
    uint64_t v26 = 92;
    sub_100048B34((char *)0x192, 92);
    if (!sub_10004641C(qword_100091B70, "%s BTNODE_ROOT flag? ", v27, v28, v29, v30, v31, v32, (char)v25)) {
      goto LABEL_168;
    }
    unsigned __int16 v23 = *(_WORD *)(a4 + 32) & 0xFFFE | a16;
    *(_WORD *)(a4 + 32) = v23;
    int v232 = 1;
  }
  uint64_t v223 = a1;
  int v33 = *(unsigned __int16 *)(a4 + 34);
  if ((*(_WORD *)(a4 + 34) == 0) == ((v23 & 2) == 0))
  {
    if ((v23 & 1) == 0
      || (uint64_t v34 = a4 + *(unsigned int *)(a5 + 8),
          uint64_t v35 = *(unsigned int *)(a4 + 36),
          uint64_t v36 = *(void *)(v34 - 16),
          (*(void *)(v34 - 8) != 1) == (v36 == v35)))
    {
      int v41 = (unsigned __int16)*a14;
      if (v41 == 0xFFFF || v33 != v41) {
        goto LABEL_37;
      }
      uint64_t v42 = "not a leaf";
      if (!*(_WORD *)(a4 + 34)) {
        uint64_t v42 = "a leaf";
      }
      unint64_t v215 = v23;
      uint64_t v216 = v42;
      uint64_t v213 = (const char *)v23;
      uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
      if (*(_WORD *)(a4 + 34)) {
        uint64_t v43 = "Clear";
      }
      else {
        uint64_t v43 = "Set";
      }
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btree node is %s\n", a2, a3, a4, a5, (uint64_t)a6, a7, (uint64_t)a8, *(void *)(a4 + 8));
      uint64_t v26 = 92;
      sub_100048B34((char *)0x4AF, 92);
      if (!sub_10004641C(qword_100091B70, "%s BTNODE_LEAF flag? ", v44, v45, v46, v47, v48, v49, (char)v43))goto LABEL_168; {
      BOOL v50 = v33 == 0;
      }
    }
    else
    {
      uint64_t v37 = *(void *)(a4 + 8);
      uint64_t v38 = "not a leaf";
      if (v36 == v35) {
        uint64_t v38 = "a leaf";
      }
      if ((v33 == 0) != (v36 == v35))
      {
        unint64_t v215 = *(unsigned __int16 *)(a4 + 34);
        uint64_t v216 = v38;
        uint64_t v213 = (const char *)v23;
        uint64_t v214 = (const char *)v215;
        sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_level (%u), given btree node is %s\n", a2, a3, a4, a5, (uint64_t)a6, a7, (uint64_t)a8, v37);
        sub_100048B34((char *)0x4AE, 92);
        goto LABEL_37;
      }
      unint64_t v215 = v23;
      uint64_t v216 = v38;
      uint64_t v213 = (const char *)v23;
      uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
      sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btree node is %s\n", a2, a3, a4, a5, (uint64_t)a6, a7, (uint64_t)a8, v37);
      uint64_t v26 = 92;
      sub_100048B34((char *)0x4AD, 92);
      uint64_t v57 = "Clear";
      if (v36 == v35) {
        uint64_t v57 = "Set";
      }
      if (!sub_10004641C(qword_100091B70, "%s BTNODE_LEAF flag? ", v51, v52, v53, v54, v55, v56, (char)v57))goto LABEL_168; {
      BOOL v50 = v36 == v35;
      }
    }
    __int16 v58 = v50;
    *(_WORD *)(a4 + 32) = *(_WORD *)(a4 + 32) & 0xFFFD | (2 * v58);
    int v232 = 1;
  }
LABEL_37:
  uint64_t v239 = (void *)0xAAAAAAAAAAAAAAAALL;
  int v233 = -1431655766;
  uint64_t v59 = sub_10003416C(a4, a15, 1, &v232, a5, (uint64_t)a6, a7, (uint64_t)a8);
  int v68 = *(unsigned __int16 *)(a4 + 32);
  if (v59)
  {
    unsigned int v69 = v59;
    *(_WORD *)(a4 + 32) = v68 ^ 2;
    int v70 = sub_10003416C(a4, a15, 0, &v232, v63, v64, v65, v66);
    int v78 = *(unsigned __int16 *)(a4 + 32);
    *(_WORD *)(a4 + 32) = v78 ^ 2;
    if (v70) {
      goto LABEL_39;
    }
    uint64_t v79 = "a leaf";
    if ((v78 & 2) == 0) {
      uint64_t v79 = "not a leaf";
    }
    unint64_t v215 = v78 ^ 2u;
    uint64_t v216 = v79;
    uint64_t v213 = (const char *)v215;
    uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
    uint64_t v80 = (v78 & 2) != 0 ? "Set" : "Clear";
    sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btree node is %s\n", v71, v72, v73, v74, v75, v76, v77, *(void *)(a4 + 8));
    sub_100048B34((char *)0x480, 92);
    uint64_t v59 = sub_10004641C(qword_100091B70, "%s BTNODE_LEAF flags? ", v81, v82, v83, v84, v85, v86, (char)v80);
    if (!v59)
    {
LABEL_39:
      uint64_t v26 = sub_10000AD08(v223, a15, *(void *)(a4 + 8), *(void *)(a4 + 16), *(unsigned __int16 *)(a4 + 34), a10, a11, a12, a13, v69);
      goto LABEL_168;
    }
    int v87 = *(unsigned __int16 *)(a4 + 32);
    int v68 = v87 ^ 2;
    *(_WORD *)(a4 + 32) = v87 ^ 2;
    if ((v78 & 2) != 0) {
      *(_WORD *)(a4 + 34) = 0;
    }
    int v232 = 1;
  }
  uint64_t v219 = a5;
  if ((v68 & 2) != 0 && sub_10001D070(v59, v60, v61, v62, v63, v64, v65, v66))
  {
    sub_10004458C("fsck_apfs is out of memory - some cross checks are skipped\n", v60, v61, v88, v63, v64, v65, v66, v210);
    sub_100048B34((char *)0x585, 12);
  }
  if (!*(_DWORD *)(v223 + 52)
    || (uint64_t v26 = sub_10004B130(a15, a4, a6, *(unsigned int *)(v223 + 24), v63, v64, v65, v66), !v26))
  {
    unsigned __int16 v89 = 0;
    uint64_t v90 = 0;
    char v91 = 0;
    char v225 = v68;
    int v218 = (v68 << 25) & 0x20000000;
    unsigned int v224 = (unsigned __int16)a13;
    unsigned int v92 = *(_DWORD *)(a4 + 36);
    uint64_t v93 = v223;
    long long v94 = a10;
    while (1)
    {
      unsigned __int16 v95 = v19;
      uint64_t v96 = (uint64_t)v94;
      if (v92 <= v91)
      {
        long long v94 = a12;
        uint64_t v237 = 0;
        uint64_t v238 = a12;
        HIWORD(v234) = a13;
        if (!v96) {
          goto LABEL_128;
        }
      }
      else
      {
        sub_100033F78(a4, a15, v91, (uint64_t *)&v238, (_WORD *)&v234 + 1, (uint64_t *)&v237, &v234);
        long long v94 = v238;
        if (!v96) {
          goto LABEL_128;
        }
      }
      if (v94)
      {
        uint64_t v97 = *(void *)(v93 + 8);
        if (v97) {
          uint64_t v98 = *(void *)(v97 + 40);
        }
        else {
          uint64_t v98 = 0;
        }
        unsigned __int16 v226 = v19;
        unsigned int v99 = HIWORD(v234);
        unsigned int v221 = v95;
        uint64_t v229 = (uint64_t)v94;
        uint64_t v100 = (*(uint64_t (**)(uint64_t, uint64_t))(v93 + 16))(v98, v96);
        if (v100 == 45)
        {
          unint64_t v215 = (v91 - 1);
          uint64_t v216 = v91;
          uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
          uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
          sub_100044674("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nwarning: btn: can't compare key (%u) with key (%u)\n", v60, v61, v101, v63, v64, v65, v66, *(void *)(a4 + 8));
          sub_100048B34((char *)0x55F, -5);
          if (v91) {
            int v102 = -1;
          }
          else {
            int v102 = 0;
          }
          int v233 = v102;
        }
        else
        {
          uint64_t v26 = v100;
          if (v100)
          {
            sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: key (%u) compare error: %d\n", v60, v61, v101, v63, v64, v65, v66, *(void *)(a4 + 8));
            uint64_t v194 = 403;
            goto LABEL_165;
          }
          int v102 = v233;
        }
        unsigned __int16 v95 = v226;
        if (!v91 && v102)
        {
          BOOL v103 = v102 < 0;
          int v104 = "greater than";
          if (v103) {
            int v104 = "less than";
          }
          uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
          unint64_t v215 = (unint64_t)v104;
          uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
          sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key order: minkey is %s index 0 (should be equal)\n", v60, v61, v101, v63, v64, v65, v66, *(void *)(a4 + 8));
          uint64_t v105 = 1117;
          goto LABEL_82;
        }
        long long v94 = (const void *)v229;
        if (v91)
        {
          if ((v102 & 0x80000000) == 0)
          {
            uint64_t v106 = *(void *)(a4 + 8);
            BOOL v50 = v102 == 0;
            uint64_t v107 = "greater than";
            if (v50) {
              uint64_t v107 = "equal to";
            }
            if (v91 == *(_DWORD *)(a4 + 36))
            {
              unint64_t v215 = (v91 - 1);
              uint64_t v216 = v107;
              uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
              uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
              sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key order: index %u is %s maxkey (should be less than)\n", v60, v61, v229, v63, v64, v65, v66, v106);
              uint64_t v105 = 1118;
            }
            else
            {
              uint64_t v216 = v107;
              uint64_t v217 = v91;
              uint64_t v214 = (const char *)*(unsigned __int16 *)(a4 + 34);
              unint64_t v215 = (v91 - 1);
              uint64_t v213 = (const char *)*(unsigned __int16 *)(a4 + 32);
              sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid key order: index %u is %s index %u (should be less than)\n", v60, v61, v229, v63, v64, v65, v66, v106);
              uint64_t v105 = 404;
            }
LABEL_82:
            sub_100048B34((char *)v105, 92);
            unsigned int v108 = v226;
            if (v226 <= v99) {
              unsigned int v108 = v99;
            }
            size_t v109 = 3 * v108 + 1;
            uint64_t v110 = (char *)malloc_type_malloc(v109, 0xA7D72012uLL);
            *(void *)&long long v118 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v118 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)__str = v118;
            long long v255 = v118;
            if (v110)
            {
              uint64_t v119 = v110;
              if (v91 && v90)
              {
                sub_100036B34(__str, v91 - 1, *(_DWORD *)(a4 + 36));
                sub_100036BC0(v119, v109, v90, v89);
                sub_10004435C("\t%-14s: %s\n", v120, v121, v122, v123, v124, v125, v126, (char)__str);
              }
              sub_100036B34(__str, v91, *(_DWORD *)(a4 + 36));
              sub_100036BC0(v119, v109, v96, v221);
              sub_10004435C("\t%-14s: %s\n", v127, v128, v129, v130, v131, v132, v133, (char)__str);
              sub_100036B34(__str, v91 + 1, *(_DWORD *)(a4 + 36));
              sub_100036BC0(v119, v109, v229, v99);
              sub_10004435C("\t%-14s: %s\n", v134, v135, v136, v137, v138, v139, v140, (char)__str);
              unsigned int v141 = *(_DWORD *)(a4 + 36);
              if (v91 < v141)
              {
                *(void *)int v243 = 0xAAAAAAAAAAAAAAAALL;
                LOWORD(v241) = -21846;
                unsigned int v142 = (unsigned __int16)a13;
                uint64_t v143 = (uint64_t)a12;
                if (v141 > (int)v91 + 1)
                {
                  sub_100033F78(a4, a15, v91 + 1, (uint64_t *)v243, &v241, 0, 0);
                  unsigned int v141 = *(_DWORD *)(a4 + 36);
                  uint64_t v143 = *(void *)v243;
                  unsigned int v142 = (unsigned __int16)v241;
                }
                sub_100036B34(__str, v91 + 2, v141);
                sub_100036BC0(v119, v109, v143, v142);
                sub_10004435C("\t%-14s: %s\n", v144, v145, v146, v147, v148, v149, v150, (char)__str);
              }
              free(v119);
            }
            uint64_t v26 = 92;
            if (v91 || (v233 & 0x80000000) == 0) {
              goto LABEL_167;
            }
            sub_10004435C("Checking if the parent's minkey can be updated...\n", v111, v112, v113, v114, v115, v116, v117, v211);
            uint64_t v93 = v223;
            *(_OWORD *)uint64_t v230 = *(_OWORD *)a3;
            uint64_t v231 = *(void *)(a3 + 16);
            uint64_t v252 = (void *)0xAAAAAAAAAAAAAAAALL;
            if (!*(_DWORD *)(a2 + 36)) {
              goto LABEL_104;
            }
            unsigned int v151 = 0;
            do
            {
              sub_100033F78(a2, a15, v151, &v253, &v249, (uint64_t *)&v252, &v248);
              uint64_t v152 = *(_DWORD *)(a15 + 40) ? *(void *)(a15 + 64) : 0;
              if (v152 + *v252 == *a6) {
                break;
              }
              ++v151;
            }
            while (v151 < *(_DWORD *)(a2 + 36));
            if (!v151)
            {
LABEL_104:
              unsigned int v151 = 0;
              if ((*(_WORD *)(a2 + 32) & 1) == 0) {
                *(unsigned char *)(a15 + 75) = 1;
              }
            }
            uint64_t v250 = 0xAAAAAAAAAAAAAAAALL;
            uint64_t v251 = (const void *)0xAAAAAAAAAAAAAAAALL;
            unsigned __int16 v247 = -21846;
            __int16 v246 = -21846;
            sub_100033F78(a4, a15, 0, (uint64_t *)&v251, &v247, 0, 0);
            uint64_t v157 = v151 + 1;
            if (*(_DWORD *)(a2 + 36) <= v157)
            {
              uint64_t v158 = (uint64_t)a12;
              uint64_t v250 = (uint64_t)a12;
              __int16 v246 = a13;
            }
            else
            {
              sub_100033F78(a2, a15, v157, &v250, &v246, 0, 0);
              uint64_t v158 = v250;
            }
            int v245 = -1431655766;
            if (v158)
            {
              uint64_t v159 = *(void *)(v223 + 8);
              uint64_t v160 = v159 ? *(void *)(v159 + 40) : 0;
              LODWORD(v26) = (*(uint64_t (**)(uint64_t, const void *, void))(v223 + 16))(v160, v251, v247);
              if (v26 || (v245 & 0x80000000) == 0)
              {
                sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unable to repair minkey\n", v161, v157, v162, v153, v154, v155, v156, *(void *)(a2 + 8));
                if (v26) {
                  uint64_t v26 = v26;
                }
                else {
                  uint64_t v26 = 92;
                }
                uint64_t v194 = 1114;
LABEL_165:
                int v195 = v26;
LABEL_166:
                sub_100048B34((char *)v194, v195);
LABEL_167:
                uint64_t v18 = a14;
                break;
              }
            }
            if (*(_DWORD *)(a4 + 36) < 2u)
            {
              __int16 v246 = a13;
              uint64_t v163 = (uint64_t)a12;
              if (!a12)
              {
LABEL_124:
                if (!sub_10004641C(qword_100091B70, "Update the parent's minkey? ", v157, v163, v153, v154, v155, v156, v212))
                {
                  uint64_t v26 = 92;
                  goto LABEL_167;
                }
                *(_OWORD *)int v243 = *(_OWORD *)a15;
                int v167 = *(_DWORD *)(v223 + 36);
                uint64_t v168 = *(void *)(v223 + 56);
                *(_DWORD *)&v243[20] = -1431655766;
                uint64_t v244 = v168;
                *(_DWORD *)&v243[16] = v167;
                if (!sub_100038D8C((uint64_t)v243, (unsigned __int16 *)a2, v151, v251, v247, 0, 0))
                {
                  sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: parent doesn't have enough space to update the minkey\n", v169, v170, v171, v172, v173, v174, v175, *(void *)(a2 + 8));
                  uint64_t v26 = 92;
                  uint64_t v194 = 1116;
                  int v195 = 92;
                  goto LABEL_166;
                }
                long long v177 = *(uint64_t **)v223;
                uint64_t v178 = *(void *)(v223 + 8);
                long long v241 = *(_OWORD *)v230;
                uint64_t v242 = v231;
                uint64_t v179 = sub_100026BA0(v177, v178, a2, (uint64_t)&v241, *(int8x16_t *)v230, v176);
                if (v179) {
                  goto LABEL_142;
                }
                sub_100048AE4();
                long long v94 = (const void *)v229;
                unsigned __int16 v95 = v226;
                goto LABEL_128;
              }
            }
            else
            {
              sub_100033F78(a4, a15, 1u, &v250, &v246, 0, 0);
              uint64_t v163 = v250;
              if (!v250) {
                goto LABEL_124;
              }
            }
            uint64_t v164 = *(void *)(v223 + 8);
            if (v164) {
              uint64_t v165 = *(void *)(v164 + 40);
            }
            else {
              uint64_t v165 = 0;
            }
            LODWORD(v26) = (*(uint64_t (**)(uint64_t, const void *, void))(v223 + 16))(v165, v251, v247);
            if (v26 || (v245 & 0x80000000) == 0)
            {
              sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: unable to repair minkey\n", v166, v157, v163, v153, v154, v155, v156, *(void *)(a2 + 8));
              if (v26) {
                uint64_t v26 = v26;
              }
              else {
                uint64_t v26 = 92;
              }
              uint64_t v194 = 1115;
              goto LABEL_165;
            }
            goto LABEL_124;
          }
        }
      }
LABEL_128:
      unsigned int v92 = *(_DWORD *)(a4 + 36);
      if ((v225 & 2) != 0 && a8 && v91 < v92)
      {
        unsigned __int16 v19 = HIWORD(v234);
        if (!*(unsigned char *)(a15 + 74))
        {
          long long v180 = v94;
          uint64_t v179 = a8(*(void *)v93, *(void *)(v93 + 8), v94, HIWORD(v234), v237, (unsigned __int16)v234, a9, &v232);
          if (v179)
          {
LABEL_142:
            uint64_t v26 = v179;
            goto LABEL_167;
          }
          unsigned int v92 = *(_DWORD *)(a4 + 36);
          long long v94 = v180;
        }
      }
      else
      {
        unsigned __int16 v19 = HIWORD(v234);
      }
      uint64_t v239 = v237;
      char v91 = (const char *)(v91 + 1);
      unsigned __int16 v89 = v95;
      uint64_t v90 = v96;
      if (v91 > v92)
      {
        uint64_t v240 = v94;
        unsigned __int16 v236 = v19;
        if ((v225 & 2) != 0 || !v92)
        {
          uint64_t v181 = v219;
          uint64_t v18 = a14;
          if ((v225 & 2) != 0) {
            *a14 = 0;
          }
          goto LABEL_145;
        }
        uint64_t v181 = v219;
        uint64_t v18 = a14;
        if (*(unsigned char *)(a15 + 73) && *(unsigned __int16 *)(a4 + 34) < 2u) {
          goto LABEL_145;
        }
        memset(v243, 170, sizeof(v243));
        v230[0] = 0;
        sub_100033F78(a4, a15, 0, (uint64_t *)&v240, &v236, (uint64_t *)&v239, &v235);
        uint64_t v182 = *(_DWORD *)(a15 + 40) ? *(void *)(a15 + 64) : 0;
        uint64_t v197 = v182 + *v239;
        unsigned int v198 = sub_1000257B4(*(uint64_t **)v93, *(void *)(v93 + 8), *(_DWORD *)(v93 + 40), v197, a7, v218, 3, *(_DWORD *)(v93 + 48), (uint64_t **)v230, (uint64_t)v243, a17);
        if (!v198) {
          goto LABEL_193;
        }
        unsigned int v199 = v198;
        long long v200 = a12;
        if (*(_DWORD *)(a4 + 36) >= 2u)
        {
          sub_100033F78(a4, a15, 1u, (uint64_t *)&v238, (_WORD *)&v234 + 1, 0, 0);
          long long v200 = v238;
          unsigned int v224 = HIWORD(v234);
        }
        uint64_t v26 = sub_10000AD08(v93, a15, v197, *(void *)(a4 + 16), (unsigned __int16)(*(_WORD *)(a4 + 34) - 1), v240, v236, v200, v224, v199);
        if (!v26)
        {
LABEL_193:
          if (*(unsigned __int16 *)(a4 + 34) > 1u)
          {
            long long v201 = sub_100036CCC;
            goto LABEL_189;
          }
          *(_DWORD *)__str = -1431655766;
          uint64_t v202 = sub_10002F368(**(void **)v93);
          if (v202)
          {
            uint64_t v26 = v202;
            free(v230[0]);
            break;
          }
          long long v201 = sub_100037050;
          if (!*(_DWORD *)__str) {
            long long v201 = sub_1000374D4;
          }
LABEL_189:
          *(_OWORD *)__str = *(_OWORD *)v219;
          *(void *)&long long v255 = *(void *)(v219 + 16);
          long long v241 = *(_OWORD *)v243;
          uint64_t v242 = *(void *)&v243[16];
          LOBYTE(v213) = a17;
          uint64_t v26 = ((uint64_t (*)(uint64_t, uint64_t, char *, void *, long long *, uint64_t, uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *), uint64_t, const void *, unsigned int, _WORD *, uint64_t, const char *, const char *, unint64_t, const char *, const char *))v201)(v93, a4, __str, v230[0], &v241, a7, a8, a9, a12, a13, a14, a15, v213, v214, v215, v216, v217);
          if (!v26)
          {
LABEL_145:
            if (*(unsigned char *)(a15 + 74) || *(unsigned char *)(a15 + 73)) {
              goto LABEL_147;
            }
            int v203 = *(unsigned __int16 *)(a4 + 34);
            if (v203 != (unsigned __int16)*v18)
            {
              sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_level (expected %u, actual %u)\n", v60, v61, (uint64_t)v94, v63, v64, v65, v66, *(void *)(a4 + 8));
              uint64_t v26 = 92;
              sub_100048B34((char *)0x197, 92);
              if (!sub_10004641C(qword_100091B70, "Fix btn_level (%u)? ", v204, v205, v206, v207, v208, v209, *(_WORD *)(a4 + 34)))break; {
              int v203 = (unsigned __int16)*v18;
              }
              *(_WORD *)(a4 + 34) = v203;
              int v232 = 1;
            }
            if ((v225 & 2) != 0)
            {
              if (v203) {
                goto LABEL_186;
              }
            }
            else if (!v203)
            {
LABEL_186:
              sub_10004458C("btn: oid (%llu), xid (%llu), type (0x%x), subtype (0x%x), flags (0x%x) level (%u)\nerror: btn: invalid btn_flags (0x%x), given btn_level (%u)\n", v60, v61, (uint64_t)v94, v63, v64, v65, v66, *(void *)(a4 + 8));
              uint64_t v26 = 92;
              uint64_t v39 = 408;
              goto LABEL_18;
            }
LABEL_147:
            if (!*(_DWORD *)(v93 + 40))
            {
              int v183 = sub_10001F74C(1, *a6, 1);
              if (v183)
              {
                int v191 = v183;
                sub_100044674("object (oid 0x%llx): Unable to mark omap entry in use for omap space verification \n", v184, v185, v186, v187, v188, v189, v190, *a6);
                sub_100048B34((char *)0x3F4, v191);
              }
            }
            if (v232)
            {
              long long v192 = *(uint64_t **)v93;
              uint64_t v193 = *(void *)(v93 + 8);
              *(_OWORD *)int v243 = *(_OWORD *)v181;
              *(void *)&v243[16] = *(void *)(v181 + 16);
              uint64_t v26 = sub_100026BA0(v192, v193, a4, (uint64_t)v243, *(int8x16_t *)v243, v67);
              if (v26)
              {
                uint64_t v39 = 409;
                int v40 = v26;
                goto LABEL_19;
              }
              sub_100048AE4();
            }
            else
            {
              uint64_t v26 = 0;
            }
          }
        }
        break;
      }
    }
  }
LABEL_168:
  ++*v18;
  return v26;
}

char *sub_100036B34(char *__str, unsigned int a2, int a3)
{
  if (!a2)
  {
    *(_DWORD *)(__str + 3) = 7955819;
    int v4 = 1802398061;
LABEL_6:
    *(_DWORD *)__str = v4;
    return __str;
  }
  if (a3 + 1 <= a2)
  {
    *(_DWORD *)(__str + 3) = 7955819;
    int v4 = 1803051373;
    goto LABEL_6;
  }
  snprintf(__str, 0x20uLL, "index %u key", a2 - 1);
  return __str;
}

char *sub_100036BC0(char *__s, size_t __size, uint64_t a3, unsigned int a4)
{
  unsigned int v5 = __size;
  if (a4 == 4)
  {
    snprintf(__s, __size, "0x%08x");
  }
  else if (a4 == 8)
  {
    snprintf(__s, __size, "0x%016llx");
  }
  else
  {
    BOOL v7 = a4 != 0;
    if (a4 && __size)
    {
      unint64_t v8 = 0;
      unint64_t v9 = 0;
      unint64_t v10 = __size;
      unint64_t v11 = a4;
      do
      {
        snprintf(&__s[v9], v5, "%02x ", *(unsigned __int8 *)(a3 + v8++));
        BOOL v7 = v8 < v11;
        if (v8 >= v11) {
          break;
        }
        v9 += 3;
        v5 -= 3;
      }
      while (v9 < v10);
    }
    if (v7) {
      __s[strlen(__s) - 1] = 43;
    }
  }
  return __s;
}

uint64_t sub_100036CCC(uint64_t a1, uint64_t a2, long long *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, unsigned __int16 a10, _WORD *a11, uint64_t a12, char a13)
{
  uint64_t v13 = a4;
  uint64_t v51 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v52 = a4;
  uint64_t v49 = 0;
  BOOL v50 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v48 = 0;
  unsigned __int16 v47 = -21846;
  __int16 v46 = -21846;
  unsigned __int16 v45 = 0;
  __int16 v44 = 0;
  __int16 v16 = *(_WORD *)(a2 + 32);
  *(void *)&long long v17 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v17 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v57 = v17;
  long long v56 = v17;
  long long v55 = v17;
  long long v54 = v17;
  sub_100033F78(a2, a12, 0, (uint64_t *)&v51, &v47, (uint64_t *)&v50, &v46);
  uint64_t v18 = v50;
  uint64_t v19 = *v50;
  uint64_t v53 = *v50;
  if (*(_DWORD *)(a12 + 40))
  {
    uint64_t v53 = *(void *)(a12 + 64) + v19;
    __memcpy_chk();
  }
  uint64_t v20 = v51;
  unsigned int v21 = v47;
  __int16 v22 = v46;
  unsigned int v23 = *(_DWORD *)(a2 + 36);
  if (!v23)
  {
LABEL_22:
    uint64_t v31 = 0;
    goto LABEL_23;
  }
  int v24 = 0;
  int v37 = (v16 & 0x10) << 25;
  int v25 = v13;
  while (1)
  {
    *a11 = *(_WORD *)(a2 + 34) - 1;
    unsigned int v26 = v24 + 1;
    if (v23 <= v24 + 1)
    {
      uint64_t v48 = 0;
      uint64_t v49 = a9;
      unsigned __int16 v45 = a10;
      if (!v24) {
        goto LABEL_17;
      }
    }
    else
    {
      sub_100033F78(a2, a12, v24 + 1, (uint64_t *)&v49, &v45, (uint64_t *)&v48, &v44);
      if (!v24) {
        goto LABEL_17;
      }
    }
    uint64_t v27 = *v18;
    uint64_t v53 = *v18;
    if (*(_DWORD *)(a12 + 40))
    {
      v27 += *(void *)(a12 + 64);
      uint64_t v53 = v27;
      __memcpy_chk();
    }
    unsigned int v28 = sub_1000257B4(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), v27, a6, v37, 3, *(_DWORD *)(a1 + 48), &v52, a5, a13);
    if (!v28)
    {
      uint64_t v13 = v52;
      int v25 = v52;
LABEL_17:
      if (v25)
      {
        long long v42 = *a3;
        uint64_t v43 = *((void *)a3 + 2);
        long long v40 = *(_OWORD *)a5;
        uint64_t v41 = *(void *)(a5 + 16);
        BYTE1(v33) = a13;
        LOBYTE(v33) = 0;
        uint64_t v31 = sub_100035AC8(a1, a2, &v42, v25, &v40, &v53, a6, a7, a8, v20, v21, v49, v45, a11, a12, v33);
        free(v52);
        uint64_t v52 = 0;
        if (v31) {
          return v31;
        }
        uint64_t v13 = 0;
        uint64_t v20 = v49;
      }
      else
      {
        uint64_t v20 = v49;
      }
      goto LABEL_21;
    }
    uint64_t v29 = v49;
    uint64_t v30 = sub_10000AD08(a1, a12, v53, *(void *)(a2 + 16), (unsigned __int16)(*(_WORD *)(a2 + 34) - 1), v20, v21, v49, v45, v28);
    uint64_t v13 = v52;
    if (v30) {
      break;
    }
    if (v52) {
      free(v52);
    }
    uint64_t v13 = 0;
    uint64_t v52 = 0;
    uint64_t v20 = v29;
LABEL_21:
    int v25 = 0;
    unsigned int v21 = v45;
    uint64_t v18 = v48;
    BOOL v50 = v48;
    __int16 v22 = v44;
    unsigned int v23 = *(_DWORD *)(a2 + 36);
    ++v24;
    if (v26 >= v23) {
      goto LABEL_22;
    }
  }
  uint64_t v31 = v30;
LABEL_23:
  uint64_t v51 = v20;
  unsigned __int16 v47 = v21;
  __int16 v46 = v22;
  if (v13) {
    free(v13);
  }
  return v31;
}

uint64_t sub_100037050(uint64_t a1, uint64_t a2, long long *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9, unsigned __int16 a10, _WORD *a11, uint64_t a12, char a13)
{
  BOOL v50 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v51 = a4;
  uint64_t v48 = 0;
  uint64_t v49 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unsigned __int16 v47 = -21846;
  __int16 v46 = -21846;
  unsigned __int16 v45 = 0;
  __int16 v15 = *(_WORD *)(a2 + 32);
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v58[56] = v16;
  *(_OWORD *)&v58[40] = v16;
  *(_OWORD *)&v58[24] = v16;
  *(_OWORD *)&v58[8] = v16;
  uint64_t v57 = 0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  memset(v52, 0, sizeof(v52));
  __int16 v44 = -21846;
  sub_100033F78(a2, a12, 0, (uint64_t *)&v50, &v47, (uint64_t *)&v49, &v46);
  uint64_t v17 = *v49;
  *(void *)__int16 v58 = *v49;
  if (*(_DWORD *)(a12 + 40))
  {
    *(void *)__int16 v58 = *(void *)(a12 + 64) + v17;
    __memcpy_chk();
  }
  unsigned int v18 = *(_DWORD *)(a2 + 36);
  if (!v18)
  {
LABEL_26:
    uint64_t v31 = 0;
    goto LABEL_28;
  }
  unsigned int v19 = 0;
  int v37 = (v15 & 0x10) << 25;
  unsigned int v20 = v47;
  unsigned int v21 = v50;
  while (1)
  {
    *a11 = *(_WORD *)(a2 + 34) - 1;
    unsigned int v22 = v19 + 1;
    if (v18 <= v19 + 1)
    {
      uint64_t v48 = a9;
      uint64_t v49 = 0;
      unsigned __int16 v45 = a10;
    }
    else
    {
      sub_100033F78(a2, a12, v19 + 1, (uint64_t *)&v48, &v45, (uint64_t *)&v49, &v46);
      unsigned int v18 = *(_DWORD *)(a2 + 36);
    }
    if (v19 < v18 - 1)
    {
      uint64_t v23 = *v49;
      *(void *)&long long v53 = *v49;
      if (*(_DWORD *)(a12 + 40))
      {
        v23 += *(void *)(a12 + 64);
        *(void *)&long long v53 = v23;
        __memcpy_chk();
      }
      *((unsigned char *)&v44 + (v19 & 1)) = 1;
      unsigned int v24 = sub_100026B34(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), v23, a6, v37, 3, *(_DWORD *)(a1 + 48), (uint64_t)&v52[11 * (v19 & 1)]);
      if (v24) {
        break;
      }
    }
LABEL_16:
    if (v19
      && *((unsigned char *)&v44 + !(v19 & 1))
      && (unsigned int v29 = sub_100026B70(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), *(uint64_t *)v58, a6, v37, 3, *(_DWORD *)(a1 + 48), (uint64_t)&v52[11 * !(v19 & 1)], (uint64_t **)&v51, a5, a13)) != 0)
    {
      uint64_t v30 = v48;
      uint64_t v28 = sub_10000AD08(a1, a12, *(uint64_t *)v58, *(void *)(a2 + 16), (unsigned __int16)(*(_WORD *)(a2 + 34) - 1), v21, v20, v48, v45, v29);
      if (v28) {
        goto LABEL_27;
      }
      if (v51) {
        free(v51);
      }
      uint64_t v51 = 0;
    }
    else
    {
      uint64_t v30 = v48;
      if (v51)
      {
        long long v42 = *a3;
        uint64_t v43 = *((void *)a3 + 2);
        long long v40 = *(_OWORD *)a5;
        uint64_t v41 = *(void *)(a5 + 16);
        BYTE1(v33) = a13;
        LOBYTE(v33) = 0;
        uint64_t v31 = sub_100035AC8(a1, a2, &v42, v51, &v40, v58, a6, a7, a8, v21, v20, v48, v45, a11, a12, v33);
        free(v51);
        uint64_t v51 = 0;
        if (v31) {
          return v31;
        }
      }
    }
    unsigned int v20 = v45;
    *(_OWORD *)&v58[32] = v55;
    *(_OWORD *)&v58[48] = v56;
    *(void *)&v58[64] = v57;
    *(_OWORD *)__int16 v58 = v53;
    *(_OWORD *)&v58[16] = v54;
    ++v19;
    unsigned int v21 = v30;
    unsigned int v18 = *(_DWORD *)(a2 + 36);
    if (v22 >= v18) {
      goto LABEL_26;
    }
  }
  unsigned int v25 = v24;
  *(void *)&long long v42 = 0xAAAAAAAAAAAAAAAALL;
  LOWORD(v40) = -21846;
  unsigned int v26 = a10;
  uint64_t v27 = a9;
  if (*(_DWORD *)(a2 + 36) > v19 + 2)
  {
    sub_100033F78(a2, a12, v19 + 2, (uint64_t *)&v42, &v40, 0, 0);
    uint64_t v27 = (const void *)v42;
    unsigned int v26 = (unsigned __int16)v40;
  }
  uint64_t v28 = sub_10000AD08(a1, a12, v53, *(void *)(a2 + 16), (unsigned __int16)(*(_WORD *)(a2 + 34) - 1), v48, v45, v27, v26, v25);
  if (!v28)
  {
    *((unsigned char *)&v44 + (v19 & 1)) = 0;
    goto LABEL_16;
  }
LABEL_27:
  uint64_t v31 = v28;
LABEL_28:
  if (v51) {
    free(v51);
  }
  return v31;
}

uint64_t sub_1000374D4(uint64_t a1, uint64_t a2, long long *a3, void *a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, _OWORD *a11, uint64_t a12, unsigned __int8 a13)
{
  uint64_t v99 = a7;
  uint64_t v100 = a8;
  uint64_t v113 = a6;
  size_t v109 = a5;
  uint64_t v110 = a4;
  uint64_t v98 = a3;
  uint64_t v124 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v125 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v123 = 0;
  unsigned __int16 v122 = -21846;
  __int16 v121 = -21846;
  unsigned __int16 v120 = 0;
  __int16 v16 = *(_WORD *)(a2 + 32);
  sub_100033F78(a2, a12, 0, (uint64_t *)&v125, &v122, (uint64_t *)&v124, &v121);
  bzero(v126, 0x580uLL);
  size_t v17 = 112 * *(unsigned int *)(a2 + 36);
  __chkstk_darwin(v18);
  if (v20)
  {
    *(void *)&long long v21 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v21 + 1) = 0xAAAAAAAAAAAAAAAALL;
    size_t v22 = v17;
    uint64_t v23 = &v97[v17 / 0xFFFFFFFFFFFFFFF8];
    do
    {
      v23[5] = v21;
      v23[6] = v21;
      v23[3] = v21;
      void v23[4] = v21;
      v23[1] = v21;
      v23[2] = v21;
      *uint64_t v23 = v21;
      v23 += 7;
      v22 -= 112;
    }
    while (v22);
  }
  v97[1] = v19;
  int v24 = v16 & 0x10;
  uint64_t v25 = *(unsigned int *)(a2 + 36);
  uint64_t v26 = __chkstk_darwin(&v97[v17 / 0xFFFFFFFFFFFFFFF8]);
  uint64_t v28 = (void *)((char *)v97 - v27);
  uint64_t v29 = 4 * v25;
  uint64_t v111 = (void *)v26;
  if (v25)
  {
    uint64_t v30 = memset((char *)v97 - v27, 170, 8 * v25);
    __chkstk_darwin(v30);
    uint64_t v106 = (char *)v97 - ((v29 + 15) & 0x7FFFFFFF0);
    memset(v106, 170, 4 * v25);
    uint64_t v31 = v111;
  }
  else
  {
    uint64_t v31 = (void *)__chkstk_darwin(v26);
    uint64_t v106 = (char *)v97 - ((v29 + 15) & 0x7FFFFFFF0);
  }
  int v112 = v24 << 25;
  bzero(v31, v17);
  uint64_t v32 = (int *)v111;
  int v33 = v124;
  uint64_t v34 = *v124;
  v111[1] = *v124;
  if (*(_DWORD *)(a12 + 40))
  {
    *((void *)v32 + 1) = *(void *)(a12 + 64) + v34;
    memcpy(v32 + 4, v33 + 1, *(unsigned int *)(a12 + 44));
    uint64_t v32 = (int *)v111;
  }
  int v35 = a10;
  uint64_t v105 = a9;
  uint64_t v36 = v109;
  int v37 = v110;
  *((_OWORD *)v32 + 5) = *v109;
  *((void *)v32 + 12) = *((void *)v36 + 2);
  *((unsigned char *)v32 + 104) = v37 != 0;
  bzero(v28, 8 * v25);
  *uint64_t v28 = v37;
  uint64_t v110 = v28;
  if (v25 >= 2)
  {
    LODWORD(v109) = a10;
    uint64_t v38 = v32 + 28;
    uint64_t v39 = 1;
    do
    {
      sub_100033F78(a2, a12, v39, (uint64_t *)&v125, &v122, (uint64_t *)&v124, &v121);
      *uint64_t v38 = v39;
      *((unsigned char *)v38 + 104) = 1;
      long long v40 = v124;
      uint64_t v41 = *v124;
      *((void *)v38 + 1) = *v124;
      if (*(_DWORD *)(a12 + 40))
      {
        v41 += *(void *)(a12 + 64);
        *((void *)v38 + 1) = v41;
        memcpy(v38 + 4, v40 + 1, *(unsigned int *)(a12 + 44));
      }
      unsigned int v42 = sub_1000250DC(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), v41, v113, v112, 3, *(_DWORD *)(a1 + 48), (uint64_t)(v38 + 20));
      unint64_t v43 = v39 + 1;
      if (v42)
      {
        unsigned int v44 = v42;
        if (v43 >= *(unsigned int *)(a2 + 36))
        {
          unsigned __int16 v45 = (const void *)v105;
          uint64_t v123 = (const void *)v105;
          unsigned __int16 v120 = a10;
          unsigned int v46 = (unsigned __int16)a10;
        }
        else
        {
          sub_100033F78(a2, a12, v39 + 1, (uint64_t *)&v123, &v120, 0, 0);
          unsigned __int16 v45 = v123;
          unsigned int v46 = v120;
        }
        uint64_t v47 = sub_10000AD08(a1, a12, *((void *)v38 + 1), *(void *)(a2 + 16), (unsigned __int16)(*(_WORD *)(a2 + 34) - 1), v125, v122, v45, v46, v44);
        if (v47)
        {
LABEL_63:
          uint64_t v74 = v47;
          goto LABEL_64;
        }
        *((unsigned char *)v38 + 104) = 0;
        *((void *)v38 + 10) = 0x7FFFFFFFFFFFFFFFLL;
      }
      v38 += 28;
      ++v39;
    }
    while (v43 < *(unsigned int *)(a2 + 36));
    LODWORD(v25) = *(_DWORD *)(a2 + 36);
    uint64_t v28 = v110;
    uint64_t v32 = (int *)v111;
    int v35 = (int)v109;
  }
  qsort(v32 + 28, (v25 - 1), 0x70uLL, (int (__cdecl *)(const void *, const void *))sub_100037D88);
  unint64_t v48 = *(unsigned int *)(a2 + 36);
  if (!v48) {
    goto LABEL_32;
  }
  uint64_t v49 = 0;
  BOOL v50 = v32;
  uint64_t v51 = v106;
  do
  {
    uint64_t v52 = *v50;
    v50 += 28;
    *(_DWORD *)&v51[4 * v52] = v49++;
  }
  while (v48 != v49);
  if (v48 < 2)
  {
LABEL_32:
    uint64_t v60 = 1;
LABEL_33:
    sub_100033F78(a2, a12, 0, (uint64_t *)&v125, &v122, 0, 0);
    unsigned int v61 = *(_DWORD *)(a2 + 36);
    if (!v61)
    {
      uint64_t v74 = 0;
      goto LABEL_68;
    }
    signed int v62 = 0;
    size_t v109 = a11;
    unsigned int v101 = (unsigned __int16)v35;
    int v102 = a13;
    uint64_t v63 = 1;
    unsigned int v108 = v122;
    uint64_t v107 = (uint64_t)v125;
    uint64_t v64 = v111;
    uint64_t v65 = v60;
    uint64_t v104 = a12;
    do
    {
      int v66 = *(_DWORD *)&v106[4 * v62];
      uint64_t v67 = v110[v62];
      if (v67 || !LOBYTE(v64[14 * v66 + 13]))
      {
        uint64_t v68 = v63;
        signed int v69 = v62 + 1;
        if (v61 <= v62 + 1)
        {
          uint64_t v70 = v105;
          uint64_t v123 = (const void *)v105;
          unsigned int v71 = v101;
          unsigned __int16 v120 = v101;
        }
        else
        {
          sub_100033F78(a2, v104, v62 + 1, (uint64_t *)&v123, &v120, 0, 0);
          uint64_t v64 = v111;
          uint64_t v70 = (uint64_t)v123;
          unsigned int v71 = v120;
        }
        *(_WORD *)size_t v109 = *(_WORD *)(a2 + 34) - 1;
        if (LOBYTE(v64[14 * v66 + 13]))
        {
          uint64_t v72 = v62;
          uint64_t v73 = &v64[14 * v66];
          long long v118 = *v98;
          uint64_t v119 = *((void *)v98 + 2);
          long long v116 = *((_OWORD *)v73 + 5);
          uint64_t v117 = v73[12];
          BYTE1(v96) = v102;
          LOBYTE(v96) = 0;
          uint64_t v74 = sub_100035AC8(a1, a2, &v118, v67, &v116, v73 + 1, v113, v99, v100, v107, v108, v70, v71, v109, v104, v96);
          uint64_t v28 = v110;
          free((void *)v110[v72]);
          v28[v72] = 0;
          if (v74) {
            goto LABEL_68;
          }
          uint64_t v70 = (uint64_t)v123;
          unsigned int v71 = v120;
          uint64_t v64 = v111;
        }
        unsigned int v61 = *(_DWORD *)(a2 + 36);
        unsigned int v108 = v71;
        uint64_t v107 = v70;
        signed int v62 = v69;
        uint64_t v63 = v68;
      }
      if (v63 < v61)
      {
        uint64_t v103 = v65;
        uint64_t v75 = &v64[14 * (int)v63];
        int v77 = *((unsigned __int8 *)v75 + 104);
        uint64_t v76 = v75 + 13;
        if (v77)
        {
          uint64_t v78 = SLODWORD(v64[14 * (int)v63]);
          uint64_t v79 = &v64[14 * (int)v63];
          uint64_t v82 = v79[1];
          uint64_t v81 = v79 + 1;
          uint64_t v80 = v82;
          int v83 = (v63 - 1) & 7;
          if (1 - (int)v63 >= 0) {
            int v83 = -((1 - v63) & 7);
          }
          int v84 = v63;
          unsigned int v85 = sub_100026B70(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), v80, v113, v112, 3, *(_DWORD *)(a1 + 48), (uint64_t)&v126[11 * v83], (uint64_t **)&v110[v78], (uint64_t)(v81 + 9), v102);
          LODWORD(v63) = v84;
          uint64_t v64 = v111;
          if (v85)
          {
            unsigned int v86 = v85;
            *(void *)&long long v118 = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v116 = 0xAAAAAAAAAAAAAAAALL;
            unsigned __int16 v115 = -21846;
            unsigned __int16 v114 = -21846;
            uint64_t v87 = v104;
            sub_100033F78(a2, v104, v78, (uint64_t *)&v118, &v115, 0, 0);
            unsigned int v88 = v101;
            unsigned __int16 v89 = (const void *)v105;
            if (*(_DWORD *)(a2 + 36) > (v78 + 1))
            {
              sub_100033F78(a2, v87, v78 + 1, (uint64_t *)&v116, &v114, 0, 0);
              unsigned __int16 v89 = (const void *)v116;
              unsigned int v88 = v114;
            }
            uint64_t v47 = sub_10000AD08(a1, v87, *v81, *(void *)(a2 + 16), (unsigned __int16)(*(_WORD *)(a2 + 34) - 1), (const void *)v118, v115, v89, v88, v86);
            if (v47) {
              goto LABEL_63;
            }
            unsigned char *v76 = 0;
            uint64_t v64 = v111;
            LODWORD(v63) = v84;
          }
        }
        uint64_t v63 = (v63 + 1);
        unsigned int v61 = *(_DWORD *)(a2 + 36);
        uint64_t v65 = v103;
      }
      if (v65 < v61)
      {
        if (LOBYTE(v64[14 * (int)v65 + 13]))
        {
          uint64_t v90 = v63;
          int v91 = (v65 - 1) & 7;
          if (1 - (int)v65 >= 0) {
            int v91 = -((1 - v65) & 7);
          }
          uint64_t v47 = sub_100026B34(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), v64[14 * (int)v65 + 1], v113, v112, 3, *(_DWORD *)(a1 + 48), (uint64_t)&v126[11 * v91]);
          if (v47) {
            goto LABEL_63;
          }
          unsigned int v61 = *(_DWORD *)(a2 + 36);
          uint64_t v64 = v111;
          uint64_t v63 = v90;
        }
        uint64_t v65 = (v65 + 1);
      }
    }
    while (v62 < v61);
    uint64_t v74 = 0;
LABEL_64:
    uint64_t v28 = v110;
    goto LABEL_68;
  }
  LODWORD(v109) = v35;
  long long v53 = (unsigned __int8 *)(v32 + 54);
  long long v54 = v126;
  unint64_t v55 = 1;
  long long v56 = (unsigned __int8 *)(v32 + 54);
  while (1)
  {
    int v57 = *v56;
    v56 += 112;
    if (!v57) {
      goto LABEL_29;
    }
    uint64_t v58 = sub_100026B34(*(uint64_t **)a1, *(void *)(a1 + 8), *(_DWORD *)(a1 + 40), *((void *)v53 - 12), v113, v112, 3, *(_DWORD *)(a1 + 48), (uint64_t)v54);
    if (v58) {
      break;
    }
    unint64_t v48 = *(unsigned int *)(a2 + 36);
LABEL_29:
    unint64_t v59 = v55 + 1;
    if (v55 <= 7)
    {
      v54 += 11;
      long long v53 = v56;
      ++v55;
      if (v59 < v48) {
        continue;
      }
    }
    uint64_t v60 = v59;
    LOWORD(v35) = (_WORD)v109;
    goto LABEL_33;
  }
  uint64_t v74 = v58;
LABEL_68:
  unint64_t v92 = *(unsigned int *)(a2 + 36);
  if (v92)
  {
    for (unint64_t i = 0; i < v92; ++i)
    {
      long long v94 = (void *)v28[i];
      if (v94)
      {
        free(v94);
        unint64_t v92 = *(unsigned int *)(a2 + 36);
      }
    }
  }
  return v74;
}

uint64_t sub_100037D88(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t sub_100037DA0(unsigned __int8 *a1, uint64_t a2)
{
  int v23 = (int)a1;
  if (a2 >= 1)
  {
    int v2 = 0;
    uint64_t v3 = a1;
    unint64_t i = (unint64_t)&a1[a2];
    BOOL v5 = a1 + 16;
    int v6 = a1 + 17;
    unint64_t v22 = (unint64_t)&a1[a2];
    while (1)
    {
      unint64_t v7 = (unint64_t)&v5[-i];
      if ((unint64_t)v5 < i) {
        unint64_t v7 = 0;
      }
      if (v7 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v7;
      }
      if ((unint64_t)v5 >= i) {
        int v9 = i;
      }
      else {
        int v9 = (int)v5;
      }
      unint64_t v10 = v3 + 16;
      if (i >= (unint64_t)(v3 + 16)) {
        unint64_t v11 = v3 + 16;
      }
      else {
        unint64_t v11 = (unsigned __int8 *)i;
      }
      if (i <= (unint64_t)v10 || !v2) {
        goto LABEL_21;
      }
      uint64_t v12 = v3;
      if (v3 < v11) {
        break;
      }
LABEL_19:
      if (v2 == 1)
      {
        fwrite(". . .\n", 6uLL, 1uLL, __stderrp);
        int v2 = 2;
      }
LABEL_46:
      v5 += 16;
      v6 += 16;
      uint64_t v3 = v10;
      if (i <= (unint64_t)v10) {
        goto LABEL_47;
      }
    }
    while (!*v12)
    {
      if (++v12 >= v11) {
        goto LABEL_19;
      }
    }
LABEL_21:
    int v24 = v6;
    fprintf(__stderrp, "%04x:  ", v3 - v23);
    if (v3 >= v11)
    {
      int v2 = 1;
    }
    else
    {
      uint64_t v13 = 0;
      int v2 = 1;
      do
      {
        fprintf(__stderrp, "%02x", v3[v13]);
        if (((v13 + 1) & 1) == 0) {
          fputc(32, __stderrp);
        }
        if (v3[v13]) {
          int v2 = 0;
        }
        ++v13;
      }
      while (&v3[v13] < v11);
    }
    if (((v10 - v11) & 0x80000000) == 0)
    {
      int v14 = -v9;
      int v15 = v24;
      do
      {
        fwrite("  ", 2uLL, 1uLL, __stderrp);
        if (((_BYTE)v14 + (_BYTE)v15 - 1)) {
          fputc(32, __stderrp);
        }
        --v15;
      }
      while (v14 + v15 > 0);
    }
    fwrite("    |", 5uLL, 1uLL, __stderrp);
    for (unint64_t i = v22; v3 < v11; ++v3)
    {
      __int16 v16 = __stderrp;
      int v17 = *v3;
      if ((char)*v3 < 0) {
        __uint32_t v18 = __maskrune(*v3, 0x500uLL);
      }
      else {
        __uint32_t v18 = _DefaultRuneLocale.__runetype[*v3] & 0x500;
      }
      if (v18) {
        int v19 = v17;
      }
      else {
        int v19 = 46;
      }
      fputc(v19, v16);
    }
    if (v22 < (unint64_t)v10)
    {
      do
      {
        fputc(32, __stderrp);
        --v8;
      }
      while (v8);
    }
    fwrite("|\n", 2uLL, 1uLL, __stderrp);
    int v6 = v24;
    goto LABEL_46;
  }
LABEL_47:
  int v20 = __stderrp;

  return fputc(10, v20);
}

uint64_t sub_100038040(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, uint64_t a12, uint64_t a13)
{
  uint64_t result = 22;
  if (a4 <= 0x7FFFFFF)
  {
    if (a4 != 0x80000000 && a4) {
      return result;
    }
LABEL_7:
    uint64_t result = 0;
    *(void *)a1 = a2;
    *(void *)(a1 + 8) = a3;
    *(_DWORD *)(a1 + 40) = a4;
    *(_DWORD *)(a1 + 44) = a5;
    *(_DWORD *)(a1 + 48) = a6;
    *(_DWORD *)(a1 + 52) = a7;
    *(_DWORD *)(a1 + 24) = a8;
    *(_DWORD *)(a1 + 28) = a9;
    *(_DWORD *)(a1 + 32) = a10;
    *(_DWORD *)(a1 + 36) = a11;
    *(void *)(a1 + 56) = a12;
    *(void *)(a1 + --*(_DWORD *)(result + 16) = a13;
    return result;
  }
  if (a4 == 0x40000000 || a4 == 0x8000000) {
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_1000380B0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int *a5, unsigned int a6, void *a7, unsigned int *a8)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_1000380EC(a1, a2, a3, a4, a5, a6, a7, a8, 0, 0);
  }
  else {
    return 22;
  }
}

uint64_t sub_1000380EC(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int *a5, unsigned int a6, void *a7, unsigned int *a8, void **a9, unsigned __int16 a10)
{
  uint64_t v12 = a3;
  uint64_t v13 = a2;
  int v15 = a9;
  int v63 = -1431655766;
  int v64 = -1431655766;
  int v62 = 0;
  unsigned int v50 = a3 - 1;
  BOOL v52 = (a3 - 1) < 2;
  BOOL v53 = a3 == -2;
  long long v56 = 0u;
  long long v57 = 0u;
  uint64_t v54 = 0;
  long long __src = 0;
  uint64_t v16 = *(void *)(a1 + 56);
  if (a9) {
    *a9 = 0;
  }
  uint64_t v17 = sub_10002E8D0(a1, &__src, *(unsigned int *)(a1 + 40), a2, v16);
  if (v17)
  {
LABEL_46:
    if (v15)
    {
      free(*v15);
      *int v15 = 0;
    }
    goto LABEL_48;
  }
  unsigned __int16 v51 = 0;
  unsigned __int16 v18 = -4081;
  while (1)
  {
    int v19 = v15;
    uint64_t v20 = v13;
    uint64_t v21 = v12;
    unint64_t v22 = a4;
    int v23 = a5;
    int v24 = (unsigned __int16 *)__src;
    uint64_t v25 = *(void *)(a1 + 56);
    uint64_t v26 = sub_10003A34C((unsigned int *)a1, (uint64_t)__src, v16 == v25, v18);
    if (v26)
    {
      uint64_t v17 = v26;
      int v15 = v19;
      goto LABEL_46;
    }
    uint64_t v27 = v16;
    unsigned int v28 = v24[17];
    if (v28 < a10) {
      return 22;
    }
    BOOL v46 = v27 == v25;
    a5 = v23;
    a4 = v22;
    uint64_t v12 = v21;
    uint64_t v13 = v20;
    int v15 = v19;
    if (v46)
    {
      uint64_t v29 = *(unsigned int *)(a1 + 24);
      long long v56 = *(_OWORD *)((char *)v24 + v29 - 40);
      *(void *)&long long v57 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000;
      *((void *)&v57 + 1) = v27;
      uint64_t v30 = sub_10003A4E8((uint64_t)v19, v28 - a10 + 1, v29);
      if (v30) {
        goto LABEL_45;
      }
      int v24 = (unsigned __int16 *)__src;
    }
    if (v19)
    {
      uint64_t v31 = (void *)*((void *)*v19 + 2 * (int)(v28 - a10) + 1);
      if (v31) {
        memcpy(v31, v24, *(unsigned int *)(a1 + 24));
      }
    }
    while (v28 > a10)
    {
      uint64_t v32 = sub_10003A59C(a1, (uint64_t)&v56, (uint64_t)__src, (uint64_t)a4, *a5, &v63, &v64);
      uint64_t v17 = v32;
      signed int v33 = v63;
      if (v15) {
        *((_DWORD *)*v15 + 4 * (int)(v28 - a10) + 4) = v63;
      }
      if (v32) {
        goto LABEL_46;
      }
      uint64_t v34 = __src;
      if (v53 && v33 > 0 || v52 && v33 < *((_DWORD *)__src + 9) - 1)
      {
        uint64_t v30 = sub_10003A5E0((uint64_t)&v56, (uint64_t)__src, v52 - v53 + v33, &v54);
        if (v30) {
          goto LABEL_45;
        }
        unsigned __int16 v51 = v28 - 1;
        uint64_t v34 = __src;
      }
      uint64_t v30 = sub_10003A69C((unsigned int *)a1, v13, &v56, (uint64_t)v34, v33, 0, (uint64_t *)&__src);
      if (v30) {
        goto LABEL_45;
      }
      unsigned int v28 = *((unsigned __int16 *)__src + 17);
      if (v15)
      {
        int v35 = (void *)*((void *)*v15 + 2 * (int)(v28 - a10) + 1);
        if (v35) {
          memcpy(v35, __src, *(unsigned int *)(a1 + 24));
        }
      }
    }
    uint64_t v30 = sub_10003A760(a1, (uint64_t)&v56, (uint64_t)__src, (uint64_t)a4, *a5, &v63, &v64);
    if (v30)
    {
LABEL_45:
      uint64_t v17 = v30;
      goto LABEL_46;
    }
    int v36 = v64;
    if (v64)
    {
      if (v12 == -2)
      {
        int v37 = v63--;
        int v36 = v37 > 0;
      }
      else
      {
        if (v12 != 2) {
          goto LABEL_55;
        }
        int v36 = ++v63 < *((_DWORD *)__src + 9);
      }
      int v64 = v36;
    }
    if (!v12 || v36) {
      break;
    }
    if (v12 >= 0xFFFFFFFE)
    {
      unsigned int v38 = v63 - 1;
      if (v63 >= 1) {
        goto LABEL_58;
      }
    }
    if (v50 <= 1 && v63 < *((_DWORD *)__src + 9))
    {
      unsigned int v38 = v63;
      goto LABEL_58;
    }
    uint64_t v16 = v54;
    if (!v54) {
      goto LABEL_56;
    }
    uint64_t v54 = 0;
    uint64_t v17 = sub_10002E8D0(a1, &__src, *(unsigned int *)(a1 + 40), v13, v16);
    BOOL v52 = 0;
    BOOL v53 = 0;
    unsigned __int16 v18 = v51;
    if (v17) {
      goto LABEL_46;
    }
  }
  if (!v36)
  {
LABEL_56:
    uint64_t v17 = 2;
    goto LABEL_46;
  }
LABEL_55:
  unsigned int v38 = v63;
LABEL_58:
  if (v15) {
    *((_DWORD *)*v15 + 4 * (int)(v28 - a10) + 4) = v38;
  }
  unsigned int v61 = (void *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v59 = -1431655766;
  uint64_t v40 = sub_10003A888((uint64_t)&v56, (uint64_t)__src, v38, &v61, &v59);
  uint64_t v17 = v40;
  if (!v12 || v40)
  {
    if (v40) {
      goto LABEL_46;
    }
  }
  else
  {
    uint64_t v41 = *(void *)(a1 + 8);
    if (v41) {
      uint64_t v42 = *(void *)(v41 + 40);
    }
    else {
      uint64_t v42 = 0;
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t, void *, void, void *, void, int *))(a1 + 16))(v42, v61, v59, a4, *a5, &v62);
    if (v17) {
      goto LABEL_46;
    }
    if (v12 == -2 && (v62 & 0x80000000) == 0)
    {
      uint64_t v17 = 92;
      goto LABEL_46;
    }
    BOOL v43 = v12 == 1;
    if (v62 >= 0) {
      BOOL v43 = 0;
    }
    BOOL v44 = v12 == 2 && v62 < 1;
    BOOL v45 = v44;
    BOOL v46 = v62 > 0 && v12 == -1;
    uint64_t v17 = 92;
    if (v46 || v43 || v45) {
      goto LABEL_46;
    }
  }
  *(void *)uint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v58 = -1431655766;
  uint64_t v17 = sub_10003A910((uint64_t)&v56, (uint64_t)__src, v38, v60, &v58);
  if (v17) {
    goto LABEL_46;
  }
  *a5 = a6;
  uint64_t v17 = sub_10003AA08(v61, v59, *(const void **)v60, v58, a4, a5, a7, a8);
  if (v17) {
    goto LABEL_46;
  }
LABEL_48:
  if (__src && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(__src);
  }
  return v17;
}

uint64_t sub_100038610(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_100038630(a1, a2, a3, a4, a5, a6, 0, 0);
  }
  else {
    return 22;
  }
}

uint64_t sub_100038630(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6, void **a7, unsigned int a8)
{
  long long __src = 0;
  if (a7) {
    *a7 = 0;
  }
  int v37 = (long long *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v15 = sub_10003AC58(a1, a2, 0, &__src, &v37);
  if (v15) {
    goto LABEL_4;
  }
  if ((*((_WORD *)__src + 16) & 2) != 0 && !*((_DWORD *)__src + 9))
  {
    uint64_t v15 = 2;
    goto LABEL_4;
  }
  unsigned int v16 = *((unsigned __int16 *)__src + 17);
  if (v16 < a8) {
    return 22;
  }
  long long v34 = *v37;
  uint64_t v18 = *(void *)(a1 + 56);
  unint64_t v35 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000;
  uint64_t v36 = v18;
  uint64_t v15 = sub_10003A4E8((uint64_t)a7, v16 - a8 + 1, *(_DWORD *)(a1 + 24));
  if (v15) {
    goto LABEL_4;
  }
  if (a7)
  {
    int v19 = (void *)*((void *)*a7 + 2 * (int)(v16 - a8) + 1);
    if (v19) {
      memcpy(v19, __src, *(unsigned int *)(a1 + 24));
    }
  }
  if (v16 > a8)
  {
    while (1)
    {
      uint64_t v20 = sub_10003A69C((unsigned int *)a1, a2, &v34, (uint64_t)__src, 0, 0, (uint64_t *)&__src);
      if (v20) {
        break;
      }
      unsigned int v21 = *((unsigned __int16 *)__src + 17);
      if (a7)
      {
        unint64_t v22 = (void *)*((void *)*a7 + 2 * (int)(v21 - a8) + 1);
        if (v22) {
          memcpy(v22, __src, *(unsigned int *)(a1 + 24));
        }
      }
      if (v21 <= a8) {
        goto LABEL_24;
      }
    }
    uint64_t v15 = v20;
    goto LABEL_4;
  }
LABEL_24:
  if (!*((_DWORD *)__src + 9))
  {
    uint64_t v15 = 22;
    goto LABEL_4;
  }
  int v23 = (char *)__src + 56;
  unsigned int v24 = *((unsigned __int16 *)__src + 28);
  unsigned int v25 = *((unsigned __int16 *)__src + 22);
  BOOL v26 = v25 >= v24;
  unsigned int v27 = v25 - v24;
  if (v27 == 0
    || !v26
    || ((*((_WORD *)__src + 16) & 4) != 0 ? (unsigned __int16 v28 = WORD4(v34)) : (unsigned __int16 v28 = *((_WORD *)__src + 29)), v27 < v28))
  {
    uint64_t v15 = 92;
    goto LABEL_4;
  }
  uint64_t v29 = *((unsigned __int16 *)__src + 21);
  *(void *)uint64_t v32 = 0xAAAAAAAAAAAAAAAALL;
  int v31 = -1431655766;
  uint64_t v15 = sub_10003A910((uint64_t)&v34, (uint64_t)__src, 0, v32, (unsigned int *)&v31);
  if (v15 || (uint64_t v15 = sub_10003AA08(&v23[v29 + v24], v28, *(const void **)v32, v31, a3, a4, a5, a6), v15))
  {
LABEL_4:
    if (a7)
    {
      free(*a7);
      *a7 = 0;
    }
  }
  if (__src && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(__src);
  }
  return v15;
}

uint64_t sub_10003889C(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int a5, unsigned int a6, void *a7, int a8)
{
  if (a5 > a6) {
    return 34;
  }
  *(void *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = a3;
  *(_DWORD *)(a1 + 64) = a6;
  *(_DWORD *)(a1 + 68) = a8;
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = sub_100038958;
  *(void *)(a1 + --*(_DWORD *)(result + 16) = a4;
  *(void *)(a1 + 24) = a7;
  *(_DWORD *)(a1 + 32) = a5;
  *(unsigned char *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 36) = a8;
  if (*(_DWORD *)(a2 + 44) == 2)
  {
    uint64_t result = sub_1000380EC(a2, a3, 1, a4, (unsigned int *)(a1 + 32), a6, a7, (unsigned int *)(a1 + 36), 0, 0);
    if (result)
    {
      *(unsigned char *)(a1 + 40) = 1;
      if (result == 2) {
        return 0;
      }
      else {
        return result;
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 40) = 1;
    return 22;
  }
  return result;
}

uint64_t sub_100038958(uint64_t a1)
{
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 68);
  int v2 = (unsigned int *)(a1 + 36);
  uint64_t v3 = *(void *)(a1 + 48);
  if (*(_DWORD *)(v3 + 44) == 2)
  {
    uint64_t result = sub_1000380EC(v3, *(void *)(a1 + 56), 2, *(void **)(a1 + 16), (unsigned int *)(a1 + 32), *(_DWORD *)(a1 + 64), *(void **)(a1 + 24), v2, 0, 0);
    if (result)
    {
      *(unsigned char *)(a1 + 40) = 1;
      if (result == 2) {
        return 0;
      }
      else {
        return result;
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + 40) = 1;
    return 22;
  }
  return result;
}

uint64_t sub_1000389E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, unsigned int a6, unsigned int a7)
{
  size_t v14 = *(unsigned int *)(a2 + 24);
  uint64_t v15 = ((uint64_t (*)(void))__chkstk_darwin)();
  uint64_t v16 = (v14 + 15) & 0x1FFFFFFF0;
  uint64_t v17 = (char *)&v24 - v16;
  if (v14)
  {
    uint64_t v18 = memset((char *)&v24 - v16, 170, v14);
    __chkstk_darwin(v18);
    int v19 = (char *)&v24 - v16;
    memset(v19, 170, v14);
  }
  else
  {
    __chkstk_darwin(v15);
    int v19 = (char *)&v24 - v16;
  }
  unsigned int v24 = v14;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + --*(_DWORD *)(result + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(void *)a1 = sub_100038C88;
  *(void *)(a1 + 8) = sub_100038CB4;
  *(unsigned char *)(a1 + 40) = 1;
  if (*(_DWORD *)(a2 + 44) != 2) {
    return 22;
  }
  if (v14 < a6) {
    return 34;
  }
  if (a5)
  {
    memcpy(v17, a5, a6);
    unsigned int v25 = a6;
    uint64_t v20 = sub_1000380EC(a2, a3, a4, v17, &v25, v14, v19, &v24, (void **)(a1 + 72), a7);
    if (v20 != 2) {
      goto LABEL_15;
    }
    if (a4 < 0xFFFFFFFE) {
      return 0;
    }
    uint64_t v22 = sub_1000380EC(a2, a3, 1, v17, &v25, v14, v19, &v24, (void **)(a1 + 72), a7);
  }
  else
  {
    unsigned int v25 = v14;
    uint64_t v22 = sub_100038630(a2, a3, v17, &v25, v19, &v24, (void **)(a1 + 72), a7);
  }
  uint64_t v20 = v22;
LABEL_15:
  if (v20 == 2) {
    return 0;
  }
  if (v20
    || (uint64_t v23 = *(void *)(a1 + 72) + 16 * **(int **)(a1 + 72),
        *(void *)(a1 + 48) = a2,
        *(void *)(a1 + 56) = a3,
        *(void *)(a1 + 64) = *(void *)(v23 - 8) + *(unsigned int *)(a2 + 24) - 40,
        uint64_t v20 = sub_100038CF8(a1),
        v20))
  {
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 40) = 0;
  }
  return v20;
}

void sub_100038C88(uint64_t a1)
{
  *(void *)(a1 + 72) = 0;
}

uint64_t sub_100038CB4(uint64_t a1)
{
  if (sub_10003AD20(a1, 0) || sub_100038CF8(a1)) {
    *(unsigned char *)(a1 + 40) = 1;
  }
  return 0;
}

uint64_t sub_100038CF8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void *)(a1 + 72);
  long long v7 = *(_OWORD *)*(void *)(a1 + 64);
  int v4 = *(_DWORD *)(v2 + 36);
  uint64_t v5 = *(void *)(v2 + 56);
  int v9 = -1431655766;
  uint64_t v10 = v5;
  int v8 = v4;
  uint64_t result = sub_10003A888((uint64_t)&v7, *(void *)(v3 + 8), *(_DWORD *)(v3 + 16), (void *)(a1 + 16), (_DWORD *)(a1 + 32));
  if (!result) {
    return sub_10003A910((uint64_t)&v7, *(void *)(v3 + 8), *(_DWORD *)(v3 + 16), (void *)(a1 + 24), (unsigned int *)(a1 + 36));
  }
  return result;
}

uint64_t sub_100038D78(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, unsigned int a5)
{
  return sub_1000389E0(a1, a2, a3, 1, a4, a5, 0);
}

BOOL sub_100038D8C(uint64_t a1, unsigned __int16 *a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  if (a4)
  {
    unsigned __int16 v12 = a2[16];
    uint64_t v13 = &a2[2 * a3 + 28];
    if ((v12 & 4) == 0) {
      uint64_t v13 = &a2[4 * a3 + 28];
    }
    unsigned int v44 = *v13;
    if ((v12 & 4) != 0) {
      int v14 = *(_DWORD *)(a1 + 8);
    }
    else {
      LOWORD(v14) = a2[4 * a3 + 29];
    }
    if ((*(_DWORD *)a1 & 0x40) != 0) {
      unsigned int v15 = a5;
    }
    else {
      unsigned int v15 = (a5 + 7) & 0xFFFFFFF8;
    }
    unsigned int v17 = (unsigned __int16)v14;
    int v18 = ((unsigned __int16)v14 + 7) & 0x1FFF8;
    if ((*(_DWORD *)a1 & 0x40) != 0) {
      unsigned int v16 = v17;
    }
    else {
      unsigned int v16 = v18;
    }
  }
  else
  {
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    unsigned int v17 = 0;
    unsigned int v44 = 0xFFFF;
  }
  if (a6)
  {
    if ((a2[16] & 4) != 0) {
      int v19 = &a2[2 * a3 + 29];
    }
    else {
      int v19 = &a2[4 * a3 + 30];
    }
    unsigned int v20 = *v19;
    unsigned int v21 = sub_100039198(a1, (uint64_t)a2, a3);
    unsigned int v22 = v21;
    if (a7 == 65534)
    {
      unsigned int v23 = 0;
    }
    else
    {
      unsigned int v23 = (a7 + 7) & 0xFFFFFFF8;
      if ((*(unsigned char *)a1 & 0x40) != 0) {
        unsigned int v23 = a7;
      }
    }
    v15 += v23;
    if (v21 == 65534)
    {
      int v24 = 0;
    }
    else
    {
      int v24 = (v21 + 7) & 0x1FFF8;
      if ((*(unsigned char *)a1 & 0x40) != 0) {
        int v24 = v21;
      }
    }
    v16 += v24;
  }
  else
  {
    unsigned int v22 = 0;
    unsigned int v20 = 0xFFFF;
  }
  unsigned int v25 = sub_100039210((unsigned char *)a1, a2, 0) + v16;
  if (v15 <= v25)
  {
    unsigned int __n = a7;
    if (a4)
    {
      sub_100039280(a1, a2, 0, v44, v17);
      unsigned int v26 = a5;
      unsigned int v27 = sub_100039390((int *)a1, a2, 0, a5);
      if (v27)
      {
        unsigned int v26 = 0;
      }
      else if ((*(unsigned char *)a1 & 0x40) == 0)
      {
        unsigned int v26 = (a5 + 7) & 0xFFFFFFF8;
      }
    }
    else
    {
      unsigned int v26 = 0;
      unsigned int v27 = 0;
    }
    if (a6)
    {
      sub_100039280(a1, a2, 1, v20, v22);
      unsigned __int16 v28 = sub_100039390((int *)a1, a2, 1, __n);
      if (!v28)
      {
        if (__n == 65534)
        {
          unsigned int v31 = 0;
        }
        else
        {
          unsigned int v31 = (__n + 7) & 0xFFFFFFF8;
          if ((*(unsigned char *)a1 & 0x40) != 0) {
            unsigned int v31 = __n;
          }
        }
        uint64_t v30 = a6;
        uint64_t v29 = 0;
        v26 += v31;
LABEL_45:
        if (v26 <= a2[23])
        {
LABEL_56:
          if (a4)
          {
            unsigned int v34 = sub_100039944((int *)a1, a2, 0, a5, v27);
            __int16 v35 = v34;
            uint64_t v36 = a2 + 28;
            memcpy((char *)a2 + a2[21] + v34 + 56, a4, a5);
            if ((a2[16] & 4) != 0)
            {
              v36[2 * a3] = v35;
            }
            else
            {
              int v37 = &v36[4 * a3];
              *int v37 = v35;
              v37[1] = a5;
            }
            uint64_t v30 = a6;
          }
          if (v30)
          {
            unsigned int v38 = sub_100039944((int *)a1, a2, 1, __n, v29);
            __int16 v39 = v38;
            if (v38 <= 0xFFFD)
            {
              uint64_t v40 = -40;
              if ((a2[16] & 1) == 0) {
                uint64_t v40 = 0;
              }
              memcpy((char *)a2 + *(unsigned int *)(a1 + 4) + v40 - v38, a6, __n);
            }
            uint64_t v41 = a2 + 28;
            if ((a2[16] & 4) != 0)
            {
              v41[2 * a3 + 1] = v39;
            }
            else
            {
              uint64_t v42 = &v41[4 * a3];
              v42[2] = v39;
              v42[3] = __n;
            }
          }
          return v15 <= v25;
        }
        if (a4)
        {
          uint64_t v32 = a2 + 28;
          if ((a2[16] & 4) != 0)
          {
            v32[2 * a3] = -1;
            if (!v30)
            {
LABEL_55:
              sub_10003950C(a1, (uint64_t)a2, 0);
              unsigned int v27 = 0;
              uint64_t v29 = 0;
              goto LABEL_56;
            }
LABEL_52:
            signed int v33 = a2 + 28;
            if ((a2[16] & 4) != 0) {
              v33[2 * a3 + 1] = -1;
            }
            else {
              *(_DWORD *)&v33[4 * a3 + 2] = 0xFFFF;
            }
            goto LABEL_55;
          }
          *(_DWORD *)&v32[4 * a3] = 0xFFFF;
        }
        if (!v30) {
          goto LABEL_55;
        }
        goto LABEL_52;
      }
      uint64_t v29 = v28;
    }
    else
    {
      uint64_t v29 = 0;
    }
    uint64_t v30 = a6;
    goto LABEL_45;
  }
  return v15 <= v25;
}

uint64_t sub_100039198(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v3 = *(_WORD *)(a2 + 32);
  uint64_t v4 = a2 + 56;
  if ((v3 & 4) != 0)
  {
    uint64_t v5 = (unsigned __int16 *)(v4 + 4 * a3 + 2);
    LODWORD(v4) = *(_DWORD *)(a1 + 12);
  }
  else
  {
    v4 += 8 * a3;
    uint64_t v5 = (unsigned __int16 *)(v4 + 4);
    LOWORD(v4) = *(_WORD *)(v4 + 6);
  }
  int v6 = *v5;
  if (v6 == 65534)
  {
    LOWORD(v4) = -2;
  }
  else if (v6 == 0xFFFF)
  {
    LOWORD(v4) = 0;
  }
  else if ((v3 & 2) == 0)
  {
    if ((v3 & 8) != 0) {
      LOWORD(v4) = *(_WORD *)(a1 + 16) + 8;
    }
    else {
      LOWORD(v4) = 8;
    }
  }
  return (unsigned __int16)v4;
}

uint64_t sub_100039210(unsigned char *a1, _WORD *a2, int a3)
{
  uint64_t v3 = (unsigned __int16)a2[25] + (unsigned __int16)a2[23] + (unsigned __int16)a2[27];
  if ((a2[16] & 4) != 0 && (*a1 & 4) == 0) {
    return v3;
  }
  unsigned int v4 = (unsigned __int16)a2[21];
  unsigned int v5 = sub_10003ADF8((uint64_t)a1, (uint64_t)a2, a3);
  unsigned int v6 = v5 - v4;
  if (v5 < v4) {
    return v3 - v5 + v4;
  }
  if (v5 <= v4) {
    return v3;
  }
  BOOL v7 = v3 >= v6;
  unsigned int v8 = v3 - v6;
  if (v7) {
    return v8;
  }
  else {
    return 0;
  }
}

uint64_t sub_100039280(uint64_t result, _WORD *a2, int a3, unsigned int a4, unsigned int a5)
{
  if (a4 <= 0xFFFD)
  {
    int v5 = (unsigned __int16)a2[22];
    uint64_t v6 = *(unsigned int *)(result + 4);
    int v7 = (unsigned __int16)a2[23];
    unsigned int v8 = (a5 + 7) & 0xFFFFFFF8;
    if ((*(unsigned char *)result & 0x40) != 0) {
      unsigned int v8 = a5;
    }
    if (a3 || v8 + a4 != v5)
    {
      if (a3 == 1
        && v6
         - (unsigned __int16)a2[21]
         - (v5
          + v7)
         + (((unsigned __int16)a2[16] << 31 >> 31) & 0xFFFFFFD8)
         - 56 == a4)
      {
        a2[23] = v7 + v8;
      }
      else
      {
        int v9 = a2 + 24;
        uint64_t v10 = 26;
        if (a3) {
          int v9 = a2 + 26;
        }
        else {
          uint64_t v10 = 24;
        }
        v9[1] += v8;
        if (v8 >= 4)
        {
          if (a3)
          {
            unint64_t v11 = (char *)a2 + v6;
            uint64_t v12 = -40;
            if ((a2[16] & 1) == 0) {
              uint64_t v12 = 0;
            }
            uint64_t v13 = &v11[v12 - a4];
          }
          else
          {
            uint64_t v13 = (char *)a2 + (unsigned __int16)a2[21] + a4 + 56;
          }
          *((_WORD *)v13 + 1) = v8;
          *(_WORD *)uint64_t v13 = a2[v10];
          a2[v10] = a4;
        }
      }
    }
    else
    {
      a2[23] = v7 + v8;
      a2[22] = v5 - v8;
    }
  }
  return result;
}

unsigned __int16 *sub_100039390(int *a1, unsigned __int16 *a2, int a3, unsigned int a4)
{
  uint64_t result = 0;
  if (a4 && a4 != 65534)
  {
    uint64_t v6 = 24;
    if (a3)
    {
      uint64_t v6 = 26;
      int v7 = a2 + 26;
    }
    else
    {
      int v7 = a2 + 24;
    }
    int v8 = *a1;
    unsigned int v9 = (a4 + 7) & 0xFFFFFFF8;
    if ((*a1 & 0x40) != 0) {
      unsigned int v9 = a4;
    }
    if (v9 <= v7[1])
    {
      unsigned int v10 = a2[v6];
      if (v10 != 0xFFFF)
      {
        uint64_t result = 0;
        unsigned int v11 = -1;
        while (1)
        {
          if (a3)
          {
            if (v10 < 4) {
              return result;
            }
            uint64_t v12 = a1[1];
            int v13 = a2[16];
            if (v12 - a2[23] - (a2[21] + a2[22]) + ((v13 << 31 >> 31) & 0xFFFFFFD8) - 56 < v10) {
              return result;
            }
            int v14 = (char *)a2 + v12;
            uint64_t v15 = (v13 & 1) != 0 ? -40 : 0;
            unsigned int v16 = (unsigned __int16 *)&v14[v15 - v10];
            unsigned int v17 = v16[1];
            if (v17 < 4) {
              return result;
            }
            unsigned int v18 = (v17 + 7) & 0x1FFF8;
            if ((v8 & 0x40) != 0) {
              unsigned int v18 = v16[1];
            }
            if (v18 > v10) {
              return result;
            }
          }
          else
          {
            unsigned int v19 = a2[22];
            unsigned int v20 = v19 - v10;
            if (v19 <= v10) {
              return result;
            }
            if (v20 < 4) {
              return result;
            }
            unsigned int v16 = (unsigned __int16 *)((char *)a2 + a2[21] + v10 + 56);
            unsigned int v17 = v16[1];
            if (v17 < 4) {
              return result;
            }
            unsigned int v21 = (v17 + 7) & 0x1FFF8;
            if ((v8 & 0x40) != 0) {
              unsigned int v21 = v16[1];
            }
            if (v21 > v20) {
              return result;
            }
          }
          if (v9 <= v17 && v11 > v17)
          {
            uint64_t result = v7;
            unsigned int v11 = v17;
          }
          unsigned int v10 = *v16;
          int v7 = v16;
          if (v10 == 0xFFFF) {
            return result;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

void sub_10003950C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = malloc_type_calloc(*(unsigned int *)(a2 + 36), 6uLL, 0x1000040274DC3F3uLL);
  int v7 = (char *)v6;
  size_t v8 = *(unsigned int *)(a2 + 36);
  if (v8)
  {
    uint64_t v9 = 0;
    unsigned int v10 = v6 + 2;
    uint64_t v11 = 60;
    uint64_t v12 = 58;
    do
    {
      *(v10 - 2) = v9;
      if ((*(_WORD *)(a2 + 32) & 4) != 0) {
        uint64_t v13 = v12;
      }
      else {
        uint64_t v13 = v11;
      }
      *(v10 - 1) = *(_WORD *)(a2 + v13);
      int v14 = sub_100039198(a1, a2, v9);
      if (v14 == 65534)
      {
        __int16 v15 = 0;
      }
      else if ((*(unsigned char *)a1 & 0x40) != 0)
      {
        __int16 v15 = v14;
      }
      else
      {
        __int16 v15 = (v14 + 7) & 0xFFF8;
      }
      *unsigned int v10 = v15;
      v10 += 3;
      ++v9;
      v11 += 8;
      v12 += 4;
    }
    while (v8 != v9);
  }
  else
  {
    size_t v8 = 0;
  }
  qsort(v7, v8, 6uLL, (int (__cdecl *)(const void *, const void *))sub_10003AE6C);
  __int16 v16 = *(_WORD *)(a2 + 32);
  uint64_t v17 = -40;
  if ((v16 & 1) == 0) {
    uint64_t v17 = 0;
  }
  __base = v7;
  if (*(_DWORD *)(a2 + 36))
  {
    int v58 = a3;
    unint64_t v18 = 0;
    LODWORD(v19) = 0;
    uint64_t v20 = a2 + *(unsigned int *)(a1 + 4) + v17;
    unsigned int v21 = v7;
    uint64_t v22 = a2 + 56;
    unsigned int v23 = (unsigned __int16 *)(v21 + 4);
    do
    {
      unint64_t v24 = *(v23 - 1);
      if (v24 <= 0xFFFD)
      {
        size_t v25 = *v23;
        uint64_t v19 = (v19 + v25);
        memmove((void *)(v20 - v19), (const void *)(v20 - v24), v25);
        uint64_t v26 = *(v23 - 2);
        __int16 v16 = *(_WORD *)(a2 + 32);
        if ((v16 & 4) != 0)
        {
          *(_WORD *)(v22 + 4 * v26 + 2) = v19;
        }
        else
        {
          __int16 v27 = sub_100039198(a1, a2, *(v23 - 2));
          uint64_t v28 = v22 + 8 * v26;
          *(_WORD *)(v28 + 4) = v19;
          *(_WORD *)(v28 + 6) = v27;
        }
      }
      ++v18;
      unint64_t v29 = *(unsigned int *)(a2 + 36);
      v23 += 3;
    }
    while (v18 < v29);
    a3 = v58;
  }
  else
  {
    LOWORD(v19) = 0;
    LODWORD(v29) = 0;
  }
  *(_WORD *)(a2 + 46) = v19;
  if ((v16 & 4) == 0 || (*(unsigned char *)a1 & 4) != 0) {
    unsigned int v30 = sub_10003ADF8(a1, a2, a3);
  }
  else {
    unsigned int v30 = *(unsigned __int16 *)(a2 + 42);
  }
  unsigned int v31 = (char *)__base;
  if (v29)
  {
    uint64_t v32 = 0;
    signed int v33 = (_WORD *)(a2 + 56);
    int v34 = *(_DWORD *)a1;
    size_t v35 = v29;
    uint64_t v36 = __base + 2;
    int v37 = (_WORD *)(a2 + 56);
    do
    {
      *(v36 - 2) = v32;
      if ((*(_WORD *)(a2 + 32) & 4) != 0) {
        unsigned int v38 = v37;
      }
      else {
        unsigned int v38 = v33;
      }
      *(v36 - 1) = *v38;
      if ((*(_WORD *)(a2 + 32) & 4) != 0) {
        int v39 = *(_DWORD *)(a1 + 8);
      }
      else {
        LOWORD(v39) = v33[1];
      }
      if ((v34 & 0x40) == 0) {
        LOWORD(v39) = (v39 + 7) & 0xFFF8;
      }
      *uint64_t v36 = v39;
      v36 += 3;
      ++v32;
      v37 += 2;
      v33 += 4;
    }
    while (v29 != v32);
  }
  else
  {
    size_t v35 = 0;
  }
  qsort(__base, v35, 6uLL, (int (__cdecl *)(const void *, const void *))sub_10003AE6C);
  unint64_t v40 = *(unsigned int *)(a2 + 36);
  if (v40)
  {
    uint64_t v41 = 0;
    uint64_t v42 = __base + 2;
    unsigned int v43 = v30;
    while (v43 > *(v42 - 1) + *(unsigned __int16 *)(a2 + 42))
    {
      int v44 = *v42;
      v42 += 3;
      v43 += v44;
      if (v40 == ++v41)
      {
        unint64_t v45 = *(unsigned int *)(a2 + 36);
        goto LABEL_49;
      }
    }
    unint64_t v45 = v41;
LABEL_49:
    if ((int)v45 >= 1)
    {
      uint64_t v46 = a2 + 56;
      unint64_t v47 = v45 + 1;
      LODWORD(v48) = v43;
      do
      {
        uint64_t v49 = &v31[6 * (v47 - 2)];
        size_t v50 = *((unsigned __int16 *)v49 + 2);
        uint64_t v48 = (v48 - v50);
        memmove((void *)(v46 + v48), (const void *)(v46 + *(unsigned __int16 *)(a2 + 42) + *((unsigned __int16 *)v49 + 1)), v50);
        uint64_t v51 = *(unsigned __int16 *)v49;
        if ((*(_WORD *)(a2 + 32) & 4) != 0) {
          uint64_t v52 = 4 * v51;
        }
        else {
          uint64_t v52 = 8 * v51;
        }
        *(_WORD *)(v46 + v52) = v48 - v30;
        --v47;
        unsigned int v31 = (char *)__base;
      }
      while (v47 > 1);
      unint64_t v40 = *(unsigned int *)(a2 + 36);
    }
  }
  else
  {
    unint64_t v45 = 0;
    unint64_t v40 = 0;
    unsigned int v43 = v30;
  }
  if (v45 < v40)
  {
    uint64_t v53 = a2 + 56;
    uint64_t v54 = &v31[6 * v45 + 4];
    do
    {
      uint64_t v55 = *((unsigned __int16 *)v54 - 1);
      if (v55 != 0xFFFF)
      {
        memmove((void *)(v53 + v43), (const void *)(v53 + *(unsigned __int16 *)(a2 + 42) + v55), *(unsigned __int16 *)v54);
        uint64_t v56 = *((unsigned __int16 *)v54 - 2);
        if ((*(_WORD *)(a2 + 32) & 4) != 0) {
          uint64_t v57 = 4 * v56;
        }
        else {
          uint64_t v57 = 8 * v56;
        }
        *(_WORD *)(v53 + v57) = v43 - v30;
        v43 += *(unsigned __int16 *)v54;
        unint64_t v40 = *(unsigned int *)(a2 + 36);
      }
      ++v45;
      v54 += 6;
    }
    while (v45 < v40);
  }
  *(_WORD *)(a2 + 42) = v30;
  *(_WORD *)(a2 + 44) = v43 - v30;
  *(_WORD *)(a2 + 46) = *(_WORD *)(a1 + 4)
                      - (v43
                       + *(_WORD *)(a2 + 46))
                      + (((__int16)(*(_WORD *)(a2 + 32) << 15) >> 15) & 0xFFD8)
                      - 56;
  *(void *)(a2 + 48) = 0xFFFF0000FFFFLL;

  free(v31);
}

uint64_t sub_100039944(int *a1, _WORD *a2, int a3, unsigned int a4, _WORD *a5)
{
  if (a4)
  {
    if (a4 == 65534)
    {
      LOWORD(v5) = -2;
    }
    else
    {
      int v6 = *a1;
      unsigned int v7 = a4 + 7;
      if (a5)
      {
        unsigned int v8 = v7 & 0xFFFFFFF8;
        if ((v6 & 0x40) != 0) {
          unsigned int v8 = a4;
        }
        uint64_t v9 = a2 + 26;
        if (!a3) {
          uint64_t v9 = a2 + 24;
        }
        uint64_t v5 = (unsigned __int16)*a5;
        if (a3)
        {
          uint64_t v10 = -40;
          if ((a2[16] & 1) == 0) {
            uint64_t v10 = 0;
          }
          uint64_t v11 = (_WORD *)((char *)a2 + a1[1] + v10 - v5);
        }
        else
        {
          uint64_t v11 = (_WORD *)((char *)a2 + (unsigned __int16)a2[21] + v5 + 56);
        }
        v9[1] -= v8;
        unsigned int v14 = (unsigned __int16)v11[1] - v8;
        if (v14 < 4)
        {
          *a5 = *v11;
        }
        else
        {
          v11[1] = v14;
          if (a3) {
            unsigned int v14 = -v14;
          }
          LOWORD(v5) = v5 + v14;
        }
      }
      else
      {
        __int16 v12 = v7 & 0xFFF8;
        if ((v6 & 0x40) != 0) {
          __int16 v12 = a4;
        }
        unsigned __int16 v13 = a2[23] - v12;
        a2[23] = v13;
        if (a3)
        {
          LODWORD(v5) = a1[1]
                      - (unsigned __int16)a2[22]
                      - ((unsigned __int16)a2[21]
                       + v13)
                      + (((unsigned __int16)a2[16] << 31 >> 31) & 0xFFD8)
                      + 65480;
        }
        else
        {
          LOWORD(v5) = a2[22];
          a2[22] = v5 + v12;
        }
      }
    }
  }
  else
  {
    LOWORD(v5) = -1;
  }
  return (unsigned __int16)v5;
}

uint64_t sub_100039A6C(_DWORD *a1, uint64_t a2, const void *a3, uint64_t a4, const void *a5, uint64_t a6)
{
  if (a1[11] != 2) {
    return 22;
  }
  unsigned int v7 = a5;
  uint64_t v9 = a3;
  uint64_t v36 = 0;
  long long __src = 0;
  size_t v35 = 0;
  if (a3)
  {
    if (a5) {
      goto LABEL_4;
    }
LABEL_12:
    unsigned int v7 = &unk_10006F3B9;
    if (a6 != 65534 && a6) {
      return 14;
    }
    goto LABEL_4;
  }
  if (a4) {
    return 14;
  }
  uint64_t v9 = &unk_10006F3B8;
  if (!a5) {
    goto LABEL_12;
  }
LABEL_4:
  unsigned int v38 = (long long *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = sub_10003AC58(a1, a2, 1, &__src, &v38);
  if (v12) {
    goto LABEL_42;
  }
  if ((*((_WORD *)__src + 16) & 8) != 0)
  {
    uint64_t v12 = 45;
    goto LABEL_42;
  }
  int v13 = *(_DWORD *)v38;
  int v14 = *((_DWORD *)v38 + 1);
  int v16 = *((_DWORD *)v38 + 2);
  int v15 = *((_DWORD *)v38 + 3);
  int v17 = a1[9];
  if (v16)
  {
    if (v16 != a4)
    {
LABEL_41:
      uint64_t v12 = 22;
      goto LABEL_42;
    }
  }
  else if (!a4 || ((v14 - 160) >> 2) - v17 - 8 < a4)
  {
    goto LABEL_41;
  }
  if (v15 && v15 != a6 && ((v13 & 4) == 0 || a6 != 65534 && a6)) {
    goto LABEL_41;
  }
  int v18 = (a4 + 7) & 0xFFFFFFF8;
  if ((v13 & 0x40) != 0) {
    int v18 = a4;
  }
  int v19 = (a6 + 7) & 0xFFFFFFF8;
  if ((v13 & 0x40) != 0) {
    int v19 = a6;
  }
  if (a6 == 65534) {
    int v19 = 0;
  }
  unsigned int v20 = v19 + v18;
  unsigned int v21 = v14 - 160;
  unsigned int v22 = (v21 >> 2) - v17 - 8;
  unsigned int v23 = v16 - 1;
  if ((v13 & 0x40) != 0) {
    unsigned int v24 = *((_DWORD *)v38 + 2);
  }
  else {
    unsigned int v24 = (v16 + 7) & 0xFFFFFFF8;
  }
  unsigned int v25 = (v15 + 7) & 0xFFFFFFF8;
  if ((*(_DWORD *)v38 & 0x40) != 0) {
    unsigned int v25 = *((_DWORD *)v38 + 3);
  }
  if (v23 >= v22) {
    unsigned int v24 = v22;
  }
  unsigned int v26 = v24 + v25;
  if (v15) {
    unsigned int v27 = v26;
  }
  else {
    unsigned int v27 = v21;
  }
  if (v20 > v27)
  {
    uint64_t v12 = 34;
    goto LABEL_42;
  }
  uint64_t v12 = sub_10003AE84((uint64_t)a1, a2, v38, (uint64_t)__src, v9, a4, v7, a6, &v36, &v35, &v34);
  if (v12)
  {
LABEL_42:
    uint64_t v28 = v35;
    if (v35) {
      goto LABEL_43;
    }
    goto LABEL_45;
  }
  if (!v36 || (uint64_t v28 = v35, v32 = sub_10003B1E8((uint64_t)a1, a2, v38, (uint64_t)__src, v36, v35), !v32))
  {
    signed int v33 = v38;
    if (*((_DWORD *)v38 + 4) < a4) {
      *((_DWORD *)v38 + 4) = a4;
    }
    if (a6 != 65534 && *((_DWORD *)v33 + 5) < a6) {
      *((_DWORD *)v33 + 5) = a6;
    }
    sub_10003B3E8((uint64_t)a1, a2, (char *)__src, v30, v31);
    uint64_t v12 = 0;
    goto LABEL_42;
  }
  uint64_t v12 = v32;
  if (v28)
  {
LABEL_43:
    if (a1[10] != 0x8000000) {
      free(v28);
    }
  }
LABEL_45:
  if (v36 && a1[10] != 0x8000000) {
    free(v36);
  }
  if (__src && a1[10] != 0x8000000) {
    free(__src);
  }
  return v12;
}

uint64_t sub_100039D3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_100039D54(a1, a2, a3, a4, a5);
  }
  else {
    return 22;
  }
}

uint64_t sub_100039D54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  signed int v33 = (long long *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v28 = 0;
  long long __src = 0;
  uint64_t v10 = sub_10003AC58(a1, a2, 1, &__src, &v33);
  if (v10) {
    goto LABEL_2;
  }
  uint64_t v11 = __src;
  if (*((unsigned __int16 *)__src + 17) >= a5)
  {
    if ((*((_WORD *)__src + 16) & 8) != 0)
    {
      uint64_t v10 = 45;
      goto LABEL_2;
    }
    char v27 = -86;
    long long v30 = *v33;
    uint64_t v13 = *(void *)(a1 + 56);
    unint64_t v31 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000;
    uint64_t v32 = v13;
    uint64_t v14 = sub_10003C500(a1, a2, v33, (uint64_t)__src, a3, a4, &v28, &v27, a5);
    int v17 = v28;
    if (v14)
    {
      uint64_t v10 = v14;
    }
    else
    {
      if (v28)
      {
        uint64_t v18 = sub_10003B1E8(a1, a2, v33, (uint64_t)__src, v28, 0);
        if (v18)
        {
          uint64_t v10 = v18;
LABEL_34:
          if (*(_DWORD *)(a1 + 40) != 0x8000000) {
            free(v17);
          }
LABEL_2:
          uint64_t v11 = __src;
          if (!__src) {
            return v10;
          }
          goto LABEL_6;
        }
      }
      int v19 = (unsigned __int16 *)__src;
      while (1)
      {
        int v20 = *((_DWORD *)v19 + 9);
        if (v20 != 1) {
          goto LABEL_29;
        }
        if ((v19[16] & 2) != 0) {
          goto LABEL_32;
        }
        int v21 = v19[17];
        unsigned int v22 = v33;
        long long v35 = *v33;
        int v23 = *(_DWORD *)(a1 + 36);
        uint64_t v24 = *(void *)(a1 + 56);
        int v37 = -1431655766;
        uint64_t v38 = v24;
        int v36 = v23;
        BOOL v34 = 0;
        uint64_t v25 = sub_10003A69C((unsigned int *)a1, a2, &v35, (uint64_t)v19, 0, 1, (uint64_t *)&v34);
        if (v25) {
          break;
        }
        if (sub_100039210(&v35, v34, 0) >= 0x28)
        {
          sub_10003C3D0((uint64_t)&v35, (uint64_t)v19, 0);
          if (v19[17] == 1) {
            char v26 = 3;
          }
          else {
            char v26 = 1;
          }
          sub_10003C324((unsigned int *)&v35, (uint64_t)v19, v26, v19[17] - 1);
          sub_10003C108(&v35, (uint64_t)v34, v19, 0, -1, 0, 0, 0, 0, 0);
          sub_10002EE6C(a1, *(unsigned int *)(a1 + 40), *((void *)v34 + 2), *((void *)v34 + 1));
          if (*(_DWORD *)(a1 + 40) != 0x8000000) {
            free(v34);
          }
          --*((void *)v22 + 4);
        }
        int v19 = (unsigned __int16 *)__src;
        if (*((unsigned __int16 *)__src + 17) == v21)
        {
          int v20 = *((_DWORD *)__src + 9);
LABEL_29:
          if (!v20 && (v19[16] & 2) == 0)
          {
            sub_10003C324((unsigned int *)&v30, (uint64_t)v19, 3, 0);
            int v19 = (unsigned __int16 *)__src;
          }
LABEL_32:
          sub_10003B3E8(a1, a2, (char *)v19, v15, v16);
          uint64_t v10 = 0;
          int v17 = v28;
          goto LABEL_33;
        }
      }
      uint64_t v10 = v25;
      if (v34 && *(_DWORD *)(a1 + 40) != 0x8000000) {
        free(v34);
      }
    }
LABEL_33:
    if (!v17) {
      goto LABEL_2;
    }
    goto LABEL_34;
  }
  uint64_t v10 = 22;
LABEL_6:
  if (*(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v11);
  }
  return v10;
}

uint64_t sub_10003A048(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_100039D54(a1, a2, a3, a4, 0);
  }
  else {
    return 22;
  }
}

uint64_t sub_10003A064(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 22;
  }
  unsigned int v7 = 0;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_10003AC58(a1, a2, 0, &v7, &v8);
  if (!v5) {
    *a3 = *(void *)(v8 + 24);
  }
  if (v7 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v7);
  }
  return v5;
}

uint64_t sub_10003A0F8(uint64_t a1, uint64_t a2, void *a3)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 22;
  }
  unsigned int v7 = 0;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v5 = sub_10003AC58(a1, a2, 0, &v7, &v8);
  if (!v5) {
    *a3 = *(void *)(v8 + 32);
  }
  if (v7 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v7);
  }
  return v5;
}

uint64_t sub_10003A18C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (*(_DWORD *)(a1 + 44) == 2) {
    return sub_10003A1A4(a1, a2, a3);
  }
  else {
    return 22;
  }
}

uint64_t sub_10003A1A4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  long long __src = 0;
  if (*(void *)(a1 + 56)) {
    return 17;
  }
  unsigned int v10 = a3;
  uint64_t v11 = *(void *)(a1 + 24);
  int v12 = *(_DWORD *)(a1 + 32);
  uint64_t result = sub_10003BFDC(a1, a2, &v10, 3, 0, &__src);
  if (!result)
  {
    unint64_t v8 = (char *)__src;
    ++*(void *)((char *)__src + *(unsigned int *)(a1 + 24) - 8);
    sub_10003B3E8(a1, a2, v8, v6, v7);
    *(void *)(a1 + 56) = *((void *)v8 + 1);
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v8);
    }
    return 0;
  }
  return result;
}

uint64_t sub_10003A268(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 44) != 2) {
    return 22;
  }
  int8x16_t v7 = 0;
  if (!*(void *)(a1 + 56)) {
    return 0;
  }
  uint64_t v11 = (long long *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v4 = sub_10003AC58(a1, a2, 1, &v7, &v11);
  if (!v4)
  {
    long long v8 = *v11;
    uint64_t v5 = *(void *)(a1 + 56);
    unint64_t v9 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000;
    uint64_t v10 = v5;
    uint64_t v4 = sub_10003C7C4(a1, a2, &v8, (uint64_t)v7);
    if (!v4) {
      *(void *)(a1 + 56) = 0;
    }
  }
  if (v7 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v7);
  }
  return v4;
}

uint64_t sub_10003A34C(unsigned int *a1, uint64_t a2, int a3, int a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 32);
  if ((v4 & 0x10) != 0)
  {
    int v5 = 0;
    int v6 = 0;
    if (a3)
    {
      if ((v4 & 1) == 0)
      {
LABEL_4:
        int v7 = 0;
        int v8 = v5 + 1;
        goto LABEL_24;
      }
      goto LABEL_12;
    }
  }
  else
  {
    int v9 = *(_DWORD *)(a2 + 28);
    unsigned int v10 = a1[12];
    BOOL v22 = v9 == v10;
    int v5 = v9 != v10;
    int v11 = *(unsigned __int16 *)(a2 + 24);
    if (v22) {
      int v12 = 1;
    }
    else {
      int v12 = 2;
    }
    if (a3)
    {
      if (v11 != 2) {
        int v5 = v12;
      }
      if ((v4 & 1) == 0) {
        goto LABEL_4;
      }
LABEL_12:
      uint64_t v13 = a1[6];
      uint64_t v14 = a2 + v13;
      int v15 = *(_DWORD *)(a2 + v13 - 40);
      if (*(_DWORD *)(a2 + v13 - 36) != v13) {
        ++v5;
      }
      int v16 = *(_DWORD *)(v14 - 32);
      int v17 = *(_DWORD *)(v14 - 28);
      if (v16 != a1[7]) {
        ++v5;
      }
      if (v17 != a1[8]) {
        ++v5;
      }
      int v8 = v5 + (((v15 & 0x80) == 0) ^ (a1[13] == 0)) + (((v15 & 0x100) == 0) ^ (a1[13] == 0));
      int v7 = -40;
      goto LABEL_24;
    }
    if (v11 == 3) {
      int v6 = v5;
    }
    else {
      int v6 = v12;
    }
  }
  int v8 = v6 + (v4 & 1);
  int v7 = -40;
  if ((v4 & 1) == 0) {
    int v7 = 0;
  }
LABEL_24:
  int v18 = (a1[13] != 0) ^ ((v4 & 8) >> 3);
  int v19 = (v4 >> 3) & 1 ^ ((v4 & 0x10) >> 4);
  int v20 = (*(_WORD *)(a2 + 34) == 0) ^ ((v4 & 2) >> 1);
  unsigned int v21 = a1[6] + v7 - 56;
  BOOL v22 = (v4 & 4) == 0;
  if ((v4 & 4) != 0) {
    int v23 = 3;
  }
  else {
    int v23 = 7;
  }
  if (v22) {
    char v24 = 3;
  }
  else {
    char v24 = 2;
  }
  BOOL v25 = a4 == 61455 || *(unsigned __int16 *)(a2 + 34) == a4;
  int v26 = v8 + v19 + v18 + v20;
  if (!v25) {
    ++v26;
  }
  unsigned int v27 = *(unsigned __int16 *)(a2 + 42);
  if (*(_WORD *)(a2 + 40)) {
    ++v26;
  }
  if ((v23 & v27) != 0) {
    ++v26;
  }
  if (*(_DWORD *)(a2 + 36) <= v27 >> v24) {
    int v28 = v26;
  }
  else {
    int v28 = v26 + 1;
  }
  BOOL v29 = v21 >= v27;
  unsigned int v30 = v21 - v27;
  unsigned int v31 = *(unsigned __int16 *)(a2 + 44);
  if (!v29) {
    ++v28;
  }
  BOOL v29 = v30 >= v31;
  unsigned int v32 = v30 - v31;
  if (!v29) {
    ++v28;
  }
  if (v32 >= *(unsigned __int16 *)(a2 + 46)) {
    int v33 = 0;
  }
  else {
    int v33 = -1;
  }
  if (v28 == v33) {
    return 0;
  }
  else {
    return 92;
  }
}

uint64_t sub_10003A4E8(uint64_t result, int a2, unsigned int a3)
{
  if (result)
  {
    int v5 = (void *)result;
    uint64_t v6 = (16 * a2) | 8;
    int v7 = malloc_type_calloc(1uLL, v6 + a3 * a2, 0xEB8852B4uLL);
    *int v5 = v7;
    if (v7)
    {
      *(_DWORD *)int v7 = a2;
      v7[1] = (char *)v7 + v6;
      if (a2 >= 2)
      {
        uint64_t v8 = 0;
        do
        {
          *(void *)(*v5 + v8 + 24) = *(void *)(*v5 + v8 + 8) + a3;
          v8 += 16;
        }
        while (16 * a2 - 16 != v8);
      }
      return 0;
    }
    else
    {
      return 12;
    }
  }
  return result;
}

uint64_t sub_10003A59C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, int *a7)
{
  uint64_t result = sub_10003A760(a1, a2, a3, a4, a5, a6, a7);
  if (!result && !*a7 && *a6 >= 1) {
    --*a6;
  }
  return result;
}

uint64_t sub_10003A5E0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  if ((*(_WORD *)(a2 + 32) & 8) != 0) {
    int v7 = *(_DWORD *)(a1 + 16) + 8;
  }
  else {
    int v7 = 8;
  }
  int v11 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
  unsigned int v10 = -1431655766;
  uint64_t result = sub_10003A910(a1, a2, a3, &v11, &v10);
  if (!result)
  {
    uint64_t result = 92;
    if (v11)
    {
      if (v10 == v7)
      {
        uint64_t v9 = *v11;
        *a4 = *v11;
        uint64_t result = 0;
        if ((*(_WORD *)(a2 + 32) & 8) != 0) {
          *a4 = *(void *)(a1 + 24) + v9;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10003A69C(unsigned int *a1, uint64_t a2, _DWORD *a3, uint64_t a4, unsigned int a5, int a6, uint64_t *a7)
{
  __int16 v12 = *(_WORD *)(a4 + 34);
  uint64_t v15 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = sub_10003A5E0((uint64_t)a3, a4, a5, &v15);
  if (!result)
  {
    uint64_t result = sub_10002E8D0(a1, a7, a1[10], a2, v15);
    if (!result)
    {
      uint64_t v14 = *a7;
      uint64_t result = sub_10003A34C(a1, v14, 0, (unsigned __int16)(v12 - 1));
      if (!result)
      {
        if (!a6) {
          return 0;
        }
        uint64_t result = sub_10003AAC8(a3, v14);
        if (!result) {
          return 0;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10003A760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6, int *a7)
{
  int v9 = *(_DWORD *)(a3 + 36) - 1;
  if (v9 < 0)
  {
    int v21 = 0;
    int v15 = 0;
LABEL_18:
    uint64_t result = 0;
    *a6 = v15;
    *a7 = v21;
  }
  else
  {
    int v15 = 0;
    int v24 = -1431655766;
    unint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v22 = -1431655766;
    while (1)
    {
      int v16 = v9 + v15;
      if (v9 + v15 < 0 != __OFADD__(v9, v15)) {
        ++v16;
      }
      int v17 = v16 >> 1;
      uint64_t result = sub_10003A888(a2, a3, v16 >> 1, &v23, &v22);
      if (result) {
        break;
      }
      uint64_t v19 = *(void *)(a1 + 8);
      uint64_t v20 = v19 ? *(void *)(v19 + 40) : 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, void, int *))(a1 + 16))(v20, a4, a5, v23, v22, &v24);
      if (result) {
        break;
      }
      if (!v24)
      {
        int v21 = 1;
        int v15 = v17;
        goto LABEL_18;
      }
      if (v24 < 0) {
        int v9 = v17 - 1;
      }
      else {
        int v15 = v17 + 1;
      }
      if (v15 > v9)
      {
        int v21 = 0;
        goto LABEL_18;
      }
    }
  }
  return result;
}

uint64_t sub_10003A888(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, _DWORD *a5)
{
  if ((a3 & 0x80000000) != 0 || *(_DWORD *)(a2 + 36) <= a3) {
    return 22;
  }
  __int16 v5 = *(_WORD *)(a2 + 32);
  uint64_t v6 = a2 + 56;
  int v7 = (unsigned __int16 *)(a2 + 56 + 4 * a3);
  if ((v5 & 4) == 0) {
    int v7 = (unsigned __int16 *)(a2 + 56 + 8 * a3);
  }
  unsigned int v8 = *v7;
  unsigned int v9 = *(unsigned __int16 *)(a2 + 44);
  BOOL v10 = v9 >= v8;
  unsigned int v11 = v9 - v8;
  if (v11 == 0 || !v10) {
    return 92;
  }
  *a4 = v6 + *(unsigned __int16 *)(a2 + 42) + v8;
  if ((v5 & 4) != 0) {
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
  }
  else {
    LOWORD(v6) = *(_WORD *)(v6 + 8 * a3 + 2);
  }
  if (v11 < (unsigned __int16)v6) {
    return 92;
  }
  uint64_t result = 0;
  *a5 = (unsigned __int16)v6;
  return result;
}

uint64_t sub_10003A910(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, unsigned int *a5)
{
  if ((a3 & 0x80000000) != 0) {
    return 22;
  }
  if (*(_DWORD *)(a2 + 36) <= a3) {
    return 22;
  }
  int v5 = *(unsigned __int16 *)(a2 + 32);
  uint64_t v6 = (unsigned __int16 *)(a2 + 56 + 8 * a3 + 4);
  if ((v5 & 4) != 0) {
    uint64_t v6 = (unsigned __int16 *)(a2 + 56 + 4 * a3 + 2);
  }
  uint64_t v7 = *v6;
  uint64_t v8 = *(unsigned int *)(a1 + 4);
  unsigned int v9 = v8
     + ((v5 << 31 >> 31) & 0xFFFFFFD8)
     - (*(unsigned __int16 *)(a2 + 42)
      + *(unsigned __int16 *)(a2 + 44)
      + *(unsigned __int16 *)(a2 + 46))
     - 56;
  if (v7 <= 0xFFFD && v9 < v7) {
    return 92;
  }
  uint64_t v12 = a2 + v8;
  BOOL v13 = (v5 & 1) == 0;
  uint64_t v14 = -40;
  if (v13) {
    uint64_t v14 = 0;
  }
  uint64_t v15 = v12 + v14 - v7;
  if (v9 < v7) {
    uint64_t v15 = 0;
  }
  *a4 = v15;
  unsigned int v16 = sub_100039198(a1, a2, a3);
  unsigned int v17 = v16;
  if (v16 > v7 && v16 != 65534) {
    return 92;
  }
  uint64_t result = 0;
  *a5 = v17;
  return result;
}

uint64_t sub_10003AA08(void *__src, size_t __n, const void *a3, unsigned int a4, void *__dst, _DWORD *a6, void *a7, unsigned int *a8)
{
  int v13 = __n;
  if (a4 == 65534)
  {
    unsigned int v14 = 0;
  }
  else
  {
    if (!a3 && a4) {
      return 92;
    }
    unsigned int v14 = a4;
    if (*a8 < a4) {
      return 34;
    }
  }
  if (*a6 < __n) {
    return 34;
  }
  memcpy(__dst, __src, __n);
  memcpy(a7, a3, v14);
  uint64_t result = 0;
  *a6 = v13;
  *a8 = a4;
  return result;
}

uint64_t sub_10003AAC8(_DWORD *a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 44);
  int v3 = *(unsigned __int16 *)(a2 + 32);
  unsigned int v4 = a1[1]
     - *(unsigned __int16 *)(a2 + 46)
     - (v2
      + *(unsigned __int16 *)(a2 + 42))
     + ((v3 << 31 >> 31) & 0xFFFFFFD8)
     - 56;
  if ((v3 & 2) != 0)
  {
    unsigned int v6 = a1[3];
    if (v6)
    {
      int v5 = (*(unsigned __int8 *)a1 >> 2) & 1;
      if ((v3 & 4) == 0) {
        goto LABEL_6;
      }
    }
    else
    {
      LOBYTE(v5) = 1;
      if ((v3 & 4) == 0)
      {
LABEL_6:
        uint64_t v7 = *(unsigned int *)(a2 + 36);
        if (v7)
        {
          for (unint64_t i = (unsigned __int16 *)(a2 + 62); ; i += 4)
          {
            unsigned int v9 = *(i - 3);
            if (v2 <= v9) {
              break;
            }
            unsigned int v10 = *(i - 2);
            if ((*a1 & 0x40) == 0) {
              unsigned int v10 = (v10 + 7) & 0x1FFF8;
            }
            if (v10 > v2 - v9) {
              break;
            }
            unsigned int v11 = *(i - 1);
            char v12 = v11 > 0xFFFD ? v5 : 0;
            if ((v12 & 1) == 0)
            {
              if (v4 < v11) {
                break;
              }
              unsigned int v13 = (*a1 & 0x40) != 0 ? *i : (*i + 7) & 0x1FFF8;
              if (v13 > v11) {
                break;
              }
            }
            if (!--v7) {
              return v7;
            }
          }
          return 92;
        }
        return v7;
      }
    }
    unsigned int v14 = a1[2];
    goto LABEL_28;
  }
  if ((v3 & 4) == 0)
  {
    LOBYTE(v5) = 0;
    goto LABEL_6;
  }
  unsigned int v14 = a1[2];
  LOBYTE(v5) = 0;
  if ((v3 & 8) != 0) {
    unsigned int v6 = a1[4] + 8;
  }
  else {
    unsigned int v6 = 8;
  }
LABEL_28:
  uint64_t v15 = *(unsigned int *)(a2 + 36);
  if (v15)
  {
    for (j = (unsigned __int16 *)(a2 + 58); ; j += 2)
    {
      unsigned int v17 = *(j - 1);
      if (v2 <= v17) {
        break;
      }
      unsigned int v18 = (*a1 & 0x40) != 0 ? v14 : (v14 + 7) & 0xFFFFFFF8;
      if (v18 > v2 - v17) {
        break;
      }
      unsigned int v19 = *j;
      if (v19 > 0xFFFD) {
        char v20 = v5;
      }
      else {
        char v20 = 0;
      }
      if ((v20 & 1) == 0)
      {
        unsigned int v21 = (*a1 & 0x40) != 0 ? v6 : (v6 + 7) & 0xFFFFFFF8;
        uint64_t v7 = 92;
        if (v4 < v19 || v21 > v19) {
          return v7;
        }
      }
      if (!--v15) {
        return 0;
      }
    }
    return 92;
  }
  return 0;
}

uint64_t sub_10003AC58(uint64_t a1, uint64_t a2, int a3, void **a4, void *a5)
{
  uint64_t result = sub_10002E8D0((uint64_t **)a1, a4, *(_DWORD *)(a1 + 40), a2, *(void *)(a1 + 56));
  if (!result)
  {
    unsigned int v10 = (char *)*a4;
    uint64_t result = sub_10003A34C((unsigned int *)a1, (uint64_t)v10, 1, 61455);
    if (!result)
    {
      unsigned int v11 = &v10[*(unsigned int *)(a1 + 24)];
      long long v13 = *(_OWORD *)(v11 - 40);
      uint64_t v12 = *(void *)(a1 + 56);
      unint64_t v14 = *(unsigned int *)(a1 + 36) | 0xAAAAAAAA00000000;
      uint64_t v15 = v12;
      if (!a3 || (uint64_t result = sub_10003AAC8(&v13, (uint64_t)v10), !result))
      {
        uint64_t result = 0;
        if (a5) {
          *a5 = v11 - 40;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10003AD20(uint64_t a1, int a2)
{
  unsigned int v2 = *(_DWORD **)(a1 + 72);
  if (*v2 <= a2) {
    return 2;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  long long v12 = *(_OWORD *)*(void *)(a1 + 64);
  int v5 = *(_DWORD *)(v4 + 36);
  uint64_t v6 = *(void *)(v4 + 56);
  int v14 = -1431655766;
  uint64_t v15 = v6;
  int v13 = v5;
  uint64_t v7 = &v2[4 * a2];
  uint64_t v9 = *((void *)v7 + 1);
  uint64_t v8 = (uint64_t *)(v7 + 2);
  LODWORD(v6) = *((_DWORD *)v8 + 2) + 1;
  *((_DWORD *)v8 + 2) = v6;
  if (v6 != *(_DWORD *)(v9 + 36)) {
    return 0;
  }
  uint64_t v10 = a2 + 1;
  uint64_t result = sub_10003AD20(a1, v10);
  if (!result)
  {
    *((_DWORD *)v8 + 2) = 0;
    uint64_t result = sub_10003A69C(*(unsigned int **)(a1 + 48), *(void *)(a1 + 56), &v12, *(void *)(*(void *)(a1 + 72) + 16 * v10 + 8), *(_DWORD *)(*(void *)(a1 + 72) + 16 * v10 + 16), 0, v8);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10003ADF8(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v3 = (a3 + *(_DWORD *)(a2 + 36) + 7) & 0xFFFFFFF8;
  __int16 v4 = *(_WORD *)(a2 + 32);
  if ((v4 & 4) == 0) {
    return 8 * v3;
  }
  if ((v4 & 2) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 12);
  }
  else if ((v4 & 8) != 0)
  {
    int v6 = *(_DWORD *)(a1 + 16) + 8;
  }
  else
  {
    int v6 = 8;
  }
  if (((((unint64_t)*(unsigned int *)(a1 + 4) - 56)
       / ((unint64_t)(v6 + *(_DWORD *)(a1 + 8)) + 4)) & 0xFFFFFFFE) > v3)
    unsigned int v3 = (((unint64_t)*(unsigned int *)(a1 + 4) - 56)
        / ((unint64_t)(v6 + *(_DWORD *)(a1 + 8)) + 4)) & 0xFFFFFFFE;
  if ((*(unsigned char *)a1 & 4) == 0) {
    unsigned int v3 = (((unint64_t)*(unsigned int *)(a1 + 4) - 56)
  }
        / ((unint64_t)(v6 + *(_DWORD *)(a1 + 8)) + 4)) & 0xFFFFFFFE;
  return 4 * v3;
}

uint64_t sub_10003AE6C(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 2);
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10003AE84(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, const void *a5, uint64_t a6, const void *a7, uint64_t a8, void **a9, void **a10, BOOL *a11)
{
  int v43 = -1431655766;
  unsigned int v44 = -1431655766;
  *a10 = 0;
  *a9 = 0;
  int v17 = *(_DWORD *)(a1 + 36);
  uint64_t v18 = *(void *)(a1 + 56);
  int v37 = -1431655766;
  uint64_t v38 = v18;
  int v36 = v17;
  uint64_t v42 = 0;
  unint64_t v40 = 0;
  uint64_t v41 = 0;
  unsigned __int8 v39 = 0;
  long long v35 = *a3;
  if ((*(unsigned char *)(a4 + 32) & 2) != 0)
  {
    uint64_t v20 = sub_10003A760(a1, (uint64_t)&v35, a4, (uint64_t)a5, a6, (int *)&v44, &v43);
    if (v20) {
      goto LABEL_9;
    }
    int v30 = v44;
    if (v43)
    {
      if (!sub_100038D8C((uint64_t)&v35, (unsigned __int16 *)a4, v44, a5, a6, a7, a8))
      {
        uint64_t v20 = sub_10003B954(a1, a3, a4, v30, 1, a5, a6, a7, a8, a9, a10);
        if (v20) {
          goto LABEL_9;
        }
      }
      unsigned int v33 = v30;
      int v25 = 0;
      unint64_t v23 = 0;
      int v24 = 0;
    }
    else
    {
      if ((sub_10003B7B4((int *)&v35, a4, v44, a5, a6, a7, a8) & 1) == 0)
      {
        uint64_t v20 = sub_10003B954(a1, a3, a4, v30, 0, a5, a6, a7, a8, a9, a10);
        if (v20) {
          goto LABEL_9;
        }
      }
      unsigned int v33 = v30;
      int v25 = 0;
      unint64_t v23 = 0;
      int v24 = 0;
      ++*((void *)a3 + 3);
    }
  }
  else
  {
    uint64_t v20 = sub_10003A59C(a1, (uint64_t)&v35, a4, (uint64_t)a5, a6, (int *)&v44, &v43);
    if (v20) {
      goto LABEL_9;
    }
    unsigned int v21 = v44;
    uint64_t v20 = sub_10003A69C((unsigned int *)a1, a2, &v35, a4, v44, 1, (uint64_t *)&v42);
    if (v20) {
      goto LABEL_9;
    }
    unsigned int v33 = v21;
    uint64_t v22 = sub_10003AE84(a1, a2, a3, v42, a5, a6, a7, a8, &v41, &v40, &v39);
    unint64_t v23 = v40;
    if (v22
      || (int v24 = v41,
          int v25 = v39,
          uint64_t v22 = sub_10003B4C8(a1, a3, a4, v33, (uint64_t)v42, (uint64_t)v41, (uint64_t)v40, v39, a9),
          v22))
    {
      uint64_t v20 = v22;
      if (!v23) {
        goto LABEL_9;
      }
      goto LABEL_37;
    }
  }
  __int16 v31 = *(_WORD *)(a4 + 32);
  if ((v31 & 1) == 0 && ((v31 & 2) != 0 || v24 || v23 || v25)) {
    sub_10003B3E8(a1, a2, (char *)a4, v26, v27);
  }
  if (*a9) {
    sub_10003B3E8(a1, a2, (char *)*a9, v26, v27);
  }
  if (*a10) {
    sub_10003B3E8(a1, a2, (char *)*a10, v26, v27);
  }
  if (v33) {
    BOOL v32 = 0;
  }
  else {
    BOOL v32 = (*(_WORD *)(a4 + 32) & 2 | v25) != 0;
  }
  uint64_t v20 = 0;
  *a11 = v32;
  if (v23)
  {
LABEL_37:
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v23);
    }
  }
LABEL_9:
  if (v41 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v41);
  }
  if (v42 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v42);
  }
  return v20;
}

uint64_t sub_10003B1E8(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, _WORD *a5, _WORD *a6)
{
  v29[0] = 0;
  v29[1] = a5;
  _OWORD v29[2] = a6;
  long long v25 = *a3;
  int v10 = *(_DWORD *)(a1 + 36);
  uint64_t v11 = *(void *)(a1 + 56);
  int v27 = -1431655766;
  uint64_t v28 = v11;
  int v26 = v10;
  uint64_t v12 = sub_10003BFDC(a1, *(void *)(a4 + 16), (unsigned int *)&v25, *(_WORD *)(a4 + 32) & 2, *(_WORD *)(a4 + 34), v29);
  int v13 = v29[0];
  if (v12)
  {
LABEL_2:
    if (v13)
    {
      sub_10002EE6C(a1, *(unsigned int *)(a1 + 40), v13[2], v13[1]);
      if (*(_DWORD *)(a1 + 40) != 0x8000000) {
        free(v13);
      }
    }
  }
  else
  {
    sub_10003C108(&v25, a4, v29[0], 0, -1, 0, 0, 0, 0, 0);
    sub_10003B3E8(a1, a2, (char *)v13, v14, v15);
    sub_10003C324((unsigned int *)&v25, a4, 1, *(_WORD *)(a4 + 34) + 1);
    uint64_t v16 = 0;
    unsigned int v17 = WORD4(v25);
    do
    {
      uint64_t v18 = v29[v16];
      if (!v18) {
        break;
      }
      if (!*((_DWORD *)v18 + 9))
      {
        uint64_t v12 = 22;
        goto LABEL_2;
      }
      unsigned int v19 = (unsigned __int16)v18[28];
      unsigned int v20 = (unsigned __int16)v18[22];
      BOOL v21 = v20 >= v19;
      unsigned int v22 = v20 - v19;
      if (v22 == 0 || !v21) {
        goto LABEL_18;
      }
      unsigned int v23 = v17;
      if ((v18[16] & 4) == 0) {
        unsigned int v23 = (unsigned __int16)v18[29];
      }
      if (v22 < v23)
      {
LABEL_18:
        uint64_t v12 = 92;
        goto LABEL_2;
      }
      sub_10003B7B4((int *)&v25, a4, v16++, (char *)v18 + (unsigned __int16)v18[21] + (unsigned __int16)v18[28] + 56, v23, v18 + 4, 8u);
    }
    while (v16 != 3);
    ++*((void *)a3 + 4);
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v13);
    }
    return 0;
  }
  return v12;
}

uint64_t sub_10003B3E8(uint64_t a1, uint64_t a2, char *__src, int8x16_t a4, int8x16_t a5)
{
  int v8 = *(_DWORD *)(a1 + 40);
  if (v8)
  {
LABEL_2:
    int v9 = 0x8000000;
    if (v8 == 0x8000000) {
      return sub_10002EAB0((uint64_t **)a1, __src, v9, a2, *((void *)__src + 1));
    }
    goto LABEL_7;
  }
  int v10 = *(void **)(a1 + 8);
  if (!v10 || (unint64_t v11 = v10[8]) == 0 || *((void *)__src + 2) > v11)
  {
LABEL_7:
    sub_10003D7D8((unint64_t *)__src, (uint32x4_t *)(__src + 8), (*(_DWORD *)(a1 + 24) - 8), 0, a4, a5);
    int v9 = *(_DWORD *)(a1 + 40);
    return sub_10002EAB0((uint64_t **)a1, __src, v9, a2, *((void *)__src + 1));
  }
  uint64_t v14 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = v10[7];
  if (!v13) {
    uint64_t v13 = *(void *)(v10[5] + 16);
  }
  uint64_t result = sub_10002EC6C((uint64_t **)a1, 0, 0, v13, *((void *)__src + 1), &v14);
  if (!result)
  {
    *((void *)__src + 2) = v13;
    int v8 = *(_DWORD *)(a1 + 40);
    goto LABEL_2;
  }
  return result;
}

uint64_t sub_10003B4C8(uint64_t a1, long long *a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, void **a9)
{
  *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v55[1] = v12;
  v55[2] = v12;
  long long v54 = v12;
  v55[0] = v12;
  int v13 = *((_DWORD *)a2 + 2);
  if (a8)
  {
    if (!*(_DWORD *)(a5 + 36)) {
      return 22;
    }
    unsigned int v14 = *(unsigned __int16 *)(a5 + 56);
    unsigned int v15 = *(unsigned __int16 *)(a5 + 44);
    BOOL v16 = v15 >= v14;
    unsigned int v17 = v15 - v14;
    if (v17 == 0 || !v16) {
      return 92;
    }
    if ((*(_WORD *)(a5 + 32) & 4) != 0) {
      int v18 = *((_DWORD *)a2 + 2);
    }
    else {
      LOWORD(v18) = *(_WORD *)(a5 + 58);
    }
    if (v17 < (unsigned __int16)v18) {
      return 92;
    }
    long long v54 = a5 + 56 + *(unsigned __int16 *)(a5 + 42) + (unint64_t)*(unsigned __int16 *)(a5 + 56);
    *(void *)&v55[0] = (unsigned __int16)v18;
    *((void *)&v55[0] + 1) = a4 | 0xAAAAAA0100000000;
    unsigned int v19 = 1;
  }
  else
  {
    unsigned int v19 = 0;
  }
  unint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  if (!a6) {
    goto LABEL_20;
  }
  if (!*(_DWORD *)(a6 + 36)) {
    return 22;
  }
  unsigned int v20 = *(unsigned __int16 *)(a6 + 56);
  unsigned int v21 = *(unsigned __int16 *)(a6 + 44);
  BOOL v16 = v21 >= v20;
  unsigned int v22 = v21 - v20;
  if (v22 == 0 || !v16) {
    return 92;
  }
  unsigned __int16 v23 = (*(_WORD *)(a6 + 32) & 4) != 0 ? v13 : *(_WORD *)(a6 + 58);
  if (v22 < v23) {
    return 92;
  }
  uint64_t v24 = a6 + 56 + *(unsigned __int16 *)(a6 + 42) + *(unsigned __int16 *)(a6 + 56);
  unint64_t v48 = *(void *)(a6 + 8);
  uint64_t v25 = v19++;
  int v26 = &v55[2 * v25 - 1];
  *(void *)int v26 = v24;
  *((void *)v26 + 1) = &v48;
  *((_DWORD *)v26 + 4) = v23;
  *((_DWORD *)v26 + 5) = 8;
  *((void *)v26 + 3) = (a4 + 1) | 0xAAAAAA0000000000;
LABEL_20:
  unint64_t v47 = 0xAAAAAAAAAAAAAAAALL;
  if (a7)
  {
    if (*(_DWORD *)(a7 + 36))
    {
      unsigned int v27 = *(unsigned __int16 *)(a7 + 56);
      unsigned int v28 = *(unsigned __int16 *)(a7 + 44);
      BOOL v16 = v28 >= v27;
      unsigned int v29 = v28 - v27;
      if (v29 == 0 || !v16) {
        return 92;
      }
      if ((*(_WORD *)(a7 + 32) & 4) == 0) {
        LOWORD(v13) = *(_WORD *)(a7 + 58);
      }
      if (v29 < (unsigned __int16)v13) {
        return 92;
      }
      uint64_t v31 = a7 + 56 + *(unsigned __int16 *)(a7 + 42) + *(unsigned __int16 *)(a7 + 56);
      unint64_t v47 = *(void *)(a7 + 8);
      uint64_t v32 = v19++;
      unsigned int v33 = &v55[2 * v32 - 1];
      *(void *)unsigned int v33 = v31;
      *((void *)v33 + 1) = &v47;
      *((_DWORD *)v33 + 4) = (unsigned __int16)v13;
      *((_DWORD *)v33 + 5) = 8;
      *((void *)v33 + 3) = (a4 + 2) | 0xAAAAAA0000000000;
      goto LABEL_30;
    }
    return 22;
  }
LABEL_30:
  uint64_t v53 = 0;
  long long v49 = *a2;
  int v34 = *(_DWORD *)(a1 + 36);
  uint64_t v35 = *(void *)(a1 + 56);
  int v51 = -1431655766;
  uint64_t v52 = v35;
  int v50 = v34;
  if (v19)
  {
    char v36 = 0;
    int v37 = v19 + 1;
    uint64_t v38 = v55;
    do
    {
      unsigned int v39 = *((_DWORD *)v38 + 2);
      if (v36)
      {
        unsigned int v40 = *(_DWORD *)(a3 + 36);
        uint64_t v41 = (unsigned __int16 *)a3;
        BOOL v16 = v39 >= v40;
        unsigned int v42 = v39 - v40;
        if (v42 != 0 && v16)
        {
          uint64_t v41 = (unsigned __int16 *)*a9;
          unsigned int v39 = v42;
        }
      }
      else
      {
        uint64_t v41 = (unsigned __int16 *)a3;
      }
      int v43 = (const void *)*((void *)v38 - 2);
      unsigned int v44 = (const void *)*((void *)v38 - 1);
      unsigned int v45 = *(_DWORD *)v38;
      unsigned int v46 = *((_DWORD *)v38 + 1);
      if (*((unsigned char *)v38 + 12))
      {
        if (!sub_100038D8C((uint64_t)&v49, v41, v39, v43, v45, v44, v46)) {
          goto LABEL_41;
        }
      }
      else if ((sub_10003B7B4((int *)&v49, (uint64_t)v41, v39, v43, v45, v44, v46) & 1) == 0)
      {
LABEL_41:
        uint64_t result = sub_10003B954(a1, a2, a3, *((_DWORD *)v38 + 2), *((unsigned __int8 *)v38 + 12), *((const void **)v38 - 2), *(_DWORD *)v38, *((const void **)v38 - 1), *((_DWORD *)v38 + 1), a9, &v53);
        if (result) {
          return result;
        }
        char v36 = 1;
      }
      --v37;
      v38 += 2;
    }
    while (v37 > 1);
  }
  return 0;
}

uint64_t sub_10003B7B4(int *a1, uint64_t a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  int v13 = ((*a1 & 4) == 0) & (*(unsigned __int16 *)(a2 + 32) >> 2);
  if (v13 == 1 && *(unsigned __int16 *)(a2 + 42) <= 4 * (unint64_t)*(unsigned int *)(a2 + 36)) {
    return 0;
  }
  if ((*a1 & 0x40) != 0) {
    unsigned int v14 = a5;
  }
  else {
    unsigned int v14 = (a5 + 7) & 0xFFFFFFF8;
  }
  unsigned int v15 = (a7 + 7) & 0xFFFFFFF8;
  if ((*a1 & 0x40) != 0) {
    unsigned int v15 = a7;
  }
  if (a7 == 65534) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = v15;
  }
  unsigned int v17 = sub_100039210(a1, (_WORD *)a2, 1);
  uint64_t result = 0;
  if (v17 >= v16 + v14)
  {
    unsigned int v19 = a6;
    unsigned int v20 = sub_100039390(a1, (unsigned __int16 *)a2, 0, a5);
    uint64_t v25 = a4;
    if (v20) {
      unsigned int v21 = 0;
    }
    else {
      unsigned int v21 = v14;
    }
    unsigned int v22 = sub_100039390(a1, (unsigned __int16 *)a2, 1, a7);
    if (v22) {
      unsigned int v23 = 0;
    }
    else {
      unsigned int v23 = v16;
    }
    if (v21 + v23 > *(unsigned __int16 *)(a2 + 46)
      || (uint64_t v24 = v22, (v13 & 1) == 0) && sub_10003ADF8((uint64_t)a1, a2, 1) > *(unsigned __int16 *)(a2 + 42))
    {
      sub_10003950C((uint64_t)a1, a2, 1);
      unsigned int v20 = 0;
      uint64_t v24 = 0;
    }
    sub_10003BE88((uint64_t)a1, a2, a3, v25, a5, v20, v19, a7, v24);
    return 1;
  }
  return result;
}

uint64_t sub_10003B954(uint64_t a1, _OWORD *a2, uint64_t a3, int a4, int a5, const void *a6, unsigned int a7, const void *a8, unsigned int a9, void **a10, void **a11)
{
  unsigned int v16 = a2;
  uint64_t v17 = a1;
  int v18 = a11;
  long long v72 = *a2;
  int v19 = *(_DWORD *)(a1 + 36);
  uint64_t v20 = *(void *)(a1 + 56);
  int v74 = -1431655766;
  uint64_t v75 = v20;
  int v73 = v19;
  *a11 = 0;
  *a10 = 0;
  uint64_t v21 = sub_10003BFDC(a1, *(void *)(a3 + 16), (unsigned int *)&v72, *(_WORD *)(a3 + 32) & 2, *(_WORD *)(a3 + 34), a10);
  if (v21)
  {
LABEL_2:
    if (*v18)
    {
      sub_10002EE6C(v17, *(_DWORD *)(v17 + 40), *((void *)*v18 + 2), *((void *)*v18 + 1));
      if (*(_DWORD *)(v17 + 40) != 0x8000000) {
        free(*v18);
      }
      *int v18 = 0;
    }
    if (*a10)
    {
      sub_10002EE6C(v17, *(_DWORD *)(v17 + 40), *((void *)*a10 + 2), *((void *)*a10 + 1));
      if (*(_DWORD *)(v17 + 40) != 0x8000000) {
        free(*a10);
      }
      *a10 = 0;
    }
    return v21;
  }
  if (a6)
  {
    unsigned int v22 = (a7 + 7) & 0xFFFFFFF8;
    if ((v72 & 0x40) != 0) {
      unsigned int v22 = a7;
    }
    unsigned int v68 = v22;
    if (a5)
    {
      if ((*(_WORD *)(a3 + 32) & 4) != 0) {
        unsigned __int16 v23 = WORD4(v72);
      }
      else {
        unsigned __int16 v23 = *(_WORD *)(a3 + 8 * a4 + 58);
      }
      if ((v72 & 0x40) != 0) {
        int v24 = v23;
      }
      else {
        int v24 = (v23 + 7) & 0x1FFF8;
      }
      int v67 = v24;
      goto LABEL_23;
    }
  }
  else
  {
    unsigned int v68 = 0;
  }
  int v67 = 0;
LABEL_23:
  uint64_t v62 = v17;
  if (a8)
  {
    if (a9 == 65534)
    {
      unsigned int v25 = 0;
    }
    else
    {
      unsigned int v25 = (a9 + 7) & 0xFFFFFFF8;
      if ((v72 & 0x40) != 0) {
        unsigned int v25 = a9;
      }
    }
    v68 += v25;
    if (a5)
    {
      int v26 = sub_100039198((uint64_t)&v72, a3, a4);
      if (v26 == 65534)
      {
        int v27 = 0;
      }
      else
      {
        int v27 = (v26 + 7) & 0x1FFF8;
        if ((v72 & 0x40) != 0) {
          int v27 = v26;
        }
      }
      v67 += v27;
    }
  }
  int v28 = *(_DWORD *)(a3 + 36);
  int v70 = v28 - 1;
  if (v28 - 1 < 0)
  {
LABEL_95:
    int v18 = a11;
    uint64_t v17 = v62;
    uint64_t v21 = sub_10003BFDC(v62, *(void *)(a3 + 16), (unsigned int *)&v72, *(_WORD *)(a3 + 32) & 2, *(_WORD *)(a3 + 34), a11);
    if (!v21)
    {
      sub_10003C108(&v72, a3, *a11, a5 + a4, a4, a5, a6, a7, a8, a9);
      sub_10003C108(&v72, a3, *a10, a5 + a4 - 1, a4, a5, a6, a7, a8, a9);
      uint64_t v21 = 0;
      uint64_t v56 = *((void *)v16 + 4) + 2;
      goto LABEL_101;
    }
    goto LABEL_2;
  }
  int v58 = a8;
  unsigned int v59 = a6;
  unsigned int v60 = a7;
  unsigned int v61 = v16;
  int v29 = 0;
  int v30 = 0;
  unsigned int v64 = 0;
  int v65 = WORD4(v72);
  char v69 = v72;
  signed int v66 = -1;
  int v31 = 1;
  unsigned int v63 = -1;
  do
  {
    int v32 = v70 + v29;
    if (a4 - v28 == v29)
    {
      if (a5) {
        goto LABEL_90;
      }
    }
    else
    {
      if (v32 >= a4) {
        unsigned int v33 = v70 + v29;
      }
      else {
        unsigned int v33 = v32 + 1;
      }
      int v34 = v65;
      if ((*(_WORD *)(a3 + 32) & 4) == 0) {
        int v34 = *(unsigned __int16 *)(a3 + 56 + 8 * v33 + 2);
      }
      int v35 = sub_100039198((uint64_t)&v72, a3, v33);
      if ((v69 & 0x40) != 0) {
        int v36 = v34;
      }
      else {
        int v36 = (v34 + 7) & 0x1FFF8;
      }
      int v37 = (v35 + 7) & 0x1FFF8;
      if ((v69 & 0x40) != 0) {
        int v37 = v35;
      }
      if (v35 == 65534) {
        int v37 = 0;
      }
      v30 += v36 + v37;
    }
    if (a4 - v28 + 1 == v29) {
      int v38 = a5;
    }
    else {
      int v38 = 0;
    }
    if (v32 >= a4) {
      int v39 = a5;
    }
    else {
      int v39 = 0;
    }
    if (v32 < a4) {
      int v40 = a5;
    }
    else {
      int v40 = 0;
    }
    if (v32 < a4) {
      int v41 = 1;
    }
    else {
      int v41 = v38;
    }
    int v42 = v31 - v40;
    unsigned int v43 = sub_100039210(&v72, (_WORD *)a3, v29 - v39) + v30;
    unsigned int v44 = sub_100039210(&v72, *a10, v42) - v30;
    if (v41) {
      unsigned int v45 = v44;
    }
    else {
      unsigned int v45 = v43;
    }
    unsigned int v46 = v45 + v67;
    BOOL v52 = v46 >= v68;
    unsigned int v47 = v46 - v68;
    if (v52)
    {
      if ((v69 & 2) != 0)
      {
        unsigned int v54 = v64;
        BOOL v55 = v47 > v64;
        if (v47 > v64) {
          unsigned int v54 = v47;
        }
        unsigned int v64 = v54;
        signed int v53 = v66;
        if (v55) {
          signed int v53 = v70 + v29;
        }
      }
      else
      {
        if (v41) {
          unsigned int v48 = v43;
        }
        else {
          unsigned int v48 = v47;
        }
        if (v41) {
          unsigned int v44 = v47;
        }
        if (v48 <= v44) {
          unsigned int v49 = v44;
        }
        else {
          unsigned int v49 = v48;
        }
        if (v48 < v44) {
          unsigned int v44 = v48;
        }
        unsigned int v50 = v49 - v44;
        unsigned int v51 = v63;
        BOOL v52 = v50 >= v63;
        if (v50 < v63) {
          unsigned int v51 = v50;
        }
        unsigned int v63 = v51;
        signed int v53 = v66;
        if (!v52) {
          signed int v53 = v70 + v29;
        }
      }
      signed int v66 = v53;
    }
LABEL_90:
    --v29;
    ++v31;
  }
  while (v28 + v29 > 0);
  unsigned int v16 = v61;
  a7 = v60;
  a8 = v58;
  a6 = v59;
  if (v66 == -1) {
    goto LABEL_95;
  }
  sub_10003C108(&v72, a3, *a10, v66, a4, a5, v59, v60, v58, a9);
  if (v66 < a4 || (a5 & 1) != 0)
  {
    if (v66 > a4 && a5) {
      sub_100038D8C((uint64_t)&v72, (unsigned __int16 *)a3, a4, v59, v60, v58, a9);
    }
  }
  else
  {
    sub_10003B7B4((int *)&v72, a3, a4, v59, v60, v58, a9);
  }
  uint64_t v21 = 0;
  uint64_t v56 = *((void *)v61 + 4) + 1;
LABEL_101:
  *((void *)v16 + 4) = v56;
  return v21;
}

void *sub_10003BE88(uint64_t a1, uint64_t a2, int a3, const void *a4, unsigned int a5, _WORD *a6, const void *a7, unsigned int a8, _WORD *a9)
{
  unsigned int v16 = sub_100039944((int *)a1, (_WORD *)a2, 0, a5, a6);
  unsigned int v17 = sub_100039944((int *)a1, (_WORD *)a2, 1, a8, a9);
  uint64_t v18 = a2 + 56;
  memcpy((void *)(a2 + 56 + *(unsigned __int16 *)(a2 + 42) + v16), a4, a5);
  if (a7)
  {
    if (v17 != 0xFFFF && v17 != 65534)
    {
      uint64_t v20 = -40;
      if ((*(_WORD *)(a2 + 32) & 1) == 0) {
        uint64_t v20 = 0;
      }
      memcpy((void *)(a2 + *(unsigned int *)(a1 + 4) + v20 - v17), a7, a8);
    }
  }
  uint64_t v21 = a3;
  uint64_t v22 = a3 + 1;
  uint64_t v23 = (*(_DWORD *)(a2 + 36) - a3);
  if ((*(_WORD *)(a2 + 32) & 4) != 0)
  {
    int v26 = (_WORD *)(v18 + 4 * a3);
    uint64_t result = memmove((void *)(v18 + 4 * v22), v26, 4 * v23);
    *int v26 = v16;
    v26[1] = v17;
  }
  else
  {
    int v24 = (_WORD *)(v18 + 8 * a3);
    uint64_t result = memmove((void *)(v18 + 8 * v22), (const void *)(v18 + 8 * v21), 8 * v23);
    *int v24 = v16;
    v24[1] = a5;
    v24[2] = v17;
    v24[3] = a8;
  }
  ++*(_DWORD *)(a2 + 36);
  return result;
}

uint64_t sub_10003BFDC(uint64_t a1, uint64_t a2, unsigned int *a3, char a4, __int16 a5, void *a6)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v12 = sub_10002EC6C((uint64_t **)a1, &v21, *(_DWORD *)(a1 + 40), a2, 0, &v22);
  if (v12)
  {
    if (v21 && *(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v21);
    }
  }
  else
  {
    sub_10003C324(a3, (uint64_t)v21, a4, a5);
    int v13 = v21;
    *((void *)v21 + 1) = v22;
    unint64_t v13[2] = a2;
    __int16 v14 = *((_WORD *)v13 + 16);
    if (v14) {
      int v15 = 2;
    }
    else {
      int v15 = 3;
    }
    int v16 = *(_DWORD *)(a1 + 40);
    if (v16 == 0x8000000) {
      int v17 = -2013265920;
    }
    else {
      int v17 = *(_DWORD *)(a1 + 40);
    }
    int v18 = v17 | v15;
    *((_DWORD *)v13 + 6) = v18;
    if (!v16)
    {
      uint64_t v20 = *(void *)(a1 + 8);
      if (v20)
      {
        if ((*(unsigned char *)(*(void *)(v20 + 40) + 264) & 1) == 0) {
          *((_DWORD *)v13 + 6) = v18 | 0x10000000;
        }
      }
    }
    *((_DWORD *)v13 + 7) = *(_DWORD *)(a1 + 48);
    if (v14) {
      *(_OWORD *)((char *)v13 + a3[1] - 40) = *(_OWORD *)a3;
    }
    *a6 = v13;
  }
  return v12;
}

unsigned char *sub_10003C108(unsigned char *result, uint64_t a2, _WORD *a3, signed int a4, int a5, int a6, const void *a7, unsigned int a8, const void *a9, unsigned int a10)
{
  uint64_t v15 = (uint64_t)result;
  if ((a3[16] & 4) == 0 || (*result & 4) != 0)
  {
    unsigned int v16 = *(_DWORD *)(a2 + 36);
    if (a4 < a5) {
      int v17 = a6;
    }
    else {
      int v17 = 0;
    }
    uint64_t result = (unsigned char *)sub_10003ADF8((uint64_t)result, (uint64_t)a3, (v17 << 31 >> 31) - a4 + v16);
    unsigned int v18 = (unsigned __int16)a3[21];
    if (result > v18)
    {
      a3[23] += v18 - (_WORD)result;
      a3[21] = (_WORD)result;
    }
  }
  else
  {
    unsigned int v16 = *(_DWORD *)(a2 + 36);
  }
  if (v16 > a4)
  {
    uint64_t v31 = (uint64_t)a3;
    int v19 = 0;
    unsigned int v20 = a4;
    do
    {
      unsigned int v21 = 0;
      unsigned int v33 = 0;
      int v34 = 0;
      if ((int)v20 >= a5) {
        unsigned int v22 = v20;
      }
      else {
        unsigned int v22 = v20 + 1;
      }
      uint64_t v32 = 0;
      if (v22 < v16)
      {
        sub_10003A888(v15, a2, v22, &v34, (_DWORD *)&v32 + 1);
        uint64_t result = (unsigned char *)sub_10003A910(v15, a2, v22, &v33, (unsigned int *)&v32);
        unsigned int v21 = v32;
        if (v32 == 65534 || v32 == 0) {
          unsigned int v33 = &unk_10006F3BA;
        }
      }
      if (!a6 || a5 - 1 != v20)
      {
        int v24 = v34;
        if (a5 - 1 + a6 == v20)
        {
          if (a7)
          {
            int v24 = a7;
            unsigned int v25 = a8;
          }
          else
          {
            unsigned int v25 = HIDWORD(v32);
          }
          if (a9) {
            int v26 = a9;
          }
          else {
            int v26 = v33;
          }
          if (a9) {
            unsigned int v21 = a10;
          }
        }
        else
        {
          unsigned int v25 = HIDWORD(v32);
          int v26 = v33;
        }
        uint64_t result = sub_10003BE88(v15, v31, v19++, v24, v25, 0, v26, v21, 0);
      }
      ++v20;
      unsigned int v16 = *(_DWORD *)(a2 + 36);
    }
    while (v20 < v16);
  }
  for (int i = v16 - 1; i >= a4; --i)
  {
    if (i - a5 != -1)
    {
      if (i >= a5) {
        int v28 = i;
      }
      else {
        int v28 = i + 1;
      }
      uint64_t result = sub_10003C3D0(v15, a2, v28);
    }
  }
  return result;
}

unsigned int *sub_10003C324(unsigned int *result, uint64_t a2, char a3, __int16 a4)
{
  __int16 v4 = a3 & 0x1B;
  *(_WORD *)(a2 + 32) = v4;
  *(_WORD *)(a2 + 34) = a4;
  *(_DWORD *)(a2 + 36) = 0;
  *(_WORD *)(a2 + 40) = 0;
  *(_WORD *)(a2 + 44) = 0;
  *(void *)(a2 + 48) = 0xFFFF0000FFFFLL;
  unsigned int v5 = result[2];
  if ((a3 & 2) != 0)
  {
    int v6 = result[3];
  }
  else if ((a3 & 8) != 0)
  {
    int v6 = result[4] + 8;
  }
  else
  {
    int v6 = 8;
  }
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    LOWORD(v8) = 64;
  }
  else
  {
    v4 |= 4u;
    *(_WORD *)(a2 + 32) = v4;
    int v8 = (4 * (((unint64_t)result[1] - 56) / ((unint64_t)(v6 + v5) + 4))) & 0xFFFFFFF8;
  }
  *(_WORD *)(a2 + 42) = v8;
  *(_WORD *)(a2 + 46) = *((_WORD *)result + 2) - v8 + (((__int16)(v4 << 15) >> 15) & 0xFFD8) - 56;
  return result;
}

void *sub_10003C3D0(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v6 = *(_WORD *)(a2 + 32);
  uint64_t v7 = a2 + 56;
  uint64_t v8 = a3;
  int v9 = (void *)(a2 + 56 + 4 * a3);
  int v10 = (void *)(a2 + 56 + 8 * a3);
  if ((v6 & 4) != 0) {
    unint64_t v11 = (unsigned __int16 *)(a2 + 56 + 4 * a3);
  }
  else {
    unint64_t v11 = (unsigned __int16 *)(a2 + 56 + 8 * a3);
  }
  if ((v6 & 4) != 0) {
    int v12 = *(_DWORD *)(a1 + 8);
  }
  else {
    LOWORD(v12) = *(_WORD *)(v7 + 8 * a3 + 2);
  }
  sub_100039280(a1, (_WORD *)a2, 0, *v11, (unsigned __int16)v12);
  if ((*(_WORD *)(a2 + 32) & 4) != 0) {
    int v13 = (unsigned __int16 *)(v7 + 4 * v8 + 2);
  }
  else {
    int v13 = (unsigned __int16 *)(v7 + 8 * v8 + 4);
  }
  unsigned int v14 = *v13;
  unsigned int v15 = sub_100039198(a1, a2, a3);
  sub_100039280(a1, (_WORD *)a2, 1, v14, v15);
  uint64_t v16 = v8 + 1;
  uint64_t v17 = (*(_DWORD *)(a2 + 36) + ~a3);
  if ((*(_WORD *)(a2 + 32) & 4) != 0)
  {
    uint64_t result = memmove(v9, (const void *)(v7 + 4 * v16), 4 * v17);
    unsigned int v19 = *(_DWORD *)(a2 + 36) - 1;
    *(_DWORD *)(v7 + 4 * v19) = -1;
  }
  else
  {
    uint64_t result = memmove(v10, (const void *)(v7 + 8 * v16), 8 * v17);
    unsigned int v19 = *(_DWORD *)(a2 + 36) - 1;
    *(void *)(v7 + 8 * v19) = 0xFFFF0000FFFFLL;
  }
  *(_DWORD *)(a2 + 36) = v19;
  return result;
}

uint64_t sub_10003C500(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, char **a7, char *a8, unsigned __int16 a9)
{
  unsigned int v46 = -1431655766;
  int v45 = -1431655766;
  *a7 = 0;
  int v16 = *(_DWORD *)(a1 + 36);
  uint64_t v17 = *(void *)(a1 + 56);
  int v40 = -1431655766;
  int v39 = v16;
  unsigned int v43 = 0;
  unsigned int v44 = 0;
  char v42 = 0;
  long long v38 = *a3;
  uint64_t v41 = v17;
  unsigned int v18 = *(unsigned __int16 *)(a4 + 34);
  uint64_t v19 = sub_10003A59C(a1, (uint64_t)&v38, a4, a5, a6, (int *)&v46, &v45);
  uint64_t v20 = v19;
  BOOL v21 = v18 > a9;
  int v22 = v21;
  if (!v21)
  {
    if (!v19)
    {
      if (v45)
      {
        unsigned int v24 = v46;
        sub_10003C3D0((uint64_t)&v38, a4, v46);
        if (a9) {
          goto LABEL_12;
        }
        int v29 = (void *)a3 + 3;
LABEL_15:
        int v28 = a8;
        --*v29;
LABEL_16:
        if ((*(_WORD *)(a4 + 32) & 1) == 0)
        {
          BOOL v30 = *(unsigned __int16 *)(a4 + 34) != a9 && v43 == 0;
          BOOL v31 = v30 && v42 == 0;
          int v32 = v31 ? v22 : 1;
          if (v32 == 1) {
            sub_10003B3E8(a1, a2, (char *)a4, v26, v27);
          }
        }
        if (*a7) {
          sub_10003B3E8(a1, a2, *a7, v26, v27);
        }
        if (v24)
        {
          char v33 = 0;
        }
        else if (*(unsigned __int16 *)(a4 + 34) != a9 && v42 == 0)
        {
          char v33 = v22;
        }
        else
        {
          char v33 = 1;
        }
        uint64_t v20 = 0;
        *int v28 = v33;
        goto LABEL_39;
      }
      uint64_t v20 = 2;
    }
LABEL_39:
    uint64_t v23 = v43;
    goto LABEL_40;
  }
  if (v19) {
    goto LABEL_39;
  }
  unsigned int v36 = v46;
  uint64_t v20 = sub_10003A69C((unsigned int *)a1, a2, &v38, a4, v46, 1, (uint64_t *)&v44);
  if (v20) {
    goto LABEL_39;
  }
  uint64_t v20 = sub_10003C500(a1, a2, a3, v44, a5, a6, &v43, &v42, a9);
  if (v20) {
    goto LABEL_39;
  }
  if (!*((_DWORD *)v44 + 9))
  {
    unsigned int v24 = v36;
    sub_10003C3D0((uint64_t)&v38, a4, v36);
    sub_10002EE6C(a1, *(unsigned int *)(a1 + 40), *((void *)v44 + 2), *((void *)v44 + 1));
    if (*(_DWORD *)(a1 + 40) != 0x8000000) {
      free(v44);
    }
    unsigned int v44 = 0;
    int v29 = a3 + 2;
    goto LABEL_15;
  }
  uint64_t v23 = v43;
  unsigned int v24 = v36;
  uint64_t v25 = sub_10003B4C8(a1, a3, a4, v36);
  if (!v25)
  {
LABEL_12:
    int v22 = 0;
    int v28 = a8;
    goto LABEL_16;
  }
  uint64_t v20 = v25;
LABEL_40:
  if (v23 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v23);
  }
  if (v44 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v44);
  }
  return v20;
}

uint64_t sub_10003C7C4(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  int v12 = 0;
  if ((*(_WORD *)(a4 + 32) & 2) != 0 || !*(_DWORD *)(a4 + 36))
  {
LABEL_7:
    sub_10002EE6C(a1, *(_DWORD *)(a1 + 40), *(void *)(a4 + 16), *(void *)(a4 + 8));
    uint64_t v10 = 0;
  }
  else
  {
    unsigned int v8 = 0;
    while (1)
    {
      uint64_t v9 = sub_10003A69C((unsigned int *)a1, a2, a3, a4, v8, 1, (uint64_t *)&v12);
      if (v9) {
        break;
      }
      uint64_t v9 = sub_10003C7C4(a1, a2, a3, v12);
      if (v9) {
        break;
      }
      if (++v8 >= *(_DWORD *)(a4 + 36)) {
        goto LABEL_7;
      }
    }
    uint64_t v10 = v9;
  }
  if (v12 && *(_DWORD *)(a1 + 40) != 0x8000000) {
    free(v12);
  }
  return v10;
}

uint64_t sub_10003C8A8(uint64_t *a1, uint64_t a2)
{
  unsigned int v64 = 0;
  uint64_t v4 = sub_1000257B4(a1, a2, 0x40000000, *(void *)(*(void *)(a2 + 40) + 976), 0, 0, 24, 0, (uint64_t **)&v64, 0, 1);
  if (v4)
  {
    uint64_t v12 = v4;
    sub_10004458C("could not retrieve er_state_phys_t\n", v5, v6, v7, v8, v9, v10, v11, v62);
    uint64_t v13 = 516;
    int v14 = v12;
LABEL_8:
    sub_100048B34((char *)v13, v14);
    goto LABEL_9;
  }
  unsigned int v15 = v64;
  if (*((_DWORD *)v64 + 8) != 1179402562)
  {
    sub_10004458C("er_state magic number is %d, should be %d\n", v5, v6, v7, v8, v9, v10, v11, *((_DWORD *)v64 + 8));
    uint64_t v12 = 92;
    uint64_t v13 = 517;
    goto LABEL_7;
  }
  unsigned int v16 = *((_DWORD *)v64 + 9);
  if (v16 >= 3)
  {
    sub_10004458C("er_state->ersb_version is %d, should be at most %d\n", v5, v6, v7, v8, v9, v10, v11, *((_DWORD *)v64 + 9));
    uint64_t v12 = 92;
    uint64_t v13 = 518;
LABEL_7:
    int v14 = 92;
    goto LABEL_8;
  }
  if (v16 != 2)
  {
    if (v16 != 1)
    {
      sub_10004458C("ersb_version is %d, unsupported\n", v5, v6, v7, v8, v9, v10, v11, *((_DWORD *)v64 + 9));
      uint64_t v12 = 92;
      uint64_t v13 = 739;
      goto LABEL_7;
    }
    uint64_t v12 = sub_10003CCBC(*((void *)v64 + 5), v5, v6, v7, v8, v9, v10, v11);
    if (!v12)
    {
      if ((v15[5] & 0x20) != 0 && !v15[15])
      {
        sub_10004458C("invalid ersb_flags (0x%llx), ERSB_FLAG_CID_IS_TWEAK is set but ersb_fext_cid == 0\n", v18, v19, v20, v21, v22, v23, v24, v15[5]);
        uint64_t v12 = 92;
        uint64_t v13 = 716;
        goto LABEL_7;
      }
      uint64_t v12 = sub_10003CD44((uint64_t)a1, v15[6], v19, v20, v21, v22, v23, v24);
      if (!v12)
      {
        unint64_t v32 = v15[12];
        if (v32 > *(void *)(a1[1] + 40))
        {
          sub_10004458C("ersb_total_blk_to_encrypt (%llu) exceeds device block count (%llu)\n", v25, v26, v27, v28, v29, v30, v31, v15[12]);
          uint64_t v12 = 92;
          uint64_t v13 = 522;
          goto LABEL_7;
        }
        if (v15[11] > v32) {
          sub_100044674("ersb_progress (%llu) exceeds ersb_total_blk_to_encrypt (%llu)\n", v25, v26, v27, v28, v29, v30, v31, v15[11]);
        }
        if ((v15[5] & 8) != 0 && (unsigned __int16)*((_DWORD *)v15 + 28))
        {
          sub_10004458C("ersb_flags (0x%llx) has ERSB_FLAG_PAUSED on but checksum count is non-zero (%u)\n", v25, v26, v27, v28, v29, v30, v31, v15[5]);
          uint64_t v12 = 92;
          uint64_t v13 = 523;
          goto LABEL_7;
        }
        if ((unsigned __int16)*((_DWORD *)v15 + 28) > HIWORD(*((_DWORD *)v15 + 28)))
        {
          sub_10004458C("checksum_count (%u) exceeds max checksums (%u)\n", v25, v26, v27, v28, v29, v30, v31, *((_DWORD *)v15 + 28));
          uint64_t v12 = 92;
          uint64_t v13 = 717;
          goto LABEL_7;
        }
        uint64_t v61 = sub_10003CDA4(a1, a2, v15[13], v15[12]);
        goto LABEL_49;
      }
    }
    goto LABEL_9;
  }
  uint64_t v12 = sub_10003CCBC(*((void *)v64 + 5), v5, v6, v7, v8, v9, v10, v11);
  if (v12) {
    goto LABEL_9;
  }
  uint64_t v12 = sub_10003CD44((uint64_t)a1, v15[6], v33, v34, v35, v36, v37, v38);
  if (v12) {
    goto LABEL_9;
  }
  unint64_t v45 = v15[10];
  if (v15[9] > v45)
  {
    sub_100044674("ersb_progress (%llu) exceeds ersb_total_blk_to_encrypt (%llu)\n", v39, v40, v45, v41, v42, v43, v44, v15[9]);
    unint64_t v45 = v15[10];
  }
  uint64_t v12 = sub_10003CDA4(a1, a2, v15[11], v45);
  if (v12) {
    goto LABEL_9;
  }
  int v65 = 0;
  uint64_t v46 = sub_1000257B4(a1, 0, 0x40000000, v15[11], 0, 0, 25, 0, (uint64_t **)&v65, 0, 0);
  if (v46)
  {
    uint64_t v12 = v46;
    uint64_t v54 = 2863311530;
    sub_10004458C("could not retrieve gbitmap from er_state_phys_t\n", v47, v48, v49, v50, v51, v52, v53, v63);
    sub_100048B34((char *)0x2CE, v12);
    goto LABEL_43;
  }
  unint64_t v55 = *((void *)v65 + 5);
  uint64_t v56 = a1[1];
  unint64_t v57 = *(void *)(v56 + 40);
  unint64_t v58 = v55 / v57;
  if ((v55 / v57) * v57 != v55)
  {
    uint64_t v54 = 2863311530;
    sub_10004458C("bm_bit_count %llu is not an integer multiple of container block count %llu\n", v47, v48, v49, v50, v51, v52, v53, *((void *)v65 + 5));
    uint64_t v60 = 719;
    goto LABEL_42;
  }
  uint64_t v12 = 0;
  unsigned int v59 = *(_DWORD *)(v56 + 36);
  uint64_t v54 = v59 / v58;
  if ((*(unsigned char *)(v56 + 65) & 1) != 0 && v59 != v54)
  {
    sub_10004458C("Fusion with FS block size (%u) != container device block size (%u)\n", v47, v48, v49, v50, v51, v52, v53, v59);
    uint64_t v60 = 741;
LABEL_42:
    sub_100048B34((char *)v60, 0);
    uint64_t v12 = 92;
  }
LABEL_43:
  if (v65) {
    free(v65);
  }
  if (!v12)
  {
    if (v15[13])
    {
      if ((v15[5] & 8) != 0)
      {
        sub_10004458C("ersb_flags (0x%llx) has ERSB_FLAG_PAUSED on but ersb_recovery_extents_count is non-zero (%llu)\n", v47, v48, v49, v50, v51, v52, v53, v15[5]);
        uint64_t v12 = 92;
        uint64_t v13 = 738;
        goto LABEL_7;
      }
      uint64_t v61 = sub_10003D054(a1, a2, v15, v54, v50, v51, v52, v53);
LABEL_49:
      uint64_t v12 = v61;
      goto LABEL_9;
    }
    if (v15[14])
    {
      sub_10004458C("ersb_recovery_extents_count == 0, but ersb_recovery_list_oid is non-zero (0x%llx)\n", v47, v48, v49, v50, v51, v52, v53, v15[14]);
      uint64_t v12 = 92;
      uint64_t v13 = 736;
      goto LABEL_7;
    }
    if (v15[15])
    {
      sub_10004458C("ersb_recovery_extents_count == 0, but ersb_recovery_length is non-zero (%llu)\n", v47, v48, v49, v50, v51, v52, v53, v15[15]);
      uint64_t v12 = 92;
      uint64_t v13 = 737;
      goto LABEL_7;
    }
    uint64_t v12 = 0;
  }
LABEL_9:
  if (v64) {
    free(v64);
  }
  return v12;
}

uint64_t sub_10003CCBC(__int16 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 3) == 3 || (a1 & 3) == 0)
  {
    sub_10004458C("invalid ersb_flags (0x%llx), exactly one of ERSB_FLAG_ENCRYPTING and ERSB_FLAG_DECRYPTING bits must be set\n", a2, a3, a4, a5, a6, a7, a8, a1);
    uint64_t v9 = 519;
LABEL_10:
    uint64_t v10 = 92;
    sub_100048B34((char *)v9, 92);
    return v10;
  }
  if ((a1 & 0xF00u) >= 0x700uLL)
  {
    sub_10004458C("invalid checksum block size, enum: %llu\n", a2, a3, a4, a5, a6, a7, a8, HIBYTE(a1) & 0xF);
    uint64_t v9 = 715;
    goto LABEL_10;
  }
  return 0;
}

uint64_t sub_10003CD44(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(*(void *)(a1 + 8) + 96) > a2) {
    return 0;
  }
  sub_10004458C("ersb_snap_xid (%llu) is greater than or equal to container next xid (%llu)\n", a2, a3, a4, a5, a6, a7, a8, a2);
  uint64_t v8 = 92;
  sub_100048B34((char *)0x209, 92);
  return v8;
}

uint64_t sub_10003CDA4(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v30 = 0;
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v29[2] = v7;
  uint64_t v29[3] = v7;
  v29[0] = v7;
  v29[1] = v7;
  uint64_t v8 = sub_1000257B4(a1, a2, 0x40000000, a3, 0, 0, 25, 0, &v30, 0, 1);
  if (v8)
  {
    uint64_t v16 = v8;
    sub_10004458C("could not retrieve gbitmap from er_state_phys_t\n", v9, v10, v11, v12, v13, v14, v15, v27);
    uint64_t v17 = 546;
LABEL_3:
    int v18 = v16;
LABEL_4:
    sub_100048B34((char *)v17, v18);
    goto LABEL_5;
  }
  if (v30[5] < a4)
  {
    sub_10004458C("ersb_total_blk_to_encrypt (%llu) exceeds bm_bit_count (%llu)\n", v9, v10, v11, v12, v13, v14, v15, a4);
    uint64_t v16 = 92;
    uint64_t v17 = 740;
    int v18 = 92;
    goto LABEL_4;
  }
  sub_100038040((uint64_t)v29, (uint64_t)a1, a2, 0x40000000, 2, 26, 0, *(_DWORD *)(a1[1] + 36), 8, 8, 0, v30[4], (uint64_t)sub_1000306FC);
  uint64_t v16 = sub_100035168((uint64_t)v29, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10003CF04, 0, 0, 1);
  if (v16)
  {
    sub_10004458C("encryption rolling gbitmap tree is invalid\n", v20, v21, v22, v23, v24, v25, v26, v28);
    uint64_t v17 = 494;
    goto LABEL_3;
  }
LABEL_5:
  if (v30) {
    free(v30);
  }
  return v16;
}

uint64_t sub_10003CF04(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = 0;
  unint64_t v8 = *(void *)a5 & 0x7FFFFFFFFFFFFFFFLL;
  if ((*(void *)a5 & 0x8000000000000000) != 0)
  {
    uint64_t v10 = a1[1];
    uint64_t v11 = a1[3];
    if (v11)
    {
      unint64_t v12 = *(void *)(v11 + 48);
      unint64_t v13 = *(void *)(v11 + 96);
    }
    else
    {
      unint64_t v12 = *(void *)(v10 + 40);
      if (*(unsigned char *)(v10 + 65)) {
        unint64_t v13 = *(void *)(v10 + 40);
      }
      else {
        unint64_t v13 = 0;
      }
    }
    unint64_t v14 = *(unsigned int *)(v10 + 36);
    if (v8 && (v12 >= 2 ? (BOOL v15 = v12 > v8) : (BOOL v15 = 0), v15 ? (v16 = v12 - 1 >= v8) : (v16 = 0), v16)
      || ((unint64_t v17 = 0x4000000000000000uLL >> __clz(__rbit64(v14)), v17 < v8) ? (v18 = v13 >= 2) : (v18 = 0),
          v18 ? (BOOL v19 = (v13 | v17) > v8) : (BOOL v19 = 0),
          v19 && ((v13 - 1) | v17) >= v8))
    {
      if (a2) {
        unint64_t v20 = *(void *)(*(void *)(a2 + 40) + 8);
      }
      else {
        unint64_t v20 = 0;
      }
      sub_100040DD0((uint64_t)a1, v8, 1, v20, 0x40000000, v8, 0, 0x1Bu, &_mh_execute_header, (unint64_t)&_mh_execute_header >> 32);
      return 0;
    }
    else
    {
      sub_10004458C("invalid gbitmap block oid 0x%llx for key 0x%llx\n", a2, a3, a4, (uint64_t)a5, v8, a7, a8, *a5);
      uint64_t v9 = 92;
      sub_100048B34((char *)0x30F, 92);
    }
  }
  else
  {
    uint64_t v9 = sub_1000257B4(a1, a2, 0x40000000, v8, 0, 0, 27, 0, (uint64_t **)&v22, 0, 1);
    if (v22) {
      free(v22);
    }
  }
  return v9;
}

uint64_t sub_10003D054(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8)
{
  uint64_t v60 = 0;
  if (!a3[14])
  {
    sub_10004458C("ersb_recovery_extents_count is non-zero (%llu), but ersb_recovery_list_oid == 0\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a3[13]);
    uint64_t v17 = 92;
    uint64_t v18 = 720;
LABEL_11:
    sub_100048B34((char *)v18, 92);
    BOOL v16 = 0;
    goto LABEL_12;
  }
  unint64_t v9 = a3[15];
  if (!v9)
  {
    sub_10004458C("ersb_recovery_extents_count is non-zero (%llu), but ersb_recovery_length == 0\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a3[13]);
    uint64_t v17 = 92;
    uint64_t v18 = 721;
    goto LABEL_11;
  }
  if (v9 > 0x1400000)
  {
    sub_100044674("ersb_recovery_length (%llu) exceeds recovery length limit (%llu), some checks will be disabled\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a3[15]);
    unint64_t v14 = a3 + 13;
    uint64_t v13 = a3[13];
    if ((unint64_t)(48 * v13) <= a3[15])
    {
      uint64_t v58 = 48 * v13;
      uint64_t v59 = a4;
      BOOL v16 = 0;
      goto LABEL_18;
    }
    goto LABEL_10;
  }
  unint64_t v14 = a3 + 13;
  uint64_t v13 = a3[13];
  uint64_t v15 = 48 * v13;
  if (48 * v13 > v9)
  {
LABEL_10:
    sub_10004458C("ersb_recovery_extents_count is %llu, extent descriptor size is %zu, expected descriptors length is %llu > ersb_recovery_length %llu\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v13);
    uint64_t v17 = 92;
    uint64_t v18 = 722;
    goto LABEL_11;
  }
  BOOL v16 = (unint64_t *)malloc_type_calloc(1uLL, a3[15], 0xBDE67D17uLL);
  if (!v16)
  {
    sub_10004458C("error allocating encryption rolling recovery data buffer, ersb_recovery_length %llu\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, a3[15]);
    uint64_t v17 = 12;
    uint64_t v34 = 723;
    int v57 = 12;
    goto LABEL_81;
  }
  uint64_t v58 = v15;
  uint64_t v59 = a4;
LABEL_18:
  uint64_t v20 = a3[14];
  if (v20)
  {
    unint64_t v21 = 0;
    while (1)
    {
      if (v21 >= a3[15])
      {
        sub_10004458C("encryption rolling recovery data extends past recovery length, oid 0x%llx, ersb_recovery_length %llu, accumulated length %llu\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v20);
        uint64_t v17 = 92;
        uint64_t v34 = 728;
        goto LABEL_80;
      }
      uint64_t v22 = sub_1000257B4(a1, a2, 0x40000000, v20, 0, 0, 28, 0, (uint64_t **)&v60, 0, 1);
      if (v22)
      {
        uint64_t v17 = v22;
        sub_10004458C("could not retrieve erb, oid 0x%llx\n", v23, v24, v25, v26, v27, v28, v29, v20);
        uint64_t v34 = 724;
        int v57 = 2;
        goto LABEL_81;
      }
      uint64_t v30 = v60;
      if (v21 != *((void *)v60 + 4))
      {
        sub_10004458C("encryption rolling recovery block offset mismatch, oid 0x%llx, expected %llu, actual %llu\n", v23, v24, v25, v26, v27, v28, v29, v20);
        uint64_t v17 = 92;
        uint64_t v34 = 725;
        goto LABEL_80;
      }
      uint64_t v31 = *(unsigned int *)(a1[1] + 36);
      size_t v32 = v31 - 48 >= a3[15] - v21 ? a3[15] - v21 : v31 - 48;
      if (!v32) {
        break;
      }
      if (v9 <= 0x1400000)
      {
        memcpy((char *)v16 + v21, (char *)v60 + 48, v32);
        uint64_t v30 = v60;
      }
      uint64_t v20 = v30[5];
      v21 += v32;
      free(v30);
      uint64_t v60 = 0;
      if (!v20) {
        goto LABEL_32;
      }
    }
    sub_10004458C("encryption rolling recovery block with data size 0, oid 0x%llx, nx_block_size %u, recovery length %llu\n", v23, v24, v25, v26, v27, v28, v29, v20);
    uint64_t v17 = 92;
    uint64_t v34 = 726;
  }
  else
  {
    unint64_t v21 = 0;
LABEL_32:
    unint64_t v33 = a3[15];
    if (v21 >= v33)
    {
      uint64_t v35 = a3[5];
      unsigned int v36 = (v35 >> 8) & 0xF;
      if (v36 >= 7)
      {
        sub_10004458C("checksum block size is invalid, checksum_block_size enum: %llu\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, BYTE1(v35) & 0xF);
        uint64_t v17 = 92;
        uint64_t v34 = 729;
      }
      else
      {
        if (v9 > 0x1400000 || !*v14)
        {
LABEL_73:
          uint64_t v17 = 0;
          goto LABEL_12;
        }
        uint64_t v37 = 0;
        unint64_t v38 = qword_10006F3C0[v36];
        uint64_t v39 = v58;
        uint64_t v40 = a1[1];
        unint64_t v41 = *(unsigned int *)(v40 + 36);
        uint64_t v42 = a1[3];
        unint64_t v43 = 0x4000000000000000uLL >> __clz(__rbit64(v41));
        uint64_t v44 = v16 + 3;
        while (1)
        {
          if (v42)
          {
            unint64_t v45 = *(void *)(v42 + 48);
            unint64_t v46 = *(void *)(v42 + 96);
          }
          else
          {
            unint64_t v45 = *(void *)(v40 + 40);
            if (*(unsigned char *)(v40 + 65)) {
              unint64_t v46 = *(void *)(v40 + 40);
            }
            else {
              unint64_t v46 = 0;
            }
          }
          unint64_t v47 = *(v44 - 2);
          unint64_t v49 = *v44;
          unint64_t v48 = v44[1];
          if (!*v44 || v45 < 2 || v45 <= v49 || (--v45, v45 < v49))
          {
            if (v43 >= v49 || v46 < 2 || (unint64_t v45 = v46 | v43, (v46 | v43) <= v49) || (v46 = (v46 - 1) | v43, v46 < v49))
            {
              sub_10004458C("recovery extent #%llu: invalid fext_pbn (0x%llx)\n", v47, v48, v46, v49, v45, a7, v59, v37);
              uint64_t v17 = 92;
              uint64_t v34 = 730;
              goto LABEL_80;
            }
          }
          unint64_t v50 = *(v44 - 3);
          unint64_t v51 = *(unsigned __int8 *)(v40 + 65);
          if (v51)
          {
            if (v42)
            {
              unint64_t v45 = *(void *)(v42 + 48);
              unint64_t v52 = *(void *)(v42 + 96);
            }
            else
            {
              unint64_t v45 = *(void *)(v40 + 40);
              unint64_t v52 = v45;
            }
            if (!v50 || (a7 = v45 - v47, v45 <= v47) || v45 <= v50 || a7 < v50)
            {
              if (v43 >= v50
                || (unint64_t v45 = v52 - v47, v52 <= v47)
                || (v52 |= v43, v52 <= v50)
                || (unint64_t v52 = v45 | v43, (v45 | v43) < v50))
              {
                sub_10004458C("recovery extent #%llu: invalid Fusion prange (0x%llx+%llu)\n", v47, v48, v50, v52, v45, a7, v59, v37);
                uint64_t v17 = 92;
                uint64_t v34 = 731;
                goto LABEL_80;
              }
            }
          }
          else if (!v50 {
                 || (unint64_t v45 = *(void *)(v40 + 40), v51 = v45 * (v41 / v59), v51 <= v50)
          }
                 || v51 <= v47
                 || (v51 -= v47, v51 < v50))
          {
            sub_10004458C("recovery extent #%llu: invalid prange (0x%llx+%llu), dev_bsize %u\n", v47, v48, v50, v51, v45, a7, v59, v37);
            uint64_t v17 = 92;
            uint64_t v34 = 732;
            goto LABEL_80;
          }
          uint64_t v53 = v48 / v41;
          unint64_t v54 = *(void *)(v40 + 40);
          if (v48 / v41 >= v54)
          {
            sub_10004458C("recovery extent #%llu: fext_laddr (0x%llx) exceeds nx_block_count (%llu), fs_bsize %u\n", v47, v48, v54, v53, v45, a7, v59, v37);
            uint64_t v17 = 92;
            uint64_t v34 = 733;
            goto LABEL_80;
          }
          uint64_t v55 = 8 * (v47 * v59 / v38);
          uint64_t v56 = v55 + v39;
          if (v55 + v39 > v33)
          {
            sub_10004458C("recovery extent #%llu: checksums at offset %llu, length %llu exceed ersb_recovery_length %llu\n", v56, v55, v54, v53, v45, a7, v59, v37);
            uint64_t v17 = 92;
            uint64_t v34 = 734;
            goto LABEL_80;
          }
          if ((v35 & 0x20) != 0 && !v44[2]) {
            break;
          }
          v44 += 6;
          ++v37;
          v39 += v55;
          if (*v14 == v37) {
            goto LABEL_73;
          }
        }
        sub_10004458C("recovery extent #%llu: invalid ersb_flags (0x%llx), ERSB_FLAG_CID_IS_TWEAK is set but fext_cid == 0\n", v56, 0, v54, v53, v45, a7, v59, v37);
        uint64_t v17 = 92;
        uint64_t v34 = 735;
      }
    }
    else
    {
      sub_10004458C("missing encryption rolling recovery data, actual length %llu, ersb_recovery_length %llu\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, v21);
      uint64_t v17 = 92;
      uint64_t v34 = 727;
    }
  }
LABEL_80:
  int v57 = 92;
LABEL_81:
  sub_100048B34((char *)v34, v57);
LABEL_12:
  if (v60) {
    free(v60);
  }
  if (v16) {
    free(v16);
  }
  return v17;
}

unint64_t sub_10003D630(uint32x4_t *a1, unint64_t a2, unint64_t a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5 = a3;
  unint64_t v6 = HIDWORD(a3);
  if ((a2 & 3) == 0)
  {
    for (i = a2 >> 2; i; unint64_t v6 = v34 + HIDWORD(v34))
    {
      if (i >= 0x16A00) {
        uint64_t v8 = 92672;
      }
      else {
        uint64_t v8 = i;
      }
      i -= v8;
      int64x2_t v9 = (int64x2_t)veorq_s8(a4, a4);
      int64x2_t v10 = (int64x2_t)veorq_s8(a5, a5);
      v9.i64[0] = v5;
      v10.i64[0] = v6;
      if (v8 >= 16)
      {
        uint32x4_t v11 = *a1;
        uint32x4_t v12 = a1[1];
        uint32x4_t v13 = a1[2];
        uint32x4_t v14 = a1[3];
        a1 += 4;
        int64x2_t v15 = vshlq_n_s64(v9, 4uLL);
        uint64x2_t v16 = vmull_u32(*(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
        uint64x2_t v17 = vmull_u32(*(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008);
        int64x2_t v18 = (int64x2_t)vmlal_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v11.i8, (uint32x2_t)0xF00000010), *(uint32x2_t *)v14.i8, (uint32x2_t)0x300000004);
        uint64x2_t v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v11), v12), v13);
        BOOL v20 = v8 < 32;
        for (v8 -= 32; !v20; v8 -= 16)
        {
          uint64x2_t v21 = vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_10003D5F0);
          uint32x4_t v22 = *a1;
          a1 += 4;
          uint32x4_t v11 = v22;
          uint64x2_t v23 = vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_10003D5F0[2]);
          uint32x4_t v12 = a1[-3];
          int64x2_t v24 = (int64x2_t)vpadalq_u32(v19, v14);
          uint64x2_t v25 = vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_10003D5F0[4]);
          uint32x4_t v13 = a1[-2];
          uint64x2_t v26 = vmlal_high_u32(v21, v14, *(uint32x4_t *)&qword_10003D5F0[6]);
          uint32x4_t v14 = a1[-1];
          int64x2_t v15 = vshlq_n_s64(v24, 4uLL);
          uint64x2_t v16 = vmlal_u32(v26, *(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
          uint64x2_t v17 = vmlal_u32(v23, *(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008);
          int64x2_t v18 = (int64x2_t)vmlal_u32(vmlal_u32(v25, *(uint32x2_t *)v22.i8, (uint32x2_t)0xF00000010), *(uint32x2_t *)v14.i8, (uint32x2_t)0x300000004);
          uint64x2_t v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v24, v22), v12), v13);
          BOOL v20 = v8 < 16;
        }
        int64x2_t v9 = (int64x2_t)vpadalq_u32(v19, v14);
        int64x2_t v10 = vaddq_s64(vaddq_s64((int64x2_t)vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_10003D5F0[4]), (int64x2_t)vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_10003D5F0[2])), (int64x2_t)vmlal_high_u32(vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_10003D5F0), v14, *(uint32x4_t *)&qword_10003D5F0[6]));
      }
      if ((v8 & 8) != 0)
      {
        uint32x4_t v27 = *a1;
        a1 += 2;
        uint32x4_t v28 = a1[-1];
        int64x2_t v29 = vshlq_n_s64(v9, 3uLL);
        int64x2_t v9 = (int64x2_t)vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v27), v28);
        int64x2_t v10 = vaddq_s64((int64x2_t)vmlal_high_u32(vmlal_high_u32(vmlal_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v27.i8, (uint32x2_t)0x700000008), *(uint32x2_t *)v28.i8, (uint32x2_t)0x300000004), v27, *(uint32x4_t *)&qword_10003D5F0[4]), v28, *(uint32x4_t *)&qword_10003D5F0[6]), v29);
      }
      if ((v8 & 4) != 0)
      {
        uint32x4_t v30 = *a1++;
        int64x2_t v31 = vshlq_n_s64(v9, 2uLL);
        int64x2_t v9 = (int64x2_t)vpadalq_u32((uint64x2_t)v9, v30);
        int64x2_t v10 = vaddq_s64((int64x2_t)vmlal_high_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v30.i8, (uint32x2_t)0x300000004), v30, *(uint32x4_t *)&qword_10003D5F0[6]), v31);
      }
      uint64_t v32 = v8 & 3;
      a4 = (int8x16_t)vpaddq_s64(v9, v9);
      a5 = (int8x16_t)vpaddq_s64(v10, v10);
      unint64_t v33 = a4.i64[0];
      unint64_t v34 = a5.i64[0];
      if (v32)
      {
        do
        {
          unsigned __int32 v35 = a1->i32[0];
          a1 = (uint32x4_t *)((char *)a1 + 4);
          v33 += v35;
          v34 += v33;
          BOOL v20 = v32-- <= 1;
        }
        while (!v20);
      }
      unint64_t v5 = v33 + HIDWORD(v33);
    }
  }
  unint64_t v36 = v5 + HIDWORD(v5);
  unint64_t v37 = v6 + HIDWORD(v6);
  if (v36 == 0xFFFFFFFF) {
    unint64_t v36 = 0;
  }
  if (v37 == 0xFFFFFFFF) {
    unint64_t v37 = 0;
  }
  return v36 + (v37 << 32);
}

unint64_t sub_10003D7D8(unint64_t *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t result = sub_10003D630(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(result)
      + result
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(result) + result) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  *a1 = v8 | ((unint64_t)~(v8
                                + result
                                + ((unint64_t)(((v8 + result)
                                                                   * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) << 32);
  return result;
}

unint64_t sub_10003D848(void *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t v7 = sub_10003D630(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(v7)
      + v7
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(v7) + v7) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  return (v8 | ((unint64_t)~(v8
                                  + v7
                                  + ((unint64_t)(((v8 + v7)
                                                                     * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) << 32)) ^ *a1;
}

const char *sub_10003D8BC(unsigned int a1)
{
  unint64_t result = "unknown";
  if (a1 <= 0x13 && (a1 & 0xFFFFFFFE) != 0xE) {
    return off_1000706C0[a1];
  }
  return result;
}

const char *sub_10003D8EC(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)a1 >> 60;
  if (v2 == 14) {
    LODWORD(v2) = *(unsigned __int8 *)(a1 + 8);
  }
  unint64_t result = "unknown";
  switch((int)v2)
  {
    case 9:
      if ((a2 - 3) >= 0xFFFFFFFE)
      {
        uint64_t v4 = &unk_100070808;
        goto LABEL_19;
      }
      break;
    case 10:
    case 11:
    case 12:
    case 14:
    case 15:
    case 17:
      return result;
    case 13:
      if (a2 == 1) {
        unint64_t result = "FILE_INFO_TAG_EXT_TYPE_SIGNING_ID";
      }
      break;
    case 16:
      if ((a2 - 3) >= 0xFFFFFFFE)
      {
        uint64_t v4 = &unk_100070820;
        goto LABEL_19;
      }
      break;
    case 18:
      if ((a2 - 5) >= 0xFFFFFFFC)
      {
        uint64_t v4 = &unk_100070838;
        goto LABEL_19;
      }
      break;
    case 19:
      if ((a2 - 3) >= 0xFFFFFFFE)
      {
        uint64_t v4 = &unk_100070860;
        goto LABEL_19;
      }
      break;
    default:
      if (v2 == 3 && (a2 - 21) >= 0xFFFFFFEC)
      {
        uint64_t v4 = &unk_100070760;
LABEL_19:
        unint64_t result = (const char *)v4[a2];
      }
      break;
  }
  return result;
}

uint64_t sub_10003D9FC(uint64_t a1, unint64_t *a2, unsigned int a3, unsigned int *a4)
{
  if (!a2) {
    return 22;
  }
  if (a3 < 8) {
    return 92;
  }
  unint64_t v4 = *a2;
  if (a3 <= 0xB && (v4 & 0xF000000000000000) == 0xE000000000000000) {
    return 92;
  }
  unint64_t v6 = v4 >> 60;
  if (v6 == 14)
  {
    LODWORD(v6) = *((unsigned __int8 *)a2 + 8);
    if (v6 > 0x13)
    {
      int v10 = 0;
      unsigned int v8 = 8;
      goto LABEL_33;
    }
  }
  int v7 = v6;
  if ((0xC201uLL >> v6)) {
    unsigned int v8 = 8;
  }
  else {
    unsigned int v8 = dword_10006F3F8[v6];
  }
  BOOL v9 = v7 != 4 || v8 > a3;
  if (!v9 || v7 == 11 && v8 <= a3)
  {
    int v10 = *((unsigned __int16 *)a2 + 4);
    goto LABEL_33;
  }
  if (v7 != 9)
  {
    int v10 = 0;
    goto LABEL_33;
  }
  if (!a1) {
    return 22;
  }
  if ((*(unsigned char *)(a1 + 56) & 9) != 0)
  {
    if (a3 < 0xC) {
      int v10 = 0;
    }
    else {
      int v10 = a2[1] & 0x3FF;
    }
    unsigned int v8 = 12;
  }
  else
  {
    if (a3 < 0xA) {
      int v10 = 0;
    }
    else {
      int v10 = *((unsigned __int16 *)a2 + 4);
    }
    unsigned int v8 = 10;
  }
LABEL_33:
  if (a4) {
    *a4 = v8;
  }
  if (v8 + v10 <= a3) {
    return 0;
  }
  else {
    return 92;
  }
}

uint64_t sub_10003DB18(uint64_t a1, unsigned __int16 *a2, unsigned int a3, unsigned int *a4)
{
  if (!a2) {
    return 22;
  }
  uint64_t v4 = *(void *)a1 >> 60;
  if (v4 == 14)
  {
    LODWORD(v4) = *(unsigned __int8 *)(a1 + 8);
    if (v4 > 0x13)
    {
      unsigned int v5 = 0;
      int v11 = 0;
      BOOL v6 = 0;
LABEL_26:
      switch((int)v4)
      {
        case 1:
          int v12 = a2[24];
          break;
        case 3:
          if (a3 - v5 < 4) {
            goto LABEL_33;
          }
          int v12 = a2[47];
          break;
        case 4:
          int v12 = a2[1];
          break;
        case 5:
          int v12 = a2[4];
          break;
        case 7:
          int v12 = a2[11];
          break;
        case 9:
          if (a3 - v5 < 4) {
            goto LABEL_33;
          }
          int v12 = a2[10];
          break;
        default:
LABEL_33:
          if (v6)
          {
            if (v11 == 2)
            {
              if (a3 - v5 < 4) {
                goto LABEL_19;
              }
              int v12 = a2[14];
            }
            else
            {
              if (v11 != 1) {
                goto LABEL_19;
              }
              int v12 = *((unsigned __int8 *)a2 + 2);
            }
          }
          else
          {
            unsigned int v13 = a3 - v5;
            if (a3 - v5 >= 4 && v4 == 16)
            {
              int v12 = a2[13];
            }
            else if (v13 >= 4 && v4 == 18)
            {
              int v12 = a2[27];
            }
            else
            {
              int v12 = 0;
              if (v13 >= 4 && v4 == 19) {
                int v12 = a2[5];
              }
            }
          }
          break;
      }
      goto LABEL_20;
    }
  }
  unsigned int v5 = dword_10006F448[v4];
  BOOL v6 = v4 == 13;
  if (v4 == 13)
  {
    uint64_t v7 = HIBYTE(*(void *)(a1 + 8));
    if (v7 == 2) {
      int v8 = 2;
    }
    else {
      int v8 = HIBYTE(*(void *)(a1 + 8));
    }
    if (v7 == 2) {
      unsigned int v5 = 26;
    }
    BOOL v9 = v7 == 1;
    if (v7 == 1) {
      int v11 = 1;
    }
    else {
      int v11 = v8;
    }
    if (v9) {
      unsigned int v5 = 3;
    }
  }
  else
  {
    int v11 = 0;
  }
  if (v5 <= a3) {
    goto LABEL_26;
  }
LABEL_19:
  int v12 = 0;
LABEL_20:
  if (a4) {
    *a4 = v5;
  }
  if (v12 + v5 <= a3) {
    return 0;
  }
  else {
    return 92;
  }
}

uint64_t sub_10003DCD8(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t sub_10003DD34(uint64_t a1, unint64_t *a2, unsigned int a3, unint64_t *a4, unsigned int a5, int *a6)
{
  if (a1 && *(_WORD *)(a1 + 24) != 13) {
    return 22;
  }
  uint64_t v11 = 22;
  if (a3 >= 8 && a5 >= 8)
  {
    if (sub_10003D9FC(a1, a2, a3, 0) || sub_10003D9FC(a1, a4, a5, 0)) {
      return 22;
    }
    unint64_t v13 = *a2 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v14 = *a4 & 0xFFFFFFFFFFFFFFFLL;
    if (v13 < v14) {
      goto LABEL_10;
    }
    if (v13 <= v14)
    {
      unint64_t v16 = *a2 >> 60;
      if (v16 == 14) {
        LODWORD(v--*(_DWORD *)(result + 16) = *((unsigned __int8 *)a2 + 8);
      }
      unint64_t v17 = *a4 >> 60;
      if (v17 == 14) {
        LODWORD(v17) = *((unsigned __int8 *)a4 + 8);
      }
      if (!v16)
      {
        BOOL v18 = v17 == 0;
LABEL_24:
        if (v18) {
          int v15 = 0;
        }
        else {
          int v15 = -1;
        }
        goto LABEL_27;
      }
      if (v17)
      {
        if (v16 < v17)
        {
LABEL_10:
          int v15 = -1;
LABEL_27:
          uint64_t v11 = 0;
          *a6 = v15;
          return v11;
        }
        if (v16 <= v17)
        {
          uint64_t v11 = 45;
          switch((int)v16)
          {
            case 1:
            case 2:
            case 3:
            case 6:
            case 7:
            case 10:
            case 12:
            case 18:
              goto LABEL_22;
            case 4:
            case 11:
              goto LABEL_40;
            case 5:
              unint64_t v19 = a2[1];
              unint64_t v20 = a4[1];
              if (!v19) {
                goto LABEL_56;
              }
              if (!v20) {
                break;
              }
              goto LABEL_33;
            case 8:
              unint64_t v19 = a2[1];
              unint64_t v20 = a4[1];
              if (v19 == -1)
              {
                BOOL v18 = v20 == -1;
                goto LABEL_24;
              }
              if (v20 == -1) {
                break;
              }
LABEL_33:
              BOOL v21 = v19 > v20;
              if (v19 >= v20) {
                goto LABEL_52;
              }
              goto LABEL_10;
            case 9:
              if (!a1) {
                return 22;
              }
              if ((*(unsigned char *)(a1 + 56) & 9) == 0)
              {
LABEL_40:
                uint64_t v26 = (uint64_t)a2 + 10;
                unint64_t v24 = *((unsigned __int16 *)a2 + 4);
                uint64_t v27 = (uint64_t)a4 + 10;
                unint64_t v25 = *((unsigned __int16 *)a4 + 4);
                goto LABEL_41;
              }
              unsigned int v22 = *((_DWORD *)a2 + 2);
              unsigned int v23 = *((_DWORD *)a4 + 2);
              if (v22 >> 10 < v23 >> 10) {
                goto LABEL_10;
              }
              if (v22 >> 10 <= v23 >> 10)
              {
                unint64_t v24 = v22 & 0x3FF;
                unint64_t v25 = v23 & 0x3FF;
                uint64_t v26 = (uint64_t)a2 + 12;
                uint64_t v27 = (uint64_t)a4 + 12;
LABEL_41:
                int v15 = sub_10003E034(v26, v24, v27, v25);
                goto LABEL_27;
              }
              break;
            case 13:
              unint64_t v36 = a2[1];
              unint64_t v37 = HIBYTE(v36);
              unint64_t v38 = a4[1];
              unint64_t v39 = HIBYTE(v38);
              if (!HIBYTE(v36))
              {
                BOOL v18 = v39 == 0;
                goto LABEL_24;
              }
              if (!v39) {
                break;
              }
              if (v37 != v39)
              {
                if (v37 < v39) {
                  int v15 = -1;
                }
                else {
                  int v15 = 1;
                }
                goto LABEL_27;
              }
              unint64_t v40 = v36 & 0xFFFFFFFFFFFFFFLL;
              unint64_t v41 = v38 & 0xFFFFFFFFFFFFFFLL;
              if (v40 == 0xFFFFFFFFFFFFFFLL)
              {
                BOOL v18 = v41 == 0xFFFFFFFFFFFFFFLL;
                goto LABEL_24;
              }
              if (v41 == 0xFFFFFFFFFFFFFFLL) {
                break;
              }
              BOOL v21 = v40 > v41;
              if (v40 < v41) {
                goto LABEL_10;
              }
              goto LABEL_52;
            case 16:
              unint64_t v28 = *(unint64_t *)((char *)a2 + 12);
              unint64_t v20 = *(unint64_t *)((char *)a4 + 12);
              if (!v28)
              {
LABEL_56:
                BOOL v18 = v20 == 0;
                goto LABEL_24;
              }
              if (!v20) {
                break;
              }
              BOOL v29 = v28 > v20;
              if (v28 < v20) {
                goto LABEL_10;
              }
LABEL_50:
              if (v29) {
                break;
              }
              unint64_t v34 = *(unint64_t *)((char *)a2 + 20);
              unint64_t v35 = *(unint64_t *)((char *)a4 + 20);
              BOOL v21 = v34 > v35;
              if (v34 < v35) {
                goto LABEL_10;
              }
LABEL_52:
              if (!v21)
              {
LABEL_22:
                int v15 = 0;
                goto LABEL_27;
              }
              break;
            case 17:
              unint64_t v30 = *(unint64_t *)((char *)a2 + 12);
              unint64_t v31 = *(unint64_t *)((char *)a4 + 12);
              if (v30 < v31) {
                goto LABEL_10;
              }
              if (v30 == v31) {
                goto LABEL_22;
              }
              BOOL v21 = v30 > v31;
              goto LABEL_52;
            case 19:
              unint64_t v32 = *(unint64_t *)((char *)a2 + 12);
              unint64_t v33 = *(unint64_t *)((char *)a4 + 12);
              BOOL v29 = v32 > v33;
              if (v32 < v33) {
                goto LABEL_10;
              }
              goto LABEL_50;
            default:
              return v11;
          }
        }
      }
    }
    int v15 = 1;
    goto LABEL_27;
  }
  return v11;
}

uint64_t sub_10003E034(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a2 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a2;
  }
  if (!v4 || (unint64_t v5 = v4 - 1, v4 == 1))
  {
LABEL_13:
    if (a2 < a4) {
      return 0xFFFFFFFFLL;
    }
    else {
      return a2 > a4;
    }
  }
  else
  {
    unint64_t v6 = 0;
    while (1)
    {
      int v7 = *(unsigned __int8 *)(a1 + v6);
      uint64_t v8 = v7 - *(unsigned __int8 *)(a3 + v6);
      if (v8) {
        break;
      }
      ++v6;
      if (v7) {
        BOOL v9 = v6 >= v5;
      }
      else {
        BOOL v9 = 1;
      }
      if (v9) {
        goto LABEL_13;
      }
    }
  }
  return v8;
}

uint64_t sub_10003E098(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned __int8 a5, uint64_t a6, unint64_t a7)
{
  v52[1] = (void *)0xAAAAAAAAAAAAAAAALL;
  v47[0] = 0;
  v47[1] = a3;
  unint64_t v49 = 0xAAAAAAAA00000EE0;
  uint64_t v50 = a6;
  long long v51 = a7;
  v52[0] = 0;
  LOWORD(v52[1]) = a5;
  unint64_t v48 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x6794A04DuLL);
  if (v48)
  {
    uint64_t v18 = sub_10002D3D4(a1, (uint64_t)a2, v47);
    if (v18)
    {
      uint64_t v26 = v18;
      sub_10004458C("failed to init fsroot tree for lookup in directory\n", v19, v20, v21, v22, v23, v24, v25, v42);
      uint64_t v27 = 1285;
    }
    else
    {
      uint64_t v28 = sub_10003E324((uint64_t)&v51 + 8, a4);
      if (!v28)
      {
        while (1)
        {
          unsigned int v37 = DWORD2(v51) - 1;
          if (SDWORD2(v51) < 1) {
            break;
          }
          --DWORD2(v51);
          unint64_t v45 = *((void *)v52[0] + v37) & 0xFFFFFFFFFFFFFFFLL | 0x9000000000000000;
          __int16 v46 = 0;
          unint64_t v43 = v45;
          int v44 = 0;
          uint64_t v38 = *(void *)(a2[5] + 56);
          if ((v38 & 9) != 0) {
            unint64_t v39 = (unsigned __int8 *)&v43;
          }
          else {
            unint64_t v39 = (unsigned __int8 *)&v45;
          }
          if ((v38 & 9) != 0) {
            uint64_t v40 = 12;
          }
          else {
            uint64_t v40 = 10;
          }
          uint64_t v41 = sub_10003E3C4(a1, a2, a3, 1, v39, v40, (uint64_t (*)(void))sub_10003E5AC, (uint64_t)v47);
          if (v41) {
            return v41;
          }
        }
        uint64_t v26 = 0;
        goto LABEL_8;
      }
      uint64_t v26 = v28;
      sub_10004458C("failed to allocate dir-stack memory for lookup in directory\n", v29, v30, v31, v32, v33, v34, v35, v42);
      uint64_t v27 = 1286;
    }
    sub_100048B34((char *)v27, v26);
LABEL_8:
    if (v48) {
      free(v48);
    }
    goto LABEL_10;
  }
  sub_10004458C("failed to allocate memory for lookup in directory\n", v11, v12, v13, v14, v15, v16, v17, v42);
  uint64_t v26 = 12;
  sub_100048B34((char *)0x504, 12);
LABEL_10:
  if (v52[0]) {
    free(v52[0]);
  }
  return v26;
}

uint64_t sub_10003E25C(uint64_t a1, void *a2, int a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a3)
  {
    case 1:
    case 11:
      return sub_10002D180(a1, (uint64_t)a2, a4);
    case 2:
      return sub_10002D238(a1, (uint64_t)a2, a4);
    case 3:
    case 4:
    case 5:
    case 9:
    case 10:
    case 12:
    case 13:
      goto LABEL_2;
    case 6:
    case 7:
    case 18:
    case 19:
      goto LABEL_8;
    case 8:
      uint64_t v9 = a2[6];
      if (!v9) {
        uint64_t v9 = a2[5];
      }
      if ((*(unsigned char *)(v9 + 56) & 0x20) != 0)
      {
        uint64_t result = sub_10002D2F0(a1, a2, a4, (uint64_t)a4, a5, a6, a7, a8);
      }
      else
      {
LABEL_8:
        if (*(void *)(a2[5] + 1096)) {
          uint64_t result = sub_10002D4A8(a1, (uint64_t)a2, a4);
        }
        else {
LABEL_2:
        }
          uint64_t result = sub_10002D3D4(a1, (uint64_t)a2, a4);
      }
      break;
    default:
      uint64_t result = 22;
      break;
  }
  return result;
}

uint64_t sub_10003E324(uint64_t a1, uint64_t a2)
{
  int v5 = *(_DWORD *)a1;
  int v4 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)a1 >= v4)
  {
    if (v5 > 4095) {
      return 12;
    }
    int v7 = v4 ? 2 * v4 : 32;
    unint64_t v6 = malloc_type_realloc(*(void **)(a1 + 8), 8 * v7, 0x100004000313F17uLL);
    if (!v6) {
      return 12;
    }
    *(void *)(a1 + 8) = v6;
    *(_DWORD *)(a1 + 4) = v7;
    int v5 = *(_DWORD *)a1;
  }
  else
  {
    unint64_t v6 = *(void **)(a1 + 8);
  }
  uint64_t v8 = 0;
  *(_DWORD *)a1 = v5 + 1;
  v6[v5] = a2;
  return v8;
}

uint64_t sub_10003E3C4(uint64_t a1, void *a2, uint64_t a3, int a4, unsigned __int8 *a5, uint64_t a6, uint64_t (*a7)(void), uint64_t a8)
{
  unsigned int v9 = a6;
  uint64_t v13 = *(void *)a5 >> 60;
  if (v13 == 14) {
    LODWORD(v13) = a5[8];
  }
  uint64_t v48 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v14 = sub_10003E25C(a1, a2, v13, &v48, (uint64_t)a5, a6, (uint64_t)a7, a8);
  if (v14)
  {
    uint64_t v15 = v14;
    char v16 = strerror(v14);
    sub_10004458C("unable to init fsroot tree: %s\n", v17, v18, v19, v20, v21, v22, v23, v16);
    uint64_t v24 = 1085;
LABEL_7:
    sub_100048B34((char *)v24, v15);
    return v15;
  }
  *(void *)&long long v25 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v25 + 1) = 0xAAAAAAAAAAAAAAAALL;
  long long v46 = v25;
  long long v47 = v25;
  long long v44 = v25;
  long long v45 = v25;
  long long v43 = v25;
  uint64_t v26 = sub_100038D78((uint64_t)&v43, v48, a3, a5, v9);
  if (v26)
  {
    uint64_t v15 = v26;
    char v27 = strerror(v26);
    sub_10004458C("unable to init fsroot tree iterator: %s\n", v28, v29, v30, v31, v32, v33, v34, v27);
    uint64_t v24 = 1086;
    goto LABEL_7;
  }
  if ((void)v44)
  {
    uint64_t v36 = *(void *)a5 >> 60;
    if (v36 == 14) {
      LODWORD(v36) = a5[8];
    }
    uint64_t v37 = *(void *)v44 >> 60;
    if (v37 == 14) {
      LODWORD(v37) = *(unsigned __int8 *)(v44 + 8);
    }
    BOOL v38 = v36 == v37;
  }
  else
  {
    BOOL v38 = 0;
  }
  LODWORD(v15) = 0;
  if (!BYTE8(v45))
  {
    int v39 = a4 ^ 1;
    if (v38 | v39)
    {
      while (1)
      {
        if (v38)
        {
          int v40 = a7();
          if (v40) {
            break;
          }
        }
        int v40 = (*((uint64_t (**)(long long *))&v43 + 1))(&v43);
        if (v40) {
          break;
        }
        if ((void)v44)
        {
          uint64_t v41 = *(void *)a5 >> 60;
          if (v41 == 14) {
            LODWORD(v41) = a5[8];
          }
          uint64_t v42 = *(void *)v44 >> 60;
          if (v42 == 14) {
            LODWORD(v42) = *(unsigned __int8 *)(v44 + 8);
          }
          BOOL v38 = v41 == v42;
        }
        else
        {
          BOOL v38 = 0;
        }
        LODWORD(v15) = 0;
        if (BYTE8(v45) || ((v38 | v39) & 1) == 0) {
          goto LABEL_32;
        }
      }
      LODWORD(v15) = v40;
    }
  }
LABEL_32:
  if ((void)v43) {
    ((void (*)(long long *))v43)(&v43);
  }
  if (v15 == -1) {
    return 0;
  }
  else {
    return v15;
  }
}

uint64_t sub_10003E5AC(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v47 = 8;
  uint64_t v7 = *(void *)(a5 + 8);
  uint64_t v8 = *(_WORD **)(a5 + 16);
  uint64_t v48 = *a3 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
  *(_DWORD *)(a5 + 24) = 3808;
  uint64_t v9 = sub_1000380B0(*(void *)a5, v7, 0, &v48, &v47, 8u, v8, (unsigned int *)(a5 + 24));
  if (v9)
  {
    uint64_t v10 = v9;
    uint64_t v11 = 0;
    if (v9 != 2)
    {
      uint64_t v12 = *a3;
      strerror(v9);
      sub_10004458C("unable to load inode (oid 0x%llx) for lookup in purgatory directory: %s\n", v13, v14, v15, v16, v17, v18, v19, v12);
      sub_100048B34((char *)0x501, v10);
      return v10;
    }
  }
  else
  {
    uint64_t v20 = (*(uint64_t (**)(uint64_t *, void, _WORD *, void, void))(a5 + 32))(&v48, v47, v8, *(unsigned int *)(a5 + 24), *(void *)(a5 + 40));
    if (!v20)
    {
      if ((v8[40] & 0xF000) == 0x4000)
      {
        uint64_t v11 = sub_10003E324(a5 + 48, *a3);
        if (!v11) {
          return v11;
        }
        sub_100048B34((char *)0x503, v11);
        if (!*(unsigned char *)(a5 + 64))
        {
          sub_10004458C("failed to allocate dir-stack memory for lookup in directory\n", v22, v23, v24, v25, v26, v27, v28, v46);
          return v11;
        }
        if (!*(unsigned char *)(a5 + 65))
        {
          char v38 = strerror(v11);
          sub_100044674("failed to allocate dir-stack memory for lookup in directory: %s; results may be incomplete\n",
            v39,
            v40,
            v41,
            v42,
            v43,
            v44,
            v45,
            v38);
          uint64_t v11 = 0;
          *(unsigned char *)(a5 + 65) = 1;
          return v11;
        }
      }
      return 0;
    }
    uint64_t v11 = v20;
    if (v20 == -1)
    {
      uint64_t v21 = *(void **)(a5 + 56);
      if (v21) {
        free(v21);
      }
      *(void *)(a5 + 48) = 0;
      *(void *)(a5 + 56) = 0;
      return 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v29 = *a3;
      strerror(v20);
      sub_10004458C("failed to run predicate callback on inode (oid 0x%llx) for lookup in directory: %s\n", v30, v31, v32, v33, v34, v35, v36, v29);
      sub_100048B34((char *)0x502, v11);
    }
  }
  return v11;
}

uint64_t sub_10003E760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  uint64_t v104 = 0;
  unsigned int v101 = 3808;
  unsigned int v102 = 8;
  *a5 = 0;
  if (!a4) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v10 = malloc_type_calloc(1uLL, 0xEE0uLL, 0xDF77FDE3uLL);
  if (!v10)
  {
    sub_10004458C("failed to allocate memory for file lookup in purgatory directory\n", v11, v12, v13, v14, v15, v16, v17, v98);
    uint64_t v27 = 12;
    sub_100048B34((char *)0x32C, 12);
    return v27;
  }
  uint64_t v18 = v10;
  uint64_t v103 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v19 = sub_10002D3D4(a1, a2, &v104);
  if (v19)
  {
    uint64_t v27 = v19;
    sub_10004458C("failed to init fsroot tree for file lookup in purgatory directory\n", v20, v21, v22, v23, v24, v25, v26, v98);
    sub_100048B34((char *)0x325, v27);
    goto LABEL_55;
  }
  if ((unint64_t)(v6 - 3) > 0xFFFFFFFFFFFFFFFDLL)
  {
LABEL_54:
    uint64_t v27 = 0;
    goto LABEL_55;
  }
  unint64_t v28 = 0;
  uint64_t v99 = a3;
  while (1)
  {
    uint64_t v29 = malloc_type_calloc(1uLL, 0x340uLL, 0xDECCF7BFuLL);
    uint64_t v30 = malloc_type_calloc(1uLL, 0xEE0uLL, 0x3BD1BAC2uLL);
    char v38 = v30;
    if (!v29 || !v30)
    {
      sub_10004458C("failed to allocate memory for file lookup in purgatory directory\n", v31, v32, v33, v34, v35, v36, v37, v98);
      uint64_t v27 = 12;
      sub_100048B34((char *)0x32B, 12);
      if (!v29)
      {
        if (!v38) {
          goto LABEL_16;
        }
LABEL_15:
        free(v38);
        goto LABEL_16;
      }
      goto LABEL_51;
    }
    unint64_t v100 = v28;
    *(void *)&long long v39 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v39 + 1) = 0xAAAAAAAAAAAAAAAALL;
    long long v112 = v39;
    long long v113 = v39;
    *(_OWORD *)__str = v39;
    long long v111 = v39;
    snprintf(__str, 0x40uLL, "0x%llx-dead", v6);
    uint64_t v107 = 0;
    unint64_t v40 = *(void *)(*(void *)(a2 + 40) + 56);
    unsigned int v106 = 18;
    size_t v41 = strlen(__str);
    *a5 = 0;
    uint64_t v42 = sub_10002D3D4(a1, a2, &v107);
    if (v42)
    {
      uint64_t v27 = v42;
      sub_10004458C("failed to init fsroot tree for file lookup in directory\n", v43, v44, v45, v46, v47, v48, v49, v98);
      sub_100048B34((char *)0x329, v27);
      a3 = v99;
      unint64_t v28 = v100;
      goto LABEL_51;
    }
    __int16 v79 = v41 + 1;
    *(void *)uint64_t v29 = 0x9000000000000003;
    if ((v40 & 9) != 0)
    {
      int v105 = -1;
      if (sub_1000053B0((unint64_t)__str, v41, (v40 >> 3) & 1, (void (*)(_OWORD *, uint64_t, uint64_t))sub_10003F66C, (uint64_t)&v105))
      {
        a3 = v99;
        unint64_t v28 = v100;
        goto LABEL_46;
      }
      __memcpy_chk();
      _OWORD v29[2] = v79 & 0x3FF | (v105 << 10);
      int v80 = v41 + 13;
    }
    else
    {
      __memcpy_chk();
      *((_WORD *)v29 + 4) = v79;
      int v80 = v41 + 11;
    }
    LODWORD(v109) = v80;
    a3 = v99;
    uint64_t v81 = sub_1000380B0(v107, v99, 0, v29, (unsigned int *)&v109, 0x340u, v38, &v106);
    unint64_t v28 = v100;
    if (v81 != 2)
    {
      uint64_t v27 = v81;
      if (v81)
      {
        strerror(v81);
        sub_10004458C("unable to load drec (oid 0x%llx) for file lookup in directory\n: %s\n", v82, v83, v84, v85, v86, v87, v88, 3);
        sub_100048B34((char *)0x321, v27);
        goto LABEL_51;
      }
      *a5 = 1;
      goto LABEL_47;
    }
LABEL_46:
    if (!*a5) {
      goto LABEL_48;
    }
LABEL_47:
    if (*v38 == v6)
    {
LABEL_48:
      uint64_t v27 = 0;
      goto LABEL_51;
    }
    uint64_t v27 = 0;
    *a5 = 0;
LABEL_51:
    free(v29);
    if (v38) {
      goto LABEL_15;
    }
LABEL_16:
    if (v27) {
      goto LABEL_55;
    }
    if (*a5) {
      goto LABEL_54;
    }
    uint64_t v109 = 0xAAAAAAAAAAAAAAAALL;
    long long v113 = 0u;
    long long v114 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    *(_OWORD *)__str = 0u;
    uint64_t v107 = 0x9000000000000003;
    int v108 = 0;
    *a5 = 0;
    uint64_t v50 = sub_10002D3D4(a1, a2, &v109);
    if (v50)
    {
      uint64_t v27 = v50;
      sub_10004458C("failed to init fsroot tree for file lookup in directory\n", v51, v52, v53, v54, v55, v56, v57, v98);
      uint64_t v58 = 810;
LABEL_22:
      sub_100048B34((char *)v58, v27);
      goto LABEL_23;
    }
    uint64_t v59 = sub_100038D78((uint64_t)__str, v109, a3, &v107, 0xCu);
    if (v59)
    {
      uint64_t v27 = v59;
      char v60 = strerror(v59);
      sub_10004458C("unable to initialize fsroot tree iterator for file lookup in directory: %s\n", v61, v62, v63, v64, v65, v66, v67, v60);
      uint64_t v58 = 803;
      goto LABEL_22;
    }
    while (1)
    {
      if (BYTE8(v112) || *(void *)v111 != 0x9000000000000003)
      {
        uint64_t v27 = 0;
        goto LABEL_23;
      }
      if (**((void **)&v111 + 1) == v6) {
        break;
      }
      uint64_t v70 = (*(uint64_t (**)(char *))&__str[8])(__str);
      if (v70)
      {
        uint64_t v27 = v70;
        char v71 = strerror(v70);
        sub_10004458C("error iterating fsroot tree for file lookup in directory: %s\n", v72, v73, v74, v75, v76, v77, v78, v71);
        uint64_t v58 = 804;
        goto LABEL_22;
      }
    }
    uint64_t v27 = 0;
    *a5 = 1;
LABEL_23:
    if (*(void *)__str) {
      (*(void (**)(char *))__str)(__str);
    }
    if (v27) {
      goto LABEL_55;
    }
    if (*a5) {
      goto LABEL_54;
    }
    uint64_t v103 = v6 & 0xFFFFFFFFFFFFFFFLL | 0x3000000000000000;
    unsigned int v101 = 3808;
    uint64_t v68 = sub_1000380B0(v104, a3, 0, &v103, &v102, v102, v18, &v101);
    if (v68) {
      break;
    }
    uint64_t v27 = 0;
    uint64_t v6 = *v18;
    if ((unint64_t)(*v18 - 3) <= 0xFFFFFFFFFFFFFFFDLL && v28++ < 0x1FF) {
      continue;
    }
    goto LABEL_55;
  }
  uint64_t v90 = v68;
  uint64_t v27 = 0;
  if (v68 != 2)
  {
    strerror(v68);
    sub_10004458C("unable to load inode (oid 0x%llx) for file lookup in purgatory directory: %s\n", v91, v92, v93, v94, v95, v96, v97, v6);
    sub_100048B34((char *)0x322, v90);
    uint64_t v27 = v90;
  }
LABEL_55:
  free(v18);
  return v27;
}

uint64_t sub_10003EC9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a4) {
    return sub_100038040(a1, a2, a3, *(_DWORD *)(*(void *)(a3 + 40) + 120) & 0xC0000000, (unsigned __int16)*(_DWORD *)(*(void *)(a3 + 40) + 120), 15, 0, *(_DWORD *)(*(void *)(a2 + 8) + 36), 0, 0, 0, *(void *)(*(void *)(a3 + 40) + 144), (uint64_t)sub_10003DD34);
  }
  uint64_t v31 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v8 = sub_10002D180(a2, a3, &v31);
  if (!v8)
  {
    uint64_t v9 = malloc_type_malloc(0x340uLL, 0x13F21D80uLL);
    uint64_t v10 = malloc_type_malloc(0xEE0uLL, 0x2A555787uLL);
    uint64_t v18 = v10;
    if (v9 && v10)
    {
      *uint64_t v9 = a4 & 0xFFFFFFFFFFFFFFFLL | 0x1000000000000000;
      unsigned int v29 = 3808;
      unsigned int v30 = 8;
      uint64_t v19 = sub_1000380B0(v31, 0, 0, v9, &v30, 0x340u, v10, &v29);
      if (v19)
      {
        uint64_t v8 = v19;
        strerror(v19);
        sub_10004458C("failed to lookup extentref tree oid at snap_xid %llu : %s\n", v20, v21, v22, v23, v24, v25, v26, a4);
      }
      else
      {
        uint64_t v8 = sub_100038040(a1, a2, a3, v18[10] & 0xC0000000, (unsigned __int16)v18[10], 15, 0, *(_DWORD *)(*(void *)(a2 + 8) + 36), 0, 0, 0, *(void *)v18, (uint64_t)sub_10003DD34);
      }
    }
    else
    {
      sub_10004458C("failed to allocate memory for the extentref tree\n", v11, v12, v13, v14, v15, v16, v17, v28);
      uint64_t v8 = 12;
      if (!v9)
      {
LABEL_12:
        if (v18) {
          free(v18);
        }
        return v8;
      }
    }
    free(v9);
    goto LABEL_12;
  }
  return v8;
}

uint64_t sub_10003EE64(unsigned __int16 *a1, unsigned int a2, int a3, void *a4, _WORD *a5, _DWORD *a6, unsigned int *a7)
{
  if (a2 < 4) {
    return 92;
  }
  uint64_t v7 = *a1;
  if (!*a1) {
    return 2;
  }
  if (a1[1] + 4 * v7 + 4 > a2) {
    return 92;
  }
  uint64_t v9 = 0;
  unsigned int v10 = 0;
  for (unint64_t i = a1 + 3; ; i += 2)
  {
    uint64_t v12 = *i;
    if (*((unsigned __int8 *)i - 2) == a3) {
      break;
    }
    v10 += (v12 + 7) & 0x1FFF8;
    if (v7 == ++v9) {
      return 2;
    }
  }
  uint64_t v13 = a1[1];
  if (v12 > v13 || v13 - v12 < v10) {
    return 92;
  }
  if (a4) {
    *a4 = (char *)&a1[2 * v7 + 2] + v10;
  }
  if (a5) {
    *a5 = v12;
  }
  if (a6) {
    *a6 = v9;
  }
  uint64_t result = 0;
  if (a7) {
    *a7 = v10;
  }
  return result;
}

uint64_t sub_10003EF1C(unsigned __int16 *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 4) {
    return 92;
  }
  char v8 = a6;
  unsigned int v9 = a5;
  char v11 = a3;
  unsigned __int16 v13 = (a5 + 7) & 0xFFF8;
  uint64_t v15 = a1 + 2;
  uint64_t v14 = *a1;
  if (*a1)
  {
    uint64_t v16 = a1[1];
    if (4 * v14 + (unint64_t)v13 + v16 + 8 > a2) {
      return 92;
    }
    unsigned int v17 = 0;
    uint64_t v18 = a1 + 3;
    uint64_t v19 = *a1;
    do
    {
      int v20 = *v18;
      v18 += 2;
      v17 += (v20 + 7) & 0x1FFF8;
      --v19;
    }
    while (v19);
    if (v17 >= 0x10000)
    {
      sub_10004458C("xf: xf total size (%u) is larger than UINT16_MAX\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, v17);
      uint64_t v21 = 92;
      sub_100048B34((char *)0x43F, 92);
      return v21;
    }
  }
  else
  {
    if (a2 < (v13 | 4u)) {
      return 92;
    }
    unsigned int v17 = 0;
    LODWORD(v--*(_DWORD *)(result + 16) = a1[1];
  }
  uint64_t v22 = &v15[2 * v14];
  if (v17 != v16)
  {
    if (v17 <= v16)
    {
      sub_100044674("xf: xf_used_data (%u) is larger than expected (%u)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, v16);
      sub_100048B34((char *)0x440, -11);
      if (sub_10004641C(qword_100091B70, "Fix xf_used_data? ", v23, v24, v25, v26, v27, v28, v32))
      {
        bzero((char *)v22 + v17, a1[1] - v17);
        a1[1] = v17;
        LOWORD(v--*(_DWORD *)(result + 16) = v17;
        goto LABEL_14;
      }
    }
    return 92;
  }
LABEL_14:
  memmove(v22 + 2, v22, (unsigned __int16)v16);
  uint64_t v29 = *a1;
  unsigned int v30 = &v15[2 * v29];
  *(unsigned char *)unsigned int v30 = v11;
  *((unsigned char *)v30 + 1) = v8;
  v30[1] = v9;
  *a1 = v29 + 1;
  memcpy((char *)v22 + a1[1] + 4, a4, v9);
  if (v9 != v13) {
    bzero((char *)v22 + v9 + a1[1] + 4, (v13 - v9));
  }
  uint64_t v21 = 0;
  a1[1] += v13;
  return v21;
}

uint64_t sub_10003F0F8(unsigned __int16 *a1, unsigned int *a2, int a3)
{
  __dst = 0;
  unsigned __int16 v15 = 0;
  unsigned int v13 = 0;
  int v14 = 0;
  uint64_t v6 = a1 + 2;
  uint64_t v5 = *a1;
  uint64_t result = sub_10003EE64(a1, *a2, a3, &__dst, &v15, &v14, &v13);
  if (!result)
  {
    uint64_t v8 = (v15 + 7) & 0x1FFF8;
    unint64_t v9 = (a1[1] + 7) & 0x1FFF8;
    unint64_t v10 = v8 + v13;
    if (v9 >= v10)
    {
      memmove(__dst, (char *)__dst + v8, v9 - v10);
      a1[1] -= v8;
      memmove(&v6[2 * v14], &v6[2 * v14 + 2], 4 * (*a1 + ~v14));
      unsigned __int16 v11 = *a1 - 1;
      *a1 = v11;
      memmove(&v6[2 * v11], &v6[2 * v5], a1[1]);
      int v12 = *a1;
      if (*a1) {
        int v12 = a1[1] + 4 * v12 + 4;
      }
      uint64_t result = 0;
      *a2 = v12;
    }
    else
    {
      return 92;
    }
  }
  return result;
}

uint64_t sub_10003F20C(int a1, uint64_t a2, uint64_t *a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch(a1)
  {
    case 9:
      uint64_t v8 = a2 + 18;
      int v9 = 18;
      goto LABEL_9;
    case 10:
    case 11:
    case 12:
    case 14:
    case 15:
    case 17:
      goto LABEL_5;
    case 13:
    case 16:
      uint64_t v8 = a2 + 24;
      int v9 = 24;
      goto LABEL_9;
    case 18:
      uint64_t v8 = a2 + 52;
      int v9 = 52;
      goto LABEL_9;
    case 19:
      uint64_t v8 = a2 + 8;
      int v9 = 8;
      goto LABEL_9;
    default:
      if (a1 == 3)
      {
        uint64_t v8 = a2 + 92;
        int v9 = 92;
LABEL_9:
        uint64_t v10 = 0;
        *a3 = v8;
        *a4 = v9;
      }
      else
      {
LABEL_5:
        sub_10004458C("unknown obj type (%u) to add xfields\n", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, a1);
        uint64_t v10 = 22;
        sub_100048B34((char *)0x565, 22);
      }
      return v10;
  }
}

uint64_t sub_10003F2FC(const void *a1, int *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  return sub_10003F32C(3, a1, a2, a3, a4, a5, (void (*)(uint64_t, const void *, uint64_t))sub_10003F4C4, a6);
}

uint64_t sub_10003F32C(int a1, const void *a2, int *a3, uint64_t a4, const void *a5, uint64_t a6, void (*a7)(uint64_t, const void *, uint64_t), uint64_t *a8)
{
  uint64_t v43 = 0;
  uint64_t v16 = sub_10003F4E8(a1, (uint64_t)a2, *a3, a4, a6, &v43, (uint64_t)a7, (uint64_t)a8);
  uint64_t v21 = v16;
  if ((v16 & 0xFFFFFFFD) == 0)
  {
    if (v16 != 2)
    {
      a7(v43, a5, a6);
      return 0;
    }
    uint64_t v45 = 0;
    int v44 = 0;
    uint64_t v21 = sub_10003F20C(a1, (uint64_t)a2, (uint64_t *)&v45, &v44, v17, v18, v19, v20);
    if (!v21)
    {
      int v22 = *a3;
      int v23 = v44;
      unsigned int v24 = a6 + *a3 + 4 * (*a3 == v44) + 4;
      uint64_t v25 = malloc_type_calloc(1uLL, v24, 0x8241FD3FuLL);
      *a8 = (uint64_t)v25;
      if (!v25)
      {
        sub_10004458C("failed to allocate memory to add an xfield\n", v26, v27, v28, v29, v30, v31, v32, v41);
        uint64_t v21 = 12;
        sub_100048B34((char *)0x441, 12);
        return v21;
      }
      int v42 = v23;
      memcpy(v25, a2, *a3);
      *a3 = v24;
      uint64_t v21 = sub_10003F20C(a1, *a8, (uint64_t *)&v45, &v44, v33, v34, v35, v36);
      if (!v21)
      {
        long long v39 = (unsigned __int16 *)v45;
        if (v22 == v42) {
          bzero(v45, v24 - v42);
        }
        uint64_t v21 = sub_10003EF1C(v39, v24 - v42, a4, a5, a6, 16, v37, v38);
        if (!v21) {
          return 0;
        }
      }
    }
  }
  return v21;
}

void *sub_10003F4C4(void *a1, const void *a2, size_t __n)
{
  return memcpy(a1, a2, __n);
}

uint64_t sub_10003F4CC(uint64_t a1, int a2, int a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10003F4E8(3, a1, a2, a3, a4, a5, a7, a8);
}

uint64_t sub_10003F4E8(int a1, uint64_t a2, int a3, int a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  int v9 = a5;
  unsigned __int16 v15 = 0;
  int v14 = 0;
  int v13 = 0;
  uint64_t result = sub_10003F20C(a1, a2, (uint64_t *)&v14, &v13, a5, (uint64_t)a6, a7, a8);
  if (!result)
  {
    if (a3 == v13)
    {
      return 2;
    }
    else
    {
      uint64_t result = sub_10003EE64(v14, a3 - v13, a4, a6, &v15, 0, 0);
      if (!result)
      {
        if (v15 == v9) {
          return 0;
        }
        else {
          return 34;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10003F584(const void *a1, int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v5 = a3;
  return sub_10003F32C(3, a1, a2, 13, &v5, 8, (void (*)(uint64_t, const void *, uint64_t))sub_10003F5D8, a4);
}

char *sub_10003F5D8(char *result, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = __CFADD__(*(void *)result, *a2);
  uint64_t v9 = *(void *)result + *a2;
  *(void *)uint64_t result = v9;
  if (v8)
  {
    uint64_t v10 = result;
    sub_100044674("sparse bytes overflow (current %llu, update %llu)\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v9);
    uint64_t result = sub_100048B34((char *)0x442, 92);
    *(void *)uint64_t v10 = -1;
  }
  return result;
}

uint64_t sub_10003F63C(const void *a1, int *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t *a6)
{
  return sub_10003F32C(18, a1, a2, a3, a4, a5, (void (*)(uint64_t, const void *, uint64_t))sub_10003F4C4, a6);
}

uint64_t sub_10003F66C(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = off_100091690(*a3, a1, a2);
  *a3 = result;
  return result;
}

char *sub_10003F6AC(unsigned int a1)
{
  if (a1 < 0x15) {
    return off_100070878[a1];
  }
  uint64_t v1 = byte_1000909D8;
  snprintf(byte_1000909D8, 0x20uLL, "Unknown type %d", a1);
  return v1;
}

double sub_10003F70C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 40);
  dword_1000909F8 = *(_DWORD *)(v2 + 36);
  unint64_t v4 = sub_10001CEE8(0x64u, 0x38400000uLL, 0x5A00000uLL);
  if (!sub_100038040((uint64_t)dword_100091FF0, 0, 0, 0x8000000, 2, 0, 0, 4096, 32, 16, 0, 0, (uint64_t)sub_10003F980))sub_10003A18C((uint64_t)dword_100091FF0, 0, 0); {
  byte_100090A00 = 1;
  }
  if (!sub_100038040((uint64_t)dword_100092030, 0, 0, 0x8000000, 2, 0, 0, 4096, 24, 16, 0, 0, (uint64_t)sub_10003F9B4))sub_10003A18C((uint64_t)dword_100092030, 0, 0); {
  for (uint64_t i = 0; i != 48; i += 16)
  }
  {
    if (!sub_100038040((uint64_t)&dword_100092070[i], 0, 0, 0x8000000, 2, 0, 0, 4096, 16, 8, 0, 0, (uint64_t)sub_10003FA10))sub_10003A18C((uint64_t)&dword_100092070[i], 0, 0); {
  }
    }
  byte_100090A01 = 1;
  sub_10001FDE8((uint64_t)&unk_100091EB8, v3, v4);
  byte_100090A02[0] = 0;
  byte_100090A04[0] = 1;
  if (*(unsigned char *)(*(void *)(a1 + 8) + 65))
  {
    sub_10001FDE8((uint64_t)&unk_100091F20, v3, v4);
    byte_100090A03 = 0;
    byte_100090A05 = 1;
  }
  sub_10001FDE8((uint64_t)&unk_100091F88, v3, v4);
  bzero(qword_100090A08, 0x640uLL);
  int v6 = 0;
  uint64_t v7 = *(void *)(a1 + 8);
  for (uint64_t j = 184; j != 984; j += 8)
  {
    uint64_t v9 = *(void *)(v7 + j);
    if (v9)
    {
      uint64_t v10 = 2 * v6++;
      qword_100090A08[v10] = v9;
    }
  }
  double result = 0.0;
  xmmword_100091088 = 0u;
  unk_100091098 = 0u;
  xmmword_100091068 = 0u;
  unk_100091078 = 0u;
  xmmword_100091048 = 0u;
  unk_100091058 = 0u;
  return result;
}

uint64_t sub_10003F980(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  *a6 = sub_10003FD3C(a2, a4);
  return 0;
}

uint64_t sub_10003F9B4(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, int *a6)
{
  if (*a2 > *a4) {
    goto LABEL_4;
  }
  if (*a2 < *a4) {
    goto LABEL_6;
  }
  uint64_t v6 = a2[1];
  uint64_t v7 = a4[1];
  if (v6 > v7)
  {
LABEL_4:
    int v8 = 1;
    goto LABEL_7;
  }
  if (v6 < v7)
  {
LABEL_6:
    int v8 = -1;
    goto LABEL_7;
  }
  unint64_t v10 = a2[2];
  unint64_t v11 = a4[2];
  BOOL v12 = v10 > v11;
  if (v10 >= v11) {
    int v8 = 0;
  }
  else {
    int v8 = -1;
  }
  if (v12) {
    int v8 = 1;
  }
LABEL_7:
  *a6 = v8;
  return 0;
}

uint64_t sub_10003FA10(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, int *a6)
{
  uint64_t v6 = a2[1];
  uint64_t v7 = a4[1];
  if (v6 <= v7)
  {
    if (v6 >= v7)
    {
      if (*a2 <= *a4) {
        int v8 = 0;
      }
      else {
        int v8 = -1;
      }
      if (*a2 < *a4) {
        int v8 = 1;
      }
    }
    else
    {
      int v8 = -1;
    }
  }
  else
  {
    int v8 = 1;
  }
  *a6 = v8;
  return 0;
}

_DWORD *sub_10003FA58()
{
  sub_10003A268((uint64_t)dword_100091FF0, 0);
  sub_10003A268((uint64_t)dword_100092030, 0);
  for (uint64_t i = 0; i != 312; i += 104)
    sub_10001FF20((uint64_t)&unk_100091EB8 + i);
  for (uint64_t j = 0; j != 48; j += 16)
  {
    double result = &dword_100092070[j];
    if (*(void *)&dword_100092070[j + 14]) {
      double result = (_DWORD *)sub_10003A268((uint64_t)result, 0);
    }
  }
  return result;
}

uint64_t sub_10003FAE0(uint64_t a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, __int16 a7, __int16 a8)
{
  unint64_t v18 = 0;
  uint64_t result = sub_10003A064((uint64_t)dword_100091FF0, 0, &v18);
  if (byte_100090A00 == 1 && v18 <= 0x31)
  {
    v17[1] = a2;
    unint64_t v18 = a3;
    int v19 = a4;
    uint64_t v22 = a5;
    uint64_t v23 = a6;
    __int16 v20 = a7;
    __int16 v21 = a8;
    v17[0] = a1;
    return sub_100039A6C(dword_100091FF0, 0, &v18, 32, v17, 16);
  }
  return result;
}

uint64_t sub_10003FBA8(unint64_t a1, uint64_t a2, unint64_t a3, int a4, uint64_t a5, uint64_t a6, __int16 a7, __int16 a8, char a9)
{
  memset(v36, 0, sizeof(v36));
  unint64_t v28 = 0;
  uint64_t v29 = 0;
  unint64_t v30 = a3;
  int v31 = a4;
  uint64_t v34 = a5;
  uint64_t v35 = a6;
  __int16 v32 = a7;
  __int16 v33 = a8;
  unsigned int v26 = 16;
  unsigned int v27 = 32;
  if (sub_1000380B0((uint64_t)dword_100091FF0, 0, 1, v36, &v27, 0x20u, &v28, &v26)) {
    return 0;
  }
  __int16 v20 = a8;
  while (1)
  {
    if (a2 + a1 <= v28 || v29 + v28 <= a1) {
      goto LABEL_10;
    }
    if (sub_10003FD3C((uint64_t)v36, (uint64_t)&v30)) {
      break;
    }
    a9 = 0;
LABEL_10:
    unsigned int v21 = 16;
    unsigned int v22 = 32;
    if (sub_1000380B0((uint64_t)dword_100091FF0, 0, 2, v36, &v22, 0x20u, &v28, &v21)) {
      return 0;
    }
  }
  if (a9)
  {
    v25[0] = 0;
    v25[1] = 0;
    unsigned int v23 = 16;
    unsigned int v24 = 32;
    if (sub_1000380B0((uint64_t)dword_100091FF0, 0, 0, &v30, &v24, 0x20u, v25, &v23)) {
      sub_10003FAE0(a1, a2, a3, a4, a5, a6, a7, v20);
    }
  }
  return 1;
}

uint64_t sub_10003FD3C(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1 > *(void *)a2) {
    return 1;
  }
  if (*(void *)a1 < *(void *)a2) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  if (v2 > v3) {
    return 1;
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v4 = *(void *)(a1 + 16);
  unint64_t v5 = *(void *)(a2 + 16);
  if (v4 > v5) {
    return 1;
  }
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  if (!v2)
  {
    unint64_t v14 = *(void *)(a1 + 24);
    unint64_t v15 = *(void *)(a2 + 24);
    if (v14 > v15) {
      return 1;
    }
    if (v14 < v15) {
      return 0xFFFFFFFFLL;
    }
  }
  unsigned int v7 = *(unsigned __int16 *)(a1 + 12);
  unsigned int v8 = *(unsigned __int16 *)(a2 + 12);
  if (v7 > v8) {
    return 1;
  }
  if (v7 < v8) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 14);
  unsigned int v10 = *(unsigned __int16 *)(a2 + 14);
  BOOL v11 = v9 >= v10;
  BOOL v12 = v9 == v10;
  if (v9 >= v10) {
    unsigned int v13 = 0;
  }
  else {
    unsigned int v13 = -1;
  }
  if (!v12 && v11) {
    return 1;
  }
  else {
    return v13;
  }
}

BOOL sub_10003FDD4()
{
  uint64_t v1 = 0;
  sub_10003A064((uint64_t)dword_100091FF0, 0, &v1);
  return v1 != 0;
}

uint64_t sub_10003FE14()
{
  long long v13 = 0u;
  long long v14 = 0u;
  v12[0] = 0;
  v12[1] = 0;
  unsigned int v10 = 16;
  unsigned int v11 = 32;
  for (uint64_t result = sub_1000380B0((uint64_t)dword_100091FF0, 0, 1, &v13, &v11, 0x20u, v12, &v10);
        !result;
        uint64_t result = sub_1000380B0((uint64_t)dword_100091FF0, 0, 2, &v13, &v9, 0x20u, v12, &v8))
  {
    sub_100044674("Overlapping object: (oid : 0x%llx) (type : %u) (subtype : %u), (%llu + %llu)\n", v1, v2, v3, v4, v5, v6, v7, v14);
    unsigned int v8 = 16;
    unsigned int v9 = 32;
  }
  return result;
}

uint64_t sub_10003FEE4(uint64_t *a1)
{
  long long v219 = 0u;
  long long v220 = 0u;
  unint64_t v217 = 0;
  unint64_t v218 = 0;
  unsigned int v215 = 16;
  unsigned int v216 = 32;
  uint64_t v2 = 0;
  if (sub_1000380B0((uint64_t)dword_100091FF0, 0, 1, &v219, &v216, 0x20u, &v217, &v215)) {
    return v2;
  }
  do
  {
    if (DWORD2(v219) != 0x40000000 || *((void *)&v220 + 1) != 0 || WORD6(v219) != 0 || HIWORD(v219) != 15) {
      goto LABEL_60;
    }
    uint64_t v213 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v214 = (_DWORD *)0xAAAAAAAAAAAAAAAALL;
    uint64_t v212 = 0;
    v210[0] = 0;
    v210[1] = 0;
    int v211 = 0;
    unsigned int v208 = 20;
    unsigned int v209 = 8;
    uint64_t v206 = 0;
    uint64_t v207 = 0;
    uint64_t v204 = 0;
    uint64_t v205 = 0;
    uint64_t v202 = 0;
    uint64_t v203 = 0;
    if (!sub_10003FBA8(v217, v218, v219, 0x40000000, v220, 0, 0, 15, 0))
    {
      long long v221 = v219;
      long long v222 = v220;
      sub_10003A048((uint64_t)dword_100091FF0, 0, (uint64_t)&v221, 32);
      unint64_t v15 = 0;
      goto LABEL_52;
    }
    uint64_t v7 = sub_10001F348((uint64_t)a1, v219);
    unint64_t v15 = (int8x16_t *)v7;
    if (!v7)
    {
      sub_100044674("repair_overlapped_extents: unable to find volume for fs_oid 0x%llx\n", v8, v9, v10, v11, v12, v13, v14, v219);
      uint64_t v22 = 604;
      int v23 = 2;
      goto LABEL_51;
    }
    uint64_t v16 = *((void *)v7 + 5);
    uint64_t v17 = *(void *)(v16 + 976);
    if (*(unsigned char *)(v16 + 264))
    {
      if (v17)
      {
LABEL_26:
        sub_10004458C("repair_overlapped_extents: encryption is rolling for fs_oid 0x%llx\n", v8, v9, v10, v11, v12, v13, v14, v219);
        if (v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = 16;
        }
        uint64_t v22 = 605;
        int v23 = 16;
        goto LABEL_51;
      }
    }
    else
    {
      if (v17) {
        goto LABEL_26;
      }
      if (v7[8])
      {
        unsigned int v18 = sub_100045184((const char **)v7, a1, 2);
        if (v18)
        {
          if (v2) {
            uint64_t v2 = v2;
          }
          else {
            uint64_t v2 = v18;
          }
          goto LABEL_52;
        }
      }
    }
    unsigned int v24 = sub_10003E25C((uint64_t)a1, v15, 8, (uint64_t *)&v214, v11, v12, v13, v14);
    if (v24)
    {
      unsigned int v32 = v24;
      sub_10004458C("repair_overlapped_extents: unable to init fsroot for fs_oid 0x%llx\n", v25, v26, v27, v28, v29, v30, v31, v219);
      if (v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 606;
      goto LABEL_50;
    }
    unsigned int v33 = sub_10002D238((uint64_t)a1, (uint64_t)v15, (uint64_t *)&v213);
    if (v33)
    {
      unsigned int v32 = v33;
      sub_10004458C("repair_overlapped_extents: unable to init extentref tree for fs_oid 0x%llx\n", v34, v35, v36, v37, v38, v39, v40, v219);
      if (v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 607;
      goto LABEL_50;
    }
    uint64_t v212 = v220 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
    int v41 = sub_1000380B0((uint64_t)v213, 0, 0, &v212, &v209, v209, v210, &v208);
    if (v41)
    {
      unsigned int v32 = v41;
      char v187 = v220;
      strerror(v41);
      sub_10004458C("repair_overlapped_extents: unable to load pext 0x%llx for fs_oid 0x%llx: %s\n", v49, v50, v51, v52, v53, v54, v55, v187);
      if (v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 608;
      goto LABEL_50;
    }
    int v188 = v211;
    sub_100044548("repair_overlapped_extents: allocate space for block_count 0x%llx\n", v42, v43, v44, v45, v46, v47, v48, v218);
    int v56 = sub_1000040C4(a1, v15, 3u, v218, &v207);
    if (v56)
    {
      unsigned int v32 = v56;
      char v64 = v218;
      strerror(v56);
      sub_10004458C("repair_overlapped_extents: unable to allocate space for block_count 0x%llx: %s\n", v65, v66, v67, v68, v69, v70, v71, v64);
      if (v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 609;
      goto LABEL_50;
    }
    sub_100044548("repair_overlapped_extents: copy paddr 0x%llx to paddr 0x%llx, block_count 0x%llx\n", v57, v58, v59, v60, v61, v62, v63, v217);
    int v82 = sub_100031594(a1, v217, v207, v218);
    if (v82)
    {
      unsigned int v90 = v82;
      char v189 = v217;
      strerror(v82);
      sub_10004458C("repair_overlapped_extents: failed to copy paddr 0x%llx to paddr 0x%llx, block_count 0x%llx: %s\n", v91, v92, v93, v94, v95, v96, v97, v189);
      if (v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v90;
      }
      goto LABEL_52;
    }
    uint64_t v212 = v207 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
    sub_100044548("repair_overlapped_extents: insert target pext 0x%llx\n", v83, v84, v85, v86, v87, v88, v89, v207);
    int v98 = sub_100039A6C(v213, 0, &v212, v209, v210, v208);
    if (v98)
    {
      unsigned int v32 = v98;
      char v190 = v207;
      strerror(v98);
      sub_10004458C("repair_overlapped_extents: unable to insert target pext 0x%llx for fs_oid 0x%llx: %s\n", v99, v100, v101, v102, v103, v104, v105, v190);
      if (v2) {
        uint64_t v2 = v2;
      }
      else {
        uint64_t v2 = v32;
      }
      uint64_t v22 = 613;
LABEL_50:
      int v23 = v32;
LABEL_51:
      sub_100048B34((char *)v22, v23);
      goto LABEL_52;
    }
    uint64_t v204 = v219;
    uint64_t v205 = v220;
    uint64_t v206 = 0;
    unsigned int v200 = 16;
    unsigned int v201 = 24;
    if (sub_1000380B0((uint64_t)dword_100092030, 0, 1, &v204, &v201, 0x18u, &v202, &v200))
    {
      int v180 = 0;
LABEL_73:
      uint64_t v212 = v220 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
      sub_100044548("repair_overlapped_extents: remove source pext 0x%llx\n", v106, v107, v108, v109, v110, v111, v112, v220);
      int v113 = sub_10003A048((uint64_t)v213, 0, (uint64_t)&v212, v209);
      if (v113)
      {
        int v114 = v113;
        char v184 = v220;
        strerror(v113);
        sub_10004458C("repair_overlapped_extents: unable to remove source pext 0x%llx for fs_oid 0x%llx (pext leak): %s\n", v115, v116, v117, v118, v119, v120, v121, v184);
        if (!v2) {
          LODWORD(v2) = v114;
        }
        sub_100048B34((char *)0x269, v114);
      }
      long long v221 = v219;
      long long v222 = v220;
      sub_10003A048((uint64_t)dword_100091FF0, 0, (uint64_t)&v221, 32);
      unsigned int v122 = sub_10004084C(a1, v15, v217, v218);
      if (v2) {
        unsigned int v123 = v2;
      }
      else {
        unsigned int v123 = v122;
      }
      if (v122) {
        uint64_t v2 = v123;
      }
      else {
        uint64_t v2 = v2;
      }
      goto LABEL_83;
    }
    int v180 = 0;
    int v134 = 0;
    while (1)
    {
      long long v221 = 0uLL;
      *(void *)&long long v222 = 0;
      unsigned int v197 = 24;
      unsigned int v198 = 16;
      if (v204 != (void)v219 || v205 != (void)v220) {
        break;
      }
      int v185 = v134 + 1;
      int v181 = v134;
      v199[0] = v206 & 0xFFFFFFFFFFFFFFFLL | 0x8000000000000000;
      v199[1] = v203;
      sub_100044548("repair_overlapped_extents: load fext 0x%llx 0x%llx\n", v106, v107, v108, v109, v110, v111, v112, v206);
      int v135 = sub_1000380B0((uint64_t)v214, 0, 0, v199, &v198, v198, &v221, &v197);
      if (v135)
      {
        unsigned int v143 = v135;
        char v182 = v206;
        strerror(v135);
        sub_10004458C("repair_overlapped_extents: unable to load fext 0x%llx 0x%llx for fs_oid 0x%llx: %s\n", v144, v145, v146, v147, v148, v149, v150, v182);
        if (v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v143;
        }
        uint64_t v151 = 614;
      }
      else
      {
        *((void *)&v221 + 1) = v207;
        sub_100044548("repair_overlapped_extents: update fext 0x%llx 0x%llx\n", v136, v137, v138, v139, v140, v141, v142, v206);
        int v152 = sub_100039A6C(v214, 0, v199, v198, &v221, v197);
        if (!v152)
        {
          ++v180;
          int v160 = v181;
          goto LABEL_106;
        }
        unsigned int v143 = v152;
        char v183 = v206;
        strerror(v152);
        sub_10004458C("repair_overlapped_extents: unable to update fext 0x%llx 0x%llx for fs_oid 0x%llx: %s\n", v153, v154, v155, v156, v157, v158, v159, v183);
        if (v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v143;
        }
        uint64_t v151 = 615;
      }
      sub_100048B34((char *)v151, v143);
      int v160 = v185;
LABEL_106:
      unsigned int v195 = 16;
      unsigned int v196 = 24;
      int v161 = sub_1000380B0((uint64_t)dword_100092030, 0, 2, &v204, &v196, 0x18u, &v202, &v195);
      int v134 = v160;
      if (v161) {
        goto LABEL_116;
      }
    }
    int v160 = v134;
LABEL_116:
    if (!v160) {
      goto LABEL_73;
    }
    int v124 = v188;
    if (v160 != v188)
    {
      uint64_t v212 = v220 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
      int v211 = v160;
      sub_100044548("repair_overlapped_extents: update source pext 0x%llx\n", v106, v107, v108, v109, v110, v111, v112, v220);
      int v171 = sub_100039A6C(v213, 0, &v212, v209, v210, v208);
      if (v171)
      {
        unsigned int v172 = v171;
        char v186 = v220;
        strerror(v171);
        sub_10004458C("repair_overlapped_extents: unable to update source pext 0x%llx for fs_oid 0x%llx (refcnt leak): %s\n", v173, v174, v175, v176, v177, v178, v179, v186);
        if (v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v172;
        }
        sub_100048B34((char *)0x268, v172);
      }
LABEL_83:
      int v124 = v188;
    }
    if (v180)
    {
      if (v180 != v124)
      {
        uint64_t v212 = v207 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
        int v211 = v180;
        sub_100044548("repair_overlapped_extents: update target pext 0x%llx\n", v106, v107, v108, v109, v110, v111, v112, v207);
        int v125 = sub_100039A6C(v213, 0, &v212, v209, v210, v208);
        if (v125)
        {
          unsigned int v126 = v125;
          char v191 = v207;
          strerror(v125);
          sub_10004458C("repair_overlapped_extents: unable to target update target pext 0x%llx for fs_oid 0x%llx (refcnt leak): %s\n", v127, v128, v129, v130, v131, v132, v133, v191);
          if (v2) {
            uint64_t v2 = v2;
          }
          else {
            uint64_t v2 = v126;
          }
          sub_100048B34((char *)0x26A, v126);
        }
      }
      uint64_t v207 = 0;
    }
    else
    {
      uint64_t v212 = v207 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
      sub_100044548("repair_overlapped_extents: remove target pext 0x%llx\n", v106, v107, v108, v109, v110, v111, v112, v207);
      int v162 = sub_10003A048((uint64_t)v213, 0, (uint64_t)&v212, v209);
      if (v162)
      {
        unsigned int v163 = v162;
        char v192 = v207;
        strerror(v162);
        sub_10004458C("repair_overlapped_extents: unable to remove target pext 0x%llx for fs_oid 0x%llx (pext leak): %s\n", v164, v165, v166, v167, v168, v169, v170, v192);
        if (v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v163;
        }
        sub_100048B34((char *)0x26B, v163);
      }
    }
    sub_100048AE4();
LABEL_52:
    if (v207)
    {
      sub_100044548("repair_overlapped_extents: free space for target_paddr 0x%llx block_count 0x%llx\n", v19, v20, v21, v11, v12, v13, v14, v207);
      int v72 = sub_1000051A0(a1, v15, v207, v218);
      if (v72)
      {
        unsigned int v73 = v72;
        char v74 = v207;
        strerror(v72);
        sub_10004458C("repair_overlapped_extents: unable to free space for target_paddr 0x%llx block_count 0x%llx: %s\n", v75, v76, v77, v78, v79, v80, v81, v74);
        if (v2) {
          uint64_t v2 = v2;
        }
        else {
          uint64_t v2 = v73;
        }
        sub_100048B34((char *)0x26C, v73);
      }
    }
    if (v15) {
      sub_100045320((uint64_t)v15);
    }
LABEL_60:
    unsigned int v193 = 16;
    unsigned int v194 = 32;
  }
  while (!sub_1000380B0((uint64_t)dword_100091FF0, 0, 2, &v219, &v194, 0x20u, &v217, &v193));
  return v2;
}

uint64_t sub_10004084C(uint64_t *a1, int8x16_t *a2, uint64_t a3, unint64_t a4)
{
  unint64_t v4 = a4;
  uint64_t v5 = a3;
  memset(v62, 0, sizeof(v62));
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t v8 = (unsigned int *)&unk_100090000;
  char v9 = __clz(__rbit64(dword_1000909F8));
  int v10 = sub_1000203D4((uint64_t)&unk_100091EB8 + 104 * (((unint64_t)(a3 << v9) >> 62) & 1), ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v9) & a3, a4, 0);
  if (v10)
  {
    int v11 = v10;
    strerror(v10);
    sub_100044674("free_overlapped_range: unable to free space for source_paddr 0x%llx block_count 0x%llx (leak): %s\n", v12, v13, v14, v15, v16, v17, v18, v5);
    sub_100048B34((char *)0x26D, v11);
  }
  uint64_t v59 = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v57 = 16;
  unsigned int v58 = 32;
  if (!sub_1000380B0((uint64_t)dword_100091FF0, 0, 1, v62, &v58, 0x20u, &v60, &v57))
  {
    unint64_t v19 = v4 + v5;
    do
    {
      if (v19 > v60 && v61 + v60 > (unint64_t)v5)
      {
        if (v5 <= v60) {
          uint64_t v21 = v60;
        }
        else {
          uint64_t v21 = v5;
        }
        if (v19 - v21 >= v60 - v21 + v61) {
          uint64_t v22 = v60 - v21 + v61;
        }
        else {
          uint64_t v22 = v19 - v21;
        }
        sub_100040BB8(v21, v22, WORD6(v62[0]), HIWORD(v62[0]), 0);
      }
      unsigned int v55 = 16;
      unsigned int v56 = 32;
    }
    while (!sub_1000380B0((uint64_t)dword_100091FF0, 0, 2, v62, &v56, 0x20u, &v60, &v55));
  }
  char v23 = __clz(__rbit64(dword_1000909F8));
  uint64_t v24 = 0;
  if (sub_10002029C((uint64_t)&unk_100091EB8 + 104 * (((unint64_t)(v5 << v23) >> 62) & 1), ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v23) & v5, v4, &v59))
  {
    do
    {
      unint64_t v54 = 0xAAAAAAAAAAAAAAAALL;
      char v25 = __clz(__rbit64(v8[638]));
      if (((0x4000000000000000uLL >> v25) & v5) != 0) {
        unint64_t v26 = 0x4000000000000000uLL >> v25;
      }
      else {
        unint64_t v26 = 0;
      }
      v59 |= v26;
      unint64_t v27 = v4 + v5;
      unint64_t v28 = v4 + v5 - v59;
      if (sub_100020178((uint64_t)&unk_100091EB8 + 104 * ((v59 & (0x4000000000000000uLL >> v25)) != 0), v59 & ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v25), v28, &v54))
      {
        unint64_t v36 = 0x4000000000000000uLL >> __clz(__rbit64(v8[638]));
        if ((v36 & v5) == 0) {
          unint64_t v36 = 0;
        }
        v54 |= v36;
        unint64_t v28 = v54 - v59;
      }
      sub_100044548("free_overlapped_range: free space for source_paddr 0x%llx block_count 0x%llx\n", v29, v30, v31, v32, v33, v34, v35, v59);
      int v37 = sub_1000051A0(a1, a2, v59, v28);
      if (v37) {
        BOOL v38 = v37 == 17;
      }
      else {
        BOOL v38 = 1;
      }
      if (!v38)
      {
        unsigned int v39 = v37;
        uint64_t v40 = v8;
        int v41 = a1;
        uint64_t v42 = a2;
        char v43 = v59;
        strerror(v37);
        char v53 = v43;
        a2 = v42;
        a1 = v41;
        uint64_t v8 = v40;
        sub_10004458C("free_overlapped_range: unable to free space for source_paddr 0x%llx block_count 0x%llx (leak): %s\n", v44, v45, v46, v47, v48, v49, v50, v53);
        if (v24) {
          uint64_t v24 = v24;
        }
        else {
          uint64_t v24 = v39;
        }
        sub_100048B34((char *)0x26E, v39);
      }
      uint64_t v5 = v59 + v28;
      unint64_t v4 = v27 - (v59 + v28);
      char v51 = __clz(__rbit64(v8[638]));
    }
    while ((sub_10002029C((uint64_t)&unk_100091EB8 + 104 * (((unint64_t)(v5 << v51) >> 62) & 1), ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v51) & v5, v4, &v59) & 1) != 0);
  }
  return v24;
}

uint64_t sub_100040B64(uint64_t a1, void *a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    uint64_t v3 = qword_100090A08[v2];
    if (!v3) {
      return 2;
    }
    if (v3 == a1) {
      break;
    }
    v2 += 2;
    if (v2 == 200) {
      return 2;
    }
  }
  if (v2 == 0x1FFFFFFFELL) {
    return 2;
  }
  uint64_t result = 0;
  *a2 = qword_100090A08[v2 + 1];
  return result;
}

uint64_t sub_100040BB8(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  char v8 = __clz(__rbit64(dword_1000909F8));
  uint64_t v9 = ((unint64_t)(a1 << v8) >> 62) & 1;
  if (a5) {
    LODWORD(v9) = 2;
  }
  uint64_t v10 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v8;
  if (a5) {
    uint64_t v10 = -1;
  }
  uint64_t result = sub_1000203D4((char *)&unk_100091EB8 + 104 * v9, v10 & a1, a2, 1);
  if (!result)
  {
    if (*(unsigned char *)(qword_100091B78 + 39))
    {
      return sub_100040C84(a3, a4, a2, v12, v13, v14, v15, v16);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100040C84(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 || a2 != 15)
  {
    if (a1 || a2 != 21)
    {
      if (a1 == 1) {
        unsigned int v10 = 1;
      }
      else {
        unsigned int v10 = a2;
      }
      if (a1 > 3) {
        unsigned int v10 = a1;
      }
      if (v10 >= 0x25)
      {
        sub_100044674("Invalid object type/subtype (type : %u) (subtype : %u)\n", a2, a3, a4, a5, a6, a7, a8, a1);
        uint64_t v9 = 11;
      }
      else
      {
        uint64_t v9 = dword_10006F4A0[v10];
      }
    }
    else
    {
      uint64_t v9 = 8;
    }
  }
  else
  {
    uint64_t v9 = 10;
  }
  *((void *)&xmmword_100091048 + v9) += a3;
  return 0;
}

uint64_t sub_100040D28(uint64_t a1, uint64_t a2, int a3)
{
  char v3 = __clz(__rbit64(dword_1000909F8));
  uint64_t v4 = ((unint64_t)(a1 << v3) >> 62) & 1;
  if (a3) {
    LODWORD(v4) = 2;
  }
  uint64_t v5 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v3;
  if (a3) {
    uint64_t v5 = -1;
  }
  return sub_1000203D4((char *)&unk_100091EB8 + 104 * v4, v5 & a1, a2, 0);
}

uint64_t sub_100040D7C(uint64_t a1, unint64_t a2, int a3)
{
  char v3 = __clz(__rbit64(dword_1000909F8));
  uint64_t v4 = ((unint64_t)(a1 << v3) >> 62) & 1;
  if (a3) {
    LODWORD(v4) = 2;
  }
  uint64_t v5 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v3;
  if (a3) {
    uint64_t v5 = -1;
  }
  return sub_100020720((uint64_t)&unk_100091EB8 + 104 * v4, v5 & a1, a2, 1);
}

uint64_t sub_100040DD0(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, int a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  if (*(unsigned char *)(qword_100091B78 + 40))
  {
    return sub_10003FBA8(a2, a3, a4, a5, a6, a7, a8, a9, 1);
  }
  if (a5 == 0x40000000
    && (a10 & 1) != 0
    && ((a2 << __clz(__rbit64(dword_1000909F8))) & 0x4000000000000000) != 0
    && sub_10001E0AC(a1, a2, a3))
  {
    sub_10004458C("physical metadata object (0x%llx + %llu) type %u subtype %u) is on Tier2 and inside the MT mapped range\n", v18, v19, v20, v21, v22, v23, v24, a2);
    sub_100048B34((char *)0x36D, 92);
  }
  int v25 = sub_100040BB8(a2, a3, a8, a9, (a10 >> 3) & 1);
  if (v25)
  {
    if (v25 != 12)
    {
      if (v25 == 17)
      {
        sub_100048B34((char *)0x451, 17);
        sub_10003FAE0(a2, a3, a4, a5, a6, a7, a8, a9);
        goto LABEL_16;
      }
      strerror(v25);
      sub_100044674("object oid %llu/xid %llu/type 0x%x/subtype 0x%x: unable to mark range %llu+%llu allocated for space verification: %s\n", v33, v34, v35, v36, v37, v38, v39, a6);
    }
    sub_100048B34((char *)0x437, -7);
    byte_1000746A0 = 0;
  }
LABEL_16:
  if (a4)
  {
    for (uint64_t i = 0; i != 200; i += 2)
    {
      uint64_t v41 = qword_100090A08[i];
      if (!v41) {
        break;
      }
      if (v41 == a4)
      {
        if (i != 0x1FFFFFFFELL)
        {
          qword_100090A08[i + 1] += a3;
          goto LABEL_26;
        }
        break;
      }
    }
    if ((a10 & 4) == 0) {
      sub_100044674("unable to mark allocated blocks for volume oid %llu\n", v26, v27, v28, v29, v30, v31, v32, a4);
    }
  }
LABEL_26:

  return sub_10000EF2C(a3, a4 != 0, v27, v28, v29, v30, v31, v32);
}

uint64_t sub_100041010(uint64_t a1)
{
  sub_100040DD0(a1, 0, 1, 0, 0x40000000, 0, 0, 1u, &_mh_execute_header, (unint64_t)&_mh_execute_header >> 32);
  uint64_t v45 = a1;
  uint64_t v46 = 0xC00000000;
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(unsigned int *)(v2 + 104);
  unint64_t v4 = *(void *)(v2 + 112);
  if ((v3 & 0x80000000) != 0)
  {
    if (sub_1000310DC(a1, v4, sub_100041324, (uint64_t)&v45))
    {
      byte_1000746A0 = 0;
      sub_100044674("object (oid 0x%llx): Unable to mark nx checkpoint desc range (0x%llx + %u) allocated for space verification\n", v5, v6, v7, v8, v9, v10, v11, 0);
      sub_100048B34((char *)0x1D1, -7);
    }
  }
  else
  {
    sub_100040DD0(a1, v4, v3, 0, 0x40000000, v4, 0, 0, 0xCu, 1u);
  }
  uint64_t v12 = *(void *)(a1 + 8);
  uint64_t v13 = *(unsigned int *)(v12 + 108);
  unint64_t v14 = *(void *)(v12 + 120);
  if ((v13 & 0x80000000) != 0)
  {
    if (sub_1000310DC(a1, v14, sub_100041324, (uint64_t)&v45))
    {
      byte_1000746A0 = 0;
      sub_100044674("object (oid 0x%llx): Unable to mark nx checkpoint data range (0x%llx + %u) allocated for space verification\n", v15, v16, v17, v18, v19, v20, v21, 0);
      sub_100048B34((char *)0x1D2, -7);
    }
  }
  else
  {
    sub_100040DD0(v45, v14, v13, 0, 0x40000000, v14, 0, v46, HIDWORD(v46), 1u);
  }
  uint64_t v46 = 8;
  uint64_t v22 = *(void *)(a1 + 24);
  uint64_t v23 = *(unsigned int *)(v22 + 164);
  unint64_t v24 = *(void *)(v22 + 168);
  if ((v23 & 0x80000000) != 0)
  {
    if (sub_1000310DC(a1, v24, sub_100041324, (uint64_t)&v45))
    {
      byte_1000746A0 = 0;
      sub_100044674("object (oid 0x%llx): Unable to mark spaceman ip bitmap range (0x%llx + %u) allocated for space verification\n", v25, v26, v27, v28, v29, v30, v31, 0);
      sub_100048B34((char *)0x1D3, -7);
    }
  }
  else
  {
    sub_100040DD0(v45, v24, v23, 0, 0x40000000, v24, 0, 8u, &_mh_execute_header, (unint64_t)&_mh_execute_header >> 32);
  }
  uint64_t v32 = *(void *)(a1 + 24);
  uint64_t v33 = *(void *)(v32 + 152);
  unint64_t v34 = *(void *)(v32 + 176);
  if (v33 < 0)
  {
    uint64_t result = sub_1000310DC(a1, v34, sub_100041324, (uint64_t)&v45);
    if (result)
    {
      byte_1000746A0 = 0;
      sub_100044674("object (oid 0x%llx): Unable to mark spaceman ip range (0x%llx + %llu) allocated for space verification\n", v36, v37, v38, v39, v40, v41, v42, 0);
      uint64_t result = (uint64_t)sub_100048B34((char *)0x1D4, -7);
    }
  }
  else
  {
    uint64_t result = sub_100040DD0(v45, v34, v33, 0, 0x40000000, v34, 0, v46, HIDWORD(v46), 1u);
  }
  uint64_t v43 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v43 + 65))
  {
    unint64_t v44 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v43 + 36)));
    sub_100040DD0(a1, v44, 1, 0, 0x40000000, v44, 0, 1u, &_mh_execute_header, (unint64_t)&_mh_execute_header >> 32);
    return sub_100040DD0(a1, *(void *)(*(void *)(a1 + 8) + 1368), *(void *)(*(void *)(a1 + 8) + 1376), 0, 0x40000000, *(void *)(*(void *)(a1 + 8) + 1368), 0, 0, 0x16u, 2u);
  }
  return result;
}

uint64_t sub_100041324(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return 0;
}

uint64_t sub_10004136C(uint64_t a1, unsigned int a2, int a3, uint64_t a4, char *__s1, char *__s2, unint64_t a7, uint64_t (*a8)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a9, unsigned char *a10, _DWORD *a11)
{
  uint64_t v90 = a4;
  int v88 = a3;
  uint64_t v84 = a11;
  uint64_t v87 = a9;
  uint64_t v17 = memcmp(__s1, __s2, (a7 + 7) >> 3);
  if (!v17)
  {
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    if (!a8) {
      return 0;
    }
LABEL_97:
    uint64_t v69 = v27;
    int v70 = a8(a1, v24, v25, 1, v87);
    if (v70) {
      *uint64_t v84 = v70;
    }
    a8(a1, v26, v69, 2, v87);
    return 0;
  }
  uint64_t v80 = &v72;
  unint64_t v18 = (a7 + 63) >> 6;
  uint64_t v19 = __chkstk_darwin(v17);
  uint64_t v20 = (8 * v18 + 15) & 0x3FFFFFFFFFFFFFF0;
  uint64_t v21 = (char *)&v72 - v20;
  if (v22 > 0x3F)
  {
    uint64_t v28 = memset((char *)&v72 - v20, 170, 8 * v18);
    __chkstk_darwin(v28);
    uint64_t v23 = (char *)&v72 - v20;
    memset(v23, 170, 8 * v18);
    uint64_t v29 = 0;
    if (v18 <= 1) {
      unint64_t v30 = 1;
    }
    else {
      unint64_t v30 = (a7 + 63) >> 6;
    }
    uint64_t v31 = 8 * v30;
    do
    {
      uint64_t v32 = *(void *)&__s1[v29];
      uint64_t v33 = *(void *)&__s2[v29];
      *(void *)&v21[v29] = v32 & ~v33;
      *(void *)&v23[v29] = v33 & ~v32;
      v29 += 8;
    }
    while (v31 != v29);
  }
  else
  {
    __chkstk_darwin(v19);
    uint64_t v23 = (char *)&v72 - v20;
  }
  *(void *)&long long v94 = 0;
  if (!a7)
  {
    if (byte_1000746A0)
    {
      uint64_t v24 = 0;
      uint64_t v25 = 0;
    }
    else
    {
      uint64_t v25 = 0;
      uint64_t v24 = 0;
    }
    uint64_t v26 = 0;
    uint64_t v27 = 0;
LABEL_96:
    if (!a8) {
      return 0;
    }
    goto LABEL_97;
  }
  uint64_t v79 = v23;
  uint64_t v86 = a1;
  uint64_t v25 = 0;
  uint64_t v89 = 0;
  do
  {
    uint64_t v34 = sub_100041A90(v90, (uint64_t)v21, (uint64_t *)&v94, a7);
    uint64_t v36 = v34;
    uint64_t v37 = v35;
    if (a10 && v35) {
      *a10 = 1;
    }
    if (a8)
    {
      if (v25)
      {
        if (v25 + v89 == v34)
        {
          v25 += v35;
          continue;
        }
        int v38 = ((uint64_t (*)(uint64_t))a8)(v86);
        if (v38) {
          *uint64_t v84 = v38;
        }
      }
      uint64_t v89 = v36;
      uint64_t v25 = v37;
    }
  }
  while ((unint64_t)v94 < a7);
  if (!byte_1000746A0)
  {
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    a1 = v86;
    goto LABEL_93;
  }
  uint64_t v27 = 0;
  uint64_t v26 = 0;
  unint64_t v91 = 0;
  if (a2 == 1) {
    int v39 = 2;
  }
  else {
    int v39 = 1;
  }
  unsigned int v82 = v39;
  uint64_t v73 = a2;
  long long v78 = xmmword_10006F538;
  uint64_t v77 = 8;
  a1 = v86;
  while (1)
  {
    uint64_t v81 = v27;
    uint64_t v40 = sub_100041A90(v90, (uint64_t)v79, (uint64_t *)&v91, a7);
    uint64_t v42 = v41;
    long long v94 = v78;
    uint64_t v95 = v77;
    uint64_t v43 = malloc_type_calloc(8uLL, 0x18uLL, 0x100004057661CB1uLL);
    *(void *)&long long v94 = v43;
    if (!v43) {
      return 12;
    }
    *uint64_t v43 = v40;
    v43[1] = v42;
    char v45 = v88;
    *((unsigned char *)v43 + --*(_DWORD *)(result + 16) = v88;
    HIDWORD(v94) = 1;
    uint64_t v76 = v40;
    if ((v45 & 1) == 0)
    {
      uint64_t v60 = *(void *)(a1 + 24);
      unint64_t v61 = *(void *)(v60 + 152);
      uint64_t v62 = *(void *)(v60 + 176);
      if ((v61 & 0x8000000000000000) != 0)
      {
        uint64_t v63 = sub_1000310DC(a1, v62, sub_1000431FC, (uint64_t)&v94);
      }
      else
      {
        uint64_t v96 = *(void *)(v60 + 176);
        unint64_t v97 = v61;
        uint64_t v63 = sub_1000431FC((uint64_t)v43, v62, (uint64_t)&v96, v44, (uint64_t)&v94);
      }
      uint64_t v54 = v63;
      uint64_t v27 = v81;
      if (v63)
      {
        uint64_t v48 = 0;
        int v49 = 1;
        goto LABEL_65;
      }
      if (SHIDWORD(v94) < 1)
      {
        uint64_t v48 = 0;
        uint64_t v54 = 0;
        int v49 = 1;
        uint64_t v27 = v81;
        goto LABEL_65;
      }
    }
    uint64_t v74 = v42;
    uint64_t v75 = v26;
    uint64_t v46 = 0;
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    int v49 = 1;
LABEL_32:
    uint64_t v85 = v47;
    int v83 = v49;
    uint64_t v50 = (unint64_t *)(v94 + 24 * v46);
    unint64_t v51 = *v50;
    unint64_t v52 = v50[1];
    uint64_t v96 = 0;
    unint64_t v97 = v51;
    uint64_t v93 = 0xAAAAAAAAAAAAAAAALL;
    if (*((unsigned char *)v50 + 16)) {
      unsigned int v53 = 0;
    }
    else {
      unsigned int v53 = v82;
    }
    uint64_t v54 = sub_1000432BC(v53, &v96, &v93, 4294967294);
    if (v54 == 2)
    {
      uint64_t v54 = sub_1000432BC(v53, &v96, &v93, 1);
      if (v54 == 2) {
        goto LABEL_44;
      }
    }
    if (v54) {
      goto LABEL_55;
    }
    unint64_t v55 = v52 + v51;
    unint64_t v56 = v97;
    if (v97 >= v55) {
      goto LABEL_44;
    }
    char v57 = 0;
    while (1)
    {
      DWORD2(v94) = v46;
      BYTE5(v95) = v88;
      char v92 = -86;
      uint64_t v58 = sub_1000051A8(*(void *)(v94 + 24 * v46), *(void *)(v94 + 24 * v46 + 8), v56, v93, &v92, (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t))sub_10004335C, (uint64_t)&v94);
      if (v58) {
        return v58;
      }
      v57 |= v92 != 0;
      uint64_t v59 = sub_1000432BC(v53, &v96, &v93, 2);
      if (v59) {
        break;
      }
      unint64_t v56 = v97;
      if (v97 >= v55)
      {
        if ((v57 & 1) == 0) {
          goto LABEL_44;
        }
LABEL_50:
        uint64_t v47 = v85;
        int v49 = v83;
LABEL_51:
        if (++v46 >= SHIDWORD(v94)) {
          goto LABEL_64;
        }
        goto LABEL_32;
      }
    }
    uint64_t v54 = v59;
    if (v59 == 2)
    {
      if (v57) {
        goto LABEL_50;
      }
LABEL_44:
      uint64_t v47 = malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
      if (v47)
      {
        *(_OWORD *)uint64_t v47 = *(_OWORD *)(v94 + 24 * v46);
        uint64_t v47[2] = 0;
        int v49 = 0;
        if (v48) {
          v85[2] = v47;
        }
        else {
          uint64_t v48 = (long long *)v47;
        }
        goto LABEL_51;
      }
      int v49 = 0;
LABEL_64:
      uint64_t v54 = 0;
      a1 = v86;
      uint64_t v26 = v75;
      uint64_t v27 = v81;
      uint64_t v42 = v74;
    }
    else
    {
LABEL_55:
      a1 = v86;
      uint64_t v27 = v81;
      int v49 = v83;
      uint64_t v26 = v75;
      uint64_t v42 = v74;
      if (v48)
      {
        do
        {
          char v64 = (long long *)*((void *)v48 + 2);
          free(v48);
          uint64_t v48 = v64;
        }
        while (v64);
        uint64_t v27 = v81;
        int v49 = v83;
      }
    }
LABEL_65:
    if ((void)v94)
    {
      free((void *)v94);
      uint64_t v27 = v81;
    }
    if (v54) {
      return v54;
    }
    if (!v49)
    {
      *(void *)&long long v94 = v76;
      *((void *)&v94 + 1) = v42;
      uint64_t v95 = 0;
      if (!v48) {
        uint64_t v48 = &v94;
      }
      while (1)
      {
        uint64_t v65 = (long long *)*((void *)v48 + 2);
        if (a10 && *((void *)v48 + 1)) {
          *a10 = 1;
        }
        if (!a8) {
          goto LABEL_83;
        }
        uint64_t v67 = *(void *)v48;
        uint64_t v66 = *((void *)v48 + 1);
        if (!v27) {
          goto LABEL_82;
        }
        if (v27 + v26 != v67) {
          break;
        }
        v27 += v66;
LABEL_83:
        if (v48 != &v94)
        {
          uint64_t v68 = v27;
          free(v48);
          uint64_t v27 = v68;
        }
        uint64_t v48 = v65;
        if (!v65) {
          goto LABEL_86;
        }
      }
      ((void (*)(uint64_t, uint64_t))a8)(a1, v26);
LABEL_82:
      uint64_t v26 = v67;
      uint64_t v27 = v66;
      goto LABEL_83;
    }
    if ((v88 & 1) == 0 && byte_100090A04[v73]) {
      *((void *)&xmmword_100091048 + 1) += v42;
    }
LABEL_86:
    if (v91 >= a7)
    {
LABEL_93:
      uint64_t v24 = v89;
      goto LABEL_96;
    }
  }
}

uint64_t sub_100041A90(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *a3;
  uint64_t v13 = 0;
  uint64_t v14 = v8;
  if (sub_10000A370(1, a2, v8, a4 - v8, &v14))
  {
    uint64_t v9 = v14;
  }
  else
  {
    uint64_t v14 = a4;
    uint64_t v9 = a4;
  }
  int v10 = sub_10000A370(0, a2, v9, a4 - v9, &v13);
  uint64_t v11 = v13;
  if (!v10) {
    uint64_t v11 = a4;
  }
  uint64_t result = v14 + a1;
  *a3 = v11;
  return result;
}

uint64_t sub_100041B24(uint64_t a1, uint64_t a2, unint64_t a3, char *a4, char *a5, uint64_t a6, _DWORD *a7)
{
  uint64_t result = sub_10001FF8C((uint64_t)&unk_100091F88, a2 & 0xFFFFFFFFFFFFFFC0, (a2 + a3 - (a2 & 0xFFFFFFFFFFFFFFC0) + 63) & 0xFFFFFFFFFFFFFFC0, (uint64_t)a4);
  if (!result)
  {
    sub_10000A874(a4, (8 * (unint64_t)dword_1000909F8 + 128) >> 6, a2 & 0x3F);
    return sub_10004136C(a1, 2u, 1, a2, a4, a5, a3, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100041BF8, a6, 0, a7);
  }
  return result;
}

uint64_t sub_100041BF8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 - 3) < 0xFFFFFFFE) {
    return 22;
  }
  if (!a3) {
    return 0;
  }
  int v11 = a4;
  if (a4 == 1) {
    uint64_t v14 = "underallocation";
  }
  else {
    uint64_t v14 = "overallocation";
  }
  if (a4 == 1)
  {
    sub_10004458C("underallocation detected in internal pool: (0x%llx+%llu) bitmap address (0x%llx)\n", a2, a3, a4, (uint64_t)a5, a6, a7, a8, a2);
    sub_100048B34((char *)0x4F4, 92);
  }
  else
  {
    sub_100044674("overallocation detected in internal pool: (0x%llx+%llu) bitmap address (0x%llx)\n", a2, a3, a4, (uint64_t)a5, a6, a7, a8, a2);
    uint64_t v8 = 92;
    sub_100048B34((char *)0x4F5, 92);
    if (!*(unsigned char *)(qword_100091B78 + 41)) {
      return v8;
    }
  }
  if (!sub_10004641C(qword_100091B70, "Fix %s (0x%llx+%llu) bitmap address (0x%llx)? ", v15, v16, v17, v18, v19, v20, (char)v14))return 92; {
  uint64_t v21 = malloc_type_calloc(1uLL, *(unsigned int *)(a1[1] + 36), 0xC0DA3018uLL);
  }
  if (v21)
  {
    uint64_t v29 = v21;
    uint64_t v30 = sub_10002F148(*a1, *a5);
    if (v30)
    {
      uint64_t v8 = v30;
      sub_10004458C("Failed to fix %s\n", v31, v32, v33, v34, v35, v36, v37, (char)v14);
      uint64_t v38 = 1271;
    }
    else
    {
      uint64_t v39 = a5[2] + a2 - a5[1];
      if (v11 == 1) {
        sub_10000A1C0((uint64_t)v29, v39, a3);
      }
      else {
        sub_10000A2A8((uint64_t)v29, v39, a3);
      }
      uint64_t v8 = sub_10002F2C4(*a1, *a5);
      if (!v8)
      {
        free(v29);
        sub_100048AE4();
        return v8;
      }
      sub_10004458C("Failed to fix %s\n", v40, v41, v42, v43, v44, v45, v46, (char)v14);
      uint64_t v38 = 1272;
    }
    sub_100048B34((char *)v38, v8);
    free(v29);
  }
  else
  {
    sub_100044674("failed to allocate memory for the bitmap block\n", v22, v23, v24, v25, v26, v27, v28, v48);
    uint64_t v8 = 12;
    sub_100048B34((char *)0x4F6, 12);
  }
  return v8;
}

uint64_t sub_100041E0C(uint64_t *a1)
{
  unsigned int v66 = 0;
  uint64_t v2 = a1[3];
  uint64_t v3 = *(unsigned int *)(v2 + 328);
  int v4 = dword_1000909F8;
  LODWORD(v5) = *(_DWORD *)(v2 + 160);
  uint64_t v65 = 0;
  uint64_t v6 = malloc_type_calloc(1uLL, dword_1000909F8, 0x80BC5E31uLL);
  uint64_t v7 = malloc_type_calloc(1uLL, dword_1000909F8 + 16, 0x80B0DBBFuLL);
  if (v6) {
    BOOL v15 = v7 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15)
  {
    sub_100044674("failed to allocate memory for the bitmap block\n", v8, v9, v10, v11, v12, v13, v14, v55);
    uint64_t v5 = 12;
    uint64_t v16 = 1273;
    int v17 = 12;
    goto LABEL_7;
  }
  uint64_t v18 = v7;
  if (!v5) {
    goto LABEL_50;
  }
  unsigned int v19 = 0;
  uint64_t v58 = v2 + v3;
  int v56 = v5;
  int v57 = 8 * v4;
  uint64_t v59 = (8 * v4) >> 6;
  while (1)
  {
    uint64_t v20 = *(unsigned __int16 *)(v58 + 2 * v19);
    uint64_t v21 = a1[3];
    int v22 = *(_DWORD *)(v21 + 164);
    if ((v22 & 0x7FFFFFFFu) <= v20)
    {
      LODWORD(v5) = 22;
LABEL_49:
      sub_10004458C("error (%d) looking up spaceman IP bitmap block at index %u\n", v8, v20, v10, v11, v12, v13, v14, v5);
      sub_100048B34((char *)0x4FA, v5);
LABEL_50:
      free(v6);
      free(v18);
      if (v66) {
        return v66;
      }
      else {
        return v5;
      }
    }
    uint64_t v23 = *(void *)(v21 + 168);
    if ((v22 & 0x80000000) == 0)
    {
      uint64_t v24 = v23 + v20;
      uint64_t v65 = v24;
      goto LABEL_15;
    }
    int v25 = sub_100030FD4((uint64_t)a1, v23, v20, &v65, 0);
    if (v25)
    {
      LODWORD(v5) = v25;
      goto LABEL_49;
    }
    uint64_t v24 = v65;
LABEL_15:
    int v26 = sub_10002F148(*a1, v24);
    if (v26)
    {
      LODWORD(v5) = v26;
      sub_10004458C("error (%d) reading spaceman IP bitmap block at index %u, addr 0x%llx\n", v27, v28, v29, v30, v31, v32, v33, v26);
      sub_100048B34((char *)0x4FB, v5);
      goto LABEL_50;
    }
    bzero(v18, *(unsigned int *)(a1[1] + 36));
    if (v19 == *(_DWORD *)(v2 + 160) - 1)
    {
      uint64_t v35 = *(void *)(v2 + 152);
      unint64_t v36 = (v35 & 0x7FFFFFFFFFFFFFFFuLL) % (8 * *(_DWORD *)(v2 + 32));
    }
    else
    {
      unint64_t v36 = (8 * *(_DWORD *)(v2 + 32));
      uint64_t v35 = *(void *)(v2 + 152);
    }
    uint64_t v63 = 0;
    uint64_t v64 = 0;
    uint64_t v60 = v65;
    uint64_t v61 = 0;
    unint64_t v62 = 0;
    if (v35 < 0) {
      break;
    }
    unint64_t v37 = v19 * v57;
    uint64_t v38 = a1[3];
    uint64_t v39 = *(void *)(v38 + 152);
    if ((v39 & 0x7FFFFFFFFFFFFFFFuLL) <= v37)
    {
      uint64_t v53 = 22;
LABEL_55:
      sub_10004458C("error (%d) looking up spaceman IP block address at index %u\n", v8, v34, v10, v11, v12, v13, v14, v53);
      sub_100048B34((char *)0x500, v53);
      return v53;
    }
    uint64_t v40 = *(void *)(v38 + 176);
    if (v39 < 0)
    {
      uint64_t v52 = sub_100030FD4((uint64_t)a1, v40, v19 * v57, &v64, (unint64_t *)&v63);
      if (v52)
      {
        uint64_t v53 = v52;
        goto LABEL_55;
      }
      uint64_t v41 = v64;
    }
    else
    {
      uint64_t v41 = v40 + v37;
      uint64_t v64 = v41;
    }
    uint64_t v61 = v41;
    int v51 = sub_100041B24((uint64_t)a1, v41, v36, (char *)v18, (char *)v6, (uint64_t)&v60, &v66);
    if (v51)
    {
LABEL_41:
      LODWORD(v5) = v51;
      goto LABEL_50;
    }
LABEL_39:
    if (++v19 == v56)
    {
      LODWORD(v5) = 0;
      goto LABEL_50;
    }
  }
  if (!v36) {
    goto LABEL_39;
  }
  unint64_t v42 = 0;
  unint64_t v43 = 0;
  uint64_t v44 = v19 * v57;
  while (2)
  {
    uint64_t v45 = a1[3];
    uint64_t v46 = *(void *)(v45 + 152);
    if ((v46 & 0x7FFFFFFFFFFFFFFFuLL) <= v43 + v44)
    {
      uint64_t v5 = 22;
      goto LABEL_46;
    }
    uint64_t v47 = *(void *)(v45 + 176);
    if ((v46 & 0x8000000000000000) == 0)
    {
      uint64_t v48 = v47 + v43 + v44;
      uint64_t v64 = v48;
LABEL_30:
      if (v42 >= v36 - v43) {
        unint64_t v50 = v36 - v43;
      }
      else {
        unint64_t v50 = v42;
      }
      unint64_t v62 = v43;
      uint64_t v63 = v50;
      uint64_t v61 = v48;
      int v51 = sub_100041B24((uint64_t)a1, v48, v50, (char *)v18, (char *)v6, (uint64_t)&v60, &v66);
      if (v51) {
        goto LABEL_41;
      }
      sub_10000A874(v6, v59, v63);
      unint64_t v42 = v63;
      v43 += v63;
      if (v43 >= v36) {
        goto LABEL_39;
      }
      continue;
    }
    break;
  }
  uint64_t v49 = sub_100030FD4((uint64_t)a1, v47, v43 + v44, &v64, (unint64_t *)&v63);
  if (!v49)
  {
    unint64_t v42 = v63;
    uint64_t v48 = v64;
    goto LABEL_30;
  }
  uint64_t v5 = v49;
LABEL_46:
  sub_10004458C("error (%d) looking up spaceman IP block address at index %llu\n", v8, v34, v10, v11, v12, v13, v14, v5);
  uint64_t v16 = 1276;
  int v17 = v5;
LABEL_7:
  sub_100048B34((char *)v16, v17);
  return v5;
}

uint64_t sub_1000421C8(uint64_t *a1, uint64_t a2, void *a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), char **a5, int a6)
{
  uint64_t v12 = a1[3];
  unsigned int v116 = 0;
  uint64_t v115 = 0;
  int v113 = 0;
  uint64_t v13 = v12 + 48 * a2;
  if (byte_100091F08 | byte_100091F70) {
    byte_1000746A0 = 0;
  }
  unint64_t v14 = *(unsigned int *)(v12 + 36);
  unint64_t v17 = *(void *)(v13 + 48);
  uint64_t v16 = (void *)(v13 + 48);
  unint64_t v15 = v17;
  if (!a4 && !a6) {
    return 0;
  }
  unint64_t v106 = v15;
  uint64_t v19 = sub_1000427CC(a1);
  if (v19)
  {
    uint64_t v18 = v19;
    char v20 = strerror(v19);
    sub_10004458C("error (%s) failed to populate free queue trees \n", v21, v22, v23, v24, v25, v26, v27, v20);
    sub_100048B34((char *)0x4FE, v18);
    return v18;
  }
  unint64_t v101 = v14;
  uint64_t v103 = a3;
  *(void *)&long long v28 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v28 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v111[22] = v28;
  long long v112 = v28;
  uint64_t v29 = a2;
  v111[20] = v28;
  v111[21] = v28;
  v111[18] = v28;
  v111[19] = v28;
  v111[16] = v28;
  v111[17] = v28;
  v111[14] = v28;
  v111[15] = v28;
  v111[12] = v28;
  v111[13] = v28;
  v111[10] = v28;
  v111[11] = v28;
  v111[8] = v28;
  v111[9] = v28;
  v111[7] = v28;
  v111[5] = v28;
  v111[6] = v28;
  v111[3] = v28;
  v111[4] = v28;
  v111[1] = v28;
  v111[2] = v28;
  v111[0] = v28;
  uint64_t v30 = malloc_type_malloc(*(unsigned int *)(a1[1] + 36), 0x5A308868uLL);
  uint64_t v31 = (char *)malloc_type_malloc(*(unsigned int *)(a1[1] + 36), 0xC5EA4E84uLL);
  int v114 = v31;
  if (!v30 || !v31)
  {
    sub_100044674("Space Verification: failed to allocate memory for the bitmap block\n", v32, v33, v34, v35, v36, v37, v38, v96);
    unsigned int v80 = 12;
    sub_100048B34((char *)0x1D9, 12);
    goto LABEL_68;
  }
  if (v103) {
    *uint64_t v103 = 0;
  }
  int v97 = a6;
  uint64_t v100 = v30;
  unint64_t v39 = v106;
  if (!v106)
  {
    uint64_t v41 = 0;
LABEL_50:
    uint64_t v29 = a2;
    if (*(void *)(v12 + 48 * a2 + 72) == v41)
    {
      unsigned int v80 = 0;
      uint64_t v30 = v100;
      int v81 = v97;
    }
    else
    {
      byte_100090A02[a2] = 1;
      int v81 = v97;
      if (v97)
      {
        uint64_t v82 = (uint64_t)a1;
        uint64_t v83 = v41;
        unsigned int v84 = sub_100042ADC(v82, a2, v41, v34, v35, v36, v37, v38);
        unsigned int v80 = v84;
        uint64_t v30 = v100;
        if (v84) {
          unsigned int v116 = v84;
        }
        uint64_t v41 = v83;
      }
      else
      {
        unsigned int v80 = 0;
        uint64_t v30 = v100;
      }
    }
    uint64_t v85 = 40;
    if (a2) {
      uint64_t v85 = 80;
    }
    if (*(void *)(v12 + v85 + 200) > (unint64_t)(*v16 - v41))
    {
      byte_100090A02[a2] = 1;
      if (v81)
      {
        uint64_t v86 = "main";
        if (a2) {
          uint64_t v86 = "tier2";
        }
        sub_10004458C("sm : free queue tree TIER (%s) has sfq_count (%llu) greater than available block count (%llu)\n", v32, v41, v34, v35, v36, v37, v38, (char)v86);
        sub_100048B34((char *)0x307, 92);
        unsigned int v116 = 92;
      }
    }
    goto LABEL_68;
  }
  unint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v99 = a4;
  unint64_t v42 = &v107;
  if (a5) {
    unint64_t v42 = a5;
  }
  uint64_t v98 = (uint64_t)v42;
  uint64_t v102 = &byte_100090A02[a2];
  unint64_t v43 = v101;
  while (1)
  {
    uint64_t v105 = v41;
    unint64_t v44 = v40;
    if (a2) {
      unint64_t v44 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(a1[1] + 36)))) | v40;
    }
    if (v40)
    {
      if (!v114 || BYTE8(v112) == 0) {
        goto LABEL_25;
      }
    }
    int v46 = sub_10000C9C0(a1, v40 / *(unsigned int *)(v12 + 36), a2, (void **)&v114);
    if (v46) {
      break;
    }
    unsigned int v47 = sub_10000D12C((uint64_t)v111, a1, (uint64_t)v114, (uint64_t **)&v115, &v113);
    if (v47) {
      goto LABEL_52;
    }
LABEL_25:
    unint64_t v48 = v43;
    uint64_t v30 = v100;
    bzero(v100, *(unsigned int *)(a1[1] + 36));
    unint64_t v104 = v39 - v48;
    if (v39 < v48) {
      unint64_t v48 = v39;
    }
    unsigned int v49 = sub_10001FF8C((uint64_t)&unk_100091EB8 + 104 * a2, v40, (v48 + 63) & 0x1FFFFFFC0, (uint64_t)v100);
    if (v49)
    {
      unsigned int v80 = v49;
      uint64_t v29 = a2;
      goto LABEL_68;
    }
    uint64_t v107 = v115;
    int v109 = -1431655766;
    int v108 = v113;
    uint64_t v110 = v114;
    unsigned int v47 = sub_10004136C((uint64_t)a1, a2, 0, v44, (char *)v100, v115, v48, v99, v98, v102, &v116);
    if (v47)
    {
LABEL_52:
      unsigned int v80 = v47;
      goto LABEL_67;
    }
    unint64_t v50 = sub_10000A3F4((uint64_t)v115, 0, 0, v48);
    unint64_t v57 = v50;
    if (v103) {
      *v103 += v48 - v50;
    }
    uint64_t v58 = a1[1];
    uint64_t v59 = *(void *)(v58 + 1248);
    if (v59)
    {
      v117[0] = 0xAAAAAAAAAAAAAAAALL;
      unint64_t v60 = sub_10004E4FC(v44, v48, *(void *)(v58 + 1240), v59, v117);
      unint64_t v61 = v57;
      if (v60) {
        unint64_t v61 = v57 - sub_10000A3F4((uint64_t)v115, 0, v117[0] - v44, v117[0] - v44 + v60);
      }
    }
    else
    {
      unint64_t v61 = v50;
    }
    unint64_t v62 = v114;
    uint64_t v63 = &v114[32 * v113];
    int v65 = *((_DWORD *)v63 + 15);
    uint64_t v64 = v63 + 60;
    uint64_t v66 = v65 & 0xFFFFF;
    if ((v57 & 0xFFFFF) != v66)
    {
      *uint64_t v102 = 1;
      if (v97)
      {
        sub_10004458C("cib: ci_free_count (%u) is not valid (%llu) (ci_addr 0x%llx)\n", v51, v52, v59, v53, v54, v55, v56, v66);
        if (!sub_10004641C(qword_100091B70, "Fix ci_free_count (%u)? ", v67, v68, v69, v70, v71, v72, *v64))
        {
          int v77 = 92;
          uint64_t v78 = 676;
          int v79 = 92;
          goto LABEL_41;
        }
        *(_DWORD *)uint64_t v64 = v57 & 0xFFFFF | (*(_DWORD *)v64 >> 20);
        unsigned int v75 = *(_DWORD *)(a1[1] + 36);
        v117[0] = v62[1];
        v117[1] = v75;
        v117[2] = 0;
        int v76 = sub_100026BA0(a1, 0, (uint64_t)v62, (uint64_t)v117, v73, v74);
        if (v76)
        {
          int v77 = v76;
          uint64_t v78 = 675;
          int v79 = v77;
LABEL_41:
          sub_100048B34((char *)v78, v79);
          unsigned int v116 = v77;
          goto LABEL_43;
        }
        sub_100048AE4();
      }
    }
LABEL_43:
    if (v115)
    {
      free(v115);
      uint64_t v115 = 0;
    }
    unsigned int v47 = sub_10000CFB0((uint64_t)v111, (uint64_t **)&v115, &v113);
    if (v47) {
      goto LABEL_52;
    }
    unint64_t v39 = v104;
    uint64_t v41 = v61 + v105;
    unint64_t v43 = v101;
    v40 += v101;
    if (v40 >= v106) {
      goto LABEL_50;
    }
  }
  unsigned int v80 = v46;
  char v87 = strerror(v46);
  sub_10004458C("error (%s) failed to get cib for chunk index %llu \n", v88, v89, v90, v91, v92, v93, v94, v87);
LABEL_67:
  uint64_t v29 = a2;
  uint64_t v30 = v100;
LABEL_68:
  if (v115)
  {
    free(v115);
    uint64_t v115 = 0;
  }
  if (v30) {
    free(v30);
  }
  if (v114) {
    free(v114);
  }
  byte_100090A04[v29] = 0;
  if (v116) {
    return v116;
  }
  else {
    return v80;
  }
}

uint64_t sub_1000427CC(uint64_t *a1)
{
  if (byte_100090A01 != 1) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = a1 + 57;
  for (uint64_t i = dword_100092070; ; i += 16)
  {
    uint64_t v51 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&long long v5 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v5 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v50[3] = v5;
    v50[4] = v5;
    v50[1] = v5;
    _OWORD v50[2] = v5;
    v50[0] = v5;
    BOOL v49 = v2 == 0;
    uint64_t v6 = sub_10002CC40(a1, v2, &v51);
    if (v6) {
      return v6;
    }
    if (*(void *)(v51 + 56))
    {
      uint64_t v7 = sub_100038D78((uint64_t)v50, v51, 0, 0, 0);
      if (v7
        || (uint64_t v7 = sub_10002C46C((uint64_t)v50, (uint64_t (*)(void, void, void, void, uint64_t))sub_100043468, (uint64_t)&v49, 0), v7))
      {
        uint64_t v14 = v7;
        char v15 = strerror(v7);
        sub_10004458C("failed to iterate the spaceman free queue tree: %s\n", v16, v17, v18, v19, v20, v21, v22, v15);
        sub_100048B34((char *)0x314, v14);
        return v14;
      }
      if ((v49 & 2) != 0) {
        break;
      }
    }
LABEL_16:
    if (++v2 == 3)
    {
      uint64_t v14 = 0;
      byte_100090A01 = 0;
      return v14;
    }
  }
  uint64_t v8 = v51;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  _OWORD v58[2] = v9;
  v58[3] = v9;
  v58[0] = v9;
  v58[1] = v9;
  v57[3] = v9;
  v57[4] = v9;
  v57[1] = v9;
  v57[2] = v9;
  v56[4] = v9;
  v57[0] = v9;
  v56[2] = v9;
  v56[3] = v9;
  v56[0] = v9;
  v56[1] = v9;
  _OWORD v55[3] = v9;
  v55[4] = v9;
  v55[1] = v9;
  v55[2] = v9;
  v55[0] = v9;
  if (!sub_100038040((uint64_t)v58, 0, 0, 0x8000000, 2, 0, 0, 4096, 16, 8, 0, 0, (uint64_t)sub_10003FA10))sub_10003A18C((uint64_t)v58, 0, 0); {
  uint64_t v10 = sub_100038D78((uint64_t)v57, v8, 0, 0, 0);
  }
  if (v10
    || (uint64_t v10 = sub_10002C46C((uint64_t)v57, (uint64_t (*)(void, void, void, void, uint64_t))sub_1000436E0, (uint64_t)v58, 0), v10))
  {
    uint64_t v14 = v10;
    char v23 = strerror(v10);
    sub_10004458C("error copying on-disk free queue tree into reordered tree in memory: %s\n", v24, v25, v26, v27, v28, v29, v30, v23);
    uint64_t v31 = 923;
    goto LABEL_27;
  }
  uint64_t v52 = v3;
  int v54 = -1431655766;
  int v53 = v2;
  uint64_t v11 = sub_100038D78((uint64_t)v56, (uint64_t)v58, 0, 0, 0);
  if (v11)
  {
    uint64_t v14 = v11;
LABEL_25:
    char v32 = strerror(v14);
    sub_10004458C("unable to init iterators for free queue tree repair: %s\n", v33, v34, v35, v36, v37, v38, v39, v32);
    uint64_t v31 = 924;
    goto LABEL_27;
  }
  uint64_t v12 = sub_100038D78((uint64_t)v55, (uint64_t)i, 0, 0, 0);
  if (v12)
  {
    uint64_t v14 = v12;
    if (*(void *)&v56[0]) {
      (*(void (**)(_OWORD *))&v56[0])(v56);
    }
    goto LABEL_25;
  }
  uint64_t v13 = sub_10002C50C((uint64_t)v56, (uint64_t)v55, (uint64_t (*)(long long *, long long *, int *, uint64_t))sub_10004374C, (uint64_t)&v52);
  if (!v13)
  {
    sub_10003A268((uint64_t)v58, 0);
    goto LABEL_16;
  }
  uint64_t v14 = v13;
  char v40 = strerror(v13);
  sub_10004458C("error iterating trees during free queue tree repair: %s\n", v41, v42, v43, v44, v45, v46, v47, v40);
  uint64_t v31 = 925;
LABEL_27:
  sub_100048B34((char *)v31, v14);
  sub_10003A268((uint64_t)v58, 0);
  return v14;
}

uint64_t sub_100042ADC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a2;
  uint64_t v11 = 3 * a2;
  sub_10004458C("sm: sm_free_count (%llu) is not valid (%llu) (sm_dev %d)\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(*(void *)(a1 + 24) + 48 * a2 + 72));
  if (sub_10004641C(qword_100091B70, "Fix sm_free_count (%llu)? ", v12, v13, v14, v15, v16, v17, *(void *)(*(void *)(a1 + 24) + 16 * v11 + 72)))
  {
    uint64_t v19 = *(void *)(a1 + 24);
    *(void *)(v19 + 48 * v9 + 72) = a3;
    int8x16_t v24 = *(int8x16_t *)(a1 + 88);
    uint64_t v25 = *(void *)(a1 + 104);
    uint64_t v20 = sub_100026BA0((uint64_t *)a1, 0, v19, (uint64_t)&v24, v24, v18);
    if (!v20)
    {
      sub_100048AE4();
      return v20;
    }
    uint64_t v21 = 677;
    int v22 = v20;
  }
  else
  {
    uint64_t v20 = 92;
    uint64_t v21 = 678;
    int v22 = 92;
  }
  sub_100048B34((char *)v21, v22);
  return v20;
}

uint64_t sub_100042BCC(uint64_t *a1)
{
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v2 = sub_1000427CC(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    char v4 = strerror(v2);
    sub_10004458C("error (%s) failed to populate free queue trees \n", v5, v6, v7, v8, v9, v10, v11, v4);
    sub_100048B34((char *)0x4FF, v3);
  }
  else
  {
    LODWORD(v3) = sub_100041E0C(a1);
    if (byte_100090A04[0] | byte_100090A02[0] || *(unsigned char *)(qword_100091B78 + 40)) {
      unsigned int v19 = sub_1000421C8(a1, 0, &v58, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100042DF4, 0, 1);
    }
    else {
      unsigned int v19 = 0;
    }
    if ((*(unsigned char *)(a1[1] + 65) & 1) != 0
      && (byte_100090A05 | byte_100090A03 || *(unsigned char *)(qword_100091B78 + 40)))
    {
      unsigned int v20 = sub_1000421C8(a1, 1, &v57, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100042DF4, 0, 1);
    }
    else
    {
      unsigned int v20 = 0;
    }
    if (*(unsigned char *)(qword_100091B78 + 39))
    {
      char v22 = v57;
      char v21 = v58;
      sub_10004435C("\nSpace allocation summary:\n\n", v12, v13, v14, v15, v16, v17, v18, v56);
      sub_10004435C("%-20s%-15s\n", v23, v24, v25, v26, v27, v28, v29, (char)"category");
      sub_10004435C("%-20s%-15s\n", v30, v31, v32, v33, v34, v35, v36, (char)"--------");
      uint64_t v44 = 0;
      char v45 = 0;
      do
      {
        uint64_t v46 = *(void *)((char *)&xmmword_100091048 + v44 * 8);
        if (v46)
        {
          v45 += v46;
          sub_10004435C("%-20s%-15llu\n", v37, v38, v39, v40, v41, v42, v43, (char)off_100070918[v44]);
        }
        ++v44;
      }
      while (v44 != 12);
      sub_10004435C("\nTotal blocks marked by fsck: %llu\n", v37, v38, v39, v40, v41, v42, v43, v45);
      sub_10004435C("Total blocks allocated by spaceman: %llu\n\n", v47, v48, v49, v50, v51, v52, v53, v22 + v21);
    }
    if (v19) {
      unsigned int v54 = v19;
    }
    else {
      unsigned int v54 = v20;
    }
    if (v3) {
      return v3;
    }
    else {
      return v54;
    }
  }
  return v3;
}

uint64_t sub_100042DF4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 - 3) < 0xFFFFFFFE) {
    return 22;
  }
  if (!a3) {
    return 0;
  }
  if (((a2 << __clz(__rbit64(*(unsigned int *)(a1[1] + 36)))) & 0x4000000000000000) != 0) {
    uint64_t v14 = "Secondary";
  }
  else {
    uint64_t v14 = "Main";
  }
  uint64_t v15 = *(void *)(*(void *)(a5 + 16) + 32 * *(unsigned int *)(a5 + 8) + 64);
  if (a4 == 1) {
    uint64_t v16 = "underallocation";
  }
  else {
    uint64_t v16 = "overallocation";
  }
  if (a4 == 1)
  {
    sub_10004458C("underallocation detected on %s device: (0x%llx+%llu) bitmap address (0x%llx)\n", a2, a3, a4, a5, a6, a7, a8, (char)v14);
    sub_100048B34((char *)0x1DA, 92);
  }
  else
  {
    sub_100044674("overallocation detected on %s device: (0x%llx+%llu) bitmap address (0x%llx)\n", a2, a3, a4, a5, a6, a7, a8, (char)v14);
    sub_100048B34((char *)0x1DB, 92);
    if (!*(unsigned char *)(qword_100091B78 + 41))
    {
      if (a2 != 1) {
        return 92;
      }
      uint64_t v30 = a1[1];
      if ((*(unsigned char *)(v30 + 65) & 1) != 0 || *(_DWORD *)(v30 + 36) != 4096 || !(*(void *)(v30 + 40) >> 29)) {
        return 92;
      }
    }
  }
  if (!sub_10004641C(qword_100091B70, "Fix %s (0x%llx+%llu) bitmap address (0x%llx)? ", v17, v18, v19, v20, v21, v22, (char)v16))return 92; {
  uint64_t v8 = sub_100004BC0(a1, 0, a2, a3, v15, *(void *)a5, *(void **)(a5 + 16), a4, 0, 0);
  }
  if (v8)
  {
    sub_10004458C("Failed to fix %s\n", v23, v24, v25, v26, v27, v28, v29, (char)v16);
    sub_100048B34((char *)0x316, v8);
  }
  else
  {
    sub_100048AE4();
  }
  return v8;
}

uint64_t sub_100042FC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(unint64_t, unint64_t, uint64_t), uint64_t a5)
{
  unint64_t v10 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)))) & a2;
  if (sub_10001FF7C((uint64_t)&unk_100091EB8 + 104 * (v10 != 0)))
  {
    unint64_t v18 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)))) & a2;
    unint64_t v19 = v18 + a3;
    unint64_t v26 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v27 = 0xAAAAAAAAAAAAAAAALL;
    while (v19 > v18 && sub_10002029C((uint64_t)&unk_100091EB8 + 104 * (v10 != 0), v18, v19 - v18, &v27))
    {
      if ((sub_100020178((uint64_t)&unk_100091EB8, v27, v19 - v27, &v26) & 1) == 0) {
        unint64_t v26 = v19;
      }
      if (v10)
      {
        unint64_t v20 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)));
        unint64_t v21 = v20 | v27;
        unint64_t v22 = v20 | v26;
      }
      else
      {
        unint64_t v22 = v26;
        unint64_t v21 = v27;
      }
      uint64_t v23 = a4(v21, v22 - v21, a5);
      unint64_t v18 = v26;
      if (v23) {
        return v23;
      }
    }
    return 0;
  }
  else
  {
    sub_10004458C("unexpected: space verification data structure not initialized", v11, v12, v13, v14, v15, v16, v17, v26);
    uint64_t v24 = 22;
    sub_100048B34((char *)0x434, 22);
  }
  return v24;
}

uint64_t sub_100043130(uint64_t a1, uint64_t (*a2)(unint64_t, unint64_t, uint64_t), uint64_t a3)
{
  char v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)(a1 + 24);
  char v9 = 1;
  do
  {
    while (1)
    {
      char v10 = v9;
      uint64_t v11 = (v6 & 1) != 0
          ? 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)))
          : 0;
      uint64_t v12 = *(void *)(v8 + 48 * v7 + 48);
      if (!v12) {
        break;
      }
      uint64_t result = sub_100042FC4(a1, v11, v12, a2, a3);
      char v9 = 0;
      char v6 = 1;
      uint64_t v7 = 1;
      if (((result == 0) & v10) == 0) {
        return result;
      }
    }
    char v9 = 0;
    uint64_t v7 = 1;
    char v6 = 1;
  }
  while ((v10 & 1) != 0);
  return 0;
}

uint64_t sub_1000431FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  *(_DWORD *)(a5 + 8) = 0;
  *(unsigned char *)(a5 + 21) = 1;
  if (*(int *)(a5 + 12) >= 1)
  {
    int v7 = 0;
    char v9 = -86;
    do
    {
      if (!*(unsigned char *)(*(void *)a5 + 24 * v7 + 16))
      {
        uint64_t result = sub_1000051A8(*(void *)(*(void *)a5 + 24 * v7), *(void *)(*(void *)a5 + 24 * v7 + 8), *(void *)a3, *(void *)(a3 + 8), &v9, (uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t))sub_10004335C, a5);
        if (result) {
          return result;
        }
        int v7 = *(_DWORD *)(a5 + 8);
        if (!v9) {
          *(_DWORD *)(a5 + 8) = ++v7;
        }
      }
    }
    while (v7 < *(_DWORD *)(a5 + 12));
  }
  return 0;
}

uint64_t sub_1000432BC(unsigned int a1, void *a2, void *a3, uint64_t a4)
{
  unsigned int v17 = 16;
  unsigned int v16 = 8;
  uint64_t v5 = sub_1000380B0((uint64_t)&unk_100092070 + 64 * (unint64_t)a1, 0, a4, a2, &v17, 0x10u, a3, &v16);
  uint64_t v6 = v5;
  if ((v5 & 0xFFFFFFFD) != 0)
  {
    uint64_t v7 = a2[1];
    strerror(v5);
    sub_10004458C("Space Verification: failed to lookup paddr (%llu) : error %s\n", v8, v9, v10, v11, v12, v13, v14, v7);
    sub_100048B34((char *)0x364, v6);
  }
  return v6;
}

uint64_t sub_10004335C(uint64_t a1, uint64_t a2, int a3, char **a4)
{
  int v8 = *((_DWORD *)a4 + 2);
  int v9 = v8;
  if (a3)
  {
    uint64_t v10 = *a4;
    *((unsigned char *)a4 + 20) = (*a4)[24 * v8 + 16];
  }
  else
  {
    int v11 = *((_DWORD *)a4 + 3);
    uint64_t v12 = *a4;
    if (v11 == *((_DWORD *)a4 + 4))
    {
      *((_DWORD *)a4 + 4) = 2 * v11;
      uint64_t v12 = (char *)malloc_type_realloc(v12, 48 * v11, 0x100004057661CB1uLL);
      if (!v12)
      {
        free(*a4);
        *a4 = 0;
        return 12;
      }
      *a4 = v12;
      int v11 = *((_DWORD *)a4 + 3);
    }
    memmove(&v12[24 * v8 + 24], &v12[24 * v8], 24 * (v11 - v8));
    int v8 = *((_DWORD *)a4 + 2);
    ++*((_DWORD *)a4 + 3);
    uint64_t v10 = *a4;
  }
  uint64_t result = 0;
  uint64_t v14 = &v10[24 * v9];
  *(void *)uint64_t v14 = a1;
  *((void *)v14 + 1) = a2;
  uint64_t v15 = 20;
  if (a3) {
    uint64_t v15 = 21;
  }
  v14[16] = *((unsigned char *)a4 + v15);
  *((_DWORD *)a4 + 2) = v8 + 1;
  return result;
}

uint64_t sub_100043468(long long *a1, int a2, uint64_t *a3, int a4, int *a5)
{
  uint64_t v5 = 22;
  if (a2 == 16 && (a4 & 0xFFFFFFF7) == 0)
  {
    int v7 = *a5;
    long long v47 = *a1;
    uint64_t v8 = 1;
    if (a3 && a4) {
      uint64_t v8 = *a3;
    }
    uint64_t v46 = v8;
    long long v9 = v47;
    long long v45 = *a1;
    unint64_t v44 = 0xAAAAAAAAAAAAAAAALL;
    if (v7)
    {
      unsigned int v10 = 0;
    }
    else if (((*((void *)&v47 + 1) << __clz(__rbit64(dword_1000909F8))) & 0x4000000000000000) != 0)
    {
      unsigned int v10 = 2;
    }
    else
    {
      unsigned int v10 = 1;
    }
    uint64_t v5 = sub_1000432BC(v10, &v45, &v44, 4294967294);
    if (v5 == 2 && (uint64_t v5 = sub_1000432BC(v10, &v45, &v44, 1), v5 == 2))
    {
      uint64_t v18 = v10;
LABEL_33:
      uint64_t v34 = sub_100039A6C(&dword_100092070[16 * v18], 0, &v47, 16, &v46, 8);
      uint64_t v5 = v34;
      if (v34)
      {
        char v35 = BYTE8(v47);
        strerror(v34);
        sub_10004458C("Space Verification: failed to insert paddr (%llu) error : %s\n", v36, v37, v38, v39, v40, v41, v42, v35);
        sub_100048B34((char *)0x365, v5);
      }
    }
    else if (!v5)
    {
      unint64_t v19 = v9;
      uint64_t v20 = v8;
      uint64_t v21 = *((void *)&v9 + 1);
      do
      {
        if (*((void *)&v45 + 1) >= (unint64_t)(v20 + v21))
        {
          uint64_t v18 = v10;
          goto LABEL_33;
        }
        if (v44 + *((void *)&v45 + 1) > v21)
        {
          sub_100044674("found spaceman free queue tree entry (0x%llx+%llu, xid %llu) which overlaps with existing range (0x%llx+%llu)\n", v11, v12, v13, v14, v15, v16, v17, SBYTE8(v9));
          sub_100048B34((char *)0x1CE, -7);
          *a5 |= 2u;
          if (v21 >= *((uint64_t *)&v45 + 1)) {
            uint64_t v22 = *((void *)&v45 + 1);
          }
          else {
            uint64_t v22 = v21;
          }
          if (v21 - v22 + v20 <= *((void *)&v45 + 1) - v22 + v44) {
            uint64_t v20 = *((void *)&v45 + 1) - v22 + v44;
          }
          else {
            v20 += v21 - v22;
          }
          if (v19 <= (unint64_t)v45) {
            unint64_t v19 = v45;
          }
          int v23 = sub_10003A048((uint64_t)&dword_100092070[16 * (unint64_t)v10], 0, (uint64_t)&v45, 16);
          if (v23)
          {
            int v24 = v23;
            char v25 = BYTE8(v45);
            strerror(v23);
            sub_10004458C("Space Verification: failed to remove paddr (%llu) error : %s\n", v26, v27, v28, v29, v30, v31, v32, v25);
            sub_100048B34((char *)0x366, v24);
          }
          *(void *)&long long v47 = v19;
          *((void *)&v47 + 1) = v22;
          uint64_t v21 = v22;
          uint64_t v46 = v20;
        }
        uint64_t v33 = sub_1000432BC(v10, &v45, &v44, 2);
      }
      while (!v33);
      uint64_t v5 = v33;
      uint64_t v18 = v10;
      if (v33 == 2) {
        goto LABEL_33;
      }
    }
  }
  return v5;
}

uint64_t sub_1000436E0(const void *a1, uint64_t a2, uint64_t *a3, int a4, _DWORD *a5)
{
  if ((a4 & 0xFFFFFFF7) != 0) {
    return 22;
  }
  v9[1] = v5;
  v9[2] = v6;
  uint64_t v8 = 1;
  if (a3)
  {
    if (a4) {
      uint64_t v8 = *a3;
    }
  }
  v9[0] = v8;
  return sub_100039A6C(a5, 0, a1, a2, v9, 8);
}

uint64_t sub_10004374C(uint64_t *a1, uint64_t *a2, int *a3, _DWORD **a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned char *a8)
{
  uint64_t v8 = *a1;
  if (!*a1)
  {
    uint64_t v15 = "unexpected end of iteration while repairing free queue tree\n";
LABEL_14:
    sub_10004458C(v15, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, v8, a7, (uint64_t)a8, v19);
    return 22;
  }
  a8 = (unsigned char *)a1[1];
  uint64_t v10 = *a2;
  if (!*a2)
  {
LABEL_15:
    int v18 = 1;
    uint64_t result = sub_100027E70(*a4, *((_DWORD *)a4 + 2), 0, 0, 1, (long long *)v8, 0x10u, a8, 8u);
    goto LABEL_19;
  }
  uint64_t v11 = (unsigned char *)a2[1];
  uint64_t v12 = *(void *)(v10 + 8);
  uint64_t v13 = *(void *)(v8 + 8);
  if (v12 != v13)
  {
    unint64_t v16 = *(void *)a8;
    goto LABEL_9;
  }
  if (*(void *)v10 == *(void *)v8 && *(void *)v11 == *(void *)a8) {
    return 0;
  }
  if (*(void *)v10 <= *(void *)v8)
  {
    unint64_t v16 = *(void *)a8;
    if (*(void *)v11 <= *(void *)a8)
    {
LABEL_9:
      if (v12 <= v13 || v12 - v13 < v16)
      {
        uint64_t v19 = *(void *)(v8 + 8);
        uint64_t v15 = "unexpected on-disk range 0x%llx+%llu xid %llu and in-memory range 0x%llx+%llu xid %llu while repairing free queue tree\n";
        goto LABEL_14;
      }
      goto LABEL_15;
    }
  }
  int v18 = 2;
  uint64_t result = sub_100027E70(*a4, *((_DWORD *)a4 + 2), 2, 0, 1, (long long *)v10, 0x10u, v11, 8u);
LABEL_19:
  if (!result) {
    *a3 = v18;
  }
  return result;
}

FILE *sub_100043884(const char *a1)
{
  int v1 = open(a1, 777, 438);
  if (v1 < 0) {
    return 0;
  }
  int v2 = v1;
  v3.__darwin_time_t tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v3.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v6.st_blksize = v3;
  *(timespec *)v6.st_qspare = v3;
  v6.st_birthtimespec = v3;
  *(timespec *)&v6.off_t st_size = v3;
  v6.st_mtimespec = v3;
  v6.st_ctimespec = v3;
  *(timespec *)&v6.st_uid = v3;
  v6.st_atimespec = v3;
  *(timespec *)&v6.dev_t st_dev = v3;
  if (!fstat(v1, &v6) && (v6.st_mode & 0xF000) == 0x8000) {
    return fdopen(v2, "a");
  }
  close(v2);
  uint64_t v5 = __error();
  uint64_t result = 0;
  *uint64_t v5 = 1;
  return result;
}

void sub_10004392C()
{
  dword_1000746A8 = 0;
  uint64_t v0 = (FILE *)qword_1000910A8;
  uint64_t v1 = qword_1000910B8;
  uint64_t v2 = qword_1000910D8;
  if (qword_1000910A8) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = qword_1000910B8 == 0;
  }
  if (v3 && qword_1000910D8 == 0) {
    return;
  }
  uint64_t v5 = qword_1000910B0;
  time_t v17 = time(0);
  if (v1)
  {
    stat v6 = ctime(&v17);
    sub_100043C4C(2, (uint64_t)&qword_1000910A8, "fsck_apfs completed at %s\n", v6, 0);
  }
  else
  {
    if (!v0) {
      goto LABEL_43;
    }
    if (qword_100092138) {
      int v7 = (const char *)qword_100092138;
    }
    else {
      int v7 = "UNKNOWN-DEV";
    }
    uint64_t v8 = ctime(&v17);
    fprintf(v0, "%s: fsck_apfs completed at %s\n", v7, v8);
  }
  if (!v0 || dword_100092130)
  {
    if (v0)
    {
      if (v2 | v1 && dword_100092130 != 0)
      {
        pthread_mutex_lock(&stru_1000746B0);
        pthread_cond_broadcast(&stru_1000910E8);
        pthread_mutex_unlock(&stru_1000746B0);
        pthread_join((pthread_t)qword_100091118, 0);
        pthread_join((pthread_t)qword_100091120, 0);
        if (v2) {
          free((void *)v2);
        }
        qword_1000910D0 = 0;
        qword_1000910D8 = 0;
        qword_1000910E0 = 0;
        if (v1) {
          free((void *)v1);
        }
        qword_1000910B0 = 0;
        qword_1000910B8 = 0;
        qword_1000910C0 = 0;
        fflush(v0);
        fclose(v0);
        qword_1000910A8 = 0;
        goto LABEL_43;
      }
    }
    if (v1)
    {
      if (getuid() || (fflush(__stdoutp), fflush(__stderrp), !fork()))
      {
        memset(__b, 170, sizeof(__b));
        fclose(__stdoutp);
        fclose(__stdinp);
        fclose(__stderrp);
        if (getuid())
        {
          uid_t v10 = getuid();
          uint64_t v11 = getpwuid(v10);
          if (!v11) {
            goto LABEL_43;
          }
          uint64_t v12 = __b;
          snprintf(__b, 0x400uLL, "%s/Library/Logs/fsck_apfs.log", v11->pw_dir);
        }
        else
        {
          uint64_t v12 = "/var/log/fsck_apfs.log";
        }
        char v13 = 1;
        while (1)
        {
          char v14 = v13;
          uint64_t v15 = sub_100043884(v12);
          if (v15)
          {
            if (v5) {
              break;
            }
          }
          if (*__error() == 30)
          {
            sleep(1u);
            char v13 = 0;
            if (v14) {
              continue;
            }
          }
          goto LABEL_43;
        }
        unint64_t v16 = v15;
        fwrite((const void *)v1, v5 - v1, 1uLL, v15);
        fflush(v16);
        fclose(v16);
        qword_1000910A8 = 0;
        free((void *)v1);
        qword_1000910B0 = 0;
        qword_1000910B8 = 0;
        qword_1000910C0 = 0;
      }
    }
  }
  else
  {
    fflush(v0);
    fclose(v0);
    qword_1000910A8 = 0;
  }
LABEL_43:
  if (qword_1000910D8) {
    free((void *)qword_1000910D8);
  }
  if (qword_1000910B8) {
    free((void *)qword_1000910B8);
  }
}

uint64_t sub_100043C4C(uint64_t result, uint64_t a2, char *__format, const char *a4, va_list a5)
{
  va_list v18 = 0;
  if (*(void *)(a2 + 8) && *(void *)(a2 + 16))
  {
    int v8 = result;
    if (result == 1) {
      va_list v18 = a5;
    }
    if (dword_100092130 && *(FILE **)a2 == __stdoutp) {
      pthread_mutex_lock(&stru_1000746B0);
    }
    long long v9 = *(char **)(a2 + 8);
    uid_t v10 = *(unsigned char **)(a2 + 16);
    size_t v11 = *(void *)(a2 + 24);
    int64_t v12 = v9 - v10;
    if (v8 == 1) {
      uint64_t result = vsnprintf(*(char **)(a2 + 8), v11 - (v9 - v10), __format, a5);
    }
    else {
      uint64_t result = snprintf(v9, v11 - (v9 - v10), "%s", a4);
    }
    if (v11 - (v9 - v10) >= (int)result)
    {
      v9 += (int)result;
    }
    else
    {
      if ((int)result >= 4096) {
        int v13 = (result + 4095) & 0xFFFFF000;
      }
      else {
        int v13 = 4096;
      }
      size_t v14 = v11 + v13;
      if (!(v14 >> 20))
      {
        uint64_t result = (uint64_t)malloc_type_realloc(v10, v14, 0x47F31725uLL);
        if (result)
        {
          uint64_t v15 = result;
          uint64_t v16 = result + v12;
          if (v8 == 1) {
            uint64_t result = vsnprintf((char *)(result + v12), v14 - v12, __format, v18);
          }
          else {
            uint64_t result = snprintf((char *)(result + v12), v14 - v12, "%s", a4);
          }
          uint64_t v17 = (int)result;
          if (v14 - v12 < (int)result) {
            uint64_t v17 = 0;
          }
          long long v9 = (char *)(v16 + v17);
          uid_t v10 = (unsigned char *)v15;
          size_t v11 = v14;
        }
      }
    }
    *(void *)(a2 + 8) = v9;
    *(void *)(a2 + --*(_DWORD *)(result + 16) = v10;
    *(void *)(a2 + 24) = v11;
    if (dword_100092130)
    {
      if (*(FILE **)a2 == __stdoutp)
      {
        pthread_cond_signal(&stru_1000910E8);
        return pthread_mutex_unlock(&stru_1000746B0);
      }
    }
  }
  return result;
}

uint64_t sub_100043E2C()
{
  uint64_t v0 = qword_1000910A8;
  setlinebuf(__stdoutp);
  uint64_t result = setlinebuf(__stderrp);
  dword_100092130 = byte_100092140;
  if (!v0)
  {
    uint64_t result = (uint64_t)sub_100043884("/var/log/fsck_apfs.log");
    if (result)
    {
      uint64_t v2 = (FILE *)result;
      qword_1000910A8 = result;
      setlinebuf((FILE *)result);
      if (dword_100092130)
      {
        BOOL v3 = malloc_type_malloc(0x1000uLL, 0xA27AA54CuLL);
        uint64_t result = (uint64_t)malloc_type_malloc(0x1000uLL, 0x5A11F06DuLL);
        if (v3 && result)
        {
          *BOOL v3 = 0;
          qword_1000910B0 = (uint64_t)v3;
          qword_1000910B8 = (uint64_t)v3;
          qword_1000910C0 = 4096;
          *(unsigned char *)uint64_t result = 0;
          qword_1000910C8 = (uint64_t)__stdoutp;
          qword_1000910D0 = result;
          qword_1000910D8 = result;
          qword_1000910E0 = 4096;
          time_t v7 = time(0);
          char v4 = ctime(&v7);
          uint64_t result = sub_100043C4C(2, (uint64_t)&qword_1000910A8, "\nfsck_apfs started at %s", v4, 0);
          if (dword_100092130)
          {
            pthread_cond_init(&stru_1000910E8, 0);
            pthread_create((pthread_t *)&qword_100091118, 0, (void *(__cdecl *)(void *))sub_100043FFC, &qword_1000910C8);
            return pthread_create((pthread_t *)&qword_100091120, 0, (void *(__cdecl *)(void *))sub_100043FFC, &qword_1000910A8);
          }
        }
      }
      else
      {
        time_t v7 = time(0);
        if (qword_100092138) {
          uint64_t v5 = (const char *)qword_100092138;
        }
        else {
          uint64_t v5 = "UNKNOWN-DEV";
        }
        stat v6 = ctime(&v7);
        fprintf(v2, "\n%s: fsck_apfs started at %s", v5, v6);
        return fflush(v2);
      }
    }
    else
    {
      dword_100092130 = 0;
    }
  }
  return result;
}

uint64_t sub_100043FFC(uint64_t a1)
{
  uint64_t v2 = *(FILE **)a1;
  memset(__b, 170, sizeof(__b));
  BOOL v3 = 0;
  while (dword_1000746A8 || *(void *)(a1 + 8) != *(void *)(a1 + 16))
  {
    pthread_mutex_lock(&stru_1000746B0);
    while (dword_1000746A8 && *(void *)(a1 + 8) == *(void *)(a1 + 16))
    {
      int v4 = pthread_cond_wait(&stru_1000910E8, &stru_1000746B0);
      if (v4)
      {
        fprintf(__stderrp, "error %d from cond wait\n", v4);
        break;
      }
    }
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(void *)(a1 + 16);
    unint64_t v7 = v5 - v6;
    if (v5 == v6)
    {
      pthread_mutex_unlock(&stru_1000746B0);
    }
    else
    {
      if (v7 < 0x400)
      {
        __memcpy_chk();
        uint64_t v8 = v6;
      }
      else
      {
        memcpy(__b, *(const void **)(a1 + 16), 0x3FFuLL);
        memmove((void *)v6, (const void *)(v6 + 1023), v7 - 1023);
        uint64_t v8 = v5 - 1023;
        unint64_t v7 = 1023;
      }
      __b[v7] = 0;
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + --*(_DWORD *)(result + 16) = v6;
      pthread_mutex_unlock(&stru_1000746B0);
      int v9 = __b[0];
      if (__b[0])
      {
        uid_t v10 = __b;
        do
        {
          size_t v11 = v10++;
          if (v9)
          {
            while (v9 != 10)
            {
              int v12 = *v10++;
              int v9 = v12;
              if (!v12) {
                goto LABEL_19;
              }
            }
            *(v10 - 1) = 0;
            int v13 = "\n";
          }
          else
          {
LABEL_19:
            --v10;
            int v13 = "";
          }
          if (v2 == __stdoutp || *v11 == 0 || v3) {
            fprintf(v2, "%s%s");
          }
          else {
            fprintf(v2, "%s: %s%s");
          }
          BOOL v3 = *v13 != 10;
          int v9 = *v10;
        }
        while (*v10);
      }
      fflush(v2);
    }
  }
  return 0;
}

uint64_t sub_100044240(uint64_t a1, const char *a2)
{
  byte_100091128 = 0;
  if (dword_100092130)
  {
    return sub_100043C4C(2, (uint64_t)&qword_1000910A8, "%s", a2, 0);
  }
  else
  {
    uint64_t result = qword_1000910A8;
    if (qword_1000910A8)
    {
      fprintf((FILE *)qword_1000910A8, "%s: ", (const char *)qword_100092138);
      byte_100091128 = 1;
      int v4 = (FILE *)qword_1000910A8;
      return fputs(a2, v4);
    }
  }
  return result;
}

uint64_t sub_10004431C(int a1, char *a2)
{
  if (dword_100092130) {
    return sub_100043C4C(2, (uint64_t)&qword_1000910C8, "%s", a2, 0);
  }
  else {
    return fputs(a2, __stdoutp);
  }
}

uint64_t sub_10004435C(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_100044388(a1, &a9);
}

uint64_t sub_100044388(char *__format, va_list a2)
{
  va_list v9 = a2;
  va_list v10 = a2;
  byte_100091128 = 0;
  if (qword_100091B78 && *(_DWORD *)(qword_100091B78 + 32) == 3)
  {
    __s = (char *)0xAAAAAAAAAAAAAAAALL;
    vasprintf(&__s, __format, v10);
    BOOL v3 = __s;
    if (__s)
    {
      size_t v4 = strlen(__s);
      v7[0] = 0xAAAAAAAA00000000;
      v7[1] = __s;
      void v7[2] = 0x100000005;
      v7[3] = 0xAAAAAAAA00000000;
      v7[4] = 0;
      if (v4)
      {
        if (__s[v4 - 1] == 10)
        {
          __s[v4 - 1] = 0;
          BOOL v3 = __s;
        }
      }
      sub_100046714(qword_100091B70, (uint64_t)v7, v3, 0);
      free(__s);
    }
  }
  else if (dword_100092130)
  {
    sub_100043C4C(1, (uint64_t)&qword_1000910C8, __format, 0, v10);
  }
  else
  {
    vfprintf(__stderrp, __format, v10);
  }
  if (dword_100092130) {
    return sub_100043C4C(1, (uint64_t)&qword_1000910A8, __format, 0, v9);
  }
  uint64_t result = qword_1000910A8;
  if (qword_1000910A8)
  {
    if (byte_100091128)
    {
      if (!strchr(__format, 10)) {
        return vfprintf((FILE *)qword_1000910A8, __format, v9);
      }
      BOOL v6 = 0;
    }
    else
    {
      fprintf((FILE *)qword_1000910A8, "%s: ", (const char *)qword_100092138);
      BOOL v6 = strchr(__format, 10) == 0;
    }
    byte_100091128 = v6;
    return vfprintf((FILE *)qword_1000910A8, __format, v9);
  }
  return result;
}

char *sub_100044548(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (qword_100091B78)
  {
    if (*(_DWORD *)(qword_100091B78 + 24)) {
      return (char *)sub_100044388(result, &a9);
    }
  }
  return result;
}

void sub_10004458C(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_1000445C4(const char *a1, const char *a2, va_list a3)
{
  size_t v5 = strlen(a1);
  unsigned int v6 = vsnprintf(0, 0, a2, a3);
  if ((v6 & 0x80000000) == 0)
  {
    size_t v7 = v5 + v6 + 1;
    uint64_t v8 = (char *)malloc_type_malloc(v7, 0xA3806769uLL);
    va_list v9 = strcpy(v8, a1);
    vsnprintf(&v9[v5], v7 - v5, a2, a3);
    sub_10004435C("%s", v10, v11, v12, v13, v14, v15, v16, (char)v8);
    free(v8);
  }
}

void sub_100044674(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v10 = strlen(a1);
  uint64_t v11 = off_100091690(0, a1, v10) & 0x3FF;
  int v12 = byte_100091129[v11];
  if (v12 <= 49)
  {
    byte_100091129[v11] = v12 + 1;
    sub_1000445C4("warning: ", a1, &a9);
    if (byte_100091129[v11] == 50) {
      sub_10004435C("Too many warnings of this type generated; suppressing subsequent ones.\n",
    }
        v13,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v20);
  }
}

char *sub_100044718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100044548("vers: %u.%u flags: %#x class: %c os: ", a2, a3, a4, a5, a6, a7, a8, *(_WORD *)a1);
  sub_100044548("%d%d-%d", v9, v10, v11, v12, v13, v14, v15, HIBYTE(*(_DWORD *)(a1 + 12)));
  return sub_100044548(" revision: %u key len: %u", v16, v17, v18, v19, v20, v21, v22, *(_WORD *)(a1 + 16));
}

char *sub_1000447BC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100044548("inum: %8lld version: %u flags: %u current_offset: %8llu current_ns_offset: %8llu\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a2);
}

char *sub_1000447FC(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100044548("obj-id: %8lld type: %-11s\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, *a2);
  return sub_100044548("logical addr: %lld  phys-block-num: %lld  len: %lld  flags: %x\n", v9, v10, v11, v12, v13, v14, v15, a2[1]);
}

void sub_100044868(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a3 > 7)
  {
    unsigned int v9 = a5;
    unsigned int v11 = a3;
    unint64_t v14 = *(void *)a2;
    if (a3 <= 0xB && (v14 & 0xF000000000000000) == 0xE000000000000000)
    {
      sub_100044548("obj-id: %8lld type: ???\n", a2, a3, a4, a5, a6, a7, a8, v14);
    }
    else
    {
      unint64_t v15 = v14 >> 60;
      if (v14 >> 60 == 14) {
        LODWORD(v15) = *(unsigned __int8 *)(a2 + 8);
      }
      unsigned int v77 = -1431655766;
      unsigned int v78 = -1431655766;
      char v16 = v14;
      sub_10003F6AC(v15);
      sub_100044548("obj-id: %8lld type: %-11s\n", v17, v18, v19, v20, v21, v22, v23, v16);
      if (sub_10003D9FC(*(void *)(a1 + 40), (unint64_t *)a2, v11, &v78)
        || sub_10003DB18(a2, (unsigned __int16 *)a4, v9, &v77))
      {
        sub_10004458C("key size (%u)/val size (%u) is invalid\n", v24, v25, v26, v27, v28, v29, v30, v11);
      }
      else if (v78 <= v11)
      {
        if (v77 <= v9)
        {
          switch((int)v15)
          {
            case 1:
              sub_100044548(" extentref_tree_oid: %lld sblock_oid: %lld change_time: %llu create_time: %llu\n", v24, v25, v26, v27, v28, v29, v30, *(_OWORD *)a4);
              sub_100044548(" extentref_Tree_type: %u flags: %u name: '%.*s' name_len: %u\n", v31, v32, v33, v34, v35, v36, v37, *(_DWORD *)(a4 + 40));
              break;
            case 2:
              sub_100044548("refcnt %d len %lld owning_obj_id %lld\n", v24, v25, v26, v27, v28, v29, v30, *(_DWORD *)(a4 + 16));
              break;
            case 3:
              sub_100044548("private-id: %lld parent-id: %lld cr/mtime: %lld/%lld \n", v24, v25, v26, v27, v28, v29, v30, *(void *)(a4 + 8));
              if ((*(_WORD *)(a4 + 80) & 0xF000) == 0x4000)
              {
                sub_100044548("gen-count: %u nchildren: %d \n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a4 + 64));
              }
              else if (*(int *)(a4 + 56) >= 2)
              {
                sub_100044548("nlink: %d \n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a4 + 56));
              }
              sub_100044548("def-prot-class: %d \n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a4 + 60));
              if (*(_WORD *)(a4 + 82)) {
                sub_100044548("pad1: 0x%x \n", v68, v69, v70, v71, v72, v73, v74, *(_WORD *)(a4 + 82));
              }
              if (*(void *)(a4 + 84)) {
                sub_100044548("uncompressed-size: 0x%llx \n", v68, v69, v70, v71, v72, v73, v74, *(void *)(a4 + 84));
              }
              sub_100044548("uid/gid/mode: %d/%d/0x%x bsd_flags: 0x%x internal_flags: 0x%llx name: %s\n", v68, v69, v70, v71, v72, v73, v74, *(_DWORD *)(a4 + 72));
              break;
            case 4:
              sub_100044548("flags: 0x%x data-len: %d name: %.*s\n", v24, v25, v26, v27, v28, v29, v30, *(_WORD *)a4);
              if (*(_WORD *)a4) {
                sub_100044548(" out-of-line data size: %lld (under obj-id: %lld / crypto-id: %lld)\n", v38, v39, v40, v41, v42, v43, v44, *(void *)(a4 + 12));
              }
              else {
                sub_100044548(" embedded data size: %d\n", v38, v39, v40, v41, v42, v43, v44, *(_WORD *)(a4 + 2));
              }
              break;
            case 5:
              sub_100044548("sib-id: %lld parent-id: %lld name: %.*s\n", v24, v25, v26, v27, v28, v29, v30, *(void *)(a2 + 8));
              break;
            case 6:
              sub_100044548("refcnt %d\n", v24, v25, v26, v27, v28, v29, v30, *(_DWORD *)a4);
              break;
            case 7:
              long long v75 = *(_OWORD *)(a4 + 4);
              int v76 = *(_DWORD *)(a4 + 20);
              sub_100044548("refcnt: %d \n", v24, v25, v26, v27, v28, v29, v30, *(_DWORD *)a4);
              sub_100044718((uint64_t)&v75, v54, v55, v56, v57, v58, v59, v60);
              break;
            case 8:
              sub_100044548("logical addr: %lld  phys-block-num: %lld  crypto-id: %lld  len: %lld  flags: %x\n", v24, v25, v26, v27, v28, v29, v30, *(void *)(a2 + 8));
              break;
            case 9:
              if ((*(unsigned char *)(*(void *)(a1 + 40) + 56) & 9) != 0) {
                sub_100044548("file-id: %6lld flags: %d date-added: %lld hash: 0x%x name-len: %d name: %.*s\n", v24, v25, v26, v27, v28, v29, v30, *(void *)a4);
              }
              else {
                sub_100044548("file-id: %6lld flags: %d date-added: %lld name-len: %d name: %.*s\n", v24, v25, v26, v27, v28, v29, v30, *(void *)a4);
              }
              break;
            case 10:
              sub_100044548("num children: %lld total size: %lld gen-count: %lld\n", v24, v25, v26, v27, v28, v29, v30, *(_OWORD *)a4);
              if (*(void *)(a4 + 16)) {
                sub_100044548(" chained-key: %lld\n", v61, v62, v63, v64, v65, v66, v67, *(void *)(a4 + 16));
              }
              break;
            case 11:
              unint64_t v45 = v11 - 10;
              if (v45 >= *(unsigned __int16 *)(a2 + 8)) {
                LOWORD(v45) = *(_WORD *)(a2 + 8);
              }
              sub_100044548(" name: '%.*s' name_len: %u snap_xid: %lld\n", v24, v25, v26, v27, v28, v29, v30, v45);
              break;
            case 12:
              sub_100044548("sib-map: %lld\n", v24, v25, v26, v27, v28, v29, v30, *(void *)a4);
              break;
            case 13:
              unint64_t v46 = *(void *)(a2 + 8);
              if (HIBYTE(v46) == 2)
              {
                sub_100044548(" type: %u hash: 0x%llx total_count: %llu physical_size: %llu flags: 0x%x\n", v24, v25, v26, v27, v28, v29, v30, 2);
              }
              else if (HIBYTE(v46) == 1)
              {
                sub_100044548(" type: %u logical addr: %lld\n", v24, v25, v26, v27, v28, v29, v30, 1);
              }
              else
              {
                sub_100044548(" type: %u\n", v24, v25, v26, v27, v28, v29, v30, SHIBYTE(v46));
              }
              break;
            case 16:
              sub_100044548(" atime: %llu file_id: %llu file_size: %llu dstream_id: %llu flags: 0x%x owning_uid: %u\n", v24, v25, v26, v27, v28, v29, v30, *(void *)(a2 + 12));
              break;
            case 17:
              sub_100044548(" file_id: %llu dstream_id: %llu\n", v24, v25, v26, v27, v28, v29, v30, *(void *)(a2 + 12));
              break;
            case 18:
              sub_100044548(" descendants: %llu phys_size: %llu resource_fork_size: %llu gen_count: %llu chained_key: %llu flags: 0x%x\n", v24, v25, v26, v27, v28, v29, v30, *(_OWORD *)a4);
              break;
            case 19:
              sub_100044548(" private_id: %llu, file_id: %llu\n", v24, v25, v26, v27, v28, v29, v30, *(void *)(a2 + 12));
              break;
            default:
              return;
          }
        }
        else
        {
          sub_10004458C("val size is too small, actual: %u, minimum: %u\n", v24, v25, v26, v27, v28, v29, v30, v9);
        }
      }
      else
      {
        sub_10004458C("key size is too small, actual: %u, minimum: %u\n", v24, v25, v26, v27, v28, v29, v30, v11);
      }
    }
  }
  else
  {
    sub_100044548("obj-id: ??? type: ???\n", a2, a3, a4, a5, a6, a7, a8, a9);
  }
}

char *sub_100044E88()
{
  IOPMAssertionID AssertionID = 0;
  if (IOPMAssertionCreateWithName(@"PreventUserIdleDisplaySleep", 0xFFu, @"Running FSCK", &AssertionID))
  {
    size_t v7 = "failed!";
  }
  else
  {
    dword_10009152C = AssertionID;
    size_t v7 = "succeeded.";
  }
  return sub_100044548("Disabling idle sleep, %s\n", v0, v1, v2, v3, v4, v5, v6, (char)v7);
}

char *sub_100044EF8()
{
  uint64_t result = (char *)dword_10009152C;
  if (dword_10009152C)
  {
    dword_10009152C = 0;
    IOReturn v1 = IOPMAssertionRelease((IOPMAssertionID)result);
    unsigned int v9 = "failed!";
    if (!v1) {
      unsigned int v9 = "succeeded.";
    }
    return sub_100044548("Enabling idle sleep, %s\n", v2, v3, v4, v5, v6, v7, v8, (char)v9);
  }
  return result;
}

uint64_t sub_100044F50()
{
  int v0 = dword_100074EC0;
  if ((dword_100074EC0 & 0x80000000) == 0)
  {
    dword_100074EC0 = -1;
    fcntl(v0, 54, 0);
    uint64_t result = close(v0);
  }
  if (dword_100091530)
  {
    int v2 = dword_100091530;
    dword_100091530 = 0;
    return sub_10001CBE8((io_connect_t *)&v2);
  }
  return result;
}

uint64_t sub_100044FC0(const char *a1)
{
  uint64_t result = open(a1, 2);
  if ((result & 0x80000000) == 0)
  {
    return close(result);
  }
  return result;
}

BOOL sub_100044FF8(const char *a1)
{
  IOReturn v1 = sub_10002DAEC(a1);
  CFDictionaryRef v2 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v2);
  if (MatchingService)
  {
    io_object_t v4 = MatchingService;
    io_iterator_t iterator = 0;
    IORegistryEntryGetChildIterator(MatchingService, "IOService", &iterator);
    if (iterator)
    {
      io_object_t v5 = IOIteratorNext(iterator);
      if (!v5)
      {
LABEL_8:
        IOObjectRelease(iterator);
        BOOL v11 = 0;
LABEL_16:
        IOObjectRelease(v4);
        return v11;
      }
      io_object_t v6 = v5;
      CFAllocatorRef v7 = kCFAllocatorDefault;
      while (1)
      {
        CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v6, @"IOMatchCategory", kCFAllocatorDefault, 0);
        if (CFProperty)
        {
          unsigned int v9 = CFProperty;
          int v10 = CFEqual(CFProperty, @"IOStorage");
          CFRelease(v9);
          if (v10) {
            break;
          }
        }
        IOObjectRelease(v6);
        io_object_t v6 = IOIteratorNext(iterator);
        if (!v6) {
          goto LABEL_8;
        }
      }
      IOObjectRelease(iterator);
    }
    else
    {
      CFAllocatorRef v7 = kCFAllocatorDefault;
      io_object_t v6 = v4;
    }
    CFTypeRef v12 = IORegistryEntryCreateCFProperty(v6, @"Status", v7, 0);
    if (v12)
    {
      uint64_t v13 = v12;
      BOOL v11 = CFEqual(v12, @"Corrupt") != 0;
      CFRelease(v13);
    }
    else
    {
      BOOL v11 = 0;
    }
    IOObjectRelease(v6);
    goto LABEL_16;
  }
  return 0;
}

uint64_t sub_100045184(const char **a1, void *a2, char a3)
{
  BOOL v6 = sub_10002DCA0(*a1);
  BOOL v7 = v6;
  if (v6) {
    int v8 = 16;
  }
  else {
    int v8 = 8;
  }
  if (a2) {
    unsigned int v9 = *(_DWORD *)(a2[1] + 36);
  }
  else {
    unsigned int v9 = 0;
  }
  uint64_t v10 = 0;
  if (v6) {
    unsigned int v11 = v9;
  }
  else {
    unsigned int v11 = 0;
  }
  int v30 = a3 & 3;
  for (char i = 1; ; char i = 0)
  {
    uint64_t v13 = &a1[12 * v10];
    v13[104] = (const char *)v10;
    unint64_t v14 = &a1[v10];
    char v16 = v14[3];
    unint64_t v15 = (uint64_t *)(v14 + 3);
    if (v16)
    {
      uint64_t v17 = sub_10001E454(v15, (long long *)v13 + 48, v8, v11);
      if (v17) {
        break;
      }
      if (a2) {
        goto LABEL_17;
      }
      goto LABEL_20;
    }
    uint64_t v18 = (char *)*a1;
    if (a2)
    {
      uint64_t v17 = sub_10001ED38(v18, v30, v15, (long long *)v13 + 48, v8, v11);
      if (v17) {
        break;
      }
LABEL_17:
      if (*v15)
      {
        sub_10002F130(*v15);
        sub_1000452E0(a2, *v15);
      }
      goto LABEL_20;
    }
    uint64_t v17 = sub_10002FBF4(v18, v30, v15);
    if (v17) {
      break;
    }
LABEL_20:
    char v19 = i & v7;
    uint64_t v10 = 1;
    if ((v19 & 1) == 0) {
      return 0;
    }
  }
  uint64_t v20 = v17;
  uint64_t v21 = *a1;
  strerror(v17);
  sub_10004458C("device %s failed to open with error: %s\n", v22, v23, v24, v25, v26, v27, v28, (char)v21);
  return v20;
}

void *sub_1000452E0(void *result, uint64_t a2)
{
  uint64_t v2 = result[1];
  if (*(unsigned char *)(v2 + 65))
  {
    uint64_t v3 = result[3];
    if (v3) {
      return sub_10001E3F4(a2, *(void *)(v3 + 48), 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v2 + 36))), *(void *)(v3 + 96));
    }
  }
  return result;
}

uint64_t sub_100045320(uint64_t a1)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = a1 + 8 * v2;
    uint64_t v8 = *(void *)(v5 + 24);
    BOOL v7 = (void *)(v5 + 24);
    uint64_t result = v8;
    if (v8)
    {
      uint64_t result = sub_10002F0E0(result);
      *BOOL v7 = 0;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  return result;
}

uint64_t sub_100045374(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v4 = qword_100091B78;
  if (*(_DWORD *)(qword_100091B78 + 16) != -1)
  {
    *(_WORD *)a2 = 0;
    *(unsigned char *)(a2 + 2) = 0;
    goto LABEL_3;
  }
  BOOL v7 = (unsigned char *)(a2 + 2);
  uint64_t v8 = (unsigned char *)(a2 + 1);
  int v9 = sub_100045644(*(const char **)(qword_100091B78 + 8), 1, (unsigned char *)a2, (unsigned char *)(a2 + 1), (char *)(a2 + 2), (void **)(a2 + 8));
  if (v9)
  {
    int v17 = v9;
    uint64_t v18 = *(void *)(qword_100091B78 + 8);
    strerror(v9);
    sub_10004458C("dev_is_mounted(%s) failed with error: %s\n", v19, v20, v21, v22, v23, v24, v25, v18);
    uint64_t v26 = 153;
    int v27 = v17;
LABEL_7:
    sub_100048B34((char *)v26, v27);
    return 66;
  }
  if (!*(unsigned char *)a2)
  {
    uint64_t v4 = qword_100091B78;
LABEL_3:
    if (!*(unsigned char *)(v4 + 37))
    {
      uint64_t v5 = 0;
      *(_DWORD *)(a2 + 32) = 18;
      return v5;
    }
    goto LABEL_4;
  }
  uint64_t v29 = qword_100091B78;
  if (!*v8)
  {
    if (*(_DWORD *)(qword_100091B78 + 20) == -1)
    {
      *(unsigned char *)(a2 + --*(_DWORD *)(result + 16) = 1;
    }
    else
    {
      int v31 = sub_100045644(*(const char **)qword_100091B78, 0, (unsigned char *)(a2 + 16), (unsigned char *)(a2 + 17), (char *)(a2 + 18), (void **)(a2 + 24));
      if (v31)
      {
        int v32 = v31;
        uint64_t v33 = *(void *)qword_100091B78;
        strerror(v31);
        sub_10004458C("dev_is_mounted(%s) failed with error: %s\n", v34, v35, v36, v37, v38, v39, v40, v33);
        uint64_t v26 = 155;
        int v27 = v32;
        goto LABEL_7;
      }
      if (!*(unsigned char *)(a2 + 16))
      {
        uint64_t v42 = qword_100091B78;
        if (!*(unsigned char *)(qword_100091B78 + 37))
        {
          *(_DWORD *)(a2 + 32) = 18;
          *(unsigned char *)(a2 + 40) = 1;
          sub_10004458C("live repair of a volume in mounted container %s is not supported yet.\n", v10, v11, v12, v13, v14, v15, v16, *(void *)(v42 + 8));
          uint64_t v5 = 64;
          uint64_t v30 = 158;
          int v41 = 64;
          goto LABEL_31;
        }
        if (!*(unsigned char *)(qword_100091B78 + 36))
        {
          if (*(unsigned char *)(qword_100091B78 + 38)) {
            goto LABEL_27;
          }
          sub_10004458C("container %s is mounted with write access; please re-run with -l.\n",
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            *(void *)(qword_100091B78 + 8));
          uint64_t v5 = 65;
          uint64_t v30 = 589;
          goto LABEL_30;
        }
        if (*(unsigned char *)(qword_100091B78 + 38)) {
          goto LABEL_27;
        }
LABEL_35:
        uint64_t v5 = 0;
        *a3 = 1;
        return v5;
      }
    }
    if (!*(unsigned char *)(qword_100091B78 + 37))
    {
      sub_10004458C("container %s is mounted with write access.\n", v10, v11, v12, v13, v14, v15, v16, *(void *)(qword_100091B78 + 8));
      uint64_t v5 = 65;
      uint64_t v30 = 157;
      goto LABEL_30;
    }
    if (!*(unsigned char *)(qword_100091B78 + 36) || !*(unsigned char *)(a2 + 18) || *(unsigned char *)(qword_100091B78 + 38))
    {
      if (*(unsigned char *)(qword_100091B78 + 38))
      {
LABEL_27:
        uint64_t v5 = 0;
        *(_DWORD *)(a2 + 32) = 0;
        *(unsigned char *)(a2 + 40) = 1;
        return v5;
      }
      sub_10004458C("container %s is mounted with write access; please re-run with -l.\n",
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        *(void *)(qword_100091B78 + 8));
      uint64_t v5 = 65;
      uint64_t v30 = 156;
LABEL_30:
      int v41 = 65;
LABEL_31:
      sub_100048B34((char *)v30, v41);
      return v5;
    }
    goto LABEL_35;
  }
  if (!*(unsigned char *)(qword_100091B78 + 37))
  {
    if (*v7)
    {
      *(void *)(a2 + 32) = 0x4000000000012;
      sub_10004458C("container %s is mounted. repairs in a mounted container is not supported yet.\n", v10, v11, v12, v13, v14, v15, v16, *(void *)(v29 + 8));
      uint64_t v5 = 65;
      uint64_t v30 = 857;
    }
    else
    {
      sub_10004458C("container %s is mounted.\n", v10, v11, v12, v13, v14, v15, v16, *(void *)(qword_100091B78 + 8));
      uint64_t v5 = 65;
      uint64_t v30 = 154;
    }
    goto LABEL_30;
  }
LABEL_4:
  uint64_t v5 = 0;
  *(_DWORD *)(a2 + 32) = 0;
  return v5;
}

uint64_t sub_100045644(const char *a1, int a2, unsigned char *a3, unsigned char *a4, char *a5, void **a6)
{
  uint64_t v8 = a4;
  *a3 = 0;
  *a4 = 1;
  *a5 = 0;
  *a6 = 0;
  uint64_t v10 = sub_10002DAEC(a1);
  size_t v11 = strlen(v10);
  unsigned int v12 = getfsstat(0, 0, 2);
  if ((v12 & 0x80000000) != 0)
  {
    uint64_t v15 = 0;
    goto LABEL_34;
  }
  int v13 = 2168 * v12;
  uint64_t v14 = (statfs *)malloc_type_malloc(2168 * v12, 0x100004087E0324AuLL);
  uint64_t v15 = v14;
  if (!v14 || (unsigned int v16 = getfsstat(v14, v13, 2), (v16 & 0x80000000) != 0))
  {
LABEL_34:
    uint64_t v34 = *__error();
  }
  else
  {
    if (v16)
    {
      uint64_t v36 = v8;
      uint64_t v37 = a5;
      unint64_t v17 = 0;
      uint64_t v18 = 2168 * v16;
      while (1)
      {
        _X23 = &v15[v17 / 0x878];
        f_mntfromname = v15[v17 / 0x878].f_mntfromname;
        int v21 = strcmp(f_mntfromname, "root_device");
        __asm { PRFM            #0, [X23,#0x1998] }
        if (!v21) {
          f_mntfromname = devname(_X23->f_fsid.val[0], 0x6000u);
        }
        uint64_t v26 = strrchr(f_mntfromname, 64);
        if (v26) {
          int v27 = v26 + 1;
        }
        else {
          int v27 = f_mntfromname;
        }
        uint64_t v28 = sub_10002DAEC(v27);
        if (strncmp(v28, v10, v11)) {
          goto LABEL_31;
        }
        int v29 = v28[v11];
        if (v28[v11])
        {
          if (a2)
          {
            if (v29 != 115) {
              goto LABEL_31;
            }
LABEL_17:
            uint32_t f_flags = v15[v17 / 0x878].f_flags;
            if ((f_flags & 0x4000) == 0) {
              goto LABEL_18;
            }
            goto LABEL_24;
          }
          if (v29 != 115 || (v15[v17 / 0x878].f_flags & 0x40000000) == 0) {
            goto LABEL_31;
          }
        }
        else if (a2)
        {
          goto LABEL_17;
        }
        uint32_t f_flags = v15[v17 / 0x878].f_flags;
        if ((f_flags & 0x40000000) == 0)
        {
LABEL_18:
          char v31 = 0;
          goto LABEL_26;
        }
LABEL_24:
        if (*a3) {
          goto LABEL_27;
        }
        char v31 = 1;
LABEL_26:
        *uint64_t v37 = v31;
LABEL_27:
        *a3 = 1;
        if ((f_flags & 1) == 0) {
          *uint64_t v36 = 0;
        }
        if (!*a6)
        {
          uint64_t v33 = strdup(v15[v17 / 0x878].f_mntonname);
          *a6 = v33;
          if (!v33)
          {
            uint64_t v8 = v36;
            goto LABEL_34;
          }
        }
LABEL_31:
        v17 += 2168;
        if (v18 == v17)
        {
          uint64_t v34 = 0;
          uint64_t v8 = v36;
          goto LABEL_35;
        }
      }
    }
    uint64_t v34 = 0;
  }
LABEL_35:
  if (!*a3) {
    *uint64_t v8 = 0;
  }
  if (v15) {
    free(v15);
  }
  if (v34 && *a6)
  {
    free(*a6);
    *a6 = 0;
  }
  return v34;
}

uint64_t sub_100045888(uint64_t *a1, int a2)
{
  int v3 = *(_DWORD *)(qword_100091B78 + 16);
  if (v3 == -1) {
    int v4 = sub_10001EDA4(*(char **)(qword_100091B78 + 8), a2, a1);
  }
  else {
    int v4 = sub_10001ECE4(v3, a1);
  }
  int v5 = v4;
  if (!v4) {
    return 0;
  }
  uint64_t v6 = *(void *)(qword_100091B78 + 8);
  strerror(v4);
  sub_10004458C("device %s failed to open with error: %s\n", v7, v8, v9, v10, v11, v12, v13, v6);
  sub_100048B34((char *)0xA3, v5);
  return 66;
}

uint64_t sub_10004591C(uint64_t a1, char a2, BOOL *a3)
{
  unsigned int v22 = -1431655766;
  unsigned int v23 = -1431655766;
  sub_10001F3FC(a1, &v23, (int *)&v22);
  uint64_t result = 0;
  *a3 = 0;
  unsigned int v7 = v23;
  if (v23 < v22)
  {
    while (1)
    {
      uint64_t v8 = sub_10001F314(a1, v7);
      uint64_t v9 = *(const char **)v8;
      if (!*(void *)v8)
      {
        uint64_t v10 = *(void *)(qword_100091B78 + 8);
        uint64_t v24 = 0;
        asprintf(&v24, "/dev/r%ss%d", (const char *)(v10 + 6), v7 + 1);
        uint64_t v9 = v24;
        *(void *)uint64_t v8 = v24;
        if (!v9)
        {
          sub_10004458C("failed to allocate memory for device path\n", v11, v12, v13, v14, v15, v16, v17, v21);
          sub_100048B34((char *)0xA4, 12);
          return 71;
        }
      }
      if (!*(unsigned char *)(qword_100091B78 + 36) && !*(unsigned char *)(qword_100091B78 + 43))
      {
        BOOL v18 = sub_10002DC4C(v9);
        BOOL v19 = *a3 || v18;
        *a3 = v19;
        if (v18)
        {
          if (*(unsigned char *)(qword_100091B78 + 44))
          {
            *strrchr(*(char **)v8, 115) = 0;
            v8[8] = 1;
            *a3 = 0;
          }
          int v20 = sub_100045184((const char **)v8, 0, a2);
          if (v20) {
            break;
          }
        }
      }
      if (++v7 >= v22) {
        return 0;
      }
    }
    sub_100048B34((char *)0x9F, v20);
    return 66;
  }
  return result;
}

uint64_t sub_100045A94(uint64_t a1, char a2)
{
  unsigned int v32 = -1431655766;
  unsigned int v33 = -1431655766;
  sub_10001F3FC(a1, &v33, (int *)&v32);
  if (dword_100091530)
  {
    unsigned int v4 = v32;
  }
  else
  {
    int v35 = -1431655766;
    *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
    v34[4] = v16;
    _OWORD v34[5] = v16;
    v34[2] = v16;
    void v34[3] = v16;
    v34[0] = v16;
    v34[1] = v16;
    uint64_t v17 = *(void *)(a1 + 8);
    BOOL v18 = *(char **)(qword_100091B78 + 8);
    long long v19 = *(_OWORD *)(v17 + 1392);
    v31[0] = *(_OWORD *)(v17 + 1296);
    v31[1] = v19;
    int v20 = sub_10001CAC4(v18, (a2 & 3) != 0, v31, (io_connect_t *)&dword_100091530, (uint64_t)v34);
    if (v20)
    {
      int v21 = v20;
      uint64_t v22 = *(void *)(qword_100091B78 + 8);
      strerror(v20);
      sub_10004458C("failed to enable crypto I/O mode for container %s: %s\n", v23, v24, v25, v26, v27, v28, v29, v22);
      sub_100048B34((char *)0x3B1, v21);
      return 66;
    }
    unsigned int v4 = v32;
    for (i = v33; i < v32; unsigned int v4 = v32)
    {
      sub_10001F314(a1, i)[8] = *((unsigned char *)v34 + i) != 0;
      ++i;
    }
  }
  unsigned int v5 = v33;
  if (v33 < v4)
  {
    do
    {
      uint64_t v6 = sub_10001F314(a1, v5);
      if (!v6[8])
      {
        unsigned int v7 = v6;
        uint64_t v8 = 0;
        char v9 = 1;
        do
        {
          char v10 = v9;
          uint64_t v11 = &v7[8 * v8];
          uint64_t v14 = *((void *)v11 + 3);
          uint64_t v13 = v11 + 24;
          uint64_t v12 = v14;
          if (v14)
          {
            sub_10002F0E0(v12);
            *uint64_t v13 = 0;
          }
          char v9 = 0;
          uint64_t v8 = 1;
        }
        while ((v10 & 1) != 0);
      }
      ++v5;
    }
    while (v5 < v32);
  }
  return 0;
}

uint64_t sub_100045C4C(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = *(const char **)(a2 + 24);
  if (!v4) {
    unsigned int v4 = *(const char **)(a2 + 8);
  }
  int v5 = open(v4, 0);
  dword_100074EC0 = v5;
  if (v5 < 0)
  {
    int v17 = *__error();
    strerror(v17);
    sub_10004458C("could not open %s to freeze the volume: %s\n", v18, v19, v20, v21, v22, v23, v24, (char)v4);
    sub_100048B34((char *)0xA1, v17);
    return 66;
  }
  if (a3)
  {
    int v33 = 0;
    uint64_t result = ffsctl(v5, 0x80044A62uLL, &v33, 0);
    if (!result) {
      return result;
    }
    int v7 = *__error();
    char v8 = strerror(v7);
    sub_10004458C("could not sync and freeze volume: %s\n", v9, v10, v11, v12, v13, v14, v15, v8);
    uint64_t v16 = 1081;
  }
  else
  {
    uint64_t result = fcntl(v5, 53, 0);
    if (!result) {
      return result;
    }
    int v7 = *__error();
    char v25 = strerror(v7);
    sub_10004458C("could not freeze volume: %s\n", v26, v27, v28, v29, v30, v31, v32, v25);
    uint64_t v16 = 162;
  }
  sub_100048B34((char *)v16, v7);
  return 71;
}

uint64_t sub_100045D54(uint64_t *a1, int8x16_t *a2)
{
  sub_10001F0A4((void *)a2[2].i64[1], "fsck_apfs", *(void *)(a2[2].i64[1] + 16));
  uint64_t v4 = a2[2].i64[1];
  int8x16_t v7 = a2[5];
  uint64_t v8 = a2[6].i64[0];
  uint64_t result = sub_100026BA0(a1, 0, v4, (uint64_t)&v7, v7, v5);
  if (!result) {
    *(unsigned char *)(qword_100091B78 + 49) = 1;
  }
  return result;
}

uint64_t sub_100045DD0(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v22 = 0xAAAAAAAAAAAAAAAALL;
  *a3 = -1;
  unsigned int v21 = 8;
  v20[0] = 0xAAAAAAAAAAAAAAAALL;
  v20[1] = 0xAAAAAAAAAAAAAAAALL;
  unsigned int v19 = 16;
  uint64_t v4 = sub_10002CE38(a1, a2, &v22);
  if (!v4)
  {
    uint64_t v14 = v22;
    uint64_t v15 = 0xFFFFFFFFLL;
    uint64_t v16 = a3;
    unsigned int v17 = 8;
    while (1)
    {
      uint64_t v18 = sub_1000380B0(v14, 0, v15, v16, &v21, v17, v20, &v19);
      uint64_t v4 = v18;
      if ((v18 & 0xFFFFFFFD) != 0) {
        break;
      }
      if (v18) {
        return v4;
      }
      if ((v20[0] & 3) == 0) {
        return 0;
      }
      uint64_t v14 = v22;
      unsigned int v17 = v21;
      uint64_t v15 = 4294967294;
      uint64_t v16 = a3;
    }
  }
  char v5 = strerror(v4);
  sub_10004458C("unable to lookup latest snap xid: %s\n", v6, v7, v8, v9, v10, v11, v12, v5);
  return v4;
}

void sub_100045EB4(uint64_t a1, const char *a2, va_list a3)
{
  if (!a1) {
    return;
  }
  memset(__b, 170, sizeof(__b));
  int v5 = vsnprintf(__b, 0x400uLL, a2, a3);
  if (v5 < 0x401)
  {
LABEL_10:
    if (*(unsigned char *)(a1 + 56) == 1)
    {
      uint64_t v11 = *(void (**)(uint64_t, unsigned char *))(a1 + 48);
      if (!v11) {
        return;
      }
    }
    else
    {
      uint64_t v11 = *(void (**)(uint64_t, unsigned char *))(a1 + 40);
      if (!v11) {
        return;
      }
    }
    v11(a1, __b);
    return;
  }
  size_t v6 = v5;
  size_t v7 = v5 + 1;
  uint64_t v8 = (char *)malloc_type_malloc(v7, 0xCF70ADBAuLL);
  if (!v8)
  {
    strcpy(__b, "* * * cannot allocate memory * * *\n");
    goto LABEL_10;
  }
  uint64_t v9 = v8;
  if (v7 <= vsnprintf(v8, v6, a2, a3))
  {
    strcpy(__b, " * * * cannot allocate memory * * *\n");
    free(v9);
    goto LABEL_10;
  }
  uint64_t v10 = *(void (**)(uint64_t, char *))(a1 + 40);
  if (v10) {
    v10(a1, v9);
  }
  free(v9);
}

void sub_100046018(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

uint64_t sub_100046044(FILE **a1, char *a2)
{
  if (*a1) {
    uint64_t v2 = *a1;
  }
  else {
    uint64_t v2 = __stdoutp;
  }
  fputs(a2, v2);

  return fflush(v2);
}

unsigned char *sub_100046098(char *a1)
{
  if (!a1) {
    return 0;
  }
  IOReturn v1 = a1;
  unsigned int v2 = 1;
  do
  {
    a1 = strchr(a1 + 1, 37);
    v2 += 5;
  }
  while (a1);
  size_t v3 = strlen(v1);
  uint64_t v4 = malloc_type_calloc(1uLL, v3 + v2, 0xB352F366uLL);
  int v5 = v4;
  if (v4)
  {
    char v6 = *v1;
    size_t v7 = v4;
    if (*v1)
    {
      int v8 = 0;
      int v9 = 0;
      uint64_t v10 = v4;
      do
      {
        if (v8)
        {
          unsigned int v11 = v6 - 65;
          BOOL v12 = ((1 << (v6 - 65)) & 0x94E17D0094407DLL) == 0;
          int v8 = v11 > 0x37 || v12;
          size_t v7 = v10;
        }
        else
        {
          *uint64_t v10 = v6;
          size_t v7 = v10 + 1;
          if (*v1 == 37)
          {
            if (v1[1] == 37)
            {
              int v8 = 0;
              size_t v7 = v10 + 2;
              v10[1] = 37;
              ++v1;
            }
            else
            {
              v7 += sprintf(v10 + 1, "%d$@", ++v9);
              int v8 = 1;
            }
          }
          else
          {
            int v8 = 0;
          }
        }
        int v13 = *++v1;
        char v6 = v13;
        uint64_t v10 = v7;
      }
      while (v13);
    }
    *size_t v7 = 0;
  }
  return v5;
}

FILE **sub_1000461F0()
{
  int v0 = (FILE **)malloc_type_calloc(1uLL, 0x48uLL, 0x10B0040D577FD4FuLL);
  IOReturn v1 = v0;
  if (v0)
  {
    if (sub_10004626C((uint64_t)v0, (uint64_t)&unk_100074188) == -1)
    {
      sub_100046348(v1);
      return 0;
    }
    else
    {
      v1[5] = (FILE *)sub_100046044;
    }
  }
  return v1;
}

uint64_t sub_10004626C(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  if (a1)
  {
    uint64_t v4 = a2;
    if (a2)
    {
      if (!*(void *)(a2 + 8)) {
        return 0;
      }
      uint64_t v5 = 0;
      char v6 = (uint64_t *)(a2 + 48);
      do
      {
        uint64_t v7 = *v6;
        v6 += 5;
        ++v5;
      }
      while (v7);
      int v8 = malloc_type_realloc(*(void **)(a1 + 32), 8 * (*(_DWORD *)(a1 + 24) + (int)v5), 0x2004093837F09uLL);
      if (v8)
      {
        *(void *)(a1 + 32) = v8;
        int v9 = *(_DWORD *)(a1 + 24);
        uint64_t v10 = 8 * v9;
        uint64_t v11 = v5;
        do
        {
          *(void *)(*(void *)(a1 + 32) + v10) = v4;
          v10 += 8;
          v4 += 40;
          --v11;
        }
        while (v11);
        BOOL v12 = *(void **)(a1 + 32);
        int v13 = v9 + v5;
        *(_DWORD *)(a1 + 24) = v13;
        qsort(v12, v13, 8uLL, (int (__cdecl *)(const void *, const void *))sub_10004657C);
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

void sub_100046348(FILE **a1)
{
  if (a1)
  {
    unsigned int v2 = a1[4];
    if (v2) {
      free(v2);
    }
    if ((_BYTE)a1[1]) {
      fclose(*a1);
    }
    size_t v3 = a1[8];
    if (v3) {
      free(v3);
    }
    free(a1);
  }
}

uint64_t sub_1000463AC(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)(a1 + 40) = a2;
  return result;
}

uint64_t sub_1000463C8(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(void *)(a1 + 48) = a2;
  return result;
}

uint64_t sub_1000463E4(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + --*(_DWORD *)(result + 16) = a2;
  return result;
}

uint64_t sub_100046400(uint64_t a1, int a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 20) = a2;
  return result;
}

uint64_t sub_10004641C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 16) != 1)
  {
    int v29 = *(_DWORD *)(a1 + 20);
    if (v29 == 2) {
      unsigned int v30 = 1;
    }
    else {
      unsigned int v30 = -1;
    }
    if (v29 == 1) {
      return 0;
    }
    else {
      return v30;
    }
  }
  unsigned int v11 = 0;
  uint64_t v34 = (char *)0xAAAAAAAAAAAAAAAALL;
  while (1)
  {
    uint64_t v34 = &a9;
    sub_100045EB4(a1, a2, &a9);
    int v18 = *(_DWORD *)(a1 + 20);
    if (v18 == 1)
    {
      uint64_t v28 = 0;
      uint64_t v31 = "NO\n";
LABEL_29:
      sub_100046018(a1, v31, v12, v13, v14, v15, v16, v17, v33);
      return v28;
    }
    if (v18 == 2)
    {
      uint64_t v28 = 1;
      uint64_t v31 = "YES\n";
      goto LABEL_29;
    }
    size_t v33 = 0xAAAAAAAAAAAAAAAALL;
    unsigned int v19 = fgetln(__stdinp, &v33);
    if (!v19 || v33 == 0) {
      break;
    }
    int v27 = *v19;
    if (v27 == 10) {
      break;
    }
    if (v27 > 109)
    {
      if (v27 == 110) {
        return 0;
      }
      if (v27 == 121) {
        return 1;
      }
    }
    else
    {
      if (v27 == 78) {
        return 0;
      }
      if (v27 == 89) {
        return 1;
      }
    }
LABEL_12:
    ++v11;
  }
  if (v11 < 0xA) {
    goto LABEL_12;
  }
  sub_100046018(a1, "\n", v20, v21, v22, v23, v24, v25, v33);
  return 0;
}

uint64_t sub_10004657C(_DWORD **a1, _DWORD **a2)
{
  return (**a1 - **a2);
}

uint64_t sub_100046594(_DWORD *a1, _DWORD **a2)
{
  return (*a1 - **a2);
}

const void **sub_1000465A8(const void **result, int a2)
{
  int __key = a2;
  if (result)
  {
    uint64_t result = (const void **)bsearch(&__key, result[4], *((int *)result + 6), 8uLL, (int (__cdecl *)(const void *, const void *))sub_100046594);
    if (result) {
      return (const void **)*result;
    }
  }
  return result;
}

char *sub_1000465F8(int a1, const char *a2, va_list a3)
{
  int v8 = 0;
  uint64_t v7 = 0;
  int v3 = a1 - 1;
  if ((a1 - 1) > 8)
  {
    uint64_t v4 = "";
    uint64_t v5 = "";
  }
  else
  {
    uint64_t v4 = off_100070978[v3];
    uint64_t v5 = (const char *)*((void *)&off_1000709C0 + v3);
  }
  vasprintf(&v7, a2, a3);
  if (!v7) {
    return 0;
  }
  asprintf(&v8, "%s%s%s\n", v4, v7, v5);
  free(v7);
  return v8;
}

uint64_t sub_100046694(uint64_t a1, uint64_t a2, const char *a3, va_list a4)
{
  if (*(const char **)(a2 + 8) != a3) {
    sub_10004E93C();
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5 == 8) {
    return 0;
  }
  char v6 = sub_1000465F8(v5, a3, a4);
  if (v6)
  {
    uint64_t v13 = v6;
    sub_100046018(a1, "%s", v7, v8, v9, v10, v11, v12, (char)v6);
    free(v13);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100046714(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4)
{
  if (*(char **)(a2 + 8) != a3) {
    sub_10004E968();
  }
  char v6 = sub_100046098(a3);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v6;
  sub_100046018(a1, "<plist version=\"1.0\">\n", v7, v8, v9, v10, v11, v12, v94);
  sub_100046018(a1, "\t<dict>\n", v14, v15, v16, v17, v18, v19, v95);
  sub_100046018(a1, "\t\t<key>%s</key> <string>%s</string>\n", v20, v21, v22, v23, v24, v25, (char)"fsck_msg_type");
  if (*(_DWORD *)a2 != 119)
  {
    sub_100046018(a1, "\t\t<key>%s</key> <integer>%s</integer>\n", v27, v28, v29, v30, v31, v32, (char)"fsck_verbosity");
    sub_100046018(a1, "\t\t<key>%s</key> <integer>%u</integer>\n", v33, v34, v35, v36, v37, v38, (char)"fsck_msg_number");
    sub_100046018(a1, "\t\t<key>%s</key> <string>%s</string>\n", v39, v40, v41, v42, v43, v44, (char)"fsck_msg_string");
  }
  if (*(int *)(a2 + 24) >= 1)
  {
    sub_100046018(a1, "\t\t<key>%s</key>\n", v27, v28, v29, v30, v31, v32, (char)"parameters");
    sub_100046018(a1, "\t\t<array>\n", v45, v46, v47, v48, v49, v50, v97);
    if (*(int *)(a2 + 24) >= 1)
    {
      uint64_t v57 = 0;
      do
      {
        switch(*(_DWORD *)(*(void *)(a2 + 32) + 4 * v57))
        {
          case 1:
          case 8:
            uint64_t v58 = a4;
            a4 += 2;
            sub_100046018(a1, "\t\t\t<integer>%d</integer>\n", v51, v52, v53, v54, v55, v56, *v58);
            break;
          case 2:
            uint64_t v60 = a4;
            a4 += 2;
            sub_100046018(a1, "\t\t\t<integer>%ld</integer>\n", v51, v52, v53, v54, v55, v56, *v60);
            break;
          case 3:
            a4 += 2;
            uint64_t v61 = sub_100046B0C();
            sub_100046018(a1, "\t\t\t<string>%s</string>\n", v62, v63, v64, v65, v66, v67, (char)v61);
            goto LABEL_22;
          case 4:
            a4 += 2;
            uint64_t v61 = sub_100046B0C();
            uint64_t v74 = "path";
            goto LABEL_18;
          case 5:
            a4 += 2;
            uint64_t v61 = sub_100046B0C();
            uint64_t v74 = "file";
            goto LABEL_18;
          case 6:
            a4 += 2;
            uint64_t v61 = sub_100046B0C();
            uint64_t v74 = "directory";
LABEL_18:
            sub_100046018(a1, "\t\t\t<dict><key>%s</key> <string>%s</string></dict>\n", v68, v69, v70, v71, v72, v73, (char)v74);
            goto LABEL_22;
          case 7:
            a4 += 2;
            uint64_t v61 = sub_100046B0C();
            sub_100046018(a1, "\t\t\t<dict><key>%s</key> <string>%s</string></dict>\n", v75, v76, v77, v78, v79, v80, (char)"volumename");
            goto LABEL_22;
          case 9:
            a4 += 2;
            uint64_t v61 = sub_100046B0C();
            sub_100046018(a1, "\t\t\t<dict><key>%s</key> <string>%s</string></dict>\n", v81, v82, v83, v84, v85, v86, (char)"fstype");
LABEL_22:
            free(v61);
            break;
          case 0xA:
            char v87 = a4;
            a4 += 2;
            sub_100046018(a1, "\t\t\t<integer>%llu</integer>\n", v51, v52, v53, v54, v55, v56, *v87);
            break;
          default:
            uint64_t v59 = a4;
            a4 += 2;
            sub_100046018(a1, "\t\t\t<integer>%p</integer>\n", v51, v52, v53, v54, v55, v56, *v59);
            break;
        }
        ++v57;
      }
      while (v57 < *(int *)(a2 + 24));
    }
    sub_100046018(a1, "\t\t</array>\n", v51, v52, v53, v54, v55, v56, v98);
  }
  sub_100046018(a1, "\t</dict>\n", v27, v28, v29, v30, v31, v32, v96);
  sub_100046018(a1, "</plist>\n", v88, v89, v90, v91, v92, v93, v99);
  free(v13);
  return 0;
}

char *sub_100046B0C()
{
  uint64_t result = (char *)__chkstk_darwin();
  if (result)
  {
    IOReturn v1 = result;
    bzero(__s1, 0x1801uLL);
    char v2 = *v1;
    if (*v1)
    {
      int v3 = (unsigned __int8 *)(v1 + 1);
      uint64_t v4 = __s1;
      do
      {
        if (v2 <= 38)
        {
          if (v2 == 34)
          {
            *(_DWORD *)uint64_t v4 = 1869967654;
            *((_WORD *)v4 + 2) = 15220;
            goto LABEL_16;
          }
          if (v2 != 38)
          {
LABEL_17:
            *uint64_t v4 = v2;
            uint64_t v5 = 1;
            goto LABEL_18;
          }
          *(_DWORD *)uint64_t v4 = 1886216486;
          v4[4] = 59;
          uint64_t v5 = 5;
        }
        else
        {
          switch(v2)
          {
            case '\'':
              *(_DWORD *)uint64_t v4 = 1869635878;
              *((_WORD *)v4 + 2) = 15219;
LABEL_16:
              uint64_t v5 = 6;
              goto LABEL_18;
            case '<':
              *(_DWORD *)uint64_t v4 = 997485606;
              break;
            case '>':
              *(_DWORD *)uint64_t v4 = 997484326;
              break;
            default:
              goto LABEL_17;
          }
          uint64_t v5 = 4;
        }
LABEL_18:
        v4 += v5;
        int v6 = *v3++;
        char v2 = v6;
      }
      while (v6);
    }
    return strdup(__s1);
  }
  return result;
}

uint64_t sub_100046C60(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4)
{
  if (*(char **)(a2 + 8) != a3) {
    sub_10004E994();
  }
  int v6 = sub_100046098(a3);
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = v6;
  int v14 = *(_DWORD *)(a2 + 16) - 1;
  if (v14 > 8) {
    LOBYTE(v15) = 63;
  }
  else {
    int v15 = dword_10006F5A0[v14];
  }
  if (*(_DWORD *)a2 != 119) {
    sub_100046018(a1, "(%c,\"%s\",%d)\n", v7, v8, v9, v10, v11, v12, v15);
  }
  if (*(int *)(a2 + 24) >= 1)
  {
    uint64_t v17 = 0;
    do
    {
      switch(*(_DWORD *)(*(void *)(a2 + 32) + 4 * v17))
      {
        case 1:
          uint64_t v20 = a4;
          a4 += 2;
          sub_100046018(a1, "%d\n", v7, v8, v9, v10, v11, v12, *v20);
          break;
        case 2:
          uint64_t v21 = a4;
          a4 += 2;
          sub_100046018(a1, "%ld\n", v7, v8, v9, v10, v11, v12, *v21);
          break;
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
          uint64_t v18 = a4;
          a4 += 2;
          sub_100046018(a1, "%s\n", v7, v8, v9, v10, v11, v12, *v18);
          break;
        case 8:
          uint64_t v22 = a4;
          a4 += 2;
          sub_100046018(a1, "(%d %%)\n", v7, v8, v9, v10, v11, v12, *v22);
          break;
        case 0xA:
          uint64_t v23 = a4;
          a4 += 2;
          sub_100046018(a1, "%llu\n", v7, v8, v9, v10, v11, v12, *v23);
          break;
        default:
          uint64_t v19 = a4;
          a4 += 2;
          sub_100046018(a1, "%p\n", v7, v8, v9, v10, v11, v12, *v19);
          break;
      }
      ++v17;
    }
    while (v17 < *(int *)(a2 + 24));
  }
  free(v13);
  return 0;
}

uint64_t sub_100046EA0()
{
  return 0;
}

uint64_t sub_100046EA8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = sub_1000465A8((const void **)a1, a2);
  if (!v10) {
    sub_10004E9C0();
  }
  uint64_t v11 = v10;
  int v12 = *(_DWORD *)(a1 + 16) - 1;
  if (v12 > 3) {
    uint64_t v13 = sub_100046EA0;
  }
  else {
    uint64_t v13 = *(&off_100070A50 + v12);
  }
  *(unsigned char *)(a1 + 56) = 1;
  sub_100046694(a1, (uint64_t)v10, (const char *)v10[1], &a9);
  *(unsigned char *)(a1 + 56) = 0;
  return ((uint64_t (*)(uint64_t, const void **, const void *, char *))v13)(a1, v11, v11[1], &a9);
}

uint64_t sub_100046F64(void *a1, uint64_t a2, long long *a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8, char a9)
{
  if (!a1) {
    return 22;
  }
  unsigned int v11 = a6;
  if (a6 > 0x10000 && (a9 & 1) != 0)
  {
    unsigned int v11 = 0x10000;
  }
  else
  {
    while (a5 > 0x10000 && v11 < 0x10000 || a5 > 0x1000 && v11 < 0x400)
    {
      a5 >>= 1;
      v11 *= 2;
    }
    while (a5 <= 0xFFF && v11 > 0x400 || !HIWORD(a5) && v11 > 0x10000)
    {
      a5 *= 2;
      v11 >>= 1;
    }
  }
  uint64_t result = 34;
  if (a5 - 65537 >= 0xFFFF0FFF && v11 <= 0x10000 && v11 >= 0x400)
  {
    unsigned int v18 = *(_DWORD *)(a2 + 100);
    uint64_t v19 = (char *)malloc_type_calloc(1uLL, 0x128uLL, 0x10E004068787CB3uLL);
    if (v19)
    {
      uint64_t v20 = v19;
      *((void *)v19 + 4) = a2;
      *((void *)v19 + 5) = a4;
      *((_DWORD *)v19 + 12) = v18;
      *((void *)v19 + 7) = *(void *)(a2 + 128);
      *((_DWORD *)v19 + 22) = a7;
      if (a3)
      {
        long long v21 = *a3;
        *(_OWORD *)(v19 + 2--*(_DWORD *)(result + 16) = a3[1];
        *(_OWORD *)(v19 + 200) = v21;
        long long v22 = a3[2];
        long long v23 = a3[3];
        long long v24 = a3[5];
        *(_OWORD *)(v19 + 264) = a3[4];
        *(_OWORD *)(v19 + 280) = v24;
        *(_OWORD *)(v19 + 248) = v23;
        *(_OWORD *)(v19 + 232) = v22;
      }
      uint64_t v25 = malloc_type_calloc(1uLL, 8 * a7, 0x2004093837F09uLL);
      *((void *)v20 + 10) = v25;
      if (v25)
      {
        size_t v26 = v11 * (unint64_t)a5;
        do
        {
          if (a5 % v18)
          {
            sub_100047230((unsigned int *)v20);
            return 34;
          }
          unsigned int v27 = v11;
          unsigned int v28 = a5;
          uint64_t v29 = mmap(0, v26, 3, 4098, -1, 0);
          uint64_t v30 = v29;
          *((void *)v20 + 17) = v29;
          if (v29 != (unsigned char *)-1) {
            break;
          }
          unsigned int v11 = 0;
          a5 = 0x10000;
          BOOL v31 = v26 > 0x400000;
          size_t v26 = 0;
        }
        while (v31);
        if (v29 != (unsigned char *)-1)
        {
          *((void *)v20 + --*(_DWORD *)(result + 16) = v29;
          if (a8)
          {
            int v32 = getpagesize();
            uint64_t v33 = v27 * v28;
            if (v33)
            {
              uint64_t v34 = &v30[v33];
              do
              {
                *uint64_t v30 = 0;
                v30 += v32;
              }
              while (v30 < v34);
              uint64_t v30 = (unsigned char *)*((void *)v20 + 17);
            }
          }
          unsigned int v35 = v27 - 1;
          do
          {
            uint64_t v36 = &v30[v28];
            *(void *)uint64_t v30 = v36;
            uint64_t v30 = v36;
            --v35;
          }
          while (v35);
          *uint64_t v36 = 0;
          *((_DWORD *)v20 + 36) = v27;
          *((_DWORD *)v20 + 23) = v28;
          *((_DWORD *)v20 + 24) = v27;
          uint64_t v37 = (char *)malloc_type_malloc(0x900uLL, 0x10A0040E6181C31uLL);
          if (v37)
          {
            uint64_t v38 = v37;
            bzero(v37, 0x900uLL);
            for (uint64_t i = 0; i != 2256; i += 48)
              *(void *)&v38[i] = &v38[i + 48];
            uint64_t result = 0;
            *((void *)v20 + 21) = v38;
            *((void *)v20 + 19) = v38;
            *a1 = v20;
            *(void *)uint64_t v20 = v20;
            *((void *)v20 + 1) = v20;
            *((void *)v20 + 2) = v20 + 16;
            *((void *)v20 + 3) = v20 + 16;
            return result;
          }
        }
      }
      sub_100047230((unsigned int *)v20);
    }
    return 12;
  }
  return result;
}

uint64_t sub_100047230(unsigned int *a1)
{
  if (a1)
  {
    if (*((void *)a1 + 19))
    {
      for (uint64_t i = (uint64_t **)*((void *)a1 + 20); i; uint64_t i = (uint64_t **)*i)
      {
        int v3 = i[5];
        if (v3 && (i[2] & 0x80000000) != 0) {
          free(v3);
        }
      }
      for (uint64_t j = (uint64_t **)*((void *)a1 + 21); j; uint64_t j = (uint64_t **)*j)
      {
        uint64_t v5 = j[5];
        if (v5 && (j[2] & 0x80000000) != 0) {
          free(v5);
        }
      }
      free(*((void **)a1 + 19));
    }
    if (*((void *)a1 + 16))
    {
      sub_1000473B8((uint64_t)a1);
      munmap(*((void **)a1 + 16), a1[24] * a1[23]);
    }
    int v6 = (void *)*((void *)a1 + 10);
    if (v6)
    {
      unint64_t v7 = a1[22];
      if (v7)
      {
        for (unint64_t k = 0; k < v7; ++k)
        {
          uint64_t v9 = *(void **)(*((void *)a1 + 10) + 8 * k);
          if (v9)
          {
            do
            {
              uint64_t v10 = (void *)v9[2];
              free(v9);
              uint64_t v9 = v10;
            }
            while (v10);
            unint64_t v7 = a1[22];
          }
        }
        int v6 = (void *)*((void *)a1 + 10);
      }
      free(v6);
    }
    *((void *)a1 + 36) = 0;
    *((_OWORD *)a1 + --*(_DWORD *)(result + 16) = 0u;
    *((_OWORD *)a1 + 17) = 0u;
    *((_OWORD *)a1 + 14) = 0u;
    *((_OWORD *)a1 + 15) = 0u;
    *((_OWORD *)a1 + 12) = 0u;
    *((_OWORD *)a1 + 13) = 0u;
    *((_OWORD *)a1 + 10) = 0u;
    *((_OWORD *)a1 + 11) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_OWORD *)a1 + 9) = 0u;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    *((_OWORD *)a1 + 5) = 0u;
    *((_OWORD *)a1 + 2) = 0u;
    *((_OWORD *)a1 + 3) = 0u;
    *(_OWORD *)a1 = 0u;
    *((_OWORD *)a1 + 1) = 0u;
    free(a1);
  }
  return 0;
}

uint64_t sub_100047358(uint64_t a1)
{
  return *(unsigned int *)(a1 + 92);
}

uint64_t sub_100047360(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 92) % a2) {
    return 34;
  }
  uint64_t result = 0;
  unint64_t v4 = *(void *)(a1 + 56) * (unint64_t)*(unsigned int *)(a1 + 48) / a2;
  *(_DWORD *)(a1 + 48) = a2;
  *(void *)(a1 + 56) = v4;
  return result;
}

void *sub_1000473A0(void *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  result[7] = a2;
  result[8] = a4;
  result[9] = a3;
  return result;
}

uint64_t sub_1000473AC(uint64_t result)
{
  if (result) {
    return *(void *)(result + 40);
  }
  return result;
}

uint64_t sub_1000473B8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 120)) {
    return 16;
  }
  unint64_t v3 = *(unsigned int *)(a1 + 88);
  if (v3)
  {
    for (unint64_t i = 0; i < v3; ++i)
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 80) + 8 * i);
      if (v5)
      {
        do
        {
          int v6 = *(_DWORD *)(v5 + 40);
          if (v6)
          {
            if ((v6 & 4) != 0) {
              uint64_t v7 = a1 + 200;
            }
            else {
              uint64_t v7 = 0;
            }
            uint64_t result = sub_1000486C0(a1, v5, v7);
            if (result) {
              return result;
            }
            *(_DWORD *)(v5 + 40) &= ~1u;
            --*(_DWORD *)(a1 + 100);
          }
          uint64_t v5 = *(void *)(v5 + 16);
        }
        while (v5);
        unint64_t v3 = *(unsigned int *)(a1 + 88);
      }
    }
  }
  *(_DWORD *)(a1 + 104) = 0;
  (*(void (**)(void, uint64_t))(*(void *)(a1 + 40) + 80))(*(void *)(a1 + 32), 1);
  return 0;
}

uint64_t sub_100047474(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2 / *(unsigned int *)(a1 + 92) * *(unsigned int *)(a1 + 92) % *(unsigned int *)(a1 + 88);
  if (a3) {
    *a3 = 0;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 80) + 8 * v5);
  if (!v6) {
    return 2;
  }
  while (*(void *)(v6 + 48) != a2)
  {
    uint64_t v6 = *(void *)(v6 + 16);
    if (!v6) {
      return 2;
    }
  }
  if (!*(void *)(v6 + 112))
  {
    uint64_t v7 = 0;
    if (!a3) {
      return v7;
    }
    goto LABEL_14;
  }
  uint64_t v7 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 48))(*(void *)(a1 + 32));
  if (v7)
  {
    uint64_t v9 = *(void **)(v6 + 56);
    *uint64_t v9 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = v9;
    ++*(_DWORD *)(a1 + 144);
    *(void *)(v6 + 56) = 0;
  }
  free(*(void **)(v6 + 112));
  *(void *)(v6 + 112) = 0;
  if (a3)
  {
LABEL_14:
    if (!v7) {
      *a3 = v6;
    }
  }
  return v7;
}

uint64_t sub_100047548(void *a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a2 + 44);
  if (!v2) {
    return 37;
  }
  *(_DWORD *)(a2 + 44) = v2 - 1;
  sub_100047580(a1, (uint64_t *)a2, 0);
  return 0;
}

void *sub_100047580(void *result, uint64_t *a2, int a3)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v4 = a2[1];
    if (v4)
    {
      *(void *)(v3 + 8) = v4;
      *(void *)a2[1] = v3;
    }
  }
  if (*((_DWORD *)a2 + 11))
  {
    unint64_t v5 = (void *)result[2];
    *a2 = (uint64_t)v5;
    uint64_t v6 = result + 2;
    uint64_t result = v5;
  }
  else if (a3)
  {
    *a2 = (uint64_t)result;
    uint64_t v6 = (void *)result[1];
  }
  else
  {
    uint64_t v6 = result;
    uint64_t result = (void *)*result;
    *a2 = (uint64_t)result;
  }
  a2[1] = (uint64_t)v6;
  result[1] = a2;
  *(void *)a2[1] = a2;
  return result;
}

uint64_t sub_1000475E8(uint64_t a1, unint64_t a2, unsigned int a3, void *a4, uint64_t a5, int a6, unsigned char *a7, long long *a8, uint64_t a9)
{
  unint64_t v15 = *(unsigned int *)(a1 + 92);
  if ((a6 & 4) != 0 && v15 != *(_DWORD *)(a1 + 48)) {
    return 45;
  }
  unint64_t v72 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v16 = a2 / v15 * v15;
  uint64_t v17 = (void *)(a1 + 160);
  while (1)
  {
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      break;
    }
    unint64_t v18 = v17[3];
    BOOL v19 = v18 < a2 || v18 >= a2 + a3;
    if (!v19) {
      return 11;
    }
  }
  uint64_t v67 = (void *)(a1 + 160);
  unint64_t v68 = a2 % v15;
  uint64_t v21 = sub_100047B18(a1, v16, &v72, a5, a6, a7, a8 != 0, a9);
  uint64_t v20 = v21;
  if (a8 && !*a7)
  {
    size_t v26 = (void *)v72;
    uint64_t v27 = *(void *)(a1 + 32);
    if (!v72)
    {
      unint64_t v28 = *(unsigned int *)(a1 + 88);
      uint64_t v29 = sub_100048944(v16, a5, a9, a6);
      if (!v29) {
        return 12;
      }
      size_t v26 = v29;
      uint64_t v29[3] = 0;
      uint64_t v30 = *(void *)(a1 + 80);
      uint64_t v31 = *(void *)(v30 + 8 * (v16 % v28));
      _OWORD v29[2] = v31;
      if (v31) {
        *(void *)(v31 + 24) = v29;
      }
      *(void *)(v30 + 8 * (v16 % v28)) = v29;
    }
    uint64_t v32 = v26[7];
    if (v32)
    {
      if (!v26[14]) {
        return 14;
      }
      *((void *)a8 + 14) = v32;
      ++*((_DWORD *)v26 + 11);
      sub_100047580((void *)a1, v26, 0);
      return 0;
    }
    unint64_t v34 = *(unsigned int *)(a1 + 48);
    uint64_t v35 = *(void *)(a1 + 56);
    uint64_t v36 = *(void *)(a1 + 64);
    unint64_t v37 = v16 / v34;
    if (v36)
    {
      unint64_t v38 = *(void *)(a1 + 72);
      uint64_t v39 = v38 + v36;
      if (v38 <= v37) {
        uint64_t v35 = v39;
      }
    }
    unint64_t v40 = v35 - 1;
    BOOL v19 = v40 >= v37;
    unint64_t v41 = v40 - v37;
    if (!v19) {
      return 6;
    }
    unint64_t v42 = *(_DWORD *)(a1 + 92) / v34;
    if (v41 < v42) {
      unint64_t v43 = v41 + 1;
    }
    else {
      unint64_t v43 = v42;
    }
    uint64_t v44 = sub_1000489B0(*(void *)(v27 + 16));
    v26[7] = v44;
    if (v44)
    {
      uint64_t v45 = malloc_type_malloc(0x68uLL, 0x10A2040BE83C1C8uLL);
      v26[14] = v45;
      if (v45)
      {
        long long v46 = *a8;
        long long v47 = a8[2];
        v45[1] = a8[1];
        v45[2] = v47;
        *uint64_t v45 = v46;
        long long v48 = a8[3];
        long long v49 = a8[4];
        long long v50 = a8[5];
        *((void *)v45 + 12) = *((void *)a8 + 12);
        _OWORD v45[4] = v49;
        v45[5] = v50;
        v45[3] = v48;
        uint64_t v20 = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, void, uint64_t, uint64_t, void, void, _DWORD, void))(*(void *)(a1 + 40) + 40))(v27, v37, v43, v26[7], a5, 1, v26[14], v26[12], *((_DWORD *)v26 + 26), 0);
        if (v20)
        {
          uint64_t v51 = *(void *)(v27 + 16);
          uint64_t v52 = (void *)v26[7];
          *uint64_t v52 = *(void *)(v51 + 136);
          *(void *)(v51 + 136) = v52;
          ++*(_DWORD *)(v51 + 144);
          v26[7] = 0;
          free((void *)v26[14]);
          v26[14] = 0;
        }
        else
        {
          *((void *)a8 + 14) = v26[7];
          ++*((_DWORD *)v26 + 11);
          sub_100047580((void *)a1, v26, 0);
        }
        return v20;
      }
      uint64_t v63 = *(void *)(v27 + 16);
      uint64_t v64 = (void *)v26[7];
      *uint64_t v64 = *(void *)(v63 + 136);
      *(void *)(v63 + 136) = v64;
      ++*(_DWORD *)(v63 + 144);
      v26[7] = 0;
    }
    return 12;
  }
  if (v21) {
    return v20;
  }
  uint64_t v22 = *(void *)(a1 + 168);
  if (!v22) {
    return 55;
  }
  *(void *)(a1 + 168) = *(void *)v22;
  *a4 = v22;
  *(void *)uint64_t v22 = 0;
  *(void *)(v22 + 8) = 0;
  *(_DWORD *)(v22 + --*(_DWORD *)(result + 16) = 0;
  *(void *)(v22 + 24) = a2;
  *(_DWORD *)(v22 + 32) = a3;
  *(void *)(v22 + 40) = 0;
  if (v16 / *(unsigned int *)(a1 + 92) == (a2 + a3 - 1) / *(unsigned int *)(a1 + 92))
  {
    unint64_t v23 = v72;
    *(void *)(v22 + 40) = *(void *)(v72 + 56) + v68;
    ++*(_DWORD *)(v23 + 44);
    sub_100047580((void *)a1, (uint64_t *)v23, 0);
LABEL_16:
    long long v24 = v67;
    uint64_t v25 = *v67;
    if (*v67)
    {
      *(void *)uint64_t v22 = v25;
      *(void *)(v22 + 8) = 0;
      long long v24 = (void *)(v25 + 8);
    }
    uint64_t v20 = 0;
    *long long v24 = v22;
    ++*(_DWORD *)(a1 + 176);
    return v20;
  }
  *(_DWORD *)(v22 + --*(_DWORD *)(result + 16) = 0x80000000;
  char v71 = -86;
  if (a8)
  {
    *(void *)uint64_t v22 = *(void *)(a1 + 168);
    *(void *)(a1 + 168) = v22;
    return 45;
  }
  uint64_t v53 = malloc_type_malloc(a3, 0x5F096CBuLL);
  *(void *)(v22 + 40) = v53;
  if (!v53) {
    return 12;
  }
  unsigned int v54 = *(_DWORD *)(a1 + 92) - v68;
  unsigned int v55 = a3 - v54;
  memcpy(v53, (const void *)(*(void *)(v72 + 56) + v68), v54);
  uint64_t v56 = (uint64_t *)v72;
  ++*(_DWORD *)(v72 + 44);
  sub_100047580((void *)a1, v56, 0);
  if (!v55)
  {
LABEL_55:
    ++*(_DWORD *)(a1 + 192);
    goto LABEL_16;
  }
  unint64_t v57 = v16 + *(unsigned int *)(a1 + 92);
  while (1)
  {
    uint64_t v58 = sub_100047B18(a1, v57, &v72, a5, a6, &v71, 0, 0);
    if (v58) {
      break;
    }
    unsigned int v59 = *(_DWORD *)(a1 + 92);
    if (v55 >= v59) {
      size_t v60 = v59;
    }
    else {
      size_t v60 = v55;
    }
    memcpy((void *)(*(void *)(v22 + 40) + v54), *(const void **)(v72 + 56), v60);
    uint64_t v61 = (uint64_t *)v72;
    ++*(_DWORD *)(v72 + 44);
    uint64_t v62 = *(unsigned int *)(a1 + 92);
    sub_100047580((void *)a1, v61, 0);
    if (!v71) {
      *a7 = 0;
    }
    v54 += v60;
    v57 += v62;
    v55 -= v60;
    if (!v55) {
      goto LABEL_55;
    }
  }
  uint64_t v20 = v58;
  free(*(void **)(v22 + 40));
  *(void *)(v22 + 40) = 0;
  if (!v54)
  {
    unint64_t v65 = v57 - *(unsigned int *)(a1 + 92);
    while (1)
    {
      uint64_t v20 = sub_100047B18(a1, v65, &v72, a5, a6, a7, 0, 0);
      if (v20) {
        break;
      }
      uint64_t v66 = (uint64_t *)v72;
      --*(_DWORD *)(v72 + 44);
      sub_100047580((void *)a1, v66, 0);
    }
  }
  return v20;
}

uint64_t sub_100047B18(uint64_t a1, unint64_t a2, void *a3, uint64_t a4, int a5, unsigned char *a6, int a7, uint64_t a8)
{
  uint64_t result = 22;
  if (!a3 || !a6) {
    return result;
  }
  char v10 = a7;
  unint64_t v13 = a2 % *(unsigned int *)(a1 + 88);
  *a6 = 0;
  *a3 = 0;
  uint64_t v14 = *(void *)(a1 + 80);
  unint64_t v15 = *(void **)(v14 + 8 * v13);
  if (v15)
  {
    unint64_t v16 = *(void **)(v14 + 8 * v13);
    while (v16[6] != a2)
    {
      unint64_t v16 = (void *)v16[2];
      if (!v16) {
        goto LABEL_7;
      }
    }
    if (v15 != v16)
    {
      uint64_t v18 = v16[2];
      if (v18) {
        *(void *)(v18 + 24) = v16[3];
      }
      *(void *)(v16[3] + --*(_DWORD *)(result + 16) = v18;
    }
    if (v16[7] && !v16[14]) {
      *a6 = 1;
    }
  }
  else
  {
LABEL_7:
    if (a7)
    {
      ++*(_DWORD *)(a1 + 176);
      return 2;
    }
    uint64_t v17 = sub_100048944(a2, a4, a8, a5);
    if (!v17) {
      return 12;
    }
    unint64_t v16 = v17;
    uint64_t v14 = *(void *)(a1 + 80);
  }
  if (*(void **)(v14 + 8 * v13) != v16)
  {
    void v16[3] = 0;
    uint64_t v19 = *(void *)(v14 + 8 * v13);
    v16[2] = v19;
    if (v19) {
      *(void *)(v19 + 24) = v16;
    }
    *(void *)(v14 + 8 * v13) = v16;
  }
  if (v10) {
    goto LABEL_26;
  }
  if (v16[7])
  {
    if (v16[14]) {
      sub_100047474(a1, a2, 0);
    }
    goto LABEL_26;
  }
  uint64_t v20 = sub_1000489B0(a1);
  v16[7] = v20;
  if (!v20) {
    return 12;
  }
  unint64_t v21 = *(unsigned int *)(a1 + 48);
  unint64_t v22 = a2 / v21;
  if (a2 % v21 || *(_DWORD *)(a1 + 92) % v21) {
    return 22;
  }
  uint64_t v23 = *(void *)(a1 + 56);
  uint64_t v24 = *(void *)(a1 + 64);
  if (v24)
  {
    unint64_t v25 = *(void *)(a1 + 72);
    uint64_t v26 = v25 + v24;
    if (v25 <= v22) {
      uint64_t v23 = v26;
    }
  }
  if (v23 - 1 < v22) {
    return 6;
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 40))(*(void *)(a1 + 32));
  if (!result)
  {
    ++*(_DWORD *)(a1 + 184);
LABEL_26:
    uint64_t result = 0;
    *a3 = v16;
  }
  return result;
}

uint64_t sub_100047D24(_DWORD *a1, uint64_t a2, unint64_t a3, int a4, int a5, int a6, uint64_t a7, int a8, uint64_t a9)
{
  unint64_t v16 = a1[23];
  if ((a8 & 4) != 0 && v16 != a1[12]) {
    return 45;
  }
  uint64_t v33 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v29 = a2;
  uint64_t v30 = a3;
  int v31 = a4;
  int v32 = a6;
  char v28 = -86;
  int v17 = a1[30];
  if (v17)
  {
    int v32 = v17 | a6;
  }
  else if ((a6 & 1) == 0)
  {
    if (a1[26])
    {
      uint64_t result = sub_1000473B8((uint64_t)a1);
      if (result) {
        return result;
      }
    }
  }
  unint64_t v18 = a3 / v16 * v16;
  uint64_t result = sub_100047B18((uint64_t)a1, v18, &v33, a7, a8, &v28, 0, a9);
  if (result) {
    return result;
  }
  int v20 = a3 - v18;
  unsigned int v21 = a1[23];
  if ((int)a3 - (int)v18 + a4 <= v21)
  {
    uint64_t result = sub_100047EF8((uint64_t)a1, (uint64_t)&v29, v33, a5, a7);
    if (result) {
      return result;
    }
    goto LABEL_22;
  }
  unsigned int v22 = v21 - v20;
  int v31 = v21 - v20;
  uint64_t result = sub_100047EF8((uint64_t)a1, (uint64_t)&v29, v33, a5, a7);
  if (result) {
    return result;
  }
  unsigned int v23 = a4 - v22;
  if (a4 == v22)
  {
LABEL_22:
    uint64_t result = 0;
    ++a1[45];
    return result;
  }
  uint64_t v24 = a1[23];
  unint64_t v25 = v18 + v24;
  while (1)
  {
    int v26 = v23 >= v24 ? v24 : v23;
    sub_100047B18((uint64_t)a1, v25, &v33, a7, a8, &v28, 0, 0);
    uint64_t v27 = *(void *)(v33 + 48);
    int v31 = v26;
    uint64_t v29 = a2 + v22;
    uint64_t v30 = v27;
    uint64_t result = sub_100047EF8((uint64_t)a1, (uint64_t)&v29, v33, a5, a7);
    if (result) {
      return result;
    }
    v22 += v26;
    uint64_t v24 = a1[23];
    v25 += v24;
    v23 -= v26;
    if (!v23) {
      goto LABEL_22;
    }
  }
}

uint64_t sub_100047EF8(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  unint64_t v10 = *(void *)(a2 + 8) % (unint64_t)*(unsigned int *)(a1 + 92);
  if (*(_DWORD *)(a1 + 120))
  {
    size_t v11 = *(unsigned int *)(a2 + 16);
    int v12 = *(void **)(a3 + 64);
    if (v12)
    {
      uint64_t v13 = *(unsigned int *)(a3 + 80);
      if (v13)
      {
        size_t v14 = *(void *)(a3 + 72);
        if (v13 != v11 || v14 != v10)
        {
          size_t v15 = v14 + v13;
          memcpy(v12, *(const void **)(a3 + 56), v14);
          memcpy((void *)(*(void *)(a3 + 64) + v15), (const void *)(*(void *)(a3 + 56) + v15), *(unsigned int *)(a1 + 92) - v15);
          *(void *)(a3 + 72) = 0;
          *(_DWORD *)(a3 + 80) = 0;
        }
      }
    }
    else
    {
      unint64_t v16 = sub_1000489B0(a1);
      *(void *)(a3 + 64) = v16;
      if (!v16) {
        return 12;
      }
      memcpy((char *)v16 + v10, (const void *)(*(void *)(a3 + 56) + v10), v11);
      *(void *)(a3 + 72) = v10;
      int v17 = *(_DWORD *)(a3 + 40);
      *(_DWORD *)(a3 + 80) = v11;
      *(_DWORD *)(a3 + 84) = v17;
      *(void *)(a3 + 32) = *(void *)(a1 + 112);
      *(void *)(a1 + 112) = a3;
      ++*(_DWORD *)(a1 + 108);
    }
  }
  memcpy((void *)(*(void *)(a3 + 56) + v10), *(const void **)a2, *(unsigned int *)(a2 + 16));
  unint64_t v18 = *(void *)(a2 + 8);
  unint64_t v19 = *(unsigned int *)(a1 + 92);
  unsigned int v20 = *(_DWORD *)(a1 + 48);
  signed int v21 = (v18 % v19) / v20;
  LODWORD(v19) = (v18 + *(unsigned int *)(a2 + 16) - 1) % v19;
  uint64_t v22 = a3 + 88;
  int v23 = v21 >> 3;
  signed int v24 = v19 / v20;
  int v25 = 255 << (v21 & 7);
  if (v21 >> 3 == v24 >> 3)
  {
    unsigned int v26 = (0xFFu >> (~(_BYTE)v24 & 7)) & v25;
  }
  else
  {
    *(unsigned char *)(v22 + v23) |= v25;
    if (v23 + 1 < v24 >> 3) {
      memset((void *)(v23 + a3 + 89), 255, ((v24 >> 3) - v23 - 2) + 1);
    }
    unsigned int v26 = 0xFFu >> (~(_BYTE)v24 & 7);
    int v23 = v24 >> 3;
  }
  *(unsigned char *)(v22 + v23) |= v26;
  int v27 = *(_DWORD *)(a2 + 20) & 3;
  if (v27)
  {
    int v28 = *(_DWORD *)(a3 + 40);
    if ((v28 & 1) == 0) {
      ++*(_DWORD *)(a1 + 100);
    }
    *(_DWORD *)(a3 + 40) = v28 | v27;
    goto LABEL_18;
  }
  uint64_t result = sub_1000486C0(a1, a3, a5);
  if (!result)
  {
LABEL_18:
    sub_100047580((void *)a1, (uint64_t *)a3, a4);
    return 0;
  }
  return result;
}

uint64_t sub_100048124(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 120)) {
    return 37;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 120) = 1;
  ++*(_DWORD *)(a1 + 104);
  return result;
}

uint64_t sub_100048154(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 120)) {
    return 37;
  }
  uint64_t v1 = *(void *)(a1 + 112);
  if (v1)
  {
    int v2 = *(_DWORD *)(a1 + 144);
    uint64_t v3 = *(void **)(a1 + 136);
    do
    {
      uint64_t v4 = *(void **)(v1 + 64);
      *uint64_t v4 = v3;
      *(void *)(a1 + 136) = v4;
      ++v2;
      *(void *)(v1 + 64) = 0;
      *(_DWORD *)(v1 + 84) = 0;
      uint64_t v1 = *(void *)(v1 + 32);
      uint64_t v3 = v4;
    }
    while (v1);
    *(_DWORD *)(a1 + 144) = v2;
  }
  *(void *)(a1 + 1--*(_DWORD *)(result + 16) = 0;
  *(void *)(a1 + 108) = 0;
  unsigned int v5 = *(_DWORD *)(a1 + 96);
  unsigned int v6 = v5 - *(_DWORD *)(a1 + 100);
  unsigned int v7 = v5 >> 2;
  BOOL v8 = v6 >= 0x101 && v6 >= v7;
  if (v8 && *(_DWORD *)(a1 + 104) < 0x400u) {
    return 0;
  }
  uint64_t result = sub_1000473B8(a1);
  if (!result) {
    return 84;
  }
  return result;
}

uint64_t sub_1000481F0(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 120)) {
    return 22;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  if (v2)
  {
    int v3 = -1;
    while (1)
    {
      uint64_t v4 = *(void *)(v2 + 64);
      if (!v4) {
        return 14;
      }
      if (++v3 >= *(_DWORD *)(a1 + 108)) {
        return 14;
      }
      size_t v5 = *(unsigned int *)(v2 + 80);
      unsigned int v6 = *(void **)(v2 + 56);
      if (v5)
      {
        memcpy((char *)v6 + *(void *)(v2 + 72), (const void *)(v4 + *(void *)(v2 + 72)), v5);
        unsigned int v6 = *(void **)(v2 + 64);
      }
      else
      {
        *(void *)(v2 + 56) = v4;
      }
      *unsigned int v6 = *(void *)(a1 + 136);
      *(void *)(a1 + 136) = v6;
      ++*(_DWORD *)(a1 + 144);
      *(void *)(v2 + 64) = 0;
      int v7 = *(_DWORD *)(v2 + 84);
      *(_DWORD *)(v2 + 40) = v7;
      *(_DWORD *)(v2 + 84) = 0;
      if ((v7 & 1) == 0) {
        --*(_DWORD *)(a1 + 100);
      }
      uint64_t v2 = *(void *)(v2 + 32);
      if (!v2) {
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    uint64_t result = 0;
    *(void *)(a1 + 1--*(_DWORD *)(result + 16) = 0;
    *(void *)(a1 + 108) = 0;
    --*(_DWORD *)(a1 + 104);
  }
  return result;
}

double sub_1000482D4(uint64_t a1, uint64_t *a2, int a3)
{
  unint64_t v20 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v6 = a2[3];
  unint64_t v7 = v6 / *(unsigned int *)(a1 + 92) * *(unsigned int *)(a1 + 92);
  char v19 = -86;
  if (!sub_100047B18(a1, v7, &v20, 0, 0, &v19, 0, 0))
  {
    if ((a2[2] & 0x80000000) != 0)
    {
      unsigned int v10 = *((_DWORD *)a2 + 8) + v6 - v7 - *(_DWORD *)(a1 + 92);
      size_t v11 = (uint64_t *)v20;
      if ((*(unsigned char *)(v20 + 40) & 2) == 0) {
        --*(_DWORD *)(v20 + 44);
      }
      sub_100047580((void *)a1, v11, a3);
      if (v10)
      {
        unint64_t v12 = v7 + *(unsigned int *)(a1 + 92);
        do
        {
          sub_100047B18(a1, v12, &v20, 0, 0, &v19, 0, 0);
          unsigned int v13 = *(_DWORD *)(a1 + 92);
          if (v10 >= v13) {
            unsigned int v14 = v10 - v13;
          }
          else {
            unsigned int v14 = 0;
          }
          size_t v15 = (uint64_t *)v20;
          if ((*(unsigned char *)(v20 + 40) & 2) == 0) {
            --*(_DWORD *)(v20 + 44);
          }
          sub_100047580((void *)a1, v15, a3);
          v12 += *(unsigned int *)(a1 + 92);
          BOOL v16 = v10 > v13;
          unsigned int v10 = v14;
        }
        while (v16);
      }
      free((void *)a2[5]);
    }
    else
    {
      uint64_t v9 = (uint64_t *)v20;
      if ((*(unsigned char *)(v20 + 40) & 2) == 0) {
        --*(_DWORD *)(v20 + 44);
      }
      sub_100047580((void *)a1, v9, a3);
    }
    uint64_t v17 = *a2;
    if (*a2) {
      *(void *)(v17 + 8) = a2[1];
    }
    unint64_t v18 = (void *)a2[1];
    if (v18) {
      *unint64_t v18 = v17;
    }
    if (*(uint64_t **)(a1 + 160) == a2) {
      *(void *)(a1 + 160) = *a2;
    }
    double result = 0.0;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
    *a2 = *(void *)(a1 + 168);
    *(void *)(a1 + 168) = a2;
  }
  return result;
}

uint64_t sub_100048490(uint64_t a1, _DWORD *a2)
{
  if (a2[11]) {
    return 16;
  }
  uint64_t v4 = *((void *)a2 + 2);
  if (v4) {
    *(void *)(v4 + 24) = *((void *)a2 + 3);
  }
  uint64_t v5 = *((void *)a2 + 3);
  if (v5) {
    unint64_t v6 = (void *)(v5 + 16);
  }
  else {
    unint64_t v6 = (void *)(*(void *)(a1 + 80) + 8 * (*((void *)a2 + 6) % (unint64_t)*(unsigned int *)(a1 + 88)));
  }
  *unint64_t v6 = v4;
  if (!*((void *)a2 + 7) || (uint64_t result = sub_100048534(a1, (uint64_t)a2), !result))
  {
    *((void *)a2 + 14) = 0;
    *((_OWORD *)a2 + 5) = 0u;
    *((_OWORD *)a2 + 6) = 0u;
    *((_OWORD *)a2 + 3) = 0u;
    *((_OWORD *)a2 + 4) = 0u;
    *((_OWORD *)a2 + 1) = 0u;
    *((_OWORD *)a2 + 2) = 0u;
    *(_OWORD *)a2 = 0u;
    free(a2);
    return 0;
  }
  return result;
}

uint64_t sub_100048534(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a2 + 40);
  if ((v4 & 4) != 0) {
    uint64_t v5 = a1 + 200;
  }
  else {
    uint64_t v5 = 0;
  }
  if ((v4 & 1) != 0 || *(void *)(a2 + 64))
  {
    if (*(_DWORD *)(a1 + 120)) {
      return 16;
    }
    if (*(_DWORD *)(a1 + 104))
    {
      uint64_t result = sub_1000473B8(a1);
      if (result) {
        return result;
      }
      unsigned int v4 = *(_DWORD *)(a2 + 40);
    }
    else
    {
      uint64_t result = sub_1000486C0(a1, a2, v5);
      if (result) {
        return result;
      }
      unsigned int v4 = *(_DWORD *)(a2 + 40) & 0xFFFFFFFE;
      *(_DWORD *)(a2 + 40) = v4;
      --*(_DWORD *)(a1 + 100);
    }
  }
  uint64_t result = 0;
  if ((v4 & 2) == 0)
  {
    unint64_t v7 = *(void **)(a2 + 56);
    *unint64_t v7 = *(void *)(a1 + 136);
    *(void *)(a1 + 136) = v7;
    ++*(_DWORD *)(a1 + 144);
  }
  return result;
}

uint64_t sub_1000485EC(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v11 = a2;
  unint64_t v4 = *(unsigned int *)(a1 + 92);
  if (a2) {
    uint64_t v5 = *(unsigned int *)(a1 + 92);
  }
  else {
    uint64_t v5 = a3 % v4 + a4;
  }
  if (!v5) {
    return 0;
  }
  char v10 = -86;
  unint64_t v7 = a3 - a3 % v4;
  while (!a2)
  {
    sub_100047B18(a1, v7, &v11, 0, 0, &v10, 1, 0);
    a2 = v11;
    if (v11) {
      break;
    }
LABEL_13:
    a2 = 0;
    uint64_t v11 = 0;
    uint64_t v9 = *(unsigned int *)(a1 + 92);
    v7 += v9;
    v5 -= v9;
    if (!v5) {
      return 0;
    }
  }
  if (!*(_DWORD *)(a2 + 44))
  {
    if (*(void *)(a2 + 56))
    {
      uint64_t result = sub_100048534(a1, a2);
      if (result) {
        return result;
      }
      a2 = v11;
    }
    *(void *)(a2 + 56) = 0;
    goto LABEL_13;
  }
  return 16;
}

uint64_t sub_1000486C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 48);
  unint64_t v4 = *(unsigned int *)(a1 + 48);
  if (v3 % v4) {
    return 22;
  }
  unsigned int v6 = *(_DWORD *)(a1 + 92);
  int v7 = v6 / v4;
  if (v6 % v4) {
    return 22;
  }
  if (v7 < 1) {
    return 0;
  }
  uint64_t v11 = *(void *)(a2 + 56);
  unint64_t v12 = (unsigned __int8 *)(a2 + 88);
  do
  {
    uint64_t v13 = 0;
    unsigned int v14 = v12;
    while (1)
    {
      unsigned int v16 = *v14++;
      unsigned int v15 = v16;
      if (v16) {
        break;
      }
      v13 += 8;
      if (((v7 - 1) & 0xFFFFFFF8) + 8 == v13) {
        return 0;
      }
    }
    if ((v15 & 1) == 0)
    {
      do
      {
        char v17 = v15;
        LODWORD(v13) = v13 + 1;
        v15 >>= 1;
      }
      while ((v17 & 2) == 0);
    }
    uint64_t result = 0;
    if ((int)v13 >= v7 || v13 == -1) {
      break;
    }
    LODWORD(v18) = 0;
    do
      uint64_t v18 = (v18 + 1);
    while (((v12[((int)v18 + (int)v13) >> 3] >> ((v18 + v13) & 7)) & 1) != 0);
    int v19 = (int)v13 >> 3;
    int v20 = v13 + v18 - 1;
    int v21 = v20 >> 3;
    unsigned int v22 = 0xFFu >> (8 - (v13 & 7));
    if (v20 >> 3 == (int)v13 >> 3)
    {
      int v23 = (510 << (v20 & 7)) | v22;
    }
    else
    {
      v12[v19] &= v22;
      if (v19 + 1 < v21) {
        bzero(&v12[v19 + 1], (v21 - v19 - 2) + 1);
      }
      int v23 = 510 << (v20 & 7);
      int v19 = v20 >> 3;
    }
    v12[v19] &= v23;
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t, uint64_t, uint64_t, void, void, void))(*(void *)(a1 + 40) + 72))(*(void *)(a1 + 32), (v3 + (*(_DWORD *)(a1 + 48) * v13)) / *(unsigned int *)(a1 + 48), v18, v11 + (*(_DWORD *)(a1 + 48) * v13), a3, *(void *)(a2 + 96), *(unsigned int *)(a2 + 104), 0);
    if (result) {
      break;
    }
    ++*(_DWORD *)(a1 + 188);
    int v7 = *(_DWORD *)(a1 + 92) / *(_DWORD *)(a1 + 48);
  }
  while (v7 > 0);
  return result;
}

uint64_t sub_1000488B0(uint64_t result)
{
  unint64_t v1 = *(unsigned int *)(result + 88);
  if (v1)
  {
    uint64_t v2 = result;
    for (unint64_t i = 0; i < v1; ++i)
    {
      uint64_t v4 = *(void *)(*(void *)(v2 + 80) + 8 * i);
      if (v4)
      {
        do
        {
          if (*(void *)(v4 + 112))
          {
            uint64_t result = sub_100047474(v2, *(void *)(v4 + 48), 0);
            if (!result)
            {
              int v5 = *(_DWORD *)(v4 + 44);
              if (v5)
              {
                *(_DWORD *)(v4 + 44) = v5 - 1;
                uint64_t result = (uint64_t)sub_100047580((void *)v2, (uint64_t *)v4, 0);
              }
            }
          }
          uint64_t v4 = *(void *)(v4 + 16);
        }
        while (v4);
        unint64_t v1 = *(unsigned int *)(v2 + 88);
      }
    }
  }
  return result;
}

void *sub_100048944(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result = malloc_type_calloc(0x78uLL, 1uLL, 0x94B8249DuLL);
  if (result)
  {
    result[6] = a1;
    if (a2) {
      *((_DWORD *)result + 10) |= 4u;
    }
    result[12] = a3;
    *((_DWORD *)result + 26) = a4 & 0xFFFEFFFF;
  }
  return result;
}

void *sub_1000489B0(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 136);
  if (result && *(_DWORD *)(a1 + 144)) {
    goto LABEL_3;
  }
  uint64_t v4 = *(uint64_t **)(a1 + 8);
  if (v4 == (uint64_t *)a1) {
    return 0;
  }
  while (1)
  {
    uint64_t v5 = *v4;
    *(void *)(v5 + 8) = v4[1];
    *(void *)v4[1] = v5;
    if ((v4[5] & 1) == 0 && !*((_DWORD *)v4 + 11)) {
      break;
    }
    uint64_t v6 = *(void *)(a1 + 16);
    *uint64_t v4 = v6;
    v4[1] = a1 + 16;
    *(void *)(v6 + 8) = v4;
    *(void *)v4[1] = v4;
    uint64_t v4 = *(uint64_t **)(a1 + 8);
    if (v4 == (uint64_t *)a1) {
      return 0;
    }
  }
  sub_100048490(a1, v4);
  uint64_t result = *(void **)(a1 + 136);
  if (result)
  {
LABEL_3:
    int v3 = *(_DWORD *)(a1 + 144);
    if (v3)
    {
      *(void *)(a1 + 136) = *result;
      *(_DWORD *)(a1 + 144) = v3 - 1;
      return result;
    }
    return 0;
  }
  return result;
}

time_t sub_100048A64()
{
  time_t result = time(0);
  qword_100091538 = result;
  qword_100091540 = (uint64_t)"";
  dword_100091548 = 1;
  dword_10009154C = -1;
  dword_100091550 = 0;
  dword_100091554 = 1;
  return result;
}

void sub_100048AC0()
{
}

uint64_t sub_100048ACC(uint64_t result)
{
  dword_100091548 = result;
  return result;
}

uint64_t sub_100048AD8(uint64_t result)
{
  qword_100091540 = result;
  return result;
}

void sub_100048AE4()
{
}

BOOL sub_100048AF8()
{
  int v0 = dword_100091554;
  if (dword_100091554 <= 4) {
    ++dword_100091554;
  }
  return v0 < 5;
}

uint64_t sub_100048B1C()
{
  return dword_100091564;
}

uint64_t sub_100048B28()
{
  return dword_100091568;
}

char *sub_100048B34(char *result, int a2)
{
  int v2 = (int)result;
  if (a2) {
    int v3 = a2;
  }
  else {
    int v3 = -1;
  }
  if ((v3 + 11) >= 0xA)
  {
    int v8 = dword_10009165C;
    uint64_t v9 = dword_10009165C;
    int v10 = dword_10009154C;
    if (dword_10009165C < 1)
    {
      LODWORD(v11) = 0;
    }
    else
    {
      uint64_t v11 = 0;
      while (dword_100091660[v11] != dword_10009154C)
      {
        if (dword_10009165C == ++v11)
        {
          LODWORD(v11) = dword_10009165C;
          goto LABEL_15;
        }
      }
      ++dword_100091674[v11];
    }
LABEL_15:
    if (v11 == v9 && v8 <= 4 && v10 >= 1)
    {
      dword_100091660[v9] = v10;
      dword_100091674[v9] = 1;
      dword_10009165C = v9 + 1;
    }
    free((void *)qword_100091558);
    time_t result = strdup((const char *)qword_100091540);
    qword_100091558 = (uint64_t)result;
    dword_100091688 = dword_100091548;
    dword_10009154C = v2;
    dword_100091550 = v3;
    int v7 = &dword_100091568;
    int v4 = dword_100091568;
    goto LABEL_20;
  }
  int v4 = dword_100091564;
  if (dword_100091564 <= 20)
  {
    uint64_t v5 = (-2 - v3);
    uint64_t v6 = dword_10009156C[v5];
    if ((int)v6 <= 4)
    {
      *((_DWORD *)&unk_100091594 + 5 * v5 + v6) = result;
      dword_10009156C[v5] = v6 + 1;
      int v7 = &dword_100091564;
LABEL_20:
      *int v7 = v4 + 1;
    }
  }
  return result;
}

uint64_t sub_100048CA8(FILE *a1, int a2)
{
  int v3 = "";
  int v4 = "n";
  if (a2 != 1) {
    int v4 = "";
  }
  if (a2 == 2) {
    int v4 = "y";
  }
  if (qword_100091558) {
    int v3 = (const char *)qword_100091558;
  }
  fprintf(a1, "dev=%s vers=%s default_ans=%s result=%d ", v3, "2317.60.23.0.1", v4, dword_100091550);
  if (dword_100091564)
  {
    uint64_t v5 = 0;
    uint64_t v6 = &dword_100091598;
    do
    {
      uint64_t v7 = dword_10009156C[v5];
      if ((int)v7 >= 1)
      {
        fprintf(a1, "wr=%d wl=%d", -2 - v5, *((_DWORD *)&unk_100091594 + 5 * v5));
        if (v7 != 1)
        {
          uint64_t v8 = v7 - 1;
          uint64_t v9 = v6;
          do
          {
            int v10 = *v9++;
            fprintf(a1, ":%d", v10);
            --v8;
          }
          while (v8);
        }
        fputc(32, a1);
      }
      ++v5;
      v6 += 5;
    }
    while (v5 != 10);
  }
  if (dword_10009165C >= 1)
  {
    uint64_t v11 = 0;
    do
    {
      fprintf(a1, "pl=%d:%d ", dword_100091660[v11], dword_100091674[v11]);
      ++v11;
    }
    while (v11 < dword_10009165C);
  }
  int v12 = dword_100091688;
  int v13 = dword_10009154C;
  int v14 = dword_100091560;
  time_t v15 = time(0);
  return fprintf(a1, "fp=%d fl=%d repairs=%d time=%ld iter=%d\n", v12, v13, v14, (v15 - qword_100091538 + 59) / 60, dword_100091554);
}

uint64_t sub_100048EBC(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 8 && a4 == 16)
  {
    unint64_t v8 = *a3;
    uint64_t v9 = *(void *)(*a5 + 8);
    uint64_t v10 = *(void *)(*a5 + 24);
    if (v10)
    {
      unint64_t v11 = *(void *)(v10 + 48);
      unint64_t v12 = *(void *)(v10 + 96);
    }
    else
    {
      unint64_t v11 = *(void *)(v9 + 40);
      if (*(unsigned char *)(v9 + 65)) {
        unint64_t v12 = *(void *)(v9 + 40);
      }
      else {
        unint64_t v12 = 0;
      }
    }
    unint64_t v14 = *(unsigned int *)(v9 + 36);
    unint64_t v15 = a3[1];
    if (v8 && (v11 > v15 ? (BOOL v16 = v11 > v8) : (BOOL v16 = 0), v16 ? (v17 = v11 - v15 >= v8) : (v17 = 0), v17)
      || ((unint64_t v18 = 0x4000000000000000uLL >> __clz(__rbit64(v14)), v18 < v8) ? (v19 = v12 > v15) : (v19 = 0),
          v19 ? (BOOL v20 = (v12 | v18) > v8) : (BOOL v20 = 0),
          v20 && ((v12 - v15) | v18) >= v8))
    {
      uint64_t v13 = 0;
      a5[1] += v15;
    }
    else
    {
      sub_10004458C("invalid range: 0x%llx+%llu\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, *a3);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    sub_10004458C("unexpected key (%u) / val (%u) size in extent list tree\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a2);
    uint64_t v13 = 92;
    sub_100048B34((char *)0x218, 92);
  }
  return v13;
}

uint64_t sub_100048FC0(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 8 && a4 == 16)
  {
    unint64_t v8 = a5[1];
    unint64_t v9 = a3[1];
    unint64_t v10 = *a5 - *a3;
    if (v10 > v9 - v8) {
      int v11 = 0;
    }
    else {
      int v11 = -1;
    }
    if (v10 < v9 && v9 >= v8) {
      unsigned int v13 = v11;
    }
    else {
      unsigned int v13 = 0;
    }
    if (*a5 >= *a3) {
      return v13;
    }
    else {
      return 0;
    }
  }
  else
  {
    sub_10004458C("unexpected key (%u) / val (%u) size in extent list tree\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a2);
    uint64_t v14 = 92;
    sub_100048B34((char *)0x219, 92);
  }
  return v14;
}

uint64_t sub_100049048(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(uint32x2_t **)(a1 + 24);
  uint64_t v9 = v8[4].u32[0];
  uint64_t v10 = *(void *)(a1 + 8);
  if (v9 != *(_DWORD *)(v10 + 36))
  {
    sub_10004458C("spaceman block size %u doesn't match NX superblock block size %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[4].i32[0]);
    uint64_t v37 = 92;
    uint64_t v38 = 131;
    goto LABEL_39;
  }
  if (*(void *)&v8[12] + *(void *)&v8[6] != *(void *)(v10 + 40))
  {
    sub_10004458C("spaceman block count %llu doesn't match NX superblock block count %llu\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[12].i8[0] + v8[6].i8[0]);
    uint64_t v37 = 92;
    uint64_t v38 = 132;
    goto LABEL_39;
  }
  if (v8[4].i32[1] != 8 * v9)
  {
    sub_10004458C("spaceman blocks per chunk %u is inconsistent with block size %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[4].i32[1]);
    uint64_t v37 = 92;
    uint64_t v38 = 133;
    goto LABEL_39;
  }
  if (v8[5].i32[0] != (unint64_t)(v9 - 40) >> 5)
  {
    sub_10004458C("spaceman chunks per cib %u is inconsistent with block size %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[5].i32[0]);
    uint64_t v37 = 92;
    uint64_t v38 = 138;
    goto LABEL_39;
  }
  if (v8[5].i32[1] != (unint64_t)(v9 - 40) >> 3)
  {
    sub_10004458C("spaceman cibs per cab %u is inconsistent with block size %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[5].i32[1]);
    uint64_t v37 = 92;
    uint64_t v38 = 139;
    goto LABEL_39;
  }
  uint64_t v13 = 0;
  uint64_t v14 = *(unsigned int *)(a1 + 96);
  char v15 = 1;
  BOOL v16 = "main";
  do
  {
    char v17 = v15;
    uint32x2_t v18 = v8[6 * v13 + 6];
    uint32x2_t v19 = v8[6 * v13 + 7];
    unint64_t v20 = v8[4].u32[1];
    unint64_t v21 = *(void *)&v18 / v20;
    if (*(void *)&v18 % v20) {
      ++v21;
    }
    if (*(void *)&v19 != v21)
    {
      sub_10004458C("spaceman %s chunk count %llu is inconsistent with block count %llu and blocks per chunk %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)v16);
      uint64_t v37 = 92;
      uint64_t v38 = 134;
      goto LABEL_39;
    }
    uint64_t v22 = v8[6 * v13 + 8].u32[0];
    unint64_t v23 = v8[5].u32[0];
    unint64_t v24 = *(void *)&v19 / v23;
    if (*(void *)&v19 % v23) {
      ++v24;
    }
    if (v24 != v22)
    {
      sub_10004458C("spaceman %s cib count %u is inconsistent with chunk count %llu and chunks per cib %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)v16);
      uint64_t v37 = 92;
      uint64_t v38 = 135;
      goto LABEL_39;
    }
    unsigned __int32 v25 = v8[5].u32[1];
    unsigned int v26 = v22 / v25;
    if (v22 % v25) {
      ++v26;
    }
    if (v26 == 1) {
      unsigned int v27 = 0;
    }
    else {
      unsigned int v27 = v26;
    }
    if (v8[6 * v13 + 8].i32[1] != v27)
    {
      sub_10004458C("spaceman %s cab count %u is inconsistent with cib count %u and cibs per cab %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)v16);
      uint64_t v37 = 92;
      uint64_t v38 = 140;
      goto LABEL_39;
    }
    if (*(void *)&v8[6 * v13 + 9] > *(void *)&v18)
    {
      if (v17) {
        int v28 = "main";
      }
      else {
        int v28 = "tier2";
      }
      sub_10004458C("spaceman %s free count is too large: %llu > %llu\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)v28);
      sub_100048B34((char *)0x93, -8);
    }
    char v15 = 0;
    BOOL v16 = "tier2";
    uint64_t v13 = 1;
  }
  while ((v17 & 1) != 0);
  uint64_t v29 = *(void *)&v8[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v29 != 3 * (vaddvq_s64((int64x2_t)vaddl_u32(v8[8], v8[14])) + *(void *)&v8[7] + *(void *)&v8[13]))
  {
    sub_10004458C("spaceman ip block count is bad: %lld\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[19].i8[0]);
    uint64_t v37 = 92;
    uint64_t v38 = 142;
    goto LABEL_39;
  }
  if ((v8[4].u32[0] + 8 * ((unint64_t)(v29 + 63) >> 6) - 1) / v8[4].u32[0] != v8[20].i32[0])
  {
    sub_10004458C("spaceman ip bm block count is bad: %d\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, v8[20].i32[0]);
    uint64_t v37 = 92;
    uint64_t v38 = 143;
    goto LABEL_39;
  }
  uint64_t v154 = a1;
  uint64_t v155 = 0;
  if (sub_100049F10(a1, &v154, a3, a4, a5, a6, a7, a8))
  {
    sub_10004458C("spaceman IP bitmap range is invalid: 0x%llx+0x%x\n", v30, v31, v32, v33, v34, v35, v36, *(void *)&v8[21]);
    uint64_t v37 = 92;
    uint64_t v38 = 144;
    goto LABEL_39;
  }
  if (v155 != (v8[20].i32[1] & 0x7FFFFFFF))
  {
    sub_10004458C("spaceman IP bitmap blocks field is %u, but sum of ranges is %llu\n", v30, v31, v32, v33, v34, v35, v36, v8[20].i8[4]);
    uint64_t v37 = 92;
    uint64_t v38 = 576;
    goto LABEL_39;
  }
  uint64_t v155 = 0;
  if (sub_100049F84(a1, (uint64_t (*)(void *, uint64_t, void *, uint64_t, uint64_t))sub_100048EBC, (uint64_t)&v154))
  {
    sub_10004458C("spaceman IP range is invalid: 0x%llx+0x%llx\n", v40, v41, v42, v43, v44, v45, v46, *(void *)&v8[22]);
    uint64_t v37 = 92;
    uint64_t v38 = 145;
    goto LABEL_39;
  }
  uint32x2_t v47 = v8[19];
  if ((*(void *)&v47 & 0x7FFFFFFFFFFFFFFFLL) != v155)
  {
    sub_10004458C("spaceman IP blocks field is %llu, but sum of ranges is %llu\n", v40, v41, v42, v43, v44, v45, v46, v47.i8[0]);
    uint64_t v37 = 92;
    uint64_t v38 = 577;
    goto LABEL_39;
  }
  uint64_t v142 = v14;
  if ((*(void *)&v47 & 0x8000000000000000) == 0)
  {
    uint64_t v48 = v8[20].u32[1];
    if ((v48 & 0x80000000) == 0)
    {
      uint32x2_t v49 = v8[21];
      uint32x2_t v50 = v8[22];
      if (*(void *)&v49 < *(void *)&v50 + *(void *)&v47 && *(void *)&v50 < *(void *)&v49 + v48)
      {
        sub_10004458C("spaceman ip bm range (%llu, %llu) overlaps with spaceman ip range (%llu, %llu)\n", v40, v41, v42, v43, v44, v45, v46, v49.i8[0]);
        uint64_t v37 = 92;
        uint64_t v38 = 146;
        goto LABEL_39;
      }
    }
  }
  uint32x2_t v51 = v8[23];
  if (*(void *)&v51 > *(void *)(*(void *)(a1 + 8) + 40))
  {
    sub_10004458C("spaceman fs_reserve_block_count %llu is greater than nx_block_count %llu\n", v40, v41, v42, v43, v44, v45, v46, *(void *)&v8[23]);
    sub_100048B34((char *)0x2F4, 92);
    uint32x2_t v51 = v8[23];
  }
  if (*(void *)&v8[24] > *(void *)&v51)
  {
    sub_100044674("spaceman fs_reserve_alloc_count %llu is greater than sm_fs_reserve_block_count %llu\n", v40, v41, v42, v43, v44, v45, v46, *(void *)&v8[24]);
    sub_100048B34((char *)0x2F5, -7);
  }
  if (v8[18].i8[0])
  {
    __int32 v53 = v8[42].i32[0];
    if (v53 == 1)
    {
      if (v8[42].i32[1] != 2520)
      {
        sub_10004458C("unexpected spaceman struct size %u != %u\n", v40, v41, v42, v43, v44, v45, v46, v8[42].i32[1]);
        uint64_t v37 = 92;
        uint64_t v38 = 603;
        goto LABEL_39;
      }
    }
    else
    {
      if (!v53)
      {
        sub_10004458C("spaceman struct is versioned but version is 0\n", v40, v41, v42, v43, v44, v45, v46, v142);
        uint64_t v37 = 92;
        uint64_t v38 = 602;
        goto LABEL_39;
      }
      sub_100044674("unknown spaceman struct version %u > %u\n", v40, v41, v42, v43, v44, v45, v46, v8[42].i32[0]);
    }
    char v54 = 0;
    uint64_t v55 = 0;
    uint64_t v145 = v8 + 43;
    unsigned int v143 = v8 + 76;
    int v56 = 1;
    unint64_t v57 = "main";
    while (1)
    {
      int v144 = v56;
      uint64_t v58 = &v8[6 * v55];
      uint32x2_t v59 = v58[6];
      uint64_t v151 = v58 + 6;
      if (v59) {
        break;
      }
LABEL_111:
      int v56 = 0;
      char v54 = 1;
      unint64_t v57 = "tier2";
      uint64_t v55 = 1;
      if ((v144 & 1) == 0)
      {
        int v52 = 2520;
        goto LABEL_113;
      }
    }
    unint64_t v60 = 0;
    uint64_t v149 = &v143[136 * v55];
    uint64_t v148 = -7;
    uint64_t v146 = v55;
    while (1)
    {
      uint64_t v61 = (uint64_t)&v145[136 * v55 + 17 * v60];
      long long __base = *(_OWORD *)v61;
      long long v161 = *(_OWORD *)(v61 + 80);
      long long v162 = *(_OWORD *)(v61 + 96);
      long long v163 = *(_OWORD *)(v61 + 112);
      uint64_t v164 = *(void *)(v61 + 128);
      long long v157 = *(_OWORD *)(v61 + 16);
      long long v158 = *(_OWORD *)(v61 + 32);
      long long v159 = *(_OWORD *)(v61 + 48);
      long long v160 = *(_OWORD *)(v61 + 64);
      BOOL v147 = __base != 0;
      if (__base != 0)
      {
        unint64_t v62 = *((void *)&__base + 1) - __base;
        if (*((void *)&__base + 1) < (unint64_t)__base) {
          goto LABEL_70;
        }
        unint64_t v63 = 0x4000000000000000uLL >> __clz(__rbit64(v8[4].u32[0]));
        if ((v54 & (v63 > (unint64_t)__base)) != 0) {
          goto LABEL_70;
        }
        uint32x2_t v80 = *v151;
        if ((v54 & 1) == 0) {
          unint64_t v63 = 0;
        }
        BOOL v72 = *(void *)&v80 >= v62;
        unint64_t v81 = *(void *)&v80 - v62;
        if (v81 == 0
          || !v72
          || (v63 | *(void *)&v80) <= (unint64_t)__base
          || (v63 | v81) < (unint64_t)__base)
        {
LABEL_70:
          sub_100044674("spaceman %s datazone current boundaries (%llu -> %llu) is not a valid address range on disk\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
          sub_100048B34((char *)0x3BA, -7);
        }
      }
      uint64_t v64 = 0;
      char v65 = 0;
      unint64_t v150 = v60;
      int v152 = (uint64_t *)v60;
      do
      {
        unint64_t v66 = *(void *)((char *)&__base + v64 + 16);
        unint64_t v67 = *(void *)((char *)&v157 + v64 + 8);
        BOOL v68 = *(long long *)((char *)&__base + v64 + 16) != 0;
        if (*(long long *)((char *)&__base + v64 + 16) != 0)
        {
          unint64_t v69 = v67 - v66;
          if (v67 < v66) {
            goto LABEL_83;
          }
          unint64_t v70 = 0x4000000000000000uLL >> __clz(__rbit64(v8[4].u32[0]));
          if ((v54 & (v70 > v66)) != 0) {
            goto LABEL_83;
          }
          uint32x2_t v71 = *v151;
          if ((v54 & 1) == 0) {
            unint64_t v70 = 0;
          }
          BOOL v72 = *(void *)&v71 >= v69;
          unint64_t v73 = *(void *)&v71 - v69;
          BOOL v74 = v73 != 0 && v72 && (v70 | *(void *)&v71) > v66;
          if (!v74 || (v70 | v73) < v66)
          {
LABEL_83:
            sub_100044674("spaceman %s datazone previous boundaries (%llu -> %llu) is not a valid address range on disk\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
            sub_100048B34((char *)0x3BB, -7);
          }
        }
        v65 |= v68;
        v64 += 16;
      }
      while (v64 != 112);
      int v75 = (unsigned __int16)v164;
      if ((unsigned __int16)v164 > 4u) {
        break;
      }
      if ((_WORD)v164) {
        goto LABEL_88;
      }
      unint64_t v77 = v150;
      if (v147 || v65 & 1 | (WORD1(v164) != 0))
      {
        sub_100044674("spaceman %s datazone zone id is zero but other fields are initialized\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
        sub_100048B34((char *)0x3BD, 92);
        char v76 = 1;
        goto LABEL_89;
      }
      char v76 = 1;
LABEL_91:
      if (v77 <= 6)
      {
        uint64_t v78 = v149;
        uint64_t v79 = v148;
        do
        {
          if ((v76 & 1) == 0 && v75 == v78->u16[0])
          {
            sub_100044674("spaceman %s datazone duplicate zone id (%hu) for allocation zones at indices (%hu, %hu)\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
            sub_100048B34((char *)0x3BF, -2);
          }
          v78 += 17;
          BOOL v72 = __CFADD__(v79++, 1);
        }
        while (!v72);
      }
      unint64_t v60 = v150 + 1;
      ++v148;
      v149 += 17;
      uint64_t v55 = v146;
      if (v150 == 7) {
        goto LABEL_111;
      }
    }
    sub_100044674("spaceman %s datazone unknown zone id (%hu)\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
    sub_100048B34((char *)0x3BC, -2);
LABEL_88:
    char v76 = 0;
    unint64_t v77 = v150;
LABEL_89:
    if (WORD1(v164) >= 7u)
    {
      sub_100044674("spaceman %s datazone invalid previous boundary index (%hu)\n", v40, v41, v42, v43, v44, v45, v46, (char)v57);
      sub_100048B34((char *)0x3BE, -2);
    }
    goto LABEL_91;
  }
  int v52 = 336;
LABEL_113:
  LODWORD(__base) = 0;
  DWORD1(__base) = v52;
  __int32 v82 = v8[20].i32[0];
  __int32 v83 = v8[20].i32[1];
  DWORD2(__base) = v8[40].i32[1];
  HIDWORD(__base) = 8 * v82;
  LODWORD(v157) = v8[41].i32[0];
  DWORD1(v157) = 2 * v82;
  DWORD2(v157) = v8[41].i32[1];
  HIDWORD(v157) = 2 * v83;
  LODWORD(v158) = v8[10].i32[0];
  __int32 v84 = v8[8].i32[1];
  if (!v84) {
    __int32 v84 = v8[8].i32[0];
  }
  __int32 v85 = v8[16].i32[0];
  DWORD1(v158) = 8 * v84;
  DWORD2(v158) = v85;
  __int32 v86 = v8[14].i32[1];
  if (!v86) {
    __int32 v86 = v8[14].i32[0];
  }
  HIDWORD(v158) = 8 * v86;
  qsort(&__base, 6uLL, 8uLL, (int (__cdecl *)(const void *, const void *))sub_100049FF8);
  unint64_t v95 = 0;
  char v96 = (_DWORD *)&__base + 2;
  do
  {
    unsigned int v97 = *(v96 - 2);
    unsigned int v98 = *(v96 - 1);
    if (v142 < v97 || v98 > v142 - v97)
    {
      sub_10004458C("spaceman struct range %u+%u lies outside the struct itself (size %u)\n", v88, v89, v90, v91, v92, v93, v94, v97);
      uint64_t v37 = 92;
      uint64_t v38 = 578;
      goto LABEL_39;
    }
    if (v95 <= 4 && v98 > *v96 - v97)
    {
      sub_10004458C("spaceman struct ranges %u+%u and %u+%u overlap\n", v88, v89, v90, v91, v92, v93, v94, v97);
      uint64_t v37 = 92;
      uint64_t v38 = 579;
      goto LABEL_39;
    }
    v96 += 2;
    ++v95;
  }
  while (v95 != 6);
  int v100 = v8[40].u16[1];
  if (v8[40].u16[0] == 0xFFFF)
  {
    if (v100 != 0xFFFF)
    {
LABEL_131:
      sub_10004458C("spaceman sm_ip_bm_free_head %u and sm_ip_bm_free_tail %u do not point to a valid list\n", v88, v89, v90, v91, v92, v93, v94, v8[40].i16[0]);
      uint64_t v37 = 92;
      uint64_t v38 = 760;
      goto LABEL_39;
    }
  }
  else if (v100 == 0xFFFF)
  {
    goto LABEL_131;
  }
  __int32 v101 = v8[20].i32[1];
  if ((v101 & 0x7FFF0000) == 0)
  {
    int v152 = &v142;
    uint64_t v102 = (char *)v8 + v8[41].u32[1];
    size_t v103 = 2 * (v101 & 0x7FFFFFFF);
    __chkstk_darwin(v87);
    unint64_t v104 = (char *)&v142 - ((v103 + 15) & 0x1FFFFFFF0);
    if (v105) {
      memset((char *)&v142 - ((v103 + 15) & 0x1FFFFFFF0), 170, v103);
    }
    else {
      size_t v103 = 0;
    }
    bzero(v104, v103);
    unsigned int v113 = v8[40].u16[0];
    while (1)
    {
      if (v113 == 0xFFFF) {
        goto LABEL_143;
      }
      unsigned int v114 = v113;
      if ((v8[20].i32[1] & 0x7FFFFFFFu) <= v113) {
        break;
      }
      if (*(_WORD *)&v104[2 * v113] == 2)
      {
        sub_10004458C("spaceman ip bm list has a loop\n", v106, v107, v108, v109, v110, v111, v112, v142);
        uint64_t v37 = 92;
        uint64_t v141 = 765;
        goto LABEL_175;
      }
      *(_WORD *)&v104[2 * v113] = 2;
      unsigned int v113 = *(unsigned __int16 *)&v102[2 * v113];
      if (v113 == 0xFFFF)
      {
        if (v8[40].u16[1] == v114)
        {
LABEL_143:
          unint64_t v115 = v8[20].u32[0];
          if (v115)
          {
            uint64_t v116 = 0;
            uint64_t v117 = (char *)v8 + v8[40].u32[1];
            uint64_t v118 = (char *)v8 + v8[41].u32[0];
            uint64_t v37 = 92;
            while (*(void *)&v117[8 * v116] <= *(void *)&v8[2])
            {
              uint64_t v119 = *(unsigned __int16 *)&v118[2 * v116];
              if ((v8[20].i32[1] & 0x7FFFFFFFu) <= v119)
              {
                sub_10004458C("spaceman ip bitmap block address is invalid: %hu > %u\n", v106, v107, v108, v109, v110, v111, v112, *(_WORD *)&v118[2 * v116]);
                uint64_t v37 = 92;
                uint64_t v141 = 150;
                goto LABEL_175;
              }
              int v120 = *(unsigned __int16 *)&v104[2 * *(unsigned __int16 *)&v118[2 * v116]];
              if (v120 == 1)
              {
                sub_10004458C("spaceman ip bitmap %u at index %u was referenced by a previous entry in sm_ip_bitmap \n", v106, v107, v108, v109, v110, v111, v112, *(_WORD *)&v118[2 * v116]);
                uint64_t v37 = 92;
                uint64_t v141 = 780;
                goto LABEL_175;
              }
              if (v120 == 2)
              {
                sub_10004458C("spaceman ip bitmap %u at index %u was on the free list\n", v106, v107, v108, v109, v110, v111, v112, *(_WORD *)&v118[2 * v116]);
                uint64_t v37 = 92;
                uint64_t v141 = 770;
                goto LABEL_175;
              }
              if (*(__int16 *)&v102[2 * v119] != -1)
              {
                sub_10004458C("spaceman ip bitmap %u at index %u is not invalidated on the free list\n", v106, v107, v108, v109, v110, v111, v112, *(_WORD *)&v118[2 * v116]);
                sub_100048B34((char *)0x30B, 92);
                if (!sub_10004641C(qword_100091B70, "Invalidate spaceman ip bm free list at index at index %u? ", v121, v122, v123, v124, v125, v126, *(_WORD *)&v118[2 * v116]))return v37; {
                *(_WORD *)&v102[2 * *(unsigned __int16 *)&v118[2 * v116]] = -1;
                }
                *a2 = 1;
                unint64_t v115 = v8[20].u32[0];
                uint64_t v119 = *(unsigned __int16 *)&v118[2 * v116];
              }
              *(_WORD *)&v104[2 * v119] = 1;
              if (++v116 >= v115) {
                goto LABEL_153;
              }
            }
            sub_10004458C("spaceman ip bitmap block xid is invalid: %llu > %llu\n", v106, v107, v108, v109, v110, v111, v112, *(void *)&v117[8 * v116]);
            uint64_t v37 = 92;
            uint64_t v141 = 149;
          }
          else
          {
LABEL_153:
            uint64_t v127 = v8[20].i32[1] & 0x7FFFFFFF;
            if (!v127)
            {
LABEL_157:
              uint64_t v129 = 0;
              uint64_t v130 = "main";
              char v131 = 1;
              while (1)
              {
                char v132 = v131;
                uint64_t v133 = &v8[6 * v129];
                uint64_t v134 = (uint64_t)v8 + v133[10].u32[0];
                uint64_t v153 = 0;
                unsigned int v135 = v133[8].u32[1];
                if (v135)
                {
                  uint64_t v136 = sub_10004A010((uint64_t *)a1, v129, v134, v135, &v153, v110, v111, v112);
                  if (v136) {
                    return v136;
                  }
                }
                else
                {
                  uint64_t v136 = sub_10004A220((uint64_t *)a1, v129, v134, 0, v8[6 * v129 + 8].u32[0], &v153, v111, v112);
                  if (v136) {
                    return v136;
                  }
                }
                if (v153 != *(void *)&v8[6 * v129 + 9])
                {
                  sub_100044674("spaceman %s free count %llu does not match sum of free counts %llu\n", v137, v138, v139, v140, v110, v111, v112, (char)v130);
                  sub_100048B34((char *)0x24C, -7);
                }
                char v131 = 0;
                uint64_t v130 = "tier2";
                uint64_t v129 = 1;
                if ((v132 & 1) == 0) {
                  return 0;
                }
              }
            }
            uint64_t v128 = 0;
            while (*(_WORD *)&v104[2 * v128])
            {
              if (v127 == ++v128) {
                goto LABEL_157;
              }
            }
            sub_10004458C("spaceman ip bitmap block at index [%u] is neither on the sm_ip_bitmap[] nor on the free list\n", v106, v107, v108, v109, v110, v111, v112, v128);
            uint64_t v37 = 92;
            uint64_t v141 = 773;
          }
        }
        else
        {
          sub_10004458C("spaceman sm_ip_bm_free_tail %u does not point to the last index on the free list %u\n", v106, v107, v108, v109, v110, v111, v112, v8[40].i16[1]);
          uint64_t v37 = 92;
          uint64_t v141 = 761;
        }
LABEL_175:
        sub_100048B34((char *)v141, 92);
        return v37;
      }
    }
    sub_10004458C("spaceman sm_ip_bm_free_next index %u does not lie in ip bm range\n", v106, v107, v108, v109, v110, v111, v112, v113);
    uint64_t v37 = 92;
    uint64_t v141 = 764;
    goto LABEL_175;
  }
  sub_10004458C("spaceman sm_ip_bm_block_count %u is too large\n", v88, v89, v90, v91, v92, v93, v94, v8[20].i32[1]);
  uint64_t v37 = 92;
  uint64_t v38 = 778;
LABEL_39:
  sub_100048B34((char *)v38, 92);
  return v37;
}

uint64_t sub_100049F10(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 24);
  unint64_t v10 = *(unsigned int *)(v9 + 164);
  uint64_t v11 = *(void *)(v9 + 168);
  if ((v10 & 0x80000000) != 0)
  {
    return sub_1000310DC(a1, v11, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048EBC, (uint64_t)a2);
  }
  else
  {
    v13[0] = *(void *)(v9 + 168);
    v13[1] = v10;
    return sub_100048EBC(a1, 8, v13, 16, a2, a6, a7, a8);
  }
}

uint64_t sub_100049F84(uint64_t a1, uint64_t (*a2)(void *, uint64_t, void *, uint64_t, uint64_t), uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(void *)(v4 + 152);
  uint64_t v6 = *(void *)(v4 + 176);
  if (v5 < 0)
  {
    return sub_1000310DC(a1, v6, (uint64_t (*)(void, void, void, void, uint64_t))a2, a3);
  }
  else
  {
    uint64_t v9 = 0;
    v8[0] = v6;
    v8[1] = v5;
    return a2(&v9, 8, v8, 16, a3);
  }
}

uint64_t sub_100049FF8(_DWORD *a1, _DWORD *a2)
{
  if (*a1 < *a2) {
    return 0xFFFFFFFFLL;
  }
  else {
    return *a1 > *a2;
  }
}

uint64_t sub_10004A010(uint64_t *a1, unsigned int a2, uint64_t a3, unsigned int a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v38 = 0;
  uint64_t v8 = a1[3];
  if (!a4) {
    return 0;
  }
  uint64_t v12 = 0;
  int v13 = *(_DWORD *)(v8 + 48 * a2 + 64);
  int v14 = *(_DWORD *)(v8 + 48 * a2 + 68) - 1;
  uint64_t v15 = a4;
  while (1)
  {
    uint64_t v16 = *(void *)(a3 + 8 * v12);
    v39[0] = v16;
    v39[1] = 1;
    uint64_t v17 = a1[3];
    unint64_t v18 = *(void *)(v17 + 152);
    uint64_t v19 = *(void *)(v17 + 176);
    if ((v18 & 0x8000000000000000) != 0)
    {
      int v21 = sub_1000310DC((uint64_t)a1, v19, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048FC0, (uint64_t)v39);
      uint64_t v16 = *(void *)(a3 + 8 * v12);
      if (v21 == -1) {
        goto LABEL_10;
      }
LABEL_9:
      sub_100044674("spaceman cab %u address 0x%llx is not in the internal pool\n", v19, a3, v16, (uint64_t)a5, a6, a7, a8, v12);
      sub_100048B34((char *)0x38C, -7);
      uint64_t v16 = *(void *)(a3 + 8 * v12);
      goto LABEL_10;
    }
    unint64_t v20 = v16 - v19;
    if (v16 < v19 || v20 >= v18 || v20 > v18 - 1) {
      goto LABEL_9;
    }
LABEL_10:
    uint64_t v22 = sub_1000257B4(a1, 0, 0x40000000, v16, 0, 0, 6, 0, (uint64_t **)&v38, 0, 1);
    if (v22)
    {
      uint64_t v34 = v22;
      sub_10004458C("failed to read spaceman cab %u at address 0x%llx\n", v23, v24, v25, v26, v27, v28, v29, v12);
      return v34;
    }
    uint64_t v30 = *((unsigned int *)v38 + 8);
    if (v12 != v30)
    {
      sub_10004458C("spaceman cab out of order: %u, expected %u\n", v23, v24, v25, v26, v27, v28, v29, *((_DWORD *)v38 + 8));
      uint64_t v35 = 586;
LABEL_22:
      uint64_t v34 = 92;
      sub_100048B34((char *)v35, 92);
      goto LABEL_24;
    }
    unsigned int v31 = *(_DWORD *)(v8 + 44);
    if (v30 == v14) {
      uint64_t v32 = v13 - v31 * v14;
    }
    else {
      uint64_t v32 = v31;
    }
    if (*((_DWORD *)v38 + 9) != v32)
    {
      sub_10004458C("spaceman cab %u wrong number of cibs: %u, expected %u\n", v23, v24, v25, v32, v27, v28, v29, v30);
      uint64_t v35 = 587;
      goto LABEL_22;
    }
    uint64_t v33 = sub_10004A220(a1, a2, (uint64_t)v38 + 40, v31 * v30, v32, a5, v28, v29);
    if (v33) {
      break;
    }
    free(v38);
    uint64_t v38 = 0;
    if (v15 == ++v12) {
      return 0;
    }
  }
  uint64_t v34 = v33;
LABEL_24:
  if (v38) {
    free(v38);
  }
  return v34;
}

uint64_t sub_10004A220(uint64_t *a1, unsigned int a2, uint64_t a3, int a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[3];
  unint64_t v77 = 0;
  if (!a5) {
    return 0;
  }
  int v9 = a4;
  uint64_t v10 = a3;
  uint64_t v12 = 0;
  uint64_t v13 = v8 + 48 * a2;
  int v14 = *(_DWORD *)(v13 + 56);
  int v71 = *(_DWORD *)(v13 + 64) - 1;
  uint64_t v68 = a5;
  int v73 = a4;
  uint64_t v65 = v8;
  int v69 = v14;
  while (1)
  {
    uint64_t v15 = *(void *)(v10 + 8 * v12);
    unint64_t v78 = v15;
    uint64_t v79 = 1;
    uint64_t v16 = a1[3];
    unint64_t v17 = *(void *)(v16 + 152);
    uint64_t v18 = *(void *)(v16 + 176);
    if ((v17 & 0x8000000000000000) != 0)
    {
      int v20 = sub_1000310DC((uint64_t)a1, v18, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048FC0, (uint64_t)&v78);
      uint64_t v15 = *(void *)(v10 + 8 * v12);
      if (v20 == -1) {
        goto LABEL_10;
      }
LABEL_9:
      sub_100044674("spaceman cib %u address 0x%llx is not in the internal pool\n", v18, a3, v15, a5, (uint64_t)a6, a7, a8, v12 + v9);
      sub_100048B34((char *)0x38B, -7);
      uint64_t v15 = *(void *)(v10 + 8 * v12);
      goto LABEL_10;
    }
    unint64_t v19 = v15 - v18;
    if (v15 < v18 || v19 >= v17 || v19 > v17 - 1) {
      goto LABEL_9;
    }
LABEL_10:
    uint64_t v21 = sub_1000257B4(a1, 0, 0x40000000, v15, 0, 0, 7, 0, (uint64_t **)&v77, 0, 1);
    if (v21)
    {
      uint64_t v62 = v21;
      sub_10004458C("failed to read spaceman cib %u at address 0x%llx\n", v22, v23, v24, v25, v26, v27, v28, v12 + v9);
      return v62;
    }
    uint64_t v29 = v77;
    if (*((_DWORD *)v77 + 8) != v12 + v9) {
      break;
    }
    unsigned int v30 = *(_DWORD *)(v8 + 40);
    if (v12 + v9 == v71) {
      uint64_t v31 = v14 - v30 * v71;
    }
    else {
      uint64_t v31 = v30;
    }
    if (*((_DWORD *)v77 + 9) != v31)
    {
      sub_10004458C("spaceman cib %u wrong number of chunks: %u, expected %u\n", v22, v23, v24, v25, v26, v27, v28, v12 + v9);
      uint64_t v62 = 92;
      uint64_t v63 = 585;
      goto LABEL_60;
    }
    unsigned int v32 = a2;
    if (v31)
    {
      uint64_t v33 = a1[3];
      uint64_t v76 = *(void *)(v33 + 48 * a2 + 48);
      uint64_t v75 = *(void *)(v33 + 48 * a2 + 56) - 1;
      uint64_t v34 = (unint64_t *)((char *)v77 + 64);
      uint64_t v35 = v30 * v73;
      while (1)
      {
        if (*(v34 - 3) > *(void *)(v33 + 16))
        {
          sub_10004458C("spaceman chunk %llu xid is invalid: %llu > %llu\n", v22, v23, v24, v25, v26, v27, v28, v35);
          uint64_t v62 = 92;
          uint64_t v63 = 580;
          goto LABEL_60;
        }
        unint64_t v22 = *v34;
        if (*v34)
        {
          unint64_t v78 = *v34;
          uint64_t v79 = 1;
          uint64_t v36 = a1[3];
          unint64_t v37 = *(void *)(v36 + 152);
          uint64_t v38 = *(void *)(v36 + 176);
          if ((v37 & 0x8000000000000000) == 0)
          {
            BOOL v39 = __OFSUB__(v22, v38);
            uint64_t v40 = v22 - v38;
            if (v40 < 0 != v39 || v40 >= v37 || v40 > v37 - 1)
            {
LABEL_26:
              sub_100044674("spaceman chunk %llu bitmap address 0x%llx is not in the internal pool\n", v22, v23, v24, v25, v26, v27, v28, v35);
              sub_100048B34((char *)0x389, -7);
              goto LABEL_27;
            }
LABEL_47:
            sub_100040DD0((uint64_t)a1, v22, 1, 0, 0x40000000, v22, 0, 8u, 0, 8u);
            goto LABEL_27;
          }
          int v41 = sub_1000310DC((uint64_t)a1, v38, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048FC0, (uint64_t)&v78);
          unint64_t v22 = *v34;
          if (v41 != -1) {
            goto LABEL_26;
          }
          if (v22) {
            goto LABEL_47;
          }
        }
LABEL_27:
        uint64_t v42 = *(unsigned int *)(v33 + 36);
        unint64_t v43 = v35 * v42;
        if (*(v34 - 2) != v35 * v42)
        {
          sub_10004458C("spaceman chunk %llu disk address out of order: 0x%llx, expected 0x%llx\n", v22, v23, v24, v25, v26, v27, v28, v35);
          uint64_t v62 = 92;
          uint64_t v63 = 581;
          goto LABEL_60;
        }
        if (v75 == v35) {
          uint64_t v44 = (v76 - v43);
        }
        else {
          uint64_t v44 = v42;
        }
        if ((*(_DWORD *)(v34 - 1) & 0xFFFFF) != v44)
        {
          sub_10004458C("spaceman chunk %llu wrong number of blocks: %u, expected %u\n", v22, v23, v24, v25, v26, v27, v28, v35);
          uint64_t v62 = 92;
          uint64_t v63 = 582;
          goto LABEL_60;
        }
        int v45 = *((_DWORD *)v34 - 1);
        uint64_t v46 = *(void *)&v45 & 0xFFFFFLL;
        if ((v45 & 0xFFFFFu) > v44)
        {
          sub_100044674("spaceman chunk %llu free count %u > block count %u\n", v22, v23, v24, v25, v26, v27, v28, v35);
          sub_100048B34((char *)0x247, -7);
          goto LABEL_50;
        }
        uint64_t v47 = a1[1];
        uint64_t v24 = *(void *)(v47 + 1248);
        if (!v24)
        {
          *a6 += v46;
          goto LABEL_50;
        }
        if (v32 == 1) {
          v43 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v47 + 36)));
        }
        unint64_t v78 = 0xAAAAAAAAAAAAAAAALL;
        unint64_t v48 = sub_10004E4FC(v43, v44, *(void *)(v47 + 1240), v24, &v78);
        if (!v48)
        {
          uint64_t v59 = *((_DWORD *)v34 - 1) & 0xFFFFF;
          unint64_t v60 = a6;
          unint64_t v61 = *a6;
LABEL_49:
          *unint64_t v60 = v61 + v59;
          goto LABEL_50;
        }
        unint64_t v49 = v48;
        if (v48 >= (*(_DWORD *)(v34 - 1) & 0xFFFFFu)) {
          goto LABEL_50;
        }
        uint64_t v24 = *v34;
        if (!*v34)
        {
          uint64_t v59 = *((_DWORD *)v34 - 1) & 0xFFFFF;
          unint64_t v60 = a6;
          unint64_t v61 = *a6 - v48;
          goto LABEL_49;
        }
        uint32x2_t v80 = (uint64_t *)0xAAAAAAAAAAAAAAAALL;
        uint64_t v50 = sub_1000257B4(a1, 0, 0x40000000, v24, 0, 0x20000000, 8, 0, &v80, 0, 0);
        if (v50)
        {
          uint64_t v62 = v50;
          goto LABEL_61;
        }
        unsigned int v58 = sub_10000A3F4((uint64_t)v80, 0, 0, *(_DWORD *)(v34 - 1) & 0xFFFFF);
        if ((*((_DWORD *)v34 - 1) & 0xFFFFF) != v58)
        {
          sub_100044674("spaceman chunk %llu wrong free count: %u, expected %u\n", v51, v52, v53, v54, v55, v56, v57, v35);
          sub_100048B34((char *)0x388, -7);
        }
        *a6 = *a6 + v58 - sub_10000A3F4((uint64_t)v80, 0, v78 - v43, v78 - v43 + v49);
        free(v80);
        unsigned int v32 = a2;
LABEL_50:
        if (!*v34 && (*((_DWORD *)v34 - 1) & 0xFFFFF) != v44)
        {
          sub_100044674("spaceman chunk %llu free count %u of unallocated bitmap != block count %u\n", v22, v23, v24, v25, v26, v27, v28, v35);
          sub_100048B34((char *)0x38A, -7);
        }
        v34 += 4;
        ++v35;
        if (!--v31)
        {
          uint64_t v29 = v77;
          uint64_t v10 = a3;
          int v9 = a4;
          uint64_t v8 = v65;
          break;
        }
      }
    }
    free(v29);
    unint64_t v77 = 0;
    ++v12;
    ++v73;
    int v14 = v69;
    if (v12 == v68) {
      return 0;
    }
  }
  sub_10004458C("spaceman cib out of order: %u, expected %u\n", v22, v23, v24, v25, v26, v27, v28, *((_DWORD *)v77 + 8));
  uint64_t v62 = 92;
  uint64_t v63 = 584;
LABEL_60:
  sub_100048B34((char *)v63, 92);
LABEL_61:
  if (v77) {
    free(v77);
  }
  return v62;
}

uint64_t sub_10004A7E8(uint64_t a1, void *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 24);
  if (*(void *)(v10 + 184) != *a2)
  {
    sub_100044674("sm_fs_reserve_block_count is not valid (expected %llu, actual %llu)\n", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a2);
    sub_100048B34((char *)0x446, -7);
    if (sub_10004641C(qword_100091B70, "Fix sm_fs_reserve_block_count? ", v11, v12, v13, v14, v15, v16, v24))
    {
      *(void *)(v10 + 184) = *a2;
      *a3 = 1;
    }
  }
  if (*(void *)(v10 + 192) != a2[1])
  {
    sub_100044674("sm_fs_reserve_alloc_count is not valid (expected %llu, actual %llu)\n", (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8, a2[1]);
    sub_100048B34((char *)0x447, -7);
    if (sub_10004641C(qword_100091B70, "Fix sm_fs_reserve_alloc_count? ", v17, v18, v19, v20, v21, v22, v25))
    {
      *(void *)(v10 + 192) = a2[1];
      *a3 = 1;
    }
  }
  return 0;
}

uint64_t sub_10004A8D4(uint64_t *a1, _DWORD *a2)
{
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  uint64_t v6 = a1[3];
  v35[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v7 = v6 + 216;
  while (1)
  {
    uint64_t v8 = v7 + v4;
    if (*(void *)(v7 + v4 - 8)) {
      break;
    }
LABEL_21:
    ++v5;
    v4 += 40;
    if (v4 == 120) {
      return 0;
    }
  }
  uint64_t v34 = 0xAAAAAAAAAAAAAAAALL;
  LOBYTE(v35[0]) = v4 == 0;
  HIDWORD(v35[0]) = v4 == 80;
  v35[2] = 0;
  uint64_t v36 = 0;
  v35[1] = 0;
  unint64_t v37 = -1;
  uint64_t v9 = sub_10002CC40(a1, v5, &v34);
  if (v9
    || (uint64_t v9 = sub_100035168(v34, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10004AB40, (uint64_t)v35, 0, 0), v9))
  {
    uint64_t v32 = v9;
    sub_10004458C("Spaceman free queue tree of type [%d] is invalid\n", v10, v11, v12, v13, v14, v15, v16, v5);
    return v32;
  }
  unint64_t v17 = *(void *)(v8 - 16);
  if (!LOBYTE(v35[0]) || v17 <= (*(void *)(v6 + 152) & 0x7FFFFFFFFFFFFFFFuLL))
  {
    if (v17 != v36)
    {
      uint64_t v18 = "tier2";
      if (v4 == 40) {
        uint64_t v18 = "main";
      }
      if (!v4) {
        uint64_t v18 = "IP";
      }
      sub_100044674("Spaceman free queue tree of type [%s] has sfq_count (%llu) mismatch with cumulative counts in the tree (%llu)\n", v10, v11, v12, v13, v14, v15, v16, (char)v18);
      sub_100048B34((char *)0x2F7, 92);
      if (sub_10004641C(qword_100091B70, "Fix spaceman free queue tree sfq_count (oid 0x%llx)? ", v19, v20, v21, v22, v23, v24, *(void *)(v8 - 8)))
      {
        *(void *)(v8 - --*(_DWORD *)(result + 16) = v36;
        *a2 = 1;
      }
    }
    if (*(void *)(v7 + v4) > v37)
    {
      char v25 = "tier2";
      if (v4 == 40) {
        char v25 = "main";
      }
      if (!v4) {
        char v25 = "IP";
      }
      sub_100044674("Spaceman free queue tree of type [%s] has sfq_oldest_xid (%llu) greater than the oldest xid in the free tree (%llu)\n", v10, v11, v12, v13, v14, v15, v16, (char)v25);
      sub_100048B34((char *)0x30D, 92);
      if (sub_10004641C(qword_100091B70, "Fix spaceman free queue tree sfq_oldest_xid (oid 0x%llx)? ", v26, v27, v28, v29, v30, v31, *(void *)(v8 - 8)))
      {
        *(void *)(v7 + v4) = v37;
        *a2 = 1;
      }
    }
    goto LABEL_21;
  }
  sub_10004458C("Spaceman IP free queue tree has sfq_count (%llu) greater than IP block count (%llu)\n", v10, v11, v12, v13, v14, v15, v16, *(void *)(v8 - 16));
  uint64_t v32 = 92;
  sub_100048B34((char *)0x2F6, 92);
  return v32;
}

uint64_t sub_10004AB40(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, unint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v10 = *a3;
  unint64_t v9 = a3[1];
  if (a5)
  {
    unint64_t v11 = *a5;
    if (!v10) {
      goto LABEL_6;
    }
  }
  else
  {
    unint64_t v11 = 1;
    if (!v10)
    {
LABEL_6:
      sub_10004458C("sfqe_key : (paddr 0x%llx, xid 0x%llx) : invalid xid\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, a3[1]);
      uint64_t v13 = 92;
      uint64_t v14 = 752;
LABEL_7:
      sub_100048B34((char *)v14, 92);
      return v13;
    }
  }
  uint64_t v12 = *(void **)(a1 + 24);
  if (v10 > v12[2]) {
    goto LABEL_6;
  }
  if (!*(unsigned char *)a7)
  {
    unint64_t v20 = v12[6 * (*(_DWORD *)(a7 + 4) == 1) + 6];
    unint64_t v21 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 8) + 36)));
    if (*(_DWORD *)(a7 + 4) != 1) {
      unint64_t v21 = 0;
    }
    BOOL v23 = v21 < v9 && v20 > v11 && (v21 | v20) > v9;
    if (!v23 || (v21 | (v20 - v11)) < v9)
    {
      sub_10004458C("sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in free queue tree is not a valid address range on disk\n", a2, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v9);
      uint64_t v13 = 92;
      uint64_t v14 = 754;
      goto LABEL_7;
    }
    unint64_t v27 = a3[1];
    unint64_t v28 = v11;
    unint64_t v24 = v12[19];
    uint64_t v17 = v12[22];
    if ((v24 & 0x8000000000000000) != 0)
    {
      if (sub_1000310DC(a1, v17, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048FC0, (uint64_t)&v27) != -1)goto LABEL_38; {
    }
      }
    else
    {
      unint64_t v25 = v9 - v17;
      if ((uint64_t)v9 < v17 || v24 < v11 || v25 >= v24 || v25 > v24 - v11) {
        goto LABEL_38;
      }
    }
    sub_10004458C("sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in free queue tree lies in the internal pool\n", v17, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v9);
    uint64_t v13 = 92;
    uint64_t v14 = 784;
    goto LABEL_7;
  }
  unint64_t v27 = a3[1];
  unint64_t v28 = v11;
  unint64_t v16 = v12[19];
  uint64_t v17 = v12[22];
  if ((v16 & 0x8000000000000000) == 0)
  {
    unint64_t v18 = v9 - v17;
    if ((uint64_t)v9 >= v17)
    {
      BOOL v19 = v16 < v11 || v18 >= v16;
      if (!v19 && v18 <= v16 - v11) {
        goto LABEL_38;
      }
    }
LABEL_29:
    sub_10004458C("sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : Range in ip free queue tree does not lie in the internal pool\n", v17, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v9);
    uint64_t v13 = 92;
    uint64_t v14 = 753;
    goto LABEL_7;
  }
  if (sub_1000310DC(a1, v17, (uint64_t (*)(void, void, void, void, uint64_t))sub_100048FC0, (uint64_t)&v27) != -1)goto LABEL_29; {
LABEL_38:
  }
  if (*(void *)(a7 + 8) == v10 && (int64_t)v9 < *(void *)(a7 + 16))
  {
    sub_100044674("sfqe_entry : (range 0x%llx+0x%llx, xid 0x%llx) : key out of order (last paddr 0x%llx, last xid 0x%llx)\n", v17, (uint64_t)a3, a4, (uint64_t)a5, a6, a7, a8, v9);
    sub_100048B34((char *)0x2F3, -7);
  }
  *(void *)(a7 + 8) = v10;
  *(void *)(a7 + --*(_DWORD *)(result + 16) = v11 + v9;
  unint64_t v26 = *(void *)(a7 + 32);
  *(void *)(a7 + 24) += v11;
  uint64_t v13 = 0;
  if (v26 > v10) {
    *(void *)(a7 + 32) = v10;
  }
  return v13;
}

uint64_t sub_10004AD8C(uint64_t *a1, uint64_t a2, uint64_t a3, BOOL *a4, void *a5, void *a6, void *a7, unsigned int a8)
{
  BOOL v19 = (void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_10004AE8C(a1, a2, a3, (uint64_t **)&v19);
  if (!v13)
  {
    uint64_t v14 = v19;
    int v15 = *((_DWORD *)v19 + 9);
    *a4 = (v15 & 1) == 0;
    if (a5) {
      *a5 = v14[2];
    }
    if (a6) {
      *a6 = v14[6];
    }
    uint64_t v13 = 0;
    if (!a7 || (v15 & 1) != 0) {
      goto LABEL_12;
    }
    int v16 = *((_DWORD *)v14 + 10) - 1;
    if v16 <= 4 && ((0x1Du >> v16))
    {
      unsigned int v17 = dword_10006F5C4[v16];
      if (v17 > a8)
      {
        uint64_t v13 = 34;
        goto LABEL_12;
      }
    }
    else
    {
      unsigned int v17 = 0;
    }
    memcpy(a7, (char *)v14 + *((unsigned int *)v14 + 11), v17);
    uint64_t v13 = 0;
LABEL_12:
    free(v14);
  }
  return v13;
}

uint64_t sub_10004AE8C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  uint64_t v4 = *(void *)(a2 + 48);
  if (!v4) {
    uint64_t v4 = *(void *)(a2 + 40);
  }
  uint64_t v12 = sub_1000257B4(a1, a2, 0, *(void *)(v4 + 1024), a3, 0, 30, 0, a4, 0, 0);
  if (v12)
  {
    sub_10004458C("integrity_meta: failed to copy object (0x%llx:0x%llx)\n", v5, v6, v7, v8, v9, v10, v11, *(void *)(v4 + 1024));
    sub_100048B34((char *)0x376, v12);
  }
  return v12;
}

uint64_t sub_10004AF1C(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v31 = 0;
  unsigned int v4 = *(_DWORD *)(a1[1] + 36);
  uint64_t v12 = sub_10004AE8C(a1, a2, a3, (uint64_t **)&v31);
  if (v12) {
    return v12;
  }
  uint64_t v13 = v31;
  uint64_t v14 = *((void *)v31 + 1);
  unsigned int v15 = *((_DWORD *)v31 + 8);
  if (v15)
  {
    if (*((_DWORD *)v31 + 9) >= 4u)
    {
      sub_100044674("integrity_meta: (0x%llx:0x%llx): unknown flags (0x%x)\n", v5, v6, v7, v8, v9, v10, v11, v14);
      sub_100048B34((char *)0x378, -3);
      uint64_t v13 = v31;
    }
    unsigned int v16 = v13[10];
    if ((v16 | 2) == 2 || v16 >= 6)
    {
      sub_10004458C("integrity_meta: (0x%llx:0x%llx): unknown hash type (%u)\n", v5, v6, v7, v8, v9, v10, v11, v14);
      uint64_t v12 = 92;
      uint64_t v18 = 889;
    }
    else
    {
      unsigned int v20 = v16 - 1;
      if (v20 > 4) {
        int v21 = 0;
      }
      else {
        int v21 = dword_10006F5D8[v20];
      }
      unint64_t v22 = v13[11];
      if ((int)v22 + v21 > v4) {
        goto LABEL_26;
      }
      if (v15 > 2)
      {
        unint64_t v23 = 48;
      }
      else
      {
        unint64_t v23 = 128;
        if (v13[8] == 1) {
          unint64_t v23 = 48;
        }
      }
      if (v23 <= v22)
      {
        if (!sub_10000A0DC((uint64_t)v13 + v22, 0, (8 * v21)))
        {
          if (*((_DWORD *)v31 + 8) < 2u || ((*((_DWORD *)v31 + 9) & 1) == 0) == (*((void *)v31 + 6) == 0))
          {
            uint64_t v12 = 0;
            *(_DWORD *)(a2 + --*(_DWORD *)(result + 16) = *((_DWORD *)v31 + 10);
            *(_DWORD *)(a2 + 20) = v21;
          }
          else
          {
            sub_10004458C("integrity_meta: (0x%llx:0x%llx): unexpected flags (0x%x) for xid (%llu)\n", v24, v25, v26, v27, v28, v29, v30, v14);
            sub_100048B34((char *)0x3B3, 92);
            uint64_t v12 = 0;
          }
          goto LABEL_13;
        }
        sub_10004458C("integrity_meta: (0x%llx:0x%llx): invalid root hash\n", v24, v25, v26, v27, v28, v29, v30, v14);
        uint64_t v12 = 92;
        uint64_t v18 = 891;
      }
      else
      {
LABEL_26:
        sub_10004458C("integrity_meta: (0x%llx:0x%llx): invalid root hash offset (%u+%u) > %u\n", v5, v6, v7, v8, v9, v10, v11, v14);
        uint64_t v12 = 92;
        uint64_t v18 = 890;
      }
    }
  }
  else
  {
    sub_10004458C("integrity_meta: (0x%llx:0x%llx): invalid version\n", v5, v6, v7, v8, v9, v10, v11, *((void *)v31 + 1));
    uint64_t v12 = 92;
    uint64_t v18 = 887;
  }
  sub_100048B34((char *)v18, 92);
LABEL_13:
  if (v31) {
    free(v31);
  }
  return v12;
}

uint64_t sub_10004B130(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(unsigned char *)(a1 + 72)) {
    return 0;
  }
  if ((*(_WORD *)(a2 + 32) & 8) != 0)
  {
    switch(*(_DWORD *)(a1 + 40))
    {
      case 1:
        ccsha256_di();
        break;
      case 3:
        ccsha384_di();
        break;
      case 4:
        ccsha512_di();
        break;
      case 5:
        ccsha512_256_di();
        break;
      default:
        break;
    }
    *(void *)&long long v12 = 0xAAAAAAAAAAAAAAAALL;
    *((void *)&v12 + 1) = 0xAAAAAAAAAAAAAAAALL;
    __s2[2] = v12;
    __s2[3] = v12;
    __s2[0] = v12;
    __s2[1] = v12;
    ccdigest();
    if (memcmp(a3 + 1, __s2, *(unsigned int *)(a1 + 44)))
    {
      sub_10004458C("hash validation: invalid node hash for node %llu (root oid: %llu, seal xid: %lld, broken xid: %lld)\n", v13, v14, v15, v16, v17, v18, v19, *a3);
      uint64_t v10 = 92;
      uint64_t v11 = 928;
      goto LABEL_11;
    }
    return 0;
  }
  sub_10004458C("hash validation: invalid node %llu (root %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *a3);
  uint64_t v10 = 92;
  uint64_t v11 = 927;
LABEL_11:
  sub_100048B34((char *)v11, 92);
  return v10;
}

uint64_t sub_10004B29C(uint64_t a1)
{
  unsigned int v528 = -1431655766;
  unsigned int v529 = -1431655766;
  int v2 = sub_10001F308();
  *(_OWORD *)v526 = 0u;
  long long v527 = 0u;
  *(_OWORD *)v525 = 0u;
  int v524 = 0;
  __int16 v523 = 0;
  int v3 = malloc_type_calloc(1uLL, 0x48uLL, 0x1030040F6ADE6ACuLL);
  qword_100091B78 = (uint64_t)v3;
  if (!v3)
  {
    sub_10004458C("failed to allocate memory for fsck_state\n", v4, v5, v6, v7, v8, v9, v10, v492);
LABEL_14:
    uint64_t v33 = 0;
    uint64_t v34 = 0;
LABEL_15:
    uint64_t v35 = 71;
    goto LABEL_16;
  }
  *(_OWORD *)int v3 = *(_OWORD *)a1;
  long long v11 = *(_OWORD *)(a1 + 16);
  long long v12 = *(_OWORD *)(a1 + 32);
  long long v13 = *(_OWORD *)(a1 + 48);
  v3[8] = *(void *)(a1 + 64);
  *((_OWORD *)v3 + 2) = v12;
  *((_OWORD *)v3 + 3) = v13;
  *((_OWORD *)v3 + 1) = v11;
  int v14 = *(_DWORD *)(qword_100091B78 + 20);
  BOOL v15 = v14 == -1 && !*(unsigned char *)(qword_100091B78 + 42) && *(unsigned char *)(qword_100091B78 + 43) == 0;
  if (!*(unsigned char *)(qword_100091B78 + 36) && *(unsigned char *)(qword_100091B78 + 38)) {
    sub_100044E88();
  }
  uint64_t v16 = sub_1000461F0();
  if (!v16)
  {
    sub_10004458C("Could not initialize message output\n", v17, v18, v19, v20, v21, v22, v23, v492);
    uint64_t v32 = 151;
    goto LABEL_13;
  }
  uint64_t v24 = (uint64_t)v16;
  sub_100046400((uint64_t)v16, *(_DWORD *)(qword_100091B78 + 28));
  sub_1000463E4(v24, *(_DWORD *)(qword_100091B78 + 32));
  if (sub_10004626C(v24, (uint64_t)&unk_1000746F0))
  {
    sub_10004458C("Could not initialize APFS-specific messages\n", v25, v26, v27, v28, v29, v30, v31, v492);
    uint64_t v32 = 152;
LABEL_13:
    sub_100048B34((char *)v32, 12);
    goto LABEL_14;
  }
  sub_1000463AC(v24, (uint64_t)sub_10004431C);
  sub_1000463C8(v24, (uint64_t)sub_100044240);
  qword_100091B70 = v24;
  if (v14 == -1) {
    sub_10000EEB0(0);
  }
  else {
    sub_10000EF04(0);
  }
  sub_100048AD8(*(void *)(qword_100091B78 + 8));
  sub_100048ACC(2);
  char v522 = 0;
  uint64_t v45 = sub_100045374((uint64_t)v2, (uint64_t)v525, &v522);
  if (v45)
  {
LABEL_32:
    uint64_t v35 = v45;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    goto LABEL_16;
  }
  char v501 = v15;
  int v502 = v14;
  uint64_t v52 = (void **)(v2 + 1);
  v504 = v2 + 1;
  while (1)
  {
    if (v522)
    {
      uint64_t v34 = 0;
      uint64_t v90 = qword_100091B78;
      if (*(unsigned char *)(qword_100091B78 + 36))
      {
        uint64_t v33 = 0;
        goto LABEL_86;
      }
      uint64_t v35 = 0;
      char v91 = 0;
      int v92 = 106;
      uint64_t v33 = 0;
      goto LABEL_328;
    }
    uint64_t v45 = sub_100045888(v2, v527);
    if (v45) {
      goto LABEL_32;
    }
    BOOL v521 = 0;
    uint64_t v45 = sub_10004591C((uint64_t)v2, v527, &v521);
    if (v45) {
      goto LABEL_32;
    }
    if (BYTE8(v527))
    {
      uint64_t v45 = sub_100045C4C((uint64_t)v2, (uint64_t)v525, *(unsigned __int8 *)(qword_100091B78 + 45));
      if (v45) {
        goto LABEL_32;
      }
    }
    sub_100048ACC(3);
    uint64_t v34 = sub_100031898(*v2, 0, (unsigned char *)&v523 + 1);
    if (!v34
      || (sub_100046EA8(v24, 201, v53, v54, v55, v56, v57, v58, v492), !HIBYTE(v523))
      && sub_100031C60(*v2, (uint64_t)v34, 0, v59, v60, v61, v62, v63))
    {
      uint64_t v88 = v24;
      int v89 = 301;
      goto LABEL_72;
    }
    nullsub_1(v34 + 18);
    sub_100048ACC(4);
    if (sub_100032850(*v2, (uint64_t)v34, v52, v2 + 5)) {
      break;
    }
    sub_100046EA8(v24, 222, v53, v54, v55, v56, v57, v58, *((void *)*v52 + 2));
    uint64_t v503 = *((void *)v34 + 8);
    if ((v503 & 0x100) != 0)
    {
      uint64_t v33 = sub_100031898(*v2, 1, &v523);
      if (!v33
        || (sub_100046EA8(v24, 202, v64, v65, v66, v67, v68, v69, v492), !(_BYTE)v523)
        && (sub_100031C60(*v2, (uint64_t)v33, 0, v70, v71, v72, v73, v74)
         || sub_10003268C((uint64_t)v33, (uint64_t)*v52, 0, 1, v66, v67, v68, v69)))
      {
LABEL_65:
        uint64_t v85 = v24;
        int v86 = 302;
LABEL_76:
        sub_100046EA8(v85, v86, v64, v65, v66, v67, v68, v69, v492);
LABEL_77:
        char v91 = 0;
        goto LABEL_78;
      }
      int v75 = sub_10002CF20((uint64_t)v2, 0);
      if (v75)
      {
        char v457 = strerror(v75);
        sub_10004458C("failed to initialize the Fusion MT tree: %s\n", v458, v459, v460, v461, v462, v463, v464, v457);
        goto LABEL_77;
      }
    }
    else
    {
      uint64_t v33 = 0;
    }
    sub_100048ACC(5);
    if (HIBYTE(v523))
    {
      if (sub_10004641C(qword_100091B70, "Fix corrupt container superblock? ", v64, v65, v66, v67, v68, v69, v492) != 1)goto LABEL_75; {
      uint64_t v76 = (_DWORD *)v2[1];
      }
      unsigned int v77 = v76[9];
      memcpy(v34, v76, 0x588uLL);
      __str[0].i64[0] = 0;
      __str[0].i64[1] = v77;
      __str[1].i64[0] = 0;
      if (sub_100026BA0(v2, 0, (uint64_t)v34, (uint64_t)__str, v78, v79)) {
        goto LABEL_75;
      }
      sub_100048AE4();
    }
    if ((_BYTE)v523)
    {
      if (sub_10004641C(qword_100091B70, "Fix corrupt 2nd-tier device container superblock? ", v64, v65, v66, v67, v68, v69, v492) != 1)goto LABEL_65; {
      uint32x2_t v80 = (unsigned int *)v2[1];
      }
      unint64_t v81 = v80[9];
      memcpy(v33, v80, 0x588uLL);
      *((unsigned char *)v33 + 1295) |= 1u;
      __str[0].i64[0] = 0x4000000000000000uLL >> __clz(__rbit64(v81));
      __str[0].i64[1] = v81;
      __str[1].i64[0] = 0;
      if (sub_100026BA0(v2, 0, (uint64_t)v33, (uint64_t)__str, v82, v83)) {
        goto LABEL_65;
      }
      sub_100048AE4();
      uint64_t v52 = (void **)(v2 + 1);
    }
    if (*(unsigned char *)(qword_100091B78 + 36))
    {
      if ((*((unsigned char *)*v52 + 1264) & 1) == 0)
      {
        uint64_t v35 = sub_10004CE78(v24, v2);
        char v91 = 0;
        goto LABEL_79;
      }
LABEL_75:
      uint64_t v85 = v24;
      int v86 = 301;
      goto LABEL_76;
    }
    if (!(HIBYTE(v523) | v523) || !(BOOL v84 = sub_100044FF8(*(const char **)(qword_100091B78 + 8))))
    {
      sub_10003F70C((uint64_t)v2);
      unint64_t v87 = *(void *)(v2[1] + 1384);
      if (v87 > 0x83B5A93981BC1)
      {
        memset(__str, 170, 25);
        unint64_t v95 = sub_10001F194(v87, __str[0].i8, 25);
        LOBYTE(v103) = (_BYTE)v95;
        if (!v95)
        {
          size_t v103 = __str;
          snprintf(__str[0].i8, 0x19uLL, "%llu", *((void *)*v52 + 173));
        }
        sub_100044674("container has been mounted by APFS version %s, which is newer than %s\n", v96, v97, v98, v99, v100, v101, v102, (char)v103);
        if (*(unsigned char *)(qword_100091B78 + 41)) {
          uint64_t v111 = "enabling overallocation repairs because -o was passed; this may cause data loss\n";
        }
        else {
          uint64_t v111 = "disabling overallocation repairs by default; use -o to override\n";
        }
        sub_100044674(v111, v104, v105, v106, v107, v108, v109, v110, v493);
      }
      else
      {
        *(unsigned char *)(qword_100091B78 + 41) = 1;
      }
      uint64_t v498 = (uint64_t)(v2 + 57);
      int v119 = sub_100027B10((uint64_t)(v2 + 57), 0);
      if (v119)
      {
LABEL_94:
        sub_10004458C("failed to initialize tree for container repairs\n", v112, v113, v114, v115, v116, v117, v118, v492);
        uint64_t v120 = 926;
        int v121 = v119;
LABEL_95:
        sub_100048B34((char *)v120, v121);
        goto LABEL_15;
      }
      uint64_t v35 = 0;
      char v496 = 0;
      v497 = (int8x16_t *)(v2 + 11);
      while (1)
      {
        sub_100048ACC(6);
        if (*((void *)v34 + 159)) {
          sub_100044674("found unexpected EFI jumpstart record\n", v122, v123, v124, v125, v126, v127, v128, v492);
        }
        sub_100048ACC(7);
        unsigned int v135 = v2 + 1;
        if (*(void *)(*v504 + 1256))
        {
          v136.i64[0] = 0xAAAAAAAAAAAAAAAALL;
          v136.i64[1] = 0xAAAAAAAAAAAAAAAALL;
          int8x16_t v532 = v136;
          int8x16_t v533 = v136;
          __str[0] = v136;
          __str[1] = v136;
          sub_100046EA8(v24, 218, v129, v130, v131, v132, v133, v134, v492);
          sub_10004D028((uint64_t)__str, (uint64_t)v2, *(void *)(v2[1] + 1256));
          if (sub_100035168((uint64_t)__str, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_1000335C8, 0, 0, 1))
          {
            uint64_t v478 = v24;
            int v479 = 319;
            goto LABEL_379;
          }
        }
        sub_100048ACC(8);
        if (sub_10002C9D0(v2, 0))
        {
          int v92 = 106;
          uint64_t v35 = 8;
          goto LABEL_382;
        }
        if (sub_100023A08(v2, v143, v46, v47, v48, v49, v50, v51)) {
          goto LABEL_380;
        }
        sub_100048ACC(9);
        sub_100046EA8(v24, 203, v144, v145, v146, v147, v148, v149, v492);
        if (sub_10002CA70(v2, 0)) {
          goto LABEL_350;
        }
        if (v502 == -1) {
          sub_10000EEB0(v2[3]);
        }
        if (sub_100049048((uint64_t)v2, &v524, v137, v138, v139, v140, v141, v142))
        {
LABEL_350:
          uint64_t v478 = v24;
          int v479 = 303;
          goto LABEL_379;
        }
        sub_1000452E0(v2, *v2);
        uint64_t v150 = v2[1];
        if ((*(_DWORD *)(v150 + 104) & 0x80000000) != 0
          || (*(_DWORD *)(v150 + 108) & 0x80000000) != 0
          || (uint64_t v151 = v2[3], (*(_DWORD *)(v151 + 164) & 0x80000000) != 0)
          || (*(void *)(v151 + 152) & 0x8000000000000000) != 0)
        {
          sub_100048ACC(10);
          sub_100046EA8(v24, 213, v152, v153, v154, v155, v156, v157, v492);
          if (sub_100033730((uint64_t)v2))
          {
            uint64_t v478 = v24;
            int v479 = 315;
            goto LABEL_379;
          }
        }
        sub_100048ACC(11);
        sub_100046EA8(v24, 217, v158, v159, v160, v161, v162, v163, v492);
        if (sub_10004A8D4(v2, &v524))
        {
          uint64_t v478 = v24;
          int v479 = 318;
          goto LABEL_379;
        }
        if (v524)
        {
          uint64_t v165 = v2[3];
          __str[0] = *v497;
          __str[1].i64[0] = v2[13];
          int v166 = sub_100026BA0(v2, 0, v165, (uint64_t)__str, __str[0], v164);
          if (v166)
          {
            int v481 = v166;
            sub_100046EA8(v24, 303, v167, v168, v169, v170, v171, v172, v492);
            uint64_t v482 = 782;
            int v483 = v481;
LABEL_376:
            sub_100048B34((char *)v482, v483);
            goto LABEL_380;
          }
          sub_100048AE4();
          int v524 = 0;
        }
        sub_100041010((uint64_t)v2);
        sub_100048ACC(12);
        sub_100046EA8(v24, 204, v173, v174, v175, v176, v177, v178, v492);
        if (sub_10002CB10(v2, 0, 0)) {
          goto LABEL_380;
        }
        if (v502 == -1) {
          sub_10001F6B4(0, *(void *)(v2[1] + 88), *(void *)(v2[4] + 88));
        }
        if (sub_10000EFC4(v2, 0, v46, v47, v48, v49, v50, v51))
        {
          uint64_t v478 = v24;
          int v479 = 305;
          goto LABEL_379;
        }
        if ((v503 & 0x100) != 0)
        {
          unint64_t v179 = *(void *)(v2[3] + 48) + 63;
          v533.i64[0] = 0;
          int8x16_t v532 = 0u;
          memset(__str, 0, sizeof(__str));
          uint64_t v520 = 0xAAAAAAAAAAAAAAAALL;
          sub_100048ACC(29);
          sub_100046EA8(v24, 212, v180, v181, v182, v183, v184, v185, v492);
          __str[1].i64[0] = (uint64_t)malloc_type_calloc(v179 >> 6, 8uLL, 0x100004000313F17uLL);
          if (!__str[1].i64[0])
          {
            sub_10004458C("failed to allocate %zd bytes for APFS Fusion data\n", v186, v187, v188, v189, v190, v191, v192, 8 * (v179 >> 6));
            uint64_t v120 = 710;
            int v121 = 12;
            goto LABEL_95;
          }
          if (sub_1000257B4(v2, 0, 0x80000000, *(void *)(v2[1] + 1360), 0, 0, 22, 0, (uint64_t **)&__str[1].i64[1], (uint64_t)&v532, 0))
          {
            sub_100046EA8(v24, 313, v193, v194, v195, v196, v197, v198, v492);
            v480 = (void *)__str[1].i64[0];
LABEL_368:
            free(v480);
LABEL_380:
            uint64_t v35 = 8;
LABEL_381:
            int v92 = 106;
LABEL_382:
            char v91 = v496;
            goto LABEL_80;
          }
          if (sub_10002CF20((uint64_t)v2, &v520)
            || sub_100035168(v520, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001D4A8, (uint64_t)__str, 0, 1))
          {
            sub_100046EA8(v24, 313, v199, v200, v201, v202, v203, v204, v492);
            free((void *)__str[1].i64[0]);
            v480 = (void *)__str[1].i64[1];
            goto LABEL_368;
          }
          int v205 = sub_10001D7C4(v2, (uint64_t)__str, v199, v200, v201, v202, v203, v204);
          if (!v205)
          {
            unint64_t v206 = sub_10000A3F4(__str[1].i64[0], 1, 0, v179 & 0xFFFFFFFFFFFFFFC0);
            if (v206
              && (sub_100044674("%lld bytes of space on the main tier are unaccounted for\n", v207, v208, v209, v210, v211, v212, v213, v206 * *(unsigned char *)(v2[3] + 32)), sub_100048B34((char *)0x2C7, -8), sub_10004641C(qword_100091B70, "Fix orphaned MT mappings? ", v214, v215, v216, v217, v218, v219,
                                  v494)))
            {
              int v205 = sub_100035168(v520, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001DDD8, (uint64_t)__str, 0, 0);
            }
            else
            {
              int v205 = 0;
            }
          }
          free((void *)__str[1].i64[0]);
          free((void *)__str[1].i64[1]);
          if (v205) {
            goto LABEL_353;
          }
          unsigned int v135 = v2 + 1;
        }
        if (*(void *)(*v135 + 1400) || *(void *)(*v135 + 1304))
        {
          sub_100048ACC(30);
          sub_100046EA8(v24, 223, v220, v221, v222, v223, v224, v225, v492);
          if (sub_1000221D0(v2, v226, v227, v228, v229, v230, v231, v232)) {
            goto LABEL_354;
          }
        }
        if (v521)
        {
          uint64_t v233 = sub_100045A94((uint64_t)v2, v527);
          if (v233)
          {
            uint64_t v35 = v233;
            goto LABEL_16;
          }
        }
        v519[0] = 0;
        v519[1] = 0;
        sub_10001F3FC((uint64_t)v2, &v529, (int *)&v528);
        uint64_t v234 = v529;
        if (v529 < v528)
        {
          while (1)
          {
            if (!*(void *)(*v135 + 8 * v234 + 184)) {
              goto LABEL_160;
            }
            __int16 v235 = sub_10001F314((uint64_t)v2, v234);
            sub_100048AD8(*(void *)v235);
            sub_100048ACC(13);
            sub_100046EA8(v24, 101, v236, v237, v238, v239, v240, v241, *(void *)v235);
            sub_100046EA8(v24, 206, v242, v243, v244, v245, v246, v247, v495);
            v500 = v235 + 704;
            int v248 = sub_100027B10((uint64_t)(v235 + 704), (uint64_t)v235);
            if (v248)
            {
              int v477 = v248;
              sub_10004458C("failed to initialize tree for volume repairs\n", v249, v250, v251, v252, v253, v254, v255, v492);
              uint64_t v120 = 705;
              int v121 = v477;
              goto LABEL_95;
            }
            uint64_t v256 = (uint64_t *)(v235 + 40);
            unint64_t v257 = *(void *)(*v135 + 8 * v234 + 184);
            uint64_t v499 = v234;
            if (*((void *)v235 + 5))
            {
              if (sub_10001F74C(0, v257, 1))
              {
                sub_100044674("object (oid 0x%llx): Unable to mark the omap entry of the apfs_sb at index (%u) in use for omap space verification\n", v258, v259, v260, v261, v262, v263, v264, *(void *)(*v135 + 8 * v234 + 184));
                sub_100048B34((char *)0x3DD, -7);
              }
            }
            else if (sub_1000257B4(v2, 0, 0, v257, 0, 0, 13, 0, (uint64_t **)v235 + 5, (uint64_t)(v235 + 80), 0))
            {
              goto LABEL_147;
            }
            if (v502 != -1) {
              sub_10000EF04(*v256);
            }
            long long v517 = 0u;
            long long v518 = 0u;
            uint64_t v515 = 0;
            memset(v514, 0, sizeof(v514));
            unint64_t v516 = 16;
            LODWORD(v517) = *(_DWORD *)(*v256 + 960);
            sub_10004D084(v24);
            if (sub_10004D174((uint64_t)v2, *v256, v234, &v524))
            {
LABEL_147:
              uint64_t v271 = v24;
              int v272 = 307;
              goto LABEL_148;
            }
            sub_100048ACC(14);
            sub_100046EA8(v24, 204, v280, v281, v282, v283, v284, v285, v492);
            if (sub_10002CB10(v2, (uint64_t)v235, 0)) {
              goto LABEL_149;
            }
            if (!*(unsigned char *)(qword_100091B78 + 42)) {
              sub_10001F6B4(1, *(void *)(*v135 + 88), *(void *)(*((void *)v235 + 9) + 88));
            }
            if (sub_10000EFC4(v2, (uint64_t)v235, v286, v287, v288, v289, v290, v291))
            {
              uint64_t v271 = v24;
              int v272 = 305;
              goto LABEL_148;
            }
            unint64_t v292 = *(void *)(*v256 + 1000);
            if (v292)
            {
              int v293 = sub_10001F74C(1, v292, 1);
              if (v293)
              {
                int v301 = v293;
                sub_100044674("object (oid 0x%llx): Unable to mark the omap entry of the apfs_snap_meta_ext_oid in use for omap space verification\n", v294, v295, v296, v297, v298, v299, v300, *(void *)(*v256 + 1000));
                sub_100048B34((char *)0x3D5, v301);
              }
            }
            uint64_t v302 = *((void *)v235 + 6);
            if (!v302) {
              uint64_t v302 = *v256;
            }
            if ((*(unsigned char *)(v302 + 56) & 0x20) != 0 && sub_10004AF1C(v2, (uint64_t)v235, 0)) {
              goto LABEL_149;
            }
            sub_100048ACC(15);
            uint64_t v303 = *v256;
            if ((*(unsigned char *)(*v256 + 264) & 1) == 0 || *(void *)(v303 + 976))
            {
              if (v235[8])
              {
                int v304 = sub_100045184((const char **)v235, v2, v527);
                if (v304)
                {
                  sub_100048B34((char *)0x45F, v304);
                  uint64_t v35 = 66;
                  goto LABEL_16;
                }
                uint64_t v303 = *v256;
              }
              if (*(void *)(v303 + 976) && sub_10003C8A8(v2, (uint64_t)v235))
              {
                uint64_t v271 = v24;
                int v272 = 314;
                goto LABEL_148;
              }
            }
            sub_100048ACC(17);
            if (*(void *)(*v256 + 152))
            {
              __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
              sub_10002B948();
              sub_100046EA8(v24, 209, v305, v306, v307, v308, v309, v310, v492);
              if (sub_10002D180((uint64_t)v2, (uint64_t)v235, __str[0].i64)
                || sub_100035168(__str[0].i64[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, (uint64_t)v514, 0, 1)|| sub_10002BC14(v500))
              {
                uint64_t v271 = v24;
                int v272 = 310;
                goto LABEL_148;
              }
            }
            sub_100048ACC(19);
            uint64_t v317 = *v256;
            BOOL v318 = (*(unsigned char *)(*v256 + 264) & 1) != 0 && !*(void *)(v317 + 976) || *((void *)v235 + 3) != 0;
            v235[9] = v318;
            char v319 = *(unsigned char *)(qword_100091B78 + 42);
            LOBYTE(v320) = v319 == 0;
            if (!v319 && !v318)
            {
              if (*((void *)v235 + 6)) {
                uint64_t v317 = *((void *)v235 + 6);
              }
              int v320 = (*(unsigned __int8 *)(v317 + 56) >> 5) & 1;
            }
            v235[10] = v320;
            v235[11] = v319;
            sub_100046EA8(v24, 205, v311, v312, v313, v314, v315, v316, v492);
            long long v512 = 0u;
            long long v513 = 0u;
            uint64_t v510 = 0;
            memset(v509, 0, sizeof(v509));
            unint64_t v511 = 16;
            LODWORD(v512) = *(_DWORD *)(*((void *)v235 + 5) + 960);
            if (sub_10000F538(v2, v235, (uint64_t)v509, v321, v322, v323, v324, v325, (int8x16_t)0, v326)) {
              goto LABEL_203;
            }
            if (!*(unsigned char *)(qword_100091B78 + 42) && v515 != v510) {
              sub_100044674("omap has %llu snaphots but snap meta tree has %llu\n", v327, v265, v266, v267, v268, v269, v270, v510);
            }
            if (v516 < v511) {
              unint64_t v516 = v511;
            }
            if (v517 < v512) {
              LODWORD(v517) = v512;
            }
            if (!*(unsigned char *)(qword_100091B78 + 42) && sub_100006D3C(v2, (uint64_t)v235, (uint64_t)v500))
            {
LABEL_203:
              uint64_t v271 = v24;
              int v272 = 306;
              goto LABEL_148;
            }
            if ((*(unsigned char *)(*v256 + 264) & 1) != 0 && !*(void *)(*v256 + 976) || *((void *)v235 + 3))
            {
              sub_1000070EC((uint64_t)v2, (uint64_t)v235, 0);
              uint64_t v328 = *((void *)v235 + 5);
              if (*(void *)(v328 + 1072) || *(void *)(v328 + 1080))
              {
                sub_100048ACC(28);
                sub_100046EA8(v24, 221, v329, v330, v331, v332, v333, v334, v492);
                if (sub_100007840(v2, (int8x16_t *)v235, 0))
                {
                  uint64_t v271 = v24;
                  int v272 = 322;
                  goto LABEL_148;
                }
              }
            }
            sub_100048ACC(16);
            *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
            *(void *)&long long v335 = 0xAAAAAAAAAAAAAAAALL;
            *((void *)&v335 + 1) = 0xAAAAAAAAAAAAAAAALL;
            *(_OWORD *)uuid_string_t out = v335;
            *(_OWORD *)&out[16] = v335;
            uuid_unparse((const unsigned __int8 *)(*v256 + 240), out);
            uint64_t v343 = *v256;
            if ((*(unsigned char *)(*v256 + 56) & 0x10) != 0) {
              break;
            }
            if (*(void *)(v343 + 160))
            {
              v235[9] = 0;
              sub_100044674("Volume %s has revert_to_xid set, skipping the fsroot tree.\n", v336, v337, v338, v339, v340, v341, v342, (char)out);
LABEL_226:
              int v344 = 0;
              goto LABEL_227;
            }
            if (((*(unsigned char *)(v343 + 264) & 1) == 0 || *(void *)(v343 + 976)) && !*((void *)v235 + 3))
            {
              sub_100044674("Volume %s is encrypted and crypto I/O failed/was skipped, skipping the fsroot tree.\n", v336, v337, v338, v339, v340, v341, v342, (char)out);
              goto LABEL_226;
            }
            sub_100020D04(v235);
            __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
            sub_100046EA8(v24, 207, v363, v364, v365, v366, v367, v368, v492);
            if (sub_10002D3D4((uint64_t)v2, (uint64_t)v235, __str[0].i64)
              || (sub_100015870(__str[0].i64[0], 0),
                  sub_100035168(__str[0].i64[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, (uint64_t)v514, 0, 0))|| *(void *)(*v256 + 1096)&& (sub_10002D4A8((uint64_t)v2, (uint64_t)v235, __str[0].i64)|| sub_100015910((uint64_t)v2, (uint64_t)v235, v500, v266, v267, v268, v269, v270)|| sub_100035168(__str[0].i64[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, (uint64_t)v514, 0, 0))|| v235[9] && sub_10002E2D8((uint64_t)v2, (uint64_t)v235)|| sub_100015964(v2, v235, 0, v500, v267, v268, v269, v270))
            {
              int v272 = 308;
LABEL_242:
              uint64_t v271 = v24;
              goto LABEL_148;
            }
            if (sub_100007690((uint64_t)v2, (uint64_t)v235, 0))
            {
              int v272 = 322;
              goto LABEL_242;
            }
            int v344 = 1;
LABEL_227:
            sub_100007230();
            uint64_t v345 = *((void *)v235 + 6);
            if (!v345) {
              uint64_t v345 = *v256;
            }
            if ((*(unsigned char *)(v345 + 56) & 0x20) != 0)
            {
              sub_100020D04(v235);
              __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
              sub_100048ACC(26);
              sub_100046EA8(v24, 219, v352, v353, v354, v355, v356, v357, v492);
              if (sub_10002D2F0((uint64_t)v2, v235, __str, v358, v359, v360, v361, v362)
                || sub_100035168(__str[0].i64[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001578C, (uint64_t)v514, 0, 1))
              {
                uint64_t v271 = v24;
                int v272 = 320;
                goto LABEL_148;
              }
            }
            sub_100048ACC(18);
            sub_100046EA8(v24, 208, v346, v347, v348, v349, v350, v351, v492);
            uint64_t v508 = 0xAAAAAAAAAAAAAAAALL;
            if (sub_10002D238((uint64_t)v2, (uint64_t)v235, &v508)
              || sub_100035168(v508, 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100010988, (uint64_t)v514, 0, 1))
            {
              uint64_t v271 = v24;
              int v272 = 309;
              goto LABEL_148;
            }
            if (sub_100021D5C((uint64_t)v235, 0)) {
              goto LABEL_149;
            }
            if ((*(unsigned char *)(*v256 + 56) & 0x40) != 0)
            {
              __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
              sub_100048ACC(27);
              sub_100046EA8(v24, 220, v375, v376, v377, v378, v379, v380, v492);
              if (sub_10002CFD8((uint64_t)v2, (uint64_t)v235, __str[0].i64, v381, v382, v383, v384, v385)
                || sub_100035168(__str[0].i64[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_100033C4C, (uint64_t)v514, 0, 1)|| sub_100033AFC((uint64_t)v2, (uint64_t)v235, v500, v266, v267, v268, v269, v270))
              {
                uint64_t v271 = v24;
                int v272 = 321;
LABEL_148:
                sub_100046EA8(v271, v272, v265, v266, v267, v268, v269, v270, v492);
LABEL_149:
                sub_10001F70C(1);
                sub_10000B37C();
                sub_1000158D0((uint64_t)v235);
                sub_100007230();
                v235[11] = 1;
                v235[13] = 1;
                goto LABEL_150;
              }
            }
            if (v344)
            {
              sub_100048ACC(31);
              sub_100046EA8(v24, 224, v369, v370, v371, v372, v373, v374, v492);
              if (sub_10001FCEC(v2, (uint64_t)v235, 1))
              {
                uint64_t v271 = v24;
                int v272 = 323;
                goto LABEL_148;
              }
            }
            else
            {
              sub_10001F70C(1);
            }
            sub_100045320((uint64_t)v235);
            sub_100048ACC(21);
            if (v235[9] && sub_10004DF58(*v256, (uint64_t)v514, &v524, v386, v267, v268, v269, v270)
              || !v235[11]
              && sub_10004E248((uint64_t)v2, (uint64_t *)*v256, v519, &v524, v267, v268, v269, v270))
            {
              goto LABEL_147;
            }
            if ((*(unsigned char *)(*v256 + 264) & 4) != 0
              && (__str[0].i64[0] = 0, sub_10003A064((uint64_t)v500, 0, __str), !__str[0].i64[0])
              && (v524
               || v235[12]
               || sub_10004641C(qword_100091B70, "Clear volume inconsistent bit? ", v387, v388, v389, v390, v391, v392, v492)))
            {
              *(void *)(*v256 + 264) &= ~4uLL;
              int v524 = 1;
            }
            else if (!v524 && !v235[12])
            {
              goto LABEL_150;
            }
            int v399 = sub_100045D54(v2, (int8x16_t *)v235);
            if (v399 && v524)
            {
              sub_100046EA8(v24, 307, v393, v394, v395, v396, v397, v398, v492);
              sub_100048B34((char *)0xA7, v399);
              goto LABEL_149;
            }
            sub_100048AE4();
            int v524 = 0;
            v235[12] = 0;
            if (v399) {
              goto LABEL_149;
            }
LABEL_150:
            uint64_t v273 = 0;
            int v274 = v235[11];
            int v275 = v235[13];
            char v276 = 1;
            do
            {
              char v277 = v276;
              uint64_t v278 = *(void *)&v235[8 * v273 + 24];
              if (v278) {
                sub_10001E424(v278);
              }
              char v276 = 0;
              uint64_t v273 = 1;
            }
            while ((v277 & 1) != 0);
            v501 &= v274 == 0;
            if (v275) {
              uint64_t v35 = 8;
            }
            else {
              uint64_t v35 = v35;
            }
            sub_10001E424(*v2);
            __str[0].i64[0] = 0;
            sub_10003A064((uint64_t)v500, 0, __str);
            if (__str[0].i64[0])
            {
              int v279 = 109;
              unsigned int v135 = v2 + 1;
              uint64_t v234 = v499;
            }
            else
            {
              if (v235[13]) {
                int v279 = 108;
              }
              else {
                int v279 = 104;
              }
              uint64_t v234 = v499;
              if (v235[13])
              {
                unsigned int v135 = v2 + 1;
              }
              else
              {
                unsigned int v135 = v2 + 1;
                if (v502 != -1) {
                  goto LABEL_160;
                }
              }
            }
            sub_10004E39C(v24, v279, v235);
LABEL_160:
            sub_100048AD8(*(void *)(qword_100091B78 + 8));
            if (++v234 >= (unint64_t)v528) {
              goto LABEL_283;
            }
          }
          v235[9] = 0;
          sub_100044674("Volume %s is incompletely restored, skipping the fsroot tree.\n", v336, v337, v338, v339, v340, v341, v342, (char)out);
          goto LABEL_226;
        }
LABEL_283:
        sub_100048ACC(22);
        sub_100046EA8(v24, 210, v400, v401, v402, v403, v404, v405, v492);
        if (v501)
        {
          int v417 = sub_10004A7E8((uint64_t)v2, v519, &v524, v406, v407, v408, v409, v410);
          if (!v417 && v524)
          {
            uint64_t v419 = v2[3];
            __str[0] = *v497;
            __str[1].i64[0] = v2[13];
            int v417 = sub_100026BA0(v2, 0, v419, (uint64_t)__str, __str[0], v418);
          }
          if (v417)
          {
            sub_100046EA8(v24, 303, v411, v412, v413, v414, v415, v416, v492);
            uint64_t v482 = 1098;
            int v483 = v417;
            goto LABEL_376;
          }
          if (v524)
          {
            sub_100048AE4();
            int v524 = 0;
          }
        }
        if (v502 == -1)
        {
          if (sub_10001FCEC(v2, 0, 0)) {
            goto LABEL_378;
          }
          if (sub_100022F38(v2, v420, v137, v138, v139, v140, v141, v142))
          {
LABEL_354:
            uint64_t v478 = v24;
            int v479 = 324;
            goto LABEL_379;
          }
        }
        sub_100048ACC(32);
        byte_1000746A0 = (byte_1000746A0 != 0) & v501;
        if (sub_10000B7C0(v2))
        {
          uint64_t v478 = v24;
          int v479 = 325;
          goto LABEL_379;
        }
        sub_100048ACC(22);
        if (sub_100042BCC(v2)) {
          goto LABEL_378;
        }
        if ((v503 & 0x100) != 0)
        {
          if (byte_1000746A0)
          {
            __str[0].i64[0] = 0xAAAAAAAAAAAAAAAALL;
            if (sub_10002CF20((uint64_t)v2, __str[0].i64)
              || sub_100035168(__str[0].i64[0], 0, (uint64_t (*)(void, void, const void *, void, void *, void, uint64_t, int *))sub_10001D734, 0, 0, 0))
            {
LABEL_353:
              uint64_t v478 = v24;
              int v479 = 313;
              goto LABEL_379;
            }
          }
        }
        sub_100048ACC(23);
        uint64_t v506 = 0;
        uint64_t v507 = 0;
        uint64_t v505 = 0;
        __str[0].i64[0] = 0;
        sub_10003A064(v498, 0, __str);
        uint64_t v427 = __str[0].i64[0];
        for (unint64_t i = v529; i < v528; ++i)
        {
          v429 = sub_10001F314((uint64_t)v2, i);
          if (*(void *)(v2[1] + 8 * i + 184))
          {
            __str[0].i64[0] = 0;
            sub_10003A064((uint64_t)(v429 + 704), 0, __str);
            v427 += __str[0].i64[0];
          }
        }
        if (!v427) {
          goto LABEL_318;
        }
        sub_100046EA8(v24, 216, v421, v422, v423, v424, v425, v426, v492);
        int v437 = sub_1000281AC(v498, v2, 0, byte_1000746A0, 0, &v507, &v506, &v505);
        unint64_t v438 = v528;
        for (unint64_t j = v529; j < v438; ++j)
        {
          if (*(void *)(*v504 + 8 * j + 184))
          {
            v440 = sub_10001F314((uint64_t)v2, j);
            int v441 = sub_1000281AC((uint64_t)(v440 + 704), v2, (uint64_t)v440, byte_1000746A0, 0, &v507, &v506, &v505);
            if (!v437) {
              int v437 = v441;
            }
            unint64_t v438 = v528;
          }
        }
        if (v437)
        {
          if (v505) {
            int v490 = 316;
          }
          else {
            int v490 = 317;
          }
          sub_100046EA8(v24, v490, v431, v432, v433, v434, v435, v436, v492);
          uint64_t v35 = 8;
          int v92 = 110;
          goto LABEL_382;
        }
        if (byte_1000746A0) {
          BOOL v442 = 1;
        }
        else {
          BOOL v442 = v507 == 0;
        }
        if (!v442)
        {
          sub_10004458C("Unable to perform deferred repairs without full space verification\n", v430, v431, v432, v433, v434, v435, v436, v492);
          if (*(_DWORD *)(qword_100091B78 + 20) != -1) {
            sub_10004458C("Try running fsck against the entire APFS container instead of a volume\n", v491, v46, v47, v48, v49, v50, v51, v492);
          }
          goto LABEL_380;
        }
        if (v506)
        {
          if (!sub_100048AF8())
          {
            sub_10004458C("Reached max number of fsck passes during repair\n", v450, v451, v452, v453, v454, v455, v456, v492);
            uint64_t v35 = 8;
            char v91 = 1;
            goto LABEL_79;
          }
          sub_10004435C("Restarting after deferred repairs...\n", v450, v451, v452, v453, v454, v455, v456, v492);
          sub_10003FA58();
          sub_10003F70C((uint64_t)v2);
          int v119 = sub_100027B10(v498, 0);
          char v496 = 1;
          if (v119) {
            goto LABEL_94;
          }
        }
        else
        {
LABEL_318:
          sub_100048ACC(24);
          if (!byte_1000746A0 || !sub_10003FDD4()) {
            goto LABEL_365;
          }
          if (*(unsigned char *)(qword_100091B78 + 40))
          {
            sub_10003FE14();
            if (sub_10004641C(qword_100091B70, "Fix overlapped extents? ", v484, v485, v486, v487, v488, v489, v492))
            {
              if (!sub_10003FEE4(v2))
              {
                *(unsigned char *)(qword_100091B78 + 40) = 0;
LABEL_365:
                sub_100048ACC(25);
                goto LABEL_381;
              }
            }
            else
            {
              sub_100048B34((char *)0x1CB, 92);
            }
LABEL_378:
            uint64_t v478 = v24;
            int v479 = 311;
LABEL_379:
            sub_100046EA8(v478, v479, v137, v138, v139, v140, v141, v142, v492);
            goto LABEL_380;
          }
          sub_10004435C("Overlap repair pass...\n", v443, v444, v445, v446, v447, v448, v449, v492);
          *(unsigned char *)(qword_100091B78 + 40) = 1;
          int v119 = sub_100027B10(v498, 0);
          if (v119) {
            goto LABEL_94;
          }
        }
      }
    }
    __int16 v523 = 0;
    nullsub_1(v84);
    sub_10001F444();
    if (v33) {
      free(v33);
    }
    free(v34);
    sub_10002C6C4(v2);
    *(_OWORD *)v526 = 0u;
    long long v527 = 0u;
    *(_OWORD *)v525 = 0u;
    sub_100044FC0(*(const char **)(qword_100091B78 + 8));
    sub_100048AD8(*(void *)(qword_100091B78 + 8));
    sub_100048ACC(2);
    char v522 = 0;
    uint64_t v35 = sub_100045374((uint64_t)v2, (uint64_t)v525, &v522);
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    if (v35) {
      goto LABEL_16;
    }
  }
  uint64_t v88 = v24;
  int v89 = 304;
LABEL_72:
  sub_100046EA8(v88, v89, v53, v54, v55, v56, v57, v58, v492);
  char v91 = 0;
  uint64_t v33 = 0;
LABEL_78:
  uint64_t v35 = 8;
LABEL_79:
  int v92 = 106;
LABEL_80:
  uint64_t v90 = qword_100091B78;
  if (!*(unsigned char *)(qword_100091B78 + 36))
  {
LABEL_328:
    if (v502 == -1)
    {
      if (v35) {
        int v94 = 127;
      }
      else {
        int v94 = 128;
      }
      uint64_t v492 = *(void *)v90;
      uint64_t v93 = v24;
LABEL_340:
      sub_100046EA8(v93, v94, v46, v47, v48, v49, v50, v51, v492);
    }
    else
    {
      if (v91) {
        int v465 = 105;
      }
      else {
        int v465 = 104;
      }
      if (v35) {
        int v466 = v92;
      }
      else {
        int v466 = v465;
      }
      v467 = sub_10001F314((uint64_t)v2, *(_DWORD *)(v90 + 20));
      sub_10004E39C(v24, v466, v467);
    }
    goto LABEL_341;
  }
  if (v35)
  {
    if (v35 == 8) {
      uint64_t v35 = 3;
    }
    else {
      uint64_t v35 = v35;
    }
    uint64_t v93 = v24;
    int v94 = 126;
    goto LABEL_340;
  }
LABEL_86:
  sub_100046EA8(v24, 125, v46, v47, v48, v49, v50, v51, v492);
  uint64_t v35 = 0;
LABEL_341:
  int v468 = sub_100048B1C();
  int v469 = sub_100048B28();
  if (!v35)
  {
    if (*(unsigned char *)(qword_100091B78 + 46) && v468 | v469)
    {
      if (*(unsigned char *)(qword_100091B78 + 36)) {
        uint64_t v35 = 3;
      }
      else {
        uint64_t v35 = 8;
      }
      sub_10004435C("%d failures and %d warnings issued; failing execution as requested.\n",
        v470,
        v471,
        v472,
        v473,
        v474,
        v475,
        v476,
        v469);
    }
    else
    {
      uint64_t v35 = 0;
    }
  }
LABEL_16:
  sub_100044F50();
  sub_10001F444();
  if (v33) {
    free(v33);
  }
  if (v34) {
    free(v34);
  }
  sub_10002C6C4(v2);
  if (v526[1]) {
    free(v526[1]);
  }
  if (v525[1]) {
    free(v525[1]);
  }
  uint64_t v36 = sub_10003FA58();
  if (byte_100091B68) {
    sub_10001E180((uint64_t)v36, v37, v38, v39, v40, v41, v42, v43);
  }
  return v35;
}

uint64_t sub_10004CE78(uint64_t a1, uint64_t *a2)
{
  int v42 = 0;
  sub_10003F70C((uint64_t)a2);
  sub_100048ACC(12);
  sub_100046EA8(a1, 204, v4, v5, v6, v7, v8, v9, v39);
  if (sub_10002CB10(a2, 0, 0)) {
    return 8;
  }
  if (sub_10000EFC4(a2, 0, v10, v11, v12, v13, v14, v15))
  {
    uint64_t v22 = a1;
    int v23 = 305;
    goto LABEL_4;
  }
  unsigned int v43 = -1431655766;
  unsigned int v44 = -1431655766;
  sub_10001F3FC((uint64_t)a2, &v44, (int *)&v43);
  uint64_t v25 = v44;
  if (v44 >= v43) {
    return 0;
  }
  while (1)
  {
    if (!*(void *)(a2[1] + 8 * v25 + 184)) {
      goto LABEL_14;
    }
    uint64_t v26 = sub_10001F314((uint64_t)a2, v25);
    sub_100048AD8(*(void *)v26);
    sub_100048ACC(13);
    sub_100046EA8(a1, 101, v27, v28, v29, v30, v31, v32, *(void *)v26);
    sub_100046EA8(a1, 206, v33, v34, v35, v36, v37, v38, v41);
    if (!*((void *)v26 + 5))
    {
      if (sub_1000257B4(a2, 0, 0, *(void *)(a2[1] + 8 * v25 + 184), 0, 0, 13, 0, (uint64_t **)v26 + 5, (uint64_t)(v26 + 80), 0))break; {
    }
      }
    sub_10004D084(a1);
    if (sub_10004D174((uint64_t)a2, *((void *)v26 + 5), v25, &v42)) {
      break;
    }
    if (v42)
    {
      if (sub_100045D54(a2, (int8x16_t *)v26)) {
        break;
      }
      sub_100048AE4();
      int v42 = 0;
    }
LABEL_14:
    if (++v25 >= (unint64_t)v43) {
      return 0;
    }
  }
  uint64_t v22 = a1;
  int v23 = 307;
LABEL_4:
  sub_100046EA8(v22, v23, v16, v17, v18, v19, v20, v21, v40);
  return 8;
}

uint64_t sub_10004D028(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100038040(a1, a2, 0, 0x40000000, 2, 33, 0, *(_DWORD *)(*(void *)(a2 + 8) + 36), 8, 16, 0, a3, (uint64_t)sub_1000306FC);
}

uint64_t sub_10004D084(uint64_t a1)
{
  *(void *)&long long v2 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v2 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v10[14] = v2;
  v10[15] = v2;
  v10[12] = v2;
  v10[13] = v2;
  v10[10] = v2;
  v10[11] = v2;
  v10[8] = v2;
  v10[9] = v2;
  v10[6] = v2;
  v10[7] = v2;
  _OWORD v10[4] = v2;
  v10[5] = v2;
  v10[2] = v2;
  v10[3] = v2;
  v10[0] = v2;
  v10[1] = v2;
  __strlcpy_chk();
  __strlcpy_chk();
  __strlcpy_chk();
  return sub_100046EA8(a1, 124, v3, v4, v5, v6, v7, v8, (char)v10);
}

uint64_t sub_10004D174(uint64_t a1, uint64_t a2, int a3, _DWORD *a4)
{
  uint64_t v8 = *(void *)(a1 + 8);
  unint64_t v9 = *(void *)(v8 + 96);
  unint64_t v10 = *(void *)(v8 + 40);
  uint64_t v11 = sub_1000104DC();
  if (*(_DWORD *)(a2 + 32) != 1112756289)
  {
    sub_10004458C("apfs superblock at index %u: apfs_magic invalid: %d\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 14;
LABEL_24:
    sub_100048B34((char *)v37, 92);
    return v21;
  }
  unint64_t v19 = v11;
  uint64_t v20 = *(void **)(a1 + 24);
  if (*(_DWORD *)(a2 + 36) != a3)
  {
    sub_10004458C("apfs_fs_index (%d) is not valid (%d)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    sub_100048B34((char *)0xF, 92);
    if (!sub_10004641C(qword_100091B70, "Fix apfs_fs_index(oid 0x%llx, xid 0x%llx)? ", v22, v23, v24, v25, v26, v27, *(void *)(a2 + 8)))return v21; {
    *(_DWORD *)(a2 + 36) = a3;
    }
    *a4 = 1;
  }
  if ((*(void *)(a2 + 40) & 0xFFFFFFFFFFFFFFE0) != 0)
  {
    sub_100044674("apfs superblock at index %u: apfs_features has unrecognized features (0x%llX)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x10, -3);
  }
  if ((*(void *)(a2 + 48) & 0xFFFFFFFFFFFFFFF1) != 0)
  {
    sub_100044674("apfs superblock at index %u: apfs_readonly_compatible_features has unsupported flags: (0x%llX)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v28 = qword_100091B78;
    *(_DWORD *)(qword_100091B78 + 28) = 1;
    *(unsigned char *)(v28 + 37) = 1;
    sub_100046400(qword_100091B70, 1);
    sub_100048B34((char *)0x11, -3);
  }
  uint64_t v29 = *(void *)(a2 + 56);
  if ((v29 & 0xFFFFFFFFFFFFFC00) != 0 || (*(void *)(a2 + 56) & 9) == 9)
  {
    sub_10004458C("apfs superblock at index %u: apfs_incompatible_features has unsupported flags: (0x%llX)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 18;
    goto LABEL_24;
  }
  if ((v29 & 0x200) != 0 && (*(void *)(a2 + 48) & 2) != 0)
  {
    sub_10004458C("apfs superblock at index %u: incompatible features set (apfs_readonly_compatible_features: (0x%llX), apfs_incompatible_features: (0x%llX))\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 1210;
    goto LABEL_24;
  }
  if (*(void *)(a2 + 64) > v19)
  {
    sub_100044674("apfs superblock at index %u: apfs_unmount_time (%llu) is greater than current time (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x13, -4);
  }
  if (v20)
  {
    if (*(void *)(a2 + 88) > *(void *)(*(void *)(a1 + 8) + 40) - (v20[30] + v20[9] + v20[15] + v20[35]))
    {
      sub_100044674("apfs superblock at index %u: apfs_fs_alloc_count (%llu) is greater than container wide allocated count (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      sub_100048B34((char *)0x308, -7);
    }
    unint64_t v30 = *(void *)(a2 + 72);
    if (v30)
    {
      if (v30 <= *(void *)(*(void *)(a1 + 8) + 40))
      {
        if (v30 > v20[23])
        {
          sub_100044674("apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) is greater than spaceman reserve block count (%llu) for a guaranteed-minimum space FS\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
          sub_100048B34((char *)0x14, -7);
          unint64_t v30 = *(void *)(a2 + 72);
        }
      }
      else
      {
        sub_10004458C("apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) is greater than the container block count (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
        uint64_t v21 = 92;
        sub_100048B34((char *)0x448, 92);
        if (!sub_10004641C(qword_100091B70, "Fix apfs_fs_reserve_block_count(oid 0x%llx, xid 0x%llx)? ", v31, v32, v33, v34, v35, v36, *(void *)(a2 + 8)))return v21; {
        unint64_t v30 = 0;
        }
        *(void *)(a2 + 72) = 0;
        *a4 = 1;
      }
      if (v30 >= *(void *)(a2 + 88)) {
        unint64_t v30 = *(void *)(a2 + 88);
      }
      if (v30 > v20[24])
      {
        sub_100044674("apfs superblock at index %u: apfs reserve alloc count (%llu) is greater than spaceman reserve alloc count (%llu) for a guaranteed-minimum space FS\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
        sub_100048B34((char *)0x309, -7);
      }
    }
  }
  unint64_t v39 = *(void *)(a2 + 80);
  if (v39)
  {
    if (*(void *)(a2 + 72) > v39)
    {
      sub_10004458C("apfs superblock at index %u: apfs_fs_reserve_block_count (%llu) must not be greater than apfs_fs_quota_block_count (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 21;
      goto LABEL_24;
    }
    if (v39 > v10)
    {
      sub_100044674("apfs superblock at index %u: apfs_fs_quota_block_count (%llu) should not be greater than nx_block_count (%llu) for an FS with quota\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      sub_100048B34((char *)0x16, -7);
      unint64_t v39 = *(void *)(a2 + 80);
    }
    if (*(void *)(a2 + 88) > v39)
    {
      sub_10004458C("apfs superblock at index %u: apfs_fs_alloc_count (%llu) must not be greater than apfs_fs_quota_block_count (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 23;
      goto LABEL_24;
    }
  }
  int v40 = *(_DWORD *)(a2 + 116);
  if ((unsigned __int16)v40 != 2
    || (unsigned int v41 = v40 & 0xC0000000, (v40 & 0xC0000000) != 0x80000000) && v41 && v41 != 0x40000000)
  {
    sub_10004458C("apfs superblock at index %u: apfs_root_tree_type is invalid: 0x%x\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 24;
    goto LABEL_24;
  }
  int v42 = *(_DWORD *)(a2 + 120);
  if ((unsigned __int16)v42 != 2
    || (unsigned int v43 = v42 & 0xC0000000, (v42 & 0xC0000000) != 0x80000000) && v43 && v43 != 0x40000000)
  {
    sub_10004458C("apfs superblock at index %u: apfs_extentref_tree_type is invalid: 0x%x\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 25;
    goto LABEL_24;
  }
  int v44 = *(_DWORD *)(a2 + 124);
  if ((unsigned __int16)v44 != 2
    || (unsigned int v45 = v44 & 0xC0000000, (v44 & 0xC0000000) != 0x80000000) && v45 && v45 != 0x40000000)
  {
    sub_10004458C("apfs superblock at index %u: apfs_snap_meta_tree_type is invalid: 0x%x\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 26;
    goto LABEL_24;
  }
  if (!*(void *)(a2 + 128))
  {
    sub_10004458C("apfs superblock at index %u: apfs_omap_oid is invalid.\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 27;
    goto LABEL_24;
  }
  if (!*(void *)(a2 + 136))
  {
    sub_10004458C("apfs superblock at index %u: apfs_root_tree_oid is invalid.\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 28;
    goto LABEL_24;
  }
  if ((*(void *)(a2 + 56) & 0x100) != 0)
  {
    if ((*(void *)(a2 + 264) & 1) != 0 && !*(void *)(a2 + 976))
    {
      sub_10004458C("apfs superblock at index %u: apfs_fs_flags (0x%llx) inconsistent with apfs_incompatible_features secondary fsroot bit (0x%llx)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 1160;
      goto LABEL_24;
    }
    if (!*(void *)(a2 + 1096))
    {
      sub_10004458C("apfs superblock at index %u: apfs_sec_root_tree_oid is invalid\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 1161;
      goto LABEL_24;
    }
    if ((unsigned __int16)*(_DWORD *)(a2 + 1104) != 2
      || (unsigned int v54 = *(_DWORD *)(a2 + 1104) & 0xC0000000, v54 != 0x80000000) && v54 && v54 != 0x40000000)
    {
      sub_10004458C("apfs superblock at index %u: apfs_sec_root_tree_type is invalid\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 1162;
      goto LABEL_24;
    }
  }
  else if (*(void *)(a2 + 1096))
  {
    sub_100044674("apfs superblock at index %u: apfs_sec_root_tree_oid (%llu) set on incompatible volume\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x48B, -2);
  }
  if (!*(void *)(a2 + 144))
  {
    sub_10004458C("apfs superblock at index %u: apfs_extentref_tree_oid is invalid.\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 29;
    goto LABEL_24;
  }
  unint64_t v46 = *(void *)(a2 + 160);
  if (v46 >= v9)
  {
    sub_10004458C("apfs superblock at index %u: apfs_revert_to_xid (%llu) should be less than nx_next_xid (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 30;
    goto LABEL_24;
  }
  if (v46 && !*(void *)(a2 + 168))
  {
    sub_10004458C("apfs superblock at index %u: apfs_revert_to_xid is %llu, but sblock oid is invalid\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 31;
    goto LABEL_24;
  }
  if (*(void *)(a2 + 232) > *(void *)(a2 + 224))
  {
    sub_100044674("apfs superblock at index %u: apfs_total_blocks_freed (%llu) should not be greater than apfs_total_blocks_alloced (%llu)\n", v12, v13, v14, v15, v16, v17, v18, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x20, -7);
  }
  if (uuid_is_null((const unsigned __int8 *)(a2 + 240)))
  {
    sub_10004458C("apfs superblock at index %u: apfs_vol_uuid is NULL\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 33;
    goto LABEL_24;
  }
  if (*(void *)(a2 + 256) > v19)
  {
    sub_100044674("apfs superblock at index %u: apfs_last_mod_time (%llu) is greater than current time (%llu)\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x22, -4);
  }
  unint64_t v55 = *(void *)(a2 + 264);
  if (v55 >= 0x1000)
  {
    sub_100044674("apfs superblock at index %u: apfs_fs_flags has an unknown flag set 0x%llx\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x23, -3);
    unint64_t v55 = *(void *)(a2 + 264);
  }
  unint64_t v56 = v55 & 0x109;
  if ((*(unsigned char *)(a2 + 48) & 2) == 0 && (v56 == 256) == ((*(void *)(a2 + 56) & 0x40) == 0))
  {
    sub_10004458C("apfs superblock at index %u: apfs_fs_flags (0x%llx) PFK bit inconsistent with apfs_incompatible_features (0x%llx) PFK bit\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 998;
    goto LABEL_24;
  }
  if ((v56 & (v56 - 1)) != 0)
  {
    sub_10004458C("apfs superblock at index %u: apfs_fs_flags has conflicting encryption flags 0x%llx\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 999;
    goto LABEL_24;
  }
  if ((v55 & 0x80) != 0 && (*(void *)(a2 + 56) & 0x20 | *(void *)(a2 + 1024) || *(void *)(a2 + 1032)))
  {
    sub_10004458C("apfs superblock at index %u: apfs_fs_flags (0x%llx) previously sealed bit inconsistent with apfs_incompatible_features (0x%llx) / apfs_integrity_meta_oid (%llu) / apfs_fext_tree_oid (%llu)\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 951;
    goto LABEL_24;
  }
  if ((v55 & 1) == 0 || *(void *)(a2 + 976))
  {
    if ((*(unsigned char *)(a2 + 56) & 0x20) != 0)
    {
      sub_10004458C("apfs superblock at index %u: apfs_fs_flags (0x%llx) indicates sealed volume is not fully unencrypted\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 917;
      goto LABEL_24;
    }
    sub_10004E458((char *)(a2 + 96), a2, v48, v49, v50, v51, v52, v53);
  }
  if (!*(unsigned char *)(a2 + 704))
  {
    sub_10004458C("apfs superblock at index %u: apfs_volname[0] == 0\n", v47, v48, v49, v50, v51, v52, v53, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 36;
    goto LABEL_24;
  }
  if (strnlen((const char *)(a2 + 272), 0x20uLL) == 32)
  {
    sub_10004458C("apfs superblock at index %u: apfs_formatted_by.id (%.*s) is not NULL terminated.\n", v57, v58, v59, v60, v61, v62, v63, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    sub_100048B34((char *)0x25, 92);
    if (!sub_10004641C(qword_100091B70, "Fix apfs_formatted_by.id(oid 0x%llx, xid 0x%llx)? ", v64, v65, v66, v67, v68, v69, *(void *)(a2 + 8)))return v21; {
    *(unsigned char *)(a2 + 303) = 0;
    }
    *a4 = 1;
  }
  if (*(void *)(a2 + 304) > v19)
  {
    sub_100044674("apfs superblock at index %u: apfs_formatted_by.timestamp (%llu) is greater than current time (%llu)\n", v57, v58, v59, v60, v61, v62, v63, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x26, -4);
  }
  if (*(void *)(a2 + 312) > v9)
  {
    sub_100044674("apfs superblock at index %u: apfs_formatted_by.last_xid (0x%llx) is greater than nx_next_xid (0x%llx)\n", v57, v58, v59, v60, v61, v62, v63, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x27, -2);
  }
  uint64_t v70 = 0;
  uint64_t v71 = a2 + 320;
  do
  {
    unint64_t v72 = *(void *)(v71 + 32);
    if (!v72) {
      break;
    }
    if (strnlen((const char *)v71, 0x20uLL) == 32)
    {
      uint64_t v80 = v71;
      sub_10004458C("apfs superblock at index %u: apfs_modified_by[%d].id (%.*s) is not NULL terminated.\n", v73, v74, v75, v76, v77, v78, v79, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      sub_100048B34((char *)0x28, 92);
      if (!sub_10004641C(qword_100091B70, "Fix apfs_modified_by[%d].id(oid 0x%llx, xid 0x%llx)? ", v81, v82, v83, v84, v85, v86, v70))return v21; {
      uint64_t v71 = v80;
      }
      *(unsigned char *)(v80 + 31) = 0;
      *a4 = 1;
      unint64_t v72 = *(void *)(v80 + 32);
    }
    if (v72 > v19)
    {
      sub_100044674("apfs superblock at index %u: apfs_modified_by[%d].timestamp (%llu) is greater than current time (%llu)\n", v73, v74, v75, v76, v77, v78, v79, *(_DWORD *)(a2 + 36));
      sub_100048B34((char *)0x29, -4);
    }
    if (*(void *)(v71 + 40) > v9)
    {
      sub_100044674("apfs superblock at index %u: apfs_modified_by[%d].last_xid (0x%llx) is greater than nx_next_xid (0x%llx)\n", v73, v74, v75, v76, v77, v78, v79, *(_DWORD *)(a2 + 36));
      sub_100048B34((char *)0x2A, -2);
    }
    ++v70;
    v71 += 48;
  }
  while (v70 != 8);
  if (strnlen((const char *)(a2 + 704), 0x100uLL) == 256)
  {
    sub_10004458C("apfs superblock at index %u: apfs_volname (%.*s) is not NULL terminated.\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    sub_100048B34((char *)0x2B, 92);
    if (!sub_10004641C(qword_100091B70, "Fix apfs_volname(oid 0x%llx, xid 0x%llx)? ", v94, v95, v96, v97, v98, v99, *(void *)(a2 + 8)))return v21; {
    *(unsigned char *)(a2 + 959) = 0;
    }
    *a4 = 1;
  }
  if (*(_DWORD *)(a2 + 960) <= 2u)
  {
    sub_10004458C("apfs superblock at index %u: apfs_next_doc_id (%u) should not be less than MIN_DOC_ID (%d)\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    uint64_t v37 = 44;
    goto LABEL_24;
  }
  if (*(void *)(a2 + 216) && !*(void *)(a2 + 1000)) {
    sub_100044548("apfs_sb: object (oid 0x%llx): apfs_snap_meta_ext_oid invalid\n", v87, v88, v89, v90, v91, v92, v93, *(void *)(a2 + 8));
  }
  uint64_t v100 = *(void *)(a2 + 56);
  if ((v100 & 0x20) != 0)
  {
    if (!*(void *)(a2 + 1032))
    {
      sub_10004458C("apfs superblock at index %u: apfs_fext_tree_oid is invalid.\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 909;
      goto LABEL_24;
    }
    int v116 = *(_DWORD *)(a2 + 1040);
    if ((unsigned __int16)v116 != 2
      || (unsigned int v117 = v116 & 0xC0000000, (v116 & 0xC0000000) != 0x80000000) && v117 && v117 != 0x40000000)
    {
      sub_10004458C("apfs superblock at index %u: apfs_fext_tree_type is invalid: %u\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 910;
      goto LABEL_24;
    }
    if (!*(void *)(a2 + 1024))
    {
      sub_10004458C("apfs superblock at index %u: apfs_integrity_meta_oid is invalid.\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 911;
      goto LABEL_24;
    }
  }
  if ((v100 & 0x40) != 0)
  {
    if (!*(void *)(a2 + 1048))
    {
      sub_10004458C("apfs superblock at index %u: apfs_pfkur_tree_oid is invalid.\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 970;
      goto LABEL_24;
    }
    int v118 = *(_DWORD *)(a2 + 1044);
    if ((unsigned __int16)v118 != 2
      || (unsigned int v119 = v118 & 0xC0000000, (v118 & 0xC0000000) != 0x80000000) && v119 && v119 != 0x40000000)
    {
      sub_10004458C("apfs superblock at index %u: apfs_pfkur_tree_type is invalid: 0x%x\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      uint64_t v21 = 92;
      uint64_t v37 = 971;
      goto LABEL_24;
    }
  }
  if (*(void *)(a2 + 1056) >= *(void *)(*(void *)(a1 + 8) + 96))
  {
    sub_100044674("apfs superblock at index %u: apfs_doc_id_index_xid (%llu) is greater than or equal to container nx_next_xid (%llu)\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x40F, -2);
  }
  unsigned int v101 = *(_DWORD *)(a2 + 1064);
  if (v101 >= 0x20)
  {
    sub_100044674("apfs superblock at index %u: apfs_doc_id_index_flags has unrecognized flags (0x%x)\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x410, -3);
    unsigned int v101 = *(_DWORD *)(a2 + 1064);
  }
  if ((v101 & 1) == 0)
  {
    if (*(void *)(a2 + 1080))
    {
      sub_100044674("apfs superblock at index %u: apfs_prev_doc_id_tree_oid is set (%llu), despite apfs_doc_id_index_flags (0x%x)\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      sub_100048B34((char *)0x411, -3);
    }
    if (*(void *)(a2 + 1088))
    {
      sub_100044674("apfs superblock at index %u: apfs_doc_id_fixup_cursor is set (%llu), despite apfs_doc_id_index_flags (0x%x)\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
      sub_100048B34((char *)0x412, -3);
      if (sub_10004641C(qword_100091B70, "Fix apfs_doc_id_fixup_cursor? ", v102, v103, v104, v105, v106, v107, v120))
      {
        *(void *)(a2 + 1088) = 0;
        *a4 = 1;
      }
    }
  }
  if (*(void *)(a2 + 1088) >= *(void *)(a2 + 176))
  {
    sub_100044674("apfs superblock at index %u: apfs_doc_id_fixup_cursor (%llu) is greater than or equal to apfs_next_obj_id (%llu)\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
    sub_100048B34((char *)0x413, -2);
  }
  if (!*(void *)(a2 + 1072) && !*(void *)(a2 + 1080)) {
    return 0;
  }
  int v108 = *(_DWORD *)(a2 + 1068);
  if ((unsigned __int16)v108 != 2
    || (uint64_t v21 = 0, v109 = v108 & 0xC0000000, (v108 & 0xC0000000) != 0x80000000) && v109 && v109 != 0x40000000)
  {
    sub_10004458C("apfs superblock at index %u: apfs_doc_id_tree_type is invalid: %u\n", v87, v88, v89, v90, v91, v92, v93, *(_DWORD *)(a2 + 36));
    uint64_t v21 = 92;
    sub_100048B34((char *)0x414, 92);
    if (sub_10004641C(qword_100091B70, "Fix apfs_doc_id_tree_type? ", v110, v111, v112, v113, v114, v115, v121))
    {
      uint64_t v21 = 0;
      *(_DWORD *)(a2 + 1068) = 2;
      *a4 = 1;
    }
  }
  return v21;
}

uint64_t sub_10004DF58(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 176) < *(void *)(a2 + 40))
  {
    sub_10004458C("apfs_next_obj_id is not valid (expected %llu, actual %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 40));
    uint64_t v11 = 92;
    sub_100048B34((char *)0x2D, 92);
    if (!sub_10004641C(qword_100091B70, "Fix apfs_next_obj_id(oid 0x%llx, xid 0x%llx)? ", v12, v13, v14, v15, v16, v17, *(void *)(a1 + 8)))return v11; {
    *(void *)(a1 + 176) = *(void *)(a2 + 40);
    }
    *a3 = 1;
  }
  if (*(_DWORD *)(a1 + 960) < *(_DWORD *)(a2 + 48))
  {
    sub_10004458C("apfs_next_doc_id is not valid (expected %u, actual %u)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(_DWORD *)(a2 + 48));
    uint64_t v11 = 92;
    sub_100048B34((char *)0x415, 92);
    if (!sub_10004641C(qword_100091B70, "Fix apfs_next_doc_id(oid 0x%llx, xid 0x%llx)? ", v18, v19, v20, v21, v22, v23, *(void *)(a1 + 8)))return v11; {
    *(_DWORD *)(a1 + 960) = *(_DWORD *)(a2 + 48);
    }
    *a3 = 1;
  }
  if (*(void *)(a1 + 184) != *(void *)a2)
  {
    sub_100044674("apfs_num_files is not valid (expected %llu, actual %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)a2);
    sub_100048B34((char *)0x2E, -8);
    if (sub_10004641C(qword_100091B70, "Fix apfs_num_files(oid 0x%llx, xid 0x%llx)? ", v24, v25, v26, v27, v28, v29, *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 184) = *(void *)a2;
      *a3 = 1;
    }
  }
  if (*(void *)(a1 + 192) != *(void *)(a2 + 8))
  {
    sub_100044674("apfs_num_directories is not valid (expected %llu, actual %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 8));
    sub_100048B34((char *)0x2F, -8);
    if (sub_10004641C(qword_100091B70, "Fix apfs_num_directories(oid 0x%llx, xid 0x%llx)? ", v30, v31, v32, v33, v34, v35, *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 192) = *(void *)(a2 + 8);
      *a3 = 1;
    }
  }
  if (*(void *)(a1 + 200) != *(void *)(a2 + 16))
  {
    sub_100044674("apfs_num_symlinks is not valid (expected %llu, actual %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 16));
    sub_100048B34((char *)0x30, -8);
    if (sub_10004641C(qword_100091B70, "Fix apfs_num_symlinks(oid 0x%llx, xid 0x%llx)? ", v36, v37, v38, v39, v40, v41, *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 200) = *(void *)(a2 + 16);
      *a3 = 1;
    }
  }
  if (*(void *)(a1 + 208) != *(void *)(a2 + 24))
  {
    sub_100044674("apfs_num_other_fsobjects is not valid (expected %llu, actual %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 24));
    sub_100048B34((char *)0x31, -8);
    if (sub_10004641C(qword_100091B70, "Fix apfs_num_other_fsobjects(oid 0x%llx, xid 0x%llx)? ", v42, v43, v44, v45, v46, v47, *(void *)(a1 + 8)))
    {
      *(void *)(a1 + 208) = *(void *)(a2 + 24);
      *a3 = 1;
    }
  }
  if (*(void *)(a1 + 216) == *(void *)(a2 + 32)) {
    return 0;
  }
  sub_100044674("apfs_num_snapshots is not valid (expected %llu, actual %llu)\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, *(void *)(a2 + 32));
  sub_100048B34((char *)0x32, -8);
  if (!sub_10004641C(qword_100091B70, "Fix apfs_num_snapshots(oid 0x%llx, xid 0x%llx)? ", v48, v49, v50, v51, v52, v53, *(void *)(a1 + 8)))return 0; {
  uint64_t v11 = 0;
  }
  *(void *)(a1 + 2--*(_DWORD *)(result + 16) = *(void *)(a2 + 32);
  *a3 = 1;
  return v11;
}

uint64_t sub_10004E248(uint64_t a1, uint64_t *a2, uint64_t *a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11 = a2[9];
  uint64_t v12 = *a3;
  if (v11 > *(void *)(*(void *)(a1 + 8) + 40) - *a3)
  {
    sub_10004458C("apfs_fs_reserve_block_count brings total reserve block count beyond the container block count (max %llu, actual %llu)\n", (uint64_t)a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, *(unsigned char *)(*(void *)(a1 + 8) + 40) - *(unsigned char *)a3);
    uint64_t v13 = 92;
    sub_100048B34((char *)0x449, 92);
    if (!sub_10004641C(qword_100091B70, "Fix apfs_fs_reserve_block_count(oid 0x%llx, xid 0x%llx)? ", v14, v15, v16, v17, v18, v19, a2[1]))return v13; {
    unint64_t v11 = 0;
    }
    a2[9] = 0;
    *a4 = 1;
    uint64_t v12 = *a3;
  }
  *a3 = v12 + v11;
  unint64_t v35 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v13 = sub_100040B64(a2[1], &v35);
  if (!v13)
  {
    unint64_t v27 = a2[11];
    if (v27 != v35)
    {
      sub_100044674("apfs_fs_alloc_count is not valid (expected %llu, actual %llu)\n", v20, v21, v22, v23, v24, v25, v26, v35);
      sub_100048B34((char *)0x367, -8);
      if (sub_10004641C(qword_100091B70, "Fix apfs_fs_alloc_count(oid 0x%llx, xid 0x%llx)? ", v28, v29, v30, v31, v32, v33, a2[1]))
      {
        unint64_t v27 = v35;
        a2[11] = v35;
        *a4 = 1;
      }
      else
      {
        unint64_t v27 = a2[11];
      }
    }
    if (a2[9] < v27) {
      unint64_t v27 = a2[9];
    }
    a3[1] += v27;
  }
  return v13;
}

uint64_t sub_10004E39C(uint64_t a1, int a2, void *a3)
{
  memset(dst, 170, sizeof(dst));
  *(void *)&out[29] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v6 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v6 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)uuid_string_t out = v6;
  *(_OWORD *)&out[16] = v6;
  uint64_t v7 = a3[5];
  if (v7) {
    uuid_copy(dst, (const unsigned __int8 *)(v7 + 240));
  }
  else {
    uuid_clear(dst);
  }
  uuid_unparse(dst, out);
  return sub_100046EA8(a1, a2, v8, v9, v10, v11, v12, v13, *a3);
}

char *sub_10004E458(char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_WORD *)result != 5)
  {
    sub_100044674("apfs object (oid 0x%llx): crypto major version (%u) is not CP_CURRENT (%u)\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(a2 + 8));
    time_t result = sub_100048B34((char *)0xC, -6);
  }
  if (*((_DWORD *)v9 + 1))
  {
    sub_100044674("apfs object (oid 0x%llx): cpflags (%u) should be 0\n", a2, a3, a4, a5, a6, a7, a8, *(void *)(a2 + 8));
    return sub_100048B34((char *)0xD, -3);
  }
  return result;
}

unint64_t sub_10004E4FC(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  unint64_t v5 = a2 + a1;
  unint64_t v6 = a4 + a3;
  if (a2 + a1 > a3)
  {
    BOOL v7 = v6 >= a1;
    BOOL v8 = v6 == a1;
  }
  else
  {
    BOOL v7 = 0;
    BOOL v8 = 0;
  }
  BOOL v9 = !v8 && v7 && v5 >= a1;
  if (!v9 || v6 < a3) {
    return 0;
  }
  if (a1 <= a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = a1;
  }
  if (v5 >= v6) {
    unint64_t v5 = a4 + a3;
  }
  if (a5) {
    *a5 = v11;
  }
  return v5 - v11;
}

uint64_t sub_10004E540(unint64_t a1)
{
  if (a1 > 0x8AC7230489E7FFFFLL) {
    return 19;
  }
  if (a1 > 0xDE0B6B3A763FFFFLL) {
    return 18;
  }
  if (a1 > 0x16345785D89FFFFLL) {
    return 17;
  }
  if (a1 > 0x2386F26FC0FFFFLL) {
    return 16;
  }
  if (a1 > 0x38D7EA4C67FFFLL) {
    return 15;
  }
  if (a1 > 0x5AF3107A3FFFLL) {
    return 14;
  }
  if (a1 > 0x9184E729FFFLL) {
    return 13;
  }
  if (a1 > 0xE8D4A50FFFLL) {
    return 12;
  }
  if (a1 > 0x174876E7FFLL) {
    return 11;
  }
  if (a1 > 0x2540BE3FFLL) {
    return 10;
  }
  if (a1 > 0x3B9AC9FF) {
    return 9;
  }
  if (a1 > 0x5F5E0FF) {
    return 8;
  }
  if (a1 > 0x98967F) {
    return 7;
  }
  if (a1 > 0xF423F) {
    return 6;
  }
  if (a1 >> 5 > 0xC34) {
    return 5;
  }
  if (a1 >> 4 > 0x270) {
    return 4;
  }
  if (a1 > 0x3E7) {
    return 3;
  }
  if (a1 <= 0x63) {
    return a1 > 9;
  }
  return 2;
}

uint64_t sub_10004E710(uint64_t result)
{
  if (result)
  {
    int v1 = result;
    if ((result & 0x3FFF | 0xC000) == result)
    {
      return result & 0x3FFF;
    }
    else if (result >= 0x6B)
    {
      time_t result = 6;
      if (v1 <= -536870175)
      {
        switch(v1)
        {
          case -536870195:
LABEL_14:
            time_t result = 13;
            break;
          case -536870194:
          case -536870192:
          case -536870191:
          case -536870189:
          case -536870188:
          case -536870186:
          case -536870185:
          case -536870184:
          case -536870182:
            return 94;
          case -536870193:
            time_t result = 30;
            break;
          case -536870190:
          case -536870187:
            time_t result = 16;
            break;
          case -536870183:
            return result;
          case -536870181:
            time_t result = 28;
            break;
          default:
            switch(v1)
            {
              case -536870211:
                time_t result = 12;
                break;
              case -536870210:
              case -536870209:
                return 94;
              case -536870208:
                return result;
              case -536870207:
                goto LABEL_14;
              case -536870206:
                time_t result = 22;
                break;
              default:
                if (v1 != -536870198) {
                  return 94;
                }
                time_t result = 5;
                break;
            }
            break;
        }
      }
      else if (v1 != -536870167 && v1 != -536870172)
      {
        if (v1 == -536870174) {
          return 1;
        }
        else {
          return 94;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10004E898(const void *a1, CC_LONG a2)
{
  *(_OWORD *)md = 0u;
  long long v8 = 0u;
  *(void *)&v6.wbuf[14] = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&long long v4 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v4 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v6.wbuf[6] = v4;
  *(_OWORD *)&v6.wbuf[10] = v4;
  *(_OWORD *)&v6.hash[6] = v4;
  *(_OWORD *)&v6.wbuf[2] = v4;
  *(_OWORD *)v6.count = v4;
  *(_OWORD *)&v6.hash[2] = v4;
  CC_SHA256_Init(&v6);
  CC_SHA256_Update(&v6, a1, a2);
  CC_SHA256_Final(md, &v6);
  return *((void *)&v8 + 1) & 0x1FFFFFFFFFFFFFLL;
}

void sub_10004E93C()
{
  __assert_rtn("fsckPrintString", "fsck_messages.c", 733, "(void *)m->msg == (void *)fmt");
}

void sub_10004E968()
{
  __assert_rtn("fsckPrintXML", "fsck_messages.c", 864, "(void *)fmt == (void *)m->msg");
}

void sub_10004E994()
{
  __assert_rtn("fsckPrintGUI", "fsck_messages.c", 972, "(void *)fmt == (void *)m->msg");
}

void sub_10004E9C0()
{
  __assert_rtn("fsckPrint", "fsck_messages.c", 1067, "msg != NULL");
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return _CC_SHA256_Final(md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return _CC_SHA256_Init(c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA256_Update(c, data, len);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFStringRef CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation, CFAllocatorRef contentsDeallocator)
{
  return _CFStringCreateWithBytesNoCopy(alloc, bytes, numBytes, encoding, isExternalRepresentation, contentsDeallocator);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

CFMutableDictionaryRef IOBSDNameMatching(mach_port_t mainPort, uint32_t options, const char *bsdName)
{
  return _IOBSDNameMatching(mainPort, options, bsdName);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallStructMethod(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return _IOObjectConformsTo(object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return _IOObjectRetain(object);
}

IOReturn IOPMAssertionCreateWithName(CFStringRef AssertionType, IOPMAssertionLevel AssertionLevel, CFStringRef AssertionName, IOPMAssertionID *AssertionID)
{
  return _IOPMAssertionCreateWithName(AssertionType, AssertionLevel, AssertionName, AssertionID);
}

IOReturn IOPMAssertionRelease(IOPMAssertionID AssertionID)
{
  return _IOPMAssertionRelease(AssertionID);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperties(entry, properties, allocator, options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

kern_return_t IORegistryEntryCreateIterator(io_registry_entry_t entry, const io_name_t plane, IOOptionBits options, io_iterator_t *iterator)
{
  return _IORegistryEntryCreateIterator(entry, plane, options, iterator);
}

kern_return_t IORegistryEntryGetChildIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return _IORegistryEntryGetChildIterator(entry, plane, iterator);
}

kern_return_t IORegistryEntryGetLocationInPlane(io_registry_entry_t entry, const io_name_t plane, io_name_t location)
{
  return _IORegistryEntryGetLocationInPlane(entry, plane, location);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return _IORegistryEntryGetParentEntry(entry, plane, parent);
}

kern_return_t IORegistryEntryGetParentIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return _IORegistryEntryGetParentIterator(entry, plane, iterator);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntrySearchCFProperty(entry, plane, key, allocator, options);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return _IOServiceClose(connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return _IOServiceOpen(service, owningTask, type, connect);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int *__error(void)
{
  return ___error();
}

double __exp10(double a1)
{
  return ___exp10(a1);
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return ___sprintf_chk(a1, a2, a3, a4);
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

void _exit(int a1)
{
}

uint64_t _get_cpu_capabilities()
{
  return __get_cpu_capabilities();
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

int aio_error(const aiocb *aiocbp)
{
  return _aio_error(aiocbp);
}

int aio_read(aiocb *aiocbp)
{
  return _aio_read(aiocbp);
}

ssize_t aio_return(aiocb *aiocbp)
{
  return _aio_return(aiocbp);
}

int aio_suspend(const aiocb *const aiocblist[], int nent, const timespec *timeoutp)
{
  return _aio_suspend(aiocblist, nent, timeoutp);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

int atexit(void (*a1)(void))
{
  return _atexit(a1);
}

int atoi(const char *a1)
{
  return _atoi(a1);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  return _bsearch(__key, __base, __nel, __width, __compar);
}

void bzero(void *a1, size_t a2)
{
}

uint64_t ccdigest()
{
  return _ccdigest();
}

uint64_t ccsha256_di()
{
  return _ccsha256_di();
}

uint64_t ccsha384_di()
{
  return _ccsha384_di();
}

uint64_t ccsha512_256_di()
{
  return _ccsha512_256_di();
}

uint64_t ccsha512_di()
{
  return _ccsha512_di();
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return _clock_gettime(__clock_id, __tp);
}

int close(int a1)
{
  return _close(a1);
}

char *__cdecl ctime(const time_t *a1)
{
  return _ctime(a1);
}

char *__cdecl devname(dev_t a1, mode_t a2)
{
  return _devname(a1, a2);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return _fdopen(a1, a2);
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

int ffsctl(int a1, unint64_t a2, void *a3, unsigned int a4)
{
  return _ffsctl(a1, a2, a3, a4);
}

char *__cdecl fgetln(FILE *a1, size_t *a2)
{
  return _fgetln(a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

pid_t fork(void)
{
  return _fork();
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return _fputc(a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return _fputs(a1, a2);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return _fstatfs(a1, a2);
}

int fsync(int a1)
{
  return _fsync(a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

int getfsstat(statfs *a1, int a2, int a3)
{
  return _getfsstat(a1, a2, a3);
}

int getopt_long(int a1, char *const *a2, const char *a3, const option *a4, int *a5)
{
  return _getopt_long(a1, a2, a3, a4, a5);
}

int getpagesize(void)
{
  return _getpagesize();
}

passwd *__cdecl getpwuid(uid_t a1)
{
  return _getpwuid(a1);
}

uid_t getuid(void)
{
  return _getuid();
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return _memchr(__s, __c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return _memset_s(__s, __smax, __c, __n);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return _pread(__fd, __buf, __nbyte, a4);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return _pthread_cond_signal(a1);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return _pthread_join(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return _pwrite(__fd, __buf, __nbyte, a4);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

uint64_t random(void)
{
  return _random();
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return _reallocf(__ptr, __size);
}

int setlinebuf(FILE *a1)
{
  return _setlinebuf(a1);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return _sprintf(a1, a2);
}

void srandomdev(void)
{
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return _strndup(__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

void uuid_clear(uuid_t uu)
{
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return _uuid_compare(uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

int uuid_is_null(const uuid_t uu)
{
  return _uuid_is_null(uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return _vfprintf(a1, a2, a3);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}