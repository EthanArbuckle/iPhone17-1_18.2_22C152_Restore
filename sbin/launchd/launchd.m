uint64_t sub_100002E10(uint64_t result)
{
  if (!result) {
    sub_100050CD4();
  }
  return result;
}

uint64_t sub_100002E2C(int a1)
{
  if (!a1) {
    sub_100050CF0();
  }
  return 0;
}

uint64_t sub_100002E4C()
{
  os_map_str_init();

  return os_map_32_init();
}

_DWORD *sub_100002E94(const char *a1, unsigned int a2)
{
  v4 = sub_100013BB8(55 * a2 + 32);
  *(void *)v4 = sub_1000123B8();
  v4[2] = a2;
  *((void *)v4 + 3) = sub_1000159F0(a1);
  v4[5] = 0;
  return v4;
}

void sub_100002EF4(uint64_t a1)
{
  while (*(_DWORD *)(a1 + 16))
    sub_100002F90((_DWORD *)a1);
  *(_DWORD *)(a1 + 20) = 0;
  sub_10001252C(*(void **)a1);
  free(*(void **)(a1 + 24));

  free((void *)a1);
}

void sub_100002F54(_DWORD *a1)
{
  while (a1[4])
    sub_100002F90(a1);
  a1[5] = 0;
}

double sub_100002F90(_DWORD *a1)
{
  if (!a1[4]) {
    sub_100050D0C();
  }
  v2 = (char *)a1 + 55 * a1[3];
  sub_1000124B0();
  *(void *)(v2 + 79) = 0;
  double result = 0.0;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  int v4 = a1[4] - 1;
  a1[3] = (a1[3] + 1) % a1[2];
  a1[4] = v4;
  return result;
}

uint64_t sub_100003000(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_100003008(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_100003010(_DWORD *a1, unsigned int a2)
{
  if (a1[4] < a2) {
    sub_100050D0C();
  }
  return (uint64_t)a1 + 55 * ((a1[3] + a2) % a1[2]) + 32;
}

unint64_t sub_100003050(uint64_t a1, uint64_t a2)
{
  unint64_t result = os_map_32_count();
  if (result > 0x7CF) {
    return result;
  }
  unint64_t result = os_map_str_count();
  if (result)
  {
    if (a2)
    {
LABEL_5:
      if (os_map_32_find()) {
        sub_100040E80("launch_service_stats_record_spawn() must not be called twice with the same pid (%d)", a1);
      }
      return _os_map_32_insert(&unk_100075B48, a1, a2);
    }
LABEL_13:
    sub_100040E80("launch_service_stats_record_spawn() must not be called with a zero timestamp");
  }
  if (dword_100075B60 == 500)
  {
    os_map_32_destroy();
    unint64_t result = os_map_32_init();
    ++dword_100075B60;
    return result;
  }
  if (dword_100075B60 <= 0x1F3)
  {
    ++dword_100075B60;
    if (a2) {
      goto LABEL_5;
    }
    goto LABEL_13;
  }
  return result;
}

uint64_t sub_100003164(uint64_t a1)
{
  return _os_map_32_delete(&unk_100075B48, a1);
}

_DWORD *sub_100003174(_DWORD *result, int a2, const char *a3, int a4, uint64_t a5, uint64_t a6, char a7, uint64_t a8, int a9, int a10, int a11, __int16 a12)
{
  if (a5)
  {
    v18 = result;
    unsigned int v19 = result[4];
    unsigned int v20 = result[2];
    if (v19 == v20)
    {
      v21 = a3;
      sub_100002F90(result);
      a3 = v21;
      unsigned int v19 = v18[4];
      ++v18[5];
      unsigned int v20 = v18[2];
    }
    if (v19 >= v20) {
      sub_100050D0C();
    }
    uint64_t v22 = a6;
    v23 = (char *)v18 + 55 * ((v18[3] + v19) % v20);
    unint64_t result = (_DWORD *)sub_1000123F0(*(void *)v18, a3);
    *((void *)v23 + 4) = result;
    *((void *)v23 + 5) = a5;
    *((_DWORD *)v23 + 14) = a2;
    *((_DWORD *)v23 + 15) = a4;
    *((void *)v23 + 6) = v22;
    v23[64] = a7;
    *(void *)(v23 + 65) = a8;
    *(_DWORD *)(v23 + 73) = a9;
    *(_DWORD *)(v23 + 77) = a10;
    *(_DWORD *)(v23 + 81) = a11;
    *(_WORD *)(v23 + 85) = a12;
    ++v18[4];
  }
  return result;
}

uint64_t sub_100003288(const char *a1, unsigned int a2)
{
  if (os_map_str_find()) {
    return 17;
  }
  sub_100002E94(a1, a2);
  os_map_str_insert();
  return 0;
}

uint64_t sub_1000032EC()
{
  uint64_t v0 = os_map_str_delete();
  if (!v0) {
    return 2;
  }
  sub_100002EF4(v0);
  return 0;
}

uint64_t sub_100003324()
{
  return os_map_str_find();
}

uint64_t sub_100003334()
{
  return os_map_str_foreach();
}

uint64_t sub_1000033A8(uint64_t a1)
{
  return 1;
}

uint64_t sub_1000033D0(char *key)
{
  uint64_t v6 = 0;
  if (qword_100075B68)
  {
    xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100075B68, key);
    if (value)
    {
      v2 = value;
      if (!sub_100003488(value, "SampleRate", &v6)) {
        sub_100043D78(7, "Probabilistic Guard Malloc SampleRate has the wrong format");
      }
      if (!sub_100003488(v2, "ActivationRate", (_DWORD *)&v6 + 1)) {
        sub_100043D78(7, "Probabilistic Guard Malloc ActivationRate has the wrong format");
      }
    }
  }
  if (v6) {
    uint64_t v3 = v6;
  }
  else {
    uint64_t v3 = qword_100075B70;
  }
  if (HIDWORD(v6)) {
    uint64_t v4 = HIDWORD(v6);
  }
  else {
    uint64_t v4 = HIDWORD(qword_100075B70);
  }
  return v3 | (v4 << 32);
}

BOOL sub_100003488(void *a1, const char *a2, _DWORD *a3)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    unint64_t int64 = xpc_dictionary_get_int64(a1, a2);
    BOOL result = HIDWORD(int64) == 0;
    if (int64 >= (unint64_t)&_mh_execute_header) {
      unint64_t int64 = (unint64_t)&_mh_execute_header;
    }
  }
  else
  {
    LODWORD(int64) = 0;
    BOOL result = 0;
  }
  *a3 = int64;
  return result;
}

void sub_100003504()
{
  byte_100075B80 = sub_1000035E0(&qword_100075B78);
  int has_internal_diagnostics = os_variant_has_internal_diagnostics();
  uint64_t v1 = 0x3E800000000;
  if (has_internal_diagnostics) {
    uint64_t v1 = 0xFA00000000;
  }
  qword_100075B70 = v1;
  qword_100075B68 = 0;
  xpc_object_t v2 = sub_10004AC14("ProbGuardPolicy");
  if (v2)
  {
    uint64_t v3 = (uint64_t)v2;
    if (xpc_get_type(v2) == (xpc_type_t)&_xpc_type_dictionary)
    {
      qword_100075B68 = v3;
      qword_100075B70 = sub_1000033D0("GlobalPolicy");
      return;
    }
    uint64_t v4 = "Probabilistic Guard Malloc configuration file plist is not a dictionary";
    int v5 = 5;
  }
  else
  {
    uint64_t v4 = "Probabilistic Guard Malloc config absent";
    int v5 = 7;
  }

  sub_100043D78(v5, v4);
}

BOOL sub_1000035E0(unint64_t *a1)
{
  xpc_object_t v2 = getenv("MallocProbGuard");
  BOOL v3 = sub_100015D70(v2, "1");
  if (v3)
  {
    uint64_t v4 = getenv("MallocProbGuardSampleRate");
    *a1 = 500;
    if (v4) {
      *a1 = strtoul(v4, 0, 10);
    }
  }
  return v3;
}

void sub_10000364C(uint64_t a1)
{
  if (!byte_100075B80)
  {
    uint32_t v2 = *(_DWORD *)(a1 + 1352);
    if (v2)
    {
      if (!arc4random_uniform(v2))
      {
        byte_100075B80 = 1;
        *(void *)(a1 + 1376) |= 0x200000000000000uLL;
        sub_10000522C(a1, "MallocProbGuardViaLaunchd", "1", 1);
        int v8 = *(_DWORD *)(a1 + 924);
        int v9 = *(_DWORD *)(a1 + 928);
        if (v8 >= 1) {
          *(_DWORD *)(a1 + 924) = v8 + 2;
        }
        if (v9 >= 1) {
          *(_DWORD *)(a1 + 928) = v9 + 2;
        }
        int v10 = *(_DWORD *)(a1 + 1348);
        if (v10)
        {
          *(_DWORD *)&__str[7] = 0;
          *(void *)__str = 0;
          snprintf(__str, 0xBuLL, "%u", v10);
          sub_10000522C(a1, "MallocProbGuardSampleRate", __str, 0);
        }
        sub_10001E4BC(a1, 5, "Enabling Probabilistic Guard Malloc", v3, v4, v5, v6, v7, v11);
      }
    }
  }
}

void sub_10000376C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = *(void *)(a1 + 1376);
  if ((v9 & 0x200000000000000) != 0)
  {
    if (!byte_100075B80) {
      sub_100050D0C();
    }
    uint64_t v11 = *(void *)(a1 + 1384);
    byte_100075B80 = 0;
    *(void *)(a1 + 1384) = v11;
    *(void *)(a1 + 1376) = v9 & 0xFDFFFFFFFFFFFFFFLL;
    uint64_t v12 = a1 + 1008;
    uint64_t v13 = a1 + 1008;
    do
      uint64_t v13 = *(void *)v13;
    while (v13 && !sub_100015CAC((const char *)(v13 + 32), "MallocProbGuardViaLaunchd"));
    while (1)
    {
      uint64_t v12 = *(void *)v12;
      if (!v12) {
        break;
      }
      if (sub_100015CAC((const char *)(v12 + 32), "MallocProbGuardSampleRate"))
      {
        if (v13)
        {
          sub_1000051B0(a1, (char *)v13);
          uint64_t v13 = v12;
          goto LABEL_11;
        }
LABEL_19:
        sub_100050D0C();
      }
    }
    if (!v13) {
      goto LABEL_19;
    }
LABEL_11:
    sub_1000051B0(a1, (char *)v13);
    int v19 = *(_DWORD *)(a1 + 924);
    int v20 = *(_DWORD *)(a1 + 928);
    if (v19 >= 3) {
      *(_DWORD *)(a1 + 924) = v19 - 2;
    }
    if (v20 >= 3) {
      *(_DWORD *)(a1 + 928) = v20 - 2;
    }
    sub_10001E4BC(a1, 5, "Probabilistic Guard Malloc-enabled process exited", v14, v15, v16, v17, v18, a9);
  }
}

size_t sub_10000388C(int a1, char *__s)
{
  uint64_t v4 = 0;
  while (dword_100075268[v4] != a1)
  {
    v4 += 6;
    if (v4 == 18) {
      sub_100040E80("unrecognized launch diagnostic thread type: %u", a1);
    }
  }
  uint64_t v5 = &dword_100075268[v4];
  uint64_t v6 = v5 + 1;
  unsigned int v7 = atomic_fetch_add_explicit(v5 + 1, 1u, memory_order_relaxed) + 1;
  unsigned int v8 = v5[4];
  if (v7 > v8)
  {
    sub_100043D78(4, "Exceeded max diagnostic thread count for type %s (%u)", *((const char **)v5 + 1), v8);
    uint64_t v9 = 0;
    atomic_fetch_add_explicit(v6, 0xFFFFFFFF, memory_order_relaxed);
    return (size_t)v9;
  }
  size_t v10 = strlen(__s);
  size_t v11 = v10 + 16;
  BOOL v12 = v10 >= 0xFFFFFFFFFFFFFFF0;
  size_t result = v10 + 17;
  uint64_t v14 = v11 == -1;
  uint64_t v15 = v14 << 63 >> 63;
  BOOL v16 = v15 != v14;
  if (!v12 && !v16 && (v15 & 0x8000000000000000) == 0)
  {
    uint64_t v9 = sub_100013BB8(result);
    *(void *)uint64_t v9 = dispatch_semaphore_create(0);
    v9[2] = a1;
    size_t v17 = strlen(__s);
    memcpy(v9 + 3, __s, v17);
    memset(&v20, 0, sizeof(v20));
    if (pthread_attr_init(&v20)) {
      sub_100050D28();
    }
    if (pthread_attr_setdetachstate(&v20, 2)) {
      sub_100050D28();
    }
    pthread_t v19 = 0;
    int v18 = pthread_create(&v19, &v20, (void *(__cdecl *)(void *))sub_100003AF0, v9);
    if (pthread_attr_destroy(&v20)) {
      sub_100050D28();
    }
    if (v18)
    {
      sub_100003A60((uint64_t)v9);
      return 0;
    }
    return (size_t)v9;
  }
  __break(1u);
  return result;
}

void sub_100003A60(uint64_t a1)
{
  uint64_t v2 = 0;
  while (dword_100075268[v2] != *(_DWORD *)(a1 + 8))
  {
    v2 += 6;
    if (v2 == 18) {
      sub_100040E80("unrecognized launch diagnostic thread type: %u", *(_DWORD *)(a1 + 8));
    }
  }
  dispatch_release(*(dispatch_object_t *)a1);
  free((void *)a1);
  atomic_fetch_add_explicit(&dword_100075268[v2 + 1], 0xFFFFFFFF, memory_order_relaxed);
}

intptr_t sub_100003AE8(dispatch_semaphore_t *a1)
{
  return dispatch_semaphore_signal(*a1);
}

uint64_t sub_100003AF0(dispatch_semaphore_t *a1)
{
  memset(v3, 0, sizeof(v3));
  __strlcpy_chk();
  if (pthread_setname_np((const char *)v3)) {
    sub_100050D28();
  }
  dispatch_semaphore_wait(*a1, 0xFFFFFFFFFFFFFFFFLL);
  sub_100003A60((uint64_t)a1);
  return 0;
}

void sub_100003B8C(uint64_t a1, uint64_t (*a2)(const char *, void **))
{
  if (qword_100075B88) {
    sub_100050D0C();
  }
  if (dword_100075B90) {
    sub_100050D0C();
  }
  dword_100075B90 = 1;
  if (getenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE"))
  {
    sub_100043D78(65541, "not setting boot-mode to hw.osenvironment due to USR to boot-mode");
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v3 = a2("hw.osenvironment", &v5);
    uint64_t v4 = v5;
    if (v3 && v5 && *(unsigned char *)v5)
    {
      sub_100043D78(65541, "boot-mode set by sysctl: %s", (const char *)v5);
      sub_100003C78((const char *)v5);
      dword_100075B90 = 2;
      uint64_t v4 = v5;
    }
    free(v4);
  }
}

void sub_100003C78(const char *a1)
{
  if (!a1) {
    sub_100050D0C();
  }
  if (dword_100075B90 < 2)
  {
    free((void *)qword_100075B88);
    qword_100075B88 = (uint64_t)sub_1000159F0(a1);
  }
  else if (dword_100075B90 == 2)
  {
    if (!qword_100075B88) {
      sub_100050D0C();
    }
    sub_100043D78(65541, "boot-mode forced to (%s) skipping set: %s", (const char *)qword_100075B88, a1);
  }
  else if (dword_100075B90 == 3)
  {
    sub_100040E80("Cannot set boot-mode after it has been committed: (%s, %s)", (const char *)qword_100075B88, a1);
  }
}

char *sub_100003D20(int a1)
{
  if (!a1) {
    sub_100040E80("can't ask for the string for 'none' boot mode!");
  }
  uint64_t v1 = 0;
  while (LODWORD((&off_1000752B0)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 14) {
      sub_100040E80("Unknown boot-mode: %d", a1);
    }
  }
  return (&off_1000752B0)[v1];
}

uint64_t sub_100003D88(char *__s1)
{
  if (!__s1) {
    sub_100040E80("empty boot-mode name given");
  }
  uint64_t v2 = 0;
  while (!sub_100015D70(__s1, (&off_1000752B0)[v2]))
  {
    v2 += 2;
    if (v2 == 14) {
      sub_100040E80("Unknown boot-mode: %s", __s1);
    }
  }
  return LODWORD((&off_1000752B0)[v2 + 1]);
}

void sub_100003E08(int a1)
{
  uint64_t v1 = sub_100003D20(a1);

  sub_100003C78(v1);
}

void sub_100003E30()
{
  if (dword_100075B90 == 3) {
    sub_100050D0C();
  }
  dword_100075B90 = 3;
  sub_100043D78(65541, "boot-mode committed: %s", (const char *)qword_100075B88);
}

uint64_t sub_100003E88()
{
  if (dword_100075B90 != 3) {
    sub_100050D0C();
  }
  return qword_100075B88;
}

BOOL sub_100003EB8()
{
  return dword_100075B90 == 2;
}

uint64_t sub_100003ECC(char *a1)
{
  if (!a1) {
    sub_100050D0C();
  }
  if (dword_100075B90 != 3) {
    sub_100050D0C();
  }
  uint64_t result = qword_100075B88;
  if (qword_100075B88) {
    return strcasecmp((const char *)qword_100075B88, a1) == 0;
  }
  return result;
}

uint64_t sub_100003F18(int a1)
{
  uint64_t v1 = sub_100003D20(a1);

  return sub_100003ECC(v1);
}

double xpc_binprefs_alloc()
{
  uint64_t v0 = sub_100013BB8(0x24uLL);
  double result = 0.0;
  *uint64_t v0 = 0u;
  v0[1] = 0u;
  *((_DWORD *)v0 + 8) = 0;
  return result;
}

double xpc_binprefs_init(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 0;
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void *xpc_binprefs_copy(const void *a1)
{
  return sub_1000159AC(a1, 0x24uLL);
}

uint64_t xpc_binprefs_add(uint64_t result, int a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(result + 32);
  if (v3 >= 4) {
    return _os_assumes_log();
  }
  *(_DWORD *)(result + 4 * v3) = a2;
  *(_DWORD *)(result + 4 * (*(_DWORD *)(result + 32))++ + 16) = a3;
  return result;
}

uint64_t xpc_binprefs_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t xpc_binprefs_cpu_type(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 32) <= a2) {
    sub_100050D0C();
  }
  return *(unsigned int *)(a1 + 4 * a2);
}

uint64_t xpc_binprefs_cpu_subtype(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 32) <= a2) {
    sub_100050D0C();
  }
  return *(unsigned int *)(a1 + 4 * a2 + 16);
}

BOOL xpc_binprefs_equal(uint64_t a1, uint64_t a2)
{
  BOOL result = (a1 | a2) == 0;
  if (a1 && a2)
  {
    int v5 = *(_DWORD *)(a1 + 32);
    if (v5 == *(_DWORD *)(a2 + 32))
    {
      if (!v5) {
        return 1;
      }
      unsigned int v6 = 0;
      while (1)
      {
        int v7 = xpc_binprefs_cpu_type(a1, v6);
        if (v7 != xpc_binprefs_cpu_type(a2, v6)) {
          break;
        }
        int v8 = xpc_binprefs_cpu_subtype(a1, v6);
        if (v8 != xpc_binprefs_cpu_subtype(a2, v6)) {
          break;
        }
        if (++v6 >= *(_DWORD *)(a1 + 32)) {
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}

char *xpc_binprefs_copy_description(uint64_t a1)
{
  if (a1)
  {
    uint64_t v3 = (const char **)sub_100010724(0x80uLL);
    sub_1000107B4((uint64_t)v3, "%d: [", v4, v5, v6, v7, v8, v9, *(_DWORD *)(a1 + 32));
    if (*(_DWORD *)(a1 + 32))
    {
      unsigned int v16 = 0;
      do
      {
        if (v16) {
          sub_1000107B4((uint64_t)v3, ", ", v10, v11, v12, v13, v14, v15, v26);
        }
        char v17 = xpc_binprefs_cpu_type(a1, v16);
        xpc_binprefs_cpu_subtype(a1, v16);
        sub_1000107B4((uint64_t)v3, "%d.%d", v18, v19, v20, v21, v22, v23, v17);
        ++v16;
      }
      while (v16 < *(_DWORD *)(a1 + 32));
    }
    sub_1000107B4((uint64_t)v3, "]", v10, v11, v12, v13, v14, v15, v26);
    v24 = sub_100010770(v3);
    sub_100010778((void **)v3);
    return v24;
  }
  else
  {
    return sub_1000159F0("(null)");
  }
}

uint64_t xpc_binprefs_set_psattr(cpu_type_t *a1, posix_spawnattr_t *a2)
{
  uint64_t result = posix_spawnattr_setarchpref_np(a2, a1[8], a1, a1 + 4, 0);
  if (result) {
    sub_100050D28();
  }
  return result;
}

size_t sub_10000421C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 248);
  uint64_t v124 = 0;
  v125 = 0;
  int v7 = *(_DWORD *)(a1 + 1296);
  BOOL v8 = v7 != 0;
  BOOL v54 = v7 == 0;
  uint64_t v9 = 1;
  if (!v54) {
    uint64_t v9 = 2;
  }
  if ((*(_DWORD *)(a1 + 1340) + 1) >= 2) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = v8;
  }
  uint64_t v11 = *(char **)(a1 + 888);
  if (v11)
  {
    uint64_t v12 = sub_10002E9B8(v6, v11);
    if (v12)
    {
      int v19 = sub_100048818(v12, 1, v13, v14, v15, v16, v17, v18);
      ++v10;
      goto LABEL_11;
    }
    sub_10001E4BC(a1, 3, "Could not find exception endpoint for service: %s", v14, v15, v16, v17, v18, *(void *)(a1 + 888));
  }
  int v19 = 0;
LABEL_11:
  uint64_t v123 = 0;
  sub_1000308B8(v6, &v124, (uint64_t *)&v125, &v123, v10);
  if (*(_DWORD *)(a1 + 1296))
  {
    xpc_array_set_mach_send();
    uint64_t v20 = v123++;
    *((_DWORD *)v125 + v20) = 129;
  }
  if ((*(_DWORD *)(a1 + 1340) + 1) >= 2)
  {
    xpc_array_set_mach_send();
    uint64_t v23 = v123++;
    *((_DWORD *)v125 + v23) = 130;
    if (v19) {
      goto LABEL_15;
    }
  }
  else if (v19)
  {
LABEL_15:
    xpc_array_set_mach_send();
    uint64_t v21 = v123;
    uint64_t v22 = ++v123;
    *((_DWORD *)v125 + v21) = 128;
    goto LABEL_18;
  }
  uint64_t v22 = v123;
LABEL_18:
  size_t v24 = *(void *)(a1 + 592) + 4 * v22;
  for (uint64_t i = qword_100076AD0; i; uint64_t i = *(void *)i)
    v24 += strlen((const char *)(i + 32)) + 1;
  for (uint64_t j = qword_100076AD8; j; uint64_t j = *(void *)j)
    v24 += strlen((const char *)(j + 32)) + 1;
  for (k = *(const char **)(*(void *)(a1 + 248) + 96); k; k = *(const char **)k)
  {
    if (sub_10001E900()) {
      v24 += strlen(k + 32) + 1;
    }
  }
  size_t v120 = v24;
  if ((*(unsigned char *)(a1 + 1322) & 4) != 0)
  {
    if (*(void *)(a1 + 1256))
    {
      v28 = (const char *)sub_10001E034(a1);
      size_t v29 = strlen(v28);
      size_t v24 = strlen(*(const char **)(a1 + 1256)) + v24 - v29;
      size_t v120 = v24;
    }
    v30 = *(void **)(a1 + 1264);
    if (v30)
    {
      uint64_t v31 = *(unsigned int *)(a1 + 428);
      if (v31)
      {
        v32 = *(const char ***)(a1 + 432);
        do
        {
          v33 = *v32++;
          v24 += ~strlen(v33);
          --v31;
        }
        while (v31);
      }
      if (xpc_array_get_count(v30))
      {
        size_t v34 = 0;
        do
        {
          string = xpc_array_get_string(*(xpc_object_t *)(a1 + 1264), v34);
          if (string) {
            v24 += strlen(string) + 1;
          }
          ++v34;
        }
        while (v34 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1264)));
      }
      size_t v120 = v24;
    }
    v36 = *(const char **)(a1 + 1272);
    if (v36)
    {
      v37 = *(const char **)(a1 + 440);
      if (v37) {
        v24 += ~strlen(v37);
      }
      size_t v120 = v24 + strlen(v36) + 1;
    }
    if (*(void *)(a1 + 1280)) {
      xpc_dictionary_apply_f();
    }
    uint64_t v38 = *(void *)(a1 + 1288);
    if (v38)
    {
      if (*(void *)(a1 + 904))
      {
        v120 -= _xpc_spawnattr_binprefs_size(*(void *)(a1 + 904));
        uint64_t v38 = *(void *)(a1 + 1288);
      }
      size_t v24 = v120 + _xpc_spawnattr_binprefs_size(v38);
    }
    else
    {
      size_t v24 = v120;
    }
  }
  for (m = *(void **)(a1 + 680); m; m = (void *)*m)
    v24 += 20;
  v40 = (unsigned int *)sub_100013BB8(v24);
  unsigned int v122 = 0;
  size_t v121 = v24 - 240;
  unsigned int *v40 = v24;
  v40[1] = 0;
  v41 = *(char **)(a1 + 1256);
  if (!v41) {
    v41 = (char *)sub_10001E034(a1);
  }
  _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v41);
  *((unsigned char *)v40 + 230) = 0;
  size_t v42 = *(unsigned int *)(a1 + 624);
  if (v42)
  {
    v40[2] = v122;
    v40[3] = v42;
    _xpc_spawnattr_pack_bytes((uint64_t)v40, &v122, &v121, *(void **)(a1 + 616), v42);
  }
  v43 = *(void **)(a1 + 1264);
  if (v43)
  {
    unsigned int count = xpc_array_get_count(v43);
    v40[4] = count;
    if (count)
    {
      size_t v45 = 0;
      v40[5] = v122;
      do
      {
        v46 = (char *)xpc_array_get_string(*(xpc_object_t *)(a1 + 1264), v45);
        if (v46) {
          _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v46);
        }
        ++v45;
      }
      while (v45 < v40[4]);
    }
  }
  else
  {
    unsigned int v47 = *(_DWORD *)(a1 + 428);
    if (v47)
    {
      unint64_t v48 = 0;
      unsigned int v49 = v122;
      v40[4] = v47;
      v40[5] = v49;
      do
        _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, *(char **)(*(void *)(a1 + 432) + 8 * v48++));
      while (v48 < *(unsigned int *)(a1 + 428));
    }
    else
    {
      v40[4] = 0;
    }
  }
  v50 = *(void **)(*(void *)(a1 + 248) + 96);
  if (v50)
  {
    uint64_t v51 = 0;
    do
    {
      v51 += sub_10001E900();
      v50 = (void *)*v50;
    }
    while (v50);
  }
  else
  {
    uint64_t v51 = 0;
  }
  uint64_t v52 = qword_100076AD0;
  uint64_t v53 = *(void *)(a1 + 1280);
  if (*(_WORD *)(a1 + 1016)) {
    BOOL v54 = 0;
  }
  else {
    BOOL v54 = qword_100076AD8 == 0;
  }
  if (v54 && qword_100076AD0 == 0 && v53 == 0 && v51 == 0)
  {
    v40[7] = 0;
  }
  else
  {
    v40[7] = v122;
    if (v53)
    {
      xpc_dictionary_apply_f();
      uint64_t v52 = qword_100076AD0;
    }
    for (; v52; uint64_t v52 = *(void *)v52)
    {
      _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, (char *)(v52 + 32));
      ++v40[6];
    }
    for (n = *(char **)(a1 + 1008); n; n = *(char **)n)
    {
      _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, n + 32);
      ++v40[6];
    }
    for (iuint64_t i = *(char **)(*(void *)(a1 + 248) + 96); ii; iuint64_t i = *(char **)ii)
    {
      if (sub_10001E900())
      {
        _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, ii + 32);
        ++v40[6];
      }
    }
    for (juint64_t j = qword_100076AD8; jj; juint64_t j = *(void *)jj)
    {
      _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, (char *)(jj + 32));
      ++v40[6];
    }
  }
  uint64_t v61 = *(void *)(a1 + 1288);
  if (v61 || (uint64_t v61 = *(void *)(a1 + 904)) != 0) {
    _xpc_spawnattr_binprefs_pack((uint64_t)v40, v61, &v122, &v121);
  }
  else {
    v40[9] = 0;
  }
  v62 = *(char **)(a1 + 800);
  if (v62)
  {
    v40[10] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v62);
  }
  else
  {
    v40[10] = 0;
  }
  v63 = *(char **)(a1 + 808);
  if (v63)
  {
    v40[11] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v63);
  }
  else
  {
    v40[11] = 0;
  }
  if (*(unsigned char *)(a1 + 1380))
  {
    *((_WORD *)v40 + 26) = *(_WORD *)(a1 + 816);
    int v64 = 0x2000;
  }
  else
  {
    int v64 = 0;
  }
  uint64_t v65 = *(void *)(a1 + 248);
  v40[12] = *(_DWORD *)(v65 + 56);
  v40[59] = v40[59] & 0xFFF7FFFF | ((*(unsigned char *)(v65 + 104) & 1) << 19);
  unsigned int v66 = sub_1000250C8(a1);
  if (v66 != -1)
  {
    v40[59] |= 0x1000000u;
    v40[53] = v66;
  }
  if ((_UNKNOWN *)sub_1000301F4(v6) == &unk_100075750) {
    *((void *)v40 + 7) = sub_1000301FC(*(void *)(a1 + 248));
  }
  v72 = *(char **)(a1 + 1272);
  if (v72 || (v72 = *(char **)(a1 + 440)) != 0)
  {
    v40[16] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v72);
  }
  else
  {
    v40[16] = 0;
  }
  v73 = *(char **)(a1 + 448);
  if (v73)
  {
    v40[17] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v73);
  }
  else
  {
    v40[17] = 0;
  }
  v74 = *(char **)(a1 + 456);
  if (v74)
  {
    v40[18] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v74);
  }
  else
  {
    v40[18] = 0;
  }
  v75 = *(char **)(a1 + 464);
  if (v75)
  {
    v40[19] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v75);
  }
  else
  {
    v40[19] = 0;
  }
  v76 = *(char **)(a1 + 472);
  if (v76)
  {
    v40[20] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v76);
  }
  else
  {
    v40[20] = 0;
  }
  v77 = *(char **)(a1 + 480);
  if (v77)
  {
    v40[21] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v77);
  }
  else
  {
    v40[21] = 0;
  }
  v78 = *(char **)(a1 + 488);
  if (v78)
  {
    v40[22] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v78);
  }
  else
  {
    v40[22] = 0;
  }
  v79 = *(char **)(a1 + 1360);
  if (v79)
  {
    v40[26] = v122;
    _xpc_spawnattr_pack_string((uint64_t)v40, &v122, &v121, v79);
  }
  *((void *)v40 + 14) = *(void *)(a1 + 896);
  *((unsigned char *)v40 + 196) = *(unsigned char *)(a1 + 984);
  unsigned int v80 = *(__int16 *)(a1 + 1320);
  if (!*(_WORD *)(a1 + 1320)) {
    unsigned int v80 = *(_DWORD *)(a1 + 916);
  }
  v40[30] = v80;
  unsigned int v81 = *(_DWORD *)(a1 + 1312);
  if ((v81 & 0x80000000) != 0) {
    unsigned int v81 = *(_DWORD *)(a1 + 920);
  }
  v40[31] = v81;
  unsigned int v82 = *(_DWORD *)(a1 + 1316);
  unsigned int v83 = v82;
  if (!v82)
  {
    unsigned int v82 = *(_DWORD *)(a1 + 924);
    unsigned int v83 = *(_DWORD *)(a1 + 928);
  }
  v40[32] = v82;
  v40[33] = v83;
  unsigned int v84 = *(_DWORD *)(a1 + 932);
  if ((v84 & 0x80000000) == 0) {
    v40[34] = v84;
  }
  *(void *)(v40 + 35) = *(void *)(a1 + 936);
  *(_OWORD *)(v40 + 37) = *(_OWORD *)(a1 + 944);
  *(void *)(v40 + 41) = *(void *)(a1 + 960);
  v40[43] = *(_DWORD *)(a1 + 968);
  sub_10001EAA8(a1, (uint64_t)v40, v67, (uint64_t)v79, v68, v69, v70, v71, v118);
  v40[48] = sub_10001EA18(a1);
  v40[47] = sub_10001E930(a1);
  unint64_t v85 = *(void *)(a1 + 1376);
  unsigned int v86 = (v85 >> 23) & 0x2000000 | v40[59] & 0xF9FFFFFF | (v85 >> 24) & 0x4000000;
  v40[59] = v86;
  unsigned int v87 = *(_DWORD *)(a1 + 1020);
  char v88 = *(unsigned char *)(a1 + 1018);
  if (v87 || *(unsigned char *)(a1 + 1018))
  {
    v86 |= 0x200000u;
    v40[59] = v86;
    v40[56] = v87;
    *((unsigned char *)v40 + 228) = v88;
  }
  v40[50] = *(_DWORD *)(a1 + 912);
  uint64_t v89 = 1;
  v90 = (void *)(a1 + 680);
  do
  {
    v90 = (void *)*v90;
    --v89;
  }
  while (v90);
  if (v89)
  {
    int v91 = -(int)v89;
    unsigned int v92 = v122;
    v40[51] = v91;
    v40[52] = v92;
    v93 = *(uint64_t **)(a1 + 680);
    if (v93)
    {
      size_t v94 = v121;
      do
      {
        int v95 = *((_DWORD *)v93 + 8);
        uint64_t v96 = (uint64_t)v40 + v92 + 240;
        *(_OWORD *)uint64_t v96 = *((_OWORD *)v93 + 1);
        *(_DWORD *)(v96 + 16) = v95;
        v92 += 20;
        v94 -= 20;
        v93 = (uint64_t *)*v93;
      }
      while (v93);
      unsigned int v122 = v92;
      size_t v121 = v94;
    }
    if ((v85 & 0x800) == 0) {
      goto LABEL_158;
    }
  }
  else
  {
    v40[51] = 0;
    v40[52] = 0;
    if ((v85 & 0x800) == 0)
    {
LABEL_158:
      char v97 = *(unsigned char *)(a1 + 1322) & 1;
      goto LABEL_161;
    }
  }
  char v97 = 1;
LABEL_161:
  *((unsigned char *)v40 + 108) = v97;
  uint64_t v98 = v123;
  v40[55] = v123;
  if (v98)
  {
    unsigned int v99 = v122;
    v40[54] = v122;
    v100 = (unsigned int *)v125;
    size_t v101 = v121;
    uint64_t v102 = 4 * v98;
    do
    {
      unsigned int v103 = *v100++;
      *(unsigned int *)((char *)v40 + v99 + 240) = v103;
      v99 += 4;
      unsigned int v122 = v99;
      --v98;
    }
    while (v98);
    size_t v121 = v101 - v102;
  }
  else
  {
    v40[54] = 0;
  }
  int v104 = (8 * v85) & 0x10 | (v85 >> 12) & 3 | (v85 >> 3) & 0x20 | (v85 >> 24) & 0x800000 | v86 & 0xFF7FF200;
  int v105 = *(_DWORD *)(a1 + 1160) == 11;
  unsigned int v106 = (v85 >> 3) & 0xC | (v85 >> 11) & 0x100 | (((*(_DWORD *)(a1 + 368) >> 5) & 1) << 7);
  *((unsigned char *)v40 + 229) = *(unsigned char *)(a1 + 1332);
  v40[59] = (v85 >> 13) & 0x800 | (((v85 >> 9) & 1) << 10) | v106 | v104 | (v105 << 6);
  if (sub_10001E908(a1) && sub_10001E908(a1) != -1) {
    v40[59] |= 0x200u;
  }
  unint64_t v107 = *(void *)(a1 + 1376);
  if ((v107 & 0x2000000) != 0 || (*(unsigned char *)(a1 + 1322) & 0x10) != 0) {
    v40[59] |= 0x20000u;
  }
  if ((v107 & 0x4000000) != 0)
  {
    unsigned int v108 = v40[59];
    goto LABEL_176;
  }
  unsigned int v108 = v40[59];
  if ((*(unsigned char *)(a1 + 1322) & 0x20) != 0) {
LABEL_176:
  }
    v108 |= 0x40000u;
  v40[59] = (v107 >> 11) & 0x400000 | v64 | (v107 >> 40) & 0x8000 | v108 & 0xFFBF5FFF;
  int v109 = sub_10001E1C8(a1);
  if ((v107 & 0x20000000000000) != 0)
  {
    if (v109) {
      sub_10001E4BC(a1, 3, "Conflicting request: resliding disabled, but requesting a shared cache reslide. No reslide will be performed.", v110, v111, v112, v113, v114, v119);
    }
    unsigned int v116 = v40[59] & 0xF7FFFFFF;
  }
  else
  {
    if (v109) {
      int v115 = 0x8000000;
    }
    else {
      int v115 = 0;
    }
    unsigned int v116 = v40[59] & 0xF7FFFFFF | v115;
  }
  v40[59] = (*(void *)(a1 + 1376) >> 18) & 0x10000 | (*(void *)(a1 + 1376) >> 20) & 0x100000 | v116 & 0xFFEEFFFF;
  if ((_UNKNOWN *)sub_1000301F4(*(void *)(a1 + 248)) == &unk_1000755B8) {
    v40[59] |= 0x10000000u;
  }
  if (v121 || v122 + 240 != v24) {
    sub_100040E80("failed to marshall spawnattrs: offset = %u, left = %lu, expected = %lu", v122, v121, *(void *)(a1 + 592));
  }
  free(v125);
  *a3 = v40;
  *a2 = v124;
  return v24;
}

void *sub_100004DA0(char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = (_DWORD *)a3[1];
  int v7 = (void *)a3[2];
  uint64_t result = xpc_get_type(object);
  if (result == &_xpc_type_string)
  {
    _xpc_spawnattr_pack_string_fragment(v5, v6, v7, a1);
    _xpc_spawnattr_pack_string_fragment(v5, v6, v7, "=");
    string_ptr = (char *)xpc_string_get_string_ptr(object);
    uint64_t result = (void *)_xpc_spawnattr_pack_string(v5, v6, v7, string_ptr);
    ++*(_DWORD *)(v5 + 24);
  }
  return result;
}

char *sub_100004E48(const char *a1, xpc_object_t object, void *a3)
{
  uint64_t result = (char *)xpc_get_type(object);
  if (result == (char *)&_xpc_type_string)
  {
    size_t v7 = strlen(a1);
    uint64_t result = (char *)xpc_string_get_length(object);
    *a3 += &result[v7 + 2];
  }
  return result;
}

void sub_100004EB8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 424)) {
    sub_100040E80("deallocation of active service");
  }
  if (*(void *)(a1 + 24) != -1 || *(void *)(a1 + 32) != -1) {
    sub_100040E80("service disposal while still in list");
  }
  if (*(void *)(a1 + 40) != -1 || *(void *)(a1 + 48) != -1) {
    sub_100040E80("service disposal while in parent instance list");
  }
  if (*(void *)(a1 + 512)) {
    sub_100040E80("Service: %s has leaked pended requests", (const char *)(a1 + 1392));
  }
  if (*(void *)(a1 + 872)) {
    sub_100050D0C();
  }
  if (*(void *)(a1 + 136)) {
    sub_100050D0C();
  }
  if (*(void *)(a1 + 144)) {
    sub_100050D0C();
  }
  if ((*(unsigned char *)(a1 + 1383) & 2) != 0) {
    sub_100050D0C();
  }
  uint64_t v2 = *(void **)(a1 + 576);
  if (v2 != (void *)(a1 + 1392)) {
    free(v2);
  }
  free(*(void **)(a1 + 584));
  sub_10001A174(*(void **)(a1 + 16));
  free(*(void **)(a1 + 600));
  free(*(void **)(a1 + 432));
  free(*(void **)(a1 + 440));
  free(*(void **)(a1 + 888));
  free(*(void **)(a1 + 616));
  free(*(void **)(a1 + 472));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 488));
  free(*(void **)(a1 + 448));
  free(*(void **)(a1 + 456));
  free(*(void **)(a1 + 464));
  free(*(void **)(a1 + 800));
  free(*(void **)(a1 + 808));
  free(*(void **)(a1 + 904));
  free(*(void **)(a1 + 1360));
  free(*(void **)(a1 + 1368));
  free(*(void **)(a1 + 304));
  uint64_t v3 = *(void **)(a1 + 976);
  if (v3) {
    j__free(v3);
  }
  uint64_t v4 = *(void **)(a1 + 632);
  if (v4) {
    xpc_release(v4);
  }
  uint64_t v5 = *(void **)(a1 + 640);
  if (v5) {
    xpc_release(v5);
  }
  uint64_t v6 = *(void **)(a1 + 648);
  if (v6) {
    xpc_release(v6);
  }
  size_t v7 = *(void **)(a1 + 656);
  if (v7) {
    xpc_release(v7);
  }
  BOOL v8 = *(void **)(a1 + 664);
  if (v8) {
    xpc_release(v8);
  }
  uint64_t v9 = *(void **)(a1 + 496);
  if (v9) {
    xpc_release(v9);
  }
  uint64_t v10 = *(void **)(a1 + 504);
  if (v10) {
    xpc_release(v10);
  }
  if (*(void *)(a1 + 712)) {
    sub_100005170(a1);
  }
  while (1)
  {
    uint64_t v11 = *(char **)(a1 + 1008);
    if (!v11) {
      break;
    }
    sub_1000051B0(a1, v11);
  }
  while (1)
  {
    uint64_t v13 = *(uint64_t **)(a1 + 672);
    if (!v13) {
      break;
    }
    uint64_t v12 = *v13;
    if (*v13) {
      *(void *)(v12 + 8) = v13[1];
    }
    *(void *)v13[1] = v12;
    free(v13);
  }
  while (1)
  {
    uint64_t v15 = *(uint64_t **)(a1 + 680);
    if (!v15) {
      break;
    }
    uint64_t v14 = *v15;
    if (*v15) {
      *(void *)(v14 + 8) = v15[1];
    }
    *(void *)v15[1] = v14;
    free(v15);
  }
  uint64_t v16 = *(void **)(a1 + 1056);
  if (v16) {
    xpc_release(v16);
  }
  uint64_t v17 = *(void **)(a1 + 1064);
  if (v17) {
    xpc_release(v17);
  }
  mach_port_name_t v18 = *(_DWORD *)(a1 + 1340);
  if (v18 + 1 >= 2 && mach_port_mod_refs(mach_task_self_, v18, 0, -1)) {
    sub_100050D28();
  }

  sub_10003EC6C(a1);
}

void sub_100005170(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 712);
  if (!v2) {
    sub_100050D0C();
  }
  dispatch_set_context(v2, v2);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 712));
  *(void *)(a1 + 712) = 0;
}

void sub_1000051B0(uint64_t a1, char *a2)
{
  --*(_WORD *)(a1 + 1016);
  *(void *)(a1 + 592) += ~strlen(a2 + 32);
  uint64_t v3 = *(void *)a2;
  if (*(void *)a2) {
    *(void *)(v3 + 8) = *((void *)a2 + 1);
  }
  **((void **)a2 + 1) = v3;
  *(void *)a2 = -1;
  *((void *)a2 + 1) = -1;

  j__free(a2);
}

void sub_10000522C(uint64_t a1, char *__s, const char *a3, char a4)
{
  size_t v7 = 0;
  uint64_t v5 = sub_10001A1EC(__s, a3, 0, &v7, a4);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 1008);
    *(void *)uint64_t v5 = v6;
    if (v6) {
      *(void *)(v6 + 8) = v5;
    }
    *(void *)(a1 + 1008) = v5;
    ++*(_WORD *)(a1 + 1016);
    *(void *)(a1 + 592) += v7;
    *((void *)v5 + 1) = a1 + 1008;
    *((void *)v5 + 2) = a1;
  }
}

uint64_t sub_1000052DC(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 0:
      unint64_t v4 = *(void *)(a1 + 1376);
      if ((v4 & 0x40400000000) != 0)
      {
        if (sub_10000FE40(a1 + 376, 30)) {
          goto LABEL_17;
        }
        unint64_t v4 = *(void *)(a1 + 1376);
      }
      uint64_t v2 = (v4 >> 44) & 1;
      return v2 & 1;
    case 1:
    case 2:
    case 3:
    case 5:
      LODWORD(v2) = (*(unsigned __int8 *)(a1 + 1381) >> 4) & 1;
      return v2 & 1;
    case 4:
      LOBYTE(v2) = (*(unsigned char *)(a1 + 1381) & 1) == 0;
      return v2 & 1;
    case 6:
      LOBYTE(v2) = *(unsigned char *)(a1 + 1381) & 1;
      return v2 & 1;
    case 7:
      uint64_t v5 = *(unsigned __int8 *)(a1 + 984);
      if (!*(unsigned char *)(a1 + 984)) {
        goto LABEL_17;
      }
      if (v5 == 2) {
        goto LABEL_14;
      }
      xpc_object_t v6 = sub_100043720(a1 + 376);
      if (!v6) {
        goto LABEL_14;
      }
      size_t v7 = v6;
      if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
      {
        xpc_object_t array = xpc_dictionary_get_array(v7, "com.apple.private.xpc.allowed-launch-types");
        if (xpc_array_get_count(array))
        {
          size_t v11 = 0;
          do
          {
            int64_t int64 = xpc_array_get_int64(array, v11);
            LOBYTE(v2) = int64 == v5;
            if (int64 == v5) {
              break;
            }
            ++v11;
          }
          while (v11 < xpc_array_get_count(array));
        }
        else
        {
          LOBYTE(v2) = 0;
        }
        xpc_release(v7);
      }
      else
      {
        xpc_release(v7);
LABEL_14:
        LOBYTE(v2) = 0;
      }
      break;
    case 8:
      unint64_t v8 = *(void *)(a1 + 1376);
      if ((v8 & 0x40400000000) == 0) {
        goto LABEL_19;
      }
      if (sub_10000FE40(a1 + 376, 31))
      {
LABEL_17:
        LOBYTE(v2) = 1;
      }
      else
      {
        unint64_t v8 = *(void *)(a1 + 1376);
LABEL_19:
        uint64_t v2 = (v8 >> 44) & 1;
      }
      break;
    default:
      return v2 & 1;
  }
  return v2 & 1;
}

void sub_10000548C(uint64_t a1, char *a2)
{
  if (!strcasecmp(a2, "Interactive"))
  {
    int v10 = 1024;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "Adaptive"))
  {
    int v10 = 1536;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "Standard"))
  {
    int v10 = 768;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "Background"))
  {
    int v10 = 1280;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "SystemApp"))
  {
    *(_DWORD *)(a1 + 896) = 256;
    uint64_t v9 = *(void *)(a1 + 1376) | 0x3000;
    goto LABEL_17;
  }
  if (!strcasecmp(a2, "App"))
  {
    *(_DWORD *)(a1 + 896) = 256;
    uint64_t v9 = *(void *)(a1 + 1376) | 0x1000;
    goto LABEL_17;
  }
  if (strcasecmp(a2, "_AdaptiveUtility"))
  {
    if (strcasecmp(a2, "Driver"))
    {
      sub_10001E4BC(a1, 4, "Unknown ProcessType: %s", v4, v5, v6, v7, v8, (char)a2);
      uint64_t v9 = *(void *)(a1 + 1376) | 1;
LABEL_17:
      *(void *)(a1 + 1376) = v9;
      return;
    }
    int v10 = 1792;
LABEL_14:
    *(_DWORD *)(a1 + 896) = v10;
    return;
  }
  *(_DWORD *)(a1 + 896) = 1536;
  *(_DWORD *)(a1 + 912) = 17;
}

uint64_t sub_1000055E4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  if ((*(unsigned char *)(a1 + 1380) & 0x40) == 0) {
    return 0;
  }
  uint64_t v3 = sub_100014BAC(*(void *)(a1 + 248), (const char *)(a1 + 1392));
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void, unsigned char *, void))(a1 + 544))(a1, a1 + 1392, &_xpc_BOOL_true, 0, v3, *(void *)(a1 + 568));
  if (!v2)
  {
    *(void *)(a1 + 1376) |= 1uLL;
    sub_100014CD8(v3, 3, "Failed to create the implicit endpoint");
  }
  sub_100014C90((uint64_t)v3);
  *(void *)(a1 + 1376) &= ~0x4000000000uLL;
  return v2;
}

uint64_t sub_1000056B8(_DWORD *a1, xpc_object_t object, char *a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10002A5B8((uint64_t)a1, 3, "Root node of launchd.plist is not a dictionary.", v14, v15, v16, v17, v18, v87);
LABEL_3:
    uint64_t v19 = 0;
    int v20 = 109;
LABEL_16:
    *a7 = v20;
    return v19;
  }
  string = xpc_dictionary_get_string(object, "Label");
  if (!string)
  {
    uint64_t v31 = "Service plist does not specify a label.";
LABEL_15:
    sub_10002A5B8((uint64_t)a1, 3, v31, v22, v23, v24, v25, v26, v87);
    uint64_t v19 = 0;
    int v20 = 110;
    goto LABEL_16;
  }
  v27 = string;
  size_t v28 = strlen(string);
  if (!v28)
  {
    uint64_t v31 = "Service plist has an empty label.";
    goto LABEL_15;
  }
  size_t v29 = v28;
  __s1 = a3;
  uint64_t v90 = a4;
  uint64_t v88 = a5;
  uint64_t v30 = 0;
  uint64_t v31 = "Service plist has an empty label.";
  while (1)
  {
    __darwin_ct_rune_t v32 = v27[v30];
    if (v32 < 0) {
      break;
    }
    if ((_DefaultRuneLocale.__runetype[v32] & 0x4000) == 0) {
      goto LABEL_18;
    }
LABEL_11:
    if (v29 == ++v30) {
      goto LABEL_15;
    }
  }
  if (__maskrune(v32, 0x4000uLL)) {
    goto LABEL_11;
  }
LABEL_18:
  size_t v34 = sub_100007498(object, (uint64_t)a1, v27);
  if (!v34) {
    goto LABEL_3;
  }
  v35 = v34;
  v36 = sub_100014BAC((uint64_t)a1, v27);
  v37 = xpc_dictionary_get_string(v35, "Label");
  if (!v37)
  {
    sub_100014CD8(v36, 3, "Service plist does not specify a label.");
    uint64_t v19 = 0;
    int v43 = 110;
    goto LABEL_52;
  }
  uint64_t v38 = (char *)v37;
  BOOL v39 = xpc_dictionary_get_BOOL(v35, "Disabled");
  BOOL v40 = xpc_dictionary_get_BOOL(v35, "ForceEnableHack");
  xpc_object_t v41 = sub_100030404((uint64_t)a1, v38);
  xpc_object_t value = xpc_dictionary_get_value(v35, "_Conclave");
  if ((a6 & 0x800) == 0 && value)
  {
    sub_100014CD8(v36, 3, "Only LaunchDaemons are allowed to use the _Conclave key");
    uint64_t v19 = 0;
    int v43 = 109;
    goto LABEL_52;
  }
  if (v41) {
    BOOL v44 = v41 == &_xpc_BOOL_true;
  }
  else {
    BOOL v44 = v39;
  }
  if ((a6 & 0x20) == 0 && v44 && !((a6 >> 1) & 1 | v40))
  {
    uint64_t v19 = 0;
    int v43 = 119;
    goto LABEL_52;
  }
  if ((a6 >> 1) & 1 | v40) {
    sub_10002E3A4((uint64_t)a1, v38, 2);
  }
  xpc_object_t v45 = xpc_dictionary_get_value(v35, "LimitLoadToSessionType");
  if (!v45)
  {
    string_ptr = 0;
    goto LABEL_43;
  }
  v46 = v45;
  if (xpc_get_type(v45) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = (char *)xpc_string_get_string_ptr(v46);
LABEL_43:
    if (sub_100030248((uint64_t)a1, string_ptr)) {
      goto LABEL_44;
    }
    goto LABEL_51;
  }
  if (xpc_get_type(v46) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(v46))
  {
LABEL_51:
    uint64_t v19 = 0;
    int v43 = 134;
    goto LABEL_52;
  }
  size_t v47 = 0;
  while (1)
  {
    unint64_t v48 = (char *)xpc_array_get_string(v46, v47);
    if (sub_100030248((uint64_t)a1, v48)) {
      break;
    }
    if (++v47 >= xpc_array_get_count(v46)) {
      goto LABEL_51;
    }
  }
LABEL_44:
  xpc_object_t v50 = xpc_dictionary_get_value(v35, "LimitLoadToHardware");
  if (v50 && (uint64_t v51 = v50, xpc_get_type(v50) == (xpc_type_t)&_xpc_type_dictionary) && (sub_100008B04(v51) & 1) == 0
    || (xpc_object_t v52 = xpc_dictionary_get_value(v35, "LimitLoadFromHardware")) != 0
    && (uint64_t v53 = v52, xpc_get_type(v52) == (xpc_type_t)&_xpc_type_dictionary)
    && sub_100008B04(v53))
  {
LABEL_50:
    uint64_t v19 = 0;
    int v43 = 138;
    goto LABEL_52;
  }
  xpc_object_t v54 = xpc_dictionary_get_value(v35, "_LimitLoadToVariant");
  if (v54 && (sub_100008BA8(v54) & 1) == 0
    || (xpc_object_t v55 = xpc_dictionary_get_value(v35, "_LimitLoadFromVariant")) != 0 && sub_100008BA8(v55))
  {
    uint64_t v19 = 0;
    int v43 = 158;
    goto LABEL_52;
  }
  xpc_object_t v56 = xpc_dictionary_get_value(v35, "_PersistToBootMode");
  if (v56)
  {
    if ((a6 & 0x200) == 0)
    {
      sub_100014CD8(v36, 3, "Service specifies _PersistToBootMode which is not permitted for services that were not dynamically submitted");
      goto LABEL_94;
    }
    if ((a6 & 0x40000) == 0 && (sub_10000FE40(v90, 36) & 1) == 0)
    {
      sub_100014CD8(v36, 3, "Unentitled submitter specifies _PersistToBootMode in service, which is not permitted");
LABEL_94:
      uint64_t v19 = 0;
      int v43 = 137;
LABEL_52:
      *a7 = v43;
      goto LABEL_53;
    }
  }
  xpc_object_t v57 = xpc_dictionary_get_value(v35, "_LimitLoadToBootMode");
  if (!v57)
  {
    int v59 = 0;
    goto LABEL_72;
  }
  int v58 = sub_100008C90(v57);
  if ((a6 & 0x40000) != 0) {
    int v59 = 0;
  }
  else {
    int v59 = v58 ^ 1;
  }
  if (!v56 && (v58 & 1) == 0)
  {
LABEL_103:
    uint64_t v19 = 0;
    int v43 = 152;
    goto LABEL_52;
  }
LABEL_72:
  xpc_object_t v60 = xpc_dictionary_get_value(v35, "_LimitLoadFromBootMode");
  if (v60)
  {
    int v61 = sub_100008C90(v60);
    if (v61) {
      int v59 = (a6 & 0x40000) == 0;
    }
    if (!v56 && v61) {
      goto LABEL_103;
    }
  }
  if (xpc_dictionary_get_BOOL(v35, "_LimitLoadToClarityMode") && (sub_100008D6C() & 1) == 0) {
    goto LABEL_103;
  }
  if (xpc_dictionary_get_BOOL(v35, "_LimitLoadFromClarityMode") && sub_100008D6C()) {
    goto LABEL_103;
  }
  BOOL v62 = xpc_dictionary_get_BOOL(v35, "LimitLoadToDeveloperMode");
  if (((a6 & 0x4000) != 0 || v62) && (int)sub_1000106F0("security.mac.amfi.developer_mode_status") <= 0) {
    goto LABEL_103;
  }
  xpc_object_t v63 = xpc_dictionary_get_value(v35, "_LimitLoadToDeviceTree");
  if (v63 && (sub_100008DB8(v63, v36) & 1) == 0) {
    goto LABEL_50;
  }
  xpc_object_t v64 = xpc_dictionary_get_value(v35, "_LimitLoadFromDeviceTree");
  if (v64)
  {
    if (sub_100008DB8(v64, v36)) {
      goto LABEL_50;
    }
  }
  xpc_object_t v65 = xpc_dictionary_get_value(v35, "_LimitLoadToBootarg");
  if (v65 && (sub_100008EE4(v65, v36) & 1) == 0
    || (xpc_object_t v66 = xpc_dictionary_get_value(v35, "_LimitLoadFromBootarg")) != 0 && sub_100008EE4(v66, v36))
  {
    uint64_t v19 = 0;
    int v43 = 160;
    goto LABEL_52;
  }
  if (byte_1000769F0 && !xpc_dictionary_get_BOOL(v35, "MinimalBootProfile")) {
    goto LABEL_103;
  }
  uint64_t v67 = sub_10002E140(a1, v38);
  if (v67)
  {
    uint64_t v68 = (const char *)sub_10001E040((uint64_t)v67);
    if (!strcmp(__s1, v68))
    {
      int v43 = 37;
    }
    else
    {
      if (*v68 == 47 && *__s1 == 47) {
        sub_10002A5B8((uint64_t)a1, 4, "Attempt to re-bootstrap service from different path, will use existing: service = %s, existing = %s, conflicting = %s", v69, v70, v71, v72, v73, (char)v38);
      }
      int v43 = 17;
    }
    uint64_t v19 = 0;
    goto LABEL_52;
  }
  v74 = sub_100009010(v35, __s1, v90, a6, v88, a7, v36);
  uint64_t v19 = (uint64_t)v74;
  if (v74)
  {
    *((void *)v74 + 173) = *((void *)v74 + 173) & 0xFFFFFFFFFFFFFFFELL | (v59 != 0);
    if (v59) {
      sub_10002A5B8((uint64_t)a1, 5, "Retaining, but not starting, service %s", v75, v76, v77, v78, v79, (char)v38);
    }
    int v80 = sub_1000067D4(v19, (uint64_t)a1, v36);
    *a7 = v80;
    if (v80)
    {
      sub_10001A174((void *)v19);
      uint64_t v19 = 0;
    }
    else
    {
      sub_100009730(v19, (uint64_t)a1, v81, v82, v83, v84, v85, v86);
      if (*(_DWORD *)(v19 + 896) == 768 && !byte_100076A83) {
        *(_DWORD *)(v19 + 912) = 17;
      }
      if (byte_100076A47)
      {
        *(void *)(v19 + 924) = -1;
        *(_DWORD *)(v19 + 916) &= 0xFFFFFFF3;
      }
    }
  }
LABEL_53:
  sub_100014C90((uint64_t)v36);
  xpc_release(v35);
  return v19;
}

BOOL sub_100005DD8(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 1377) & 0x40) != 0 || *(unsigned char *)(a1 + 1344) != 0;
}

char *sub_100005DF8(uint64_t a1, unsigned __int8 *uu, uint64_t a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, int *a8)
{
  uint64_t v9 = *(void *)(a1 + 1376);
  if ((v9 & 0x20000) != 0
    || *(void *)(*(void *)(a1 + 248) + 72) == a1
    || (v9 & 0x20000000) != 0
    || (~v9 & 0x40000001000) == 0
    || (v9 & 0x80) != 0
    || *(void *)(a1 + 144))
  {
    size_t v11 = 0;
    int v12 = 136;
LABEL_8:
    *a8 = v12;
    return v11;
  }
  if ((v9 & 0x4000) == 0 && !*(unsigned char *)(a1 + 1344) || (v9 & 0x8000) != 0 || (*(unsigned char *)(a1 + 368) & 0x20) != 0) {
    goto LABEL_28;
  }
  if ((v9 & 0x4000000000) != 0) {
    sub_100040E80("multiple-instance service has no initialized endpoints");
  }
  mach_port_name_t v20 = *(_DWORD *)(a1 + 1340);
  if (v20 + 1 >= 2)
  {
    if (sub_10000D65C(v20))
    {
LABEL_28:
      size_t v11 = 0;
      int v12 = 137;
      goto LABEL_8;
    }
  }
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)__str = 0u;
  long long v26 = 0u;
  snprintf(__str, 0x100uLL, "%s.%s", (const char *)(a1 + 1392), out);
  uint64_t v21 = sub_100014BAC(*(void *)(a1 + 248), __str);
  uint64_t v22 = sub_100006038(a1, uu, __str, a3, a5, a6, a7, v21, a8);
  size_t v11 = v22;
  if (a4)
  {
    if (*(void *)a4) {
      sub_1000066F8((uint64_t)v22, *(const void **)a4);
    }
    uint64_t v23 = *(const char **)(a4 + 8);
    if (v23) {
      sub_10000675C((uint64_t)v11, v23);
    }
    if (*(void *)(a4 + 16)) {
      xpc_dictionary_apply_f();
    }
  }
  if (v11)
  {
    int v24 = sub_1000067D4((uint64_t)v11, *(void *)(a1 + 248), v21);
    *a8 = v24;
    if (v24)
    {
      sub_10001A174(v11);
      size_t v11 = 0;
    }
  }
  sub_100014C90((uint64_t)v21);
  return v11;
}

char *sub_100006038(uint64_t a1, const unsigned __int8 *a2, char *a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, unsigned char *a8, int *a9)
{
  if (*(_DWORD *)(a1 + 428))
  {
    xpc_object_t v17 = xpc_array_create(0, 0);
    if (*(_DWORD *)(a1 + 428))
    {
      v93 = a2;
      unint64_t v18 = 0;
      do
        xpc_array_set_string(v17, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(*(void *)(a1 + 432) + 8 * v18++));
      while (v18 < *(unsigned int *)(a1 + 428));
      a2 = v93;
    }
  }
  else
  {
    xpc_object_t v17 = 0;
  }
  uint64_t v22 = sub_10000750C(*(void **)(a1 + 16), a5, a3, v17, a6, a7 | 4, a9, a8);
  if (v17) {
    xpc_release(v17);
  }
  if (v22)
  {
    if (a4 == -1
      || (int v23 = sub_10001EF6C(v22, *(void *)(a1 + 448), *(void *)(a1 + 456), *(void *)(a1 + 464), a4, v19, v20, v21)) == 0)
    {
      if (!a5)
      {
        long long v30 = *(_OWORD *)(a1 + 392);
        *(_OWORD *)(v22 + 376) = *(_OWORD *)(a1 + 376);
        *(_OWORD *)(v22 + 392) = v30;
      }
      long long v31 = *(const char **)(a1 + 576);
      if (v31) {
        *((void *)v22 + 72) = sub_1000159F0(v31);
      }
      long long v32 = *(const char **)(a1 + 440);
      if (v32) {
        *((void *)v22 + 55) = sub_1000159F0(v32);
      }
      long long v33 = *(const char **)(a1 + 888);
      if (v33) {
        *((void *)v22 + 111) = sub_1000159F0(v33);
      }
      long long v34 = *(const char **)(a1 + 448);
      if (v34) {
        *((void *)v22 + 56) = sub_1000159F0(v34);
      }
      long long v35 = *(const char **)(a1 + 456);
      if (v35) {
        *((void *)v22 + 57) = sub_1000159F0(v35);
      }
      long long v36 = *(const char **)(a1 + 464);
      if (v36) {
        *((void *)v22 + 58) = sub_1000159F0(v36);
      }
      sub_10004011C(a1, (uint64_t)v22);
      sub_1000401AC(a1, (uint64_t)v22);
      long long v37 = *(const char **)(a1 + 480);
      if (v37) {
        *((void *)v22 + 60) = sub_1000159F0(v37);
      }
      long long v38 = *(const char **)(a1 + 472);
      if (v38) {
        *((void *)v22 + 74) += ~strlen(v38);
      }
      long long v39 = *(const char **)(a1 + 488);
      if (v39) {
        *((void *)v22 + 61) = sub_1000159F0(v39);
      }
      uuid_copy((unsigned __int8 *)v22 + 408, a2);
      xpc_object_t v45 = *(const char **)(a1 + 800);
      if (v45) {
        *((void *)v22 + 100) = sub_1000159F0(v45);
      }
      v46 = *(const char **)(a1 + 808);
      if (v46) {
        *((void *)v22 + 101) = sub_1000159F0(v46);
      }
      *((void *)v22 + 112) = *(void *)(a1 + 896);
      uint64_t v47 = *((void *)v22 + 173);
      unint64_t v48 = *((void *)v22 + 172) & 0xDFFFFFFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 61) & 1) << 61);
      *((void *)v22 + 172) = v48;
      *(_OWORD *)(v22 + 916) = *(_OWORD *)(a1 + 916);
      *((_DWORD *)v22 + 233) = *(_DWORD *)(a1 + 932);
      *((void *)v22 + 117) = *(void *)(a1 + 936);
      *((_OWORD *)v22 + 59) = *(_OWORD *)(a1 + 944);
      *((void *)v22 + 120) = *(void *)(a1 + 960);
      *((_DWORD *)v22 + 242) = *(_DWORD *)(a1 + 968);
      v22[984] = *(unsigned char *)(a1 + 984);
      uint64_t v49 = v48 | 0x20000000000;
      *((void *)v22 + 172) = v48 | 0x20000000000;
      v22[356] = *(unsigned char *)(a1 + 356);
      v22[1030] = *(unsigned char *)(a1 + 1030);
      uint64_t v50 = *(void *)(a1 + 1376) >> 59;
      *((void *)v22 + 173) = v47;
      *((void *)v22 + 172) = v49 & 0xF7FFFFFFFFFFFFFFLL | ((unint64_t)(v50 & 1) << 59);
      v22[1018] = *(unsigned char *)(a1 + 1018);
      *((_DWORD *)v22 + 255) = *(_DWORD *)(a1 + 1020);
      uint64_t v51 = *(const void **)(a1 + 904);
      if (v51) {
        *((void *)v22 + 113) = xpc_binprefs_copy(v51);
      }
      *((_DWORD *)v22 + 228) = *(_DWORD *)(a1 + 912);
      xpc_object_t v52 = *(void **)(a1 + 1008);
      if (v52)
      {
        uint64_t v53 = (uint64_t *)(v22 + 1008);
        do
        {
          out[0] = 0;
          xpc_object_t v54 = (void *)sub_10001A2E4((uint64_t)v52, out);
          uint64_t v55 = *v53;
          *xpc_object_t v54 = *v53;
          if (v55) {
            *(void *)(v55 + 8) = v54;
          }
          *((void *)v22 + 126) = v54;
          v54[1] = v53;
          ++*((_WORD *)v22 + 508);
          *((void *)v22 + 74) += out[0];
          xpc_object_t v52 = (void *)*v52;
        }
        while (v52);
      }
      uint64_t v56 = *((void *)v22 + 172);
      unint64_t v57 = *((void *)v22 + 173) & 0xFFFFFFFFFFFFFFFELL | *(void *)(a1 + 1384) & 1;
      *((void *)v22 + 173) = v57;
      unint64_t v58 = v56 & 0xFFFFFFFFFFFFFFFELL | *(void *)(a1 + 1376) & 1;
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v58;
      unint64_t v59 = v58 & 0xFFFFFFFFFFFFFFFDLL | (2 * ((*(void *)(a1 + 1376) >> 1) & 1));
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v59;
      unint64_t v60 = v59 & 0xFFFFFFFFFFFFFFFBLL | (4 * ((*(void *)(a1 + 1376) >> 2) & 1));
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v60;
      unint64_t v61 = v60 & 0xFFFFFFFFFFFFFFF7 | (8 * ((*(void *)(a1 + 1376) >> 3) & 1));
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v61;
      unint64_t v62 = v61 & 0xFFFFFFFFFFFFFFDFLL | (32 * ((*(void *)(a1 + 1376) >> 5) & 1));
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v62;
      unint64_t v63 = v62 & 0xFFFFFFFFFFFFFFBFLL | (((*(void *)(a1 + 1376) >> 6) & 1) << 6);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v63;
      v22[1332] = *(unsigned char *)(a1 + 1332);
      unint64_t v64 = v63 & 0xFFFFFFFFFFFFFEFFLL | (((*(void *)(a1 + 1376) >> 8) & 1) << 8);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v64;
      unint64_t v65 = v64 & 0xFFFFFFFFFFFFFDFFLL | (((*(void *)(a1 + 1376) >> 9) & 1) << 9);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v65;
      unint64_t v66 = v65 & 0xFFFFFFFFFFFFFBFFLL | (((*(void *)(a1 + 1376) >> 10) & 1) << 10);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v66;
      unint64_t v67 = v66 & 0xFFFFFFFFFFFEFFFFLL | (((*(void *)(a1 + 1376) >> 16) & 1) << 16);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v67;
      unint64_t v68 = v67 & 0xFFFFFFFFFF7FFFFFLL | (((*(void *)(a1 + 1376) >> 23) & 1) << 23);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v68;
      unint64_t v69 = v68 & 0xFFFFFFFFFEFFFFFFLL | (((*(void *)(a1 + 1376) >> 24) & 1) << 24);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v69;
      unint64_t v70 = v69 & 0xFF7FFFFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 55) & 1) << 55);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v70;
      unint64_t v71 = v70 & 0xFFFFFFFFBFFFFFFFLL | (((*(void *)(a1 + 1376) >> 30) & 1) << 30);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v71;
      *((_OWORD *)v22 + 62) = *(_OWORD *)(a1 + 992);
      unint64_t v72 = v71 & 0xFFFFFFFDFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 33) & 1) << 33);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v72;
      v22[1040] = *(unsigned char *)(a1 + 1040);
      unint64_t v73 = v72 & 0xFFDFFFFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 53) & 1) << 53);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v73;
      *((_WORD *)v22 + 514) = *(_WORD *)(a1 + 1028);
      unint64_t v74 = v73 & 0xFFEFFFFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 52) & 1) << 52);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v74;
      unint64_t v75 = v74 & 0xFFFFFFFBFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 34) & 1) << 34);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v75;
      uint64_t v76 = *(const char **)(a1 + 584);
      if (v76)
      {
        *((void *)v22 + 73) = sub_1000159F0(v76);
        unint64_t v57 = *((void *)v22 + 173);
        unint64_t v75 = *((void *)v22 + 172);
      }
      *((_DWORD *)v22 + 217) = *(_DWORD *)(a1 + 868);
      unint64_t v77 = v75 & 0xFFFFFEFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 40) & 1) << 40);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v77;
      unint64_t v78 = v77 & 0xFFFFF7FFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 43) & 1) << 43);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v78;
      unint64_t v79 = v78 & 0xFFFFEFFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 44) & 1) << 44);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v79;
      *((_DWORD *)v22 + 332) = *(_DWORD *)(a1 + 1328);
      unint64_t v80 = v79 & 0xFFFFBFFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 46) & 1) << 46);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v80;
      unint64_t v81 = v80 & 0xFFFF7FFFFFFFFFFFLL | (((*(void *)(a1 + 1376) >> 47) & 1) << 47);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v81;
      unint64_t v82 = v81 & 0xFFFEFFFFFFFFFFFFLL | ((HIWORD(*(void *)(a1 + 1376)) & 1) << 48);
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v82;
      uint64_t v83 = *(void *)(a1 + 1376) >> 50;
      *((void *)v22 + 173) = v57;
      *((void *)v22 + 172) = v82 & 0xFFFBFFFFFFFFFFFFLL | ((unint64_t)(v83 & 1) << 50);
      *((_DWORD *)v22 + 335) = *(_DWORD *)(a1 + 1340);
      uint64_t v84 = *(void **)(a1 + 640);
      if (v84) {
        *((void *)v22 + 80) = xpc_retain(v84);
      }
      uint64_t v85 = *(void **)(a1 + 648);
      if (v85) {
        *((void *)v22 + 81) = xpc_retain(v85);
      }
      uint64_t v86 = *(void **)(a1 + 496);
      if (v86)
      {
        if (*(unsigned char *)(a1 + 1344) == 2) {
          *((void *)v22 + 62) = xpc_retain(v86);
        }
        else {
          sub_10001E4BC((uint64_t)v22, 4, "Service instances do not support XPC events.", v40, v41, v42, v43, v44, v92);
        }
      }
      char v87 = *(const char **)(a1 + 1360);
      if (v87) {
        *((void *)v22 + 170) = sub_1000159F0(v87);
      }
      uint64_t v88 = *(const char **)(a1 + 1368);
      if (v88) {
        *((void *)v22 + 171) = sub_1000159F0(v88);
      }
      uint64_t v89 = *(const void **)(a1 + 600);
      if (v89)
      {
        *((void *)v22 + 75) = sub_1000159AC(v89, *(unsigned int *)(a1 + 608));
        *((_DWORD *)v22 + 152) = *(_DWORD *)(a1 + 608);
      }
      uint64_t v90 = *(const void **)(a1 + 616);
      if (v90)
      {
        *((void *)v22 + 77) = sub_1000159AC(v90, *(unsigned int *)(a1 + 624));
        *((_DWORD *)v22 + 156) = *(_DWORD *)(a1 + 624);
      }
      *((void *)v22 + 74) = *(void *)(a1 + 592);
      memset(out, 0, 37);
      uuid_unparse(a2, (char *)out);
      sub_10000522C((uint64_t)v22, "LaunchInstanceID", (const char *)out, 1);
    }
    else
    {
      char v24 = v23;
      *a9 = v23;
      strerror(v23);
      sub_10001E4BC(a1, 3, "Could not set up nowait inetd service: %d: %s", v25, v26, v27, v28, v29, v24);
      sub_10001A174(v22);
      return 0;
    }
  }
  return v22;
}

uint64_t sub_1000066F8(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 904);
  if (v4)
  {
    *(void *)(a1 + 592) -= _xpc_spawnattr_binprefs_size(v4);
    free(*(void **)(a1 + 904));
  }
  *(void *)(a1 + 904) = xpc_binprefs_copy(a2);
  uint64_t result = _xpc_spawnattr_binprefs_size((uint64_t)a2);
  *(void *)(a1 + 592) += result;
  return result;
}

size_t sub_10000675C(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(void **)(a1 + 480);
  if (v4)
  {
    *(void *)(a1 + 592) += ~strlen(*(const char **)(a1 + 480));
    free(v4);
  }
  *(void *)(a1 + 480) = sub_1000159F0(a2);
  size_t result = strlen(a2);
  *(void *)(a1 + 592) += result + 1;
  return result;
}

uint64_t sub_1000067D4(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (!sub_10002ABC8(a2))
  {
    uint64_t v7 = (void *)sub_1000301F4(a2);
    uint64_t v8 = v7;
    unint64_t v9 = *(void *)(a1 + 1376);
    if ((v9 & 0x40000000) != 0 && v7 != &unk_100075750)
    {
      sub_100014CD8(a3, 3, "_AbandonCoalition is only available to Application services.");
      unint64_t v9 = *(void *)(a1 + 1376) & 0xFFFFFFFFBFFFFFFFLL;
      *(void *)(a1 + 1376) = v9;
    }
    if ((v9 & 0x80000000000) != 0 && v8 != &unk_1000755B8)
    {
      sub_100014CD8(a3, 3, "DisallowAllLookups is not supported for non-System services.");
      *(void *)(a1 + 1376) &= ~0x80000000000uLL;
    }
    if (!sub_10002A744(a2))
    {
      if (*(void *)(a1 + 800))
      {
        int v10 = (*(void *)(a1 + 1376) & 2) != 0 ? "_RoleAccount" : "UserName";
        sub_100014CD8(a3, 3, "%s is not supported by the domain, ignoring.", v10);
        size_t v11 = *(void **)(a1 + 800);
        if (v11)
        {
          *(void *)(a1 + 592) += ~strlen(*(const char **)(a1 + 800));
          free(v11);
          *(void *)(a1 + 800) = 0;
        }
      }
      if (*(void *)(a1 + 808))
      {
        sub_100014CD8(a3, 3, "GroupName is not supported by the domain, ignoring.");
        int v12 = *(char **)(a1 + 808);
        *(void *)(a1 + 592) += ~strlen(v12);
        free(v12);
        *(void *)(a1 + 808) = 0;
      }
    }
    uint64_t v13 = *(void *)(a1 + 1376);
    if ((v13 & 0x400000000000) != 0)
    {
      if ((v13 & 0x40400000000) == 0)
      {
        uint64_t v6 = 144;
        sub_100014CD8(a3, 3, "persona can only be set on submitted jobs and extensions");
        return v6;
      }
      if ((sub_10000FE40(a1 + 376, 3) & 1) == 0 && !sub_10000FE40(a1 + 376, 15))
      {
        uint64_t v6 = 144;
        sub_100014CD8(a3, 3, "setting persona requires an entitlement");
        return v6;
      }
    }
    uint64_t v14 = *(void *)(a1 + 1384);
    uint64_t v15 = *(void *)(a1 + 1376);
    if ((v15 & 0x1000000000000000) != 0)
    {
      if ((v15 & 0x40400000000) == 0
        || (char v16 = sub_10000FE40(a1 + 376, 30),
            uint64_t v14 = *(void *)(a1 + 1384),
            uint64_t v15 = *(void *)(a1 + 1376),
            (v16 & 1) == 0))
      {
        if ((v15 & 0x100000000000) == 0)
        {
          uint64_t v6 = 1;
          sub_100014CD8(a3, 3, "_Cryptex can only be set on trusted services");
          return v6;
        }
      }
    }
    if (*(void *)(a1 + 1368))
    {
      if ((v15 & 0x40400000000) == 0
        || (char v17 = sub_10000FE40(a1 + 376, 31),
            uint64_t v14 = *(void *)(a1 + 1384),
            uint64_t v15 = *(void *)(a1 + 1376),
            (v17 & 1) == 0))
      {
        if ((v15 & 0x100000000000) == 0)
        {
          uint64_t v6 = 1;
          sub_100014CD8(a3, 3, "_Conclave can only be set on trusted services");
          return v6;
        }
      }
    }
    if ((v15 & 0x8000000) != 0) {
      sub_100050D0C();
    }
    *(void *)(a1 + 1384) = v14;
    *(void *)(a1 + 1376) = v15 | 0x8000000;
    *(void *)(a1 + 248) = a2;
    (*(void (**)(uint64_t, void))(a1 + 560))(a1, *(void *)(a1 + 568));
    unint64_t v18 = *(char **)(*(void *)(a1 + 248) + 48);
    while (v18)
    {
      uint64_t v19 = (char **)v18;
      unint64_t v18 = *(char **)v18;
      if (sub_100015D70(v19[2], (const char *)(a1 + 1392)))
      {
        sub_10001E4BC(a1, 5, "matched domain attach request on creation", v20, v21, v22, v23, v24, v46);
        sub_100047BA0(dword_100076A00, v19[3]);
        xpc_release(v19[3]);
        uint64_t v25 = *v19;
        if (*v19) {
          *((void *)v25 + 1) = v19[1];
        }
        *(void *)v19[1] = v25;
        free(v19);
        break;
      }
    }
    if (*(void *)(a1 + 496))
    {
      if (sub_1000250F0(a1))
      {
        sub_10001E4BC(a1, 5, "Ignoring events for retain only services", v26, v27, v28, v29, v30, v46);
      }
      else
      {
        if (byte_100076A79) {
          sub_10001E4BC(a1, 5, "Operating in pure on-demand mode. Ignoring events", v26, v27, v28, v29, v30, v46);
        }
        else {
          xpc_dictionary_apply_f();
        }
        if ((*(unsigned char *)(a1 + 1377) & 0x40) == 0 && !*(unsigned char *)(a1 + 1344))
        {
          xpc_release(*(xpc_object_t *)(a1 + 496));
          *(void *)(a1 + 496) = 0;
        }
      }
    }
    long long v31 = *(void **)(a1 + 504);
    if (v31)
    {
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = sub_100007A58;
      applier[3] = &unk_10006D208;
      applier[4] = a1;
      xpc_dictionary_apply(v31, applier);
      xpc_release(*(xpc_object_t *)(a1 + 504));
      *(void *)(a1 + 504) = 0;
      long long v32 = sub_100013BB8(0x28uLL);
      v32[32] = 1;
      *((void *)v32 + 2) = sub_10001E304;
      *((void *)v32 + 3) = "provides events";
      long long v33 = (void *)(a1 + 672);
      uint64_t v34 = *(void *)(a1 + 672);
      *(void *)long long v32 = v34;
      if (v34) {
        *(void *)(v34 + 8) = v32;
      }
      void *v33 = v32;
      *((void *)v32 + 1) = v33;
    }
    int v35 = sub_10003B5BC();
    uint64_t v41 = *(void *)(a1 + 1376);
    if (v35 || (v41 & 0x400001000) == 0)
    {
      uint64_t v6 = 0;
      *(void *)(a1 + 1384) = *(void *)(a1 + 1384);
      *(void *)(a1 + 1376) = v41 | 0x2000000000000;
      return v6;
    }
    if ((v41 & 0x80000) != 0)
    {
      uint64_t v42 = "it has a roleaccount set";
    }
    else if (*(void *)(a1 + 680))
    {
      uint64_t v42 = "it has limits set";
    }
    else if (*(void *)(a1 + 440))
    {
      uint64_t v42 = "it set a non standard working directory";
    }
    else if ((v41 & 0x100000000) != 0)
    {
      uint64_t v42 = "it set a non standard umask";
    }
    else if ((v41 & 0x60) != 0)
    {
      uint64_t v42 = "it set an io priority";
    }
    else
    {
      xpc_object_t v45 = (const char *)sub_10001E034(a1);
      if (access(v45, 1))
      {
        uint64_t v42 = "its binary is missing or not executable";
      }
      else if (*(void *)(a1 + 1360))
      {
        uint64_t v42 = "is from a cryptex";
      }
      else if ((*(unsigned char *)(a1 + 1379) & 0x80) != 0)
      {
        uint64_t v42 = "it disabled initgroups";
      }
      else
      {
        sub_100007C44();
        if (!v42)
        {
          if (byte_100075AC4)
          {
            uint64_t v43 = "service will attempt to elide xpcproxy";
          }
          else
          {
            *(void *)(a1 + 1376) |= 0x2000000000000uLL;
            uint64_t v43 = "service will always use xpcproxy, elision was disabled by boot-arg";
          }
          goto LABEL_63;
        }
      }
    }
    *(void *)(a1 + 1376) |= 0x2000000000000uLL;
    char v46 = (char)v42;
    uint64_t v43 = "service will always use xpcproxy because %s";
LABEL_63:
    sub_10001E4BC(a1, 5, v43, v36, v37, v38, v39, v40, v46);
    return 0;
  }
  return 124;
}

void sub_100006D50(void *guard)
{
  uint64_t v1 = guard[172];
  if ((v1 & 0x10000000) != 0) {
    sub_100040E80("attempted to petrify a service twice");
  }
  guard[173] = guard[173];
  guard[172] = v1 | 0x10000000;
  if ((v1 & 0x8000000) == 0) {
    sub_100040E80("attempted to petrify a service that hasn't been animated");
  }
  uint64_t v3 = (void *)guard[17];
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)v3[2];
      sub_10003D5CC(v3);
      sub_10001A174(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  uint64_t v5 = (void *)guard[18];
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)v5[2];
      sub_10003D048((uint64_t)v5);
      sub_10001A174(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  sub_100024F7C((mach_port_context_t)guard);

  sub_10001E368((uint64_t)guard, 9, 0);
}

char *sub_100006E30(uint64_t a1, uint64_t a2, _OWORD *a3, void *a4, uint64_t a5, unint64_t a6, int *a7)
{
  uint64_t property = xpc_bundle_get_property();
  if (!property)
  {
    *a7 = 107;
    uint64_t v43 = "Could not get path for service bundle.";
LABEL_18:
    sub_10002A5B8(a1, 3, v43, v14, v15, v16, v17, v18, v75);
    return 0;
  }
  char v19 = property;
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary();
  if (!info_dictionary)
  {
    *a7 = 107;
    char v75 = v19;
    uint64_t v43 = "Could not get Info.plist for bundle at %s";
    goto LABEL_18;
  }
  uint64_t v21 = info_dictionary;
  string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier");
  if (!string)
  {
    sub_10002A5B8(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v23, v24, v25, v26, v27, v19);
    goto LABEL_20;
  }
  uint64_t v28 = string;
  xpc_object_t value = xpc_dictionary_get_value(v21, "XPCService");
  if (!value) {
    goto LABEL_7;
  }
  uint64_t v30 = sub_100007498(value, a1, v28);
  if (!v30)
  {
LABEL_20:
    uint64_t v44 = 0;
    *a7 = 107;
    return v44;
  }
  long long v31 = v30;
  xpc_dictionary_set_value(v21, "XPCService", v30);
  xpc_release(v31);
LABEL_7:
  unint64_t v80 = sub_100014BAC(a1, v28);
  uint64_t v32 = xpc_bundle_get_property();
  if (!v32) {
    sub_100050D0C();
  }
  long long v33 = (const char *)v32;
  uint64_t v34 = (void *)xpc_bundle_get_info_dictionary();
  if (!v34) {
    sub_100050D0C();
  }
  int v35 = v34;
  uint64_t v36 = xpc_dictionary_get_string(v34, "CFBundleIdentifier");
  if (!v36) {
    sub_100050D0C();
  }
  uint64_t v37 = (char *)v36;
  uint64_t executable_path = xpc_bundle_get_executable_path();
  if (!executable_path)
  {
    xpc_object_t v45 = "Bundle has no executable";
LABEL_25:
    uint64_t v42 = (uint64_t)v80;
    sub_100014CD8(v80, 3, v45);
    *a7 = 107;
    goto LABEL_26;
  }
  uint64_t v39 = (char *)executable_path;
  xpc_object_t v40 = xpc_dictionary_get_value(v35, "XPCService");
  if (!v40)
  {
    xpc_object_t v45 = "XPC Service Info.plist is missing XPCService dictionary";
    goto LABEL_25;
  }
  xpc_object_t object = v40;
  xpc_type_t type = xpc_get_type(v40);
  if (object == &_xpc_BOOL_false && type == (xpc_type_t)&_xpc_type_BOOL)
  {
    *a7 = 107;
LABEL_15:
    uint64_t v42 = (uint64_t)v80;
LABEL_26:
    sub_100014C90(v42);
    return 0;
  }
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v45 = "XPCService must be dictionary";
    goto LABEL_25;
  }
  if ((a6 & 0x40) != 0)
  {
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(v35, "EXAppExtensionAttributes");
    if (dictionary)
    {
      uint64_t v49 = xpc_dictionary_get_string(dictionary, "EXExtensionPointIdentifier");
      if (!v49)
      {
        xpc_object_t v45 = "App Extension Info.plist is missing EXExtentionPointIdentifier";
        goto LABEL_25;
      }
    }
    else
    {
      xpc_object_t v50 = xpc_dictionary_get_dictionary(v35, "NSExtension");
      if (!v50 || (uint64_t v49 = xpc_dictionary_get_string(v50, "NSExtensionPointIdentifier")) == 0)
      {
        xpc_object_t v45 = "App Extension Info.plist is missing NSExtentionPointIdentifier";
        goto LABEL_25;
      }
    }
    if (a4 && (xpc_object_t v51 = xpc_dictionary_get_value(a4, "XPCService")) != 0) {
      xpc_object_t v77 = xpc_dictionary_get_value(v51, "ProgramArguments");
    }
    else {
      xpc_object_t v77 = 0;
    }
    uint64_t v76 = v49;
    xpc_object_t v47 = sub_10000F1FC(v49);
  }
  else
  {
    xpc_object_t v47 = sub_10000F27C(v37, object);
    uint64_t v76 = 0;
    xpc_object_t v77 = 0;
  }
  sub_10000E6A8(v47, v80);
  sub_100007D48(object, v47, v80, 1);
  xpc_object_t xdict = v47;
  xpc_object_t v52 = xpc_dictionary_get_value(v47, "ExecuteAllowed");
  if (v52)
  {
    uint64_t v53 = v52;
    if (xpc_get_type(v52) == (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL v73 = xpc_BOOL_get_value(v53);
      if ((a6 & 0x200) == 0 && !v73)
      {
        *a7 = 157;
        xpc_release(xdict);
        goto LABEL_15;
      }
    }
  }
  sub_1000460A4();
  uint64_t v55 = v54;
  uint64_t v56 = sub_10001DF4C((uint64_t)v37, v39, v33, v54);
  sub_10001A174(v55);
  unint64_t v57 = a3;
  uint64_t v42 = (uint64_t)v80;
  uint64_t v44 = sub_10000750C(v56, v57, v37, v77, a5, a6, a7, v80);
  sub_10001A174(v56);
  if (!v44)
  {
    xpc_release(xdict);
    goto LABEL_26;
  }
  *((void *)v44 + 172) |= 0x4000000002uLL;
  if ((a6 & 0x40) != 0)
  {
    BOOL v67 = sub_100015CAC(v37, "com.apple.");
    uint64_t v68 = *((void *)v44 + 172);
    if (!v67) {
      v68 |= 0x8000000000uLL;
    }
    *((void *)v44 + 172) = v68 | 0x40000000;
    unint64_t v69 = sub_10001A054(v44, 1, (uint64_t)v80, 0);
    xpc_dictionary_apply_f();
    sub_10001A12C(v69);
    sub_10000875C((uint64_t)v44, object);
    sub_10000E820((uint64_t)v44, xdict, (uint64_t)v80);
    nullsub_23(v44, xdict);
    xpc_release(xdict);
    if (v76) {
      *((void *)v44 + 73) = sub_1000159F0(v76);
    }
    if (a4)
    {
      xpc_object_t v70 = xpc_dictionary_get_value(a4, "XPCService");
      if (v70)
      {
        xpc_object_t v71 = xpc_dictionary_get_value(v70, "PersonaEnterprise");
        if (v71)
        {
          *((_DWORD *)v44 + 332) = xpc_int64_get_value(v71);
          *((void *)v44 + 172) |= 0x400000000000uLL;
        }
      }
    }
    uint64_t v65 = *((void *)v44 + 173);
    unint64_t v66 = *((void *)v44 + 172) & 0xFFFFFFFFFFFFFCFFLL;
  }
  else
  {
    unint64_t v58 = sub_10001A054(v44, 1, (uint64_t)v80, 0);
    xpc_dictionary_apply_f();
    sub_10001A12C(v58);
    sub_10000875C((uint64_t)v44, object);
    sub_10000E820((uint64_t)v44, xdict, (uint64_t)v80);
    nullsub_23(v44, xdict);
    xpc_release(xdict);
    uint64_t v65 = *((void *)v44 + 173);
    unint64_t v66 = *((void *)v44 + 172);
  }
  *((void *)v44 + 72) = v44 + 1392;
  *((void *)v44 + 173) = v65;
  *((void *)v44 + 172) = v66 | 0x1000000000;
  sub_100008808((uint64_t)v44, a6, v59, v60, v61, v62, v63, v64);
  sub_100008894((uint64_t)v44);
  int v72 = sub_1000067D4((uint64_t)v44, a1, v80);
  *a7 = v72;
  if (v72)
  {
    sub_10001A174(v44);
    goto LABEL_26;
  }
  if (*((void *)v44 + 62))
  {
    sub_100014CD8(v80, 4, "Ignoring launch events for a bundle");
    xpc_release(*((xpc_object_t *)v44 + 62));
    *((void *)v44 + 62) = 0;
  }
  sub_100014C90((uint64_t)v80);
  int v74 = byte_100076A47;
  if ((v44[1380] & 4) != 0) {
    int v74 = byte_100076A48 | byte_100076A47;
  }
  if (v74)
  {
    *(void *)(v44 + 924) = -1;
    *((_DWORD *)v44 + 229) &= 0xFFFFFFF3;
  }
  return v44;
}

uint64_t *sub_100007498(void *a1, uint64_t a2, const char *a3)
{
  uint64_t v4 = sub_100014BAC(a2, a3);
  int v10 = sub_10003BCA8(a1, v4);
  if (*((unsigned char *)v4 + 16))
  {
    sub_1000442C4((const char *)v4[1], 3, "Plist preprocessing failed, rejecting", v5, v6, v7, v8, v9, v12);
    xpc_release(v10);
    int v10 = 0;
  }
  sub_100014C90((uint64_t)v4);
  return v10;
}

char *sub_10000750C(void *a1, _OWORD *a2, char *__s1, void *a4, uint64_t a5, unint64_t a6, int *a7, unsigned char *a8)
{
  uint64_t v13 = __s1;
  if (!strcmp(__s1, "shell"))
  {
    uint64_t v16 = 0;
    int v17 = 140;
    goto LABEL_7;
  }
  if (!a4)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    int v44 = 0;
LABEL_24:
    uint64_t v16 = sub_10001A944(v13);
    *((void *)v16 + 2) = sub_10001A0AC(a1);
    if (a2)
    {
      long long v34 = a2[1];
      *(_OWORD *)(v16 + 376) = *a2;
      *(_OWORD *)(v16 + 392) = v34;
    }
    v16[424] = 0;
    int v35 = (const char *)sub_10001E034((uint64_t)v16);
    *((void *)v16 + 74) = v19 + strlen(v35) + 241;
    *((_DWORD *)v16 + 107) = v44;
    *((void *)v16 + 54) = v18;
    *((_DWORD *)v16 + 209) = 10;
    *((_DWORD *)v16 + 208) = dword_100075A90;
    *((_OWORD *)v16 + 75) = 0u;
    *((_OWORD *)v16 + 76) = 0u;
    *((_OWORD *)v16 + 77) = 0u;
    *((void *)v16 + 156) = 0;
    *((_DWORD *)v16 + 216) = 5;
    *((_DWORD *)v16 + 217) = dword_100075A98;
    *((void *)v16 + 112) = 1536;
    *((_WORD *)v16 + 660) = 0;
    *((void *)v16 + 164) = 0xFFFFFFFFLL;
    *((_DWORD *)v16 + 232) = -1;
    v16[1018] = 0;
    *((_DWORD *)v16 + 255) = 0;
    *((_OWORD *)v16 + 57) = xmmword_100053CD0;
    long long v36 = *(_OWORD *)(a5 + 32);
    *(_OWORD *)(v16 + 536) = *(_OWORD *)(a5 + 16);
    *(_OWORD *)(v16 + 552) = v36;
    *(_OWORD *)(v16 + 520) = *(_OWORD *)a5;
    *((void *)v16 + 71) = *(void *)(a5 + 48);
    *((void *)v16 + 86) = -1;
    *((_DWORD *)v16 + 174) = -1;
    v16[1041] = 1;
    *((void *)v16 + 172) |= 0x300uLL;
    uint64_t v37 = sub_1000033D0(v16 + 1392);
    *((void *)v16 + 25) = 0;
    *(void *)(v16 + 1348) = v37;
    uint64_t v38 = *((void *)v16 + 173);
    uint64_t v39 = *((void *)v16 + 172) | 0x8000000000000;
    *((void *)v16 + 172) = v39;
    *((_WORD *)v16 + 514) = 10;
    *((_DWORD *)v16 + 60) = *((_DWORD *)v16 + 56);
    *((void *)v16 + 29) = *((void *)v16 + 27);
    *((_DWORD *)v16 + 56) = 3044;
    *((void *)v16 + 26) = v16 + 200;
    *((void *)v16 + 27) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/service_create.c";
    *(void *)&long long v40 = -1;
    *((void *)&v40 + 1) = -1;
    *(_OWORD *)(v16 + 24) = v40;
    *(_OWORD *)(v16 + 40) = v40;
    if ((a6 & 4) == 0)
    {
      sub_10000522C((uint64_t)v16, "XPC_SERVICE_NAME", v13, 1);
      uint64_t v38 = *((void *)v16 + 173);
      uint64_t v39 = *((void *)v16 + 172);
    }
    if ((a6 & 0x202C0) != 0)
    {
      *((void *)v16 + 173) = v38;
      *((void *)v16 + 172) = v39 | (a6 << 33) & 0x10000000000 | (a6 << 27) & 0x100000000000 | (a6 << 33) & 0x40000000000 | (((a6 >> 6) & 1) << 34);
    }
    *((_DWORD *)v16 + 335) = 0;
    v16[984] = (v39 & 0x100000000000 | (a6 << 27) & 0x100000000000) != 0;
    if ((a6 & 0x8000) != 0) {
      sub_100007908((uint64_t)v16, "com.apple.cryptex.app");
    }
    return v16;
  }
  if (xpc_get_type(a4) != (xpc_type_t)&_xpc_type_array)
  {
    sub_100014CD8(a8, 3, "ProgramArguments is not an array.");
LABEL_5:
    uint64_t v16 = 0;
    int v17 = 111;
LABEL_7:
    *a7 = v17;
    return v16;
  }
  uint64_t v42 = a1;
  uint64_t v43 = v13;
  unint64_t v41 = a6;
  if (xpc_array_get_count(a4))
  {
    size_t v20 = 0;
    uint64_t v19 = 0;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(a4, v20);
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string) {
        break;
      }
      v19 += xpc_string_get_length(value) + 1;
      if (++v20 >= xpc_array_get_count(a4)) {
        goto LABEL_15;
      }
    }
    sub_100014CD8(a8, 3, "ProgramArguments is not an array of strings.", a6);
    goto LABEL_5;
  }
  uint64_t v19 = 0;
LABEL_15:
  size_t result = (char *)xpc_array_get_count(a4);
  uint64_t v23 = result + 1;
  uint64_t v24 = v23 << 31 >> 31;
  if (v24 == v23 && (v24 & 0x8000000000000000) == 0)
  {
    uint64_t v25 = (uint64_t)result;
    uint64_t v26 = v24 & 0x1FFFFFFFFLL;
    size_t result = (char *)(v19 + 8 * v26);
    a1 = v42;
    uint64_t v13 = v43;
    if (!__CFADD__(v19, 8 * v26))
    {
      uint64_t v27 = (char *)sub_100013BB8((size_t)result);
      uint64_t v18 = v27;
      uint64_t v28 = v25;
      int v44 = v25;
      if (v25)
      {
        size_t v29 = 0;
        uint64_t v30 = &v27[(8 * v25 + 8) & 0x7FFFFFFF8];
        do
        {
          xpc_object_t v31 = xpc_array_get_value(a4, v29);
          string_ptr = xpc_string_get_string_ptr(v31);
          size_t length = xpc_string_get_length(v31);
          *(void *)&v18[8 * v29] = v30;
          strcpy(v30, string_ptr);
          v30 += length + 1;
          ++v29;
        }
        while (v28 != v29);
        a6 = v41;
        a1 = v42;
        uint64_t v13 = v43;
      }
      else
      {
        a6 = v41;
      }
      goto LABEL_24;
    }
  }
  __break(1u);
  return result;
}

size_t sub_100007908(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(void **)(a1 + 1360);
  if (v4)
  {
    *(void *)(a1 + 592) += ~strlen(*(const char **)(a1 + 1360));
    free(v4);
    *(void *)(a1 + 1360) = 0;
  }
  *(void *)(a1 + 1360) = sub_1000159F0(a2);
  size_t result = strlen(a2);
  *(void *)(a1 + 592) += result + 1;
  return result;
}

void sub_100007984(char *a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    if ((*(unsigned char *)(a3 + 1380) & 0x80) != 0 || !sub_10001A45C(a1))
    {
      string_ptr = xpc_string_get_string_ptr(object);
      sub_10000522C(a3, a1, string_ptr, 0);
    }
    else
    {
      sub_10001E4BC(a3, 3, "Disallowing environment variable: %s", v12, v13, v14, v15, v16, (char)a1);
    }
  }
  else
  {
    xpc_type_t type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_10001E4BC(a3, 3, "Invalid type for environment variable value (env/type): %s/%s", v7, v8, v9, v10, v11, (char)a1);
  }
}

uint64_t sub_100007A58(uint64_t a1, const void *a2, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_uint64) {
    sub_100050D0C();
  }
  uint64_t v6 = *(void *)(a1 + 32);
  char value = xpc_uint64_get_value(object);
  sub_10003CBBC(v6, a2, value, 0);
  return 1;
}

void sub_100007AC8(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_100007BA0;
    applier[3] = &unk_10006D228;
    applier[4] = a3;
    void applier[5] = a1;
    xpc_dictionary_apply(object, applier);
  }
  else
  {
    xpc_type_t type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_10001E4BC(a3, 3, "Invalid type for event stream (stream/type): %s/%s", v7, v8, v9, v10, v11, a1);
    *(void *)(a3 + 1376) |= 1uLL;
  }
}

uint64_t sub_100007BA0(uint64_t a1, const char *a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  uint64_t v7 = *(void *)(a1 + 32);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10003D3E4(*(void **)(a1 + 32), *(const void **)(a1 + 40), a2, object);
  }
  else
  {
    uint64_t v8 = xpc_get_type(object);
    xpc_type_get_name(v8);
    sub_10001E4BC(v7, 3, "Invalid type for event (event/type): %s/%s", v9, v10, v11, v12, v13, (char)a2);
    *(void *)(*(void *)(a1 + 32) + 1376) |= 1uLL;
  }
  return 1;
}

double sub_100007C44()
{
  uint64_t v0 = __chkstk_darwin();
  *(void *)(v0 + 720) = 0x6400000064;
  bzero(v5, 0x1090uLL);
  if (!*(void *)(v0 + 800))
  {
    uint64_t v1 = *(void *)(v0 + 248);
    if (*(unsigned char *)(v1 + 104))
    {
      if (sub_10001ABC4(*(_DWORD *)(v1 + 56), v5)) {
        return result;
      }
      goto LABEL_6;
    }
  }
  if (!sub_10001AD1C())
  {
LABEL_6:
    *(void *)(v0 + 720) = v6;
    long long v3 = v8;
    *(_OWORD *)(v0 + 728) = v7;
    *(_OWORD *)(v0 + 744) = v3;
    double result = *(double *)&v9;
    long long v4 = v10;
    *(_OWORD *)(v0 + 760) = v9;
    *(_OWORD *)(v0 + 776) = v4;
    *(_DWORD *)(v0 + 792) = v11;
  }
  return result;
}

void sub_100007D48(void *a1, xpc_object_t xdict, unsigned char *a3, int a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "EnablePressuredExit");
  xpc_object_t v9 = xpc_dictionary_get_value(xdict, "EnableTransactions");
  if (xpc_dictionary_get_BOOL(a1, "KeepAlive"))
  {
    if (a4) {
      sub_100040E80("XPC bundles can't have KeepAlive, they can't even set it as a plist key, how did we get here?");
    }
    int v10 = 1;
    if (!v9)
    {
      int v11 = 4;
      int v12 = 1;
      goto LABEL_19;
    }
LABEL_18:
    int v12 = xpc_BOOL_get_value(v9);
    int v11 = 0;
LABEL_19:
    int v13 = 0;
    if (!value) {
      goto LABEL_23;
    }
    goto LABEL_20;
  }
  if (value)
  {
    int v10 = 0;
    if (xpc_BOOL_get_value(value))
    {
      int v11 = 3;
      int v12 = 1;
      int v13 = 1;
    }
    else
    {
      if (v9) {
        goto LABEL_18;
      }
      int v13 = 0;
      if (a4) {
        int v11 = 5;
      }
      else {
        int v11 = 4;
      }
      int v12 = 1;
    }
LABEL_20:
    int v14 = xpc_BOOL_get_value(value);
    if (v10 == 1 && v13 != v14)
    {
      sub_100014CD8(a3, 3, "EnablePressuredExit is not compatible with KeepAlive=true. Ignoring EnablePressuredExit.");
      goto LABEL_25;
    }
LABEL_23:
    if (v10 == 2) {
      sub_100014CD8(a3, 4, "Assuming EnablePressuredExit=false given EnableTransactions=false.");
    }
LABEL_25:
    if (!v9) {
      goto LABEL_29;
    }
    goto LABEL_26;
  }
  if (!v9)
  {
    LOBYTE(v13) = 1;
    LOBYTE(v12) = 1;
    goto LABEL_29;
  }
  if (!xpc_BOOL_get_value(v9))
  {
    int v10 = 2;
    goto LABEL_18;
  }
  int v11 = 3;
  LOBYTE(v13) = 1;
  int v12 = 1;
LABEL_26:
  int v15 = xpc_BOOL_get_value(v9);
  if (v11 == 3 && v12 != v15) {
    sub_100014CD8(a3, 3, "Service sets EnableTransactions=false and EnablePressuredExit=true, which makes no sense. Enabling Transactions.");
  }
LABEL_29:
  xpc_dictionary_set_BOOL(xdict, "EnablePressuredExit", v13);

  xpc_dictionary_set_BOOL(xdict, "EnableTransactions", v12);
}

void sub_100007F20(char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = (unsigned char *)a3[1];
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL value = xpc_BOOL_get_value(object);
    int v22 = *a1;
    switch(v22)
    {
      case 'j':
        goto LABEL_14;
      case '_':
        BOOL v36 = value;
        if (!strcmp(a1, "_MultipleInstances"))
        {
          *(unsigned char *)(v5 + 1344) = v36;
          return;
        }
        if (!strcmp(a1, "_JoinGUISession")) {
          return;
        }
        if (!strcmp(a1, "_AbandonCoalition"))
        {
          uint64_t v65 = 0x40000000;
          if (!v36) {
            uint64_t v65 = 0;
          }
          unint64_t v66 = *(void *)(v5 + 1376) & 0xFFFFFFFFBFFFFFFFLL;
        }
        else
        {
          if (!strcmp(a1, "_OmitSandboxParameters")) {
            return;
          }
          if (strcasecmp(a1, "_HighBitsASLR"))
          {
            if (!strcasecmp(a1, "_ExponentialThrottling"))
            {
              unint64_t v37 = *(void *)(v5 + 1376) & 0xFFE7FFFFFFFFFFFFLL;
              *(_WORD *)(v5 + 1028) = 3;
              uint64_t v38 = 0x10000000000000;
              if (v36) {
                uint64_t v38 = 0x18000000000000;
              }
              uint64_t v39 = v38 | v37;
              goto LABEL_72;
            }
            break;
          }
          uint64_t v65 = 0x200000000;
          if (!v36) {
            uint64_t v65 = 0;
          }
          unint64_t v66 = *(void *)(v5 + 1376) & 0xFFFFFFFDFFFFFFFFLL;
        }
        uint64_t v39 = v66 | v65;
        goto LABEL_72;
      case 'J':
LABEL_14:
        if (!strcmp(a1, "JoinExistingSession")) {
          return;
        }
        break;
    }
    sub_10001E4BC(v5, 4, "Unknown key for Boolean: %s", v17, v18, v19, v20, v21, (char)a1);
    goto LABEL_71;
  }
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    int64_t v23 = xpc_int64_get_value(object);
    int v24 = *a1;
    if (v24 == 80 || v24 == 112)
    {
      if (!strcasecmp(a1, "PersonaEnterprise") || !strcasecmp(a1, "Platform")) {
        return;
      }
    }
    else if (v24 == 95)
    {
      unint64_t v25 = v23;
      if (!strcasecmp(a1, "_VoluntaryExitTimeOut"))
      {
        *(_DWORD *)(v5 + 864) = v25;
        return;
      }
      if (!strcasecmp(a1, "_LaunchWatchdogTimeOut"))
      {
        sub_10001E4BC(v5, 4, "setting launch watchdog timeout to %u secs from overlay", v26, v27, v28, v29, v30, v25);
        *(_DWORD *)(v5 + 868) = v25;
        return;
      }
      if (!strcasecmp(a1, "_ThrottleInterval"))
      {
        if ((v25 & 0x8000000000000000) != 0)
        {
          char v83 = (char)a1;
          int v13 = "%s less than zero. Ignoring.";
        }
        else
        {
          if (!HIDWORD(v25))
          {
            if (v25)
            {
              *(_DWORD *)(v5 + 836) = v25;
            }
            else
            {
              sub_10001E4BC(v5, 3, "_ThrottleInterval set to zero. You're not that important. Ignoring.", v8, v9, v10, v11, v12, v82);
              *(_DWORD *)(v5 + 836) = 1;
            }
            return;
          }
          char v83 = (char)a1;
          int v13 = "%s is too large. Ignoring.";
        }
        uint64_t v14 = v5;
        int v15 = 4;
        goto LABEL_10;
      }
    }
    sub_10001E4BC(v5, 4, "Unknown key for integer: %s", v8, v9, v10, v11, v12, (char)a1);
LABEL_71:
    uint64_t v39 = *(void *)(v5 + 1376) | 1;
LABEL_72:
    *(void *)(v5 + 1376) = v39;
    return;
  }
  if (type == (xpc_type_t)&_xpc_type_double)
  {
    xpc_double_get_value(object);
    sub_10001E4BC(v5, 4, "Unknown key for double: %s", v31, v32, v33, v34, v35, (char)a1);
    goto LABEL_71;
  }
  if (type == (xpc_type_t)&_xpc_type_data)
  {
    xpc_data_get_bytes_ptr(object);
    xpc_data_get_length(object);
    sub_10001E4BC(v5, 4, "Unknown key for data: %s", v40, v41, v42, v43, v44, (char)a1);
    goto LABEL_71;
  }
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    int v51 = *a1;
    if (v51 <= 94)
    {
      if (v51 == 82) {
        goto LABEL_62;
      }
      if (v51 == 83)
      {
LABEL_56:
        unint64_t v58 = "ServiceType";
        goto LABEL_63;
      }
    }
    else
    {
      if (v51 != 95)
      {
        if (v51 != 114)
        {
          if (v51 != 115) {
            goto LABEL_64;
          }
          goto LABEL_56;
        }
LABEL_62:
        unint64_t v58 = "RunLoopType";
LABEL_63:
        if (sub_100015D70(a1, v58)) {
          return;
        }
        goto LABEL_64;
      }
      BOOL v67 = (char *)string_ptr;
      if (sub_100015DB0(a1, "_RoleAccount"))
      {
        if (sub_100015D70(v67, "root"))
        {
          uint64_t v39 = *(void *)(v5 + 1376) | 0x80000;
          goto LABEL_72;
        }
        BOOL v73 = (char **)(v5 + 800);
LABEL_102:
        *(void *)(v5 + 592) += strlen(v67) + 1;
        int v74 = j__strdup(v67);
        char *v73 = v74;
        if (!v74)
        {
          sub_10001E4BC(v5, 3, "Could not set string argument for key: %s", v75, v76, v77, v78, v79, (char)a1);
          goto LABEL_71;
        }
        return;
      }
      if (sub_100015DB0(a1, "_SandboxProfile"))
      {
        sub_10000675C(v5, v67);
        return;
      }
      if (sub_100015DB0(a1, "_SandboxContainer"))
      {
        BOOL v73 = (char **)(v5 + 472);
        goto LABEL_102;
      }
      if (sub_100015DB0(a1, "_ProcessType")) {
        return;
      }
      if (sub_100015D70(a1, "_Cryptex"))
      {
        sub_100007908(v5, v67);
        uint64_t v39 = *(void *)(v5 + 1376) | 0x1000000000000000;
        goto LABEL_72;
      }
      if (sub_100015D70(a1, "_ManagedBy"))
      {
        xpc_object_t v81 = xpc_string_create(v67);
        sub_100040028(v5, v81);
        xpc_release(v81);
        return;
      }
      if (sub_100015D70(a1, "_Conclave"))
      {
        sub_1000088EC(v5, v67);
        return;
      }
    }
LABEL_64:
    sub_10001E4BC(v5, 4, "Unknown key for string: %s", v46, v47, v48, v49, v50, (char)a1);
    goto LABEL_71;
  }
  if (type != (xpc_type_t)&_xpc_type_array)
  {
    if (type != (xpc_type_t)&_xpc_type_dictionary)
    {
      char v83 = (char)a1;
      xpc_type_get_name(type);
      int v13 = "Invalid type for service dictionary (key/type): %s/%s";
LABEL_9:
      uint64_t v14 = v5;
      int v15 = 3;
LABEL_10:
      sub_10001E4BC(v14, v15, v13, v8, v9, v10, v11, v12, v83);
      return;
    }
    __darwin_ct_rune_t v59 = __tolower(*a1);
    if (v59 != 95)
    {
      if (v59 == 101 && !strcmp(a1, "EnvironmentVariables"))
      {
        xpc_dictionary_apply_f();
        return;
      }
      goto LABEL_60;
    }
    if (!strcmp(a1, "_LaunchEvents"))
    {
      char v83 = (char)a1;
      int v13 = "The %s key is not yet implemented. %s";
      goto LABEL_9;
    }
    if (!strcmp(a1, "_AdditionalServices"))
    {
      sub_10001E4BC(v5, 3, "The %s key is no longer respected. %s", v68, v69, v70, v71, v72, (char)a1);
      v85[0] = _NSConcreteStackBlock;
      v85[1] = 0x40000000;
      v85[2] = sub_100008A08;
      v85[3] = &unk_10006D248;
      v85[4] = v5;
      v85[5] = v6;
      unint64_t v80 = v85;
    }
    else
    {
      if (strcmp(a1, "_AdditionalSubServices"))
      {
        if (!strcasecmp(a1, "_AdditionalProperties"))
        {
          *(void *)(v5 + 640) = xpc_retain(object);
          return;
        }
LABEL_60:
        sub_10001E4BC(v5, 4, "Unknown key for dictionary: %s", v60, v61, v62, v63, v64, (char)a1);
        goto LABEL_71;
      }
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = sub_100008A2C;
      applier[3] = &unk_10006D268;
      applier[4] = v5;
      void applier[5] = v6;
      unint64_t v80 = applier;
    }
    xpc_dictionary_apply(object, v80);
    return;
  }
  __darwin_ct_rune_t v52 = __tolower(*a1);
  if (v52 == 112)
  {
    if (sub_100015D70(a1, "ProgramArguments")) {
      return;
    }
    goto LABEL_70;
  }
  if (v52 != 95)
  {
LABEL_70:
    sub_10001E4BC(v5, 4, "Unknown key for array: %s", v53, v54, v55, v56, v57, (char)a1);
    goto LABEL_71;
  }
  if (!strcmp(a1, "_AdditionalServices"))
  {
    sub_100008968(v5, a1, (uint64_t)&_xpc_BOOL_true, v6);
  }
  else
  {
    if (!strcmp(a1, "_AllowedClients")) {
      return;
    }
    if (strcmp(a1, "_ManagedBy"))
    {
      if (!strcmp(a1, "_ManagedBy_Services"))
      {
        sub_10004013C(v5, object);
        return;
      }
      goto LABEL_70;
    }
    sub_100040028(v5, object);
  }
}

void sub_10000875C(uint64_t a1, xpc_object_t xdict)
{
  if ((*(void *)(a1 + 1376) & 0x400000000) != 0) {
    int v4 = 1024;
  }
  else {
    int v4 = 1536;
  }
  string = xpc_dictionary_get_string(xdict, "RunLoopType");
  if (string && !strcmp(string, "_UIApplicationMain")) {
    int v4 = 256;
  }
  *(_DWORD *)(a1 + 896) = v4;
  uint64_t v6 = (char *)xpc_dictionary_get_string(xdict, "_ProcessType");
  if (v6)
  {
    sub_10000548C(a1, v6);
  }
}

void sub_100008808(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x400) != 0)
  {
    char v8 = 3;
  }
  else if ((a2 & 0x800) != 0)
  {
    char v8 = 1;
  }
  else if ((a2 & 0x1000) != 0)
  {
    char v8 = 2;
  }
  else if ((a2 & 0x40) != 0)
  {
    char v8 = 6;
  }
  else if ((*(unsigned char *)(a1 + 1376) & 2) != 0)
  {
    char v8 = 5;
  }
  else if ((a2 & 0x40000) != 0)
  {
    char v8 = 7;
  }
  else
  {
    if ((a2 & 0x200) == 0)
    {
      sub_10001E4BC(a1, 3, "Unknown service type. flags: %llx", a4, a5, a6, a7, a8, a2);
      return;
    }
    char v8 = 4;
  }
  *(unsigned char *)(a1 + 356) = v8;
}

uint64_t sub_100008894(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 896);
  if (v1 == 256)
  {
    uint64_t v2 = *(void *)(result + 1384);
    uint64_t v3 = *(void *)(result + 1376);
    *(void *)(result + 1376) = v3 | 0x2000000;
    if ((v3 & 0x2000000000000000) == 0)
    {
      *(_DWORD *)(result + 900) = 1;
      *(void *)(result + 1384) = v2;
      *(void *)(result + 1376) = v3 | 0x2000000002000000;
    }
  }
  else if (v1 == 1792)
  {
    *(void *)(result + 1376) |= 0x100000000000000uLL;
  }
  return result;
}

void sub_1000088EC(uint64_t a1, char *__s)
{
  if (strlen(__s) < 0x80)
  {
    uint64_t v9 = *(void **)(a1 + 1368);
    if (v9)
    {
      free(v9);
      *(void *)(a1 + 1368) = 0;
    }
    *(void *)(a1 + 1368) = sub_1000159F0(__s);
  }
  else
  {
    sub_10001E4BC(a1, 3, "%s failed: conclave id too long", v4, v5, v6, v7, v8, (char)"_launch_service_set_conclave");
  }
}

void sub_100008968(uint64_t a1, char *__s1, uint64_t a3, unsigned char *a4)
{
  if ((*(unsigned char *)(a1 + 1380) & 0x40) != 0 && !strcmp(__s1, (const char *)(a1 + 1392)))
  {
    sub_100014CD8(a4, 4, "MachService endpoint name specified was same as implicitly created endpoint: %s", __s1);
  }
  else if ((*(uint64_t (**)(uint64_t, char *, uint64_t, void, unsigned char *, void))(a1 + 544))(a1, __s1, a3, 0, a4, *(void *)(a1 + 568)))
  {
    return;
  }
  *(void *)(a1 + 1376) |= 1uLL;
}

uint64_t sub_100008A08(uint64_t a1, char *a2, uint64_t a3)
{
  return 1;
}

uint64_t sub_100008A2C(uint64_t a1, const char *a2, uint64_t a3)
{
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v5 = (const char *)(*(void *)(a1 + 32) + 1392);
  *(_OWORD *)__str = 0u;
  long long v8 = 0u;
  snprintf(__str, 0x200uLL, "%s.%s", v5, a2);
  sub_100008968(*(void *)(a1 + 32), __str, a3, *(unsigned char **)(a1 + 40));
  return 1;
}

uint64_t sub_100008B04(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2000000000;
  char v7 = 0;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_100009798;
  applier[3] = &unk_10006D290;
  applier[4] = &v4;
  xpc_dictionary_apply(a1, applier);
  uint64_t v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

size_t sub_100008BA8(void *a1)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v3 = 0;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v3);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string && (sub_100008BA8(value) & 1) != 0) {
          break;
        }
        if (++v3 >= xpc_array_get_count(a1)) {
          return 0;
        }
      }
      return 1;
    }
  }
  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return _os_variant_check("com.apple.xpc.launchd", string_ptr);
  }
  else
  {
    return 0;
  }
  return result;
}

size_t sub_100008C90(void *a1)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v4 = 0;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v4);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string && (sub_100008C90(value) & 1) != 0) {
          break;
        }
        if (++v4 >= xpc_array_get_count(a1)) {
          return 0;
        }
      }
      return 1;
    }
  }
  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = (char *)xpc_string_get_string_ptr(a1);
    return sub_100003ECC(string_ptr);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t sub_100008D6C()
{
  uint64_t result = j___os_feature_enabled_impl();
  if (result)
  {
    return sub_10003E718("/var/mobile/Library/Accessibility/ClarityBoardEnabled");
  }
  return result;
}

size_t sub_100008DB8(void *a1, unsigned char *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_100040D80((uint64_t)string_ptr);
  }
  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v6 = 0;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v6);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
        {
          long long v8 = xpc_string_get_string_ptr(value);
          if (sub_100040D80((uint64_t)v8)) {
            return 1;
          }
        }
        else
        {
          sub_100014CD8(a2, 4, "Unsupported type for index %lu of _LimitLoadToDeviceTree", v6);
        }
        if (++v6 >= xpc_array_get_count(a1)) {
          return 0;
        }
      }
    }
  }
  else
  {
    sub_100014CD8(a2, 4, "Unsupported type for _LimitLoadToDeviceTree");
    return 0;
  }
  return result;
}

size_t sub_100008EE4(void *a1, unsigned char *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_10004A1E8((uint64_t)string_ptr);
  }
  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    size_t result = xpc_array_get_count(a1);
    if (result)
    {
      size_t v6 = 0;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a1, v6);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
        {
          if (sub_100008EE4(value, a2)) {
            return 1;
          }
        }
        else
        {
          sub_100014CD8(a2, 4, "Unsupported type for index: %lu of _LimitLoadToBootarg", v6);
        }
        if (++v6 >= xpc_array_get_count(a1)) {
          return 0;
        }
      }
    }
  }
  else
  {
    sub_100014CD8(a2, 4, "Unsupported type for _LimitLoadToBootarg");
    return 0;
  }
  return result;
}

char *sub_100009010(void *a1, char *a2, uint64_t a3, unint64_t a4, uint64_t a5, int *a6, unsigned char *a7)
{
  long long v14 = xpc_dictionary_get_string(a1, "Label");
  if (!v14) {
    sub_100050D0C();
  }
  long long v15 = (char *)v14;
  long long v16 = xpc_dictionary_get_string(a1, "Program");
  long long v17 = v16;
  if (v16)
  {
    uint64_t v64 = a5;
    string = a2;
    long long v18 = (char *)v16;
    if (*v16 == 47)
    {
LABEL_4:
      xpc_object_t value = xpc_dictionary_get_value(a1, "ProgramArguments");
      goto LABEL_5;
    }
    uint64_t v29 = a3;
    BOOL v30 = xpc_dictionary_get_BOOL(a1, "ResolveProgramIdentifier");
    long long v31 = (char *)xpc_dictionary_get_string(a1, "BundleProgram");
    if (v30 || v31)
    {
      a3 = v29;
      if (!v31 || sub_100015D70(v31, v17)) {
        goto LABEL_4;
      }
      sub_100014CD8(a7, 3, "BundleProgram(%s) is not the same as Program(%s). Bug in ServiceManagement?");
    }
    else
    {
      sub_100014CD8(a7, 3, "Service specifies non-absolute Program path.");
    }
    goto LABEL_55;
  }
  xpc_object_t v28 = xpc_dictionary_get_value(a1, "ProgramArguments");
  if (!v28 || (xpc_object_t value = v28, xpc_get_type(v28) != (xpc_type_t)&_xpc_type_array))
  {
    sub_100014CD8(a7, 3, "Service specifies neither Program nor ProgramArguments.");
LABEL_55:
    long long v18 = 0;
    goto LABEL_56;
  }
  if (!xpc_array_get_count(value))
  {
    sub_100014CD8(a7, 3, "Service specifies no Program and empty ProgramArguments.");
    goto LABEL_55;
  }
  uint64_t v64 = a5;
  string = a2;
  long long v18 = (char *)xpc_array_get_string(value, 0);
  if (!v18)
  {
    sub_100014CD8(a7, 3, "Service does not specify a valid argument array.");
LABEL_56:
    int v37 = 111;
LABEL_57:
    *a6 = v37;
    return v18;
  }
LABEL_5:
  xpc_object_t v20 = xpc_dictionary_get_value(a1, "ProcessType");
  if (v20) {
    xpc_dictionary_set_value(a1, "POSIXSpawnType", v20);
  }
  if ((a4 & 0x400) != 0) {
    xpc_dictionary_set_BOOL(a1, "__Angel", 1);
  }
  long long v21 = (char *)xpc_dictionary_get_string(a1, "POSIXSpawnType");
  if (sub_100015D70(v21, "Driver") && (sub_10000FE40(a3, 24) & 1) == 0)
  {
    if (a3) {
      int v32 = *(_DWORD *)(a3 + 20);
    }
    else {
      int v32 = 0;
    }
    sub_100014CD8(a7, 3, "Service (pid %d) does not have spawn driver entitlement", v32);
    long long v18 = 0;
    int v37 = 144;
    goto LABEL_57;
  }
  uint64_t v62 = (_OWORD *)a3;
  if ((a4 & 0x200) == 0 && xpc_dictionary_get_string(a1, "_JetsamPropertiesIdentifier"))
  {
    sub_100014CD8(a7, 3, "Ignoring _JetsamPropertiesIdentifier on a service which isn't submitted");
    xpc_dictionary_set_value(a1, "_JetsamPropertiesIdentifier", 0);
  }
  xpc_object_t v22 = sub_10000EDA0(a1);
  sub_10000E6A8(v22, a7);
  sub_100007D48(a1, v22, a7, 0);
  xpc_object_t v23 = xpc_dictionary_get_value(v22, "ExecuteAllowed");
  if (v23)
  {
    long long v24 = v23;
    if (xpc_get_type(v23) == (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL v33 = xpc_BOOL_get_value(v24);
      if ((a4 & 0x200) == 0 && !v33)
      {
        int v34 = 157;
LABEL_40:
        *a6 = v34;
        xpc_release(v22);
        return 0;
      }
    }
  }
  xpc_object_t v25 = xpc_dictionary_get_value(a1, "_StandardInFd");
  if (v25 && (long long v26 = v25, xpc_get_type(v25) == (xpc_type_t)&_xpc_type_fd)) {
    int v27 = xpc_fd_dup(v26);
  }
  else {
    int v27 = -1;
  }
  if (xpc_dictionary_get_string(a1, "StandardInPath") && v27 != -1)
  {
    close(v27);
    sub_100014CD8(a7, 3, "Service specifies both standard out file descriptor and path.");
    int v34 = 111;
    goto LABEL_40;
  }
  int v63 = v27;
  xpc_object_t v35 = xpc_dictionary_get_value(a1, "_StandardOutFd");
  if (v35 && (long long v36 = v35, xpc_get_type(v35) == (xpc_type_t)&_xpc_type_fd)) {
    int v61 = xpc_fd_dup(v36);
  }
  else {
    int v61 = -1;
  }
  if (xpc_dictionary_get_string(a1, "StandardOutPath") && v61 != -1)
  {
    close(v61);
    sub_100014CD8(a7, 3, "Service specifies both standard out file descriptor and path.");
    *a6 = 111;
    xpc_release(v22);
    if (v63 == -1) {
      return 0;
    }
    int v38 = v63;
LABEL_77:
    close(v38);
    return 0;
  }
  xpc_object_t v39 = xpc_dictionary_get_value(a1, "_StandardErrorFd");
  if (v39 && (uint64_t v40 = v39, xpc_get_type(v39) == (xpc_type_t)&_xpc_type_fd)) {
    int v60 = xpc_fd_dup(v40);
  }
  else {
    int v60 = -1;
  }
  if (xpc_dictionary_get_string(a1, "StandardErrorPath") && v60 != -1)
  {
    close(v60);
    sub_100014CD8(a7, 3, "Service specifies both standard out file descriptor and path.");
    *a6 = 111;
    xpc_release(v22);
    if (v63 != -1) {
      close(v63);
    }
    int v38 = v61;
    goto LABEL_76;
  }
  uint64_t v41 = sub_10001DF10((uint64_t)v15, v18, string);
  long long v18 = sub_10000750C(v41, v62, v15, value, v64, a4, a6, a7);
  sub_10001A174(v41);
  if (!v18)
  {
    xpc_release(v22);
    if (v63 != -1) {
      close(v63);
    }
    if (v61 != -1) {
      close(v61);
    }
    int v38 = v60;
LABEL_76:
    if (v38 == -1) {
      return 0;
    }
    goto LABEL_77;
  }
  int v42 = sub_10000FE40((uint64_t)v62, 3);
  uint64_t v43 = *((void *)v18 + 172);
  if (v42) {
    v43 |= 0x8000000000uLL;
  }
  *((void *)v18 + 172) = v43 & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)(v17 == 0) << 24);
  uint64_t v44 = sub_10001A054(v18, 1, (uint64_t)a7, 0);
  xpc_dictionary_apply_f();
  sub_10001A12C(v44);
  if (*((void *)v18 + 81))
  {
    *((void *)v18 + 82) = xpc_retain(a1);
    *((void *)v18 + 83) = xpc_string_create(string);
  }
  sub_10000E820((uint64_t)v18, v22, (uint64_t)a7);
  nullsub_23(v18, v22);
  xpc_release(v22);
  uint64_t v51 = *((void *)v18 + 173);
  uint64_t v52 = *((void *)v18 + 172);
  if ((v52 & 0x80000000) != 0)
  {
    int v53 = v63;
    int v55 = v60;
    int v54 = v61;
    if (!*((void *)v18 + 100))
    {
      v52 &= ~0x80000000uLL;
      *((void *)v18 + 173) = v51;
      *((void *)v18 + 172) = v52;
    }
  }
  else
  {
    int v53 = v63;
    int v55 = v60;
    int v54 = v61;
  }
  uint64_t v57 = a4 & 0x10 | v52 & 0x20000;
  if (v57) {
    v52 |= 0x200000uLL;
  }
  unint64_t v58 = v52 & 0x20000000;
  unint64_t v59 = v52 | (v58 >> 7);
  if (v57 || v58)
  {
    *((void *)v18 + 172) = v59;
    *((void *)v18 + 173) = v51;
  }
  if (((v58 == 0) & ~v42) == 0 && *((_DWORD *)v18 + 224) != 1792)
  {
    *((_DWORD *)v18 + 224) = 256;
    if (v58) {
      *((_DWORD *)v18 + 230) = 160;
    }
    *((void *)v18 + 173) = v51;
    *((void *)v18 + 172) = v59 & 0xFFFFFFFFFFFFECFFLL | 0x1000;
  }
  if (v53 != -1) {
    *((_DWORD *)v18 + 172) = v53;
  }
  if (v54 != -1) {
    *((_DWORD *)v18 + 173) = v54;
  }
  if (v55 != -1) {
    *((_DWORD *)v18 + 174) = v55;
  }
  sub_100008808((uint64_t)v18, a4, v45, v46, v47, v48, v49, v50);
  if ((v18[1383] & 4) != 0) {
    sub_100024EC4((uint64_t)v18, 15);
  }
  sub_100008894((uint64_t)v18);
  return v18;
}

void sub_100009730(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 1379) & 0x20) != 0)
  {
    uint64_t v9 = *(void *)(a2 + 72);
    if (v9)
    {
      sub_10001E4BC(a1, 3, "Service tried to claim home screen from: %s", a4, a5, a6, a7, a8, v9 + 112);
      *(void *)(a1 + 1376) &= ~0x20000000uLL;
    }
    else
    {
      *(void *)(a2 + 72) = a1;
    }
  }
}

uint64_t sub_100009798(uint64_t a1, const char *a2, void *a3)
{
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(_OWORD *)__str = 0u;
  long long v9 = 0u;
  snprintf(__str, 0x80uLL, "hw.%s", a2);
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(a3))
    {
      size_t v6 = 0;
      while (1)
      {
        xpc_object_t value = xpc_array_get_value(a3, v6);
        if (sub_1000098A8(__str, value)) {
          break;
        }
        if (++v6 >= xpc_array_get_count(a3)) {
          return 1;
        }
      }
      goto LABEL_3;
    }
  }
  else if (sub_1000098A8(__str, a3))
  {
LABEL_3:
    uint64_t result = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return result;
  }
  return 1;
}

size_t sub_1000098A8(const char *a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_string)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_int64)
    {
      __s2[0] = 0;
      if (sub_100042BE4(a1, __s2))
      {
        xpc_object_t value = (char *)xpc_int64_get_value(object);
        return value == __s2[0];
      }
    }
    else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
    {
      __s2[0] = 0;
      __s2[1] = 0;
      size_t v13 = 16;
      int v4 = sysctlbyname(a1, __s2, &v13, 0, 0);
      size_t v5 = 0;
      if (v4 != -1 && v13)
      {
        BOOL v6 = xpc_BOOL_get_value(object);
        BOOL v8 = v13 < 9 && __s2[0] == 0;
        return v6 ^ v8;
      }
      return v5;
    }
    return 0;
  }
  __s2[0] = 0;
  size_t v5 = sub_100042A54(a1, __s2);
  if (v5)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    long long v10 = __s2[0];
    size_t v5 = strncmp(string_ptr, __s2[0], v5) == 0;
    free(v10);
  }
  return v5;
}

uint64_t sub_100009A1C(const char *a1, void *a2, uint64_t *a3)
{
  size_t v3 = a2;
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  char v7 = (uint64_t *)qword_100075B98;
  if (!qword_100075B98)
  {
    qword_100075B98 = (uint64_t)sub_10000DA38("plist");
    sub_10000DAE8(qword_100075B98, "AbandonProcessGroup", (char *)&stru_10006D2D0);
    sub_10000DAE8(qword_100075B98, "AuxiliaryBootstrapper", (char *)&stru_10006D310);
    sub_10000DAE8(qword_100075B98, "AuxiliaryBootstrapperAllowDemand", (char *)&stru_10006D350);
    sub_10000DD94(qword_100075B98, "AlwaysSIGTERMOnShutdown");
    sub_10000DAE8(qword_100075B98, "BootShell", (char *)&stru_10006D390);
    sub_10000DAE8(qword_100075B98, "DisabledInSafeBoot", (char *)&stru_10006D3D0);
    sub_10000DAE8(qword_100075B98, "KeepAlive", (char *)&stru_10006D410);
    sub_10000DAE8(qword_100075B98, "OnDemand", (char *)&stru_10006D450);
    sub_10000DAE8(qword_100075B98, "Debug", (char *)&stru_10006D490);
    sub_10000DD94(qword_100075B98, "Disabled");
    sub_10000DAE8(qword_100075B98, "DisableASLR", (char *)&stru_10006D4D0);
    sub_10000DAE8(qword_100075B98, "DisallowAllLookups", (char *)&stru_10006D510);
    sub_10000DAE8(qword_100075B98, "DrainMessagesOnFailedInit", (char *)&stru_10006D550);
    sub_10000DAE8(qword_100075B98, "DisableReslide", (char *)&stru_10006D590);
    sub_10000DAE8(qword_100075B98, "HopefullyExitsLast", (char *)&stru_10006D5D0);
    sub_10000DAE8(qword_100075B98, "SessionCreate", (char *)&stru_10006D610);
    sub_10000DAE8(qword_100075B98, "StartOnMount", (char *)&stru_10006D650);
    sub_10000DAE8(qword_100075B98, "ServiceIPC", (char *)&stru_10006D690);
    sub_10000DAE8(qword_100075B98, "ShutdownMonitor", (char *)&stru_10006D6D0);
    sub_10000DAE8(qword_100075B98, "LowPriorityIO", (char *)&stru_10006D710);
    sub_10000DAE8(qword_100075B98, "LowPriorityBackgroundIO", (char *)&stru_10006D750);
    sub_10000DAE8(qword_100075B98, "LegacyTimers", (char *)&stru_10006D790);
    sub_10000DAE8(qword_100075B98, "LaunchOnlyOnce", (char *)&stru_10006D7D0);
    sub_10000DAE8(qword_100075B98, "MachExceptionHandler", (char *)&stru_10006D810);
    sub_10000DAE8(qword_100075B98, "MultipleInstances", (char *)&stru_10006D850);
    sub_10000DAE8(qword_100075B98, "MaterializeDatalessFiles", (char *)&stru_10006D890);
    sub_10000DD94(qword_100075B98, "MinimalBootProfile");
    sub_10000DAE8(qword_100075B98, "InitGroups", (char *)&stru_10006D8D0);
    sub_10000DAE8(qword_100075B98, "IgnoreProcessGroupAtShutdown", (char *)&stru_10006D910);
    sub_10000DAE8(qword_100075B98, "RunAtLoad", (char *)&stru_10006D950);
    sub_10000DAE8(qword_100075B98, "ResolveProgramIdentifier", (char *)&stru_10006D990);
    sub_10000DC24(qword_100075B98, "BundleProgram", (char *)&stru_10006D9D0);
    sub_10000DAE8(qword_100075B98, "ReslideSharedCache", (char *)&stru_10006DA10);
    sub_10000DAE8(qword_100075B98, "EnableGlobbing", (char *)&stru_10006DA50);
    sub_10000DAE8(qword_100075B98, "EnableTransactions", (char *)&stru_10006DA90);
    sub_10000DAE8(qword_100075B98, "EnterKernelDebuggerBeforeKill", (char *)&stru_10006DAD0);
    sub_10000DAE8(qword_100075B98, "EmbeddedHomeScreen", (char *)&stru_10006DB10);
    sub_10000DAE8(qword_100075B98, "EventMonitor", (char *)&stru_10006DB50);
    sub_10000DAE8(qword_100075B98, "_InitialSystemSupport", (char *)&stru_10006DB90);
    sub_10000DAE8(qword_100075B98, "EnablePressuredExit", (char *)&stru_10006DBD0);
    sub_10000DD94(qword_100075B98, "ExecuteAllowed");
    sub_10000DAE8(qword_100075B98, "WaitForDebugger", (char *)&stru_10006DC10);
    sub_10000DD94(qword_100075B98, "ForceEnableHack");
    sub_10000DAE8(qword_100075B98, "NSBuiltWithThreadSanitizer", (char *)&stru_10006DC50);
    sub_10000DAE8(qword_100075B98, "_NullBootstrapPort", (char *)&stru_10006DC90);
    sub_10000DD94(qword_100075B98, "_Protected");
    sub_10000DAE8(qword_100075B98, "_ExponentialThrottling", (char *)&stru_10006DCD0);
    sub_10000DD94(qword_100075B98, "__Proxyless");
    sub_10000DAE8(qword_100075B98, "_DisablePointerAuth", (char *)&stru_10006DD10);
    sub_10000DBC8(qword_100075B98, "ExitTimeOut", (char *)&stru_10006DD50);
    sub_10000DBC8(qword_100075B98, "EmbeddedMainThreadPriority", (char *)&stru_10006DD90);
    sub_10000DBC8(qword_100075B98, "CPUMonitorPercentage", (char *)&stru_10006DDD0);
    sub_10000DBC8(qword_100075B98, "CPUMonitorInterval", (char *)&stru_10006DE10);
    sub_10000DBC8(qword_100075B98, "PersonaEnterprise", (char *)&stru_10006DE50);
    sub_10000DBC8(qword_100075B98, "Platform", (char *)&stru_10006DE90);
    sub_10000DBC8(qword_100075B98, "JetsamPriority", (char *)&stru_10006DED0);
    sub_10000DBC8(qword_100075B98, "JetsamMemoryLimit", (char *)&stru_10006DF10);
    sub_10000DBC8(qword_100075B98, "Nice", (char *)&stru_10006DF50);
    sub_10000DBC8(qword_100075B98, "TimeOut", (char *)&stru_10006DF90);
    sub_10000DBC8(qword_100075B98, "ThrottleInterval", (char *)&stru_10006DFD0);
    sub_10000DBC8(qword_100075B98, "Umask", (char *)&stru_10006E010);
    sub_10000DC24(qword_100075B98, "Umask", (char *)&stru_10006E050);
    sub_10000DBC8(qword_100075B98, "StartInterval", (char *)&stru_10006E090);
    sub_10000DBC8(qword_100075B98, "SandboxFlags", (char *)&stru_10006E0D0);
    sub_10000DD94(qword_100075B98, "ActiveHardMemoryLimit");
    sub_10000DD94(qword_100075B98, "ActiveSoftMemoryLimit");
    sub_10000DD94(qword_100075B98, "InactiveHardMemoryLimit");
    sub_10000DD94(qword_100075B98, "InactiveSoftMemoryLimit");
    sub_10000DBC8(qword_100075B98, "InitialTaskRole", (char *)&stru_10006E110);
    sub_10000DC24(qword_100075B98, "CFBundleIdentifier", (char *)&stru_10006E150);
    sub_10000DC24(qword_100075B98, "ContainingBundleID", (char *)&stru_10006E190);
    sub_10000DD38(qword_100075B98, "_BTMItemUUID", (char *)&stru_10006E1D0);
    sub_10000DD38(qword_100075B98, "_LightweightCodeRequirement", (char *)&stru_10006E210);
    sub_10000DD38(qword_100075B98, "_ProvenanceData", (char *)&stru_10006E250);
    sub_10000DC24(qword_100075B98, "ContainingBundleVersion", (char *)&stru_10006E290);
    sub_10000DC24(qword_100075B98, "MachExceptionHandler", (char *)&stru_10006E2D0);
    sub_10000DC24(qword_100075B98, "MultipleInstances", (char *)&stru_10006E310);
    sub_10000DD94(qword_100075B98, "Program");
    sub_10000DC24(qword_100075B98, "POSIXSpawnType", (char *)&stru_10006E350);
    sub_10000DC24(qword_100075B98, "ProcessType", (char *)&stru_10006E350);
    sub_10000DC24(qword_100075B98, "PublishesEvents", (char *)&stru_10006E390);
    sub_10000DD94(qword_100075B98, "Label");
    sub_10000DC24(qword_100075B98, "LimitLoadToHosts", (char *)&stru_10006E3D0);
    sub_10000DC24(qword_100075B98, "LimitLoadFromHosts", (char *)&stru_10006E410);
    sub_10000DD94(qword_100075B98, "LimitLoadToSessionType");
    sub_10000DC24(qword_100075B98, "LoginWindowUserName", (char *)&stru_10006E450);
    sub_10000DC24(qword_100075B98, "RootDirectory", (char *)&stru_10006E490);
    sub_10000DC24(qword_100075B98, "WorkingDirectory", (char *)&stru_10006E4D0);
    sub_10000DC24(qword_100075B98, "UserName", (char *)&stru_10006E510);
    sub_10000DC24(qword_100075B98, "GroupName", (char *)&stru_10006E550);
    sub_10000DC24(qword_100075B98, "StandardOutPath", (char *)&stru_10006E590);
    sub_10000DC24(qword_100075B98, "StandardErrorPath", (char *)&stru_10006E5D0);
    sub_10000DC24(qword_100075B98, "StandardInPath", (char *)&stru_10006E610);
    sub_10000DC24(qword_100075B98, "SandboxProfile", (char *)&stru_10006E650);
    sub_10000DC24(qword_100075B98, "SandboxContainer", (char *)&stru_10006E690);
    sub_10000DD94(qword_100075B98, "_LimitLoadToDeviceTree");
    sub_10000DD94(qword_100075B98, "_LimitLoadFromDeviceTree");
    sub_10000DD94(qword_100075B98, "_LimitLoadToVariant");
    sub_10000DD94(qword_100075B98, "_LimitLoadFromVariant");
    sub_10000DC24(qword_100075B98, "_ResourceCoalition", (char *)&stru_10006E6D0);
    sub_10000DD94(qword_100075B98, "_LimitLoadToBootMode");
    sub_10000DD94(qword_100075B98, "_LimitLoadFromBootMode");
    sub_10000DD94(qword_100075B98, "_LimitLoadToClarityMode");
    sub_10000DD94(qword_100075B98, "_LimitLoadFromClarityMode");
    sub_10000DD94(qword_100075B98, "_LimitLoadToBootarg");
    sub_10000DD94(qword_100075B98, "_LimitLoadFromBootarg");
    sub_10000DC24(qword_100075B98, "_ManagedBy", (char *)&stru_10006E710);
    sub_10000DC80(qword_100075B98, "_ManagedBy", (char *)&stru_10006E750);
    sub_10000DC80(qword_100075B98, "_ManagedBy_Services", (char *)&stru_10006E790);
    sub_10000DC24(qword_100075B98, "_SubsystemRoot", (char *)&stru_10006E7D0);
    sub_10000DD94(qword_100075B98, "ProgramArguments");
    sub_10000DC80(qword_100075B98, "PublishesEvents", (char *)&stru_10006E810);
    sub_10000DC80(qword_100075B98, "LimitLoadToHosts", (char *)&stru_10006E870);
    sub_10000DC80(qword_100075B98, "LimitLoadFromHosts", (char *)&stru_10006E8B0);
    sub_10000DD94(qword_100075B98, "LimitLoadToSessionType");
    sub_10000DC80(qword_100075B98, "BinaryOrderPreference", (char *)&stru_10006E8F0);
    sub_10000DC80(qword_100075B98, "StartCalendarInterval", (char *)&stru_10006E930);
    sub_10000DC80(qword_100075B98, "QueueDirectories", (char *)&stru_10006E970);
    sub_10000DC80(qword_100075B98, "WatchPaths", (char *)&stru_10006E9B0);
    sub_10000DCDC(qword_100075B98, "Policies", (char *)&stru_10006E9F0);
    sub_10000DCDC(qword_100075B98, "PublishesEvents", (char *)&stru_10006EA30);
    sub_10000DCDC(qword_100075B98, "KeepAlive", (char *)&stru_10006EA90);
    sub_10000DCDC(qword_100075B98, "inetdCompatibility", (char *)&stru_10006EAF0);
    sub_10000DCDC(qword_100075B98, "JetsamProperties", (char *)&stru_10006EB30);
    sub_10000DCDC(qword_100075B98, "EnvironmentVariables", (char *)&stru_10006EB70);
    sub_10000DCDC(qword_100075B98, "UserEnvironmentVariables", (char *)&stru_10006EBB0);
    sub_10000DCDC(qword_100075B98, "Sockets", (char *)&stru_10006EBF0);
    sub_10000DCDC(qword_100075B98, "StartCalendarInterval", (char *)&stru_10006EC50);
    sub_10000DCDC(qword_100075B98, "SoftResourceLimits", (char *)&stru_10006EC90);
    sub_10000DCDC(qword_100075B98, "SandboxFlags", (char *)&stru_10006ECD0);
    sub_10000DCDC(qword_100075B98, "HardResourceLimits", (char *)&stru_10006ED10);
    sub_10000DCDC(qword_100075B98, "MachServices", (char *)&stru_10006ED50);
    sub_10000DCDC(qword_100075B98, "LaunchEvents", (char *)&stru_10006EDB0);
    sub_10000DD94(qword_100075B98, "LimitLoadToHardware");
    sub_10000DD94(qword_100075B98, "LimitLoadFromHardware");
    sub_10000DCDC(qword_100075B98, "Datastores", (char *)&stru_10006EE10);
    sub_10000DCDC(qword_100075B98, "RemoteServices", (char *)&stru_10006EE70);
    sub_10000DCDC(qword_100075B98, "_AdditionalProperties", (char *)&stru_10006EED0);
    sub_10000DC24(qword_100075B98, "_PersistToBootMode", (char *)&stru_10006EF10);
    sub_10000DC80(qword_100075B98, "_PersistToBootMode", (char *)&stru_10006EF50);
    sub_10000DD38(qword_100075B98, "_DextCheckInPort", (char *)&stru_10006EF90);
    sub_10000DAE8(qword_100075B98, "__Angel", (char *)&stru_10006EFD0);
    sub_10000DD94(qword_100075B98, "_StandardInFd");
    sub_10000DD94(qword_100075B98, "_StandardOutFd");
    sub_10000DD94(qword_100075B98, "_StandardErrorFd");
    sub_10000DAE8(qword_100075B98, "_PanicOnCrash", (char *)&stru_10006F010);
    sub_10000DCDC(qword_100075B98, "_PanicOnCrash", (char *)&stru_10006F050);
    sub_10000DC24(qword_100075B98, "_Cryptex", (char *)&stru_10006F090);
    sub_10000DC24(qword_100075B98, "_Conclave", (char *)&stru_10006F0D0);
    sub_10000DD94(qword_100075B98, "AssociatedBundleIdentifiers");
    sub_10000DBC8(qword_100075B98, "_LaunchType", (char *)&stru_10006F110);
    sub_10000DCDC(qword_100075B98, "SpawnConstraint", (char *)&stru_10006F150);
    sub_10000DAE8(qword_100075B98, "_NeedsSystemThreadGroup", (char *)&stru_10006F190);
    size_t v3 = a2;
    char v7 = (uint64_t *)qword_100075B98;
  }
  uint64_t result = sub_10000DEA8(v7, v5, a1, v3, v6);
  if ((result & 1) == 0) {
    *(void *)(v5 + 1376) |= 1uLL;
  }
  return result;
}

void sub_10000A804(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x10000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFEFFFFLL | v4;
}

void sub_10000A834(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3)
  {
    sub_10001E4BC((uint64_t)a2, 5, "This service is defined to be constantly running and is inherently inefficient.", (uint64_t)a4, v4, v5, v6, v7, v9);
    *((void *)&a2->var4 + 125) |= 4uLL;
  }
}

void sub_10000A87C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3)
  {
    sub_10001E4BC((uint64_t)a2, 5, "This key does not do anything: OnDemand", (uint64_t)a4, v4, v5, v6, v7, v11);
  }
  else
  {
    sub_10001E4BC((uint64_t)a2, 5, "Please switch away from OnDemand to KeepAlive.", (uint64_t)a4, v4, v5, v6, v7, v9);
    *((void *)&a2->var4 + 125) |= 4uLL;
  }
}

void sub_10000A8EC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"Debug");
}

void sub_10000A930(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"DisableASLR");
}

void sub_10000A974(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x80000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFF7FFFFFFFFFFLL | v4;
}

void sub_10000A994(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x1000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFEFFFFFFFFFLL | v4;
}

void sub_10000A9B4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x20000000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFDFFFFFFFFFFFFFLL | v4;
}

void sub_10000A9D4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"HopefullyExitsLast");
}

void sub_10000AA20(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"ServiceIPC");
}

void sub_10000AA64(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"ShutdownMonitor");
}

void sub_10000AAA8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 32;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFFDFLL | v4;
}

void sub_10000AAC8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 64;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFFBFLL | v4;
}

void sub_10000AAEC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x100000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFEFFFFFLL | v4;
}

void sub_10000AB0C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 128;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFF7FLL | v4;
}

void sub_10000AB2C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  a2->var4.var92 = a3;
}

void sub_10000AB34(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    unsigned __int8 v4 = 2;
  }
  else {
    unsigned __int8 v4 = 1;
  }
  a2->var4.var89 = v4;
}

void sub_10000AB48(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x80000000;
  if (a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFF7FFFFFFFLL | v4;
}

void sub_10000AB68(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is not yet implemented. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"IgnoreProcessGroupAtShutdown");
}

void sub_10000ABAC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 16;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFFEFLL | v4;
}

void sub_10000ABD4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  a2->var4.var83.var0 = a3;
}

void sub_10000ABDC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"EnableGlobbing");
}

void sub_10000AC24(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 1024;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFBFFLL | v4;
}

void sub_10000AC44(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 125) |= 0x20000000uLL;
}

void sub_10000AC54(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x20000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFDFFFFLL | v4;
}

void sub_10000AC74(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x400000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFBFFFFFLL | v4;
}

void sub_10000AC98(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 2048;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFF7FFLL | v4;
}

void sub_10000ACB8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x1000000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFEFFFFFFFFFFFFLL | v4;
}

void sub_10000ACD8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x4000000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFBFFFFFFFFFFFFLL | v4;
}

void sub_10000ACF8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x8000000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFF7FFFFFFFFFFFFLL | v4;
  a2->var4.var80 = 3;
}

void sub_10000AD20(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v8 = *((void *)&a2->var4 + 125);
  if ((v8 & 0x40000000000) != 0)
  {
    uint64_t v9 = 0x80000000000000;
    if (!a3) {
      uint64_t v9 = 0;
    }
    *((void *)&a2->var4 + 126) = *((void *)&a2->var4 + 126);
    *((void *)&a2->var4 + 125) = v8 & 0xFF7FFFFFFFFFFFFFLL | v9;
  }
  else
  {
    sub_10001E4BC((uint64_t)a2, 3, "%s not permitted to be set on non-submitted jobs", (uint64_t)a4, v4, v5, v6, v7, (char)"_DisablePointerAuth");
  }
}

void sub_10000AD88(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  if (a3 < 0)
  {
    sub_10001E4BC((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ExitTimeOut");
  }
  else
  {
    unsigned int v9 = a3;
    if ((unint64_t)a3 >> 31)
    {
      sub_10001E4BC((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ExitTimeOut");
    }
    else
    {
      int v10 = a3 + dword_100075A94 + 2;
      if (dword_100075A9C) {
        BOOL v11 = v10 <= dword_100075A9C;
      }
      else {
        BOOL v11 = 1;
      }
      if (!v11)
      {
        sub_10001E4BC((uint64_t)a2, 4, "Service has increased maximum shutdown time to %d seconds. This will create a poor experience for the user.", (uint64_t)a4, v4, v5, v6, v7, a3 + dword_100075A94 + 2);
        dword_100075A9C = v10;
      }
      a2->var4.var44 = v9;
    }
  }
}

void sub_10000AE5C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var88 = a3;
  *((void *)&a2->var4 + 125) |= 0x400000000000uLL;
}

void sub_10000AE74(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"JetsamPriority");
}

void sub_10000AEB8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"JetsamMemoryLimit");
}

void sub_10000AF00(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"TimeOut");
}

void sub_10000AF44(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  if (a3 < 0)
  {
    sub_10001E4BC((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ThrottleInterval");
  }
  else if (HIDWORD(a3))
  {
    sub_10001E4BC((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ThrottleInterval");
  }
  else if (a3)
  {
    a2->var4.var45 = a3;
  }
  else
  {
    sub_10001E4BC((uint64_t)a2, 3, "ThrottleInterval set to zero. You're not that important. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, v9);
    a2->var4.var45 = 1;
  }
}

void sub_10000AFDC(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 125) |= (unint64_t)&_mh_execute_header;
  a2->var4.var41 = a3;
}

void sub_10000AFF0(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  unsigned __int16 v5 = strtoul(a3, 0, 0);
  *((void *)&a2->var4 + 125) |= (unint64_t)&_mh_execute_header;
  a2->var4.var41 = v5;
}

void sub_10000B030(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var52 = a3;
}

void sub_10000B038(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"SandboxFlags");
}

void sub_10000B07C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var55 = a3;
  *((void *)&a2->var4 + 125) |= 0x2000000000000000uLL;
}

void sub_10000B090(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var16 = sub_1000159F0(a3);
}

void sub_10000B0C8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_data)
  {
    xpc_type_t type = xpc_get_type(a3);
    xpc_type_get_name(type);
    sub_100014CD8(a4, 3, "Invalid type (%s) for _ProvenanceData");
LABEL_8:
    *((void *)&a2->var4 + 125) |= 1uLL;
    return;
  }
  if (xpc_data_get_length(a3) >> 32)
  {
    sub_100014CD8(a4, 3, "Provenance data too big: %zu");
    goto LABEL_8;
  }

  sub_100020330(a2, a3);
}

void sub_10000B198(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var53 = sub_1000159F0(a3);
}

void sub_10000B1C4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (sub_100015D70(a3, "Managed"))
  {
    a2->var4.var92 = 2;
    sub_100024EC4((uint64_t)a2, 16);
  }
  else
  {
    sub_100014CD8(a4, 3, "Invalid value for MultipleInstances '%s'", a3);
  }
}

void sub_10000B25C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_10000B268(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v7 = xpc_BOOL_create(1);

  sub_10000B2C0((uint64_t)a2, a3, v7, (uint64_t)a4);
}

void sub_10000B2C0(uint64_t a1, const char *a2, xpc_object_t object, uint64_t a4)
{
  if (!*(void *)(a1 + 504)) {
    *(void *)(a1 + 504) = xpc_dictionary_create(0, 0, 0);
  }
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (xpc_BOOL_get_value(object))
    {
      uint64_t v8 = *(void **)(a1 + 504);
      xpc_dictionary_set_uint64(v8, a2, 0);
    }
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v10 = 0;
    BOOL v11 = &v10;
    uint64_t v12 = 0x2000000000;
    int v13 = 0;
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_10000D010;
    applier[3] = &unk_10006F1B8;
    applier[4] = &v10;
    void applier[5] = a4;
    void applier[6] = a1;
    xpc_dictionary_apply(object, applier);
    xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 504), a2, *((unsigned int *)v11 + 6));
    _Block_object_dispose(&v10, 8);
  }
}

void sub_10000B418(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadToHosts");
}

void sub_10000B45C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadFromHosts");
}

void sub_10000B4A0(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var39 = sub_1000159F0(a3);
  a2->var4.var18 += strlen(a3) + 1;
  *((void *)&a2->var4 + 125) |= 0x40000000000000uLL;
}

void sub_10000B4F4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is not yet implemented. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"RootDirectory");
}

void sub_10000B538(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000159F0(a3);
  a2->var4.var5 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000B578(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (strcmp(a3, "root"))
  {
    a2->var4.var39 = sub_1000159F0(a3);
    a2->var4.var18 += strlen(a3) + 1;
  }
}

void sub_10000B5D4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (strcmp(a3, "wheel"))
  {
    a2->var4.var40 = sub_1000159F0(a3);
    a2->var4.var18 += strlen(a3) + 1;
  }
}

void sub_10000B630(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000159F0(a3);
  a2->var4.var7 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000B670(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000159F0(a3);
  a2->var4.var8 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000B6B0(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v5 = sub_1000159F0(a3);
  a2->var4.var6 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000B6F0(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_10000B6FC(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var9 = sub_1000159F0(a3);
  a2->var4.var18 += strlen(a3) + 1;
}

void sub_10000B744(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var3.var19 = sub_1000159F0(a3);
}

void sub_10000B770(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5 = xpc_string_create(a3);
  sub_100040028((uint64_t)a2, v5);

  xpc_release(v5);
}

void sub_10000B7BC(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_10000B7C8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_10000B7D4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5 = sub_100015BE4("%s/", a3);
  a2->var4.var11 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000B824(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000B894;
  v4[3] = &unk_10006E830;
  v4[4] = a2;
  v4[5] = a4;
  xpc_array_apply(a3, v4);
}

uint64_t sub_10000B894(uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(object);
    xpc_object_t v10 = xpc_BOOL_create(1);
    sub_10000B2C0(v8, string_ptr, v10, *(void *)(a1 + 40));
  }
  else
  {
    xpc_object_t v5 = *(unsigned char **)(a1 + 40);
    xpc_type_t type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100014CD8(v5, 3, "Invalid item type %s in PublishesEvents, expected string", name);
    *(void *)(*(void *)(a1 + 32) + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000B94C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadToHosts");
}

void sub_10000B990(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadFromHosts");
}

void sub_10000B9D4(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  int v19 = 0;
  memset(v18, 0, sizeof(v18));
  xpc_binprefs_init((uint64_t)v18);
  if (xpc_array_get_count(a3))
  {
    for (size_t i = 0; i < xpc_array_get_count(a3); ++i)
    {
      xpc_object_t value = xpc_array_get_value(a3, i);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
      {
        int v10 = xpc_int64_get_value(value);
        int v11 = -1;
      }
      else
      {
        if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
        {
          xpc_type_t type = xpc_get_type(value);
          xpc_type_get_name(type);
          sub_100014CD8(a4, 3, "Invalid CPU type value type specified: %s");
          continue;
        }
        xpc_object_t v12 = xpc_dictionary_get_value(value, "CPUType");
        if (!v12)
        {
          sub_100014CD8(a4, 3, "Missing CPUType", v17);
          continue;
        }
        int v13 = v12;
        if (xpc_get_type(v12) != (xpc_type_t)&_xpc_type_int64)
        {
          sub_100014CD8(a4, 3, "Wrong CPUType type - expecting int64", v17);
          continue;
        }
        int v14 = xpc_int64_get_value(v13);
        xpc_object_t v15 = xpc_dictionary_get_value(value, "CPUSubtype");
        if (v15)
        {
          long long v16 = v15;
          if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_int64)
          {
            sub_100014CD8(a4, 3, "Wrong CPUSubtype type - expecting int64");
            continue;
          }
          int v11 = xpc_int64_get_value(v16);
        }
        else
        {
          int v11 = -1;
        }
        int v10 = v14;
      }
      xpc_binprefs_add((uint64_t)v18, v10, v11);
    }
  }
  sub_1000066F8((uint64_t)a2, v18);
}

void sub_10000BBA0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_array_get_count(a3))
  {
    size_t v6 = 0;
    do
    {
      xpc_object_t value = xpc_array_get_value(a3, v6);
      sub_10000BC08((uint64_t)a2, value);
      ++v6;
    }
    while (v6 < xpc_array_get_count(a3));
  }
}

void sub_10000BC08(uint64_t a1, void *a2)
{
  bzero(__str, 0x400uLL);
  uint64_t v4 = qword_100075320++;
  snprintf(__str, 0x400uLL, "%s.%llu", (const char *)(a1 + 1392), v4);
  sub_10000BD38(a1, "com.apple.launchd.calendarinterval", __str, a2);
}

void sub_10000BCB8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v6, "QueueDirectories", a3);
  sub_10000BD38((uint64_t)a2, "com.apple.fsevents.matching", "com.apple.launchd.QueueDirectories", v6);

  xpc_release(v6);
}

void sub_10000BD38(uint64_t a1, char *key, const char *a3, void *a4)
{
  xpc_object_t v8 = *(xpc_object_t *)(a1 + 496);
  if (!v8)
  {
    xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
    *(void *)(a1 + 496) = v8;
  }
  xpc_object_t value = xpc_dictionary_get_value(v8, key);
  if (!value)
  {
    xpc_object_t value = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 496), key, value);
    xpc_release(value);
  }

  xpc_dictionary_set_value(value, a3, a4);
}

void sub_10000BDE0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v6, "WatchPaths", a3);
  sub_10000BD38((uint64_t)a2, "com.apple.fsevents.matching", "com.apple.launchd.WatchPaths", v6);

  xpc_release(v6);
}

void sub_10000BE60(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"Policies");
}

void sub_10000BEA4(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000BF14;
  v4[3] = &unk_10006EA50;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000BF14(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    sub_10000B2C0(*(void *)(a1 + 32), a2, object, *(void *)(a1 + 40));
  }
  else
  {
    sub_100014CD8(*(unsigned char **)(a1 + 40), 3, "Invalid item %s in PublishesEvents, expected dictionary or BOOL", a2);
    *(void *)(*(void *)(a1 + 32) + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000BFBC(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C02C;
  v4[3] = &unk_10006EAB0;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C02C(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(unsigned char **)(a1 + 40);
  v5[172] |= 8uLL;
  __darwin_ct_rune_t v7 = __tolower(*a2);
  switch(v7)
  {
    case 'n':
      xpc_object_t v8 = "NetworkState";
      goto LABEL_10;
    case 'o':
      if (strcasecmp(a2, "OtherJobActive"))
      {
        xpc_object_t v8 = "OtherJobEnabled";
LABEL_10:
        if (strcasecmp(a2, v8)) {
          goto LABEL_19;
        }
      }
      sub_10001E4BC((uint64_t)v5, 3, "The %s key is no longer respected. %s", v11, v12, v13, v14, v15, (char)a2);
      return 1;
    case 'p':
      if (strcmp(a2, "PathState")) {
        goto LABEL_19;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary) {
        goto LABEL_23;
      }
      xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_value(v16, "PathState", a3);
      sub_10000BD38((uint64_t)v5, "com.apple.fsevents.matching", "com.apple.launchd.PathState", v16);
      xpc_release(v16);
      return 1;
    case 'q':
    case 'r':
      goto LABEL_19;
    case 's':
      if (strcmp(a2, "SuccessfulExit")) {
        goto LABEL_19;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_BOOL) {
        goto LABEL_23;
      }
      uint64_t v17 = sub_100013BB8(0x28uLL);
      long long v18 = sub_10001E254;
      v17[32] = a3 == &_xpc_BOOL_true;
      int v19 = "successful exit";
      goto LABEL_27;
    default:
      if (v7 != 99)
      {
        if (v7 == 97 && !strcasecmp(a2, "AfterInitialDemand"))
        {
          if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_BOOL)
          {
            uint64_t v9 = v5[173];
            unint64_t v10 = v5[172] & 0xFFFFFFFFFF7FFFFFLL | ((unint64_t)(a3 != 0) << 23);
          }
          else
          {
            sub_100014CD8(v6, 3, "Improper type for KeepAlive key: %s", a2);
            uint64_t v9 = v5[173];
            unint64_t v10 = v5[172] | 1;
          }
          v5[172] = v10;
          v5[173] = v9;
          return 1;
        }
        goto LABEL_19;
      }
      if (strcasecmp(a2, "Crashed"))
      {
LABEL_19:
        sub_100014CD8(v6, 3, "Unknown key for KeepAlive: %s");
LABEL_20:
        v5[172] |= 1uLL;
        return 1;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_BOOL)
      {
LABEL_23:
        sub_100014CD8(v6, 3, "Improper type for KeepAlive key: %s");
        goto LABEL_20;
      }
      uint64_t v17 = sub_100013BB8(0x28uLL);
      long long v18 = sub_10001E1FC;
      v17[32] = a3 == &_xpc_BOOL_true;
      int v19 = "after crash";
LABEL_27:
      *((void *)v17 + 2) = v18;
      *((void *)v17 + 3) = v19;
      long long v21 = v5 + 84;
      uint64_t v22 = v5[84];
      *(void *)uint64_t v17 = v22;
      if (v22) {
        *(void *)(v22 + 8) = v17;
      }
      void *v21 = v17;
      *((void *)v17 + 1) = v21;
      return 1;
  }
}

void sub_10000C328(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 125) |= 0x14000uLL;
  xpc_dictionary_apply_f();
}

int64_t sub_10000C354(const char *a1, void *a2, uint64_t a3)
{
  if (!strcasecmp(a1, "Wait"))
  {
    int64_t result = xpc_BOOL_get_value(a2);
    uint64_t v7 = 0x8000;
    if (!result) {
      uint64_t v7 = 0;
    }
    *(void *)(a3 + 1376) = *(void *)(a3 + 1376) & 0xFFFFFFFFFFFF7FFFLL | v7;
  }
  else
  {
    int64_t result = strcasecmp(a1, "Instances");
    if (!result)
    {
      int64_t result = xpc_int64_get_value(a2);
      *(_DWORD *)(a3 + 268) = result;
    }
  }
  return result;
}

void sub_10000C3E0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_10000C3F8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is not yet implemented. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"UserEnvironmentVariables");
}

void sub_10000C43C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C4AC;
  v4[3] = &unk_10006EC10;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C4AC(uint64_t a1, uint64_t a2, xpc_object_t object)
{
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_array)
    {
      sub_10001E4BC(v5, 3, "Socket entry is not a dictionary or array. Skipping: %s", v7, v8, v9, v10, v11, a2);
LABEL_5:
      *(void *)(v5 + 1376) |= 1uLL;
      return 1;
    }
    if (!xpc_array_get_count(object)) {
      return 1;
    }
    size_t v12 = 0;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(object, v12);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
      {
        if ((*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, uint64_t, void))(v5 + 552))(v5, a2, value, v6, *(void *)(v5 + 568)))
        {
          goto LABEL_12;
        }
      }
      else
      {
        sub_10001E4BC(v5, 3, "Socket entry is not a dictionary. Skipping: %s", v14, v15, v16, v17, v18, a2);
      }
      *(void *)(v5 + 1376) |= 1uLL;
LABEL_12:
      if (++v12 >= xpc_array_get_count(object)) {
        return 1;
      }
    }
  }
  if (!(*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, uint64_t, void))(v5 + 552))(v5, a2, object, v6, *(void *)(v5 + 568)))goto LABEL_5; {
  return 1;
  }
}

void sub_10000C600(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_10000C60C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

uint64_t sub_10000C624(const char *a1, xpc_object_t object, uint64_t a3)
{
  uint64_t result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_int64)
  {
    int64_t value = xpc_int64_get_value(object);
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t result = strcasecmp((&off_10006F1D8)[v8], a1);
      if (!result) {
        break;
      }
      v8 += 2;
      if (v8 == 18) {
        return result;
      }
    }
    int v9 = LOWORD((&off_10006F1D8)[v8 + 1]);
    uint64_t v10 = *(void *)(a3 + 1376);
    uint64_t v11 = (uint64_t *)(a3 + 680);
    uint64_t result = (uint64_t)v11;
    while (1)
    {
      uint64_t result = *(void *)result;
      if (!result) {
        break;
      }
      if (*(unsigned __int16 *)(result + 32) == v9) {
        goto LABEL_13;
      }
    }
    uint64_t result = (uint64_t)sub_100013BB8(0x28uLL);
    *(_WORD *)(result + 32) = v9;
    uint64_t v12 = *v11;
    *(void *)uint64_t result = *v11;
    if (v12) {
      *(void *)(v12 + 8) = result;
    }
    *uint64_t v11 = result;
    *(void *)(result + 8) = v11;
LABEL_13:
    if ((v10 & 0x800000000) != 0)
    {
      *(unsigned char *)(result + 34) = 1;
      uint64_t v13 = (int64_t *)(result + 24);
    }
    else
    {
      *(unsigned char *)(result + 35) = 1;
      uint64_t v13 = (int64_t *)(result + 16);
    }
    *uint64_t v13 = value;
  }
  return result;
}

void sub_10000C71C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10001E4BC((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"SandboxFlags");
}

void sub_10000C760(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 125) |= 0x800000000uLL;
  xpc_dictionary_apply_f();
  *((void *)&a2->var4 + 125) &= ~0x800000000uLL;
}

void sub_10000C7B0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C820;
  v4[3] = &unk_10006ED70;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C820(uint64_t a1, char *a2, uint64_t a3)
{
  return 1;
}

void sub_10000C844(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C8B4;
  v4[3] = &unk_10006EDD0;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C8B4(uint64_t a1, const char *a2, xpc_object_t object)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(unsigned char **)(a1 + 40);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_10000D10C;
    applier[3] = &unk_10006F268;
    applier[4] = object;
    void applier[5] = v5;
    void applier[6] = a2;
    void applier[7] = v6;
    xpc_dictionary_apply(object, applier);
  }
  else
  {
    xpc_type_t type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100014CD8(v5, 3, "Invalid type for a LaunchEvent stream, should be a dictionary (stream/type): %s/%s", a2, name);
    *(void *)(v6 + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000C994(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000CA04;
  v4[3] = &unk_10006EE30;
  v4[4] = a4;
  v4[5] = a2;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000CA04(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_dictionary_get_int64(object, "SizeLimit"))
    {
      sub_10000BD38(*(void *)(a1 + 40), "com.apple.xpc.datastores.publish", a2, object);
      return 1;
    }
    sub_100014CD8(*(unsigned char **)(a1 + 32), 3, "Size limit for Datastore entry not specified: %s");
  }
  else
  {
    uint64_t v6 = *(unsigned char **)(a1 + 32);
    xpc_type_t type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_100014CD8(v6, 3, "Invalid type for a Datastores entry, should be a dictionary (key/type): %s/%s");
  }
  *(void *)(*(void *)(a1 + 40) + 1376) |= 1uLL;
  return 1;
}

void sub_10000CAD4(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000CB44;
  v4[3] = &unk_10006EE90;
  v4[4] = a4;
  v4[5] = a2;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000CB44(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000BD38(*(void *)(a1 + 40), "com.apple.remoted.service", a2, object);
  }
  else
  {
    uint64_t v6 = *(unsigned char **)(a1 + 32);
    xpc_type_t type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100014CD8(v6, 3, "Invalid type for a RemoteServices entry, should be a dictionary (key/type): %s/%s", a2, name);
    *(void *)(*(void *)(a1 + 40) + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000CBEC(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  a2->var4.var24 = xpc_retain(a3);
}

void sub_10000CC18(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5 = xpc_string_create(a3);
  a2->var4.var25 = xpc_array_create(&v5, 1uLL);
}

void sub_10000CC88(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  a2->var4.var25 = xpc_array_create_empty();
  if (xpc_array_get_count(a3))
  {
    size_t v7 = 0;
    do
    {
      xpc_object_t value = xpc_array_get_value(a3, v7);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
      {
        xpc_array_append_value(a2->var4.var25, value);
      }
      else
      {
        sub_100014CD8(a4, 3, "Invalid type for _PersistToBootMode at index: %lu", v7);
        *((void *)&a2->var4 + 125) |= 1uLL;
      }
      ++v7;
    }
    while (v7 < xpc_array_get_count(a3));
  }
}

void sub_10000CD58(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_mach_send) {
    a2->var4.var91 = xpc_mach_send_copy_right();
  }
  else {
    sub_100050D44((uint64_t)a2);
  }
}

void sub_10000CDAC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x400000000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFBFFFFFFFFFFFFFFLL | v4;
}

void sub_10000CDCC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    a2->var4.var81 = 1;
  }
}

void sub_10000CDDC(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v19 = 0;
  xpc_object_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 1;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  char v18 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_10000D1C0;
  applier[3] = &unk_10006F290;
  void applier[7] = &v11;
  void applier[8] = a4;
  applier[4] = &v7;
  void applier[5] = &v19;
  void applier[6] = &v15;
  xpc_dictionary_apply(a3, applier);
  if (!*((unsigned char *)v16 + 24))
  {
    if (*((unsigned char *)v12 + 24))
    {
      *((void *)&a2->var4 + 125) |= 0x800000000000000uLL;
      unint64_t v5 = v8[3];
      if (!v5) {
        unint64_t v5 = qword_100075AA8;
      }
    }
    else
    {
      a2->var4.var81 = *((unsigned char *)v20 + 24);
      unint64_t v5 = v8[3];
    }
    a2->var4.var82 = v5;
  }
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
}

void sub_10000CF38(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  *((void *)&a2->var4 + 125) |= 0x1000000000000000uLL;
}

void sub_10000CF70(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
}

void sub_10000CF7C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  unsigned __int8 var72 = a2->var4.var72;
  a2->var4.unsigned __int8 var72 = a3;
  if ((sub_1000052DC((uint64_t)a2, 7) & 1) == 0)
  {
    sub_100014CD8(a4, 3, "Supplied value (%lld) for _LaunchType key not allowed", a3);
    a2->var4.unsigned __int8 var72 = var72;
  }
}

void sub_10000CFE8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
}

void sub_10000CFF4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  unint64_t v4 = 0x8000000000000000;
  if (!a3) {
    unint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = v4 & 0x8000000000000000 | *((void *)&a2->var4 + 125) & 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t sub_10000D010(uint64_t a1, char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (sub_100015DB0(a2, "DomainInternal"))
    {
      if (!xpc_BOOL_get_value(object)) {
        return 1;
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
      int v8 = *(_DWORD *)(v7 + 24) | 1;
    }
    else
    {
      if (!sub_100015DB0(a2, "RequireTrusted"))
      {
        sub_100014CD8(*(unsigned char **)(a1 + 40), 3, "Unknown property %s for PublishesEvents");
        goto LABEL_3;
      }
      if (!xpc_BOOL_get_value(object)) {
        return 1;
      }
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
      int v8 = *(_DWORD *)(v7 + 24) | 2;
    }
    *(_DWORD *)(v7 + 24) = v8;
    return 1;
  }
  sub_100014CD8(*(unsigned char **)(a1 + 40), 3, "Invalid type for PublishesEvents property %s, expected BOOL");
LABEL_3:
  *(void *)(*(void *)(a1 + 48) + 1376) |= 1uLL;
  return 1;
}

uint64_t sub_10000D10C(uint64_t a1, const char *a2, void *a3)
{
  xpc_type_t type = xpc_get_type(*(xpc_object_t *)(a1 + 32));
  uint64_t v7 = *(const char **)(a1 + 48);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000BD38(*(void *)(a1 + 56), *(char **)(a1 + 48), a2, a3);
  }
  else
  {
    int v8 = *(unsigned char **)(a1 + 40);
    uint64_t v9 = xpc_get_type(a3);
    name = xpc_type_get_name(v9);
    sub_100014CD8(v8, 3, "Invalid type for a LaunchEvent (stream/name/type): %s/%s/%s", v7, a2, name);
    *(void *)(*(void *)(a1 + 56) + 1376) |= 1uLL;
  }
  return 1;
}

uint64_t sub_10000D1C0(uint64_t a1, char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_int64)
  {
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_BOOL)
    {
      sub_100014CD8(*(unsigned char **)(a1 + 64), 3, "Improper type for _PanicOnCrash key: %s");
      return 1;
    }
    if (object == &_xpc_BOOL_false) {
      return 1;
    }
    if (sub_100015DB0(a2, "PanicOnNonZeroExit"))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
      char v10 = 3;
LABEL_25:
      *(unsigned char *)(v9 + 24) = v10;
      return 1;
    }
    if (sub_100015DB0(a2, "InternalOnly"))
    {
      if (byte_100076A66) {
        return 1;
      }
      sub_100014CD8(*(unsigned char **)(a1 + 64), 4, "_PanicOnCrash key: InternalOnly not enabled in the current environment");
    }
    else
    {
      if (!sub_100015DB0(a2, "AutomationOnly"))
      {
        if (!sub_100015DB0(a2, "PanicOnConsecutiveCrash")) {
          return 1;
        }
        uint64_t v12 = *(void *)(a1 + 56);
        goto LABEL_24;
      }
      if (byte_100076A67) {
        return 1;
      }
      sub_100014CD8(*(unsigned char **)(a1 + 64), 4, "_PanicOnCrash key: AutomationOnly not enabled in the current environment");
    }
    uint64_t v12 = *(void *)(a1 + 48);
LABEL_24:
    uint64_t v9 = *(void *)(v12 + 8);
    char v10 = 1;
    goto LABEL_25;
  }
  int64_t value = xpc_int64_get_value(object);
  if (sub_100015DB0(a2, "PanicOnCrashDeadline"))
  {
    if (value < 0)
    {
      uint64_t v7 = *(unsigned char **)(a1 + 64);
      int v8 = "_PanicOnCrash key: PanicOnCrashDeadline less than zero. Ignoring.";
    }
    else
    {
      if (is_mul_ok(value, 0x3B9ACA00uLL))
      {
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1000000000 * value;
        return 1;
      }
      uint64_t v7 = *(unsigned char **)(a1 + 64);
      int64_t v13 = value;
      int v8 = "_PanicOnCrash key: PanicOnCrashDeadline overflowed converting to ns (%lld)";
    }
    sub_100014CD8(v7, 4, v8, v13);
  }
  return 1;
}

uint64_t sub_10000D388(uint64_t a1)
{
  uint64_t v1 = mach_absolute_time() - a1;

  return sub_10000D3C0(v1);
}

uint64_t sub_10000D3C0(uint64_t a1)
{
  if (qword_100075BA0 != -1) {
    dispatch_once_f(&qword_100075BA0, 0, (dispatch_function_t)sub_10000DA10);
  }
  if (dword_100075BA8 != *(_DWORD *)algn_100075BAC) {
    return __udivti3();
  }
  return a1;
}

void sub_10000D444(unint64_t a1)
{
  if (qword_100075BA0 != -1) {
    dispatch_once_f(&qword_100075BA0, 0, (dispatch_function_t)sub_10000DA10);
  }
  if (dword_100075BA8 != *(_DWORD *)algn_100075BAC
    && !is_mul_ok(a1 / dword_100075BA8, *(unsigned int *)algn_100075BAC))
  {
    __break(1u);
  }
}

uint64_t sub_10000D4C8(mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  do
  {
    uint64_t v6 = mach_port_construct(mach_task_self_, options, context, name);
    uint64_t v7 = v6;
    BOOL v8 = v6 == 6 || v6 == 3;
  }
  while (v8 && sub_10001598C());
  return v7;
}

uint64_t sub_10000D538(mach_port_options_t *a1, mach_port_context_t a2)
{
  mach_port_name_t name = 0;
  int v2 = sub_10000D4C8(a1, a2, &name);
  if (v2) {
    sub_100050D8C(v2);
  }
  return name;
}

uint64_t sub_10000D56C(uint32_t a1, mach_port_msgcount_t a2, mach_port_context_t a3)
{
  v4.flags = a1;
  v4.mpl.mpl_qlimit = a2;
  v4.8 = 0uLL;
  return sub_10000D538(&v4, a3);
}

uint64_t sub_10000D59C(mach_port_name_t name, mach_port_context_t guard)
{
  return mach_port_unguard(mach_task_self_, name, guard);
}

uint64_t sub_10000D5B4(mach_port_name_t name, uint64_t a2)
{
  *(void *)info = a2;
  uint64_t result = mach_port_assert_attributes(mach_task_self_, name, 8, info, 2u);
  if (result) {
    sub_100050DB4(result);
  }
  return result;
}

uint64_t sub_10000D600(mach_port_name_t name)
{
  return mach_port_insert_right(mach_task_self_, name, name, 0x14u);
}

uint64_t sub_10000D61C(mach_port_name_t name, mach_port_t *poly)
{
  mach_msg_type_name_t polyPoly = 0;
  return mach_port_extract_right(mach_task_self_, name, 0x15u, poly, &polyPoly);
}

uint64_t sub_10000D65C(mach_port_name_t name)
{
  return mach_port_mod_refs(mach_task_self_, name, 0, 1);
}

uint64_t sub_10000D678(mach_port_name_t name)
{
  return mach_port_deallocate(mach_task_self_, name);
}

uint64_t sub_10000D68C(mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return mach_port_destruct(mach_task_self_, name, srdelta, guard);
}

uint64_t sub_10000D6A8(mach_port_name_t name)
{
  return mach_port_set_attributes(mach_task_self_, name, 4, 0, 0);
}

uint64_t sub_10000D6C8(mach_port_name_t name, mach_port_t notify, mach_port_t *previous)
{
  if (notify) {
    mach_msg_type_name_t v3 = 21;
  }
  else {
    mach_msg_type_name_t v3 = 18;
  }
  return mach_port_request_notification(mach_task_self_, name, 69, 0, notify, v3, previous);
}

uint64_t sub_10000D6FC(uint64_t a1)
{
  return a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0x1FFFFFFFCLL) + 20;
}

uint64_t sub_10000D714()
{
  if (_os_alloc_once_table[2] == -1) {
    uint64_t v0 = _os_alloc_once_table[3];
  }
  else {
    uint64_t v0 = _os_alloc_once();
  }
  if (*(unsigned char *)(v0 + 41))
  {
    if (*(void *)(v0 + 48) != -1) {
      dispatch_once_f((dispatch_once_t *)(v0 + 48), (void *)(v0 + 56), (dispatch_function_t)sub_10000D7A4);
    }
  }
  else
  {
    sub_10000D7A4((task_info_t)(v0 + 56));
  }
  return v0 + 56;
}

uint64_t sub_10000D7A4(task_info_t task_info_out)
{
  mach_msg_type_number_t task_info_outCnt = 8;
  if (task_info(mach_task_self_, 0xFu, task_info_out, &task_info_outCnt)) {
    sub_100050DDC();
  }
  integer_t v2 = task_info_out[5];
  uint64_t result = getpid();
  if (v2 != result || !task_info_out[7]) {
    sub_100050DDC();
  }
  return result;
}

uint64_t sub_10000D814(posix_spawnattr_t *a1, mach_port_t new_port)
{
  if (_os_alloc_once_table[2] == -1) {
    uint64_t v4 = _os_alloc_once_table[3];
  }
  else {
    uint64_t v4 = _os_alloc_once();
  }
  if (*(unsigned char *)(v4 + 42)) {
    exception_mask_t v5 = 7168;
  }
  else {
    exception_mask_t v5 = 10240;
  }
  if (a1)
  {
    uint64_t result = posix_spawnattr_setexceptionports_np(a1, v5, new_port, -1610612732, 1);
    if (result) {
      sub_100050D28();
    }
  }
  else
  {
    task_t v7 = mach_task_self_;
    return task_set_exception_ports(v7, v5, new_port, -1610612732, 1);
  }
  return result;
}

uint64_t sub_10000D8D4(task_t task)
{
  kern_return_t exception_ports;
  mach_port_t v5;
  mach_msg_type_number_t masksCnt;
  thread_state_flavor_t old_flavors[4];
  long long v9;
  long long v10;
  uint64_t v11;
  exception_behavior_t old_behaviors[4];
  long long v13;
  long long v14;
  uint64_t v15;
  _OWORD old_handlers[3];
  uint64_t v17;
  _OWORD masks[3];
  uint64_t v19;

  if (_os_alloc_once_table[2] == -1) {
    uint64_t v2 = _os_alloc_once_table[3];
  }
  else {
    uint64_t v2 = _os_alloc_once();
  }
  uint64_t v19 = 0;
  memset(masks, 0, sizeof(masks));
  masksCnt = 0;
  uint64_t v17 = 0;
  memset(old_handlers, 0, sizeof(old_handlers));
  uint64_t v15 = 0;
  int64_t v13 = 0u;
  char v14 = 0u;
  *(_OWORD *)old_behaviors = 0u;
  uint64_t v11 = 0;
  uint64_t v9 = 0u;
  char v10 = 0u;
  *(_OWORD *)old_flavors = 0u;
  if (*(unsigned char *)(v2 + 42)) {
    exception_mask_t v3 = 1024;
  }
  else {
    exception_mask_t v3 = 0x2000;
  }
  if (mach_task_self_ == task)
  {
    exception_ports = task_get_exception_ports(task, v3, (exception_mask_array_t)masks, &masksCnt, (exception_handler_array_t)old_handlers, old_behaviors, old_flavors);
  }
  else
  {
    exception_mask_t v5 = mach_host_self();
    exception_ports = host_get_exception_ports(v5, v3, (exception_mask_array_t)masks, &masksCnt, (exception_handler_array_t)old_handlers, old_behaviors, old_flavors);
  }
  if (exception_ports) {
    sub_100050D28();
  }
  return LODWORD(old_handlers[0]);
}

uint64_t sub_10000DA10()
{
  uint64_t result = mach_timebase_info((mach_timebase_info_t)&dword_100075BA8);
  if (result) {
    sub_100050D28();
  }
  return result;
}

void *sub_10000DA38(const char *a1)
{
  uint64_t v2 = sub_100013BB8(0xB0uLL);
  void *v2 = sub_1000159F0(a1);
  os_map_str_init();
  os_map_str_init();
  os_map_str_init();
  os_map_str_init();
  os_map_str_init();
  os_map_str_init();
  os_map_str_init();
  return v2;
}

uint64_t sub_10000DAE8(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100013BB8(0x10uLL);
  v6[1] = a3;

  return sub_10000DB44(a1, a1 + 8, a2, v6);
}

uint64_t sub_10000DB44(uint64_t a1, uint64_t a2, const char *a3, char **a4)
{
  exception_mask_t v5 = sub_10000DE54(a3);
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  *a4 = v5;

  return os_map_str_insert();
}

uint64_t sub_10000DBC8(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100013BB8(0x10uLL);
  v6[1] = a3;

  return sub_10000DB44(a1, a1 + 32, a2, v6);
}

uint64_t sub_10000DC24(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100013BB8(0x10uLL);
  v6[1] = a3;

  return sub_10000DB44(a1, a1 + 56, a2, v6);
}

uint64_t sub_10000DC80(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100013BB8(0x10uLL);
  v6[1] = a3;

  return sub_10000DB44(a1, a1 + 80, a2, v6);
}

uint64_t sub_10000DCDC(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100013BB8(0x10uLL);
  v6[1] = a3;

  return sub_10000DB44(a1, a1 + 104, a2, v6);
}

uint64_t sub_10000DD38(uint64_t a1, const char *a2, char *a3)
{
  uint64_t v6 = (char **)sub_100013BB8(0x10uLL);
  v6[1] = a3;

  return sub_10000DB44(a1, a1 + 128, a2, v6);
}

uint64_t sub_10000DD94(uint64_t a1, const char *a2)
{
  sub_10000DE54(a2);
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  if (os_map_str_find()) {
    sub_100050D0C();
  }
  if (os_map_str_find()) {
    sub_100050D0C();
  }

  return os_map_str_insert();
}

char *sub_10000DE54(const char *a1)
{
  uint64_t v1 = sub_1000159F0(a1);
  if (*v1)
  {
    size_t v2 = 0;
    do
    {
      v1[v2] = __tolower(v1[v2]);
      ++v2;
    }
    while (v2 < strlen(v1));
  }
  return v1;
}

uint64_t sub_10000DEA8(uint64_t *a1, uint64_t a2, const char *a3, void *a4, uint64_t a5)
{
  uint64_t v9 = sub_10000DE54(a3);
  if (os_map_str_find()) {
    goto LABEL_2;
  }
  xpc_type_t type = xpc_get_type(a4);
  if (type != (xpc_type_t)&_xpc_type_BOOL)
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      uint64_t v16 = os_map_str_find();
      if (!v16) {
        goto LABEL_18;
      }
      uint64_t v17 = *(void *)(v16 + 8);
      int64_t value = xpc_int64_get_value(a4);
      uint64_t v19 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v17 + 16);
      uint64_t v20 = v17;
    }
    else
    {
      if (type != (xpc_type_t)&_xpc_type_string)
      {
        uint64_t v24 = os_map_str_find();
        if (v24)
        {
          uint64_t v20 = *(void *)(v24 + 8);
          uint64_t v19 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v20 + 16);
          uint64_t v23 = a2;
          int64_t value = (int64_t)a4;
          goto LABEL_17;
        }
LABEL_18:
        xpc_object_t v25 = xpc_get_type(a4);
        long long v26 = (void **)sub_100010724(0x80uLL);
        uint64_t v27 = *a1;
        xpc_type_get_name(v25);
        sub_1000107B4((uint64_t)v26, "Invalid type for %s importer (key: %s type: %s), accepted types: [", v28, v29, v30, v31, v32, v33, v27);
        uint64_t v34 = os_map_str_find();
        BOOL v41 = v34 != 0;
        if (v34) {
          sub_1000107B4((uint64_t)v26, "BOOL, ", v35, v36, v37, v38, v39, v40, v89);
        }
        if (os_map_str_find())
        {
          sub_1000107B4((uint64_t)v26, "integer, ", v42, v43, v44, v45, v46, v47, v89);
          BOOL v41 = 1;
        }
        if (os_map_str_find())
        {
          sub_1000107B4((uint64_t)v26, "string, ", v48, v49, v50, v51, v52, v53, v89);
          BOOL v41 = 1;
        }
        if (os_map_str_find())
        {
          sub_1000107B4((uint64_t)v26, "array, ", v54, v55, v56, v57, v58, v59, v89);
          BOOL v41 = 1;
        }
        if (os_map_str_find())
        {
          sub_1000107B4((uint64_t)v26, "dictionary, ", v60, v61, v62, v63, v64, v65, v89);
          if (!os_map_str_find()) {
            goto LABEL_31;
          }
        }
        else if (!os_map_str_find())
        {
          if (!v41)
          {
            uint64_t v83 = *a1;
            xpc_type_get_name(v25);
            sub_10001E4BC(a2, 3, "Unknown key for %s importer (key: %s type: %s)", v84, v85, v86, v87, v88, v83);
            goto LABEL_32;
          }
LABEL_31:
          sub_1000108B8(v26, 2uLL);
          sub_1000107B4((uint64_t)v26, "]", v72, v73, v74, v75, v76, v77, v89);
          sub_10001E4BC(a2, 3, "%s", v78, v79, v80, v81, v82, (char)*v26);
LABEL_32:
          sub_100010778(v26);
          uint64_t v10 = 0;
          goto LABEL_3;
        }
        sub_1000107B4((uint64_t)v26, "object, ", v66, v67, v68, v69, v70, v71, v89);
        goto LABEL_31;
      }
      uint64_t v21 = os_map_str_find();
      if (!v21) {
        goto LABEL_18;
      }
      uint64_t v22 = v21;
      int64_t value = (int64_t)xpc_string_get_string_ptr(a4);
      uint64_t v20 = *(void *)(v22 + 8);
      uint64_t v19 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v20 + 16);
    }
    uint64_t v23 = a2;
LABEL_17:
    v19(v20, v23, value, a5);
    goto LABEL_2;
  }
  uint64_t v13 = os_map_str_find();
  if (!v13) {
    goto LABEL_18;
  }
  uint64_t v14 = *(void *)(v13 + 8);
  BOOL v15 = xpc_BOOL_get_value(a4);
  (*(void (**)(uint64_t, uint64_t, BOOL, uint64_t))(v14 + 16))(v14, a2, v15, a5);
LABEL_2:
  uint64_t v10 = 1;
LABEL_3:
  free(v9);
  return v10;
}

void sub_10000E1F0(const void *a1)
{
  if (dword_100076EE0)
  {
    size_t v2 = sub_100014B58();
    exception_mask_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 1uLL, v2);
    dispatch_time_t v4 = dispatch_time(0, 1000000000 * dword_100076EE0);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(v3, (dispatch_function_t)sub_10000E2C4);
    exception_mask_t v5 = _Block_copy(a1);
    dispatch_set_context(v3, v5);
    dispatch_activate(v3);
  }
}

void sub_10000E2C4()
{
  uint64_t v0 = sub_100030018();
  uint64_t v1 = mach_absolute_time();
  if (!*(_DWORD *)(v0 + 188)) {
    sub_100043D78(65541, "Shutdown stall event fired with no activations (skipping report)");
  }
  uint64_t v2 = mach_absolute_time();
  uint64_t v3 = sub_10000D440(v2 - v1);

  sub_100019084(v3);
}

uint64_t sub_10000E328(void *a1)
{
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(a1, "Version4");
  if (!dictionary) {
    return 22;
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10000E44C;
  v5[3] = &unk_10006F2B0;
  _DWORD v5[4] = dictionary;
  sub_10000E3E4((uint64_t)v5);
  uint64_t result = os_variant_is_darwinos();
  if (result)
  {
    xpc_object_t v4 = xpc_retain(a1);
    xpc_array_append_value((xpc_object_t)qword_100076968, v4);
    return 0;
  }
  return result;
}

uint64_t sub_10000E3E4(uint64_t result)
{
  uint64_t v1 = result;
  for (uint64_t i = 0; i != 256; i += 32)
  {
    if ((*((unsigned char *)&unk_100075328 + i + 16) & 2) != 0)
    {
      if (!*(void *)((char *)&unk_100075328 + i + 24)) {
        sub_100050D0C();
      }
      uint64_t result = (*(uint64_t (**)(uint64_t))(v1 + 16))(v1);
    }
  }
  return result;
}

void *sub_10000E44C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(const char **)(a2 + 24);
  uint64_t result = xpc_dictionary_get_dictionary(*(xpc_object_t *)(a1 + 32), v3);
  if (result)
  {
    exception_mask_t v5 = result;
    uint64_t result = xpc_get_type(result);
    if (result == &_xpc_type_dictionary)
    {
      uint64_t v6 = 0;
      char v7 = 1;
      do
      {
        char v8 = v7;
        uint64_t result = xpc_dictionary_get_dictionary(v5, off_10006F330[v6]);
        if (result)
        {
          uint64_t v9 = result;
          uint64_t result = xpc_get_type(result);
          if (result == &_xpc_type_dictionary)
          {
            applier[0] = _NSConcreteStackBlock;
            applier[1] = 0x40000000;
            applier[2] = sub_10000F344;
            applier[3] = &unk_10006F340;
            applier[4] = a2;
            void applier[5] = v3;
            int v11 = v6;
            uint64_t result = (void *)xpc_dictionary_apply(v9, applier);
          }
        }
        char v7 = 0;
        uint64_t v6 = 1;
      }
      while ((v8 & 1) != 0);
    }
  }
  return result;
}

uint64_t sub_10000E564(const char *a1)
{
  uint64_t v2 = sub_100015BE4("%s%s", a1, "/Library/JetsamProperties/com.apple.jetsamproperties.DDI.plist");
  sub_100043D78(5, "Loading DDI overlay plist from: %s", v2);
  uint64_t v3 = sub_10000E630(v2);
  free(v2);
  if (v3 == 2)
  {
    xpc_object_t v4 = sub_100015BE4("%s%s", a1, "/System/Library/JetsamProperties/com.apple.jetsamproperties.cryptex.plist");
    sub_100043D78(5, "Loading Cryptex overlay plist from: %s", v4);
    LODWORD(v3) = sub_10000E630(v4);
    free(v4);
    if (v3 == 2) {
      return 0;
    }
    else {
      return v3;
    }
  }
  return v3;
}

uint64_t sub_10000E630(const char *a1)
{
  sub_100043D78(5, "Loading overlay plist from: %s", a1);
  uint64_t v2 = sub_10003E594(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = sub_10000E328(v2);
    xpc_release(v3);
    return v4;
  }
  else
  {
    sub_100043D78(3, "Overlay plist is missing.");
    return 2;
  }
}

void sub_10000E6A8(void *a1, unsigned char *a2)
{
  sub_10000F400(a1, "ActiveSoftMemoryLimit", "ActiveHardMemoryLimit", a2);
  sub_10000F400(a1, "InactiveSoftMemoryLimit", "InactiveHardMemoryLimit", a2);
  unint64_t int64 = xpc_dictionary_get_int64(a1, "CPUMonitorInterval");
  unint64_t v5 = xpc_dictionary_get_int64(a1, "CPUMonitorPercentage");
  if (int64 >= 0x100)
  {
    sub_100014CD8(a2, 3, "CPUMonitorInterval is out of range, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorInterval", 0);
    unint64_t int64 = 0;
  }
  if (v5 >= 0x65)
  {
    sub_100014CD8(a2, 3, "CPUMonitorPercentage is out of range, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorPercentage", 0);
    if (!int64) {
      return;
    }
    goto LABEL_11;
  }
  if (int64) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = v5 == 100;
  }
  if (!v6 && (v5 == 0) != (int64 == 0))
  {
LABEL_11:
    sub_100014CD8(a2, 3, "incomplete CPUMonitor, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorInterval", 0);
    xpc_dictionary_set_value(a1, "CPUMonitorPercentage", 0);
  }
}

BOOL sub_10000E820(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000E894;
  v4[3] = &unk_10006F2D0;
  v4[4] = a1;
  v4[5] = a3;
  return xpc_dictionary_apply(xdict, v4);
}

uint64_t sub_10000E894(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  char v7 = (uint64_t *)qword_100075BB0;
  if (!qword_100075BB0)
  {
    qword_100075BB0 = (uint64_t)sub_10000DA38("JetsamProperties");
    sub_10000DAE8(qword_100075BB0, "AlwaysSIGTERMOnShutdown", (char *)&stru_10006F380);
    sub_10000DAE8(qword_100075BB0, "EnableTransactions", (char *)&stru_10006F3C0);
    sub_10000DAE8(qword_100075BB0, "EnablePressuredExit", (char *)&stru_10006F400);
    sub_10000DD94(qword_100075BB0, "ExecuteAllowed");
    sub_10000DAE8(qword_100075BB0, "EnableIdleHysteresis", (char *)&stru_10006F440);
    sub_10000DAE8(qword_100075BB0, "MallocSpaceEfficient", (char *)&stru_10006F480);
    sub_10000DAE8(qword_100075BB0, "MallocNanoZone", (char *)&stru_10006F4C0);
    sub_10000DAE8(qword_100075BB0, "MallocLargeCache", (char *)&stru_10006F500);
    sub_10000DAE8(qword_100075BB0, "MallocAggressiveMadvise", (char *)&stru_10006F540);
    sub_10000DAE8(qword_100075BB0, "MallocMediumZone", (char *)&stru_10006F580);
    sub_10000DBC8(qword_100075BB0, "MallocMaxMagazines", (char *)&stru_10006F5C0);
    sub_10000DBC8(qword_100075BB0, "ActiveSoftMemoryLimit", (char *)&stru_10006F600);
    sub_10000DBC8(qword_100075BB0, "ActiveHardMemoryLimit", (char *)&stru_10006F640);
    sub_10000DBC8(qword_100075BB0, "AddressLimit", (char *)&stru_10006F680);
    sub_10000DBC8(qword_100075BB0, "CPUMonitorInterval", (char *)&stru_10006F6C0);
    sub_10000DBC8(qword_100075BB0, "CPUMonitorPercentage", (char *)&stru_10006F700);
    sub_10000DBC8(qword_100075BB0, "SoftFileDescriptorLimit", (char *)&stru_10006F740);
    sub_10000DBC8(qword_100075BB0, "HardFileDescriptorLimit", (char *)&stru_10006F780);
    sub_10000DBC8(qword_100075BB0, "SoftKqWorkloopLimit", (char *)&stru_10006F7C0);
    sub_10000DBC8(qword_100075BB0, "HardKqWorkloopLimit", (char *)&stru_10006F800);
    sub_10000DBC8(qword_100075BB0, "InactiveSoftMemoryLimit", (char *)&stru_10006F840);
    sub_10000DBC8(qword_100075BB0, "InactiveHardMemoryLimit", (char *)&stru_10006F880);
    sub_10000DBC8(qword_100075BB0, "JetsamPriority", (char *)&stru_10006F8C0);
    sub_10000DBC8(qword_100075BB0, "LogicalWritesLimit", (char *)&stru_10006F900);
    sub_10000DBC8(qword_100075BB0, "SoftPortLimit", (char *)&stru_10006F940);
    sub_10000DBC8(qword_100075BB0, "HardPortLimit", (char *)&stru_10006F980);
    sub_10000DBC8(qword_100075BB0, "ThreadLimit", (char *)&stru_10006F9C0);
    sub_10000DC24(qword_100075BB0, "EnergyEfficiencyMode", (char *)&stru_10006FA00);
    sub_10000DBC8(qword_100075BB0, "WiredMemoryLimit", (char *)&stru_10006FA40);
    char v7 = (uint64_t *)qword_100075BB0;
  }
  sub_10000DEA8(v7, v6, a2, a3, v5);
  return 1;
}

uint64_t sub_10000EBB4()
{
  qword_100076968 = (uint64_t)xpc_array_create_empty();

  return sub_10000E3E4((uint64_t)&stru_10006F310);
}

void sub_10000EBEC(id a1, $2CED98A4406CC48DAE53FEE9DBECCC80 *a2)
{
  a2->var1 &= ~4u;
}

void sub_10000EBFC()
{
  if (!qword_100076A50) {
    sub_100040E80("sysctl hw.targettype was not set");
  }
  uint64_t v0 = sub_10003E594("/System/Library/LaunchDaemons/com.apple.jetsamproperties.NonUI.plist");
  uint64_t v1 = sub_100015BE4("%s.%s%s.plist", "/AppleInternal/Library/LaunchDaemons/com.apple.jetsamproperties", (const char *)qword_100076A50, (const char *)qword_100076A58);
  uint64_t v2 = sub_10003E594(v1);
  if (v2
    || (free(v1),
        uint64_t v1 = sub_100015BE4("%s.%s%s.plist", "/System/Library/LaunchDaemons/com.apple.jetsamproperties", (const char *)qword_100076A50, (const char *)qword_100076A58), (v2 = sub_10003E594(v1)) != 0))
  {
    uint64_t v3 = v2;
    if (v0) {
      sub_100040E80("both NonUI & target-specific JetsamProperties plists are present. This is an error in the OS build configuration.");
    }
  }
  else
  {
    free(v1);
    if (!v0) {
      return;
    }
    uint64_t v1 = "/System/Library/LaunchDaemons/com.apple.jetsamproperties.NonUI.plist";
    uint64_t v3 = v0;
  }
  qword_100076960 = (uint64_t)v1;
  if (xpc_get_type(v3) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100040E80("JetsamProperties plist is malformed");
  }
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(v3, "Version4");
  if (!dictionary) {
    sub_100040E80("JetsamProperties plist is malformed - missing Version4 dictionary");
  }
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10000F930;
  v5[3] = &unk_10006FA60;
  _DWORD v5[4] = dictionary;
  sub_10000E3E4((uint64_t)v5);
  xpc_release(v3);
}

xpc_object_t sub_10000EDA0(void *a1)
{
  string = (char *)xpc_dictionary_get_string(a1, "POSIXSpawnType");
  if (!string) {
    string = (char *)xpc_dictionary_get_string(a1, "ProcessType");
  }
  if (xpc_dictionary_get_BOOL(a1, "__Angel"))
  {
    unsigned int v3 = 1;
  }
  else if (sub_100015D70(string, "Driver"))
  {
    unsigned int v3 = 3;
  }
  else
  {
    uint64_t v4 = xpc_dictionary_get_string(a1, "Label");
    if (!sub_100015CAC(v4, "lockdown.")
      && ((uint64_t v5 = xpc_dictionary_get_string(a1, "Label"), sub_100015CAC(v5, "UIKitApplication:"))
       || (uint64_t v6 = xpc_dictionary_get_string(a1, "Label"), sub_100015CAC(v6, "AlternateSystemApplication:"))))
    {
      if (sub_100015D70(string, "SystemApp")) {
        unsigned int v3 = 7;
      }
      else {
        unsigned int v3 = 2;
      }
    }
    else
    {
      unsigned int v3 = 0;
    }
  }
  uint64_t v7 = v3;
  if ((*((unsigned char *)&unk_100075328 + 32 * v3 + 16) & 2) == 0) {
    sub_100040E80("invalid jetsam property category type: 0x%x", v3);
  }
  char v8 = xpc_dictionary_get_string(a1, "_JetsamPropertiesIdentifier");
  if (v8) {
    goto LABEL_16;
  }
  uint64_t v13 = (char *)xpc_dictionary_get_string(a1, "Label");
  if (sub_100015CAC(v13, "lockdown."))
  {
    uint64_t v14 = strchr(v13 + 9, 46);
    if (v14)
    {
      char v8 = v14 + 1;
LABEL_16:
      uint64_t v9 = sub_1000159F0(v8);
LABEL_17:
      uint64_t v10 = v9;
      goto LABEL_18;
    }
  }
  if (!sub_100015CAC(v13, "UIKitApplication:") && !sub_100015CAC(v13, "AlternateSystemApplication:"))
  {
    uint64_t v9 = strdup(v13);
    goto LABEL_17;
  }
  BOOL v15 = strchr(v13, 58);
  uint64_t v10 = sub_1000159F0(v15 + 1);
  uint64_t v16 = strrchr(v10, 91);
  if (v16)
  {
    *uint64_t v16 = 0;
    uint64_t v17 = strrchr(v10, 91);
    if (v17) {
      *uint64_t v17 = 0;
    }
  }
LABEL_18:
  xpc_object_t v11 = sub_10000EFCC(v10, (uint64_t)a1, (uint64_t)&unk_100075328 + 32 * v7);
  free(v10);
  return v11;
}

xpc_object_t sub_10000EFCC(const void *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_apply_f();
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  char v8 = 0;
  uint64_t v9 = 0;
  long long v27 = 0u;
  long long v28 = 0u;
  if ((*(unsigned char *)(a3 + 16) & 4) != 0)
  {
    uint64_t v10 = 0;
    char v11 = 1;
    do
    {
      char v12 = v11;
      uint64_t v13 = *(rb_tree_t ***)(a3 + 8 * v10);
      uint64_t v14 = (uint64_t)sub_100045ED4(v13, "Global");
      if (v14) {
        uint64_t v14 = sub_100046114();
      }
      *((void *)&v27 + 2 * v10) = v14;
      uint64_t v15 = (uint64_t)sub_100045ED4(v13, a1);
      if (v15) {
        uint64_t v15 = sub_100046114();
      }
      char v11 = 0;
      *((void *)&v27 + 2 * v10 + 1) = v15;
      uint64_t v10 = 1;
    }
    while ((v12 & 1) != 0);
    uint64_t v9 = (void *)*((void *)&v28 + 1);
    char v8 = (void *)v28;
    uint64_t v7 = (void *)*((void *)&v27 + 1);
    uint64_t v6 = (void *)v27;
  }
  xpc_object_t v16 = xpc_dictionary_create(0, 0, 0);
  for (uint64_t i = 0; i != 29; ++i)
  {
    char v18 = (&off_10006FAA0)[i];
    if (v9)
    {
      xpc_object_t value = xpc_dictionary_get_value(v9, (&off_10006FAA0)[i]);
      if (!v8) {
        goto LABEL_16;
      }
    }
    else
    {
      xpc_object_t value = 0;
      if (!v8) {
        goto LABEL_16;
      }
    }
    if (!value) {
      xpc_object_t value = xpc_dictionary_get_value(v8, v18);
    }
LABEL_16:
    if (!value)
    {
      xpc_object_t v20 = xpc_dictionary_get_value(v5, v18);
      xpc_object_t value = v20;
      if (v7 && !v20) {
        xpc_object_t value = xpc_dictionary_get_value(v7, v18);
      }
      if (v6 && !value) {
        xpc_object_t value = xpc_dictionary_get_value(v6, v18);
      }
    }
    xpc_dictionary_set_value(v16, v18, value);
  }
  uint64_t v21 = 0;
  char v22 = 1;
  do
  {
    char v23 = v22;
    uint64_t v24 = &v27 + v21;
    xpc_object_t v25 = (void *)*((void *)v24 + 1);
    if (v25) {
      xpc_release(v25);
    }
    if (*(void *)v24) {
      xpc_release(*(xpc_object_t *)v24);
    }
    char v22 = 0;
    uint64_t v21 = 1;
  }
  while ((v23 & 1) != 0);
  xpc_release(v5);
  return v16;
}

xpc_object_t sub_10000F1FC(const void *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  if ((byte_1000753B8 & 2) == 0) {
    sub_100040E80("invalid jetsam property category type: 0x%x", 4);
  }
  unsigned int v3 = v2;
  xpc_object_t v4 = sub_10000EFCC(a1, (uint64_t)v2, (uint64_t)&unk_1000753A8);
  xpc_release(v3);
  return v4;
}

xpc_object_t sub_10000F27C(const void *a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "ServiceType");
  unsigned int v4 = 5;
  if (string)
  {
    if (!strcasecmp(string, "System")) {
      unsigned int v4 = 6;
    }
    else {
      unsigned int v4 = 5;
    }
  }
  unsigned int v5 = v4;
  uint64_t v6 = (char *)&unk_100075328 + 32 * v4;
  if ((v6[16] & 2) == 0) {
    sub_100040E80("invalid jetsam property category type: 0x%x", v5);
  }
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v8 = sub_10000EFCC(a1, (uint64_t)v7, (uint64_t)v6);
  xpc_release(v7);
  return v8;
}

uint64_t sub_10000F338()
{
  return qword_100076968;
}

uint64_t sub_10000F344(uint64_t a1, char *__s1, void *a3)
{
  if (!sub_100015D70(__s1, "Global") && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_1000460A4();
    uint64_t v7 = *(void *)(a1 + 32);
    if ((*(unsigned char *)(v7 + 16) & 4) == 0) {
      sub_100040E80("jetsam property category (%s) is not initialized", *(const char **)(a1 + 40));
    }
    xpc_object_t v8 = v6;
    sub_100045E1C(*(void *)(v7 + 8 * *(unsigned int *)(a1 + 48)), __s1, v6);
    sub_10001A174(v8);
  }
  return 1;
}

void sub_10000F400(void *a1, const char *a2, const char *a3, unsigned char *a4)
{
  int v8 = sub_10000F50C(a1, a2, a4);
  int v9 = sub_10000F50C(a1, a3, a4);
  int v10 = v9;
  if (v8 < 1 || v9 < 1)
  {
    if (v8 < 0)
    {
      xpc_dictionary_set_value(a1, a2, 0);
      if ((v10 & 0x80000000) == 0) {
        return;
      }
    }
    else if ((v9 & 0x80000000) == 0)
    {
      return;
    }
  }
  else if (v9 >= v8)
  {
    sub_100014CD8(a4, 6, "%s is ignored in favor of %s", a3, a2);
  }
  else
  {
    sub_100014CD8(a4, 6, "%s is ignored in favor of %s", a2, a3);
    a3 = a2;
  }

  xpc_dictionary_set_value(a1, a3, 0);
}

int64_t sub_10000F50C(void *a1, const char *a2, unsigned char *a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    uint64_t v7 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
    {
      int64_t result = xpc_int64_get_value(v7);
      if ((unint64_t)(result - 0x7FFFFFFF) > 0xFFFFFFFF00000001) {
        return result;
      }
      sub_100014CD8(a3, 3, "%s is out of range, ignoring");
    }
    else
    {
      sub_100014CD8(a3, 3, "%s is not an int, ignoring");
    }
    xpc_dictionary_set_value(a1, a2, 0);
  }
  return 0xFFFFFFFFLL;
}

void sub_10000F5BC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x200000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFDFFFFFFFFFFFLL | v4;
}

void sub_10000F5DC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 256;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFEFFLL | v4;
}

void sub_10000F5FC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 512;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFDFFLL | v4;
}

void sub_10000F61C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4 = 0x800000000000;
  if (!a3) {
    uint64_t v4 = 0;
  }
  *((void *)&a2->var4 + 125) = *((void *)&a2->var4 + 125) & 0xFFFF7FFFFFFFFFFFLL | v4;
}

void sub_10000F63C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_10000522C((uint64_t)a2, "MallocSpaceEfficient", v4, 0);
}

void sub_10000F668(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_10000522C((uint64_t)a2, "MallocNanoZone", v4, 0);
}

void sub_10000F694(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_10000522C((uint64_t)a2, "MallocLargeCache", v4, 0);
}

void sub_10000F6C0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_10000522C((uint64_t)a2, "MallocAggressiveMadvise", v4, 0);
}

void sub_10000F6EC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3) {
    uint64_t v4 = "1";
  }
  else {
    uint64_t v4 = "0";
  }
  sub_10000522C((uint64_t)a2, "MallocMediumZone", v4, 0);
}

void sub_10000F718(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  if (a3 < 0)
  {
    sub_10001E4BC((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"MallocMaxMagazines");
  }
  else if (HIDWORD(a3))
  {
    sub_10001E4BC((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"MallocMaxMagazines");
  }
  else
  {
    char v11 = sub_100015BE4("%u", a3);
    if (v11)
    {
      char v12 = v11;
      sub_10000522C((uint64_t)a2, "MallocMaxMagazines", v11, 0);
      free(v12);
    }
    else
    {
      sub_100014CD8(a4, 3, "Could not convert value for MallocMaxMagazines to str: %lld", a3);
    }
  }
}

void sub_10000F808(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var60 = a3;
}

void sub_10000F810(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var60 = a3;
  a2->var4.var58 |= 4u;
}

void sub_10000F824(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var63 = a3;
}

void sub_10000F82C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var78 = a3;
}

void sub_10000F834(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var77 = a3;
}

void sub_10000F83C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var66 = a3;
}

void sub_10000F844(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var67 = a3;
}

void sub_10000F84C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var68 = a3;
}

void sub_10000F854(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var69 = a3;
}

void sub_10000F85C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var61 = a3;
}

void sub_10000F864(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var61 = a3;
  a2->var4.var58 |= 8u;
}

void sub_10000F878(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var59 = a3;
}

void sub_10000F880(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var74 = (int)a3;
}

void sub_10000F88C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var64 = a3;
}

void sub_10000F894(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var65 = a3;
}

void sub_10000F89C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var62 = a3;
}

void sub_10000F8A4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (sub_100015DB0(a3, "Efficient"))
  {
    a2->var4.var73 = 1;
  }
  else if (!sub_100015DB0(a3, "UserInterface"))
  {
    sub_100014CD8(a4, 3, "Unsupported value for EnergyEfficiencyMode: %s", a3);
  }
}

void sub_10000F928(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var70 = a3;
}

void sub_10000F930(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 16) & 4) != 0) {
    sub_100040E80("found multiple jetsam property plists for category %s", *(const char **)(a2 + 24));
  }
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(*(xpc_object_t *)(a1 + 32), *(const char **)(a2 + 24));
  if (dictionary)
  {
    uint64_t v4 = dictionary;
    uint64_t v5 = 0;
    char v6 = 1;
    do
    {
      char v7 = v6;
      int v8 = off_10006F330[v5];
      int v9 = sub_100045FAC();
      *(void *)(a2 + 8 * v5) = v9;
      xpc_object_t v10 = xpc_dictionary_get_dictionary(v4, v8);
      if (v10)
      {
        char v11 = v10;
        if (xpc_get_type(v10) == (xpc_type_t)&_xpc_type_dictionary)
        {
          applier[0] = _NSConcreteStackBlock;
          applier[1] = 0x40000000;
          applier[2] = sub_10000FA8C;
          applier[3] = &unk_10006FA80;
          applier[4] = v9;
          xpc_dictionary_apply(v11, applier);
        }
      }
      char v6 = 0;
      uint64_t v5 = 1;
    }
    while ((v7 & 1) != 0);
    *(_DWORD *)(a2 + 16) |= 4u;
  }
  else
  {
    sub_100043D78(65540, "did not initialize jetsam properties category: %s", *(const char **)(a2 + 24));
  }
}

uint64_t sub_10000FA8C(uint64_t a1, const void *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_1000460A4();
    char v6 = v5;
    sub_100045E1C(*(void *)(a1 + 32), a2, v5);
    sub_10001A174(v6);
  }
  return 1;
}

void sub_10000FB08(char *a1, void *a2, void *a3)
{
  uint64_t v6 = 0;
  while (1)
  {
    char v7 = (&off_10006FAA0)[v6];
    if (!strcasecmp(a1, v7)) {
      break;
    }
    if (++v6 == 29) {
      return;
    }
  }

  xpc_dictionary_set_value(a3, v7, a2);
}

void sub_10000FB9C(const char *a1)
{
  uint64_t v1 = sub_1000159F0(a1);
  if (qword_100075BC0 != -1) {
    dispatch_once(&qword_100075BC0, &stru_10006FBA8);
  }
  xpc_object_t v2 = qword_100075BB8;

  dispatch_sync_f(v2, v1, (dispatch_function_t)sub_10000FC14);
}

void sub_10000FC14(char *__s)
{
  int v2 = dword_100075428;
  if (dword_100075428 == -1)
  {
    int v2 = open("/dev/console", 131073);
    dword_100075428 = v2;
  }
  ssize_t v3 = strlen(__s);
  if (write(v2, __s, v3) < v3 && *__error() == 5)
  {
    sub_10003E54C((int *)dword_100075428);
    dword_100075428 = -1;
  }

  free(__s);
}

void sub_10000FCC0(char *a1, ...)
{
  va_start(va, a1);
  context[0] = 0;
  va_copy((va_list)&context[1], va);
  if (vasprintf((char **)context, a1, va) != -1)
  {
    if (qword_100075BC0 != -1) {
      dispatch_once(&qword_100075BC0, &stru_10006FBA8);
    }
    dispatch_async_f((dispatch_queue_t)qword_100075BB8, context[0], (dispatch_function_t)sub_10000FC14);
  }
}

void sub_10000FD44(char *a1, ...)
{
  va_start(va, a1);
  v1[0] = 0;
  va_copy((va_list)&v1[1], va);
  if (vasprintf((char **)v1, a1, va) != -1)
  {
    sub_10000FB9C((const char *)v1[0]);
    free(v1[0]);
  }
}

void sub_10000FD90(id a1)
{
  qword_100075BB8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.serialq", 0);
}

uint64_t sub_10000FDBC()
{
  return 49197;
}

uint64_t sub_10000FDC8()
{
  return sub_10000FDBC();
}

uint64_t sub_10000FDD4()
{
  return sub_10000FDBC();
}

double sub_10000FDFC()
{
  double result = 0.0;
  xmmword_100075C68 = 0u;
  unk_100075C78 = 0u;
  xmmword_100075C48 = 0u;
  unk_100075C58 = 0u;
  xmmword_100075C28 = 0u;
  unk_100075C38 = 0u;
  xmmword_100075C08 = 0u;
  unk_100075C18 = 0u;
  xmmword_100075BE8 = 0u;
  unk_100075BF8 = 0u;
  xmmword_100075BC8 = 0u;
  unk_100075BD8 = 0u;
  qword_100075C88 = 0;
  xmmword_10007542C = 0uLL;
  qword_10007543C = 0x7FFFFFFF00000000;
  unk_100075444 = 0;
  return result;
}

uint64_t sub_10000FE40(uint64_t result, uint64_t a2)
{
  if (result)
  {
    char v2 = a2;
    ssize_t v3 = (long long *)result;
    if (a2 == 7)
    {
      if ((long long *)result != &xmmword_10007542C)
      {
        BOOL v4 = *(void *)result == (void)xmmword_10007542C
          && *(void *)(result + 8) == *((void *)&xmmword_10007542C + 1);
        BOOL v5 = v4 && *(void *)(result + 16) == qword_10007543C;
        if (!v5 || *(void *)(result + 24) != unk_100075444)
        {
          if ((sub_10000FF94(result) & 0x80) == 0) {
            return 0;
          }
          long long v16 = v3[1];
          xmmword_10007542C = *v3;
          *(_OWORD *)&qword_10007543C = v16;
        }
      }
      return 1;
    }
    else
    {
      uint64_t v7 = 0;
      while (1)
      {
        if (BYTE8(xmmword_100075BC8[3 * ((qword_100075C88 + v7) & 3) + 2]))
        {
          int v8 = (void *)&xmmword_100075BC8[3 * ((qword_100075C88 + v7) & 3)] + 1;
          if (v8 == (void *)result) {
            break;
          }
          BOOL v9 = *(void *)result == *v8
            && *(void *)(result + 8) == *(void *)&xmmword_100075BC8[3
                                                                      * ((qword_100075C88
                                                                        + v7) & 3)
                                                                      + 1];
          BOOL v10 = v9
             && *(void *)(result + 16) == *((void *)&xmmword_100075BC8[3
                                                                         * ((qword_100075C88
                                                                           + v7) & 3)
                                                                         + 1]
                                            + 1);
          if (v10
            && *(void *)(result + 24) == *(void *)&xmmword_100075BC8[3
                                                                       * ((qword_100075C88
                                                                         + v7) & 3)
                                                                       + 2])
          {
            break;
          }
        }
        if (++v7 == 4)
        {
          unint64_t v12 = sub_10000FF94(result);
          qword_100075C88 = ((_BYTE)qword_100075C88 - 1) & 3;
          uint64_t v13 = &xmmword_100075BC8[3 * qword_100075C88];
          long long v14 = v3[1];
          *(long long *)((char *)v13 + 8) = *v3;
          *(long long *)((char *)v13 + 24) = v14;
          *(void *)uint64_t v13 = v12;
          *((unsigned char *)v13 + 40) = 1;
          unint64_t v15 = v12 >> v2;
          return v15 & 1;
        }
      }
      unint64_t v15 = *(void *)&xmmword_100075BC8[3 * ((qword_100075C88 + v7) & 3)] >> a2;
      return v15 & 1;
    }
  }
  return result;
}

uint64_t sub_10000FF94(uint64_t a1)
{
  xpc_object_t v1 = sub_100043720(a1);
  if (!v1) {
    return 0;
  }
  char v2 = v1;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  do
  {
    xpc_object_t value = xpc_dictionary_get_value(v2, off_10006FBC8[v3]);
    if (value)
    {
      uint64_t v6 = value;
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(v6)) {
        v4 |= 1 << v3;
      }
    }
    ++v3;
  }
  while (v3 != 39);
  xpc_release(v2);
  return v4;
}

uint64_t sub_100010044(uint64_t a1)
{
  if (*(_DWORD *)a1 >= 2u) {
    sub_100050E1C();
  }
  if (coalition_create() == -1) {
    sub_100050DFC();
  }
  if (!*(_DWORD *)a1 && *(void *)(a1 + 40) && coalition_ledger_set_logical_writes_limit() == -1) {
    sub_100050DFC();
  }
  return 0;
}

uint64_t sub_100010164()
{
  uint64_t result = coalition_terminate();
  if (result == -1) {
    return sub_100050E38();
  }
  return result;
}

uint64_t sub_100010190()
{
  uint64_t result = coalition_reap();
  if (result == -1) {
    return sub_100050E38();
  }
  return result;
}

uint64_t sub_1000101BC()
{
  uint64_t result = posix_spawnattr_setcoalition_np();
  if (result) {
    return _os_assumes_log_ctx();
  }
  return result;
}

void sub_100010214(uint64_t a1)
{
  free(*(void **)(a1 + 64));
  char v2 = *(NSObject **)(a1 + 72);
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = *(NSObject **)(a1 + 248);
  if (v3) {
    dispatch_release(v3);
  }
  uint64_t v4 = *(void **)(a1 + 80);
  if (v4) {
    xpc_release(v4);
  }
  BOOL v5 = *(void **)(a1 + 88);
  if (v5) {
    xpc_release(v5);
  }
  uint64_t v6 = *(const void **)(a1 + 256);

  _Block_release(v6);
}

uint64_t sub_100010280()
{
  uint64_t v0 = sub_100014B70();
  qword_100075C90 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v0);
  dispatch_source_set_timer((dispatch_source_t)qword_100075C90, 0, 1000000000 * dword_100075AB0, 0);
  dispatch_source_set_event_handler_f((dispatch_source_t)qword_100075C90, (dispatch_function_t)j__sync);
  dispatch_activate((dispatch_object_t)qword_100075C90);
  qword_100076970 = (uint64_t)dispatch_semaphore_create(10);
  uint64_t v1 = setiopolicy_np(9, 0, 1);
  if (v1) {
    uint64_t v1 = _os_assumes_log();
  }

  return nullsub_23(v1, v2);
}

void sub_100010348()
{
  block = _NSConcreteStackBlock;
  uint64_t v3 = 0x40000000;
  uint64_t v4 = sub_100010654;
  BOOL v5 = &unk_10006FD00;
  dispatch_queue_t v6 = (dispatch_queue_t)sub_100014B64();
  dispatch_sync(v6, &block);
  uint64_t v0 = sub_100014B70();
  block = _NSConcreteStackBlock;
  uint64_t v3 = 0x40000000;
  uint64_t v4 = sub_100010654;
  BOOL v5 = &unk_10006FD00;
  dispatch_queue_t v6 = v0;
  dispatch_sync(v0, &block);
  uint64_t v1 = sub_100014B7C();
  block = _NSConcreteStackBlock;
  uint64_t v3 = 0x40000000;
  uint64_t v4 = sub_100010654;
  BOOL v5 = &unk_10006FD00;
  dispatch_queue_t v6 = v1;
  dispatch_sync(v1, &block);
}

uint64_t sub_100010448()
{
  return qword_100076970;
}

unsigned char *sub_100010454(char a1, uint64_t a2)
{
  uint64_t v4 = sub_10001A8B8(0);
  v4[56] = a1;
  if (a2)
  {
    BOOL v5 = (const char *)xpc_bundle_copy_normalized_cryptex_path();
    *((void *)v4 + 8) = v5;
    if (sub_100019300(v5)) {
      char v6 = 4;
    }
    else {
      char v6 = 0;
    }
    v4[264] = v4[264] & 0xFB | v6;
  }
  return v4;
}

unsigned char *sub_1000104C4(int a1, uint64_t a2, int a3)
{
  uint64_t result = sub_100010454(a1, a2);
  if (a1 == 4) {
    *((_DWORD *)result + 60) = a3;
  }
  return result;
}

void sub_1000104F8(uint64_t a1, dispatch_object_t object, const void *a3)
{
  dispatch_retain(object);
  *(void *)(a1 + 248) = object;
  *(void *)(a1 + 256) = _Block_copy(a3);
  if (*(unsigned char *)(a1 + 56) == 4 || (*(unsigned char *)(a1 + 264) & 1) != 0)
  {
LABEL_7:
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
    uint64_t v7 = *(void (**)(void))(*(void *)(a1 + 256) + 16);
    v7();
    return;
  }
  if (sub_100019B70())
  {
    if (sub_100019300(*(const char **)(a1 + 64)))
    {
      int v6 = sub_100019354(a1);
      if (!v6) {
        return;
      }
      *(_DWORD *)(a1 + 240) = v6;
      goto LABEL_7;
    }
    if ((*(unsigned char *)(a1 + 264) & 4) != 0) {
      sub_100040E80("refusing to read cache protected location from disk: %s", *(const char **)(a1 + 64));
    }
  }

  sub_100014D54(a1);
}

uint64_t sub_100010604(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t sub_10001060C(uint64_t a1)
{
  return *(void *)(a1 + 72);
}

uint64_t sub_100010614(uint64_t a1)
{
  return *(unsigned char *)(a1 + 264) & 1;
}

uint64_t sub_100010620(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 264) >> 2) & 1;
}

xpc_object_t sub_10001062C(uint64_t a1)
{
  xpc_object_t result = *(xpc_object_t *)(a1 + 88);
  if (result) {
    return xpc_retain(result);
  }
  return result;
}

uint64_t sub_10001063C(uint64_t a1)
{
  return a1 + 96;
}

uint64_t sub_100010644(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t sub_10001064C(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

void sub_100010654(uint64_t a1)
{
}

BOOL sub_10001065C(const char *a1, char *__s)
{
  size_t v4 = strlen(__s);
  return sysctlbyname(a1, 0, 0, __s, v4 + 1) == 0;
}

void *sub_1000106A8(const char *a1)
{
  uint64_t v3 = 0;
  size_t v1 = sub_100042A54(a1, (char **)&v3);
  xpc_object_t result = v3;
  if (v1)
  {
    if (!v3) {
      sub_100050D0C();
    }
  }
  else
  {
    free(v3);
    return 0;
  }
  return result;
}

uint64_t sub_1000106F0(const char *a1)
{
  uint64_t v2 = 0;
  if (sub_100042BE4(a1, &v2) == 8) {
    return v2;
  }
  else {
    return 0;
  }
}

void *sub_100010724(size_t a1)
{
  if (!a1) {
    sub_100050D0C();
  }
  uint64_t v2 = sub_100013BB8(0x18uLL);
  uint64_t v3 = sub_100013BB8(a1);
  *uint64_t v3 = 0;
  void *v2 = v3;
  v2[1] = a1;
  v2[2] = 0;
  return v2;
}

char *sub_100010770(const char **a1)
{
  return sub_1000159F0(*a1);
}

void sub_100010778(void **a1)
{
  free(*a1);

  free(a1);
}

void sub_1000107B4(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __source[0] = 0;
  __source[1] = &a9;
  int v10 = vasprintf(__source, a2, &a9);
  if (v10 == -1)
  {
    sub_100050E38();
    return;
  }
  uint64_t v11 = *(void *)(a1 + 16);
  BOOL v12 = __CFADD__(v11, v10);
  unint64_t v13 = v11 + v10;
  if (v12) {
    uint64_t v14 = ((uint64_t)v10 >> 63) + 1;
  }
  else {
    uint64_t v14 = (uint64_t)v10 >> 63;
  }
  uint64_t v15 = v14 << 63 >> 63;
  if (v15 != v14 || v15 < 0) {
    goto LABEL_20;
  }
  unint64_t v16 = *(void *)(a1 + 8);
  if (v16 <= v13)
  {
    if ((v13 & 0x8000000000000000) == 0)
    {
      size_t v18 = 2 * v13;
      if (2 * v13 < 2 * v16) {
        sub_100050D0C();
      }
      uint64_t v17 = (char *)sub_100013BB8(2 * v13);
      if (strlcpy(v17, *(const char **)a1, v18) >= v18) {
        sub_100050D0C();
      }
      free(*(void **)a1);
      *(void *)a1 = v17;
      *(void *)(a1 + 8) = v18;
      goto LABEL_13;
    }
LABEL_20:
    __break(1u);
    return;
  }
  uint64_t v17 = *(char **)a1;
  size_t v18 = *(void *)(a1 + 8);
LABEL_13:
  size_t v19 = strlcat(v17, __source[0], v18);
  *(void *)(a1 + 16) = v19;
  if (v19 >= *(void *)(a1 + 8)) {
    sub_100050D0C();
  }
  free(__source[0]);
}

void *sub_1000108B8(void *result, unint64_t a2)
{
  unint64_t v2 = result[2];
  BOOL v3 = v2 >= a2;
  unint64_t v4 = v2 - a2;
  if (!v3) {
    sub_100050D0C();
  }
  result[2] = v4;
  *(unsigned char *)(*result + v4) = 0;
  return result;
}

uint64_t sub_1000108E8(long long *a1)
{
  long long v2 = a1[1];
  long long v5 = *a1;
  long long v6 = v2;
  long long v7 = a1[2];
  uint64_t v8 = *((void *)a1 + 6);
  if (!sub_10004EB88((uint64_t)&v5)) {
    return 0;
  }
  long long v3 = a1[1];
  long long v5 = *a1;
  long long v6 = v3;
  long long v7 = a1[2];
  uint64_t v8 = *((void *)a1 + 6);
  return ((uint64_t (*)(long long *))loc_10001095C)(&v5);
}

uint64_t xpc_create_from_ce_der(unint64_t a1, uint64_t a2)
{
  long long v12 = 0uLL;
  uint64_t v13 = 0;
  long long v2 = sub_10004F3CC(&qword_10006FD20, &v12, a1, a1 + a2);
  uint64_t result = 0;
  if (v2 == (void *)&unk_100071FD8)
  {
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    long long v4 = v12;
    *(void *)&long long v5 = v13;
    if ((_UNKNOWN *)sub_10004F754((uint64_t)&qword_10006FD20, &v4, (uint64_t)&v8) == &unk_100071FD8)
    {
      long long v4 = v8;
      long long v5 = v9;
      long long v6 = v10;
      uint64_t v7 = v11;
      return sub_1000108E8(&v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100010BF8(uint64_t *a1)
{
  uint64_t v2 = *a1;
  int v3 = *((_DWORD *)a1 + 29);
  if (v3 == 2)
  {
    if (*((_DWORD *)a1 + 28) == 1)
    {
      uint64_t v7 = (void *)a1[15];
      long long v14 = *(_OWORD *)(a1 + 7);
      long long v15 = *(_OWORD *)(a1 + 9);
      long long v16 = *(_OWORD *)(a1 + 11);
      uint64_t v17 = a1[13];
      uint64_t v25 = 0;
      long long v23 = 0u;
      long long v24 = 0u;
      long long v22 = 0u;
      memset((char *)v26 + 8, 0, 248);
      long long v8 = *(_OWORD *)(a1 + 9);
      v20[0] = *(_OWORD *)(a1 + 7);
      v20[1] = v8;
      v20[2] = *(_OWORD *)(a1 + 11);
      uint64_t v21 = a1[13];
      *(void *)&v26[0] = 2;
      sub_10004EB30((uint64_t)v20, (unint64_t)v26, (uint64_t)&v22);
      v26[0] = v22;
      v26[1] = v23;
      v26[2] = v24;
      *(void *)&v26[3] = v25;
      long long v9 = (char *)sub_100010EC4((uint64_t)v26);
      v18[0] = v14;
      v18[1] = v15;
      _OWORD v18[2] = v16;
      uint64_t v19 = v17;
      v26[0] = xmmword_100053CE0;
      memset(&v26[1], 0, 240);
      sub_10004EB30((uint64_t)v18, (unint64_t)v26, (uint64_t)v20);
      xpc_object_t empty = (xpc_object_t)((uint64_t (*)(_OWORD *))loc_10001095C)(v20);
      xpc_dictionary_set_value(v7, v9, empty);
      free(v9);
    }
    else
    {
      xpc_object_t empty = xpc_array_create_empty();
      long long v11 = *(_OWORD *)(a1 + 9);
      v26[0] = *(_OWORD *)(a1 + 7);
      v26[1] = v11;
      v26[2] = *(_OWORD *)(a1 + 11);
      *(void *)&v26[3] = a1[13];
      if (sub_10004ECD0((unint64_t)v26, (uint64_t)empty, (uint64_t)sub_100010BF8) != &unk_100071FD8)
      {
        uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_manufacturingCallback", "CoreEntitlements: Couldn't iterate over DER entitlements\n");
        return (uint64_t)sub_100010EC4(v13);
      }
      xpc_array_set_value((xpc_object_t)a1[15], 0xFFFFFFFFFFFFFFFFLL, empty);
    }
    long long v6 = empty;
    goto LABEL_10;
  }
  if (v3)
  {
    if (*((_DWORD *)a1 + 28) == 2)
    {
      long long v4 = *(_OWORD *)(a1 + 9);
      v26[0] = *(_OWORD *)(a1 + 7);
      v26[1] = v4;
      v26[2] = *(_OWORD *)(a1 + 11);
      *(void *)&v26[3] = a1[13];
      long long v5 = (void *)((uint64_t (*)(_OWORD *))loc_10001095C)(v26);
      xpc_array_set_value((xpc_object_t)a1[15], 0xFFFFFFFFFFFFFFFFLL, v5);
      long long v6 = v5;
LABEL_10:
      xpc_release(v6);
      return 1;
    }
    uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_manufacturingCallback", "CoreEntitlements: not a sequence");
  }
  else
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_manufacturingCallback", "CoreEntitlements: unknown DER type");
  }
  return (uint64_t)sub_100010EC4(v13);
}

void *sub_100010EC4(uint64_t a1)
{
  long long v1 = *(_OWORD *)(a1 + 16);
  v7[0] = *(_OWORD *)a1;
  v7[1] = v1;
  v7[2] = *(_OWORD *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 48);
  uint64_t v2 = (const void *)sub_10004F174((unint64_t *)v7);
  size_t v4 = v3;
  long long v5 = sub_100013BB8(v3 + 1);
  memcpy(v5, v2, v4);
  return v5;
}

void *sub_100010F34(int a1, size_t size)
{
  return malloc_type_malloc(size, 0x78220757uLL);
}

void sub_100010F44(int a1, void *a2)
{
}

void sub_100010F4C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_100010F7C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  qword_100075AF8 = (uint64_t)"Data corruption: CoreEntitlements has aborted due to an unrecoverable error";
  __break(1u);
}

void sub_100010FC0()
{
  qword_100075C98 = 0;
}

void sub_100010FCC()
{
  uint64_t v0 = (char *)sub_10001115C("ReleaseType");
  sub_1000112A0("kern.osreleasetype", v0);
  if (byte_100076A80)
  {
    long long v1 = (char *)sub_1000106A8("kern.osversion");
    if (v1)
    {
      uint64_t v2 = v1;
      size_t v3 = sub_10001115C("ProductBuildVersion");
      if (v3)
      {
        size_t v4 = v3;
        if (!sub_100015D70(v2, v3)) {
          sub_100040EE4("Userspace reboot changed system version: previous %s != current %s", v2, v4);
        }
        free(v2);
      }
      else
      {
        sub_100043D78(65539, "Missing ProductBuildVersion");
      }
    }
    else
    {
      uint64_t v7 = __error();
      sub_100043D78(65539, "Unable to reload kern.osversion: %d", *v7);
    }
  }
  else
  {
    long long v5 = (char *)sub_10001115C("ProductVersion");
    sub_1000112A0("kern.osproductversion", v5);
    long long v6 = (char *)sub_10001115C("ProductBuildVersion");
    sub_1000112A0("kern.osversion", v6);
  }
}

const char *sub_10001112C()
{
  uint64_t result = sub_10001115C("ProductBuildVersion");
  if (!result) {
    return "99Z999";
  }
  return result;
}

const char *sub_10001115C(char *key)
{
  if (!qword_100075C98)
  {
    uint64_t v2 = sub_10003E594("/System/Library/CoreServices/SystemVersion.plist");
    if (qword_100075C98) {
      sub_100050D0C();
    }
    size_t v3 = v2;
    xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
    qword_100075C98 = (uint64_t)v4;
    if (v3)
    {
      sub_100011320(v4, v3, "ProductVersion");
      sub_100011320((void *)qword_100075C98, v3, "ProductBuildVersion");
      sub_100011320((void *)qword_100075C98, v3, "iOSSupportVersion");
      sub_100011320((void *)qword_100075C98, v3, "ReleaseType");
      xpc_object_t v4 = (xpc_object_t)qword_100075C98;
    }
    if (!xpc_dictionary_get_string(v4, "ReleaseType")) {
      xpc_dictionary_set_string((xpc_object_t)qword_100075C98, "ReleaseType", "User");
    }
    if (v3) {
      xpc_release(v3);
    }
  }
  long long v5 = (void *)qword_100075C98;

  return xpc_dictionary_get_string(v5, key);
}

BOOL sub_100011260(const char *a1)
{
  uint64_t v2 = (char *)sub_10001115C("ReleaseType");

  return sub_100015D50(v2, a1);
}

void sub_1000112A0(const char *a1, char *a2)
{
  if (a2)
  {
    xpc_object_t v4 = (unsigned __int8 *)sub_1000106A8(a1);
    if (v4 && (int v5 = *v4, free(v4), v5))
    {
      sub_100043D78(4, "%s is already set, skipping", a1);
    }
    else if (!sub_10001065C(a1, a2))
    {
      sub_100050E58(a1);
    }
  }
}

void sub_100011320(void *a1, xpc_object_t xdict, char *key)
{
  string = xpc_dictionary_get_string(xdict, key);
  if (string)
  {
    xpc_dictionary_set_string(a1, key, string);
  }
}

void *sub_10001137C()
{
  uint64_t v0 = sub_10001A618(0);
  v0[4] = 8;
  v0[2] = sub_100013BB8(0x40uLL);
  return v0;
}

void sub_1000113BC(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    unint64_t v2 = 0;
    do
      os_release(*(void **)(*(void *)(a1 + 16) + 8 * v2++));
    while (v2 < *(void *)(a1 + 24));
  }
  size_t v3 = *(void **)(a1 + 16);

  free(v3);
}

void *sub_100011418(void *result, void *object)
{
  size_t v3 = result;
  unint64_t v4 = result[3];
  unint64_t v5 = result[4];
  if (v4 == v5)
  {
    result[4] = 2 * v4;
    if ((v4 & 0x8000000000000000) != 0 || (2 * v4) >> 61 || (uint64_t result = sub_100013BB8(16 * v4), v6 = v3[3], v6 >> 61))
    {
      __break(1u);
      return result;
    }
    uint64_t v7 = result;
    uint64_t v8 = (void *)v3[2];
    memcpy(result, v8, 8 * v6);
    free(v8);
    v3[2] = v7;
    unint64_t v4 = v3[3];
    unint64_t v5 = v3[4];
  }
  if (v4 >= v5) {
    sub_100050D0C();
  }
  uint64_t result = os_retain(object);
  uint64_t v9 = v3[3];
  *(void *)(v3[2] + 8 * v9) = result;
  v3[3] = v9 + 1;
  return result;
}

void sub_1000114C4(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 24) <= a2) {
    sub_100050D0C();
  }
  os_release(*(void **)(*(void *)(a1 + 16) + 8 * a2));
  uint64_t v4 = *(void *)(a1 + 24);
  *(void *)(*(void *)(a1 + 16) + 8 * a2) = 0;
  *(void *)(a1 + 24) = v4 - 1;
  if (v4 - 1 > a2)
  {
    uint64_t v5 = *(void *)(a1 + 16) + 8 * a2;
    memmove((void *)v5, (const void *)(v5 + 8), 8 * (v4 - 1 - a2));
  }
}

uint64_t sub_100011548(uint64_t a1, unint64_t a2)
{
  if (*(void *)(a1 + 24) <= a2) {
    sub_100050D0C();
  }
  return *(void *)(*(void *)(a1 + 16) + 8 * a2);
}

uint64_t sub_100011574(uint64_t a1)
{
  return *(void *)(a1 + 24);
}

uint64_t sub_100011580()
{
  return kdebug_trace();
}

uint64_t sub_100011594()
{
  return kdebug_trace();
}

uint64_t sub_1000115A4()
{
  return kdebug_trace();
}

uint64_t sub_1000115B0(uint64_t a1, const char *a2)
{
  strncpy(__dst, a2, 0x20uLL);
  return kdebug_trace();
}

uint64_t sub_100011620(void *a1)
{
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2000000000;
  xpc_object_t empty = 0;
  xpc_object_t empty = xpc_array_create_empty();
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_1000117B0;
  applier[3] = &unk_10006FD70;
  applier[4] = &v12;
  xpc_dictionary_apply(a1, applier);
  size_t count = xpc_array_get_count((xpc_object_t)v13[3]);
  do
  {
    if (count < 2) {
      break;
    }
    size_t v3 = 0;
    for (size_t i = 1; i != count; ++i)
    {
      xpc_object_t value = xpc_array_get_value((xpc_object_t)v13[3], i - 1);
      xpc_object_t v6 = xpc_array_get_value((xpc_object_t)v13[3], i);
      string_ptr = xpc_string_get_string_ptr(value);
      uint64_t v8 = xpc_string_get_string_ptr(v6);
      if (strcmp(string_ptr, v8) >= 1)
      {
        xpc_retain(value);
        xpc_array_set_value((xpc_object_t)v13[3], i - 1, v6);
        xpc_array_set_value((xpc_object_t)v13[3], i, value);
        xpc_release(value);
        size_t v3 = i;
      }
    }
    size_t count = v3;
  }
  while (v3);
  uint64_t v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t sub_1000117B0(uint64_t a1, char *string)
{
  return 1;
}

xpc_object_t sub_1000117E0(int64_t a1, int64_t a2, xpc_object_t object)
{
  if (object && xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0;
  }
  xpc_object_t empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_int64(empty, "vers", a1);
  xpc_dictionary_set_int64(empty, "comp", 1);
  xpc_dictionary_set_int64(empty, "ccat", a2);
  if (object) {
    xpc_dictionary_set_value(empty, "reqs", object);
  }
  return empty;
}

size_t sub_100011890(void *a1)
{
  if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0;
  }
  xpc_object_t empty = xpc_array_create_empty();
  if (sub_100011CD4(a1, empty))
  {
    xpc_release(empty);
    return 0;
  }
  if (!empty) {
    return 0;
  }
  size_t result = xpc_array_get_count(empty);
  if (!(result >> 59))
  {
    uint64_t v5 = (void **)sub_100013BB8(32 * result);
    length[0] = (size_t)_NSConcreteStackBlock;
    length[1] = 0x40000000;
    length[2] = (size_t)sub_100012380;
    length[3] = (size_t)&unk_10006FDE0;
    length[4] = (size_t)v5;
    xpc_array_apply(empty, length);
    size_t count = xpc_array_get_count(empty);
    length[0] = 0;
    xpc_object_t v3 = 0;
    if (sub_10004D5B4(v5, count, (uint64_t *)length) == (void *)&unk_100071FD8)
    {
      uint64_t v7 = sub_100013BB8(length[0]);
      char v12 = 1;
      if (sub_10004D694(&qword_10006FD20, &v12, (unint64_t)v5, count, (unint64_t)v7, (unint64_t)v7 + length[0]) == (void *)&unk_100071FD8)xpc_object_t v3 = xpc_data_create(v7, length[0]); {
      else
      }
        xpc_object_t v3 = 0;
      free(v7);
    }
    size_t v8 = xpc_array_get_count(empty);
    if (v8)
    {
      size_t v9 = v8;
      long long v10 = v5 + 1;
      do
      {
        if (*(v10 - 1) == (void *)3) {
          free(*v10);
        }
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    free(v5);
    xpc_release(empty);
    return (size_t)v3;
  }
  __break(1u);
  return result;
}

uint64_t sub_100011A64(unint64_t a1, uint64_t a2)
{
  long long v13 = 0uLL;
  uint64_t v14 = 0;
  char v12 = 1;
  unint64_t v2 = sub_10004F40C(&qword_10006FD20, &v12, &v13, a1, a1 + a2);
  uint64_t result = 0;
  if (v2 == (void *)&unk_100071FD8)
  {
    long long v10 = 0u;
    long long v11 = 0u;
    long long v8 = 0u;
    long long v9 = 0u;
    long long v4 = v13;
    *(void *)&long long v5 = v14;
    if ((_UNKNOWN *)sub_10004F754((uint64_t)&qword_10006FD20, &v4, (uint64_t)&v8) == &unk_100071FD8)
    {
      long long v4 = v8;
      long long v5 = v9;
      long long v6 = v10;
      uint64_t v7 = v11;
      return sub_1000108E8(&v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

size_t sub_100011B38(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  *((void *)&v15 + 1) = 0;
  xpc_object_t v6 = sub_100011C5C(a1, a2, (int64_t *)&v15 + 1);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  *(void *)&long long v15 = 0;
  xpc_object_t v8 = sub_100011C5C(a3, a4, (int64_t *)&v15);
  if (v8)
  {
    long long v9 = v8;
    if (v15 == 0)
    {
      xpc_object_t empty = xpc_dictionary_create_empty();
      xpc_dictionary_set_value(empty, "$and", v9);
      xpc_object_t v12 = xpc_dictionary_create_empty();
      xpc_dictionary_set_value(v12, "$and", v7);
      xpc_dictionary_set_value(v12, "$or", empty);
      xpc_release(empty);
      xpc_object_t v13 = sub_1000117E0(1, 0, v12);
      xpc_release(v12);
      size_t v10 = sub_100011890(v13);
      xpc_release(v13);
    }
    else
    {
      size_t v10 = 0;
    }
    xpc_release(v7);
  }
  else
  {
    size_t v10 = 0;
    long long v9 = v7;
  }
  xpc_release(v9);
  return v10;
}

xpc_object_t sub_100011C5C(unint64_t a1, uint64_t a2, int64_t *a3)
{
  long long v4 = (void *)sub_100011A64(a1, a2);
  if (!v4) {
    return 0;
  }
  long long v5 = v4;
  xpc_object_t value = xpc_dictionary_get_value(v4, "reqs");
  xpc_object_t v7 = value;
  if (value) {
    xpc_retain(value);
  }
  *a3 = xpc_dictionary_get_int64(v5, "ccat");
  xpc_release(v5);
  return v7;
}

uint64_t sub_100011CD4(void *a1, void *a2)
{
  uint64_t v8 = 0;
  long long v9 = &v8;
  uint64_t v10 = 0x2000000000;
  int v11 = 4;
  long long v4 = (void *)sub_100011620(a1);
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t bytes = 7;
  uint64_t v13 = 0;
  xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_100011DF0;
  applier[3] = &unk_10006FD98;
  void applier[5] = a2;
  void applier[6] = a1;
  applier[4] = &v8;
  xpc_array_apply(v4, applier);
  xpc_release(v4);
  uint64_t v5 = *((unsigned int *)v9 + 6);
  if (!v5)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t bytes = 8;
    uint64_t v13 = 0;
    xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
    uint64_t v5 = *((unsigned int *)v9 + 6);
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t sub_100011DF0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void **)(a1 + 40);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t bytes = 5;
  uint64_t v16 = 0;
  xpc_array_set_data(v5, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
  string_ptr = xpc_string_get_string_ptr(a3);
  v12[3] = 0;
  v12[0] = 3;
  v12[1] = sub_1000159F0(string_ptr);
  v12[2] = xpc_string_get_length(a3);
  xpc_array_set_data(*(xpc_object_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, v12, 0x20uLL);
  xpc_object_t v7 = *(void **)(a1 + 48);
  uint64_t v8 = xpc_string_get_string_ptr(a3);
  xpc_object_t value = xpc_dictionary_get_value(v7, v8);
  if (value)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100012028(value, *(void **)(a1 + 40));
    if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      uint64_t bytes = 0;
      uint64_t v16 = 0;
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      if ((_dyld_get_image_uuid() & 1) == 0)
      {
        uint64_t bytes = 0;
        uint64_t v16 = 0;
      }
      if (_dyld_get_shared_cache_uuid())
      {
        _dyld_get_shared_cache_range();
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
      }
      xpc_string_get_string_ptr(a3);
      _os_log_simple();
      return 0;
    }
    else
    {
      uint64_t v10 = *(void **)(a1 + 40);
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t bytes = 6;
      uint64_t v16 = 0;
      xpc_array_set_data(v10, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
      return 1;
    }
  }
  else
  {
    uint64_t bytes = 0;
    uint64_t v16 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    if ((_dyld_get_image_uuid() & 1) == 0)
    {
      uint64_t bytes = 0;
      uint64_t v16 = 0;
    }
    if (_dyld_get_shared_cache_uuid())
    {
      _dyld_get_shared_cache_range();
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
    }
    xpc_string_get_string_ptr(a3);
    _os_log_simple();
    uint64_t result = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 2;
  }
  return result;
}

uint64_t sub_100012028(void *a1, void *a2)
{
  xpc_type_t type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v16 = 0;
    uint64_t bytes = 2;
    int64_t string_ptr = (int64_t)xpc_string_get_string_ptr(a1);
    size_t length = xpc_string_get_length(a1);
LABEL_12:
    uint64_t v15 = (BOOL (*)(uint64_t, uint64_t, uint64_t))length;
LABEL_16:
    LOBYTE(v16) = 0;
    xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
    return 0;
  }
  uint64_t v5 = type;
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t bytes = 4;
    uint64_t v16 = 0;
    int64_t string_ptr = xpc_int64_get_value(a1);
LABEL_15:
    uint64_t v15 = 0;
    goto LABEL_16;
  }
  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t bytes = 1;
    uint64_t v16 = 0;
    int64_t string_ptr = xpc_BOOL_get_value(a1);
    goto LABEL_15;
  }
  if (type == (xpc_type_t)&_xpc_type_data)
  {
    uint64_t v16 = 0;
    uint64_t bytes = 9;
    int64_t string_ptr = (int64_t)xpc_data_get_bytes_ptr(a1);
    size_t length = xpc_data_get_length(a1);
    goto LABEL_12;
  }
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (type == (xpc_type_t)&_xpc_type_array)
    {
      uint64_t v9 = 0;
      uint64_t v10 = &v9;
      uint64_t v11 = 0x2000000000;
      int v12 = 4;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t bytes = 5;
      int64_t string_ptr = 0;
      xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
      uint64_t bytes = (uint64_t)_NSConcreteStackBlock;
      int64_t string_ptr = 0x40000000;
      uint64_t v15 = sub_100012334;
      uint64_t v16 = &unk_10006FDC0;
      uint64_t v17 = &v9;
      uint64_t v18 = a2;
      xpc_array_apply(a1, &bytes);
      uint64_t v7 = *((unsigned int *)v10 + 6);
      if (!v7)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        uint64_t v19 = 6;
        uint64_t v20 = 0;
        xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &v19, 0x20uLL);
        uint64_t v7 = *((unsigned int *)v10 + 6);
      }
      _Block_object_dispose(&v9, 8);
    }
    else
    {
      uint64_t bytes = 0;
      int64_t string_ptr = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      if ((_dyld_get_image_uuid() & 1) == 0)
      {
        uint64_t bytes = 0;
        int64_t string_ptr = 0;
      }
      if (_dyld_get_shared_cache_uuid())
      {
        uint64_t v9 = 0;
        _dyld_get_shared_cache_range();
      }
      else
      {
        uint64_t v19 = 0;
        uint64_t v20 = 0;
      }
      xpc_type_get_name(v5);
      _os_log_simple();
      return 1;
    }
    return v7;
  }

  return sub_100011CD4(a1, a2);
}

BOOL sub_100012334(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100012028(a3, *(void *)(a1 + 40));
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t sub_100012380(uint64_t a1, uint64_t a2, xpc_object_t xdata)
{
  xpc_object_t v3 = (_OWORD *)(*(void *)(a1 + 32) + 32 * a2);
  bytes_ptr = xpc_data_get_bytes_ptr(xdata);
  long long v5 = bytes_ptr[1];
  *xpc_object_t v3 = *bytes_ptr;
  v3[1] = v5;
  return 1;
}

void *sub_1000123B8()
{
  uint64_t v0 = sub_100013BB8(0x18uLL);
  os_map_str_init();
  return v0;
}

size_t sub_1000123F0(uint64_t a1, const char *a2)
{
  xpc_object_t v3 = (_DWORD *)os_map_str_find();
  if (v3)
  {
    ++*v3;
    return (size_t)(v3 + 1);
  }
  size_t v5 = strlen(a2);
  size_t v6 = v5 + 4;
  BOOL v7 = v5 >= 0xFFFFFFFFFFFFFFFCLL;
  size_t result = v5 + 5;
  uint64_t v9 = v6 == -1;
  uint64_t v10 = v9 << 63 >> 63;
  BOOL v11 = v10 != v9;
  if (!v7 && !v11 && (v10 & 0x8000000000000000) == 0)
  {
    int v12 = sub_100013BB8(result);
    long long v4 = v12 + 1;
    size_t v13 = strlen(a2);
    memcpy(v12 + 1, a2, v13);
    *int v12 = 1;
    os_map_str_insert();
    return (size_t)v4;
  }
  __break(1u);
  return result;
}

void sub_1000124B0()
{
  uint64_t v0 = (_DWORD *)os_map_str_find();
  if (!v0) {
    sub_100050EB4();
  }
  long long v1 = v0;
  if ((*v0)-- == 1)
  {
    os_map_str_delete();
    free(v1);
  }
}

void sub_10001252C(void *a1)
{
  if (os_map_str_count()) {
    sub_100050ED0();
  }
  os_map_str_destroy();

  free(a1);
}

unsigned char *sub_100012574(uint64_t a1, const char *a2, const char *a3, int a4, uint64_t a5)
{
  if (!a1) {
    sub_100050D0C();
  }
  uint64_t v10 = sub_10001AAA4(0);
  v10[16] = 0;
  *((_DWORD *)v10 + 5) = a4;
  *((void *)v10 + 3) = a1;
  *((void *)v10 + 4) = 1;
  *((void *)v10 + 5) = 0;
  if (a2) {
    *((void *)v10 + 5) = sub_1000159F0(a2);
  }
  *((void *)v10 + 6) = 0;
  if (a3) {
    *((void *)v10 + 6) = sub_1000159F0(a3);
  }
  *((void *)v10 + 7) = 0;
  *((void *)v10 + 8) = a5;
  return v10;
}

void sub_100012608(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16) != 2) {
    sub_100050D0C();
  }
  if (*(void *)(a1 + 32)) {
    sub_100050D0C();
  }
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  unint64_t v2 = *(void **)(a1 + 56);

  free(v2);
}

uint64_t sub_100012668(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 32);
  if (!v1) {
    sub_100050D0C();
  }
  if (*(unsigned char *)(result + 16)) {
    sub_100050D0C();
  }
  *(void *)(result + 32) = v1 + 1;
  return result;
}

uint64_t sub_10001269C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    sub_100050D0C();
  }
  if (*(unsigned char *)(a1 + 16)) {
    sub_100050D0C();
  }
  uint64_t v3 = v1 - 1;
  *(void *)(a1 + 32) = v3;
  if (!v3)
  {
    *(unsigned char *)(a1 + 16) = 1;
    (*(void (**)(void))(a1 + 64))(*(void *)(a1 + 24));
  }
  return a1;
}

void *sub_1000126F8(void *result, const void *a2)
{
  if (result[4]) {
    sub_100050D0C();
  }
  unint64_t v2 = result;
  if (*((unsigned char *)result + 16) != 1) {
    sub_100050D0C();
  }
  *((unsigned char *)result + 16) = 2;
  if (a2)
  {
    size_t result = sub_1000159AC(a2, 0x160uLL);
    v2[7] = result;
  }
  return result;
}

uint64_t sub_100012750(uint64_t a1)
{
  return *(void *)(a1 + 40);
}

uint64_t sub_100012758(uint64_t a1)
{
  return *(void *)(a1 + 48);
}

uint64_t sub_100012760(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t sub_100012768(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_100012770(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 16) != a2) {
    sub_100050D0C();
  }
  return result;
}

uint64_t sub_100012794()
{
  return os_map_str_init();
}

void sub_1000127A8(uint64_t a1)
{
  uint64_t v2 = os_map_str_delete();
  if (v2 != a1)
  {
    if (v2) {
      sub_100043D78(65539, "SERVICE CACHE DELETE UNEXPECTEDLY DELAYED: %s replaced: %s by %s, %s by %s");
    }
    else {
      sub_100043D78(65539, "SERVICE CACHE DELETE INVARIANT VIOLATED: %s not found");
    }
  }
  xpc_release(*(xpc_object_t *)(a1 + 24));
  free(*(void **)(a1 + 16));
  uint64_t v3 = *(void **)(a1 + 32);

  free(v3);
}

void *sub_100012858(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t property = xpc_bundle_get_property();
  if (!property)
  {
    *a3 = 107;
    long long v26 = "Could not get path for service bundle.";
LABEL_11:
    sub_10002A5B8(a1, 3, v26, v6, v7, v8, v9, v10, v28);
    return 0;
  }
  BOOL v11 = (const char *)property;
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary();
  if (!info_dictionary)
  {
    *a3 = 107;
    char v28 = (char)v11;
    long long v26 = "Could not get Info.plist for bundle at %s";
    goto LABEL_11;
  }
  size_t v13 = info_dictionary;
  string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier");
  if (!string)
  {
    sub_10002A5B8(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v15, v16, v17, v18, v19, (char)v11);
    uint64_t v25 = 0;
    *a3 = 107;
    return v25;
  }
  uint64_t v20 = (char *)string;
  uint64_t executable_path = (char *)xpc_bundle_get_executable_path();
  uint64_t v22 = os_map_str_find();
  if (!v22) {
    goto LABEL_8;
  }
  long long v23 = (const char **)v22;
  long long v24 = (const char *)(v22 + 40);
  if (!sub_100015D70(v20, (const char *)(v22 + 40)))
  {
    sub_100043D78(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", v11, v20, v24);
LABEL_16:
    os_map_str_delete();
    goto LABEL_8;
  }
  if (!sub_100015D70(executable_path, v23[2]))
  {
    sub_100043D78(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", v11, executable_path, v23[2]);
    goto LABEL_16;
  }
  uint64_t v25 = sub_10001A0AC(v23);
  if (!v25)
  {
LABEL_8:
    uint64_t v25 = sub_10001AB24(v20);
    v25[2] = sub_1000159F0(executable_path);
    v25[3] = xpc_retain(v13);
    v25[4] = sub_1000159F0(v11);
    os_map_str_insert();
  }
  return v25;
}

uint64_t sub_100012A1C(uint64_t a1, uint64_t a2)
{
  bzero((void *)a1, 0x728uLL);
  *(void *)(a1 + 1128) = 0x6400000064;
  if (posix_spawnattr_init((posix_spawnattr_t *)a1)) {
    sub_100050D28();
  }
  uint64_t result = posix_spawn_file_actions_init((posix_spawn_file_actions_t *)(a1 + 8));
  if (result) {
    sub_100050D28();
  }
  *(void *)(a1 + 1208) = a2;
  return result;
}

void sub_100012A74(uint64_t a1)
{
  posix_spawnattr_destroy((posix_spawnattr_t *)a1);
  posix_spawn_file_actions_destroy((posix_spawn_file_actions_t *)(a1 + 8));
  while (1)
  {
    uint64_t v2 = *(void **)(a1 + 1824);
    if (!v2) {
      break;
    }
    *(void *)(a1 + 1824) = *v2;
    free(v2);
  }
  free(*(void **)(a1 + 1216));
  free(*(void **)(a1 + 1232));
  if (*(void *)(a1 + 1248))
  {
    uint64_t v3 = *(void **)(a1 + 1240);
    free(v3);
  }
}

uint64_t sub_100012AF0(posix_spawnattr_t *a1, __int16 a2, __int16 a3)
{
  __int16 v7 = 0;
  if (posix_spawnattr_getflags(a1, &v7)) {
    sub_100050D28();
  }
  __int16 v7 = v7 & ~a3 | a2;
  uint64_t result = posix_spawnattr_setflags(a1, v7);
  if (result) {
    sub_100050D28();
  }
  return result;
}

uint64_t sub_100012B60(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  if (!*(void *)(a1 + 1208))
  {
    uint64_t v21 = "Missing program";
    uint64_t v22 = 22;
    int v23 = 580;
    return sub_10001FDA8(a1, v22, 0, v23, 0, v21, a7, a8, v117);
  }
  if (*(unsigned char *)(a2 + 108)) {
    __int16 v12 = 16512;
  }
  else {
    __int16 v12 = 0x4000;
  }
  unsigned int v13 = *(_DWORD *)(a2 + 236);
  if ((v13 & 0x4000) == 0 || MEMORY[0xFFFFF4084] == 0) {
    __int16 v15 = 1024;
  }
  else {
    __int16 v15 = 1280;
  }
  int v16 = *(_DWORD *)(a2 + 236);
  if ((v13 & 0x8000) != 0)
  {
    if (posix_spawnattr_disable_ptr_auth_a_keys_np()) {
      sub_100050D28();
    }
    int v16 = *(_DWORD *)(a2 + 236);
  }
  if ((v16 & 0x40000) != 0)
  {
    if (posix_spawnattr_set_use_sec_transition_shims_np()) {
      sub_100050D28();
    }
    int v16 = *(_DWORD *)(a2 + 236);
  }
  sub_100012AF0((posix_spawnattr_t *)v8, (v13 >> 8) & 0x200 | v12 | (v13 >> 7) & 0x8000 | v15 | HIWORD(v16) & 0x800, 0);
  uint64_t v17 = (cpu_type_t *)_xpc_spawnattr_binprefs_unpack(a2, a3);
  if (v17)
  {
    uint64_t v18 = v17;
    xpc_binprefs_set_psattr(v17, (posix_spawnattr_t *)v8);
    free(v18);
  }
  qos_class_t v19 = *(_DWORD *)(a2 + 200);
  if (v19 && posix_spawnattr_set_qos_class_np((posix_spawnattr_t *)v8, v19)) {
    sub_100050D28();
  }
  int v20 = *(_DWORD *)(a2 + 236);
  if ((v20 & 0x200000) != 0)
  {
    if ((*(unsigned char *)(a2 + 228) != 100 || *(_DWORD *)(a2 + 224)) && posix_spawnattr_setcpumonitor()) {
      sub_100050D28();
    }
  }
  else if ((v20 & 2) != 0)
  {
    if (posix_spawnattr_setcpumonitor_default()) {
      sub_100050D28();
    }
  }
  else if ((v20 & 1) == 0 && posix_spawnattr_setcpumonitor_default())
  {
    sub_100050D28();
  }
  if (posix_spawnattr_setjetsam_ext()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_threadlimit_ext()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_max_addr_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_portlimits_ext()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_filedesclimit_ext()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_kqworklooplimit_ext()) {
    sub_100050D28();
  }
  if ((*(unsigned char *)(a2 + 239) & 2) != 0 && posix_spawnattr_set_max_addr_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_crash_behavior_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_crash_behavior_deadline_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_launch_type_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_crash_count_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_darwin_role_np()) {
    sub_100050D28();
  }
  int v25 = *(unsigned __int8 *)(a2 + 229);
  if (v25 == 1)
  {
    if (posix_spawnattr_setdataless_iopolicy_np()) {
      sub_100050D28();
    }
  }
  else if (v25 == 2 && posix_spawnattr_setdataless_iopolicy_np())
  {
    sub_100050D28();
  }
  unsigned int v26 = *(_DWORD *)(a2 + 80);
  if (v26)
  {
    long long v27 = _xpc_spawnattr_unpack_string(a2, a3, v26);
    if (!v27)
    {
      uint64_t v32 = "Unable to unpack container_id";
      uint64_t v33 = v8;
      int v34 = 126;
      goto LABEL_65;
    }
    uint64_t v30 = v27;
    unsigned int v31 = *(_DWORD *)(a2 + 84);
    if (!v31)
    {
      sandbox_spawnattrs_init();
LABEL_60:
      if (sandbox_spawnattrs_setcontainer() == -1) {
        sub_100050DFC();
      }
LABEL_61:
      if (posix_spawnattr_setmacpolicyinfo_np()) {
        sub_100050D28();
      }
      goto LABEL_66;
    }
  }
  else
  {
    unsigned int v31 = *(_DWORD *)(a2 + 84);
    if (!v31) {
      goto LABEL_66;
    }
    uint64_t v30 = 0;
  }
  if (_xpc_spawnattr_unpack_string(a2, a3, v31))
  {
    sandbox_spawnattrs_init();
    if (sandbox_spawnattrs_setprofilename() == -1) {
      sub_100050DFC();
    }
    if (!v30) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  uint64_t v32 = "Unable to unpack sandbox profile";
  uint64_t v33 = v8;
  int v34 = 135;
LABEL_65:
  uint64_t result = sub_10001FDA8(v33, 22, 0, v34, 0, v32, v28, v29, v117);
  if (result) {
    return result;
  }
LABEL_66:
  unsigned int v35 = *(_DWORD *)(a2 + 88);
  if (v35)
  {
    _xpc_spawnattr_unpack_string(a2, a3, v35);
    if (posix_spawnattr_set_subsystem_root_path_np()) {
      sub_100050D28();
    }
  }
  uint64_t v36 = *(unsigned int *)(a2 + 16);
  if (v36)
  {
    uint64_t v37 = (const char **)sub_100013BB8(8 * v36 + 8);
    *(void *)(v8 + 1216) = v37;
    if (!_xpc_spawnattr_unpack_strings(a2, a3, *(_DWORD *)(a2 + 20), v37, *(unsigned int *)(a2 + 16)))
    {
      uint64_t v53 = "Unable to unpack argv";
      uint64_t v54 = v8;
      int v55 = 537;
      goto LABEL_78;
    }
    uint64_t v40 = (void *)(*(void *)(v8 + 1216) + 8 * *(unsigned int *)(a2 + 16));
  }
  else
  {
    BOOL v41 = sub_100013BB8(0x10uLL);
    *(void *)(v8 + 1216) = v41;
    void *v41 = *(void *)(v8 + 1208);
    uint64_t v40 = v41 + 1;
  }
  void *v40 = 0;
  uint64_t v42 = (const char **)sub_100013BB8(8 * *(unsigned int *)(a2 + 24) + 56);
  *(void *)(v8 + 1232) = v42;
  uint64_t v46 = *(unsigned int *)(a2 + 24);
  if (!v46)
  {
LABEL_75:
    sub_100013AF0((void *)v8, "XXXXXXXX%s=%llx", v43, v44, v46, v45, v38, v39, (char)"XPC_FLAGS");
    goto LABEL_79;
  }
  if (_xpc_spawnattr_unpack_strings(a2, a3, *(_DWORD *)(a2 + 28), v42, v46))
  {
    *(void *)(v8 + 1224) = *(unsigned int *)(a2 + 24);
    goto LABEL_75;
  }
  uint64_t v53 = "Unable to unpack environment";
  uint64_t v54 = v8;
  int v55 = 565;
LABEL_78:
  uint64_t result = sub_10001FDA8(v54, 22, 0, v55, 0, v53, v38, v39, v117);
  if (result) {
    return result;
  }
LABEL_79:
  if (*(_DWORD *)(v8 + 1128) != -101)
  {
    if (a4)
    {
      *(void *)(v8 + 1120) = sub_100013AF0((void *)v8, "XXXXXXXX%s=%s", v47, v48, v49, v50, v51, v52, (char)"LOGNAME")+ 8;
      sub_100013AF0((void *)v8, "XXXXXXXX%s=%s", v56, v57, v58, v59, v60, v61, (char)"USER");
      sub_100013AF0((void *)v8, "XXXXXXXX%s=%s", v62, v63, v64, v65, v66, v67, (char)"HOME");
      sub_100013AF0((void *)v8, "XXXXXXXX%s=%s", v68, v69, v70, v71, v72, v73, (char)"SHELL");
      unsigned int v80 = *(_DWORD *)(v8 + 1128);
      if (v80 >= 0x1F5 && v80 != -2) {
        sub_100013AF0((void *)v8, "XXXXXXXX%s=%s/tmp", v74, v75, v76, v77, v78, v79, (char)"TMPDIR");
      }
      if (posix_spawnattr_set_login_np()) {
        sub_100050D28();
      }
      if (posix_spawnattr_set_uid_np()) {
        sub_100050D28();
      }
      if (posix_spawnattr_set_gid_np()) {
        sub_100050D28();
      }
      int v81 = *(_DWORD *)(a2 + 236);
      if ((v81 & 0x1000) == 0)
      {
        if (posix_spawnattr_set_groups_np()) {
          sub_100050D28();
        }
        int v81 = *(_DWORD *)(a2 + 236);
      }
      if ((v81 & 0x1000000) != 0)
      {
        if (posix_spawnattr_set_persona_uid_np()) {
          sub_100050D28();
        }
        if (posix_spawnattr_set_persona_gid_np()) {
          sub_100050D28();
        }
        if ((*(unsigned char *)(a2 + 237) & 0x10) == 0 && posix_spawnattr_set_persona_groups_np()) {
          sub_100050D28();
        }
      }
    }
    else
    {
      uint64_t result = sub_10001FDA8(v8, 22, 0, 354, 0, "Unable to setup identify", v51, v52, v117);
      if (result) {
        return result;
      }
    }
  }
  xpc_object_t v82 = xpc_dictionary_create(0, 0, 0);
  if (*(void *)(v8 + 1224))
  {
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    while (1)
    {
      uint64_t v85 = *(char **)(*(void *)(v8 + 1232) + 8 * v84);
      uint64_t v86 = strchr(v85, 61);
      if (!v86 || v86 == v85) {
        break;
      }
      uint64_t v90 = sub_100015A48(v85, v86 - v85);
      if (!xpc_dictionary_get_value(v82, v90))
      {
        xpc_dictionary_set_BOOL(v82, v90, 1);
        *(void *)(*(void *)(v8 + 1232) + 8 * v83++) = v85;
      }
      free(v90);
      if ((unint64_t)++v84 >= *(void *)(v8 + 1224)) {
        goto LABEL_108;
      }
    }
    uint64_t result = sub_10001FDA8(v8, 22, 0, 464, 0, "Invalid environment[%zd]: %s", v87, v88, v84);
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t v83 = 0;
LABEL_108:
    xpc_release(v82);
    *(void *)(v8 + 1224) = v83;
    *(void *)(*(void *)(v8 + 1232) + 8 * v83) = 0;
  }
  unsigned int v91 = *(_DWORD *)(a2 + 64);
  if (v91)
  {
    size_t v94 = _xpc_spawnattr_unpack_string(a2, a3, v91);
    if (!v94)
    {
      int v95 = "Unable to unpack cwd";
      uint64_t v96 = v8;
      int v97 = 224;
LABEL_144:
      uint64_t result = sub_10001FDA8(v96, 22, 0, v97, 0, v95, v92, v93, v117);
LABEL_145:
      if (result) {
        return result;
      }
      goto LABEL_146;
    }
  }
  else
  {
    size_t v94 = "/";
  }
  unsigned int v98 = *(_DWORD *)(a2 + 68);
  if (v98)
  {
    unsigned int v99 = _xpc_spawnattr_unpack_string(a2, a3, v98);
    if (!v99)
    {
      int v95 = "Unable to unpack stdin";
      uint64_t v96 = v8;
      int v97 = 241;
      goto LABEL_144;
    }
    v100 = (char *)v99;
    bzero(__str, 0x400uLL);
    if (*v100 != 47)
    {
      char v118 = v100;
      v100 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v94, v118);
    }
    uint64_t v101 = sub_100013B58(v100);
    if (v101)
    {
      uint64_t result = sub_10001FDA8(v8, v101, 0, 253, 0, "Unable to create stdin directory (%s)", v102, v103, (char)v100);
      goto LABEL_145;
    }
    if (posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 0, v100, 131584, 0x1B6u)) {
      sub_100050D28();
    }
  }
  else if (posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 0, "/dev/null", 0x20000, 0x1B6u))
  {
    sub_100050D28();
  }
  unsigned int v104 = *(_DWORD *)(a2 + 72);
  if (v104)
  {
    int v105 = _xpc_spawnattr_unpack_string(a2, a3, v104);
    if (!v105)
    {
      int v95 = "Unable to unpack stdout";
      uint64_t v96 = v8;
      int v97 = 268;
      goto LABEL_144;
    }
    unsigned int v106 = (char *)v105;
    bzero(__str, 0x400uLL);
    if (*v106 != 47)
    {
      char v119 = v106;
      unsigned int v106 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v94, v119);
    }
    uint64_t v107 = sub_100013B58(v106);
    if (v107)
    {
      uint64_t result = sub_10001FDA8(v8, v107, 0, 280, 0, "Unable to create stdout directory (%s)", v108, v109, (char)v106);
      goto LABEL_145;
    }
    if (posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 1, v106, 131594, 0x1B6u)) {
      sub_100050D28();
    }
  }
  else if (posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 1, "/dev/null", 131074, 0x1B6u))
  {
    sub_100050D28();
  }
  unsigned int v110 = *(_DWORD *)(a2 + 76);
  if (v110)
  {
    uint64_t v111 = _xpc_spawnattr_unpack_string(a2, a3, v110);
    if (!v111)
    {
      int v95 = "Unable to unpack stderr";
      uint64_t v96 = v8;
      int v97 = 295;
      goto LABEL_144;
    }
    uint64_t v112 = (char *)v111;
    bzero(__str, 0x400uLL);
    if (*v112 != 47)
    {
      size_t v120 = v112;
      uint64_t v112 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v94, v120);
    }
    uint64_t v113 = sub_100013B58(v112);
    if (v113)
    {
      uint64_t result = sub_10001FDA8(v8, v113, 0, 307, 0, "Unable to create stderr directory (%s)", v114, v115, (char)v112);
      goto LABEL_145;
    }
    if (posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 2, v112, 131594, 0x1B6u)) {
      sub_100050D28();
    }
  }
  else if (posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 2, "/dev/null", 131074, 0x1B6u))
  {
    sub_100050D28();
  }
LABEL_146:
  if (*(unsigned char *)(a2 + 238))
  {
    int v116 = *(_DWORD *)(v8 + 1128);
    if (!v116 || v116 == -101)
    {
      uint64_t v21 = "extensions cannot run as root";
      a1 = v8;
      uint64_t v22 = 1;
      int v23 = 769;
      return sub_10001FDA8(a1, v22, 0, v23, 0, v21, a7, a8, v117);
    }
  }
  return 0;
}

uint64_t sub_100013690(posix_spawnattr_t *a1, uint64_t a2, uint64_t a3, xpc_object_t xarray, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a2 + 220);
  if (!v8) {
    return 0;
  }
  uint64_t v11 = *(unsigned int *)(a2 + 216);
  unint64_t v12 = 4 * v8;
  if (v12 > a3 - v11) {
    return sub_10001FDA8((uint64_t)a1, 22, 0, 797, 0, "No space for special ports: %zu > (%zu - %d)", a7, a8, v12);
  }
  char v15 = 0;
  size_t v16 = 0;
  uint64_t v17 = a2 + v11 + 240;
  while (1)
  {
    xpc_array_get_value(xarray, v16);
    mach_port_t right = xpc_mach_send_get_right();
    mach_port_t v21 = right;
    if (right - 1 >= 0xFFFFFFFE)
    {
      char v26 = v16;
      int v23 = "Invalid special port[%zd]: %d";
      uint64_t v24 = (uint64_t)a1;
      int v25 = 806;
      return sub_10001FDA8(v24, 22, 0, v25, 0, v23, v19, v20, v26);
    }
    int v22 = *(_DWORD *)(v17 + 4 * v16);
    if ((v22 - 128) > 2)
    {
      if (v22 == 4)
      {
        if ((*(unsigned char *)(a2 + 239) & 4) != 0) {
          mach_port_t v21 = 0;
        }
        else {
          mach_port_t v21 = right;
        }
      }
      if (posix_spawnattr_setspecialport_np(a1, v21, v22)) {
        sub_100050D28();
      }
      goto LABEL_16;
    }
    if ((v22 - 129) <= 1) {
      break;
    }
LABEL_16:
    if (++v16 >= *(unsigned int *)(a2 + 220)) {
      return 0;
    }
  }
  if ((v15 & 1) == 0)
  {
    char v15 = 1;
    if (posix_spawnattr_set_registered_ports_np()) {
      sub_100050D28();
    }
    goto LABEL_16;
  }
  int v23 = "Already registered ports";
  uint64_t v24 = (uint64_t)a1;
  int v25 = 820;
  return sub_10001FDA8(v24, 22, 0, v25, 0, v23, v19, v20, v26);
}

size_t sub_100013834(uint64_t a1, xpc_object_t xarray)
{
  size_t result = xpc_array_get_count(xarray);
  if (result)
  {
    size_t v5 = 0;
    while (1)
    {
      xpc_object_t value = xpc_array_get_value(xarray, v5 + 1);
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
      {
        unsigned int v13 = "setup_fds bad int type";
        uint64_t v14 = a1;
        int v15 = 864;
        return sub_10001FDA8(v14, 9, 0, v15, 0, v13, v7, v8, v16);
      }
      int v9 = xpc_int64_get_value(value);
      if (v9 < 0 || getdtablesize() <= v9)
      {
        getdtablesize();
        return sub_10001FDA8(a1, 9, 0, 868, 0, "setup_fds bad dest: %d table: %d", v11, v12, v9);
      }
      xpc_object_t v10 = xpc_array_get_value(xarray, v5);
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_fd) {
        break;
      }
      _xpc_fd_get_port();
      if (posix_spawn_file_actions_add_fileportdup2_np()) {
        sub_100050D28();
      }
      v5 += 2;
      if (v5 >= xpc_array_get_count(xarray)) {
        return 0;
      }
    }
    unsigned int v13 = "setup_fds bad fd type";
    uint64_t v14 = a1;
    int v15 = 873;
    return sub_10001FDA8(v14, 9, 0, v15, 0, v13, v7, v8, v16);
  }
  return result;
}

uint64_t sub_10001398C(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5)
{
  size_t v8 = *(unsigned int *)(a2 + 12);
  if (v8) {
    int v9 = (const void *)_xpc_spawnattr_unpack_bytes(a2, a3, *(_DWORD *)(a2 + 8), v8);
  }
  else {
    int v9 = 0;
  }
  if (v8) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  int v11 = !v10;
  if (!a4 || !a5)
  {
    if (!v11) {
      return 0;
    }
    *(void *)(a1 + 1240) = sub_1000159AC(v9, v8);
    *(void *)(a1 + 1248) = v8;
    goto LABEL_19;
  }
  if (!v11)
  {
    *(void *)(a1 + 1240) = sub_1000159AC(a4, a5);
    *(void *)(a1 + 1248) = a5;
    goto LABEL_19;
  }
  uint64_t v12 = (void *)sub_100011B38((unint64_t)a4, a5, (unint64_t)v9, v8);
  if (!v12)
  {
    mach_port_t v21 = "Unable to merge spawn constraints";
    uint64_t v22 = a1;
    int v23 = 933;
    return sub_10001FDA8(v22, 22, 0, v23, 0, v21, v13, v14, v24);
  }
  int v15 = v12;
  size_t length = xpc_data_get_length(v12);
  *(void *)(a1 + 1248) = length;
  uint64_t v17 = sub_100013BB8(length);
  *(void *)(a1 + 1240) = v17;
  size_t bytes = xpc_data_get_bytes(v15, v17, 0, *(void *)(a1 + 1248));
  uint64_t v19 = *(void *)(a1 + 1248);
  xpc_release(v15);
  if (bytes != v19)
  {
    mach_port_t v21 = "Unable to copy merged spawn constraints";
    uint64_t v22 = a1;
    int v23 = 938;
    return sub_10001FDA8(v22, 22, 0, v23, 0, v21, v13, v14, v24);
  }
LABEL_19:
  uint64_t result = amfi_launch_constraint_set_spawnattr();
  if (result) {
    sub_100050D28();
  }
  return result;
}

char *sub_100013AF0(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v14[0] = 0;
  v14[1] = &a9;
  vasprintf(v14, a2, &a9);
  BOOL v10 = v14[0];
  *(void *)v14[0] = a1[228];
  a1[228] = v10;
  uint64_t result = v10 + 8;
  uint64_t v12 = a1[154];
  uint64_t v13 = a1[153];
  a1[153] = v13 + 1;
  *(void *)(v12 + 8 * v13) = result;
  return result;
}

uint64_t sub_100013B58(char *a1)
{
  uint64_t v2 = strrchr(a1, 47);
  if (!v2) {
    return 22;
  }
  uint64_t v3 = v2;
  char v4 = *v2;
  char *v2 = 0;
  LODWORD(result) = mkpath_np(a1, 0x1F6u);
  if (result == 17) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = result;
  }
  *uint64_t v3 = v4;
  return result;
}

void *sub_100013BB8(size_t size)
{
  do
  {
    uint64_t v2 = malloc_type_calloc(1uLL, size, 0x5C63E6C5uLL);
    if (v2) {
      break;
    }
    if (*__error() != 12 && *__error()) {
      sub_100050D28();
    }
  }
  while (sub_10001598C());
  return v2;
}

void *sub_100013C20(void *ptr, int a2, size_t size)
{
  do
  {
    size_t v5 = malloc_type_realloc(ptr, size, 0x662826DDuLL);
    if (v5) {
      break;
    }
    if (*__error() != 12 && *__error()) {
      sub_100050D28();
    }
  }
  while (sub_10001598C());
  return v5;
}

void sub_100013C94(uint64_t a1, int a2)
{
  if ((_UNKNOWN *)sub_1000301F4(a1) == &unk_1000755B8)
  {
    sub_100013CE8(a2, v3, v4, v5, v6, v7, v8, v9);
  }
}

void sub_100013CE8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 18)
  {
    switch(dword_100075CB8)
    {
      case 0:
        if (a1 != 1) {
          goto LABEL_38;
        }
        break;
      case 1:
        if ((a1 - 1) >= 2) {
          goto LABEL_38;
        }
        break;
      case 2:
        if (a1 != 3) {
          goto LABEL_38;
        }
        break;
      case 3:
        if (a1 != 4) {
          goto LABEL_38;
        }
        break;
      case 4:
        if (a1 != 5) {
          goto LABEL_38;
        }
        break;
      case 5:
        if (a1 != 6) {
          goto LABEL_38;
        }
        break;
      case 6:
        if (a1 != 7) {
          goto LABEL_38;
        }
        break;
      case 7:
        if (a1 != 8) {
          goto LABEL_38;
        }
        break;
      case 8:
        if (a1 != 9) {
          goto LABEL_38;
        }
        break;
      case 9:
        if (a1 != 10) {
          goto LABEL_38;
        }
        break;
      case 10:
        if (a1 != 11) {
          goto LABEL_38;
        }
        break;
      case 11:
        if (a1 != 12) {
          goto LABEL_38;
        }
        break;
      case 12:
        if (a1 != 13) {
          goto LABEL_38;
        }
        break;
      case 13:
        if (a1 != 14) {
          goto LABEL_38;
        }
        break;
      case 14:
        if (a1 != 15) {
          goto LABEL_38;
        }
        break;
      case 15:
      case 18:
        if (a1 != 16) {
          goto LABEL_38;
        }
        break;
      case 16:
        if (a1 != 17) {
          goto LABEL_38;
        }
        goto LABEL_3;
      default:
LABEL_38:
        sub_100040E80("Unexpected shutdown transition %s -> %s", off_10006FEB0[dword_100075CB8], off_10006FEB0[a1]);
    }
  }
  sub_1000442C4("shutdown", 196613, "shutdown %s -> %s", a4, a5, a6, a7, a8, (char)off_10006FEB0[dword_100075CB8]);
LABEL_3:
  dword_100075CB8 = a1;
}

void sub_100013EB8()
{
  dword_100075CB8 = 0;
  dword_100075CBC = 0;
  dword_100075CC0 = 0;
  byte_100075CC4 = 0;
  sub_10001904C();
}

void sub_100013EDC()
{
  if (dword_100075CB8 >= 2) {
    sub_100050D0C();
  }
  sub_100018ECC(&stru_10006FE50);
  sub_10000E1F0(&stru_10006FE90);
  sub_100014010();

  sub_100013CE8(2, v0, v1, v2, v3, v4, v5, v6);
}

void sub_100013F34(id a1)
{
  sub_100013F44((uint64_t)a1, v1, v2, v3, v4, v5, v6, v7);
}

void sub_100013F44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000442C4("shutdown timeout", 196611, "%s", a4, a5, a6, a7, a8, (char)"Shutting the system down has taken too long. launchd is rebooting\n(or halting) the system now. Any processes that are still running\nwill be abandoned to the mercy of the kernel.\n");
  uint64_t v8 = sub_1000147D8();
  sub_100013CE8(18, v9, v10, v11, v12, v13, v14, v15);
  sub_1000141A4(v8);
  free(v8);
  uint64_t v16 = sub_100030018();
  sub_100014630(v16);
}

void sub_100013FA4(id a1, unsigned int a2)
{
  if (a2 == 2)
  {
    if ((byte_100075CC4 & 1) == 0) {
      sub_100050D0C();
    }
    byte_100075CC4 = 0;
    if (dword_100075CB8 == 14) {
      sub_100014610();
    }
  }
  else if (a2 == 1)
  {
    if (byte_100075CC4 == 1) {
      sub_100050D0C();
    }
    byte_100075CC4 = 1;
  }
}

void sub_100014010()
{
  if (dword_100075CB8 == 1)
  {
    sub_100043D78(5, "shutdown already committed");
  }
  else
  {
    if (dword_100075CB8) {
      sub_100040E80("Attempting to commit shutdown unexpectedly: %s", off_10006FEB0[dword_100075CB8]);
    }
    sub_100043D78(5, "committing to system shutdown");
    uint64_t v0 = dispatch_queue_create("com.apple.xpc.launchd.system-override", 0);
    dispatch_async_f(v0, 0, (dispatch_function_t)sub_1000147A0);
    dispatch_release(v0);
    if (dword_100075CBC == 1)
    {
      uint64_t v8 = "kern.willuserspacereboot";
    }
    else
    {
      if (dword_100075CBC) {
        goto LABEL_9;
      }
      sub_100042CB0("kern.willshutdown", 1);
      uint64_t v8 = "security.mac.asp.willshutdown";
    }
    sub_100042CB0(v8, 1);
  }
LABEL_9:

  sub_100013CE8(1, v1, v2, v3, v4, v5, v6, v7);
}

uint64_t sub_100014114(int a1, uint64_t a2, int a3)
{
  if (dword_100075CB8)
  {
    sub_100043D78(3, "Shutdown already started: %s", off_10006FEB0[dword_100075CB8]);
    return 37;
  }
  else
  {
    dword_100075CBC = a1;
    if (a2) {
      sub_100050D0C();
    }
    dword_100075CC0 = a3;
    sub_100014010();
    return 0;
  }
}

BOOL sub_100014184(int a1)
{
  return dword_100075CB8 > 0 && dword_100075CBC == a1;
}

void sub_1000141A4(char *a1, ...)
{
  va_start(va, a1);
  if (dword_100075CB8 != 18 && (dword_100075CB8 - 2) >= 0xA) {
    sub_100050D0C();
  }
  dword_100075CBC = 0;
  v10[0] = 0;
  va_copy((va_list)&v10[1], va);
  vasprintf(v10, a1, va);
  uint64_t v8 = v10[0];
  char v9 = (char)v10[0];
  if (!v10[0])
  {
    _os_assumes_log();
    v10[0] = a1;
    char v9 = (char)a1;
  }
  sub_1000442C4("hard reboot", 196612, "Could not cleanly tear down userspace. Will force a full hardware reboot. (%s)", v3, v4, v5, v6, v7, v9);
  free(v8);
}

uint64_t sub_100014250(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_100075CB8 != 11) {
    sub_100050D0C();
  }
  sub_10002A5B8((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v25);
  sub_100013CE8(12, v9, v10, v11, v12, v13, v14, v15);
  sub_10004B370();
  sub_100013CE8(13, v16, v17, v18, v19, v20, v21, v22);
  sub_10001DDFC();
  uint64_t result = sub_100014338();
  if ((result & 1) == 0)
  {
    sub_1000143C8();
    char v24 = sub_100014B58();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_1000144B4;
    block[3] = &unk_10006FF48;
    block[4] = a1;
    dispatch_async(v24, block);
    uint64_t result = (uint64_t)sub_10001A0AC(a1);
    if (a1[47]) {
      sub_100050D0C();
    }
  }
  return result;
}

uint64_t sub_100014338()
{
  sub_100014B88();
  if (dword_100075CB8 != 13) {
    sub_100050D0C();
  }
  if (dword_100075CBC)
  {
    if (byte_100076A81)
    {
      sub_100043D78(65540, "Abandoning lingering coalitions");
    }
    else if (sub_10001D7BC(0))
    {
      return 0;
    }
  }
  sub_100013CE8(14, v0, v1, v2, v3, v4, v5, v6);
  if ((byte_100075CC4 & 1) == 0) {
    sub_100014610();
  }
  return 1;
}

uint64_t sub_1000143C8()
{
  if (dword_100075CB8 != 13) {
    sub_100050D0C();
  }
  int data_np = sysctlbyname_get_data_np();
  if (data_np)
  {
    if (data_np == -1) {
      sub_100050E38();
    }
  }
  else
  {
    free(0);
  }
  return sub_100043604();
}

void sub_1000144B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_1000144BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (dword_100075CB8 == 13)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_1000149B0;
    v13[3] = &unk_10006FF90;
    v13[4] = a1;
    if (sub_10001D7BC((uint64_t)v13))
    {
      sub_1000143C8();
      dispatch_time_t v10 = dispatch_time(0, 1000000000);
      uint64_t v11 = sub_100014B58();
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = sub_100014A14;
      v12[3] = &unk_10006FFB0;
      void v12[4] = a1;
      dispatch_after(v10, v11, v12);
    }
  }
  else
  {
    sub_10002A5B8(a1, 65541, "Polling for lingering coalitions stopped", a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1000145F8()
{
  if (dword_100075CB8 == 13) {
    return sub_100014338();
  }
  return result;
}

void sub_100014610()
{
  sub_10001904C();
  sub_100013CE8(15, v0, v1, v2, v3, v4, v5, v6);
  uint64_t v7 = sub_100030018();
  sub_100014630(v7);
}

void sub_100014630(uint64_t a1)
{
  if (dword_100075CB8 == 15 || dword_100075CB8 == 18)
  {
    uint64_t v1 = a1;
    task_t v4 = mach_host_self();
    sub_100045844(v4, 0);
    p_vtable = OS_launch_service_stub.vtable;
    char v5 = dword_100075CC0;
    sub_10000D388(*(void *)(v1 + 272));
    sub_10002A5B8(v1, 5, "shutting down system: flags = 0x%x, time = %llu ms", v6, v7, v8, v9, v10, v5);
    unint64_t v11 = sub_10000D388(*(void *)(v1 + 272));
    sub_10002A5B8(v1, 196613, "Userspace teardown took: %llu ms", v12, v13, v14, v15, v16, v11 / 0xF4240);
    if (dword_100075CBC)
    {
      if (dword_100075CBC == 1)
      {
        sub_10002A5B8(v1, 196613, "Will be re-execing for a userspace reboot", v18, v19, v20, v21, v22, v37);
        int v17 = 4;
        goto LABEL_11;
      }
LABEL_10:
      int v17 = 1;
LABEL_11:
      sub_100043D78(196613, "Quiescing queues");
      sub_100013CE8(16, v23, v24, v25, v26, v27, v28, v29);
      sub_100010348();
      sub_100043DB8();
      sub_10000FB9C("launchd quiesce complete\n");
      sub_100013CE8(17, v30, v31, v32, v33, v34, v35, v36);
      sub_100014784(v17);
    }
  }
  else
  {
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  sub_10002A5B8(v1, 196613, "Will be calling reboot(2) with flags: 0x%x", v18, v19, v20, v21, v22, *((_DWORD *)p_vtable + 816));
  goto LABEL_10;
}

void sub_100014784(int a1)
{
}

uint64_t sub_1000147A0()
{
  pthread_setname_np("system shutdown has begun");
  uint64_t result = system_override();
  if (result == -1) {
    sub_100050DFC();
  }
  return result;
}

char *sub_1000147D8()
{
  if (dword_100075CB8 != 13) {
    return sub_100015BE4("userspace shutdown timed out: %s", off_10006FEB0[dword_100075CB8]);
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  int v8 = 0;
  uint64_t v0 = (const char **)sub_100010724(0x40uLL);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10001493C;
  v4[3] = &unk_10006FF70;
  v4[4] = &v5;
  v4[5] = v0;
  sub_10001D7BC((uint64_t)v4);
  if (*((int *)v6 + 6) < 1)
  {
    uint64_t v2 = sub_100015BE4("userspace shutdown timed out: %s. Unable to identify lingering coalitions.", off_10006FEB0[dword_100075CB8]);
  }
  else
  {
    uint64_t v1 = sub_100010770(v0);
    uint64_t v2 = sub_100015BE4("userspace shutdown timed out: %s (%d).%s", off_10006FEB0[dword_100075CB8], *((_DWORD *)v6 + 6), v1);
    free(v1);
  }
  sub_100010778((void **)v0);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_10001493C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  char v5 = sub_100011574(a2);
  sub_100012750(a2);
  sub_1000107B4(v4, " %llu (%s),", v6, v7, v8, v9, v10, v11, v5);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void sub_1000149B0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = sub_100011574(a2);
  sub_100012750(a2);
  sub_10002A5B8(v3, 65540, "Lingering coalition: %llu (%s)", v5, v6, v7, v8, v9, v4);
}

uint64_t sub_100014A14(uint64_t a1)
{
  return sub_1000144BC(*(void *)(a1 + 32));
}

uint64_t sub_100014A1C(uint32_t a1)
{
  *__error() = 0;
  uint64_t result = usrctl(a1);
  if (result)
  {
    int v3 = result;
    char v4 = __error();
    sub_100040E80("usrctl(0x%x) returned %d (errno %d)", a1, v3, *v4);
  }
  return result;
}

dispatch_queue_t sub_100014A78()
{
  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  qos_class_t v1 = qos_class_main();
  uint64_t v2 = dispatch_queue_attr_make_with_qos_class(initially_inactive, v1, 0);
  qword_100075CC8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.eventq", v2);
  qos_class_t v3 = qos_class_main();
  char v4 = dispatch_queue_attr_make_with_qos_class(0, v3, 0);
  qword_100075CD0 = (uint64_t)dispatch_queue_create_with_target_V2("com.apple.xpc.launchd.spawn", v4, 0);
  qword_100076978 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.ioq", 0);
  uint64_t v5 = dispatch_queue_attr_make_with_qos_class(0, (dispatch_qos_class_t)5u, 0);
  qword_100075CD8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.bgioq", v5);
  dispatch_queue_t result = dispatch_queue_create("com.apple.xpc.launchd.bglogq", v5);
  qword_100075CE0 = (uint64_t)result;
  return result;
}

uint64_t sub_100014B58()
{
  return qword_100075CC8;
}

uint64_t sub_100014B64()
{
  return qword_100076978;
}

uint64_t sub_100014B70()
{
  return qword_100075CD8;
}

uint64_t sub_100014B7C()
{
  return qword_100075CE0;
}

void sub_100014B88()
{
}

uint64_t sub_100014B94()
{
  return qword_100075CD0;
}

void sub_100014BA0()
{
}

void *sub_100014BAC(uint64_t a1, const char *a2)
{
  qos_class_t v3 = sub_10002A624(a1, 1);
  char v4 = sub_100015BE4("%s/%s", v3, a2);
  free(v3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100014C60;
  _OWORD v7[3] = &unk_10006FFD0;
  v7[4] = v4;
  uint64_t v5 = sub_100013BB8(0x18uLL);
  *uint64_t v5 = sub_100015C58(v7);
  v5[1] = v4;
  return v5;
}

void sub_100014C60(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100014C90(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  _Block_release(*(const void **)a1);

  free((void *)a1);
}

void sub_100014CD8(unsigned char *a1, uint64_t a2, char *a3, ...)
{
  va_start(va, a3);
  a1[16] = 1;
  v4[0] = 0;
  va_copy((va_list)&v4[1], va);
  if (vasprintf((char **)v4, a3, va) != -1)
  {
    (*(void (**)(void))(*(void *)a1 + 16))();
    free(v4[0]);
  }
}

void sub_100014D54(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if ((v2 - 1) < 2)
  {
    *(void *)(a1 + 80) = xpc_bundle_create();
    sub_10001A0AC((void *)a1);
    global_queue = dispatch_get_global_queue(0, 0);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_100015464;
    _OWORD v7[3] = &unk_100070070;
    v7[4] = a1;
    char v4 = v7;
  }
  else if (v2 == 3)
  {
    sub_10001A0AC((void *)a1);
    global_queue = sub_100014B64();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100015080;
    block[3] = &unk_100070010;
    block[4] = a1;
    char v4 = block;
  }
  else
  {
    if (*(unsigned char *)(a1 + 56)) {
      sub_100040E80("unsupported IO type %d", *(unsigned __int8 *)(a1 + 56));
    }
    sub_10001A0AC((void *)a1);
    global_queue = sub_100014B64();
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_100014F0C;
    v6[3] = &unk_10006FFF0;
    v6[4] = a1;
    char v4 = v6;
  }
  dispatch_async(global_queue, v4);
}

void sub_100014F0C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  qos_class_t v3 = sub_100014B64();
  dispatch_assert_queue_V2(v3);
  int v4 = guarded_open_np();
  if (v4 < 0)
  {
    int v6 = *__error();
    goto LABEL_7;
  }
  int v5 = v4;
  if (fstat(v4, (stat *)(v2 + 96)))
  {
LABEL_3:
    int v6 = *__error();
    goto LABEL_4;
  }
  unsigned __int16 v7 = (*(_WORD *)(v2 + 100) & 0xF000) + 0x4000;
  if ((v7 & 0xF000u) >= 0xB000 || (unsigned int v8 = v7 >> 12, ((0x561u >> v8) & 1) == 0))
  {
    uint64_t v9 = sub_10003E3A4(v5);
    if (v9)
    {
      uint64_t v10 = v9;
      free(*(void **)(v2 + 64));
      *(void *)(v2 + 64) = v10;
      size_t v11 = *(void *)(v2 + 192);
      uint64_t v12 = sub_100013BB8(v11);
      ssize_t v13 = read(v5, v12, v11);
      if (v13 < 0 || v13 == v11)
      {
        dispatch_data_t v14 = dispatch_data_create(v12, v11, 0, _dispatch_data_destructor_free);
        int v6 = 0;
        *(void *)(v2 + 72) = v14;
      }
      else
      {
        free(v12);
        int v6 = 5;
      }
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  int v6 = dword_100053D10[v8];
LABEL_4:
  if (guarded_close_np() == -1) {
    sub_100050DFC();
  }
LABEL_7:
  sub_100015330(v2, 0, v6);
  sub_10001A174(*(void **)(a1 + 32));
}

void sub_100015080(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  qos_class_t v3 = sub_100014B64();
  dispatch_assert_queue_V2(v3);
  int v4 = guarded_open_np();
  if (v4 < 0)
  {
    uint64_t v9 = __error();
    sub_100015330(v2, 0, *v9);
    goto LABEL_37;
  }
  int v5 = v4;
  if (!fstat(v4, (stat *)(v2 + 96)))
  {
    if ((*(_WORD *)(v2 + 100) & 0xF000) != 0x4000)
    {
      unsigned __int16 v7 = 0;
      int v8 = 20;
      goto LABEL_34;
    }
    unsigned __int16 v7 = sub_10003E3A4(v5);
    if (!v7)
    {
      int v6 = __error();
      goto LABEL_4;
    }
    free(*(void **)(v2 + 64));
    *(void *)(v2 + 64) = v7;
    v23[0] = v7;
    v23[1] = 0;
    unsigned __int16 v7 = (char *)sub_10001137C();
    uint64_t v10 = fts_open(v23, 92, 0);
    if (v10)
    {
      size_t v11 = v10;
      uint64_t v12 = fts_read(v10);
      if (v12)
      {
        ssize_t v13 = v12;
        uint64_t v14 = 0;
        while (1)
        {
          unsigned int fts_info = v13->fts_info;
          if (fts_info > 6) {
            break;
          }
          if (fts_info == 1)
          {
            if (v14)
            {
              ++v14;
              fts_set(v11, v13, 4);
              uint64_t fts_path = (uint64_t)v13->fts_path;
              int v17 = 3;
LABEL_20:
              int fts_errno = 0;
              goto LABEL_23;
            }
            uint64_t v14 = 1;
          }
          else
          {
            if (fts_info != 6) {
              goto LABEL_22;
            }
            --v14;
          }
LABEL_25:
          ssize_t v13 = fts_read(v11);
          if (!v13) {
            goto LABEL_29;
          }
        }
        if (fts_info == 7)
        {
          uint64_t fts_path = (uint64_t)v13->fts_path;
          int fts_errno = v13->fts_errno;
          int v17 = 4;
        }
        else
        {
          if (fts_info == 11)
          {
            uint64_t fts_path = (uint64_t)v13->fts_path;
            int v17 = 0;
            goto LABEL_20;
          }
LABEL_22:
          uint64_t fts_path = (uint64_t)v13->fts_path;
          int v17 = 4;
          int fts_errno = 108;
        }
LABEL_23:
        uint64_t v19 = sub_1000104C4(v17, fts_path, fts_errno);
        if (v19)
        {
          sub_100011418(v7, v19);
          sub_10001A174(v19);
        }
        goto LABEL_25;
      }
LABEL_29:
      if (fts_close(v11) == -1) {
        sub_100050DFC();
      }
    }
    else
    {
      uint64_t v20 = *(const char **)(v2 + 64);
      int v21 = *__error();
      __error();
      uint64_t v22 = (const char *)xpc_strerror();
      sub_100043D78(4, "failed to fts_open(%s, 0x%x): %d: %s", v20, 92, v21, v22);
    }
    int v8 = 0;
    goto LABEL_34;
  }
  int v6 = __error();
  unsigned __int16 v7 = 0;
LABEL_4:
  int v8 = *v6;
LABEL_34:
  if (guarded_close_np() == -1) {
    sub_100050DFC();
  }
  sub_100015330(v2, v7, v8);
  if (v7) {
    sub_10001A174(v7);
  }
LABEL_37:
  sub_10001A174(*(void **)(a1 + 32));
}

void sub_100015330(uint64_t a1, void *a2, int a3)
{
  int v6 = sub_100014B64();
  dispatch_assert_queue_V2(v6);
  *(_DWORD *)(a1 + 240) = a3;
  sub_10001A0AC((void *)a1);
  if (a2) {
    sub_10001A0AC(a2);
  }
  unsigned __int16 v7 = *(NSObject **)(a1 + 248);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_1000153F4;
  v8[3] = &unk_100070030;
  v8[4] = a1;
  v8[5] = a2;
  dispatch_async(v7, v8);
}

void sub_1000153F4(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 256) + 16))();
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2) {
    sub_10001A174(v2);
  }
  qos_class_t v3 = *(void **)(a1 + 32);

  sub_10001A174(v3);
}

void sub_100015464(uint64_t a1)
{
  uint64_t v2 = sub_100010448();
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  xpc_bundle_resolve_sync();
  dispatch_semaphore_signal(v2);
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(NSObject **)(v3 + 248);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100015508;
  block[3] = &unk_100070050;
  block[4] = v3;
  dispatch_async(v4, block);
}

void sub_100015508(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 248));
  int error = xpc_bundle_get_error();
  if (!error)
  {
    uint64_t property = (_OWORD *)xpc_bundle_get_property();
    *(_OWORD *)(v2 + 96) = *property;
    long long v5 = property[4];
    long long v7 = property[1];
    long long v6 = property[2];
    *(_OWORD *)(v2 + 144) = property[3];
    *(_OWORD *)(v2 + 160) = v5;
    *(_OWORD *)(v2 + 112) = v7;
    *(_OWORD *)(v2 + 128) = v6;
    long long v8 = property[8];
    long long v10 = property[5];
    long long v9 = property[6];
    *(_OWORD *)(v2 + 208) = property[7];
    *(_OWORD *)(v2 + 224) = v8;
    *(_OWORD *)(v2 + 176) = v10;
    *(_OWORD *)(v2 + 192) = v9;
  }
  *(_DWORD *)(v2 + 240) = error;
  (*(void (**)(void))(*(void *)(v2 + 256) + 16))();
  size_t v11 = *(void **)(a1 + 32);

  sub_10001A174(v11);
}

size_t _xpc_spawnattr_pack_string_fragment(uint64_t a1, _DWORD *a2, void *a3, char *__src)
{
  strcpy((char *)(a1 + *a2 + 240), __src);
  size_t result = strlen(__src);
  *a2 += result;
  *a3 -= result;
  return result;
}

size_t _xpc_spawnattr_pack_string(uint64_t a1, _DWORD *a2, void *a3, char *__src)
{
  strcpy((char *)(a1 + *a2 + 240), __src);
  size_t result = strlen(__src);
  *a2 += result + 1;
  *a3 -= result + 1;
  return result;
}

const char *_xpc_spawnattr_unpack_string(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (a2 <= a3) {
    return 0;
  }
  uint64_t v3 = (const char *)(a1 + a3 + 240);
  if (strnlen(v3, a2 - a3) + 1 <= a2 - a3) {
    return v3;
  }
  else {
    return 0;
  }
}

void *_xpc_spawnattr_pack_bytes(uint64_t a1, _DWORD *a2, void *a3, void *__src, size_t __n)
{
  unsigned int v5 = __n;
  size_t result = memcpy((void *)(a1 + *a2 + 240), __src, __n);
  *a2 += v5;
  *a3 -= v5;
  return result;
}

uint64_t _xpc_spawnattr_unpack_bytes(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a2 - a3 >= a4) {
    uint64_t v4 = a1 + a3 + 240;
  }
  else {
    uint64_t v4 = 0;
  }
  if (a2 <= a3) {
    return 0;
  }
  else {
    return v4;
  }
}

const char *_xpc_spawnattr_unpack_strings(uint64_t a1, unint64_t a2, unsigned int a3, const char **a4, uint64_t a5)
{
  if (a3 >= a2) {
    return 0;
  }
  uint64_t v5 = a5;
  if (!a5) {
    return *a4;
  }
  unsigned int v7 = a3;
  uint64_t v9 = a1 + 240;
  for (size_t i = a4; ; ++i)
  {
    size_t v11 = (const char *)(v9 + v7);
    size_t v12 = strnlen(v11, a2 - v7);
    if (v12 + 1 > a2 - v7) {
      break;
    }
    v7 += v12 + 1;
    *size_t i = v11;
    if (!--v5) {
      return *a4;
    }
  }
  return 0;
}

uint64_t _xpc_spawnattr_binprefs_size(uint64_t a1)
{
  return 8 * xpc_binprefs_count(a1);
}

uint64_t _xpc_spawnattr_binprefs_pack(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4)
{
  unsigned int v8 = xpc_binprefs_count(a2);
  *(_DWORD *)(a1 + 32) = v8;
  uint64_t v9 = 0;
  if (v8)
  {
    *(_DWORD *)(a1 + 36) = *a3;
    uint64_t v10 = 8 * (v8 - 1);
    uint64_t v11 = v8;
    size_t v12 = (_DWORD *)(*a3 + a1 + 244);
    do
    {
      *(v12 - 1) = xpc_binprefs_cpu_type(a2, v9);
      *size_t v12 = xpc_binprefs_cpu_subtype(a2, v9);
      v12 += 2;
      ++v9;
    }
    while (v11 != v9);
    uint64_t v9 = v10 + 8;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = 0;
  }
  uint64_t result = xpc_binprefs_count(a2);
  if (v9 != 8 * result) {
    sub_100050D0C();
  }
  *a3 += v9;
  *a4 -= v9;
  return result;
}

uint64_t _xpc_spawnattr_binprefs_unpack(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  if (!v2 || a2 - (unint64_t)*(unsigned int *)(a1 + 36) < 8 * v2) {
    return 0;
  }
  xpc_binprefs_alloc();
  uint64_t v4 = v5;
  if (*(_DWORD *)(a1 + 32))
  {
    unint64_t v6 = 0;
    unsigned int v7 = (int *)(*(unsigned int *)(a1 + 36) + a1 + 244);
    do
    {
      xpc_binprefs_add(v4, *(v7 - 1), *v7);
      ++v6;
      v7 += 2;
    }
    while (v6 < *(unsigned int *)(a1 + 32));
  }
  return v4;
}

uint64_t sub_10001598C()
{
  return 1;
}

void *sub_1000159AC(const void *a1, size_t size)
{
  uint64_t v4 = sub_100013BB8(size);

  return memcpy(v4, a1, size);
}

char *sub_1000159F0(const char *a1)
{
  for (size_t i = a1; ; a1 = i)
  {
    uint64_t result = strdup(a1);
    if (result) {
      break;
    }
    if (*__error() != 12)
    {
      if (*__error()) {
        sub_100050D28();
      }
    }
    sub_10001598C();
  }
  return result;
}

char *sub_100015A48(const char *a1, size_t a2)
{
  size_t v2 = a2;
  uint64_t v3 = a1;
  while (1)
  {
    uint64_t result = strndup(a1, a2);
    if (result) {
      break;
    }
    if (*__error() != 12)
    {
      if (*__error()) {
        sub_100050D28();
      }
    }
    sub_10001598C();
    a1 = v3;
    a2 = v2;
  }
  return result;
}

uint64_t sub_100015AA4(const char *a1, const char *a2)
{
  memset(v8, 0, sizeof(v8));
  sub_100015B64(a1, (uint64_t)v8);
  memset(v7, 0, sizeof(v7));
  sub_100015B64(a2, (uint64_t)v7);
  uint64_t v3 = 0;
  while (1)
  {
    unint64_t v4 = v8[v3];
    unint64_t v5 = v7[v3];
    if (v4 > v5) {
      break;
    }
    if (v4 < v5) {
      return 0xFFFFFFFFLL;
    }
    if (++v3 == 3) {
      return 0;
    }
  }
  return 1;
}

void sub_100015B64(const char *a1, uint64_t a2)
{
  uint64_t v3 = strdup(a1);
  uint64_t v4 = 0;
  __stringp = v3;
  do
  {
    unint64_t v5 = strsep(&__stringp, ".");
    if (!v5) {
      break;
    }
    unint64_t v6 = 0;
    *(void *)(a2 + v4) = strtoull(v5, &v6, 10);
    v4 += 8;
  }
  while (v4 != 24);
  free(v3);
}

char *sub_100015BE4(char *a1, ...)
{
  va_start(va, a1);
  uint64_t v3 = 0;
  while (1)
  {
    vasprintf(&v3, a1, va);
    uint64_t result = v3;
    if (v3) {
      break;
    }
    if (*__error() != 12)
    {
      if (*__error()) {
        sub_100050D28();
      }
    }
    sub_10001598C();
  }
  return result;
}

void *sub_100015C58(const void *a1)
{
  for (size_t i = a1; ; a1 = i)
  {
    uint64_t result = _Block_copy(a1);
    if (result) {
      break;
    }
    if (*__error() != 12)
    {
      if (*__error()) {
        sub_100050D28();
      }
    }
    sub_10001598C();
  }
  return result;
}

BOOL sub_100015CAC(const char *a1, char *__s)
{
  size_t v4 = strlen(__s);
  return strncmp(a1, __s, v4) == 0;
}

BOOL sub_100015CF0(const char *a1, const char *a2)
{
  size_t v4 = &a1[strlen(a1)];
  unint64_t v5 = &v4[-strlen(a2)];
  return v5 >= a1 && strcmp(v5, a2) == 0;
}

BOOL sub_100015D50(char *a1, const char *a2)
{
  return strstr(a1, a2) != 0;
}

BOOL sub_100015D70(char *__s1, const char *a2)
{
  BOOL result = ((unint64_t)__s1 | (unint64_t)a2) == 0;
  if (__s1)
  {
    if (a2) {
      return strcmp(__s1, a2) == 0;
    }
  }
  return result;
}

BOOL sub_100015DB0(char *a1, const char *a2)
{
  BOOL result = ((unint64_t)a1 | (unint64_t)a2) == 0;
  if (a1)
  {
    if (a2) {
      return strcasecmp(a1, a2) == 0;
    }
  }
  return result;
}

size_t sub_100015DF0(xpc_object_t xarray, const char *a2)
{
  size_t result = 0;
  if (xarray)
  {
    if (a2)
    {
      size_t result = xpc_array_get_count(xarray);
      if (result)
      {
        size_t v5 = result;
        size_t v6 = 0;
        while (1)
        {
          string = xpc_array_get_string(xarray, v6);
          if (string)
          {
            if (!strcmp(string, a2)) {
              break;
            }
          }
          if (v5 == ++v6) {
            return 0;
          }
        }
        return 1;
      }
    }
  }
  return result;
}

BOOL sub_100015E70(void *a1)
{
  return xpc_array_apply(a1, &stru_1000700B0);
}

BOOL sub_100015E7C(id a1, unint64_t a2, void *a3)
{
  return xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string;
}

uint64_t sub_100015EA8(unsigned char *a1, uint64_t a2)
{
  if (!a2) {
    return 5381;
  }
  uint64_t result = 5381;
  do
  {
    uint64_t v4 = *a1;
    if (!*a1) {
      break;
    }
    ++a1;
    uint64_t result = 33 * result + v4;
    --a2;
  }
  while (a2);
  return result;
}

uint64_t sub_100015EDC(unsigned char *a1)
{
  char v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = a1 + 1;
  do
  {
    uint64_t result = 33 * result + v1;
    int v5 = *v4++;
    char v1 = v5;
  }
  while (v5);
  return result;
}

uint64_t sub_100015F0C(int a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  for (uint64_t i = a2 + 8; *(_DWORD *)(i - 8) != a1; i += 16)
  {
    if (!--a3) {
      return 0;
    }
  }
  return *(void *)i;
}

xpc_type_t sub_100015F3C(FILE *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3) {
    sub_100046694((uint64_t)a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  }
  xpc_type_t result = xpc_get_type(a4);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    double value = COERCE_DOUBLE(xpc_string_get_string_ptr(a4));
    uint64_t v35 = "\"%s\"";
LABEL_22:
    uint64_t v38 = a1;
    uint64_t v39 = 0;
    return (xpc_type_t)sub_100046780(v38, v39, v35, v12, v13, v14, v15, v16, *(void *)&value);
  }
  if (result == (xpc_type_t)&_xpc_type_int64)
  {
    double value = COERCE_DOUBLE(xpc_int64_get_value(a4));
    uint64_t v35 = "%lld";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_uint64)
  {
    double value = COERCE_DOUBLE(xpc_uint64_get_value(a4));
    uint64_t v35 = "%llu";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_double)
  {
    double value = xpc_double_get_value(a4);
    uint64_t v35 = "%f";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (a4 == &_xpc_BOOL_true) {
      uint64_t v36 = "true";
    }
    else {
      uint64_t v36 = "false";
    }
    double value = *(double *)&v36;
    uint64_t v35 = "%s";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_date)
  {
    xpc_date_get_value_absolute();
    time_t v44 = (uint64_t)(v37 + 978307200.0);
    memset(&v43, 0, sizeof(v43));
    gmtime_r(&v44, &v43);
    *(void *)uint64_t v45 = 0;
    uint64_t v46 = 0;
    memset(v47, 0, sizeof(v47));
    strftime(v45, 0x1EuLL, "%a %b %d %T %Y %Z", &v43);
    double value = COERCE_DOUBLE(v45);
    uint64_t v35 = "%s (approx)";
    goto LABEL_22;
  }
  if (result != (xpc_type_t)&_xpc_type_array)
  {
    if (result != (xpc_type_t)&_xpc_type_dictionary)
    {
      if (result != (xpc_type_t)&_xpc_type_bundle) {
        return result;
      }
      sub_100046780(a1, 0, "@bundle {", v12, v13, v14, v15, v16);
      info_xpc_object_t dictionary = xpc_bundle_get_info_dictionary();
      sub_100046710(a1, a2 + 1, "info plist = ", v18, v19, v20, v21, v22);
      sub_100015F3C(a1, a2 + 1, 0, info_dictionary);
      uint64_t v23 = (void *)xpc_bundle_copy_services();
      sub_100046710(a1, a2 + 1, "service bundles => ", v24, v25, v26, v27, v28);
      sub_100015F3C(a1, a2 + 1, 0, v23);
      xpc_release(v23);
      uint64_t v34 = "}";
      goto LABEL_29;
    }
    sub_100046780(a1, 0, "{", v12, v13, v14, v15, v16);
    *(void *)&v43.tm_sec = 0;
    *(void *)&v43.tm_hour = a1;
    *(void *)&v43.tm_mon = a2 + 1;
    xpc_dictionary_apply_f();
    uint64_t v35 = "}";
    uint64_t v38 = a1;
    uint64_t v39 = a2;
    return (xpc_type_t)sub_100046780(v38, v39, v35, v12, v13, v14, v15, v16, *(void *)&value);
  }
  sub_100046780(a1, 0, "[", v12, v13, v14, v15, v16);
  if (xpc_array_get_count(a4))
  {
    size_t v40 = 0;
    do
    {
      sub_100046710(a1, a2 + 1, "%lu = ", v29, v30, v31, v32, v33, v40);
      xpc_object_t v41 = xpc_array_get_value(a4, v40);
      sub_100015F3C(a1, a2 + 1, 0, v41);
      ++v40;
    }
    while (v40 < xpc_array_get_count(a4));
  }
  uint64_t v34 = "]";
LABEL_29:

  return (xpc_type_t)sub_100046780(a1, a2, v34, v29, v30, v31, v32, v33);
}

uint64_t sub_10001631C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(FILE **)(a3 + 8);
  uint64_t v10 = *(void *)(a3 + 16);
  sub_100046710(v9, v10, "\"%s\" => ", a4, a5, a6, a7, a8, a1);

  return sub_100015F3C(v9, v10, 0, a2);
}

uint64_t sub_100016388(uint64_t a1, mach_port_context_t a2)
{
  v4.reserved[1] = 0;
  memset(v5, 0, sizeof(v5));
  char v6 = 7;
  __strlcpy_chk();
  *(void *)&v4.flags = 0x8000000433;
  v4.reserved[0] = (uint64_t)v5;
  return sub_10000D538(&v4, a2);
}

void os_crash_function(const char *a1)
{
}

void start()
{
  kern_return_t v20;
  mach_port_t v21;
  pid_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSObject *v28;
  mach_port_t init_port_set[4];
  long long v30;
  long long v31;
  long long v32;
  long long v33;
  long long v34;
  long long v35;
  long long v36;
  long long v37;
  long long v38;
  long long v39;
  long long v40;
  unint64_t v41;
  char *v42;
  char out[48];

  if (!getenv("LAUNCH_DID_REEXEC") && !getenv("XPC_USERSPACE_REBOOTED")) {
    sub_100042CB0("kern.initproc_spawned", 1);
  }
  _os_crash_callback = os_crash_function;
  int v0 = isatty(1);
  if (v0 && !byte_100076A61)
  {
    int v1 = v0;
    size_t v2 = __stdoutp;
    uint64_t v3 = getprogname();
    fprintf(v2, "%s cannot be run directly.\n", v3);
    mach_port_options_t v4 = getprogname();
    sub_100040E80("%s cannot be run directly (stdout: %d)", v4, v1);
  }
  pid_t v5 = getpid();
  if (v5 != 1 && !byte_100076A61)
  {
    pid_t v6 = v5;
    unsigned int v7 = __stdoutp;
    unsigned int v8 = getprogname();
    fprintf(v7, "%s cannot be run directly.\n", v8);
    uint64_t v9 = getprogname();
    sub_100040E80("%s cannot be run directly (pid = %d)", v9, v6);
  }
  mach_port_t v10 = mach_host_self();
  panic_init(v10);
  sub_100014A78();
  if (!byte_100076A61)
  {
    sub_100016AF0(0, 0);
    sub_100016AF0(1, 1);
    sub_100016AF0(2, 2);
  }
  sub_100011580();
  sub_100010FC0();
  uint64_t v11 = sub_10004A200();
  nullsub_23(v11, v12);
  sub_100003504();
  memset(out, 0, 37);
  memset(init_port_set, 0, sizeof(init_port_set));
  _NSGetMachExecuteHeader();
  if (_dyld_get_image_uuid()) {
    goto LABEL_58;
  }
  _os_assumes_log();
  while (1)
  {
    sub_100043D78(5, "hello, launchd UUID: %s", out);
    sub_100041B04();
    if (byte_100076A7B) {
      dword_100075AB4 = -1;
    }
    if (byte_100076A47)
    {
      sub_100043D78(65543, "Memory limit override file is present, disabling memory limits.");
      dword_100075AB4 = -1;
      *(void *)init_port_set = 0;
    }
    else
    {
      *(void *)init_port_set = 0;
      if (dword_100075AB4 != -1 && sub_1000035E0((unint64_t *)init_port_set)) {
        dword_100075AB4 += 2;
      }
    }
    getpid();
    if (memorystatus_control() == -1)
    {
      int v13 = dword_100075AB4;
      int v14 = *__error();
      uint64_t v15 = __error();
      uint64_t v16 = strerror(*v15);
      sub_100043D78(65539, "Could not opt into %d MB Jetsam high watermark: %d: %s", v13, v14, v16);
    }
    sub_100043D78(65541, "%s", off_100075AC8[0]);
    uint64_t v42 = 0;
    if (sub_100042A54("kern.bootargs", &v42)) {
      sub_100043D78(65541, "boot-args = %s", v42);
    }
    free(v42);
    getpid();
    if (proc_disable_wakemon() == -1)
    {
      __error();
      _os_assert_log();
      _os_crash();
      __break(1u);
    }
    else
    {
      if (byte_100076A61)
      {
        byte_100076ABA = 1;
        sub_100043D78(65541, "Lean Testing Environment starting.");
      }
      int v17 = byte_100076A65;
      if (byte_100076A63 && !byte_100076A65)
      {
        byte_100076ABA = 1;
        sub_100043D78(65541, "Restore environment starting.");
        int v17 = byte_100076A65;
      }
      if (v17)
      {
        byte_100076ABA = 1;
        sub_100043D78(65541, "BaseSystem environment starting.");
      }
      xpc_object_t v41 = 0;
      if (sub_1000035E0(&v41)) {
        sub_100043D78(65541, "Running with Probabilistic Guard Malloc envvar (Sample Rate = %zu)", v41);
      }
      if (setsid() == -1 && !byte_100076A61 && (!byte_100076A80 || *__error() != 1) && *__error()) {
        goto LABEL_57;
      }
      if (chdir("/") != -1)
      {
        if (setlogin("root") != -1)
        {
          uint64_t v18 = 0;
          while (1)
          {
            int v19 = dword_100053D60[v18];
            dword_100075CE8 |= 1 << (v19 - 1);
            if (signal(v19, (void (__cdecl *)(int))1) == (void (__cdecl *)(int))-1)
            {
              __error();
              _os_assumes_log();
            }
            if (++v18 == 21)
            {
              uint64_t v20 = task_set_special_port(mach_task_self_, 4, 0);
              if (!v20)
              {
                bootstrap_port = 0;
                uint64_t v21 = sub_100016388((uint64_t)off_100075630, 0x70507uLL);
                init_port_set[0] = v21;
                if (!mach_ports_register(mach_task_self_, init_port_set, 1u))
                {
                  dword_100076A00 = v21;
                  qword_100076A08 = xpc_mach_send_create_with_disposition();
                  qword_100076980 = mach_absolute_time();
                  uuid_generate(byte_100076990);
                  LODWORD(qword_1000769A0) = getuid();
                  HIDWORD(qword_1000769A0) = geteuid();
                  dword_1000769A8 = getegid();
                  dword_1000769AC = geteuid();
                  LODWORD(qword_1000769B0) = getegid();
                  HIDWORD(qword_1000769B0) = getpid();
                  dword_1000769B8 = sub_1000201F8();
                  unk_1000769BC = 0;
                  uint64_t v39 = 0u;
                  size_t v40 = 0u;
                  double v37 = 0u;
                  uint64_t v38 = 0u;
                  uint64_t v35 = 0u;
                  uint64_t v36 = 0u;
                  uint64_t v33 = 0u;
                  uint64_t v34 = 0u;
                  uint64_t v31 = 0u;
                  uint64_t v32 = 0u;
                  *(_OWORD *)init_port_set = 0u;
                  uint64_t v30 = 0u;
                  uint64_t v22 = getpid();
                  uint64_t v23 = sub_1000428E0(v22, init_port_set);
                  if (v23)
                  {
                    if (v23 != 45) {
                      sub_100040E80("could not get unique pid");
                    }
                  }
                  qword_100076988 = *((void *)&v38 + 1);
                  sub_1000473E4();
                  sub_100010280();
                  sub_10003C33C();
                  sub_1000204E0();
                  sub_10002EA7C();
                  sub_10003DEB0();
                  sub_10003F0A8();
                  sub_10003B9B4();
                  sub_10003B3D4();
                  nullsub_23(v24, v25);
                  sub_100013EB8();
                  sub_100002E4C();
                  sub_10001D790();
                  uint64_t v26 = sub_10000EBB4();
                  nullsub_23(v26, v27);
                  sub_10000FDFC();
                  sub_100012794();
                  sub_10001DE94();
                  sub_10004559C();
                  uint64_t v28 = sub_100014B58();
                  dispatch_activate(v28);
                  dispatch_main();
                }
                sub_100040E80("could not set up inheritance port");
              }
              sub_100043D78(3, "Could not neuter bootstrap port: 0x%x", v20);
              exit(1);
            }
          }
        }
        goto LABEL_56;
      }
    }
    __error();
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_56:
    __error();
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_57:
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_58:
    uuid_unparse((const unsigned __int8 *)init_port_set, out);
  }
}

int *sub_100016AF0(int a1, int a2)
{
  xpc_type_t result = (int *)open("/dev/null", a1 | 0x20000, 438);
  if (result != -1)
  {
    mach_port_options_t v4 = (int *)dup2((int)result, a2);
    if (v4 == -1 && *__error()) {
      sub_100050D28();
    }
    return sub_10003E54C(v4);
  }
  return result;
}

size_t sub_100016B80(const char *a1)
{
  if (sub_100016BF0(a1, "Frameworks") & 1) != 0 || (sub_100016BF0(a1, "PrivateFrameworks")) {
    return 1;
  }

  return sub_100016BF0(a1, "AppRemovalServices");
}

size_t sub_100016BF0(const char *a1, const char *a2)
{
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/%s", "/System/Library", a2);
  if (sub_100015CAC(a1, __str)) {
    return 1;
  }
  size_t result = (size_t)sub_10004AC14("SystemRoots");
  if (result)
  {
    pid_t v5 = (void *)result;
    if (xpc_get_type((xpc_object_t)result) == (xpc_type_t)&_xpc_type_array)
    {
      size_t result = xpc_array_get_count(v5);
      if (result)
      {
        size_t v6 = 0;
        while (1)
        {
          string = xpc_array_get_string(v5, v6);
          if (string)
          {
            unsigned int v8 = string;
            bzero(__str, 0x400uLL);
            snprintf(__str, 0x400uLL, "%s/%s", v8, a2);
            if (sub_100015CAC(a1, __str)) {
              break;
            }
          }
          if (++v6 >= xpc_array_get_count(v5)) {
            return 0;
          }
        }
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

char *sub_100016D44(char a1, const char *a2, _OWORD *a3, uint64_t a4, NSObject *a5)
{
  mach_port_t v10 = (char *)sub_10001A718(0);
  v10[100] = a1;
  *((void *)v10 + 2) = sub_1000159F0(a2);
  long long v11 = a3[1];
  *(_OWORD *)(v10 + 24) = *a3;
  *(_OWORD *)(v10 + 40) = v11;
  *((void *)v10 + 7) = a4;
  *((void *)v10 + 8) = a5;
  dispatch_retain(a5);
  return v10;
}

void sub_100016DBC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 101)) {
    sub_100050D0C();
  }
  free(*(void **)(a1 + 16));
  dispatch_release(*(dispatch_object_t *)(a1 + 64));
  size_t v2 = *(const void **)(a1 + 72);
  if (v2) {
    _Block_release(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 80);
  if (v3) {
    _Block_release(v3);
  }
  mach_port_options_t v4 = *(void **)(a1 + 88);
  if (v4)
  {
    sub_10001A174(v4);
    *(void *)(a1 + 88) = 0;
  }
}

void *sub_100016E2C(uint64_t a1, void *aBlock)
{
  if (*(unsigned char *)(a1 + 101)) {
    sub_100050D0C();
  }
  size_t result = _Block_copy(aBlock);
  *(void *)(a1 + 72) = result;
  return result;
}

void *sub_100016E64(uint64_t a1, void *aBlock)
{
  if (*(unsigned char *)(a1 + 101)) {
    sub_100050D0C();
  }
  size_t result = _Block_copy(aBlock);
  *(void *)(a1 + 80) = result;
  return result;
}

void sub_100016E9C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  if (*(unsigned char *)(a1 + 101)) {
    sub_100050D0C();
  }
  *(unsigned char *)(a1 + 101) |= 1u;
  sub_10001A0AC((void *)a1);
  if (!*(void *)(a1 + 72)) {
    sub_100050D0C();
  }
  if (!*(void *)(a1 + 80)) {
    sub_100050D0C();
  }
  size_t v2 = *(const char **)(a1 + 16);
  if (*v2 != 47 || sub_100015CAC(*(const char **)(a1 + 16), "/usr/lib") || sub_100015CAC(v2, "/usr/local/lib"))
  {
    sub_100017140(a1);
  }
  else
  {
    int v3 = *(unsigned __int8 *)(a1 + 100);
    switch(*(unsigned char *)(a1 + 100))
    {
      case 1:
        sub_1000171C4(a1);
        return;
      case 2:
        sub_100017294(a1);
        return;
      case 3:
        sub_100017374(a1);
        return;
      case 4:
      case 5:
        if (!qword_100075CF0) {
          goto LABEL_28;
        }
        if (xpc_dictionary_get_BOOL((xpc_object_t)qword_100075CF0, *(const char **)(a1 + 16)))
        {
          sub_100017F2C(a1);
        }
        else
        {
          int v3 = *(unsigned __int8 *)(a1 + 100);
LABEL_28:
          if (v3 == 5) {
            int v10 = 1;
          }
          else {
            int v10 = 2;
          }
          pid_t v5 = sub_1000104C4(v10, *(void *)(a1 + 16), 0);
          long long v11 = *(_OWORD *)(a1 + 40);
          *((_OWORD *)v5 + 1) = *(_OWORD *)(a1 + 24);
          *((_OWORD *)v5 + 2) = v11;
          unsigned int v7 = *(NSObject **)(a1 + 64);
          *((void *)v5 + 6) = *(void *)(a1 + 56);
          uint64_t v12 = _NSConcreteStackBlock;
          uint64_t v13 = 0x40000000;
          unsigned int v8 = &unk_1000701F8;
          uint64_t v9 = sub_100018298;
LABEL_32:
          int v14 = v9;
          uint64_t v15 = v8;
          uint64_t v16 = a1;
          int v17 = v5;
          sub_1000104F8((uint64_t)v5, v7, &v12);
        }
        break;
      case 6:
      case 7:
        if (v3 == 7) {
          int v4 = 1;
        }
        else {
          int v4 = 2;
        }
        pid_t v5 = sub_1000104C4(v4, *(void *)(a1 + 16), 0);
        long long v6 = *(_OWORD *)(a1 + 40);
        *((_OWORD *)v5 + 1) = *(_OWORD *)(a1 + 24);
        *((_OWORD *)v5 + 2) = v6;
        unsigned int v7 = *(NSObject **)(a1 + 64);
        *((void *)v5 + 6) = *(void *)(a1 + 56);
        uint64_t v12 = _NSConcreteStackBlock;
        uint64_t v13 = 0x40000000;
        unsigned int v8 = &unk_100070218;
        uint64_t v9 = sub_10001848C;
        goto LABEL_32;
      default:
        sub_100050EEC();
    }
  }
}

void sub_100017140(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
  if ((*(unsigned char *)(a1 + 101) & 1) == 0) {
    sub_100050D0C();
  }
  *(unsigned char *)(a1 + 101) &= ~1u;

  sub_10001A174((void *)a1);
}

void sub_1000171C4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  int v3 = *(const char **)(a1 + 16);
  if (sub_100015CF0(v3, ".plist"))
  {
    char v4 = 2;
  }
  else if (sub_100015CF0(v3, ".xpc") || sub_100015CF0(v3, ".pluginkit"))
  {
    v2 |= 0x1000uLL;
    char v4 = 7;
  }
  else
  {
    char v4 = 3;
  }
  pid_t v5 = sub_100016D44(v4, v3, (_OWORD *)(a1 + 24), v2, *(NSObject **)(a1 + 64));
  sub_100017E34(a1, v5);
  sub_10001A174(v5);

  sub_100017F2C(a1);
}

void sub_100017294(uint64_t a1)
{
  uint64_t v2 = *(const char **)(a1 + 16);
  if (sub_100015CF0(v2, ".plist"))
  {
    int v3 = sub_1000104C4(0, (uint64_t)v2, 0);
    long long v4 = *(_OWORD *)(a1 + 40);
    *((_OWORD *)v3 + 1) = *(_OWORD *)(a1 + 24);
    *((_OWORD *)v3 + 2) = v4;
    pid_t v5 = *(NSObject **)(a1 + 64);
    *((void *)v3 + 6) = *(void *)(a1 + 56);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_1000180E4;
    v6[3] = &unk_1000701B8;
    v6[4] = a1;
    void v6[5] = v3;
    sub_1000104F8((uint64_t)v3, v5, v6);
  }
  else
  {
    sub_100017140(a1);
  }
}

void sub_100017374(uint64_t a1)
{
  uint64_t v2 = sub_1000104C4(3, *(void *)(a1 + 16), 0);
  long long v3 = *(_OWORD *)(a1 + 40);
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 24);
  *((_OWORD *)v2 + 2) = v3;
  long long v4 = *(NSObject **)(a1 + 64);
  *((void *)v2 + 6) = *(void *)(a1 + 56);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100018138;
  v5[3] = &unk_1000701D8;
  _DWORD v5[4] = a1;
  void v5[5] = v2;
  sub_1000104F8((uint64_t)v2, v4, v5);
}

void sub_100017410(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 140)) {
    sub_100050D0C();
  }
  sub_10001A174(*(void **)(a1 + 48));
  uint64_t v2 = *(void **)(a1 + 72);
  if (v2) {
    xpc_release(v2);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 16));
  _Block_release(*(const void **)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 80));
  long long v3 = *(NSObject **)(a1 + 56);
  if (v3) {
    dispatch_release(v3);
  }
  sub_10001A174(*(void **)(a1 + 64));
  long long v4 = *(void **)(a1 + 32);

  sub_10001A174(v4);
}

void sub_1000174B4(void *a1, int a2, void *a3, void *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 - 1) >= 2) {
    sub_100050D0C();
  }
  uint64_t v8 = a6;
  if (!a1[32]) {
    a1[32] = mach_absolute_time();
  }
  if (a2 == 1) {
    sub_10002B104((uint64_t)a1, 8, (uint64_t)a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8, v44);
  }
  int v14 = sub_100014B58();
  uint64_t v15 = (char *)sub_10001A6D8(0);
  *((void *)v15 + 6) = sub_10001A0AC(a1);
  v15[96] = a2;
  *((void *)v15 + 11) = v8;
  if (a3) {
    *((void *)v15 + 9) = xpc_retain(a3);
  }
  *((void *)v15 + 2) = v14;
  dispatch_retain(v14);
  *((void *)v15 + 10) = xpc_dictionary_create(0, 0, 0);
  *((void *)v15 + 4) = sub_10001137C();
  if (a2 == 2 && a3)
  {
    uint64_t v16 = dispatch_group_create();
    *((void *)v15 + 7) = v16;
    dispatch_group_enter(v16);
  }
  *((void *)v15 + 8) = sub_100045FAC();
  if (a5 == &qword_1000769A0
    || (*a5 == qword_1000769A0 ? (BOOL v17 = a5[1] == *(void *)&dword_1000769A8) : (BOOL v17 = 0),
        v17 ? (BOOL v18 = a5[2] == qword_1000769B0) : (BOOL v18 = 0),
        v18 ? (BOOL v19 = a5[3] == *(void *)&dword_1000769B8) : (BOOL v19 = 0),
        v19))
  {
    char v20 = 2;
  }
  else if (sub_100019178())
  {
    char v20 = 2;
  }
  else
  {
    char v20 = 1;
  }
  v15[104] = v20;
  long long v21 = *((_OWORD *)a5 + 1);
  *(_OWORD *)(v15 + 108) = *(_OWORD *)a5;
  *(_OWORD *)(v15 + 124) = v21;
  if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(a4))
    {
      size_t v22 = 0;
      do
      {
        string = xpc_array_get_string(a4, v22);
        if (string)
        {
          uint64_t v24 = string;
          if ((v8 & 0x1000) != 0) {
            char v25 = 6;
          }
          else {
            char v25 = 4;
          }
          if ((v8 & 0x1000) != 0) {
            char v26 = 7;
          }
          else {
            char v26 = 5;
          }
          if (v8 != 1) {
            char v26 = 1;
          }
          if (v8 == 2) {
            char v27 = v25;
          }
          else {
            char v27 = v26;
          }
          uint64_t v8 = v8 & 0xFFFFFF00;
          uint64_t v28 = sub_100014B58();
          uint64_t v29 = sub_100016D44(v27, v24, v15 + 108, v8, v28);
          sub_1000184E0((uint64_t)v15, v29);
          sub_10001A174(v29);
        }
        ++v22;
      }
      while (v22 < xpc_array_get_count(a4));
    }
  }
  else if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
  {
    if ((v8 & 0x1000) != 0) {
      char v30 = 6;
    }
    else {
      char v30 = 4;
    }
    if ((v8 & 0x1000) != 0) {
      char v31 = 7;
    }
    else {
      char v31 = 5;
    }
    if (v8 == 1) {
      char v32 = v31;
    }
    else {
      char v32 = 1;
    }
    if (v8 == 2) {
      char v33 = v30;
    }
    else {
      char v33 = v32;
    }
    int64_t string_ptr = xpc_string_get_string_ptr(a4);
    uint64_t v35 = sub_100014B58();
    uint64_t v36 = sub_100016D44(v33, string_ptr, v15 + 108, v8 & 0xFFFFFF00, v35);
    sub_1000184E0((uint64_t)v15, v36);
    sub_10001A174(v36);
  }
  else
  {
    if (xpc_get_type(a4) != (xpc_type_t)&_xpc_type_dictionary) {
      sub_100050F08();
    }
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_1000185CC;
    applier[3] = &unk_100070238;
    applier[4] = v8;
    void applier[5] = v15;
    xpc_dictionary_apply(a4, applier);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1000178FC;
  aBlock[3] = &unk_1000700D0;
  aBlock[4] = v15;
  if (v15[140]) {
    sub_100050D0C();
  }
  *((void *)v15 + 3) = _Block_copy(aBlock);
  double v37 = sub_100014B58();
  v45[0] = _NSConcreteStackBlock;
  v45[1] = 0x40000000;
  v45[2] = sub_100017B40;
  v45[3] = &unk_1000700F0;
  v45[4] = v15;
  char v38 = sub_10003B4B0((uint64_t)a3, v37, v45);
  if (a3)
  {
    if ((v38 & 1) == 0) {
      sub_10002A5B8((uint64_t)a1, 5, "couldn't handoff domain IO, asynced away", v39, v40, v41, v42, v43, v44);
    }
  }
}

void sub_1000178FC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  long long v3 = *(uint64_t **)(v2 + 48);
  if ((*(unsigned char *)(v2 + 89) & 4) != 0)
  {
    if (*(unsigned char *)(v2 + 96) != 1) {
      sub_100050D0C();
    }
    long long v4 = *(rb_tree_t ***)(v2 + 64);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_100018CF4;
    v16[3] = &unk_1000702B8;
    v16[4] = v3;
    v16[5] = v2;
    sub_100045F0C(v4, (uint64_t)v16);
  }
  pid_t v5 = *(void **)(v2 + 72);
  if (v5)
  {
    if (*(unsigned char *)(v2 + 96) == 1) {
      long long v6 = "bootstrap-error";
    }
    else {
      long long v6 = "bootout-error";
    }
    xpc_dictionary_set_int64(*(xpc_object_t *)(v2 + 72), v6, *(int *)(v2 + 100));
    xpc_dictionary_set_value(v5, "errors", *(xpc_object_t *)(v2 + 80));
    if (*(void *)(v2 + 56))
    {
      xpc_retain(v5);
      sub_10001A0AC(v3);
      dispatch_group_leave(*(dispatch_group_t *)(v2 + 56));
      unsigned int v7 = *(NSObject **)(v2 + 56);
      uint64_t v8 = *(NSObject **)(v2 + 16);
      int v10 = _NSConcreteStackBlock;
      uint64_t v11 = 0x40000000;
      uint64_t v12 = sub_100018D88;
      uint64_t v13 = &unk_1000702D8;
      int v14 = v5;
      uint64_t v15 = v3;
      dispatch_group_notify(v7, v8, &v10);
    }
    else if ((xpc_pipe_routine_reply() | 0x20) != 0x20)
    {
      _os_assumes_log_ctx();
    }
  }
  else
  {
    uint64_t v9 = *(void **)(v2 + 80);
    int v10 = _NSConcreteStackBlock;
    uint64_t v11 = 0x40000000;
    uint64_t v12 = sub_100018E08;
    uint64_t v13 = &unk_1000702F8;
    int v14 = (void *)v2;
    xpc_dictionary_apply(v9, &v10);
  }
  if ((*(unsigned char *)(v2 + 89) & 0x20) != 0)
  {
    v3[33] = sub_10000D388(v3[32]);
    sub_10002B47C((uint64_t)v3);
  }
  if (*(unsigned char *)(v2 + 96) == 1) {
    sub_10002B1A4((uint64_t)v3, 8);
  }
  sub_10001A174(*(void **)(a1 + 32));
}

void sub_100017B40(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 16));
  if (*(unsigned char *)(v1 + 140)) {
    sub_100050D0C();
  }
  *(unsigned char *)(v1 + 140) |= 1u;
  sub_10001A0AC((void *)v1);
  if (sub_100011574(*(void *)(v1 + 32)))
  {
    uint64_t v2 = sub_100011574(*(void *)(v1 + 32));
    if (*(unsigned char *)(v1 + 90)) {
      uint64_t v3 = 1;
    }
    else {
      uint64_t v3 = v2;
    }
    if (v3)
    {
      for (unint64_t i = 0; i != v3; ++i)
      {
        uint64_t v5 = sub_100011548(*(void *)(v1 + 32), i);
        sub_100016E9C(v5);
      }
    }
  }
  else
  {
    sub_100018BEC(v1);
  }
}

void sub_100017C00(void *a1, int a2, void *a3, void *a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_100017C08(void *a1, const char *a2, void *a3, _OWORD *a4, uint64_t a5)
{
  int v10 = sub_100014B58();
  uint64_t v11 = sub_100016D44(6, a2, a4, 20480, v10);
  if (a3) {
    xpc_retain(a3);
  }
  sub_10001A0AC(a1);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_100017D00;
  v12[3] = &unk_100070118;
  void v12[4] = a5;
  void v12[5] = a3;
  v12[6] = a1;
  v12[7] = v11;
  sub_100016E2C((uint64_t)v11, v12);
  sub_100016E64((uint64_t)v11, &stru_100070158);
  sub_100016E9C((uint64_t)v11);
}

void sub_100017D00(uint64_t a1, uint64_t a2, int a3)
{
  int v8 = a3;
  if (!a3)
  {
    uint64_t v5 = *(void **)(a1 + 40);
    if (v5)
    {
      if (!sub_10001064C(a2)) {
        sub_100050D0C();
      }
      info_xpc_object_t dictionary = xpc_bundle_get_info_dictionary();
      if (info_dictionary)
      {
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000;
        applier[2] = sub_100018EAC;
        applier[3] = &unk_100070318;
        applier[4] = info_dictionary;
        xpc_dictionary_apply(v5, applier);
      }
    }
    sub_10002E408(*(void *)(a1 + 48), a2, *(void **)(a1 + 40), &v8);
    unsigned int v7 = *(void **)(a1 + 40);
    if (v7) {
      xpc_release(v7);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  sub_10001A174(*(void **)(a1 + 48));
  sub_10001A174(*(void **)(a1 + 56));
}

void sub_100017E18(id a1, _launch_domain_io_s *a2, _launch_io_s *a3, int a4)
{
}

void *sub_100017E34(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 96)) {
    sub_100050D0C();
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100017FF8;
  aBlock[3] = &unk_100070178;
  aBlock[4] = a1;
  void aBlock[5] = a2;
  sub_100016E2C((uint64_t)a2, aBlock);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1000180DC;
  v6[3] = &unk_100070198;
  v6[4] = a1;
  sub_100016E64((uint64_t)a2, v6);
  long long v4 = *(void **)(a1 + 88);
  if (!v4)
  {
    long long v4 = sub_10001137C();
    *(void *)(a1 + 88) = v4;
  }
  return sub_100011418(v4, a2);
}

void sub_100017F2C(uint64_t a1)
{
  if (*(void *)(a1 + 88))
  {
    sub_10001A0AC((void *)a1);
    int v2 = sub_100011574(*(void *)(a1 + 88));
    *(_DWORD *)(a1 + 96) = v2;
    if (!v2) {
      sub_100050D0C();
    }
    if (sub_100011574(*(void *)(a1 + 88)))
    {
      unint64_t v3 = 0;
      do
      {
        uint64_t v4 = sub_100011548(*(void *)(a1 + 88), v3);
        sub_100016E9C(v4);
        ++v3;
      }
      while (v3 < sub_100011574(*(void *)(a1 + 88)));
    }
    sub_10001A174((void *)a1);
  }
  else
  {
    sub_100017140(a1);
  }
}

void sub_100017FF8(uint64_t a1)
{
  sub_10001806C(*(void *)(a1 + 32));
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(_DWORD *)(v2 + 96);
  if (!v3) {
    sub_100050D0C();
  }
  int v4 = v3 - 1;
  *(_DWORD *)(v2 + 96) = v4;
  if (!v4)
  {
    sub_100017140(v2);
  }
}

uint64_t sub_10001806C(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 101) & 1) == 0) {
    sub_100050D0C();
  }
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 80) + 16);

  return v2();
}

uint64_t sub_1000180DC(uint64_t a1)
{
  return sub_10001806C(*(void *)(a1 + 32));
}

void sub_1000180E4(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_100050D0C();
  }
  sub_100017140(*(void *)(a1 + 32));
  int v3 = *(void **)(a1 + 40);

  sub_10001A174(v3);
}

void sub_100018138(uint64_t a1, uint64_t a2, int a3)
{
  if (a3)
  {
    sub_100017140(*(void *)(a1 + 32));
  }
  else
  {
    if (!a2) {
      sub_100050D0C();
    }
    if (!sub_100011574(a2) && (*(unsigned char *)(*(void *)(a1 + 32) + 57) & 0x20) == 0) {
      sub_100043D78(4, "Activated a directory (%s) and found no files", "<private>");
    }
    if (sub_100011574(a2))
    {
      unint64_t v5 = 0;
      do
      {
        uint64_t v6 = sub_100011548(a2, v5);
        uint64_t v7 = *(void *)(a1 + 32);
        long long v8 = *(_OWORD *)(v7 + 40);
        *(_OWORD *)(v6 + 16) = *(_OWORD *)(v7 + 24);
        *(_OWORD *)(v6 + 32) = v8;
        *(void *)(v6 + 48) = *(void *)(v7 + 56);
        int v9 = sub_100010604(v6);
        int v10 = (const char *)sub_100010644(v6);
        if (v9 == 3) {
          char v11 = 5;
        }
        else {
          char v11 = 2;
        }
        uint64_t v12 = sub_100016D44(v11, v10, (_OWORD *)(*(void *)(a1 + 32) + 24), *(void *)(*(void *)(a1 + 32) + 56), *(NSObject **)(*(void *)(a1 + 32) + 64));
        sub_100017E34(*(void *)(a1 + 32), v12);
        sub_10001A174(v12);
        ++v5;
      }
      while (v5 < sub_100011574(a2));
    }
    sub_100017F2C(*(void *)(a1 + 32));
  }
  uint64_t v13 = *(void **)(a1 + 40);

  sub_10001A174(v13);
}

void sub_100018298(uint64_t a1, uint64_t a2, int a3)
{
  if (a2) {
    sub_100050D0C();
  }
  if (a3)
  {
    sub_100017140(*(void *)(a1 + 32));
    int v4 = (uint64_t *)(a1 + 40);
  }
  else
  {
    int v4 = (uint64_t *)(a1 + 40);
    sub_10001064C(*(void *)(a1 + 40));
    unint64_t v5 = (void *)xpc_bundle_copy_services();
    if (xpc_array_get_count(v5))
    {
      size_t v6 = 0;
      do
      {
        xpc_object_t value = xpc_array_get_value(v5, v6);
        if (sub_100010614(*v4))
        {
          long long v8 = sub_10001925C(value);
          int v9 = sub_100010604((uint64_t)v8);
          uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 56) | 0x1000;
          char v11 = (const char *)sub_100010644((uint64_t)v8);
          if (v9 == 1) {
            char v12 = 7;
          }
          else {
            char v12 = 6;
          }
          uint64_t v13 = sub_100016D44(v12, v11, (_OWORD *)(*(void *)(a1 + 32) + 24), v10, *(NSObject **)(*(void *)(a1 + 32) + 64));
          long long v14 = *(_OWORD *)(v13 + 40);
          *((_OWORD *)v8 + 1) = *(_OWORD *)(v13 + 24);
          *((_OWORD *)v8 + 2) = v14;
          *((void *)v8 + 6) = *((void *)v13 + 7);
          sub_10001806C(*(void *)(a1 + 32));
          sub_10001A174(v13);
        }
        else
        {
          path = (const char *)xpc_bundle_get_path();
          long long v8 = sub_100016D44(7, path, (_OWORD *)(*(void *)(a1 + 32) + 24), *(void *)(*(void *)(a1 + 32) + 56) | 0x1000, *(NSObject **)(*(void *)(a1 + 32) + 64));
          sub_100017E34(*(void *)(a1 + 32), v8);
        }
        sub_10001A174(v8);
        ++v6;
      }
      while (v6 < xpc_array_get_count(v5));
    }
    if ((sub_100010614(*v4) & 1) == 0 && !xpc_array_get_count(v5))
    {
      uint64_t v16 = *(void *)(a1 + 32);
      xpc_object_t v17 = (xpc_object_t)qword_100075CF0;
      if (!qword_100075CF0)
      {
        xpc_object_t v17 = xpc_dictionary_create(0, 0, 0);
        qword_100075CF0 = (uint64_t)v17;
      }
      xpc_dictionary_set_BOOL(v17, *(const char **)(v16 + 16), 1);
    }
    xpc_release(v5);
    sub_100017F2C(*(void *)(a1 + 32));
  }
  BOOL v18 = (void *)*v4;

  sub_10001A174(v18);
}

void sub_10001848C(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_100050D0C();
  }
  sub_100017140(*(void *)(a1 + 32));
  int v3 = *(void **)(a1 + 40);

  sub_10001A174(v3);
}

void *sub_1000184E0(uint64_t a1, void *a2)
{
  if (*(void *)(a1 + 40)) {
    sub_100050D0C();
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_1000186B4;
  aBlock[3] = &unk_100070278;
  aBlock[4] = a1;
  void aBlock[5] = a2;
  sub_100016E2C((uint64_t)a2, aBlock);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100018C88;
  v5[3] = &unk_100070298;
  _DWORD v5[4] = a1;
  sub_100016E64((uint64_t)a2, v5);
  return sub_100011418(*(void **)(a1 + 32), a2);
}

uint64_t sub_1000185CC(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_uint64) {
    uint64_t value = xpc_uint64_get_value(object);
  }
  else {
    uint64_t value = 0;
  }
  uint64_t v7 = *(void *)(a1 + 32) | value;
  int v8 = (*(unsigned char *)(a1 + 32) | value);
  if ((v7 & 0x1000) != 0) {
    char v9 = 6;
  }
  else {
    char v9 = 4;
  }
  if ((v7 & 0x1000) != 0) {
    char v10 = 7;
  }
  else {
    char v10 = 5;
  }
  if (v8 != 1) {
    char v10 = 1;
  }
  if (v8 == 2) {
    char v11 = v9;
  }
  else {
    char v11 = v10;
  }
  uint64_t v12 = v7 & 0xFFFFFF00;
  uint64_t v13 = (_OWORD *)(*(void *)(a1 + 40) + 108);
  long long v14 = sub_100014B58();
  uint64_t v15 = sub_100016D44(v11, a2, v13, v12, v14);
  sub_1000184E0(*(void *)(a1 + 40), v15);
  sub_10001A174(v15);
  return 1;
}

void sub_1000186B4(uint64_t a1, void *a2, int a3)
{
  sub_1000187AC(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = *(void *)(v4 + 32);
  unint64_t v6 = *(void *)(v4 + 40) + 1;
  *(void *)(v4 + 40) = v6;
  if (v6 > sub_100011574(v5)) {
    sub_100050D0C();
  }
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v7 + 40);
  uint64_t v9 = sub_100011574(*(void *)(v7 + 32));
  uint64_t v10 = *(void *)(a1 + 32);
  if (v8 == v9)
  {
    sub_100018BEC(v10);
  }
  else if (*(unsigned char *)(v10 + 90))
  {
    char v11 = sub_100014B58();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100018C58;
    block[3] = &unk_100070258;
    block[4] = *(void *)(a1 + 32);
    dispatch_async(v11, block);
  }
}

void sub_1000187AC(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  int v4 = a4;
  if (!a4)
  {
    int v7 = *(unsigned __int8 *)(a1 + 96);
    if ((v7 - 1) >= 2) {
      sub_100050D0C();
    }
    size_t v9 = *(void *)(a1 + 48);
    if (sub_10002ABC8(v9))
    {
      int v4 = 124;
      goto LABEL_47;
    }
    int v10 = *(unsigned __int8 *)(a2 + 100);
    if ((v10 - 6) >= 2)
    {
      if (v10 != 2)
      {
LABEL_46:
        int v4 = 0;
        goto LABEL_47;
      }
      if (v7 == 1)
      {
        int v11 = sub_10002D710(v9, (uint64_t)a3);
LABEL_13:
        int v4 = v11;
        goto LABEL_47;
      }
      int v12 = sub_10002DF1C(v9, (uint64_t)a3, *(NSObject **)(a1 + 56));
      if (((v12 == 36) & (*(unsigned __int8 *)(a1 + 90) >> 1)) != 0) {
        int v4 = 0;
      }
      else {
        int v4 = v12;
      }
    }
    else
    {
      if (v7 == 2)
      {
        int v4 = 116;
        goto LABEL_47;
      }
      if ((*(unsigned char *)(a1 + 89) & 4) == 0)
      {
        int v11 = sub_10002E3CC(v9, (uint64_t)a3);
        goto LABEL_13;
      }
      sub_10001064C((uint64_t)a3);
      uint64_t v13 = *(rb_tree_t ***)(a1 + 64);
      info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary();
      if (!info_dictionary
        || (uint64_t v15 = info_dictionary, (string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier")) == 0))
      {
        int v4 = 107;
        goto LABEL_47;
      }
      xpc_object_t v17 = string;
      BOOL v18 = sub_100045ED4(v13, string);
      if (!v18) {
        goto LABEL_45;
      }
      uint64_t v19 = (uint64_t)v18;
      sub_10001064C((uint64_t)v18);
      uint64_t property = (const char *)xpc_bundle_get_property();
      long long v21 = (const char *)xpc_bundle_get_property();
      if (sub_100016B80(v21) && !sub_100016B80(property))
      {
        int v4 = 127;
        goto LABEL_47;
      }
      if (sub_100016B80(v21) & 1) == 0 && (sub_100016B80(property))
      {
        int v4 = 127;
LABEL_44:
        uint64_t v34 = (const char *)sub_100010644(v19);
        sub_100018C90(a1, v34, v4);
LABEL_45:
        a3[6] &= ~0x400uLL;
        sub_100045E1C((uint64_t)v13, v17, a3);
        goto LABEL_46;
      }
      if (sub_100016B80(v21) & 1) != 0 || (sub_100016B80(property))
      {
        if (!strcmp(v21, property))
        {
          int v4 = 121;
        }
        else
        {
          sub_10002A5B8(*(void *)(a1 + 48), 4, "Conflicts exist in System services. Randomly deciding: path1 = %s, path2 = %s", v22, v23, v24, v25, v26, (char)property);
          int v4 = 130;
        }
      }
      else
      {
        char v27 = xpc_dictionary_get_string(v15, "CFBundleVersion");
        if (v27) {
          uint64_t v28 = v27;
        }
        else {
          uint64_t v28 = "0";
        }
        uint64_t v29 = (void *)xpc_bundle_get_info_dictionary();
        char v30 = xpc_dictionary_get_string(v29, "CFBundleVersion");
        if (v30) {
          char v31 = v30;
        }
        else {
          char v31 = "0";
        }
        int v32 = sub_100015AA4(v28, v31);
        if ((v32 + 1) >= 2) {
          int v33 = 0;
        }
        else {
          int v33 = 3;
        }
        if (v32 == 1) {
          int v33 = 2;
        }
        int v4 = 129;
        if ((v33 | 2) == 2) {
          goto LABEL_44;
        }
      }
    }
  }
LABEL_47:
  int v35 = *(unsigned __int8 *)(a2 + 100);
  if (v35 == 2)
  {
    if ((*(unsigned char *)(a1 + 89) & 0x20) != 0) {
      goto LABEL_62;
    }
    if (*(unsigned char *)(a1 + 96) == 1) {
      uint64_t v36 = "Bootstrap";
    }
    else {
      uint64_t v36 = "Bootout";
    }
    if (v4)
    {
      xpc_strerror();
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      sub_100042920(a1 + 108, (char *)&v42);
      if (v4 != 36)
      {
        sub_10002A5B8(*(void *)(a1 + 48), 5, "%s by %s[%d] for %s failed (%d: %s)", v37, v38, v39, v40, v41, (char)v36);
LABEL_57:
        LOBYTE(v35) = *(unsigned char *)(a2 + 100);
        goto LABEL_58;
      }
    }
    else
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      sub_100042920(a1 + 108, (char *)&v42);
    }
    sub_10002A5B8(*(void *)(a1 + 48), 5, "%s by %s[%d] for %s succeeded (%d: %s)", v37, v38, v39, v40, v41, (char)v36);
    goto LABEL_57;
  }
LABEL_58:
  if ((v35 & 0xFE) != 4 || (v4 - 107) > 0x15 || ((1 << (v4 - 107)) & 0x200005) == 0)
  {
LABEL_62:
    if (!v4) {
      return;
    }
    goto LABEL_63;
  }
  int v4 = 121;
LABEL_63:
  sub_100018C90(a1, *(const char **)(a2 + 16), v4);
}

void sub_100018BEC(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  (*(void (**)(void))(*(void *)(a1 + 24) + 16))();
  if ((*(unsigned char *)(a1 + 140) & 1) == 0) {
    sub_100050D0C();
  }
  *(unsigned char *)(a1 + 140) &= ~1u;

  sub_10001A174((void *)a1);
}

void sub_100018C58(uint64_t a1)
{
  uint64_t v1 = sub_100011548(*(void *)(*(void *)(a1 + 32) + 32), *(void *)(*(void *)(a1 + 32) + 40));

  sub_100016E9C(v1);
}

void sub_100018C88(uint64_t a1, uint64_t a2, void *a3, int a4)
{
}

void sub_100018C90(uint64_t a1, const char *a2, int a3)
{
  if (!a3) {
    sub_100050D0C();
  }
  if (*(unsigned char *)(a1 + 104) != 2)
  {
    int v5 = 5;
    goto LABEL_6;
  }
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 80), a2, a3);
  if (*(_DWORD *)(a1 + 100))
  {
    int v5 = 133;
LABEL_6:
    *(_DWORD *)(a1 + 100) = v5;
    return;
  }
  *(_DWORD *)(a1 + 100) = a3;
}

void sub_100018CF4(uint64_t a1, int a2, id a3)
{
  Class Class = j__object_getClass(a3);
  if (Class != (Class)sub_10001A8F8()) {
    sub_100050D0C();
  }
  int v6 = sub_10002E3CC(*(void *)(a1 + 32), (uint64_t)a3);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = *(void *)(a1 + 40);
    size_t v9 = (const char *)sub_100010644((uint64_t)a3);
    sub_100018C90(v8, v9, v7);
  }
}

void sub_100018D88(uint64_t a1)
{
  int v2 = xpc_pipe_routine_reply();
  xpc_release(*(xpc_object_t *)(a1 + 32));
  if ((v2 | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  int v3 = *(void **)(a1 + 40);

  sub_10001A174(v3);
}

uint64_t sub_100018E08(uint64_t a1, char a2, xpc_object_t xint)
{
  uint64_t v4 = *(void *)(a1 + 32);
  int value = xpc_int64_get_value(xint);
  BOOL v6 = (value - 119) > 0x21 || ((1 << (value - 119)) & 0x220008025) == 0;
  if (v6 || byte_100076A78)
  {
    uint64_t v7 = *(void *)(v4 + 48);
    xpc_strerror();
    sub_10002A5B8(v7, 3, "Failed to bootstrap path: path = %s, int error = %d: %s", v8, v9, v10, v11, v12, a2);
  }
  return 1;
}

uint64_t sub_100018EAC(uint64_t a1, const char *a2, void *a3)
{
  return 1;
}

void sub_100018ECC(const void *a1)
{
  if (dword_100075A9C)
  {
    int v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    int v3 = dispatch_queue_create("com.apple.xpc.launchd.timeout", v2);
    uint64_t v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v3);
    qword_100075CF8 = (uint64_t)v4;
    dispatch_time_t v5 = dispatch_time(0, 1000000000 * dword_100075A9C);
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
    BOOL v6 = qword_100075CF8;
    uint64_t v7 = _Block_copy(a1);
    dispatch_set_context(v6, v7);
    dispatch_source_set_event_handler_f((dispatch_source_t)qword_100075CF8, (dispatch_function_t)sub_100018FC8);
    uint64_t v8 = qword_100075CF8;
    dispatch_activate(v8);
  }
}

void sub_100018FC8(uint64_t a1)
{
  uint64_t v2 = sub_100030018();
  int v3 = sub_100014B58();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10001912C;
  v4[3] = &unk_100070340;
  v4[4] = a1;
  v4[5] = v2;
  dispatch_async_and_wait(v3, v4);
}

void sub_10001904C()
{
  if (qword_100075CF8)
  {
    dispatch_source_cancel((dispatch_source_t)qword_100075CF8);
    dispatch_release((dispatch_object_t)qword_100075CF8);
    qword_100075CF8 = 0;
  }
}

void sub_100019084(uint64_t a1)
{
  if (qword_100075CF8)
  {
    uint64_t v2 = sub_100030018();
    uint64_t v3 = mach_absolute_time();
    unint64_t v4 = sub_10000D440(v3 - *(void *)(v2 + 272));
    unint64_t v5 = a1 + 1000000000 * dword_100075A9C;
    if (v5 > v4)
    {
      BOOL v6 = qword_100075CF8;
      dispatch_time_t v7 = dispatch_time(0, v5 - v4);
      dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0);
    }
  }
}

uint64_t sub_10001912C(uint64_t a1)
{
  nullsub_23(*(void *)(a1 + 40), "shutdowntimeout");
  uint64_t v2 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);

  return v2();
}

BOOL sub_100019178()
{
  return sandbox_check_by_audit_token() == 0;
}

BOOL sub_1000191C0()
{
  return sandbox_check_by_audit_token() == 0;
}

BOOL sub_100019210()
{
  return sandbox_check_process_signal_target() == 0;
}

unsigned char *sub_10001925C(void *a1)
{
  if (xpc_bundle_get_property() == 1) {
    char v2 = 2;
  }
  else {
    char v2 = 1;
  }
  uint64_t property = xpc_bundle_get_property();
  unint64_t v4 = sub_100010454(v2, property);
  *((void *)v4 + 10) = xpc_retain(a1);
  long long v5 = unk_100075480;
  *((_OWORD *)v4 + 8) = xmmword_100075470;
  *((_OWORD *)v4 + 9) = v5;
  long long v6 = unk_100075460;
  *((_OWORD *)v4 + 6) = xmmword_100075450;
  *((_OWORD *)v4 + 7) = v6;
  long long v7 = unk_1000754A0;
  *((_OWORD *)v4 + 10) = xmmword_100075490;
  *((_OWORD *)v4 + 11) = v7;
  long long v8 = unk_1000754C0;
  *((_OWORD *)v4 + 12) = xmmword_1000754B0;
  *((_OWORD *)v4 + 13) = v8;
  *((_OWORD *)v4 + 14) = xmmword_1000754D0;
  v4[264] |= 1u;
  return v4;
}

BOOL sub_100019300(const char *a1)
{
  uint64_t v2 = 0;
  do
  {
    BOOL result = sub_100015CAC(a1, off_100070360[v2]);
    if (result) {
      break;
    }
  }
  while (v2++ != 1);
  return result;
}

uint64_t sub_100019354(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 == 1)
  {
    if (sub_100015CF0(*(const char **)(a1 + 64), ".appex"))
    {
      long long v14 = *(char **)(a1 + 64);
LABEL_16:
      uint64_t v16 = (uint64_t)sub_100019C18(v14);
      goto LABEL_25;
    }
LABEL_17:
    int v2 = *(unsigned __int8 *)(a1 + 56);
LABEL_18:
    if (v2 == 2)
    {
      uint64_t v16 = sub_100019C58(*(char **)(a1 + 64));
    }
    else
    {
      if (v2 == 1)
      {
        uint64_t v19 = *(char **)(a1 + 64);
        uint64_t v17 = (uint64_t)sub_100019C18(v19);
        if (!v17)
        {
          uint64_t v20 = sub_100019C58(v19);
          if (!v20) {
            return 148;
          }
          uint64_t v17 = v20;
          sub_100043D78(5, "Found XPCService bundle by executable: %s", v19);
        }
LABEL_30:
        LODWORD(v7) = *(unsigned __int8 *)(a1 + 56);
        if ((v7 - 1) >= 2)
        {
          if (*(unsigned char *)(a1 + 56)) {
            goto LABEL_38;
          }
          long long v21 = (uint64_t *)(a1 + 88);
        }
        else
        {
          long long v21 = (uint64_t *)(a1 + 80);
        }
        uint64_t *v21 = v17;
        *(unsigned char *)(a1 + 264) |= 1u;
        *(_DWORD *)(a1 + 240) = 0;
        long long v22 = unk_100075480;
        *(_OWORD *)(a1 + 128) = xmmword_100075470;
        *(_OWORD *)(a1 + 144) = v22;
        long long v23 = unk_100075460;
        *(_OWORD *)(a1 + 96) = xmmword_100075450;
        *(_OWORD *)(a1 + 112) = v23;
        long long v24 = unk_1000754A0;
        *(_OWORD *)(a1 + 160) = xmmword_100075490;
        *(_OWORD *)(a1 + 176) = v24;
        long long v25 = unk_1000754C0;
        *(_OWORD *)(a1 + 192) = xmmword_1000754B0;
        *(_OWORD *)(a1 + 208) = v25;
        *(_OWORD *)(a1 + 224) = xmmword_1000754D0;
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
        (*(void (**)(void))(*(void *)(a1 + 256) + 16))();
        return 0;
      }
      if (v2 || !qword_1000769C0 || !sub_100045ED4((rb_tree_t **)qword_1000769C0, *(const void **)(a1 + 64))) {
        return 148;
      }
      uint64_t v16 = sub_100046114();
    }
LABEL_25:
    uint64_t v17 = v16;
    if (!v16) {
      return 148;
    }
    goto LABEL_30;
  }
  if (v2 == 2)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s", *(const char **)(a1 + 64));
    uint64_t v15 = strrchr(__str, 47);
    if (v15) {
      *uint64_t v15 = 0;
    }
    if (sub_100015CF0(__str, ".appex"))
    {
      long long v14 = __str;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  if (v2 != 3) {
    goto LABEL_18;
  }
  uint64_t v3 = *(const char **)(a1 + 64);
  if ((sub_100015DF0((xpc_object_t)qword_100076A30, v3) & 1) == 0
    && (!qword_100076A38 || !sub_100015DF0((xpc_object_t)qword_100076A38, v3)))
  {
    return 148;
  }
  size_t v4 = strlen(*(const char **)(a1 + 64));
  size_t v5 = v4 + 2;
  uint64_t v6 = v4 >= 0xFFFFFFFFFFFFFFFELL;
  uint64_t v7 = v6 << 63 >> 63;
  if (v7 != v6 || v7 < 0)
  {
    __break(1u);
LABEL_38:
    sub_100040E80("unsupported cached entry type %d", v7);
  }
  long long v8 = (char *)sub_100013BB8(v4 + 2);
  strlcpy(v8, *(const char **)(a1 + 64), v5);
  *(_WORD *)&v8[v5 - 2] = 47;
  uint64_t v9 = sub_10001137C();
  *(void *)__str = _NSConcreteStackBlock;
  uint64_t v27 = 0x40000000;
  uint64_t v28 = sub_100019B98;
  uint64_t v29 = &unk_100070378;
  char v30 = v8;
  char v31 = v9;
  sub_100045F0C((rb_tree_t **)qword_1000769C0, (uint64_t)__str);
  long long v10 = unk_100075550;
  *(_OWORD *)(a1 + 192) = xmmword_100075540;
  *(_OWORD *)(a1 + 208) = v10;
  *(_OWORD *)(a1 + 224) = xmmword_100075560;
  long long v11 = unk_100075510;
  *(_OWORD *)(a1 + 128) = xmmword_100075500;
  *(_OWORD *)(a1 + 144) = v11;
  long long v12 = unk_100075530;
  *(_OWORD *)(a1 + 160) = xmmword_100075520;
  *(_OWORD *)(a1 + 176) = v12;
  long long v13 = *(_OWORD *)algn_1000754F0;
  *(_OWORD *)(a1 + 96) = xmmword_1000754E0;
  *(_OWORD *)(a1 + 112) = v13;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
  (*(void (**)(void))(*(void *)(a1 + 256) + 16))();
  sub_10001A174(v9);
  free(v8);
  return 0;
}

xpc_object_t sub_1000196B4()
{
  int v0 = (int *)open("/System/Library/xpc/launchd.plist", 0);
  if ((v0 & 0x80000000) != 0)
  {
    int v6 = *__error();
    uint64_t v7 = __error();
    long long v8 = strerror(*v7);
    sub_100043D78(65539, "Unable to open %s [%d:%s]", "/System/Library/xpc/launchd.plist", v6, v8);
    return 0;
  }
  else
  {
    uint64_t v1 = v0;
    memset(&v13, 0, sizeof(v13));
    if (fstat((int)v0, &v13))
    {
      int v2 = *__error();
      uint64_t v3 = __error();
      size_t v4 = strerror(*v3);
      sub_100043D78(65539, "Unable to stat %s [%d:%s]", "/System/Library/xpc/launchd.plist", v2, v4);
      xpc_object_t v5 = 0;
    }
    else
    {
      size_t st_size = v13.st_size;
      long long v10 = (const void *)sub_1000431C8((v13.st_size + vm_page_size - 1) & -(uint64_t)vm_page_size);
      long long v11 = dispatch_data_create(v10, st_size, 0, _dispatch_data_destructor_vm_deallocate);
      xpc_object_t v5 = xpc_data_create_with_dispatch_data(v11);
      dispatch_release(v11);
    }
    sub_10003E54C(v1);
  }
  return v5;
}

void sub_1000197EC(xpc_object_t xdata)
{
  xpc_object_t v1 = xdata;
  if (!xdata)
  {
    sub_100043D78(65539, "No MRM cache found");
LABEL_7:
    char v5 = 1;
    goto LABEL_8;
  }
  xpc_data_get_bytes_ptr(xdata);
  xpc_data_get_length(v1);
  int v2 = (void *)xpc_create_from_plist();
  xpc_object_t v1 = v2;
  if (!v2)
  {
    sub_100043D78(65541, "Unable to parse MRM cache");
    goto LABEL_7;
  }
  xpc_object_t value = xpc_dictionary_get_value(v2, "SystemLibraryTreeState");
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v4, "_imagePathToInfo", value);
  xpc_dictionary_set_value(v1, "SystemLibraryTreeState", v4);
  xpc_release(v4);
  if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v7 = xpc_dictionary_get_value(v1, "LaunchDaemons");
    xpc_object_t v8 = v7;
    if (v7)
    {
      if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_object_t v8 = xpc_retain(v8);
      }
      else {
        xpc_object_t v8 = 0;
      }
    }
    xpc_object_t v9 = xpc_dictionary_get_value(v1, "SystemLibraryTreeState");
    xpc_object_t v10 = v9;
    if (v9)
    {
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary
        && (xpc_object_t v16 = xpc_dictionary_get_value(v10, "_imagePathToInfo")) != 0
        && (uint64_t v17 = v16, xpc_get_type(v16) == (xpc_type_t)&_xpc_type_dictionary))
      {
        xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
        applier = _NSConcreteStackBlock;
        uint64_t v19 = 0x40000000;
        uint64_t v20 = sub_100019E18;
        long long v21 = &unk_1000703D8;
        xpc_object_t v22 = v10;
        xpc_dictionary_apply(v17, &applier);
      }
      else
      {
        xpc_object_t v10 = 0;
      }
    }
    xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
    applier = _NSConcreteStackBlock;
    uint64_t v19 = 0x40000000;
    uint64_t v20 = sub_100019FFC;
    long long v21 = &unk_1000703F8;
    xpc_object_t v22 = v11;
    xpc_object_t v12 = xpc_dictionary_get_value(v1, "AppExtensions");
    if (v12)
    {
      stat v13 = v12;
      if (xpc_get_type(v12) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_dictionary_apply(v13, &applier);
      }
    }
    xpc_object_t v14 = xpc_dictionary_get_value(v1, "AppRemovalServices");
    if (v14)
    {
      uint64_t v15 = v14;
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary) {
        xpc_dictionary_apply(v15, &applier);
      }
    }
    sub_100019CB8(v8, v10, v11);
    if (v8) {
      xpc_release(v8);
    }
    if (v10) {
      xpc_release(v10);
    }
    if (v11) {
      xpc_release(v11);
    }
    goto LABEL_37;
  }
  char v5 = 0;
LABEL_8:
  if (byte_100076A63) {
    BOOL v6 = byte_100076A65 == 0;
  }
  else {
    BOOL v6 = 0;
  }
  if (!v6) {
    sub_100040E80("No service cache");
  }
  sub_100019CB8(0, 0, 0);
  if ((v5 & 1) == 0)
  {
LABEL_37:
    xpc_release(v1);
    return;
  }
  if (!dword_100076A40)
  {
    sub_100043D78(65540, "Unable to load cache");
  }
}

BOOL sub_100019B70()
{
  if (byte_100076A63) {
    BOOL v0 = byte_100076A65 == 0;
  }
  else {
    BOOL v0 = 0;
  }
  return !v0;
}

void sub_100019B98(uint64_t a1, const char *a2)
{
  if (sub_100015CAC(a2, *(char **)(a1 + 32)))
  {
    xpc_object_t v4 = sub_1000104C4(0, (uint64_t)a2, 0);
    sub_100011418(*(void **)(a1 + 40), v4);
    sub_10001A174(v4);
  }
}

xpc_object_t sub_100019C18(char *key)
{
  xpc_object_t result = xpc_dictionary_get_value((xpc_object_t)qword_1000769D0, key);
  if (result)
  {
    return xpc_retain(result);
  }
  return result;
}

uint64_t sub_100019C58(char *key)
{
  if (!xpc_dictionary_get_value((xpc_object_t)qword_1000769C8, key)) {
    return 0;
  }
  uint64_t v1 = xpc_bundle_create_from_origin();
  xpc_bundle_populate();
  return v1;
}

xpc_object_t sub_100019CB8(void *a1, void *a2, void *a3)
{
  if (qword_1000769C0) {
    sub_10001A174((void *)qword_1000769C0);
  }
  qword_1000769C0 = (uint64_t)sub_100045FAC();
  if (a1 && xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_dictionary_apply(a1, &stru_1000703B8);
  }
  if (qword_1000769C8) {
    xpc_release((xpc_object_t)qword_1000769C8);
  }
  if (a2 && xpc_get_type(a2) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_object_t v6 = xpc_retain(a2);
  }
  else {
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
  }
  qword_1000769C8 = (uint64_t)v6;
  if (qword_1000769D0) {
    xpc_release((xpc_object_t)qword_1000769D0);
  }
  if (a3 && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_object_t result = xpc_retain(a3);
  }
  else {
    xpc_object_t result = xpc_dictionary_create(0, 0, 0);
  }
  qword_1000769D0 = (uint64_t)result;
  return result;
}

BOOL sub_100019DC0(id a1, const char *a2, void *a3)
{
  sub_1000460A4();
  char v5 = v4;
  sub_100045E1C(qword_1000769C0, a2, v4);
  sub_10001A174(v5);
  return 1;
}

uint64_t sub_100019E18(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (object
    && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary
    && (xpc_object_t v9 = xpc_dictionary_get_value(object, "_serviceBundles")) != 0
    && (xpc_object_t v10 = v9, xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
    && xpc_array_get_count(v10))
  {
    xpc_object_t v7 = xpc_array_create(0, 0);
    if (xpc_array_get_count(v10))
    {
      size_t v11 = 0;
      do
      {
        xpc_object_t value = xpc_array_get_value(v10, v11);
        if (value)
        {
          stat v13 = value;
          if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
          {
            xpc_object_t v14 = (void *)sub_100019F78(v13);
            if (v14)
            {
              uint64_t v15 = v14;
              xpc_array_append_value(v7, v14);
              xpc_release(v15);
            }
          }
        }
        ++v11;
      }
      while (v11 < xpc_array_get_count(v10));
    }
  }
  else
  {
    xpc_object_t v6 = (xpc_object_t)qword_100075D00;
    if (!qword_100075D00)
    {
      xpc_object_t v6 = xpc_array_create(0, 0);
      qword_100075D00 = (uint64_t)v6;
    }
    if (xpc_array_get_count(v6)) {
      sub_100050F24();
    }
    xpc_object_t v7 = xpc_retain((xpc_object_t)qword_100075D00);
  }
  if (v7)
  {
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, v7);
    xpc_release(v7);
  }
  return 1;
}

uint64_t sub_100019F78(void *a1)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "_infoPlist");
  if (!value
    || xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary
    || !xpc_dictionary_get_string(a1, "_executablePath"))
  {
    return 0;
  }
  uint64_t v3 = xpc_bundle_create_from_origin();
  xpc_bundle_populate();
  return v3;
}

uint64_t sub_100019FFC(uint64_t a1, const char *a2, void *a3)
{
  char v5 = (void *)sub_100019F78(a3);
  if (v5)
  {
    xpc_object_t v6 = v5;
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, v5);
    xpc_release(v6);
  }
  return 1;
}

void *sub_10001A054(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  xpc_object_t v7 = sub_100013BB8(0x18uLL);
  *xpc_object_t v7 = a1;
  v7[1] = a3;
  v7[2] = a4;
  if (a1)
  {
    sub_10001A5A4((uint64_t)a1);
    id v8 = a1;
  }
  return v7;
}

void *sub_10001A0AC(void *a1)
{
  sub_10001A5A4((uint64_t)a1);
  id v2 = a1;
  return a1;
}

void *sub_10001A0D8(void *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v6 = sub_100013BB8(0x18uLL);
  *xpc_object_t v6 = a1;
  v6[1] = a2;
  v6[2] = a3;
  if (a1) {
    xpc_retain(a1);
  }
  return v6;
}

void sub_10001A12C(uint64_t *a1)
{
  id v2 = (void *)*a1;
  if (*a1)
  {
    sub_10001A5A4(*a1);
  }

  free(a1);
}

void sub_10001A174(void *a1)
{
  sub_10001A5A4((uint64_t)a1);
}

void sub_10001A1AC(void **a1)
{
  id v2 = *a1;
  if (v2) {
    xpc_release(v2);
  }

  free(a1);
}

char *sub_10001A1EC(char *__s, const char *a2, uint64_t a3, size_t *a4, char a5)
{
  if ((a5 & 1) == 0)
  {
    uint64_t v9 = 0;
    while (strcmp(__s, off_100070418[v9]))
    {
      if (++v9 == 2) {
        goto LABEL_5;
      }
    }
    return 0;
  }
LABEL_5:
  size_t v10 = strlen(__s);
  size_t v11 = v10 + 1;
  BOOL v12 = v10 == -1;
  xpc_object_t result = (char *)strlen(a2);
  xpc_object_t v14 = &result[v11];
  BOOL v15 = __CFADD__(result, v11);
  size_t v16 = (size_t)(v14 + 1);
  uint64_t v17 = v14 == (char *)-1;
  uint64_t v18 = v17 << 63 >> 63;
  BOOL v19 = v18 != v17;
  if (!v12 && !v15 && !v19 && (v18 & 0x8000000000000000) == 0)
  {
    xpc_object_t result = (char *)(v16 + 32);
    if (v16 < 0xFFFFFFFFFFFFFFE0)
    {
      uint64_t v20 = sub_100013BB8((size_t)result);
      *((void *)v20 + 3) = a3;
      snprintf((char *)v20 + 32, v16, "%s=%s", __s, a2);
      *a4 = v16;
      return (char *)v20;
    }
  }
  __break(1u);
  return result;
}

size_t sub_10001A2E4(uint64_t a1, size_t *a2)
{
  uint64_t v3 = (const char *)(a1 + 32);
  size_t v4 = strlen((const char *)(a1 + 32));
  size_t v5 = v4 + 1;
  BOOL v6 = __CFADD__(v4 + 1, 32);
  size_t result = v4 + 33;
  if (v6)
  {
    __break(1u);
  }
  else
  {
    id v8 = (char *)sub_100013BB8(result);
    snprintf(v8 + 32, v5, "%s", v3);
    *a2 = v5;
    return (size_t)v8;
  }
  return result;
}

uint64_t sub_10001A358(uint64_t a1, uint64_t a2, FILE *a3)
{
  uint64_t v5 = a1 + 32;
  BOOL v6 = strrchr((char *)(a1 + 32), 61);
  *BOOL v6 = 0;
  uint64_t result = sub_100046780(a3, a2, "%s => %s", v7, v8, v9, v10, v11, v5, v6 + 1);
  *BOOL v6 = 61;
  return result;
}

char *sub_10001A3D0(uint64_t a1, const char *a2)
{
  uint64_t v3 = (const char *)(a1 + 32);
  uint64_t result = strchr((char *)(a1 + 32), 61);
  if (result)
  {
    uint64_t v5 = result;
    *uint64_t result = 0;
    uint64_t result = (char *)(strcmp(v3, a2) == 0);
    *uint64_t v5 = 61;
  }
  return result;
}

char *sub_10001A430(uint64_t a1)
{
  uint64_t v1 = strchr((char *)(a1 + 32), 61);
  if (v1) {
    return v1 + 1;
  }
  else {
    return 0;
  }
}

BOOL sub_10001A45C(const char *a1)
{
  if (!strcmp(a1, "LD_LIBRARY_PATH")) {
    return 1;
  }
  BOOL result = sub_100015CAC(a1, "DYLD_");
  if (!result) {
    return result;
  }
  if (!sub_100015CAC(a1, "DYLD_PRINT_")) {
    return 1;
  }
  uint64_t v3 = 0;
  do
  {
    int v4 = strcmp(a1, (&off_100070430)[v3]);
    BOOL result = v4 != 0;
    if (!v4) {
      break;
    }
  }
  while (v3++ != 10);
  return result;
}

_DWORD *sub_10001A4FC(mach_port_name_t a1, int a2)
{
  int v4 = sub_100013BB8(0x18uLL);
  if (sub_10000D65C(a1)) {
    _os_assumes_log();
  }
  v4[4] = a1;
  v4[5] = a2;
  return v4;
}

void sub_10001A554(mach_port_name_t *a1)
{
  if (sub_10000D678(a1[4])) {
    _os_assumes_log();
  }

  free(a1);
}

uint64_t sub_10001A5A4(uint64_t result)
{
  if (*(unsigned char *)(result + 8)) {
    sub_100050D0C();
  }
  return result;
}

uint64_t sub_10001A5C4(uint64_t a1)
{
  return a1;
}

uint64_t sub_10001A5F0(uint64_t result)
{
  if (*(unsigned char *)(result + 8)) {
    sub_100050D0C();
  }
  *(unsigned char *)(result + 8) = 1;
  return result;
}

id sub_10001A618(uint64_t a1)
{
  size_t v1 = a1 + 32;
  id v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001A658(uint64_t a1)
{
  size_t v1 = a1 + 24;
  id v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001A698(uint64_t a1)
{
  size_t v1 = a1 + 1016;
  id v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001A6D8(uint64_t a1)
{
  size_t v1 = a1 + 136;
  id v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001A718(uint64_t a1)
{
  size_t v1 = a1 + 96;
  id v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

char *sub_10001A758(const char *a1)
{
  size_t v2 = strlen(a1) + 161;
  uint64_t v3 = (objc_class *)objc_opt_class();
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 168, a1);
  return Instance;
}

id sub_10001A7A8(uint64_t a1)
{
  size_t v1 = a1 + 56;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001A7E8(uint64_t a1)
{
  size_t v1 = a1 + 80;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

char *sub_10001A828(const char *a1)
{
  size_t v2 = strlen(a1) + 33;
  uint64_t v3 = (objc_class *)objc_opt_class();
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 40, a1);
  return Instance;
}

id sub_10001A878(uint64_t a1)
{
  size_t v1 = a1 + 80;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001A8B8(uint64_t a1)
{
  size_t v1 = a1 + 264;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

uint64_t sub_10001A8F8()
{
  return objc_opt_class();
}

id sub_10001A904(uint64_t a1)
{
  size_t v1 = a1 + 80;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

char *sub_10001A944(const char *a1)
{
  size_t v2 = strlen(a1) + 1385;
  uint64_t v3 = (objc_class *)objc_opt_class();
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 1392, a1);
  return Instance;
}

id sub_10001A994(uint64_t a1)
{
  size_t v1 = a1 + 56;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

char *sub_10001A9D4(const char *a1)
{
  size_t v2 = strlen(a1) + 201;
  uint64_t v3 = (objc_class *)objc_opt_class();
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 208, a1);
  return Instance;
}

id sub_10001AA24(uint64_t a1)
{
  size_t v1 = a1 + 40;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001AA64(uint64_t a1)
{
  size_t v1 = a1 + 24;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001AAA4(uint64_t a1)
{
  size_t v1 = a1 + 64;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

id sub_10001AAE4(uint64_t a1)
{
  size_t v1 = a1 + 16;
  size_t v2 = (objc_class *)objc_opt_class();

  return class_createInstance(v2, v1);
}

char *sub_10001AB24(const char *a1)
{
  size_t v2 = strlen(a1) + 33;
  uint64_t v3 = (objc_class *)objc_opt_class();
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 40, a1);
  return Instance;
}

char *sub_10001AB74(const char *a1)
{
  size_t v2 = strlen(a1) + 25;
  uint64_t v3 = (objc_class *)objc_opt_class();
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 32, a1);
  return Instance;
}

uint64_t sub_10001ABC4(uid_t a1, _DWORD *a2)
{
  int v4 = sub_10003B570();
  if (v4 && v4 == a1)
  {
    uint64_t v5 = sub_10001AC38(0x1F5u, (uint64_t)a2);
    sub_10001AC9C(a2);
    return v5;
  }
  else
  {
    return sub_10001AC38(a1, (uint64_t)a2);
  }
}

uint64_t sub_10001AC38(uid_t a1, uint64_t a2)
{
  int v4 = 0;
  uint64_t result = getpwuid_r(a1, (passwd *)a2, (char *)(a2 + 72), 0x1000uLL, &v4);
  if (!result)
  {
    if (v4)
    {
      sub_10001AE58(*(const char **)a2, *(_DWORD *)(a2 + 20), a2);
      return 0;
    }
    else
    {
      return 114;
    }
  }
  return result;
}

uint64_t sub_10001AC9C(_DWORD *a1)
{
  uint64_t result = sub_10003B570();
  if (result)
  {
    if (a1[4] == 501) {
      a1[4] = result;
    }
    if (a1[5] == 501) {
      a1[5] = result;
    }
    int v3 = a1[1058];
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = a1 + 1042;
      do
      {
        if (v5[v4] == 501)
        {
          v5[v4] = result;
          int v3 = a1[1058];
        }
        ++v4;
      }
      while (v4 < v3);
    }
  }
  return result;
}

uint64_t sub_10001AD1C()
{
  BOOL v0 = (const char *)__chkstk_darwin();
  size_t v2 = (_DWORD *)v1;
  uint64_t v4 = v3;
  uint64_t v5 = v0;
  if (v0)
  {
    v11[0] = 0;
    uint64_t result = getpwnam_r(v0, (passwd *)v1, (char *)(v1 + 72), 0x1000uLL, v11);
    if (result) {
      return result;
    }
    if (!v11[0]) {
      return 114;
    }
    gid_t gr_gid = v2[5];
    if (!v4) {
      goto LABEL_10;
    }
  }
  else
  {
    gid_t gr_gid = -101;
    if (!v4) {
      goto LABEL_10;
    }
  }
  bzero(v11, 0x1000uLL);
  memset(&v10, 0, sizeof(v10));
  uint64_t v9 = 0;
  uint64_t result = getgrnam_r(v4, &v10, (char *)v11, 0x1000uLL, &v9);
  if (result) {
    return result;
  }
  if (!v9) {
    return 115;
  }
  gid_t gr_gid = v10.gr_gid;
LABEL_10:
  if (gr_gid != -101)
  {
    if (v5) {
      uint64_t v8 = v5;
    }
    else {
      uint64_t v8 = "root";
    }
    sub_10001AE58(v8, gr_gid, (uint64_t)v2);
  }
  sub_10001AC9C(v2);
  return 0;
}

uint64_t sub_10001AE58(const char *a1, int a2, uint64_t a3)
{
  *(_DWORD *)(a3 + 4232) = 16;
  uint64_t result = getgrouplist(a1, a2, (int *)(a3 + 4168), (int *)(a3 + 4232));
  if (result == -1) {
    return sub_100050E38();
  }
  return result;
}

uint64_t sub_10001AE98(uint64_t a1, const char *a2, int a3, uint64_t a4)
{
  if (os_map_str_find()) {
    return 17;
  }
  uint64_t v8 = sub_100013BB8(0x18uLL);
  *(void *)uint64_t v8 = sub_1000159F0(a2);
  v8[2] = a3;
  *((void *)v8 + 2) = a4;
  os_map_str_insert();
  return 0;
}

uint64_t sub_10001AF18(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = os_map_str_delete();
  if (!v4) {
    return 0;
  }
  uint64_t v5 = (void *)v4;
  uint64_t v6 = *(unsigned int *)(v4 + 8);
  *a3 = *(void *)(v4 + 16);
  free(*(void **)v4);
  free(v5);
  return v6;
}

void sub_10001AF74(void *a1)
{
  os_map_str_clear();
  os_map_str_destroy();

  free(a1);
}

BOOL sub_10001AFBC(id a1, const char *a2, void *a3)
{
  if (sub_10000D68C(*((_DWORD *)a3 + 2), 0, *((void *)a3 + 2))) {
    sub_100050D28();
  }
  free(*(void **)a3);
  free(a3);
  return 1;
}

uint64_t sub_10001B008(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a2 + 24);
  unint64_t v4 = *(void *)(a3 + 24);
  BOOL v5 = v3 >= v4;
  BOOL v6 = v3 > v4;
  if (v5) {
    return v6;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t sub_10001B020(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(a2 + 24);
  BOOL v4 = v3 >= *a3;
  BOOL v5 = v3 > *a3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void sub_10001B038(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v8 = a2;
  if (*(_DWORD *)(a1 + 24) == 4982)
  {
    node = (void **)rb_tree_find_node(*(rb_tree_t **)(a1 + 16), &v8);
    if (node)
    {
      BOOL v6 = node;
      rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), node);
      os_release(v6[4]);
      free(v6);
    }
    if (a3)
    {
      uint64_t v7 = malloc_type_malloc(0x28uLL, 0x108004034BCA2CCuLL);
      void v7[3] = v8;
      v7[4] = os_retain(a3);
      if (rb_tree_insert_node(*(rb_tree_t **)(a1 + 16), v7) != v7) {
        sub_100050D0C();
      }
    }
  }
  else
  {
    __break(1u);
  }
}

rb_tree_t **sub_10001B100(rb_tree_t **result, uint64_t a2)
{
  uint64_t v2 = a2;
  if (*((_DWORD *)result + 6) == 4982)
  {
    uint64_t result = (rb_tree_t **)rb_tree_find_node(result[2], &v2);
    if (result) {
      return (rb_tree_t **)result[4];
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

rb_tree_t **sub_10001B148(rb_tree_t **result, uint64_t a2)
{
  if (*((_DWORD *)result + 6) == 4982)
  {
    unint64_t v3 = result;
    uint64_t result = (rb_tree_t **)rb_tree_iterate(result[2], 0, 1u);
    if (result)
    {
      BOOL v4 = result;
      do
      {
        (*(void (**)(uint64_t, rb_tree_t *, rb_tree_t *))(a2 + 16))(a2, v4[3], v4[4]);
        uint64_t result = (rb_tree_t **)rb_tree_iterate(v3[2], v4, 1u);
        BOOL v4 = result;
      }
      while (result);
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

size_t sub_10001B1CC(size_t result)
{
  if (*(_DWORD *)(result + 24) == 4982) {
    return rb_tree_count(*(rb_tree_t **)(result + 16));
  }
  __break(1u);
  return result;
}

void *sub_10001B1E8()
{
  BOOL v0 = sub_10001AA64(0);
  uint64_t v1 = (rb_tree_t *)malloc_type_malloc(0x40uLL, 0x80040A284212CuLL);
  v0[2] = v1;
  rb_tree_init(v1, (const rb_tree_ops_t *)off_100075570);
  *((_DWORD *)v0 + 6) = 4982;
  return v0;
}

void sub_10001B244(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) == 4982)
  {
    *(_DWORD *)(a1 + 24) = 0;
    uint64_t v2 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), 0, 1u);
    if (v2)
    {
      unint64_t v3 = v2;
      do
      {
        BOOL v4 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), v3, 1u);
        rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), v3);
        os_release(v3[4]);
        free(v3);
        unint64_t v3 = v4;
      }
      while (v4);
    }
    BOOL v5 = *(void **)(a1 + 16);
    free(v5);
  }
  else
  {
    __break(1u);
  }
}

void sub_10001B2E8(uint64_t a1)
{
  if (qword_100075D08 == a1) {
    qword_100075D08 = 0;
  }
  unint64_t v2 = *(void *)(a1 + 88);
  if (v2)
  {
    unint64_t v3 = 0;
    int v4 = dword_100075A30;
    do
    {
      BOOL v5 = (int *)*(unsigned int *)(*(void *)(a1 + 64) + 4 * v3);
      if ((v5 & 0x80000000) == 0 && v5 != v4)
      {
        sub_10003E54C(v5);
        int v4 = dword_100075A30;
        unint64_t v2 = *(void *)(a1 + 88);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(void *)(a1 + 32) != -1 || *(void *)(a1 + 40) != -1) {
    sub_100040E80("socket deallocated while still in domain list");
  }
  if (*(void *)(a1 + 16) != -1 || *(void *)(a1 + 24) != -1) {
    sub_100040E80("socket deallocated while still in service list");
  }
  if ((*(_WORD *)(a1 + 204) & 0x84) == 4) {
    sub_100040E80("socket deallocated while still active");
  }
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 144));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  BOOL v6 = *(void **)(a1 + 192);

  xpc_release(v6);
}

uint64_t sub_10001B41C(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

void sub_10001B454(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  BOOL v12 = sub_10001B4BC(a1);
  sub_100044138(v12, a2, a3, &a9, v9);
  free(v12);
}

char *sub_10001B4BC(uint64_t a1)
{
  uint64_t v8 = (const char **)sub_100010724(0x40uLL);
  uint64_t v9 = *(void *)(a1 + 56);
  if (v9)
  {
    group v10 = sub_1000203FC(v9, 1);
    sub_1000107B4((uint64_t)v8, "%s - ", v11, v12, v13, v14, v15, v16, (char)v10);
    free(v10);
  }
  sub_1000107B4((uint64_t)v8, "%s", v2, v3, v4, v5, v6, v7, a1 - 48);
  uint64_t v17 = sub_100010770(v8);
  sub_100010778((void **)v8);
  return v17;
}

char *sub_10001B558(uint64_t a1, uint64_t a2, const char *a3, int a4, void *a5, NSObject *a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v16 = sub_10001A9D4(a3);
  *((void *)v16 + 7) = a1;
  *((_DWORD *)v16 + 24) = -1;
  *((_DWORD *)v16 + 26) = a4;
  dispatch_retain(a6);
  *((void *)v16 + 14) = a6;
  *((void *)v16 + 15) = a7;
  *((void *)v16 + 16) = a8;
  *((void *)v16 + 24) = xpc_retain(a5);
  *((_WORD *)v16 + 102) |= 2u;
  *(void *)&long long v17 = -1;
  *((void *)&v17 + 1) = -1;
  *((_OWORD *)v16 + 1) = v17;
  *((_OWORD *)v16 + 2) = v17;
  uint64_t v18 = sub_100022178(a1);
  int v19 = *(_DWORD *)(v18 + 20);
  if (v19)
  {
    uint64_t v20 = v18;
    if (v19 != getpid())
    {
      int v21 = *(_DWORD *)(v20 + 8);
      if (v21) {
        *((_DWORD *)v16 + 27) = v21;
      }
    }
  }
  string = xpc_dictionary_get_string(a5, "SockPathName");
  if (string && !strcmp(string, "/var/run/syslog")) {
    xpc_dictionary_set_BOOL(a5, "SystemLoggingSocket", 1);
  }
  *((_DWORD *)v16 + 25) = 1;
  long long v23 = sub_10001A054(v16, 1, a9, 0);
  xpc_dictionary_apply_f();
  sub_10001A12C(v23);
  if (!*((_DWORD *)v16 + 50) && (_UNKNOWN *)sub_1000301F4(a2) != &unk_1000755B8 && *((_DWORD *)v16 + 26) != a4)
  {
    sub_10001B454((uint64_t)v16, 3, "Not allowed to set SockPathOwner to UID %d. Remove key.", v25, v26, v27, v28, v29, *((_DWORD *)v16 + 26));
    *((_DWORD *)v16 + 50) = 1;
  }
  return v16;
}

void sub_10001B704(const char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = (unsigned char *)a3[1];
  xpc_type_t type = xpc_get_type(object);
  if (!strcasecmp(a1, "SockType"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    if (!strcasecmp(string_ptr, "stream"))
    {
      int v12 = 1;
    }
    else if (!strcasecmp(string_ptr, "dgram"))
    {
      int v12 = 2;
    }
    else
    {
      if (strcasecmp(string_ptr, "seqpacket"))
      {
        sub_100014CD8(v5, 3, "Unrecognized %s");
        goto LABEL_65;
      }
      int v12 = 5;
    }
    *(_DWORD *)(v6 + 100) = v12;
    return;
  }
  if (!strcasecmp(a1, "SockPassive"))
  {
    if (type == (xpc_type_t)&_xpc_type_BOOL)
    {
      if (xpc_BOOL_get_value(object)) {
        __int16 v9 = 2;
      }
      else {
        __int16 v9 = 0;
      }
      __int16 v10 = *(_WORD *)(v6 + 204) & 0xFFFD;
LABEL_27:
      __int16 v11 = v10 | v9;
LABEL_28:
      *(_WORD *)(v6 + 204) = v11;
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SecureSocketWithKey"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    if (!*(void *)(v6 + 144))
    {
      uint64_t v13 = xpc_string_get_string_ptr(object);
      *(void *)(v6 + 136) = sub_1000159F0(v13);
      return;
    }
    goto LABEL_34;
  }
  if (!strcasecmp(a1, "SockPathName"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    if (*(void *)(v6 + 136))
    {
LABEL_34:
      sub_100014CD8(v5, 3, "Can't have both %s and %s");
      goto LABEL_65;
    }
    if (xpc_string_get_length(object) >= 0x68)
    {
      sub_100014CD8(v5, 3, "%s value is too long.", a1);
      int v15 = 34;
LABEL_66:
      *(_DWORD *)(v6 + 200) = v15;
      return;
    }
    long long v17 = xpc_string_get_string_ptr(object);
    if (v17)
    {
      *(void *)(v6 + 144) = sub_1000159F0(v17);
      return;
    }
LABEL_65:
    int v15 = 22;
    goto LABEL_66;
  }
  if (!strcasecmp(a1, "SockPathOwner"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_DWORD *)(v6 + 104) = xpc_int64_get_value(object);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockPathGroup"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_DWORD *)(v6 + 108) = xpc_int64_get_value(object);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockPathMode"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_WORD *)(v6 + 152) = xpc_int64_get_value(object);
      __int16 v11 = *(_WORD *)(v6 + 204) | 8;
      goto LABEL_28;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockNodeName"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v14 = xpc_string_get_string_ptr(object);
      *(void *)(v6 + 160) = sub_1000159F0(v14);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "MulticastGroup"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v16 = xpc_string_get_string_ptr(object);
      *(void *)(v6 + 168) = sub_1000159F0(v16);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockServiceName"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      xpc_object_t v22 = xpc_string_get_string_ptr(object);
      int v19 = sub_1000159F0(v22);
    }
    else
    {
      if (type != (xpc_type_t)&_xpc_type_int64) {
        goto LABEL_64;
      }
      int64_t value = xpc_int64_get_value(object);
      int v19 = sub_100015BE4("%lld", value);
    }
    *(void *)(v6 + 176) = v19;
    return;
  }
  if (!strcasecmp(a1, "SockFamily"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v20 = xpc_string_get_string_ptr(object);
      if (!strcasecmp(v20, "IPv4"))
      {
        int v21 = 2;
      }
      else if (!strcasecmp(v20, "IPv6"))
      {
        int v21 = 30;
      }
      else
      {
        if (!strcasecmp(v20, "IPv4v6"))
        {
          *(_DWORD *)(v6 + 184) = 30;
          __int16 v11 = *(_WORD *)(v6 + 204) | 0x20;
          goto LABEL_28;
        }
        if (strcasecmp(v20, "Unix")) {
          goto LABEL_79;
        }
        int v21 = 1;
      }
      *(_DWORD *)(v6 + 184) = v21;
      return;
    }
LABEL_64:
    xpc_type_get_name(type);
    sub_100014CD8(v5, 3, "Invalid type for socket dictionary (key/type): %s/%s");
    goto LABEL_65;
  }
  if (!strcasecmp(a1, "SockProtocol"))
  {
    if (type != (xpc_type_t)&_xpc_type_string) {
      goto LABEL_64;
    }
    long long v23 = xpc_string_get_string_ptr(object);
    if (!strcasecmp(v23, "TCP"))
    {
      int v24 = 6;
    }
    else
    {
      if (strcasecmp(v23, "UDP"))
      {
LABEL_79:
        sub_100014CD8(v5, 4, "Unrecognized %s");
        return;
      }
      int v24 = 17;
    }
    *(_DWORD *)(v6 + 188) = v24;
    return;
  }
  if (strcasecmp(a1, "Bonjour"))
  {
    if (!strcasecmp(a1, "SystemLoggingSocket"))
    {
      if (xpc_BOOL_get_value(object)) {
        __int16 v9 = 64;
      }
      else {
        __int16 v9 = 0;
      }
      __int16 v10 = *(_WORD *)(v6 + 204) & 0xFFBF;
    }
    else
    {
      if (strcasecmp(a1, "ReceivePacketInfo"))
      {
        sub_100014CD8(v5, 4, "Unknown socket key %s");
        return;
      }
      if (xpc_BOOL_get_value(object)) {
        __int16 v9 = 512;
      }
      else {
        __int16 v9 = 0;
      }
      __int16 v10 = *(_WORD *)(v6 + 204) & 0xFDFF;
    }
    goto LABEL_27;
  }
  if (type != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(object))
  {
    __int16 v11 = *(_WORD *)(v6 + 204) | 0x10;
    goto LABEL_28;
  }
}

void sub_10001BC98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 204) & 0x40) != 0)
  {
    if (qword_100075D08)
    {
      sub_10001B454(a1, 3, "System logger socket is already claimed by: %s", a4, a5, a6, a7, a8, qword_100075D08 - 48);
      *(_DWORD *)(a1 + 200) = 37;
      __int16 v10 = (void *)a1;
      int v11 = 1;
    }
    else
    {
      qword_100075D08 = a1;
      *(void *)(a1 + 64) = sub_100013BB8(4uLL);
      *(void *)(a1 + 72) = sub_100013BB8(1uLL);
      *(void *)(a1 + 88) = 1;
      long long v17 = *(_DWORD **)(a1 + 64);
      *long long v17 = dword_100075A30;
      *(_DWORD *)(a1 + 100) = 2;
      *(_WORD *)(a1 + 204) |= 4u;
      if (*v17 == -1) {
        sub_10001B454(a1, 4, "System logger socket was not opened during early boot. (Proceeding anyway)", v12, v13, v14, v15, v16, v18);
      }
      __int16 v10 = (void *)a1;
      int v11 = 0;
    }
    sub_10001BDD4(v10, v11);
  }
  else
  {
    sub_10001A0AC((void *)a1);
    __int16 v9 = sub_100014B64();
    dispatch_async_f(v9, (void *)a1, (dispatch_function_t)sub_10001BE50);
  }
}

void sub_10001BDD4(void *a1, int a2)
{
  uint64_t v4 = sub_100013BB8(0x10uLL);
  *(void *)uint64_t v4 = sub_10001A0AC(a1);
  v4[2] = a2;
  uint64_t v5 = a1[14];

  dispatch_async_f(v5, v4, (dispatch_function_t)sub_10001D554);
}

void sub_10001BE50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 136);
  if (v9 || *(void *)(a1 + 144))
  {
    if (!byte_1000769D8)
    {
      sub_1000442C4("fixup-mobile-tmp", 196611, "launchd has not fixed mobile/tmp (socket)", a4, a5, a6, a7, a8, v150);
      uint64_t v9 = *(void *)(a1 + 136);
    }
    bzero(v160, 0x400uLL);
    if (v9)
    {
      __strlcpy_chk();
      if (!mkdtemp(v160) && *__error()) {
        _os_assumes_log_ctx();
      }
      __int16 v10 = sub_100015BE4("%s/%s", v160, (const char *)(a1 + 208));
      *(void *)(a1 + 144) = v10;
    }
    else
    {
      __int16 v10 = *(char **)(a1 + 144);
    }
    memset(&v172, 0, 106);
    BYTE1(v172.st_dev) = 1;
    strncpy((char *)&v172.st_dev + 2, v10, 0x67uLL);
    *(void *)(a1 + 64) = sub_100013BB8(4uLL);
    *(void *)(a1 + 72) = sub_100013BB8(1uLL);
    *(void *)(a1 + 88) = 1;
    int v11 = socket(1, *(_DWORD *)(a1 + 100), 0);
    **(_DWORD **)(a1 + 64) = v11;
    if (v11 == -1) {
      goto LABEL_129;
    }
    if ((*(_WORD *)(a1 + 204) & 2) == 0)
    {
      int v12 = connect(v11, (const sockaddr *)&v172, 0x6Au);
      goto LABEL_14;
    }
    uint64_t v14 = *(const char **)(a1 + 144);
    if (!v14) {
      sub_100050D0C();
    }
    memset(&v173, 0, sizeof(v173));
    if (stat(v14, &v173))
    {
      if (*__error() != 2)
      {
        int v13 = *__error();
        uint64_t v20 = *(void *)(a1 + 144);
        xpc_strerror();
        sub_10001B454(a1, 3, "Failed to stat() old socket path: path=%s, error=%s (%d)", v21, v22, v23, v24, v25, v20);
        if (v13) {
          goto LABEL_139;
        }
LABEL_25:
        if (bind(**(_DWORD **)(a1 + 64), (const sockaddr *)&v172, 0x6Au))
        {
          __error();
          char v32 = xpc_strerror();
          __error();
          sub_10001B454(a1, 3, "Failed to bind() a socket: error=%s (%d)", v33, v34, v35, v36, v37, v32);
          int v13 = *__error();
          if (v13) {
            goto LABEL_139;
          }
        }
        bzero(&v173, 0x400uLL);
        if (dirname_r(*(const char **)(a1 + 144), (char *)&v173))
        {
          uint64_t v38 = (int *)open((const char *)&v173, 0x100000);
          if ((v38 & 0x80000000) == 0)
          {
            uint64_t v39 = v38;
            bzero(&v173, 0x400uLL);
            if (basename_r(*(const char **)(a1 + 144), (char *)&v173))
            {
              uid_t v40 = *(_DWORD *)(a1 + 104);
              if (*(_DWORD *)(a1 + 108)) {
                gid_t v41 = *(_DWORD *)(a1 + 108);
              }
              else {
                gid_t v41 = v40 == 0;
              }
              if (fchownat((int)v39, (const char *)&v173, v40, v41, 32))
              {
                long long v42 = "Failed to fchown() a socket: error=%s (%d)";
              }
              else
              {
                if (!*(void *)(a1 + 136) || (uid_t v136 = *(_DWORD *)(a1 + 104)) == 0 || !chown(v160, v136, 0))
                {
LABEL_146:
                  if ((*(_WORD *)(a1 + 204) & 8) != 0) {
                    mode_t v137 = *(_WORD *)(a1 + 152);
                  }
                  else {
                    mode_t v137 = 438;
                  }
                  if (fchmodat((int)v39, (const char *)&v173, v137, 32))
                  {
                    __error();
                    char v138 = xpc_strerror();
                    __error();
                    sub_10001B454(a1, 3, "Failed to fchmodat() a socket: error=%s (%d)", v139, v140, v141, v142, v143, v138);
                    int v13 = *__error();
                    sub_10003E54C(v39);
                    if (v13) {
                      goto LABEL_139;
                    }
                  }
                  else
                  {
                    sub_10003E54C(v39);
                  }
                  if ((*(_DWORD *)(a1 + 100) | 4) != 5) {
                    goto LABEL_15;
                  }
                  int v12 = listen(**(_DWORD **)(a1 + 64), -1);
LABEL_14:
                  if (v12 != -1)
                  {
LABEL_15:
                    int v13 = 0;
LABEL_139:
                    *(_DWORD *)(a1 + 200) = v13;
LABEL_140:
                    *(_WORD *)(a1 + 204) |= 4u;
                    sub_10001BDD4((void *)a1, v13 != 0);
                    sub_10001A174((void *)a1);
                    return;
                  }
LABEL_129:
                  __error();
                  _os_assumes_log_ctx();
                  int v13 = *__error();
                  goto LABEL_139;
                }
                long long v42 = "Failed to chown() secure socket directory: error=%s (%d)";
              }
              __error();
              char v43 = xpc_strerror();
              __error();
              sub_10001B454(a1, 3, v42, v44, v45, v46, v47, v48, v43);
              int v13 = *__error();
              if (v13)
              {
                sub_10003E54C(v39);
                goto LABEL_139;
              }
              goto LABEL_146;
            }
            __error();
            char v130 = xpc_strerror();
            __error();
            sub_10001B454(a1, 3, "Failed to basename_r() a socket path: error=%s (%d)", v131, v132, v133, v134, v135, v130);
LABEL_138:
            int v13 = 108;
            goto LABEL_139;
          }
          uint64_t v123 = "Failed to open() socket directory: error=%s (%d)";
        }
        else
        {
          uint64_t v123 = "Failed to dirname_r() a socket path: error=%s (%d)";
        }
        __error();
        char v124 = xpc_strerror();
        __error();
        sub_10001B454(a1, 3, v123, v125, v126, v127, v128, v129, v124);
        goto LABEL_138;
      }
    }
    else if (*(_DWORD *)(a1 + 104) != v173.st_uid)
    {
      sub_10001B454(a1, 3, "Cannot remove old socket path; UIDs mismatch: socket = %d, path = %d",
        v15,
        v16,
        v17,
        v18,
        v19,
        *(_DWORD *)(a1 + 104));
      int v13 = 122;
      goto LABEL_139;
    }
    if (unlink(*(const char **)(a1 + 144)))
    {
      if (*__error() != 2)
      {
        __error();
        char v26 = xpc_strerror();
        __error();
        sub_10001B454(a1, 3, "Failed to remove old socket: error=%s (%d)", v27, v28, v29, v30, v31, v26);
        int v13 = *__error();
        if (v13) {
          goto LABEL_139;
        }
      }
    }
    goto LABEL_25;
  }
  memset(&v158, 0, sizeof(v158));
  int v49 = *(_DWORD *)(a1 + 100);
  int v50 = *(_DWORD *)(a1 + 188);
  v158.int ai_family = *(_DWORD *)(a1 + 184);
  v158.ai_sockxpc_type_t type = v49;
  v158.uint64_t ai_protocol = v50;
  if ((*(unsigned char *)(a1 + 204) & 2) != 0) {
    v158.ai_flags = 1;
  }
  v157 = 0;
  int v51 = getaddrinfo(*(const char **)(a1 + 160), *(const char **)(a1 + 176), &v158, &v157);
  if (v51)
  {
    int v144 = v51;
    _os_assumes_log_ctx();
    gai_strerror(v144);
    sub_10001B454(a1, 3, "getaddrinfo(3): %d: %s", v145, v146, v147, v148, v149, v144);
    int v13 = sub_10001D610(v144);
    *(_DWORD *)(a1 + 200) = v13;
    if (v13) {
      goto LABEL_140;
    }
LABEL_132:
    if ((*(_WORD *)(a1 + 204) & 0x10) != 0)
    {
      sub_10001A0AC((void *)a1);
      unsigned int v122 = sub_100014B58();
      dispatch_async_f(v122, (void *)a1, (dispatch_function_t)sub_10001D5B0);
      int v13 = *(_DWORD *)(a1 + 200);
    }
    else
    {
      int v13 = 0;
    }
    goto LABEL_140;
  }
  uint64_t v52 = v157;
  unint64_t v53 = *(void *)(a1 + 88);
  if (v157)
  {
    do
    {
      ++v53;
      uint64_t v52 = v52->ai_next;
    }
    while (v52);
    *(void *)(a1 + 88) = v53;
  }
  if (!(v53 >> 62))
  {
    *(void *)(a1 + 64) = sub_100013BB8(4 * v53);
    *(void *)(a1 + 72) = sub_100013BB8(*(void *)(a1 + 88));
    uint64_t v54 = v157;
    if (!v157)
    {
      size_t v121 = 0;
      goto LABEL_131;
    }
    uint64_t v55 = 0;
    while (1)
    {
      int v56 = socket(v54->ai_family, v54->ai_socktype, v54->ai_protocol);
      uint64_t v57 = *(void *)(a1 + 64);
      *(_DWORD *)(v57 + 4 * v55) = v56;
      if (v56 == -1)
      {
        __error();
        _os_assumes_log_ctx();
        uint64_t ai_protocol = v54->ai_protocol;
        uint64_t v154 = v55;
        ai_sockxpc_type_t type = (const char *)v54->ai_socktype;
        sub_10001B454(a1, 3, "Could not create socket for resolved listener (family = %d, xpc_type_t type = %d, protocol = %d, idx = %lu: ", v63, v64, v65, v66, v67, v54->ai_family);
        goto LABEL_126;
      }
      int v156 = 1;
      __int16 v58 = *(_WORD *)(a1 + 204);
      if ((v58 & 2) == 0)
      {
        int v59 = connect(*(_DWORD *)(v57 + 4 * v55), v54->ai_addr, v54->ai_addrlen);
        if (!v59) {
          goto LABEL_102;
        }
        if (v59 == -1) {
          goto LABEL_101;
        }
        goto LABEL_126;
      }
      int ai_family = v54->ai_family;
      if (ai_family == 2)
      {
        if ((v58 & 0x20) != 0)
        {
          sub_10003E54C((int *)*(unsigned int *)(v57 + 4 * v55));
          *(_DWORD *)(*(void *)(a1 + 64) + 4 * v55) = -1;
          goto LABEL_126;
        }
        if ((*(_WORD *)(a1 + 204) & 0x200) != 0)
        {
          int v62 = setsockopt(*(_DWORD *)(v57 + 4 * v55), 0, 20, &v156, 4u);
          if (v62)
          {
            if (v62 == -1) {
              goto LABEL_101;
            }
            goto LABEL_126;
          }
          int v69 = setsockopt(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v55), 0, 7, &v156, 4u);
          if (v69)
          {
            if (v69 == -1) {
              goto LABEL_101;
            }
            goto LABEL_126;
          }
        }
      }
      else if (ai_family == 30)
      {
        if ((v58 & 0x20) == 0)
        {
          int v61 = setsockopt(*(_DWORD *)(v57 + 4 * v55), 41, 27, &v156, 4u);
          if (v61)
          {
            if (v61 == -1) {
              goto LABEL_101;
            }
            goto LABEL_126;
          }
          uint64_t v57 = *(void *)(a1 + 64);
          *(_DWORD *)(a1 + 96) = *(_DWORD *)(v57 + 4 * v55);
          __int16 v58 = *(_WORD *)(a1 + 204);
        }
        if ((v58 & 0x200) != 0)
        {
          int v68 = setsockopt(*(_DWORD *)(v57 + 4 * v55), 41, 61, &v156, 4u);
          if (v68)
          {
            if (v68 == -1) {
              goto LABEL_101;
            }
            goto LABEL_126;
          }
        }
      }
      int v70 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v55);
      if (*(void *)(a1 + 168))
      {
        int v71 = setsockopt(v70, 0xFFFF, 512, &v156, 4u);
        if (v71)
        {
          if (v71 == -1) {
            goto LABEL_101;
          }
          goto LABEL_126;
        }
      }
      else
      {
        int v72 = setsockopt(v70, 0xFFFF, 4, &v156, 4u);
        if (v72)
        {
          if (v72 == -1) {
            goto LABEL_101;
          }
          goto LABEL_126;
        }
      }
      int v73 = bind(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v55), v54->ai_addr, v54->ai_addrlen);
      if (v73)
      {
        if (v73 == -1) {
          goto LABEL_101;
        }
        goto LABEL_126;
      }
      int v74 = getsockname(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v55), v54->ai_addr, &v54->ai_addrlen);
      if (v74)
      {
        if (v74 == -1) {
          goto LABEL_101;
        }
        goto LABEL_126;
      }
      uint64_t v75 = *(const char **)(a1 + 168);
      if (v75)
      {
        int v76 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v55);
        int v77 = v54->ai_protocol;
        uint64_t v78 = *(void *)&v54->ai_family;
        memset(&v173.st_uid, 0, 32);
        int v155 = v78;
        *(void *)&v173.st_mode = v78;
        v173.st_dev = 1;
        HIDWORD(v173.st_ino) = v77;
        *(void *)&v172.st_dev = 0;
        int v79 = getaddrinfo(v75, 0, (const addrinfo *)&v173, (addrinfo **)&v172);
        if (!v79)
        {
          uint64_t v91 = *(void *)&v172.st_dev;
          if (!*(void *)&v172.st_dev)
          {
LABEL_97:
            freeaddrinfo(*(addrinfo **)&v172.st_dev);
            goto LABEL_98;
          }
          while (2)
          {
            if (v155 == 30)
            {
              LODWORD(v161) = 0;
              memset(v160, 0, sizeof(v160));
              *(_OWORD *)v160 = *(_OWORD *)(*(void *)(v91 + 32) + 8);
              int v92 = v76;
              int v93 = 41;
              socklen_t v94 = 20;
LABEL_93:
              if (setsockopt(v92, v93, 12, v160, v94) != -1) {
                goto LABEL_97;
              }
              __error();
              _os_assumes_log_ctx();
            }
            else
            {
              if (v155 == 2)
              {
                *(void *)v160 = 0;
                *(_DWORD *)v160 = *(_DWORD *)(*(void *)(v91 + 32) + 4);
                int v92 = v76;
                int v93 = 0;
                socklen_t v94 = 8;
                goto LABEL_93;
              }
              sub_10001B454(a1, 3, "Unknown family encountered during multicast group bind: %d", v80, v81, v82, v83, v84, v155);
            }
            uint64_t v91 = *(void *)(v91 + 40);
            if (!v91) {
              goto LABEL_97;
            }
            continue;
          }
        }
        int v85 = v79;
        ai_sockxpc_type_t type = gai_strerror(v79);
        sub_10001B454(a1, 3, "getaddrinfo(3): %d: %s", v86, v87, v88, v89, v90, v85);
        sub_10001D610(v85);
      }
LABEL_98:
      if ((v54->ai_socktype | 4) != 5 || (int v95 = listen(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v55), -1)) == 0)
      {
LABEL_102:
        int v96 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v55);
        int v97 = (const char *)sub_100022804(*(void *)(a1 + 56));
        if (*v97 == 47)
        {
          unsigned int v98 = 0;
        }
        else
        {
          v100 = getenv("PATH");
          if (!v100)
          {
            sub_10001B454(a1, 3, "No PATH environment variable set. The application firewall will not work with this service.", v101, v102, v103, v104, v105, v150);
            goto LABEL_124;
          }
          unsigned int v98 = sub_1000159F0(v100);
          __stringp = v98;
          long long v170 = 0u;
          long long v171 = 0u;
          long long v168 = 0u;
          long long v169 = 0u;
          long long v166 = 0u;
          long long v167 = 0u;
          long long v164 = 0u;
          long long v165 = 0u;
          long long v162 = 0u;
          long long v163 = 0u;
          *(_OWORD *)v160 = 0u;
          long long v161 = 0u;
          unsigned int v106 = strsep(&__stringp, ":");
          if (v106)
          {
            uint64_t v112 = 0;
            while (v112 != 24)
            {
              uint64_t v113 = v112 + 1;
              *(void *)&v160[8 * v112] = v106;
              unsigned int v106 = strsep(&__stringp, ":");
              uint64_t v112 = v113;
              if (!v106) {
                goto LABEL_116;
              }
            }
            sub_10001B454(a1, 4, "PATH contains lots of paths. Some will be skipped.", v107, v108, v109, v110, v111, v150);
            uint64_t v113 = 24;
LABEL_116:
            uint64_t v114 = 0;
            uint64_t v115 = 8 * v113;
            while (1)
            {
              bzero(&v173, 0x400uLL);
              snprintf((char *)&v173, 0x400uLL, "%s/%s", *(const char **)&v160[v114], v97);
              memset(&v172, 0, sizeof(v172));
              if (!stat((const char *)&v173, &v172)) {
                break;
              }
              v114 += 8;
              if (v115 == v114) {
                goto LABEL_121;
              }
            }
            free(v98);
            int v97 = sub_1000159F0((const char *)&v173);
            unsigned int v98 = (char *)v97;
LABEL_121:
            if (!v97)
            {
              sub_10001B454(a1, 3, "Socket's service points to a non-existent executable. The application firewall will not work with this service.", v116, v117, v118, v119, v120, v151);
LABEL_123:
              free(v98);
LABEL_124:
              if (fcntl(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v55), 4, 4, ai_socktype, ai_protocol, v154) == -1) {
                sub_100050E38();
              }
              goto LABEL_126;
            }
          }
        }
        int v99 = strlen(v97);
        if (setsockopt(v96, 0xFFFF, 4229, v97, v99 + 1) == -1 && *__error() != 42 && *__error()) {
          _os_assumes_log_ctx();
        }
        goto LABEL_123;
      }
      if (v95 == -1) {
LABEL_101:
      }
        sub_1000515CC();
LABEL_126:
      ++v55;
      uint64_t v54 = v54->ai_next;
      if (!v54)
      {
        size_t v121 = v157;
LABEL_131:
        freeaddrinfo(v121);
        *(_DWORD *)(a1 + 200) = 0;
        goto LABEL_132;
      }
    }
  }
  __break(1u);
}

uint64_t sub_10001CB18(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 136);
  if (!v2) {
    return 0;
  }
  uint64_t result = *(void *)(a1 + 144);
  *a2 = v2;
  return result;
}

void sub_10001CB34(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 204);
  if ((v1 & 0x100) != 0) {
    sub_100040E80("attempt to watch socket that is already watched");
  }
  if ((v1 & 0x80) != 0) {
    sub_100040E80("attempt to watch canceled socket");
  }
  if (*(void *)(a1 + 80)) {
    sub_100050D0C();
  }
  unint64_t v3 = *(void *)(a1 + 88);
  if (v3 >> 61)
  {
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 80) = sub_100013BB8(8 * v3);
    unint64_t v4 = *(void *)(a1 + 88);
    if (v4)
    {
      uint64_t v5 = 0;
      while (1)
      {
        int v6 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v5);
        if (v6 != -1) {
          break;
        }
LABEL_15:
        if (++v5 >= v4) {
          goto LABEL_16;
        }
      }
      int v7 = dup(*(_DWORD *)(*(void *)(a1 + 64) + 4 * v5));
      if (v7 == -1)
      {
        sub_100050E38();
      }
      else
      {
        uintptr_t v13 = v7;
        if ((v7 & 0x80000000) == 0)
        {
          uint64_t v14 = sub_100014B58();
          uint64_t v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v13, 0, v14);
          dispatch_set_context(v15, (void *)a1);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 0x40000000;
          handler[2] = sub_10001D6D4;
          handler[3] = &unk_1000704C8;
          handler[4] = v15;
          int v17 = v6;
          dispatch_source_set_event_handler(v15, handler);
          dispatch_source_set_mandatory_cancel_handler();
          dispatch_activate(v15);
          if (v15) {
            goto LABEL_14;
          }
        }
      }
      sub_10001B454(a1, 4, "Unable to monitor socket #%zu", v8, v9, v10, v11, v12, v5);
      uint64_t v15 = 0;
LABEL_14:
      *(void *)(*(void *)(a1 + 80) + 8 * v5) = v15;
      unint64_t v4 = *(void *)(a1 + 88);
      goto LABEL_15;
    }
LABEL_16:
    *(_WORD *)(a1 + 204) |= 0x100u;
  }
}

void sub_10001CD2C(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 204);
  if ((v1 & 0x100) == 0) {
    sub_100040E80("attempt to ignore socket that is already ignored");
  }
  if ((v1 & 0x80) != 0) {
    sub_100040E80("attempt to ignore canceled socket");
  }
  unint64_t v3 = *(void **)(a1 + 80);
  if (!v3) {
    sub_100050D0C();
  }
  unint64_t v4 = *(void *)(a1 + 88);
  if (v4)
  {
    for (unint64_t i = 0; i < v4; ++i)
    {
      int v6 = *(NSObject **)(*(void *)(a1 + 80) + 8 * i);
      if (*(_DWORD *)(*(void *)(a1 + 64) + 4 * i) == -1)
      {
        if (v6) {
          sub_100050D0C();
        }
      }
      else if (v6)
      {
        dispatch_source_cancel(v6);
        unint64_t v4 = *(void *)(a1 + 88);
        *(void *)(*(void *)(a1 + 80) + 8 * i) = 0;
      }
    }
    unint64_t v3 = *(void **)(a1 + 80);
  }
  free(v3);
  *(void *)(a1 + 80) = 0;
  *(_WORD *)(a1 + 204) &= ~0x100u;
}

uint64_t sub_10001CDE0(uint64_t a1, void *a2, void *a3, void *a4)
{
  if (*(_WORD *)(a1 + 204)) {
    return 37;
  }
  *a2 = *(void *)(a1 + 64);
  *a4 = *(void *)(a1 + 88);
  if (a3) {
    *a3 = *(void *)(a1 + 72);
  }
  if (*(void *)(a1 + 88))
  {
    unint64_t v5 = 0;
    do
    {
      int v6 = *(_DWORD *)(*(void *)(a1 + 64) + 4 * v5);
      if (v6 != -1 && fcntl(v6, 4, 0) == -1) {
        sub_100050E38();
      }
      ++v5;
    }
    while (v5 < *(void *)(a1 + 88));
  }
  uint64_t result = 0;
  *(_WORD *)(a1 + 204) |= 1u;
  return result;
}

uint64_t sub_10001CE90(uint64_t result, void *a2, void *a3)
{
  *a2 = *(void *)(result + 64);
  *a3 = *(void *)(result + 88);
  return result;
}

uint64_t sub_10001CEA4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 200);
}

uint64_t sub_10001CEAC(uint64_t result)
{
  *(_WORD *)(result + 204) &= ~1u;
  unint64_t v1 = *(void *)(result + 88);
  if (v1)
  {
    uint64_t v2 = (void *)result;
    for (unint64_t i = 0; i < v1; ++i)
    {
      uint64_t result = *(unsigned int *)(v2[8] + 4 * i);
      if (result != -1)
      {
        uint64_t result = fcntl(result, 4, 4);
        if (result == -1) {
          uint64_t result = sub_100050E38();
        }
        *(unsigned char *)(v2[9] + i) = 0;
        unint64_t v1 = v2[11];
      }
    }
  }
  return result;
}

void sub_10001CF40(uint64_t a1)
{
  __int16 v2 = *(_WORD *)(a1 + 204);
  if ((v2 & 0x100) != 0)
  {
    sub_10001CD2C(a1);
    __int16 v2 = *(_WORD *)(a1 + 204);
  }
  *(_WORD *)(a1 + 204) = v2 | 0x80;
}

uint64_t sub_10001CF7C(void *a1, unsigned int **a2, void *a3)
{
  unint64_t v3 = a1[11];
  if (v3 >> 62) {
    __break(1u);
  }
  int v7 = (unsigned int *)sub_100013BB8(4 * v3);
  unint64_t v8 = a1[11];
  if (v8)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    while (1)
    {
      uint64_t v11 = a1[8];
      if (*(_DWORD *)(v11 + 4 * v9) != -1)
      {
        long long v30 = 0u;
        long long v31 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        sockaddr v24 = (sockaddr)0;
        long long v25 = 0u;
        socklen_t v23 = 128;
        int v12 = accept(*(_DWORD *)(v11 + 4 * v9), &v24, &v23);
        if (v12 == -1)
        {
          uint64_t v14 = *__error();
          if (*(unsigned char *)(a1[9] + v9))
          {
            xpc_strerror();
            sub_10001B454((uint64_t)a1, 3, "Got a socket event but accept() failed with errno %d - %s", v15, v16, v17, v18, v19, v14);
          }
          if (v14 != 35)
          {
            if (v10)
            {
              uint64_t v21 = v7;
              do
              {
                unsigned int v22 = *v21++;
                sub_10003E54C((int *)v22);
                --v10;
              }
              while (v10);
            }
            free(v7);
            return v14;
          }
        }
        else
        {
          int v13 = v12;
          if (fcntl(v12, 4, 0) == -1) {
            sub_100050E38();
          }
          v7[v10++] = v13;
        }
        *(unsigned char *)(a1[9] + v9) = 0;
        unint64_t v8 = a1[11];
      }
      if (++v9 >= v8) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v10 = 0;
LABEL_16:
  uint64_t v14 = 0;
  *a2 = v7;
  *a3 = v10;
  return v14;
}

uint64_t sub_10001D128(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100046780(a2, a3, "\"%s\" = {", a4, a5, a6, a7, a8, a1 + 208);
  __int16 v16 = *(_WORD *)(a1 + 204);
  if ((v16 & 4) == 0)
  {
    uint64_t v17 = a3 + 1;
    uint64_t v18 = "(animating)";
    uint64_t v19 = a2;
    goto LABEL_64;
  }
  if ((v16 & 0x40) == 0)
  {
    unsigned int v20 = *(_DWORD *)(a1 + 100) - 1;
    uint64_t v21 = "(unknown)";
    if (v20 <= 4) {
      uint64_t v21 = off_100070508[v20];
    }
    sub_100046780(a2, a3 + 1, "xpc_type_t type = %s", v11, v12, v13, v14, v15, v21);
    if (*(void *)(a1 + 144) || *(void *)(a1 + 136))
    {
      sub_100046780(a2, a3 + 1, "path = %s", v24, v25, v26, v27, v28, *(void *)(a1 + 144));
      if ((*(_WORD *)(a1 + 204) & 8) != 0)
      {
        LOWORD(v85) = *(_WORD *)(a1 + 152);
        sub_100046780(a2, a3 + 1, "mode = %o", v24, v25, v26, v27, v28);
      }
      if (*(void *)(a1 + 136))
      {
        uint64_t v85 = *(void *)(a1 + 136);
        sub_100046780(a2, a3 + 1, "secure key = %s", v24, v25, v26, v27, v28);
      }
      if (*(_DWORD *)(a1 + 104))
      {
        LODWORD(v85) = *(_DWORD *)(a1 + 104);
        sub_100046780(a2, a3 + 1, "owner uid = %u", v24, v25, v26, v27, v28);
        if (*(_DWORD *)(a1 + 104)) {
          sub_100046780(a2, a3 + 1, "group id = %u", v24, v25, v26, v27, v28, *(unsigned int *)(a1 + 108));
        }
      }
LABEL_39:
      if (*(_DWORD *)(a1 + 200))
      {
        LODWORD(v85) = *(_DWORD *)(a1 + 200);
        sub_100046780(a2, a3 + 1, "int error = %d", v24, v25, v26, v27, v28);
      }
      sub_100046800(a2, v22, v23, v24, v25, v26, v27, v28, v85);
      sub_100046780(a2, a3 + 1, "sockets = {", v34, v35, v36, v37, v38);
      if (*(void *)(a1 + 88))
      {
        unint64_t v44 = 0;
        do
        {
          if (*(unsigned char *)(*(void *)(a1 + 72) + v44)) {
            uint64_t v45 = "";
          }
          else {
            uint64_t v45 = "no ";
          }
          sub_100046780(a2, a3 + 2, "%d (%sbytes to read)", v39, v40, v41, v42, v43, *(unsigned int *)(*(void *)(a1 + 64) + 4 * v44++), v45);
        }
        while (v44 < *(void *)(a1 + 88));
      }
      sub_100046780(a2, a3 + 1, "}", v39, v40, v41, v42, v43);
      sub_100046800(a2, v46, v47, v48, v49, v50, v51, v52, v86);
      if (*(_WORD *)(a1 + 204)) {
        __int16 v58 = "1";
      }
      else {
        __int16 v58 = "0";
      }
      sub_100046780(a2, a3 + 1, "active = %s", v53, v54, v55, v56, v57, v58);
      if ((*(_WORD *)(a1 + 204) & 2) != 0) {
        uint64_t v64 = "1";
      }
      else {
        uint64_t v64 = "0";
      }
      sub_100046780(a2, a3 + 1, "passive = %s", v59, v60, v61, v62, v63, v64);
      if ((*(_WORD *)(a1 + 204) & 0x10) != 0) {
        int v70 = "1";
      }
      else {
        int v70 = "0";
      }
      sub_100046780(a2, a3 + 1, "bonjour = %s", v65, v66, v67, v68, v69, v70);
      if ((*(_WORD *)(a1 + 204) & 0x20) != 0) {
        int v76 = "1";
      }
      else {
        int v76 = "0";
      }
      sub_100046780(a2, a3 + 1, "ipv4int v6 = %s", v71, v72, v73, v74, v75, v76);
      if ((*(_WORD *)(a1 + 204) & 0x200) != 0) {
        int v77 = "1";
      }
      else {
        int v77 = "0";
      }
      uint64_t v84 = v77;
      uint64_t v18 = "receive_packet_info = %s";
      goto LABEL_63;
    }
    if (*(void *)(a1 + 160))
    {
      uint64_t v85 = *(void *)(a1 + 160);
      sub_100046780(a2, a3 + 1, "node mach_port_name_t name = %s", v24, v25, v26, v27, v28);
    }
    if (*(void *)(a1 + 168))
    {
      uint64_t v85 = *(void *)(a1 + 168);
      sub_100046780(a2, a3 + 1, "multicast group = %s", v24, v25, v26, v27, v28);
    }
    if (*(void *)(a1 + 176))
    {
      uint64_t v85 = *(void *)(a1 + 176);
      sub_100046780(a2, a3 + 1, "service mach_port_name_t name = %s", v24, v25, v26, v27, v28);
    }
    int v29 = *(_DWORD *)(a1 + 184);
    if (v29 > 1)
    {
      if (v29 == 2)
      {
        long long v30 = "ipv4";
        goto LABEL_31;
      }
      if (v29 == 30)
      {
        long long v30 = "ipv6";
        goto LABEL_31;
      }
    }
    else
    {
      if (!v29) {
        goto LABEL_32;
      }
      if (v29 == 1)
      {
        long long v30 = "unix";
LABEL_31:
        sub_100046780(a2, a3 + 1, "family = %s", v24, v25, v26, v27, v28, v30);
LABEL_32:
        int v31 = *(_DWORD *)(a1 + 188);
        if (v31)
        {
          char v32 = "udp";
          if (v31 != 17) {
            char v32 = "(unknown)";
          }
          if (v31 == 6) {
            uint64_t v33 = "tcp";
          }
          else {
            uint64_t v33 = v32;
          }
          sub_100046780(a2, a3 + 1, "protocol = %s", v24, v25, v26, v27, v28, v33);
        }
        goto LABEL_39;
      }
    }
    long long v30 = "(unknown)";
    goto LABEL_31;
  }
  uint64_t v18 = "(system logger socket)";
LABEL_63:
  uint64_t v19 = a2;
  uint64_t v17 = a3 + 1;
LABEL_64:
  sub_100046780(v19, v17, v18, v11, v12, v13, v14, v15, v84);

  return sub_100046780(a2, a3, "}", v78, v79, v80, v81, v82);
}

void sub_10001D554(unsigned int *a1)
{
  __int16 v2 = *(void **)a1;
  (*(void (**)(void, void, void))(*(void *)a1 + 120))(*(void *)a1, a1[2], *(void *)(*(void *)a1 + 128));
  sub_10001A174(v2);

  free(a1);
}

void sub_10001D5B0(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 204) & 0x80) == 0) {
    sub_10003D3E4(*(void **)(a1 + 56), "com.apple.bonjour.registration", (const char *)(a1 + 208), *(void **)(a1 + 192));
  }

  sub_10001A174((void *)a1);
}

uint64_t sub_10001D610(int a1)
{
  switch(a1)
  {
    case 1:
    case 5:
    case 9:
    case 10:
      uint64_t result = 45;
      break;
    case 2:
      uint64_t result = 35;
      break;
    case 3:
    case 12:
    case 13:
      uint64_t result = 22;
      break;
    case 4:
      uint64_t result = 153;
      break;
    case 6:
      uint64_t result = 12;
      break;
    case 7:
    case 8:
      uint64_t result = 3;
      break;
    case 11:
      uint64_t result = *__error();
      break;
    case 14:
      uint64_t result = 34;
      break;
    default:
      uint64_t result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_10001D6D4(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  uint64_t v3 = context[11];
  if (v3)
  {
    uint64_t v4 = 0;
    while (*(_DWORD *)(context[8] + 4 * v4) != *(_DWORD *)(a1 + 40))
    {
      if (v3 == ++v4) {
        goto LABEL_7;
      }
    }
    *(unsigned char *)(context[9] + v4) = 1;
  }
LABEL_7:
  int v6 = (uint64_t (*)(void *, uint64_t, uint64_t))context[15];
  uint64_t v5 = context[16];

  return v6(context, 2, v5);
}

void sub_10001D750(uint64_t a1)
{
  handle = (int *)dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  sub_10003E54C(handle);
  uint64_t v3 = *(NSObject **)(a1 + 32);

  dispatch_release(v3);
}

void sub_10001D790()
{
  qword_100075D10 = 0;
  byte_100075D18 = 0;
  qword_100075D20 = 0;
  qword_100075D28 = 0;
  qword_100075D30 = 0;
}

BOOL sub_10001D7BC(uint64_t a1)
{
  if (a1)
  {
    __int16 v2 = (rb_tree_t **)sub_10001D84C();
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_10001D880;
    v5[3] = &unk_100070538;
    _DWORD v5[4] = a1;
    sub_10001B148(v2, (uint64_t)v5);
  }
  uint64_t v3 = sub_10001D84C();
  return sub_10001B1CC((size_t)v3) != 0;
}

void *sub_10001D84C()
{
  sub_100014B88();
  uint64_t result = (void *)qword_100075D28;
  if (!qword_100075D28)
  {
    uint64_t result = sub_10001B1E8();
    qword_100075D28 = (uint64_t)result;
  }
  return result;
}

uint64_t sub_10001D880(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10001D894(void *a1, void *a2)
{
  uunint64_t int64 = xpc_dictionary_get_uint64(a1, "cid");
  if (!uint64) {
    return 22;
  }
  uint64_t v5 = uint64;
  int v6 = (rb_tree_t **)sub_10001D84C();
  int v7 = sub_10001B100(v6, v5);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      xpc_object_t v10 = reply;
      sub_10001D918(reply, v8);
      uint64_t result = 0;
      *a2 = v10;
      return result;
    }
    return 22;
  }
  return 3;
}

void sub_10001D918(void *a1, uint64_t a2)
{
  uint64_t v4 = sub_100011574(a2);
  xpc_dictionary_set_uint64(a1, "cid", v4);
  uint64_t v5 = (const char *)sub_100012750(a2);
  int v6 = (const char *)sub_100012758(a2);
  if (v5) {
    xpc_dictionary_set_string(a1, "name", v5);
  }
  if (v6) {
    xpc_dictionary_set_string(a1, "bundle_identifier", v6);
  }
  int v7 = (const void *)sub_100012760(a2);
  if (v7)
  {
    xpc_dictionary_set_data(a1, "resource-usage-blob", v7, 0x160uLL);
  }
}

uint64_t sub_10001D9E8(void *a1, void *a2)
{
  byte_100075D18 = 1;
  uint64_t v4 = (void *)qword_100075D30;
  if (!qword_100075D30)
  {
    uint64_t v4 = sub_10001137C();
    qword_100075D30 = (uint64_t)v4;
  }
  if (sub_100011574((uint64_t)v4))
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      int v6 = reply;
      int v7 = (void *)qword_100075D30;
      if (!qword_100075D30)
      {
        int v7 = sub_10001137C();
        qword_100075D30 = (uint64_t)v7;
      }
      uint64_t v8 = sub_100011548((uint64_t)v7, 0);
      sub_100012770(v8, 2);
      sub_10001D918(v6, v8);
      uint64_t v9 = (void *)qword_100075D30;
      if (!qword_100075D30)
      {
        uint64_t v9 = sub_10001137C();
        qword_100075D30 = (uint64_t)v9;
      }
      sub_1000114C4((uint64_t)v9, 0);
      uint64_t result = 0;
      *a2 = v6;
    }
    else
    {
      return 22;
    }
  }
  else if (qword_100075D10)
  {
    return 37;
  }
  else
  {
    xpc_object_t v11 = xpc_dictionary_create_reply(a1);
    uint64_t result = 0;
    qword_100075D10 = (uint64_t)v11;
  }
  return result;
}

uint64_t sub_10001DAD0(uint64_t a1)
{
  __int16 v2 = (rb_tree_t **)sub_10001D84C();
  uint64_t v3 = sub_10001B100(v2, a1);
  if (!v3) {
    return 5;
  }
  uint64_t v4 = v3;
  sub_100012770((uint64_t)v3, 1);
  if (!sub_100012768((uint64_t)v4))
  {
    memset(v11, 0, sizeof(v11));
    if (coalition_info_resource_usage() == -1) {
      sub_100050E38();
    }
    sub_1000126F8(v4, v11);
    int v6 = (void *)qword_100075D10;
    if (qword_100075D10)
    {
      qword_100075D10 = 0;
      sub_10001D918(v6, (uint64_t)v4);
      int v7 = xpc_pipe_routine_reply();
      xpc_release(v6);
      if (!v7) {
        goto LABEL_11;
      }
      if (v7 != 32)
      {
        _os_assumes_log();
        goto LABEL_11;
      }
    }
    sub_10001DE28(v4);
    goto LABEL_11;
  }
  sub_1000126F8(v4, 0);
LABEL_11:
  if (byte_100076A82)
  {
    uint64_t v8 = (const char *)sub_100012750((uint64_t)v4);
    sub_100043D78(65541, "coalition_reap(%llu) [%s]", a1, v8);
  }
  sub_100010190();
  uint64_t v9 = sub_10001D84C();
  uint64_t v10 = sub_100011574((uint64_t)v4);
  sub_10001B038((uint64_t)v9, v10, 0);
  return 0;
}

unsigned char *sub_10001DC50(uint64_t a1)
{
  uint64_t v2 = sub_100010044(a1);
  uint64_t v3 = sub_100012574(v2, *(const char **)(a1 + 8), *(const char **)(a1 + 16), *(_DWORD *)a1, (uint64_t)sub_100010164);
  uint64_t v4 = sub_10001D84C();
  uint64_t v5 = sub_100011574((uint64_t)v3);
  sub_10001B038((uint64_t)v4, v5, v3);
  return v3;
}

uint64_t sub_10001DCB8(const void *a1, _DWORD *a2)
{
  if (*a2) {
    sub_100050D0C();
  }
  if (!a1) {
    sub_100050D0C();
  }
  uint64_t v4 = (void *)qword_100075D20;
  if (!qword_100075D20)
  {
    uint64_t v4 = sub_10004639C(32, (uint64_t)sub_10001DDA0);
    qword_100075D20 = (uint64_t)v4;
  }
  uint64_t v5 = sub_100046328((uint64_t)v4, a1);
  if (v5)
  {
    uint64_t v6 = (uint64_t)v5;
    uint64_t v7 = sub_100011574((uint64_t)v5);
    sub_100043D78(5, "Coalition Cache Hit: %s [%llu]", (const char *)a1, v7);
    return sub_100012668(v6);
  }
  else
  {
    uint64_t v9 = sub_10001DC50((uint64_t)a2);
    uint64_t v10 = qword_100075D20;
    xpc_object_t v11 = (void *)sub_100012668((uint64_t)v9);
    sub_100046140(v10, a1, v11);
    return (uint64_t)v9;
  }
}

uint64_t sub_10001DDA0(const char *a1, uint64_t a2)
{
  uint64_t v4 = sub_100011574(a2);
  sub_100043D78(5, "Coalition Cache Evicted: %s [%llu]", a1, v4);

  return sub_10001269C(a2);
}

void sub_10001DDFC()
{
  qword_100075D20 = 0;
}

void *sub_10001DE28(void *a1)
{
  uint64_t result = (void *)sub_100012770((uint64_t)a1, 2);
  if (byte_100075D18 == 1)
  {
    uint64_t v3 = (void *)qword_100075D30;
    if (!qword_100075D30)
    {
      uint64_t v3 = sub_10001137C();
      qword_100075D30 = (uint64_t)v3;
    }
    return sub_100011418(v3, a1);
  }
  return result;
}

uint64_t sub_10001DE94()
{
  return os_map_str_init();
}

void sub_10001DEA8(uint64_t a1)
{
  os_map_str_delete();
  free(*(void **)(a1 + 16));
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    sub_10001A174(v2);
  }
}

char *sub_10001DF10(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v4 = sub_10001AB74(a3);
  *((void *)v4 + 2) = sub_1000159F0(a2);
  return v4;
}

void *sub_10001DF4C(uint64_t a1, char *a2, const char *a3, void *a4)
{
  uint64_t v7 = os_map_str_find();
  if (!v7) {
    goto LABEL_6;
  }
  uint64_t v8 = (const char **)v7;
  if (!sub_100015D70(a2, *(const char **)(v7 + 16)))
  {
    sub_100043D78(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", a3, a2, v8[2]);
LABEL_6:
    uint64_t v9 = sub_10001AB74(a3);
    v9[2] = sub_1000159F0(a2);
    v9[3] = sub_10001A0AC(a4);
    os_map_str_insert();
    return v9;
  }
  uint64_t v9 = sub_10001A0AC(v8);
  if (!v9) {
    goto LABEL_6;
  }
  return v9;
}

uint64_t sub_10001E034(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 16);
}

uint64_t sub_10001E040(uint64_t a1)
{
  return *(void *)(a1 + 16) + 32;
}

uint64_t sub_10001E04C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 16) + 24);
}

void *sub_10001E058()
{
  return sub_100013BB8(0x50uLL);
}

uint64_t sub_10001E060(uint64_t result, int a2)
{
  if (*(void *)result)
  {
    int v2 = *(_DWORD *)(result + 72);
    unsigned int v3 = *(_DWORD *)(result + 76);
    *(_DWORD *)(result + 4 * (((_BYTE)v3 + (_BYTE)v2) & 0xF) + 8) = a2 - *(void *)result;
    if (v3 > 0xF) {
      *(_DWORD *)(result + 72) = ((_BYTE)v2 + 1) & 0xF;
    }
    else {
      *(_DWORD *)(result + 76) = v3 + 1;
    }
  }
  *(void *)uint64_t result = 0;
  return result;
}

void *sub_10001E0A8(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

uint64_t sub_10001E0B0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t sub_10001E0B8(uint64_t a1, char a2)
{
  return *(unsigned int *)(a1 + 4 * ((*(_DWORD *)(a1 + 72) + a2) & 0xF) + 8);
}

uint64_t sub_10001E0D0(uint64_t a1)
{
  uint64_t result = sub_10001E15C(a1);
  if (result)
  {
    uint64_t result = os_map_str_find();
    if (!result)
    {
      unsigned int v3 = *(const char **)(a1 + 576);
      *((unsigned char *)sub_100013BB8(0x58uLL) + 1) = 1;
      sub_1000159F0(v3);
      return os_map_str_insert();
    }
  }
  return result;
}

uint64_t sub_10001E15C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 248);
  if (!v2 || (_UNKNOWN *)sub_1000301F4(v2) != &unk_100075750 || (*(unsigned char *)(a1 + 1382) & 0x10) == 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 248) + 232);

  return sub_100030204(v4);
}

uint64_t sub_10001E1C8(uint64_t a1)
{
  uint64_t v2 = sub_1000250FC(a1);
  unsigned int v3 = (unsigned __int8 *)(a1 + 1040);
  if (v2) {
    unsigned int v3 = (unsigned __int8 *)v2;
  }
  return *v3;
}

uint64_t sub_10001E1FC(uint64_t a1, uint64_t a2)
{
  if (byte_100076A79 || (*(unsigned char *)(a1 + 1378) & 0x80) != 0) {
    return 0;
  }
  if (*(unsigned __int8 *)(a2 + 32) == sub_100047058(a1 + 1200)) {
    return 6;
  }
  return 0;
}

uint64_t sub_10001E254(uint64_t a1, uint64_t a2)
{
  if (byte_100076A79 || (*(unsigned char *)(a1 + 1378) & 0x80) != 0) {
    return 0;
  }
  if (sub_100047144(a1 + 1200))
  {
    int v4 = 1;
  }
  else if (sub_100046EEC(a1 + 1200))
  {
    int v4 = sub_100046F18((_DWORD *)(a1 + 1200)) == 0;
  }
  else if (*(_DWORD *)(a1 + 1024))
  {
    int v4 = 0;
  }
  else
  {
    int v4 = *(unsigned char *)(a2 + 32) != 0;
  }
  if (*(unsigned __int8 *)(a2 + 32) == v4) {
    return 6;
  }
  else {
    return 0;
  }
}

uint64_t sub_10001E304(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 144);
  if (v3)
  {
    int v4 = 0;
    do
    {
      v4 |= sub_10003D03C(v3);
      uint64_t v3 = *(void *)(v3 + 16);
    }
    while (v3);
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  if (*(unsigned char *)(a2 + 32) == (v4 & 1)) {
    return 14;
  }
  else {
    return 0;
  }
}

void sub_10001E368(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void **)(a1 + 512);
  if (v6)
  {
    do
    {
      uint64_t v7 = (void *)*v6;
      if (a2 == 9 || *((_DWORD *)v6 + 8) == a2)
      {
        void v6[5] = sub_10001A0AC((void *)a1);
        uint64_t v8 = sub_100014B58();
        dispatch_async_f(v8, v6, (dispatch_function_t)sub_100025144);
        uint64_t v9 = (void *)*v6;
        if (*v6) {
          v9[1] = v6[1];
        }
        *(void *)v6[1] = v9;
        *uint64_t v6 = -1;
        v6[1] = -1;
      }
      uint64_t v6 = v7;
    }
    while (v7);
  }
  sub_10001A0AC((void *)a1);
  if ((a2 - 1) > 8) {
    uint64_t v15 = "WILL_SPAWN";
  }
  else {
    uint64_t v15 = off_100070918[(int)a2 - 1];
  }
  sub_10001E4BC(a1, 5, "internal event: %s, code = %ld", v10, v11, v12, v13, v14, (char)v15);
  sub_10003FDB4(a1, a2, a3, v16, v17, v18, v19, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(a1 + 520))(a1, a2, a3, *(void *)(a1 + 568));

  sub_10001A174((void *)a1);
}

void sub_10001E4BC(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12 = sub_1000203FC(a1, 2);
  sub_100044138(v12, a2, a3, &a9, v9);
  free(v12);
}

uint64_t sub_10001E528(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = a2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1 + 528))(a1, a2, *(void *)(a1 + 568));
  if (result == 124) {
    return 0;
  }
  if (!result)
  {
    if (*(void *)(a1 + 1384))
    {
      uint64_t v23 = "cannot spawn: service is configured as retain only";
    }
    else
    {
      if ((*(void *)(a1 + 1376) & 0x40000) == 0)
      {
        uint64_t v10 = *(void *)(a1 + 248);
        if ((_UNKNOWN *)sub_1000301F4(v10) == &unk_100075750)
        {
          uint64_t v25 = qword_100075D50;
          if (qword_100075D50)
          {
            do
            {
              uint64_t v26 = *(void *)v25;
              uint64_t v27 = *(void *)(a1 + 256);
              uint64_t v28 = *(char **)(v25 + 16);
              if (v27)
              {
                if (sub_100015D70(v28, (const char *)(v27 + 1392))) {
                  goto LABEL_31;
                }
              }
              else if (sub_100015D70(v28, (const char *)(a1 + 1392)))
              {
LABEL_31:
                sub_10001E4BC(a1, 5, "matched global attach request before spawn", v11, v12, v13, v14, v15, v63);
                uint64_t v33 = sub_1000301FC(v10);
                xpc_dictionary_set_uint64(*(xpc_object_t *)(v25 + 24), "handle", v33);
                if ((*(unsigned char *)(a1 + 1381) & 2) != 0) {
                  xpc_dictionary_set_uuid(*(xpc_object_t *)(v25 + 24), "_instance", (const unsigned __int8 *)(a1 + 408));
                }
                sub_100047BA0(dword_100076A00, *(void **)(v25 + 24));
                xpc_release(*(xpc_object_t *)(v25 + 24));
                uint64_t v34 = *(void *)v25;
                if (*(void *)v25) {
                  *(void *)(v34 + 8) = *(void *)(v25 + 8);
                }
                **(void **)(v25 + 8) = v34;
                free((void *)v25);
                *(_DWORD *)(a1 + 820) = v2;
                *(unsigned char *)(a1 + 1322) |= 8u;
                char v35 = sub_100024E98(v2);
                sub_10001E4BC(a1, 5, "service spawn reason '%s' pended until controller attaches", v36, v37, v38, v39, v40, v35);
                sub_100025270(a1, 1);
                char v63 = sub_100024E98(v2);
                uint64_t v24 = "pended spawn reason '%s': redriving controller attach request";
LABEL_36:
                sub_10001E4BC(a1, 5, v24, v11, v12, v13, v14, v15, v63);
                return 36;
              }
              uint64_t v25 = v26;
            }
            while (v26);
          }
        }
        int v16 = *(_DWORD *)(a1 + 1128);
        if (v16 && v16 != v2)
        {
          char v17 = sub_100024E98(v2);
          sub_10001E4BC(a1, 5, "ignoring spawn reason '%s' due to filter", v18, v19, v20, v21, v22, v17);
          return 102;
        }
        if (*(void *)(a1 + 824))
        {
          uint64_t v24 = "cannot spawn: service is throttled";
          goto LABEL_36;
        }
        uint64_t v29 = sub_1000250FC(a1);
        uint64_t v30 = a1 + 1040;
        if (v29) {
          uint64_t v31 = v29;
        }
        else {
          uint64_t v31 = a1 + 1040;
        }
        if (*(unsigned char *)(v31 + 1) || (v2 & 0xFFFFFFF7) == 3 || (*(void *)(a1 + 1376) & 0x4000) != 0) {
          goto LABEL_27;
        }
        uint64_t v41 = sub_1000250FC(a1);
        uint64_t v42 = sub_1000250FC(a1);
        if (v42) {
          uint64_t v43 = v42;
        }
        else {
          uint64_t v43 = a1 + 1040;
        }
        if (v41)
        {
          if (v43 == v30) {
            unint64_t v44 = (_DWORD *)(a1 + 1200);
          }
          else {
            unint64_t v44 = (_DWORD *)(v43 + 32);
          }
          if (!*v44) {
            goto LABEL_27;
          }
          uint64_t v45 = sub_1000250FC(a1);
          if (v45) {
            uint64_t v46 = v45;
          }
          else {
            uint64_t v46 = a1 + 1040;
          }
          if (v46 == v30) {
            uint64_t v47 = (_DWORD *)(a1 + 1200);
          }
          else {
            uint64_t v47 = (_DWORD *)(v46 + 32);
          }
          if (*v47 != 3)
          {
            if (!*v47)
            {
              sub_10001EA18(a1);
LABEL_27:
              unsigned int v32 = *(unsigned __int8 *)(a1 + 424);
              if (v32 >= 2)
              {
                if (v32 != 2)
                {
                  uint64_t v48 = sub_1000252F8(a1);
                  sub_100040E80("Spawning a service in state %s", v48);
                }
                return 36;
              }
              sub_100025270(a1, 1);
              sub_1000253C8(a1, v2);
              return sub_1000254AC(a1);
            }
            unint64_t v50 = 0;
LABEL_63:
            unint64_t v56 = sub_10001EA18(a1);
            uint64_t v57 = v56 - v50;
            if (v56 > v50)
            {
              sub_10001E4BC(a1, 5, "Service only ran for %llu seconds. Pushing respawn out by %llu seconds.", v51, v52, v53, v54, v55, v50);
              if (v56 > *(_DWORD *)(a1 + 836)) {
                sub_10001E4BC(a1, 4, "Exponential throttling is in effect for %llu seconds.", v58, v59, v60, v61, v62, v57);
              }
              if (v56 != v50)
              {
                sub_100025EAC(a1, v57, v2);
                return 36;
              }
            }
            goto LABEL_27;
          }
          uint64_t v49 = sub_100046F60((uint64_t)v47);
        }
        else
        {
          uint64_t v49 = *(void *)(v43 + 8);
        }
        unint64_t v50 = sub_10000D388(v49) / 0x3B9ACA00uLL;
        goto LABEL_63;
      }
      uint64_t v23 = "cannot spawn: service is in penalty box";
    }
    sub_10001E4BC(a1, 5, v23, v5, v6, v7, v8, v9, v63);
    return 139;
  }
  return result;
}

uint64_t sub_10001E900()
{
  return 1;
}

uint64_t sub_10001E908(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 700);
  if (!result)
  {
    uint64_t v3 = *(void *)(a1 + 256);
    if (v3) {
      return *(unsigned int *)(v3 + 700);
    }
    else {
      return 0;
    }
  }
  return result;
}

size_t sub_10001E930(uint64_t a1)
{
  sub_10001E990(a1);
  uint64_t v2 = sub_1000250FC(a1);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = a1 + 1040;
  }
  if (!*(void *)(v3 + 16)) {
    return 0;
  }
  uint64_t v4 = sub_1000250FC(a1);
  if (v4) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = a1 + 1040;
  }
  return xpc_array_get_count(*(xpc_object_t *)(v5 + 16));
}

uint64_t sub_10001E990(uint64_t a1)
{
  uint64_t result = sub_1000250FC(a1);
  if (result) {
    uint64_t v3 = result;
  }
  else {
    uint64_t v3 = a1 + 1040;
  }
  if (*(void *)(v3 + 16))
  {
    uint64_t v4 = sub_1000250FC(a1);
    if (v4) {
      uint64_t v5 = v4;
    }
    else {
      uint64_t v5 = a1 + 1040;
    }
    uint64_t v6 = *(void **)(v5 + 16);
    xpc_object_t v7 = sub_1000251B0(v6, qword_100075AA0);
    xpc_release(v6);
    uint64_t result = sub_1000250FC(a1);
    if (result) {
      uint64_t v8 = result;
    }
    else {
      uint64_t v8 = a1 + 1040;
    }
    *(void *)(v8 + 16) = v7;
  }
  return result;
}

uint64_t sub_10001EA18(uint64_t a1)
{
  sub_10001E990(a1);
  if ((*(unsigned char *)(a1 + 1382) & 8) == 0) {
    return *(unsigned int *)(a1 + 836);
  }
  uint64_t v2 = sub_1000250FC(a1);
  uint64_t v3 = a1 + 1040;
  if (v2) {
    uint64_t v3 = v2;
  }
  if (!*(void *)(v3 + 16)) {
    return *(unsigned int *)(a1 + 836);
  }
  unsigned int v4 = *(unsigned __int16 *)(a1 + 1028);
  unsigned int v5 = sub_10001E930(a1);
  unsigned int v6 = v5 - v4;
  if (v5 <= v4) {
    return *(unsigned int *)(a1 + 836);
  }
  if (v6 > 0xB) {
    return 1200;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 836);
  if (!v8) {
    sub_100050D0C();
  }
  unint64_t v9 = v8 << v6;
  if (v9 >= 0x4B0) {
    return 1200;
  }
  else {
    return v9;
  }
}

void sub_10001EAA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(unsigned char *)(a2 + 176) = 0;
  *(void *)(a2 + 180) = 0;
  if (*(unsigned char *)(a1 + 1030) || (*(unsigned char *)(a1 + 1383) & 8) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 1376);
    if (byte_100076A66) {
      BOOL v12 = 0;
    }
    else {
      BOOL v12 = (v11 & 0x10000000000) == 0;
    }
    if (v12)
    {
      sub_10001E4BC(a1, 4, "Disallowing panic-on-crash behavior for non-system service", a4, a5, a6, a7, a8, a9);
    }
    else if ((v11 & 0x800000000000000) != 0)
    {
      uint64_t v14 = sub_1000250FC(a1);
      if (v14) {
        uint64_t v15 = v14;
      }
      else {
        uint64_t v15 = a1 + 1040;
      }
      int v16 = *(void **)(v15 + 24);
      if (v16)
      {
        xpc_object_t v17 = sub_1000251B0(*(void **)(v15 + 24), *(void *)(a1 + 1032));
        xpc_release(v16);
        *(void *)(v15 + 24) = v17;
        if (xpc_array_get_count(v17) >= 2)
        {
          uint64_t v18 = sub_10001EBD8(*(void *)(a1 + 1032));
          sub_10001E4BC(a1, 4, "Enabling panic-on-crash due to consecutive crashes", v19, v20, v21, v22, v23, v24);
          *(void *)(a2 + 180) = v18;
          *(unsigned char *)(a2 + 176) = 1;
        }
      }
    }
    else
    {
      *(unsigned char *)(a2 + 176) = *(unsigned char *)(a1 + 1030);
      unint64_t v13 = *(void *)(a1 + 1032);
      if (v13) {
        *(void *)(a2 + 180) = sub_10001EBD8(v13);
      }
    }
  }
}

uint64_t sub_10001EBD8(unint64_t a1)
{
  uint64_t v2 = mach_continuous_time();
  sub_10000D444(a1);
  if (__CFADD__(v2, v3)) {
    sub_100040E80("Overflow calculating deadline: %lld + %lld", v2, v3);
  }
  return v2 + v3;
}

uint64_t sub_10001EC2C(uint64_t a1)
{
  if (*(void *)(a1 + 1384)) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 1376);
  if ((v2 & 0x220000) != 0 || (v2 & 0x400000) != 0 && !*(_DWORD *)(a1 + 1024))
  {
    uint64_t v3 = 7;
    goto LABEL_4;
  }
  if ((v2 & 4) != 0)
  {
    if (*(_DWORD *)(a1 + 1024)) {
      uint64_t v3 = 5;
    }
    else {
      uint64_t v3 = 4;
    }
    goto LABEL_4;
  }
  if ((v2 & 0x10) != 0 && !*(_DWORD *)(a1 + 1024))
  {
    if ((~v2 & 0x40000001000) != 0) {
      uint64_t v3 = 4;
    }
    else {
      uint64_t v3 = 9;
    }
    goto LABEL_4;
  }
  uint64_t v6 = sub_1000250FC(a1);
  uint64_t v7 = a1 + 1040;
  if (v6) {
    uint64_t v8 = v6;
  }
  else {
    uint64_t v8 = a1 + 1040;
  }
  if (v8 == v7) {
    uint64_t v9 = a1 + 1200;
  }
  else {
    uint64_t v9 = v8 + 32;
  }
  if ((*(unsigned char *)(v9 + 48) & 2) != 0)
  {
    uint64_t v10 = sub_1000250FC(a1);
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = a1 + 1040;
    }
    if (v11 == v7) {
      uint64_t v12 = a1 + 1200;
    }
    else {
      uint64_t v12 = v11 + 32;
    }
    BOOL v13 = sub_100047144(v12);
    uint64_t v14 = sub_1000250FC(a1);
    if (v14) {
      uint64_t v15 = v14;
    }
    else {
      uint64_t v15 = a1 + 1040;
    }
    if (!v13)
    {
      if (v15 == v7) {
        uint64_t v23 = (_DWORD *)(a1 + 1200);
      }
      else {
        uint64_t v23 = (_DWORD *)(v15 + 32);
      }
      if (sub_1000470FC(v23))
      {
        if (sub_10001EECC(a1)) {
          goto LABEL_30;
        }
        if (*(int *)(a1 + 920) >= 31)
        {
          uint64_t v24 = sub_1000250FC(a1);
          if (v24) {
            uint64_t v25 = v24;
          }
          else {
            uint64_t v25 = a1 + 1040;
          }
          *(unsigned char *)(v25 + 1) = 1;
        }
        if ((*(unsigned char *)(a1 + 1380) & 4) != 0) {
          goto LABEL_30;
        }
      }
      else
      {
        if (!sub_10001EF1C(a1)) {
          goto LABEL_30;
        }
        uint64_t v26 = sub_1000250FC(a1);
        uint64_t v27 = v26 ? v26 : a1 + 1040;
        uint64_t v28 = v27 == v7 ? a1 + 1200 : v27 + 32;
        if ((*(unsigned char *)(v28 + 48) & 1) == 0) {
          goto LABEL_30;
        }
        uint64_t v29 = sub_1000250FC(a1);
        if (v29) {
          uint64_t v35 = v29;
        }
        else {
          uint64_t v35 = a1 + 1040;
        }
        if (*(_DWORD *)(v35 + 4) > 2u)
        {
          sub_10001E4BC(a1, 5, "service exceeded successive crash limit. launch will be throttled", v30, v31, v32, v33, v34, v38);
          goto LABEL_30;
        }
        uint64_t v36 = sub_1000250FC(a1);
        if (v36) {
          uint64_t v37 = v36;
        }
        else {
          uint64_t v37 = a1 + 1040;
        }
        *(unsigned char *)(v37 + 1) = 1;
      }
      uint64_t v3 = 3;
      goto LABEL_4;
    }
    *(unsigned char *)(v15 + 1) = 1;
  }
LABEL_30:
  uint64_t v16 = *(void *)(a1 + 136);
  if (!v16)
  {
LABEL_33:
    uint64_t v17 = a1 + 672;
    while (1)
    {
      uint64_t v17 = *(void *)v17;
      if (!v17) {
        break;
      }
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 16))(a1, v17);
      if (v18)
      {
        uint64_t v3 = v18;
        goto LABEL_4;
      }
    }
LABEL_41:
    uint64_t v3 = 0;
    goto LABEL_42;
  }
  while ((sub_10003D5B4(v16) & 1) == 0)
  {
    uint64_t v16 = *(void *)(v16 + 16);
    if (!v16) {
      goto LABEL_33;
    }
  }
  uint64_t v3 = 8;
LABEL_4:
  if (byte_1000769D9)
  {
    unsigned int v4 = &dword_1000755B0;
    uint64_t v5 = 2;
    goto LABEL_39;
  }
  if (byte_100076A79)
  {
    unsigned int v4 = &dword_100075590;
    uint64_t v5 = 8;
LABEL_39:
    while (1)
    {
      int v19 = *v4++;
      if (v19 == v3) {
        break;
      }
      if (!--v5) {
        goto LABEL_41;
      }
    }
  }
LABEL_42:
  if ((*(unsigned char *)(a1 + 1380) & 4) != 0)
  {
    uint64_t v20 = sub_1000250FC(a1);
    uint64_t v21 = a1 + 1040;
    if (v20) {
      uint64_t v21 = v20;
    }
    *(unsigned char *)(v21 + 1) = 1;
  }
  return v3;
}

BOOL sub_10001EECC(uint64_t a1)
{
  uint64_t v2 = sub_1000250FC(a1);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = a1 + 1040;
  }
  if (v3 == a1 + 1040) {
    uint64_t v4 = a1 + 1200;
  }
  else {
    uint64_t v4 = v3 + 32;
  }

  return sub_100047114(v4);
}

uint64_t sub_10001EF1C(uint64_t a1)
{
  uint64_t v2 = sub_1000250FC(a1);
  if (v2) {
    uint64_t v3 = v2;
  }
  else {
    uint64_t v3 = a1 + 1040;
  }
  if (v3 == a1 + 1040) {
    uint64_t v4 = a1 + 1200;
  }
  else {
    uint64_t v4 = v3 + 32;
  }

  return sub_100047058(v4);
}

uint64_t sub_10001EF6C(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  if (a2) {
    sub_10001E4BC((uint64_t)a1, 4, "Overriding specified stdin path for inetd-compatible service.", a4, a5, a6, a7, a8, v19);
  }
  uint64_t v12 = (int *)dup(v8);
  if (v12 != -1)
  {
    BOOL v13 = v12;
    if (a3)
    {
      uint64_t v14 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v14 = dup(v8);
      if (v14 == -1)
      {
        uint64_t v15 = *__error();
        uint64_t v17 = v13;
        goto LABEL_15;
      }
    }
    if (a4)
    {
      int v16 = -1;
LABEL_11:
      uint64_t v15 = 0;
      a1[172] = v13;
      a1[173] = v14;
      a1[174] = v16;
      return v15;
    }
    int v16 = dup(v8);
    if (v16 != -1) {
      goto LABEL_11;
    }
    uint64_t v15 = *__error();
    sub_10003E54C(v13);
    if (v14 == -1) {
      return v15;
    }
    uint64_t v17 = (int *)v14;
LABEL_15:
    sub_10003E54C(v17);
    return v15;
  }
  return *__error();
}

void *sub_10001F064(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = (void *)a1;
  if (*(_DWORD *)(a1 + 1152))
  {
    sub_10001E4BC(a1, 5, "Abandoning PID %d and its process group", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 1152));
    sub_10001A0AC(v8);
    *(void *)((char *)v8 + 1188) |= 0x2000000000uLL;
    sub_10001F100((uint64_t)v8, 1);
    uint64_t v9 = v8[172];
    sub_10001A174(v8);
    if ((v9 & 0x10000000) != 0) {
      return 0;
    }
  }
  return v8;
}

void sub_10001F100(uint64_t a1, char a2)
{
  long long v155 = 0uLL;
  *(void *)&long long v156 = 0;
  int v4 = sub_100043860();
  if (v4) {
    __int16 v5 = -1;
  }
  else {
    __int16 v5 = 0;
  }
  if (v4)
  {
    int v6 = *(_DWORD *)(a1 + 1152);
    xpc_strerror();
    sub_10001E4BC(a1, 4, "failed to query memory status priority for PID %d: %s (%d)", v7, v8, v9, v10, v11, v6);
  }
  if ((a2 & 1) == 0 && (*(void *)(a1 + 1376) & 0x10000) == 0)
  {
    int v12 = killpg(*(_DWORD *)(a1 + 1152), 15);
    if (v12)
    {
      int v13 = v12;
      if (*__error() != 3)
      {
        uint64_t v14 = __error();
        if (v13 == -1 && *v14 != 1) {
          sub_10005160C();
        }
      }
    }
  }
  if ((*(unsigned char *)(a1 + 1192) & 0x20) != 0)
  {
    sub_100046F68(a1 + 1200);
    LODWORD(v18) = 0;
    LODWORD(v17) = 0;
    int v16 = 0;
  }
  else
  {
    long long v182 = 0u;
    long long v183 = 0u;
    long long v180 = 0u;
    long long v181 = 0u;
    long long v178 = 0u;
    long long v179 = 0u;
    long long v176 = 0u;
    long long v177 = 0u;
    long long v174 = 0u;
    long long v175 = 0u;
    long long v172 = 0u;
    long long v173 = 0u;
    long long v170 = 0u;
    long long v171 = 0u;
    long long v168 = 0u;
    long long v169 = 0u;
    long long v166 = 0u;
    long long v167 = 0u;
    long long v164 = 0u;
    long long v165 = 0u;
    long long v162 = 0u;
    long long v163 = 0u;
    long long v160 = 0u;
    long long v161 = 0u;
    long long v158 = 0u;
    long long v159 = 0u;
    long long v156 = 0u;
    long long v157 = 0u;
    long long v155 = 0u;
    uint64_t v15 = (long long *)(a1 + 1200);
    int v16 = sub_10004680C(a1 + 1200, *(_DWORD *)(a1 + 1152), (uint64_t)&v155);
    uint64_t v17 = *((void *)&v172 + 1) >> 10;
    unint64_t v18 = (unint64_t)v170 >> 10;
    if ((sub_100026718(a1) & 1) == 0)
    {
      uint64_t v24 = sub_1000250FC(a1);
      uint64_t v25 = v24 ? v24 : a1 + 1040;
      if (v25 != a1 + 1040 && (long long *)(v25 + 32) != v15 && *(void *)(a1 + 1232) > *(void *)(v25 + 64))
      {
        long long v26 = *v15;
        long long v27 = *(_OWORD *)(a1 + 1216);
        long long v28 = *(_OWORD *)(a1 + 1232);
        *(void *)(v25 + 80) = *(void *)(a1 + 1248);
        *(_OWORD *)(v25 + 48) = v27;
        *(_OWORD *)(v25 + 64) = v28;
        *(_OWORD *)(v25 + 32) = v26;
      }
    }
  }
  int v29 = *(_DWORD *)(a1 + 1200);
  if (v29 == 2)
  {
    sub_10001E4BC(a1, 3, "wait4() failed", v19, v20, v21, v22, v23, v147);
  }
  else if (!v29)
  {
    sub_100050D0C();
  }
  uint64_t v30 = (uint64_t *)(a1 + 1188);
  if ((*(unsigned char *)(a1 + 1192) & 2) == 0)
  {
    if (*(_DWORD *)(a1 + 1200) == 1)
    {
      uint64_t v31 = "abandoned xpcproxy before exec";
      uint64_t v32 = a1;
      int v33 = 4;
    }
    else
    {
      if (sub_100046EEC(a1 + 1200))
      {
        int v34 = sub_100046F18((_DWORD *)(a1 + 1200));
        char v35 = v34;
        if (v34 != 78) {
          sub_10001E4BC(a1, 4, "xpcproxy could not exec: %d: %s", v19, v20, v21, v22, v23, v34);
        }
        char v147 = v35;
        uint64_t v31 = "xpcproxy exited due to exit(%d)";
      }
      else
      {
        char v147 = (char)v16;
        uint64_t v31 = "xpcproxy exited due to %s";
      }
      uint64_t v32 = a1;
      int v33 = 5;
    }
    sub_10001E4BC(v32, v33, v31, v19, v20, v21, v22, v23, v147);
  }
  if (sub_100046F84(a1 + 1200)) {
    sub_10001E4BC(a1, 4, "removing service since it exited with consistent failure - %s", v36, v37, v38, v39, v40, (char)v16);
  }
  sub_100011594();
  uint64_t v41 = (void **)sub_100010724(0x80uLL);
  if (sub_100046EEC(a1 + 1200))
  {
    char v148 = sub_100046F18((_DWORD *)(a1 + 1200));
    sub_1000107B4((uint64_t)v41, "exited due to exit(%d)", v42, v43, v44, v45, v46, v47, v148);
  }
  else if (sub_100046FC4((_DWORD *)(a1 + 1200)))
  {
    sub_1000107B4((uint64_t)v41, "exited due to %s", v48, v49, v50, v51, v52, v53, (char)v16);
  }
  else
  {
    int v54 = *(_DWORD *)(a1 + 1204);
    if (v54) {
      sub_1000107B4((uint64_t)v41, "exited with exit reason (namespace: %d code: 0x%llx) - %s", v48, v49, v50, v51, v52, v53, v54);
    }
  }
  uint64_t v55 = sub_100030A44(*(void *)(a1 + 248));
  if (v55) {
    sub_1000107B4((uint64_t)v41, " during %s", v56, v57, v58, v59, v60, v61, (char)v55);
  }
  unint64_t v62 = sub_100046F54(a1 + 1200);
  sub_1000107B4((uint64_t)v41, ", ran for %qums", v63, v64, v65, v66, v67, v68, v62 / 0xF4240);
  sub_10001E4BC(a1, 5, "%s", v69, v70, v71, v72, v73, (char)*v41);
  sub_100010778(v41);
  if ((~*(unsigned __int8 *)(a1 + 1248) & 3) == 0) {
    sub_10001E4BC(a1, 5, "process exited in a dirty state", v74, v75, v76, v77, v78, v149);
  }
  free(v16);
  if (*(void *)(a1 + 848))
  {
    sub_10001A5EC(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 848));
    dispatch_release(*(dispatch_object_t *)(a1 + 848));
    *(void *)(a1 + 848) = 0;
  }
  if (*(void *)(a1 + 856))
  {
    sub_10001A5EC(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 856));
    dispatch_release(*(dispatch_object_t *)(a1 + 856));
    *(void *)(a1 + 856) = 0;
  }
  if ((*(unsigned char *)(a1 + 1380) & 4) != 0)
  {
    if (sub_1000470FC((_DWORD *)(a1 + 1200))) {
      sub_100021EAC(a1, v79, v85, v80, v81, v82, v83, v84);
    }
    char v86 = *(void **)(a1 + 136);
    if (v86)
    {
      do
      {
        uint64_t v87 = (void *)v86[2];
        sub_10003D5CC(v86);
        sub_10001A174(v86);
        char v86 = v87;
      }
      while (v87);
    }
  }
  uint64_t v88 = *v30;
  if ((*v30 & 0x200000000) == 0)
  {
    if (byte_100076A7A)
    {
      nullsub_23("xpcproxy exited before exec", v79);
      LOBYTE(v88) = *(unsigned char *)v30;
    }
    if ((_BYTE)v88)
    {
      uint64_t v89 = 89;
    }
    else if (sub_100047170(a1 + 1200))
    {
      uint64_t v89 = 80;
    }
    else if (sub_10004719C((_DWORD *)(a1 + 1200)))
    {
      uint64_t v89 = 162;
    }
    else
    {
      uint64_t v89 = 153;
    }
    sub_100026760(a1, v89, 0, v80, v81, v82, v83, v84, v149);
  }
  if ((*(unsigned char *)(a1 + 1378) & 0x10) != 0)
  {
    sub_10001E4BC(a1, 5, "service only configured to run once, removing", v80, v81, v82, v83, v84, v149);
    *(_DWORD *)(a1 + 368) |= 0x10u;
  }
  else
  {
    sub_100046F84(a1 + 1200);
  }
  if (sub_100047058(a1 + 1200))
  {
    uint64_t v90 = sub_1000250FC(a1);
    if (v90) {
      uint64_t v91 = v90;
    }
    else {
      uint64_t v91 = a1 + 1040;
    }
    ++*(_DWORD *)(v91 + 4);
    uint64_t v92 = sub_1000250FC(a1);
    if (v92) {
      uint64_t v93 = v92;
    }
    else {
      uint64_t v93 = a1 + 1040;
    }
    int v94 = *(_DWORD *)(v93 + 4);
    sub_1000250FC(a1);
    sub_10001E4BC(a1, 5, "service has crashed %u times in a row (last was%s dirty)", v95, v96, v97, v98, v99, v94);
    if (!sub_1000470F0(a1 + 1200)) {
      goto LABEL_97;
    }
    sub_10001E4BC(a1, 5, "service has crashed into the shared cache area", v100, v101, v102, v103, v104, v150);
    uint64_t v105 = (unsigned char *)sub_1000250FC(a1);
    uint64_t v111 = *(void *)(a1 + 256);
    if (v105)
    {
      if (!v111)
      {
LABEL_92:
        uint64_t v119 = sub_1000250FC(a1);
        if ((*(unsigned char *)(a1 + 1382) & 0x20) == 0)
        {
          if (v119) {
            uint64_t v120 = (unsigned char *)v119;
          }
          else {
            uint64_t v120 = (unsigned char *)(a1 + 1040);
          }
          *uint64_t v120 = 1;
        }
        goto LABEL_97;
      }
    }
    else
    {
      if (!v111) {
        goto LABEL_92;
      }
      uint64_t v105 = (unsigned char *)(v111 + 1040);
    }
    if ((*(unsigned char *)(v111 + 1382) & 0x20) == 0)
    {
      *uint64_t v105 = 1;
      sub_10001E4BC(a1, 5, "recorded reslide request for this instance in the original service", v106, v107, v108, v109, v110, v151);
    }
    goto LABEL_92;
  }
  if (sub_100026718(a1))
  {
    sub_10001E4BC(a1, 5, "skipping successive crash reset", v112, v113, v114, v115, v116, v149);
  }
  else
  {
    uint64_t v117 = sub_1000250FC(a1);
    uint64_t v118 = a1 + 1040;
    if (v117) {
      uint64_t v118 = v117;
    }
    *(_DWORD *)(v118 + 4) = 0;
  }
LABEL_97:
  for (uint64_t i = 688; i != 700; i += 4)
  {
    unsigned int v122 = (int *)*(unsigned int *)(a1 + i);
    if (v122 != -1)
    {
      sub_10003E54C(v122);
      *(_DWORD *)(a1 + i) = -1;
    }
  }
  sub_100025270(a1, 8);
  if (*(unsigned char *)(a1 + 424) != 8) {
    sub_100050D0C();
  }
  if (sub_1000470FC((_DWORD *)(a1 + 1200)) && !sub_100047114(a1 + 1200))
  {
    if (!*(void *)(a1 + 976)) {
      *(void *)(a1 + 976) = sub_10001E058();
    }
    __uint64_t v123 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    sub_10001E0A8(*(void **)(a1 + 976), v123 / 0xF4240);
  }
  if (*(unsigned char *)(a1 + 424) != 8) {
    sub_100050D0C();
  }
  unsigned int v152 = v18;
  unsigned int v153 = v17;
  uint64_t v124 = *(unsigned int *)(a1 + 1152);
  uint64_t v125 = *v30;
  if (*(void *)(a1 + 256)) {
    uint64_t v126 = *(void *)(a1 + 256);
  }
  else {
    uint64_t v126 = a1;
  }
  uint64_t v127 = *(void *)(a1 + 976);
  uint64_t v154 = (unint64_t *)(a1 + 1188);
  if (v127 && (int v128 = sub_10001E0B0(v127)) != 0)
  {
    __int16 v129 = v5;
    int v130 = sub_10001E0B8(*(void *)(a1 + 976), v128 - 1);
  }
  else
  {
    __int16 v129 = v5;
    int v130 = -1;
  }
  uint64_t v131 = (const char *)(v126 + 1392);
  if (sub_100046EEC(a1 + 1200))
  {
    uint64_t v132 = 0;
    uint64_t v133 = (int)sub_100046F18((_DWORD *)(a1 + 1200));
  }
  else
  {
    uint64_t v132 = *(unsigned int *)(a1 + 1204);
    uint64_t v133 = *(void *)(a1 + 1208);
  }
  __uint64_t v134 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  uint64_t v135 = sub_100003164(v124);
  if (!v135) {
    sub_100043D78(4, "No spawn timestamp found; service=%s, pid=%d", v131, v124);
  }
  *(void *)&long long v155 = _NSConcreteStackBlock;
  *((void *)&v155 + 1) = 0x40000000;
  *(void *)&long long v156 = sub_100026880;
  *((void *)&v156 + 1) = &unk_1000706D8;
  *((void *)&v159 + 1) = __PAIR64__(v130, v124);
  *(void *)&long long v157 = v131;
  *((void *)&v157 + 1) = v135;
  *(void *)&long long v158 = v134 / 0xF4240;
  *((void *)&v158 + 1) = v132;
  *(void *)&long long v159 = v133;
  *(void *)&long long v160 = __PAIR64__(v153, v152);
  DWORD2(v160) = v125 >> 8;
  WORD6(v160) = v129;
  sub_100003334();
  sub_10001A0AC((void *)a1);
  sub_10001E368(a1, 5, 0);
  free(*(void **)(a1 + 1136));
  *(void *)(a1 + 1136) = 0;
  sub_100025270(a1, 0);
  *(_DWORD *)(a1 + 1152) = 0;
  *(_DWORD *)(a1 + 1160) = 16;
  uid_t v136 = *(NSObject **)(a1 + 1168);
  if (v136)
  {
    dispatch_source_cancel(v136);
    dispatch_release(*(dispatch_object_t *)(a1 + 1168));
    *(void *)(a1 + 1168) = 0;
  }
  if (*(void *)(a1 + 1176))
  {
    sub_10001A5EC(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 1176));
    dispatch_release(*(dispatch_object_t *)(a1 + 1176));
    *(void *)(a1 + 1176) = 0;
  }
  unint64_t v137 = *v154;
  uint64_t v138 = *(void *)(a1 + 24);
  *(_DWORD *)(a1 + 1184) = 0;
  *uint64_t v154 = v137 & 0xFFFFFE0000000000;
  if (v138) {
    *(void *)(v138 + 32) = *(void *)(a1 + 32);
  }
  **(void **)(a1 + 32) = v138;
  *(void *)(a1 + 24) = -1;
  *(void *)(a1 + 32) = -1;
  if ((*(unsigned char *)(a1 + 368) & 0x10) == 0 && (*(unsigned char *)(a1 + 1378) & 4) == 0)
  {
    uint64_t v139 = sub_10001EC2C(a1);
    if (v139)
    {
      int v140 = sub_10001E528(a1, v139);
      if (v140)
      {
        char v141 = v140;
        if (v140 != 36 && v140 != 124)
        {
          xpc_strerror();
          sub_10001E4BC(a1, 4, "Failed to respawn: %d: %s", v142, v143, v144, v145, v146, v141);
        }
      }
    }
  }
  if ((*(unsigned char *)(a1 + 368) & 0x10) == 0 && (*(unsigned char *)(a1 + 1378) & 4) != 0) {
    sub_100025270(a1, 1);
  }
  sub_10001A174((void *)a1);
}

void sub_10001FAF0(uint64_t *a1)
{
  uint64_t v1 = *a1;
  int data = dispatch_source_get_data(*(dispatch_source_t *)(*a1 + 1168));
  int v3 = data;
  if ((data & 0x40000000) == 0)
  {
    if ((data & 0x20000000) == 0) {
      goto LABEL_3;
    }
LABEL_6:
    sub_10001FB68(v1);
    if ((v3 & 0x80000000) == 0) {
      return;
    }
    goto LABEL_7;
  }
  ++*(_WORD *)(v1 + 1184);
  if ((data & 0x20000000) != 0) {
    goto LABEL_6;
  }
LABEL_3:
  if ((data & 0x80000000) == 0) {
    return;
  }
LABEL_7:

  sub_10001F100(v1, 0);
}

void sub_10001FB68(uint64_t a1)
{
  long long v22 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(buffer, 0, sizeof(buffer));
  if (sub_1000428E0(*(_DWORD *)(a1 + 1152), buffer))
  {
    _os_assumes_log_ctx();
    if ((*(unsigned char *)(a1 + 1192) & 2) != 0) {
      goto LABEL_15;
    }
LABEL_3:
    if (*(unsigned __int8 *)(a1 + 424) > 4u) {
      return;
    }
    sub_100025270(a1, 4);
    *(void *)(a1 + 1188) |= 0x200000000uLL;
    if ((*(unsigned char *)(a1 + 1380) & 4) == 0) {
      goto LABEL_14;
    }
    if (byte_100076AC8)
    {
      unsigned int v7 = *(_DWORD *)(a1 + 868);
      if (v7)
      {
        dispatch_time_t v8 = dispatch_time(0, 1000000000 * v7);
LABEL_13:
        uint64_t v9 = sub_100014B58();
        *(void *)(a1 + 856) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v9);
        sub_10001A5C4(a1);
        dispatch_set_context(*(dispatch_object_t *)(a1 + 856), (void *)a1);
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 856), v8, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 856), (dispatch_function_t)sub_1000268D0);
        dispatch_activate(*(dispatch_object_t *)(a1 + 856));
LABEL_14:
        sub_10001E368(a1, 4, 0);
        sub_1000262BC(a1);
        char v10 = sub_10002284C(a1);
        uint64_t v11 = sub_100024E98(*(_DWORD *)(a1 + 1160));
        int v12 = sub_100015BE4("%s", v11);
        sub_10001E4BC(a1, 5, "Successfully spawned %s[%d] because %s", v13, v14, v15, v16, v17, v10);
        free(v12);
        goto LABEL_15;
      }
      sub_10001E4BC(a1, 4, "Skipping extension launch watchdog", v2, v3, v4, v5, v6, v18);
    }
    dispatch_time_t v8 = -1;
    goto LABEL_13;
  }
  *(void *)(a1 + 1144) = *((void *)&v21 + 1);
  if ((*(unsigned char *)(a1 + 1192) & 2) == 0) {
    goto LABEL_3;
  }
  free(*(void **)(a1 + 1136));
  *(void *)(a1 + 1136) = sub_1000159F0((const char *)v20);
LABEL_15:
  ++*(_WORD *)(a1 + 1186);
}

uint64_t sub_10001FDA8(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  memset(uu, 0, sizeof(uu));
  uint64_t v16 = dyld_image_header_containing_address();
  int v17 = v16;
  if (!v16)
  {
    uuid_clear(uu);
    if (!a5) {
      goto LABEL_3;
    }
LABEL_5:
    sub_100040E80("Cannot setup an event for proxyless spawns!");
  }
  _dyld_get_image_uuid();
  if (a5) {
    goto LABEL_5;
  }
LABEL_3:
  v19[0] = 0;
  v19[1] = &a9;
  vasprintf(v19, a6, &a9);
  sub_10001FEBC(*(void *)(a1 + 1256), v9 - v17, a4, uu, (int)a2, a3, (char)v19[0]);
  free(v19[0]);
  return a2;
}

void sub_10001FEBC(uint64_t a1, int a2, int a3, unsigned __int8 *uu, uint64_t a5, int a6, char a7)
{
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  if (a5 <= 85)
  {
    if (a5 > 79)
    {
      if (a5 == 80)
      {
        int v17 = "FairPlay decryption failed on binary.";
      }
      else
      {
        if (a5 != 85) {
          goto LABEL_46;
        }
        int v17 = "Program specified by service is malformed.";
      }
    }
    else
    {
      if (a5 != 8)
      {
        if (a5 == 32)
        {
          int v16 = *(_DWORD *)(a1 + 700);
          if ((v16 || (v27 = *(void *)(a1 + 256)) != 0 && (int v16 = *(_DWORD *)(v27 + 700)) != 0) && v16 != -1)
          {
            int v17 = "Service could not notify controller.";
LABEL_44:
            uint64_t v28 = a1;
            int v29 = 4;
            goto LABEL_45;
          }
        }
        goto LABEL_46;
      }
      int v17 = "Program specified by service is not a Mach-O executable file.";
    }
LABEL_42:
    uint64_t v28 = a1;
    int v29 = 3;
LABEL_45:
    sub_10001E4BC(v28, v29, v17, v11, v12, v13, v14, v15, (char)v41);
    goto LABEL_46;
  }
  if ((unint64_t)(a5 - 114) < 2)
  {
    int v18 = *(_DWORD *)(*(void *)(a1 + 248) + 56);
    xpc_strerror();
    LOBYTE(v41) = a6;
    if (v18) {
      int v17 = "Could not find uid associated with service: %d: %s %u";
    }
    else {
      int v17 = "Could not find user/group associated with service: %d: %s %s/%s";
    }
    goto LABEL_44;
  }
  if (a5 == 86)
  {
    uint64_t v19 = *(void *)(a1 + 904);
    if (v19)
    {
      memset(v42, 0, sizeof(v42));
      if (xpc_binprefs_count(v19))
      {
        unsigned int v20 = 0;
        long long v21 = (char *)v42;
        size_t v22 = 128;
        do
        {
          int v23 = xpc_binprefs_cpu_type(v19, v20);
          if (v22 < 2)
          {
            size_t v26 = 0;
          }
          else
          {
            uint64_t v24 = "(invalid)";
            if ((v23 & 0xFEFFFFFF) - 1 <= 0x11)
            {
              uint64_t v25 = &off_1000706F8[v23 & 0xFEFFFFFF];
              if ((v23 & 0x1000000) == 0) {
                uint64_t v25 = &off_100070790[v23];
              }
              uint64_t v24 = *v25;
            }
            size_t v26 = snprintf(v21, v22, "%u:%s ", v23, v24);
            if (v22 <= v26) {
              size_t v26 = v22 - 1;
            }
          }
          v21 += v26;
          v22 -= v26;
          ++v20;
        }
        while (v20 < xpc_binprefs_count(v19));
      }
      uint64_t v41 = v42;
      int v17 = "Program specified by service does not contain one of the requested architectures: %s";
    }
    else
    {
      int v17 = "Program specified by service does not contain any valid architectures for this system.";
    }
    goto LABEL_42;
  }
  if (a5 == 111)
  {
    if (a6 >= 1)
    {
      if (a6 == 75)
      {
        int v17 = "LaunchServices returned a bundle URL that does not match with the LoginItem's known association.";
      }
      else
      {
        xpc_strerror();
        sub_10001E034(a1);
        LOBYTE(v41) = a6;
        int v17 = "Could not find and/or execute program specified by service: %d: %s: %s";
      }
      goto LABEL_44;
    }
    if (a6 < 0)
    {
      LOBYTE(v41) = a6;
      sub_10001E034(a1);
      int v17 = "Could not resolve CFBundleIdentifier specified by service: %d: %s";
      goto LABEL_44;
    }
  }
LABEL_46:
  xpc_strerror();
  sub_10001E4BC(a1, 3, "Service could not initialize: %s, error 0x%llx - %s", v30, v31, v32, v33, v34, a7);
  char v35 = sub_10001112C();
  sub_10001E4BC(a1, 3, "initialization failure: %s: %s + %llu [%llu][%s]: 0x%llx", v36, v37, v38, v39, v40, v35);
}

uint64_t sub_1000201F8()
{
  return 0;
}

void sub_100020200(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    xpc_object_t v4 = sub_1000117E0(1, 0, object);
    uint64_t v5 = (void *)sub_100011890(v4);
    size_t length = xpc_data_get_length(v5);
    unsigned int v7 = sub_100013BB8(length);
    if (xpc_data_get_bytes(v5, v7, 0, length) != length) {
      _os_assumes_log_ctx();
    }
    *(void *)(a1 + 616) = v7;
    *(_DWORD *)(a1 + 624) = length;
    *(void *)(a1 + 592) += length;
    xpc_release(v4);
    xpc_release(v5);
  }
}

uint64_t sub_1000202F8(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

void *sub_100020330(void *result, xpc_object_t object)
{
  if (object)
  {
    uint64_t v3 = result;
    uint64_t result = xpc_get_type(object);
    if (result == (void *)&_xpc_type_data)
    {
      xpc_object_t v4 = (void *)v3[75];
      if (v4)
      {
        free(v4);
        v3[74] -= *((unsigned int *)v3 + 152);
      }
      size_t length = xpc_data_get_length(object);
      uint64_t v6 = sub_100013BB8(length);
      uint64_t result = (void *)xpc_data_get_bytes(object, v6, 0, length);
      if (result != (void *)length) {
        uint64_t result = (void *)_os_assumes_log_ctx();
      }
      v3[75] = v6;
      *((_DWORD *)v3 + 152) = length;
      v3[74] += length;
    }
  }
  return result;
}

char *sub_1000203FC(uint64_t a1, int a2)
{
  if ((a2 - 1) >= 2) {
    sub_100050D0C();
  }
  char v10 = (const char **)sub_100010724(0x40uLL);
  uint64_t v11 = *(void *)(a1 + 248);
  if (v11)
  {
    uint64_t v12 = sub_10002A624(v11, 1);
    sub_1000107B4((uint64_t)v10, "%s/", v13, v14, v15, v16, v17, v18, (char)v12);
    free(v12);
  }
  sub_1000107B4((uint64_t)v10, "%s", v4, v5, v6, v7, v8, v9, a1 + 112);
  if (a2 == 2)
  {
    int v25 = *(_DWORD *)(a1 + 296);
    if (v25 > 0 || (int v25 = *(_DWORD *)(a1 + 1152), v25 >= 1)) {
      sub_1000107B4((uint64_t)v10, " [%d]", v19, v20, v21, v22, v23, v24, v25);
    }
  }
  size_t v26 = sub_100010770(v10);
  sub_100010778((void **)v10);
  return v26;
}

_DWORD *sub_1000204E0()
{
  sub_100047428(2, (uint64_t)sub_100020530);

  return sub_100047428(6, (uint64_t)sub_10002086C);
}

uint64_t sub_100020530(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  unsigned int v18 = -1;
  uint64_t v7 = sub_1000269F4(a3, (int *)&v18);
  if (v18 == 36)
  {
    sub_100047D68(a3, "domain deferral", v8, v9, v10, v11, v12, v13, v17);
    return 0;
  }
  uint64_t v14 = v7;
  if (v7)
  {
    if (*(unsigned char *)(v7 + 424) == 2)
    {
      sub_10001E4BC(v7, 5, "Deferring IPC (%d) while service is spawning", v9, v10, v11, v12, v13, a2);
      sub_100026C58(v14, a3, 1);
      return 0;
    }
    uint64_t v16 = sub_100047400();
    uint64_t result = 45;
    switch(a2)
    {
      case 700:
        uint64_t result = sub_100026CC0(v14, (uint64_t)v16, a3, a4);
        break;
      case 701:
        uint64_t result = sub_100026F7C(v14, (uint64_t)v16, a3, a4);
        break;
      case 702:
        uint64_t result = sub_100027148(v14, (uint64_t)v16, a3, a4);
        break;
      case 703:
        uint64_t result = sub_100027354(v14, (uint64_t)v16, a3, a4);
        break;
      case 704:
        return sub_1000275A0(v14, (uint64_t)v16, a3, a4);
      case 705:
        uint64_t result = sub_100027A7C(v14, (uint64_t)v16, a3, a4);
        break;
      case 706:
        uint64_t result = sub_100027D58(v14, (uint64_t)v16);
        break;
      case 707:
        uint64_t result = sub_100027DC8(v14, (uint64_t)v16, a3, a4);
        break;
      case 708:
        uint64_t result = sub_100027EA0(v14, (uint64_t)v16, a3, a4);
        break;
      case 710:
        uint64_t result = sub_100027F7C(v14, (uint64_t)v16, a3, a4);
        break;
      case 711:
        uint64_t result = sub_100028054(v14, (uint64_t)v16, a3, a4);
        break;
      case 712:
        uint64_t result = sub_100028150(v14, (uint64_t)v16, a3, a4);
        break;
      case 713:
        uint64_t result = sub_100028214(v14, (uint64_t)v16, a3, a4);
        break;
      case 715:
        uint64_t result = sub_100028444(v14, (uint64_t)v16, a3, a4);
        break;
      case 716:
        uint64_t result = sub_100028634(v14, (uint64_t)v16, a3, a4);
        break;
      case 717:
      case 724:
        return result;
      case 718:
        uint64_t result = sub_100028710(v14, (uint64_t)v16, a3, a4);
        break;
      case 719:
        uint64_t result = sub_1000282F0(v14, (uint64_t)v16, a3, a4);
        break;
      case 720:
        uint64_t result = sub_1000287DC(v14, a3, a4);
        break;
      case 721:
        uint64_t result = sub_100028850(v14, v16, a3, a4);
        break;
      case 722:
        uint64_t result = sub_10002893C(v14, (uint64_t)v16, a3, a4);
        break;
      case 723:
        uint64_t result = sub_100028A50(v14, (uint64_t)v16, a3, a4);
        break;
      case 725:
        uint64_t result = sub_100028B04(v14, (uint64_t)v16, a3, a4);
        break;
      default:
        uint64_t result = 33;
        break;
    }
  }
  else
  {
    sub_100047D68(a3, "no service, code = %d", v8, v9, v10, v11, v12, v13, v18);
    uint64_t result = v18;
    if (a2 == 704 && (v18 & 0xFFFFFFFE) == 0x70)
    {
      uint64_t v16 = sub_100047400();
      return sub_1000275A0(v14, (uint64_t)v16, a3, a4);
    }
  }
  return result;
}

uint64_t sub_10002086C(uint64_t a1, int a2, void *a3, void *a4)
{
  dword_100075E88 = *((_DWORD *)sub_100047400() + 5);
  qword_100075E58 = sub_100030018();
  unsigned int v25 = -1;
  uint64_t v7 = sub_1000269F4(a3, (int *)&v25);
  uint64_t v8 = v25;
  if (v25 == 36) {
    return 0;
  }
  uint64_t v9 = (void *)v7;
  if (a2 == 301 && v25 == 135)
  {
    uint64_t v9 = &unk_100075D60;
  }
  else
  {
    if (!v7) {
      return v8;
    }
    uint64_t v8 = 45;
    if ((a2 - 302) < 8 || a2 == 300) {
      return v8;
    }
    if (a2 != 301) {
      return 33;
    }
  }
  uint64_t v10 = v9[31];
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v8 = 45;
  xpc_object_t v11 = 0;
  switch(xpc_dictionary_get_uint64(a3, "outgsk"))
  {
    case 0uLL:
      goto LABEL_55;
    case 1uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      int v12 = *((_DWORD *)v9 + 300);
      if (v12 == 2)
      {
        int64_t v13 = 11;
      }
      else if (v12)
      {
        int64_t v13 = *((int *)v9 + 307);
      }
      else
      {
LABEL_18:
        int64_t v13 = 0;
      }
      goto LABEL_53;
    case 3uLL:
      int64_t v13 = getuid();
      goto LABEL_53;
    case 4uLL:
      int64_t v13 = getpid();
      goto LABEL_53;
    case 6uLL:
      if ((_UNKNOWN *)sub_1000301F4(v10) == &unk_1000755B8 || sub_100041068(v10))
      {
        xpc_object_t v14 = xpc_string_create("System");
        goto LABEL_54;
      }
      uint64_t v8 = 125;
      goto LABEL_44;
    case 7uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      int64_t v13 = (v9[172] >> 2) & 1;
      goto LABEL_53;
    case 8uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      int64_t v13 = *((unsigned int *)v9 + 220);
      goto LABEL_53;
    case 9uLL:
      goto LABEL_18;
    case 0xAuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      int64_t v13 = *((unsigned int *)v9 + 208);
      goto LABEL_53;
    case 0xBuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
      for (uint64_t i = (char *)v9[126]; i; uint64_t i = *(char **)i)
      {
        uint64_t v16 = strrchr(i + 32, 61);
        *uint64_t v16 = 0;
        xpc_dictionary_set_string(v11, i + 32, v16 + 1);
        *uint64_t v16 = 61;
      }
      goto LABEL_55;
    case 0xCuLL:
    case 0x18uLL:
    case 0x1AuLL:
      uint64_t v8 = 126;
      goto LABEL_44;
    case 0xDuLL:
      int64_t v13 = 32;
      goto LABEL_53;
    case 0xEuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      if ((*((unsigned char *)v9 + 1380) & 1) == 0)
      {
        uint64_t v8 = 3;
        goto LABEL_44;
      }
      int64_t v13 = *((unsigned __int16 *)v9 + 408);
      goto LABEL_53;
    case 0xFuLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      int64_t v13 = (v9[172] >> 16) & 1;
      goto LABEL_53;
    case 0x10uLL:
      if (*((_DWORD *)v9 + 74)) {
        goto LABEL_43;
      }
      int64_t v13 = (v9[172] >> 8) & 1;
      goto LABEL_53;
    case 0x12uLL:
      if (!*((_DWORD *)v9 + 74))
      {
        int64_t v13 = (v9[172] >> 11) & 1;
LABEL_53:
        xpc_object_t v14 = xpc_int64_create(v13);
LABEL_54:
        xpc_object_t v11 = v14;
LABEL_55:
        uunint64_t int64 = xpc_dictionary_get_uint64(a3, "ingsk");
        if (uint64)
        {
          if (*((_DWORD *)v9 + 74))
          {
            uint64_t v8 = 135;
LABEL_58:
            if (v11) {
              xpc_release(v11);
            }
            return v8;
          }
          uint64_t v18 = uint64;
          xpc_object_t value = xpc_dictionary_get_value(a3, "in");
          if (value)
          {
            uint64_t v8 = 45;
            uint64_t v20 = value;
            switch(v18)
            {
              case 2uLL:
              case 0xDuLL:
                break;
              case 7uLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64) {
                  goto LABEL_76;
                }
                unint64_t v21 = v9[172] & 0xFFFFFFFFFFFFFFFBLL | (4 * (xpc_int64_get_value(v20) != 0));
                goto LABEL_75;
              case 8uLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64) {
                  goto LABEL_76;
                }
                if (*((_DWORD *)v9 + 288))
                {
                  if (v9[109]) {
                    sub_100050D0C();
                  }
                  *((_DWORD *)v9 + 220) = xpc_int64_get_value(v20);
                }
                break;
              case 0xAuLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64) {
                  goto LABEL_76;
                }
                *((_DWORD *)v9 + 208) = xpc_int64_get_value(v20);
                break;
              case 0xEuLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64) {
                  goto LABEL_76;
                }
                v9[172] |= (unint64_t)&_mh_execute_header;
                *((_WORD *)v9 + 408) = xpc_int64_get_value(v20);
                break;
              case 0xFuLL:
                if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
                {
LABEL_76:
                  uint64_t v8 = 22;
                  goto LABEL_58;
                }
                unint64_t v21 = v9[172] & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(xpc_int64_get_value(v20) != 0) << 16);
LABEL_75:
                v9[172] = v21;
                break;
              case 0x10uLL:
                if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64 && xpc_int64_get_value(v20)) {
                  v9[172] |= 0x100uLL;
                }
                break;
              case 0x11uLL:
              case 0x12uLL:
              case 0x16uLL:
              case 0x17uLL:
                uint64_t v8 = 126;
                goto LABEL_58;
              default:
                goto LABEL_58;
            }
          }
        }
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_object_t v23 = reply;
        if (v11)
        {
          xpc_dictionary_set_value(reply, "out", v11);
          xpc_release(v11);
        }
        uint64_t v8 = 0;
        *a4 = v23;
        return v8;
      }
LABEL_43:
      uint64_t v8 = 135;
LABEL_44:
      if (xpc_dictionary_get_uint64(a3, "ingsk"))
      {
        if (*((_DWORD *)v9 + 74)) {
          return 135;
        }
        else {
          return v8;
        }
      }
      return v8;
    default:
      goto LABEL_44;
  }
}

uint64_t sub_100020E0C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return (*(unsigned __int8 *)(a1 + 1381) >> 1) & 1;
}

uint64_t sub_100020E4C(int a1)
{
  uint64_t result = sub_100020EA0(a1);
  if (!result)
  {
    uint64_t result = sub_100020F1C(a1);
    if (result)
    {
      return sub_100020EA0(a1);
    }
  }
  return result;
}

uint64_t sub_100020EA0(int a1)
{
  int v2 = a1;
  for (uint64_t result = qword_1000762D0[sub_100015EA8(&v2, 4) % 0x35uLL]; result; uint64_t result = *(void *)(result + 24))
  {
    if (*(_DWORD *)(result + 1152) == v2) {
      break;
    }
  }
  return result;
}

uint64_t sub_100020F1C(int a1)
{
  sub_100014BA0();
  if (!a1) {
    return 0;
  }
  __dmb(9u);
  uint64_t v7 = qword_100075D58;
  if (!qword_100075D58) {
    return 0;
  }
  while (*(_DWORD *)(v7 + 1156) != a1)
  {
    uint64_t v7 = *(void *)(v7 + 24);
    if (!v7) {
      return 0;
    }
  }
  if (*(unsigned char *)(v7 + 424) != 2) {
    sub_100050D0C();
  }
  sub_10001E4BC(v7, 5, "speculatively converting service to spawned, pid=%d", v2, v3, v4, v5, v6, a1);

  return sub_100020FCC(v7, a1, 0, 1, v9, v10, v11, v12);
}

uint64_t sub_100020FCC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v11 = a1;
  if ((*(unsigned char *)(a1 + 1192) & 0x80) != 0) {
    uint64_t v12 = "xpcproxy";
  }
  else {
    uint64_t v12 = "service";
  }
  if (*(unsigned char *)(a1 + 424) != 2)
  {
    sub_10001E4BC(a1, 5, "spawn completed after a speculative conversion", a4, a5, a6, a7, a8, v95);
    if (a3) {
      sub_100040E80("speculatively converted service to spawned, but spawn failed with error %d", a3);
    }
    if (*(_DWORD *)(v11 + 1156) != a2) {
      sub_100050D0C();
    }
    int v22 = *(_DWORD *)(v11 + 1152);
    if (v22 && v22 != a2) {
      sub_100040E80("speculatively converted service to spawned with PID %d, but the PID is %d", *(_DWORD *)(v11 + 1152), a2);
    }
    if (v8) {
      sub_100050D0C();
    }
    sub_10001E368(v11, 8, 0);
    return v11;
  }
  sub_100014B88();
  uint64_t v19 = (void *)(v11 + 24);
  uint64_t v18 = *(void *)(v11 + 24);
  if (v18) {
    *(void *)(v18 + 32) = *(void *)(v11 + 32);
  }
  **(void **)(v11 + 32) = v18;
  *uint64_t v19 = -1;
  *(void *)(v11 + 32) = -1;
  if (a3)
  {
    if ((*(unsigned char *)(v11 + 1192) & 0x80) != 0)
    {
      char v20 = (char)off_100075A80[0];
      unint64_t v21 = "trampoline";
    }
    else
    {
      char v20 = sub_10001E034(v11);
      unint64_t v21 = "service";
    }
    int v45 = *(_DWORD *)(v11 + 1160);
    if (a3 <= 0xD && ((1 << a3) & 0x2104) != 0)
    {
      uint64_t v46 = *(void *)(v11 + 1376);
      if ((v46 & 0x2000000000000) == 0)
      {
        *(void *)(v11 + 1384) = *(void *)(v11 + 1384);
        *(void *)(v11 + 1376) = v46 | 0x2000000000000;
        strerror(a3);
        sub_10001E4BC(v11, 5, "Remove ability to use bypass the proxy: spawn failed: %d: %s", v47, v48, v49, v50, v51, a3);
      }
    }
    strerror(a3);
    sub_10001E4BC(v11, 5, "%s spawn failed: %d: %s", v52, v53, v54, v55, v56, (char)v21);
    sub_10001A0AC((void *)v11);
    sub_10001E368(v11, 1, (int)a3);
    strerror(a3);
    sub_10001E4BC(v11, 3, "Could not spawn process %s: %d: %s", v57, v58, v59, v60, v61, v20);
    if ((*(unsigned char *)(v11 + 1379) & 0x10) == 0)
    {
      sub_10001A174((void *)v11);
      sub_100025270(v11, 0);
      if ((*(unsigned char *)(v11 + 1192) & 0x80) != 0)
      {
        if ((*(_DWORD *)(v11 + 368) & 0x10) != 0) {
          sub_10005164C();
        }
        unsigned int v72 = sub_10001EA18(v11);
        sub_100025EAC(v11, v72, v45);
      }
      sub_100026760(v11, a3, 0, v67, v68, v69, v70, v71, v97);
      goto LABEL_51;
    }
    sub_10001E4BC(v11, 3, "Removed service on spawn failure", v62, v63, v64, v65, v66, v97);
    sub_100025270(v11, 0);
    sub_10001A174((void *)v11);
    return 0;
  }
  *(_DWORD *)(v11 + 1152) = a2;
  sub_10001E4BC(v11, 5, "%s spawned with pid %d", v13, v14, v15, v16, v17, (char)v12);
  sub_100011594();
  j__kdebug_trace();
  xpc_object_t v23 = &qword_1000762D0[sub_100015EA8((unsigned char *)(v11 + 1152), 4) % 0x35uLL];
  uint64_t v24 = *v23;
  *(void *)(v11 + 24) = *v23;
  if (v24) {
    *(void *)(v24 + 32) = v19;
  }
  uint64_t *v23 = v11;
  *(void *)(v11 + 32) = v23;
  uintptr_t v25 = *(int *)(v11 + 1152);
  size_t v26 = sub_100014B58();
  dispatch_source_t v27 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v25, 0xE0000000uLL, v26);
  *(void *)(v11 + 1168) = v27;
  uint64_t v28 = sub_10001A054((void *)v11, 26, (uint64_t)v27, 0);
  dispatch_set_context(*(dispatch_object_t *)(v11 + 1168), v28);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v11 + 1168), (dispatch_function_t)sub_10001FAF0);
  dispatch_source_set_registration_handler_f(*(dispatch_source_t *)(v11 + 1168), (dispatch_function_t)sub_100028F24);
  dispatch_source_set_mandatory_cancel_handler_f();
  dispatch_activate(*(dispatch_object_t *)(v11 + 1168));
  if ((*(unsigned char *)(v11 + 1377) & 0x80) != 0)
  {
    uint64_t v34 = *(void *)(v11 + 192);
    if (!v34)
    {
      uint64_t v73 = "inetd-compatible service with no sockets.";
LABEL_42:
      sub_10001E4BC(v11, 3, v73, v29, v30, v31, v32, v33, v96);
      goto LABEL_43;
    }
    uint64_t v99 = 0;
    uint64_t v100 = 0;
    uint64_t v98 = 0;
    int v35 = sub_10001CDE0(v34, &v100, &v99, &v98);
    if (v35)
    {
      char v39 = v35;
      xpc_strerror();
      sub_10001E4BC(v11, 3, "Could not activate inetd socket: %d: %s", v40, v41, v42, v43, v44, v39);
      goto LABEL_43;
    }
    uint64_t v74 = v100;
    uint64_t v75 = *v100;
    uint64_t v76 = v98;
    if (v98)
    {
      uint64_t v77 = v99;
      while (!*v77++)
      {
        ++v74;
        if (!--v76) {
          goto LABEL_40;
        }
      }
      uint64_t v75 = *v74;
    }
LABEL_40:
    int v79 = sub_10001EF6C((_DWORD *)v11, *(void *)(v11 + 448), *(void *)(v11 + 456), *(void *)(v11 + 464), v75, v36, v37, v38);
    if (v79)
    {
      char v96 = v79;
      strerror(v79);
      uint64_t v73 = "Could not setup inetd descriptors: %d: %s";
      goto LABEL_42;
    }
  }
LABEL_43:
  sub_10001E368(v11, 1, 0);
  if (*(unsigned char *)(v11 + 424) != 2) {
    sub_100050D0C();
  }
  sub_100025270(v11, 3);
  if (*(unsigned char *)(v11 + 424) != 3) {
    sub_100050D0C();
  }
  uint64_t v80 = *(unsigned int *)(v11 + 1152);
  __uint64_t v81 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  sub_100003050(v80, v81 / 0xF4240);
  if ((*(unsigned char *)(v11 + 1192) & 0x80) == 0) {
    sub_10001FB68(v11);
  }
  if (v8) {
    sub_10001E368(v11, 7, 0);
  }
  if (*(unsigned char *)(v11 + 1193))
  {
    sub_10001E4BC(v11, 5, "redriving pending stop", v82, v83, v84, v85, v86, v96);
    uint64_t v87 = sub_10000D714();
    sub_100021858(v11, v87, v88, v89, v90, v91, v92, v93);
LABEL_51:
    *(void *)(v11 + 1188) &= ~0x10000000000uLL;
  }
  return v11;
}

uint64_t sub_10002154C(uint64_t result)
{
  uint64_t v1 = result;
  if (*(_DWORD *)(result + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(result + 296), (const char *)(result + 1392));
  }
  if (!*(_DWORD *)(result + 1152) && (*(unsigned char *)(result + 368) & 0x10) == 0)
  {
    uint64_t result = sub_10001EC2C(result);
    if (result)
    {
      return sub_10001E528(v1, result);
    }
  }
  return result;
}

uint64_t sub_1000215D4(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 424) == 1) {
    sub_100021644(a1, 1);
  }
  uint64_t v4 = sub_1000250FC(a1);
  uint64_t v11 = a1 + 1040;
  if (v4) {
    uint64_t v11 = v4;
  }
  *(unsigned char *)(v11 + 1) = 1;

  return sub_100021748(a1, a2, v5, v6, v7, v8, v9, v10);
}

void sub_100021644(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 424) != 1) {
    sub_100050D0C();
  }
  sub_100025270(a1, 0);
  if ((*(unsigned char *)(a1 + 1378) & 4) != 0)
  {
    uint64_t v18 = *(void **)(a1 + 136);
    if (v18)
    {
      do
      {
        uint64_t v19 = (void *)v18[2];
        if (sub_10003D5C0((uint64_t)v18))
        {
          sub_10003D5CC(v18);
          sub_10001A174(v18);
        }
        uint64_t v18 = v19;
      }
      while (v19);
    }
    if (a2) {
      *(void *)(a1 + 1376) &= ~0x40000uLL;
    }
    uint64_t v17 = "canceling penalty-box spawn";
  }
  else
  {
    uint64_t v9 = *(NSObject **)(a1 + 824);
    if (!v9) {
      goto LABEL_15;
    }
    dispatch_source_cancel(v9);
    *(void *)(a1 + 824) = 0;
    *(_DWORD *)(a1 + 820) = 0;
    uint64_t v16 = *(dispatch_semaphore_t **)(a1 + 840);
    if (v16)
    {
      sub_100003AE8(v16);
      *(void *)(a1 + 840) = 0;
    }
    sub_1000261D0(a1, 0, v10, v11, v12, v13, v14, v15);
    uint64_t v17 = "canceling throttled spawn";
  }
  sub_10001E4BC(a1, 5, v17, v4, v5, v6, v7, v8, v20);
LABEL_15:

  sub_10001E368(a1, 1, 89);
}

uint64_t sub_100021748(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  if (a2 == 11)
  {
    uint64_t v10 = *(void *)(a1 + 1376);
    if ((v10 & 0x40000) == 0) {
      sub_100040E80("retry launch on service that was not deferred");
    }
    *(void *)(a1 + 1384) = *(void *)(a1 + 1384);
    *(void *)(a1 + 1376) = v10 & 0xFFFFFFFFFFFBFFFFLL;
    sub_10001E4BC(a1, 5, "retry launch", a4, a5, a6, a7, a8, v12);
  }
  else if (*(unsigned __int8 *)(a1 + 424) - 1 <= 1)
  {
    sub_10001E4BC(a1, 5, "launch already in progress", a4, a5, a6, a7, a8, v12);
    return 36;
  }
  if ((*(unsigned char *)(a1 + 1378) & 4) != 0)
  {
    sub_10001E4BC(a1, 5, "attempt to launch while in penalty box", a4, a5, a6, a7, a8, v12);
    return 139;
  }
  else if (*(_DWORD *)(a1 + 1152))
  {
    return 37;
  }
  else
  {
    return sub_10001E528(a1, a2);
  }
}

uint64_t sub_100021858(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  if ((*(unsigned char *)(a1 + 368) & 0x10) != 0)
  {
    uint64_t v10 = *(void **)(a1 + 144);
    if (v10)
    {
      do
      {
        uint64_t v11 = (void *)v10[2];
        sub_10003D048((uint64_t)v10);
        sub_10001A174(v10);
        uint64_t v10 = v11;
      }
      while (v11);
    }
  }
  int v12 = *(unsigned __int8 *)(a1 + 424);
  if (v12 == 1)
  {
    sub_100021644(a1, 0);
    return 89;
  }
  if (!*(_DWORD *)(a1 + 1152))
  {
    if (v12 == 2)
    {
      sub_10001E4BC(a1, 5, "service spawning, defer stopping", a4, a5, a6, a7, a8, v34);
      if (*(_DWORD *)(a1 + 1152)) {
        sub_100050D0C();
      }
      uint64_t v26 = *(void *)(a1 + 1188);
      *(void *)(a1 + 1188) = v26 | 0x10000000000;
      if ((v26 & 0x10000000000) != 0) {
        return 37;
      }
      else {
        return 36;
      }
    }
    else
    {
      sub_10001E4BC(a1, 5, "service not running, not stopping", a4, a5, a6, a7, a8, v34);
      return 37;
    }
  }
  if (v12 == 7)
  {
    uint64_t v15 = (*(uint64_t (**)(uint64_t, void))(a1 + 536))(a1, *(void *)(a1 + 568));
    uint64_t v13 = v15;
    if (v15)
    {
      sub_10001E4BC(a1, 5, "cannot abandon languishing service: %d", v16, v17, v18, v19, v20, v15);
      xpc_strerror();
      sub_10001E4BC(a1, 4, "Cannot abandon languishing service: %d: %s", v21, v22, v23, v24, v25, v13);
    }
    else
    {
      sub_10001E4BC(a1, 5, "abandoning languishing service", v16, v17, v18, v19, v20, v34);
      sub_10001F064(a1, v27, v28, v29, v30, v31, v32, v33);
    }
    return v13;
  }

  return sub_100021A18(a1, 0, a2, a4, a5, a6, a7, a8);
}

uint64_t sub_100021A18(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int8 *)(a1 + 424) - 3 >= 2)
  {
    sub_10001E4BC(a1, 5, "service already stopped", a4, a5, a6, a7, a8, v66);
    return 37;
  }
  memset(v67, 0, sizeof(v67));
  int v9 = *(_DWORD *)(a1 + 1152);
  if (!v9) {
    sub_100050D0C();
  }
  mach_error_t v12 = sub_1000437E0(v9, (integer_t *)v67);
  if (v12)
  {
    int v13 = *(_DWORD *)(a1 + 1152);
    mach_error_string(v12);
    sub_10001E4BC(a1, 5, "could not get audit token for service (PID %d): %d: %s", v14, v15, v16, v17, v18, v13);
    unint64_t v19 = dword_100075A94;
    int v20 = 3;
    goto LABEL_24;
  }
  if (sub_10000D714() != a3 && sub_10002EA3C(*(void *)(a1 + 248), a3) && !sub_100019210())
  {
    sub_10001E4BC(a1, 5, "caller (PID %d) is not allowed to signal target process: %s", v22, v23, v24, v25, v26, *(_DWORD *)(a3 + 20));
    return 1;
  }
  uint64_t v27 = (char *)(a1 + 1188);
  if ((*(unsigned char *)(a1 + 1192) & 2) == 0 || byte_100076A45)
  {
    int v29 = sub_100043670();
    if (v29 && v29 != 3) {
      _os_assumes_log();
    }
    if ((*(unsigned char *)(a1 + 1192) & 2) != 0)
    {
      if (!byte_100076A45) {
        sub_100050D0C();
      }
      uint64_t v28 = "sudden shutdown";
    }
    else
    {
      uint64_t v28 = "aborting trampoline";
    }
    goto LABEL_21;
  }
  if (a2 == 2)
  {
    int v20 = sub_1000435B4();
    char *v27 = 9;
  }
  else
  {
    if (a2 == 1)
    {
      uint64_t v28 = "force-kill";
LABEL_21:
      char v30 = 9;
      uint64_t v31 = a1;
      int v32 = 9;
LABEL_22:
      int v20 = sub_100028F78(v31, (uint64_t)v67, v32, (char)v28);
      char *v27 = v30;
      goto LABEL_23;
    }
    if ((*(unsigned char *)(a1 + 1381) & 0x20) != 0)
    {
      if (a2) {
        sub_100050D0C();
      }
      uint64_t v28 = "requested SIGTERM";
      char v30 = 15;
      uint64_t v31 = a1;
      int v32 = 15;
      goto LABEL_22;
    }
    if (a2) {
      sub_100050D0C();
    }
    int v20 = sub_100043670();
    char *v27 = 0;
    if (!v20)
    {
      sub_1000115A4();
      char v60 = strsignal(*v27);
      sub_10001E4BC(a1, 5, "signaled service: %s", v61, v62, v63, v64, v65, v60);
    }
  }
LABEL_23:
  unint64_t v19 = 0;
  if (!v20)
  {
    unint64_t v43 = *(void *)v27;
    goto LABEL_27;
  }
LABEL_24:
  strerror(v20);
  sub_10001E4BC(a1, 5, "could not terminate service: %d: %s", v33, v34, v35, v36, v37, v20);
  strerror(v20);
  sub_10001E4BC(a1, 3, "could not terminate service: %d: %s", v38, v39, v40, v41, v42, v20);
  if (v19 <= 1) {
    unint64_t v19 = 1;
  }
  unint64_t v43 = *(void *)(a1 + 1188) & 0xFFFFFFFFFFFFFF00 | 9;
  *(void *)(a1 + 1188) = v43;
LABEL_27:
  if (v43 == 15)
  {
    sub_100025270(a1, 5);
    uint64_t v44 = sub_1000291F4;
    if (!v19)
    {
      unint64_t v19 = *(unsigned int *)(a1 + 832);
      uint64_t v44 = sub_1000291F4;
    }
  }
  else
  {
    if (v43 != 9)
    {
      char v46 = strsignal(v43);
      sub_10001E4BC(a1, 4, "Service was sent unexpected signal: %s", v47, v48, v49, v50, v51, v46);
      int v45 = (void (__cdecl *)(void *))sub_100029010;
      unint64_t v19 = 1;
      goto LABEL_36;
    }
    sub_100025270(a1, 6);
    if (!v19) {
      unint64_t v19 = dword_100075A94;
    }
    uint64_t v44 = sub_100029010;
  }
  int v45 = (void (__cdecl *)(void *))v44;
LABEL_36:
  if (a2 == 2) {
    unint64_t v19 = 10;
  }
  strsignal(*(unsigned __int8 *)(a1 + 1188));
  sub_10001E4BC(a1, 5, "scheduling cleanup in %llu sec after sending %s", v52, v53, v54, v55, v56, v19);
  if (*(void *)(a1 + 1176)) {
    sub_100040E80("tried to overwrite service timeout_source");
  }
  uint64_t v57 = sub_100014B58();
  *(void *)(a1 + 1176) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v57);
  sub_10001A5C4(a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 1176), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 1176), v45);
  uint64_t v58 = *(NSObject **)(a1 + 1176);
  dispatch_time_t v59 = dispatch_time(0, 1000000000 * v19);
  dispatch_source_set_timer(v58, v59, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1176));
  return 0;
}

uint64_t sub_100021E70(uint64_t a1)
{
  uint64_t v2 = sub_10000D714();

  return sub_100021858(a1, v2, v3, v4, v5, v6, v7, v8);
}

void sub_100021EAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  if ((*(unsigned char *)(a1 + 1380) & 0x10) != 0)
  {
    sub_100021F08(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_100021F08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(unsigned char *)(i + 88) & 0x40) == 0)
    {
      sub_10001E4BC(a1, 5, "draining messages from %s", a4, a5, a6, a7, a8, i - 88);
      sub_100049D30(i, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  for (uint64_t j = *(void *)(a1 + 184); j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(unsigned char *)(j + 88) & 0x40) == 0)
    {
      sub_10001E4BC(a1, 5, "draining messages from %s", a4, a5, a6, a7, a8, j - 88);
      sub_100049D30(j, v18, v19, v20, v21, v22, v23, v24);
    }
  }
}

void sub_100021FB8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 880))
  {
    if (*(void *)(a1 + 872)) {
      sub_100050D0C();
    }
    uint64_t v2 = sub_100014B58();
    uint64_t v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v2);
    *(void *)(a1 + 872) = v3;
    dispatch_set_context(v3, (void *)a1);
    uint64_t v4 = *(NSObject **)(a1 + 872);
    dispatch_time_t v5 = dispatch_time(0, 1000000000 * *(unsigned int *)(a1 + 880));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 872), (dispatch_function_t)sub_10002207C);
    uint64_t v6 = *(NSObject **)(a1 + 872);
    dispatch_activate(v6);
  }
}

void sub_10002207C(uint64_t a1)
{
  int v2 = sub_10001E528(a1, 12);
  sub_10001E4BC(a1, 5, "interval event: domain response: %d", v3, v4, v5, v6, v7, v2);
  if (v2 && v2 != 36 && v2 != 124)
  {
    xpc_strerror();
    sub_10001E4BC(a1, 3, "Interval spawn of service failed: %d: %s", v8, v9, v10, v11, v12, v2);
  }
}

void sub_1000220FC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 880))
  {
    int v2 = *(NSObject **)(a1 + 872);
    if (!v2) {
      sub_100050D0C();
    }
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 872));
    *(void *)(a1 + 872) = 0;
  }
}

void sub_100022140(uint64_t a1)
{
  int v2 = *(NSObject **)(a1 + 872);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 872));
    *(void *)(a1 + 872) = 0;
  }
}

uint64_t sub_100022178(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return a1 + 376;
}

uint64_t sub_1000221B4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return *(unsigned int *)(a1 + 1152);
}

xpc_object_t sub_1000221F0(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "Label", (const char *)(a1 + 1392));
  xpc_dictionary_set_BOOL(v2, "OnDemand", (*(void *)(a1 + 1376) & 4) == 0);
  uint64_t v3 = (void *)sub_1000301F4(*(void *)(a1 + 248));
  if (v3 == (void *)&unk_1000755B8)
  {
    uint64_t v4 = "System";
  }
  else if (v3 == qword_100075640)
  {
    uint64_t v4 = "Background";
  }
  else
  {
    if (v3 != (void *)&unk_1000756C8) {
      goto LABEL_9;
    }
    uint64_t v4 = "Aqua";
  }
  xpc_dictionary_set_string(v2, "LimitLoadToSessionType", v4);
LABEL_9:
  if (sub_100047170(a1 + 1200))
  {
    int64_t v5 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else if (sub_100046FA0((_DWORD *)(a1 + 1200)))
  {
    int64_t v5 = *(int *)(a1 + 1228);
  }
  else
  {
    int64_t v5 = 0;
  }
  xpc_dictionary_set_int64(v2, "LastExitStatus", v5);
  int64_t v6 = *(int *)(a1 + 1152);
  if (v6) {
    xpc_dictionary_set_int64(v2, "PID", v6);
  }
  uint64_t v7 = *(const char **)(a1 + 448);
  if (v7) {
    xpc_dictionary_set_string(v2, "StandardInPath", v7);
  }
  uint64_t v8 = *(const char **)(a1 + 456);
  if (v8) {
    xpc_dictionary_set_string(v2, "StandardOutPath", v8);
  }
  uint64_t v9 = *(const char **)(a1 + 464);
  if (v9) {
    xpc_dictionary_set_string(v2, "StandardErrorPath", v9);
  }
  uint64_t v10 = *(void *)(a1 + 1376);
  if ((v10 & 0x100) != 0)
  {
    xpc_dictionary_set_BOOL(v2, "EnableTransactions", 1);
    uint64_t v10 = *(void *)(a1 + 1376);
  }
  if ((v10 & 0x4000) != 0)
  {
    xpc_dictionary_set_BOOL(v2, "inetdCompatibility", 1);
    xpc_dictionary_set_BOOL(v2, "Wait", (*(void *)(a1 + 1376) & 0x8000) != 0);
  }
  uint64_t v11 = *(void **)(a1 + 640);
  if (v11) {
    xpc_dictionary_set_value(v2, "_AdditionalProperties", v11);
  }
  uint64_t v12 = (const char *)sub_10001E034(a1);
  xpc_dictionary_set_string(v2, "Program", v12);
  if (*(_DWORD *)(a1 + 428))
  {
    xpc_object_t v13 = xpc_array_create(0, 0);
    if (*(_DWORD *)(a1 + 428))
    {
      unint64_t v14 = 0;
      do
        xpc_array_set_string(v13, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(*(void *)(a1 + 432) + 8 * v14++));
      while (v14 < *(unsigned int *)(a1 + 428));
    }
    xpc_dictionary_set_value(v2, "ProgramArguments", v13);
    xpc_release(v13);
  }
  return v2;
}

xpc_object_t sub_100022470(uint64_t a1, char a2)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v4, "extension", (*(void *)(a1 + 1376) & 0x400000000) != 0);
  xpc_dictionary_set_BOOL(v4, launch_extension_property_xpc_bundle, (*(void *)(a1 + 1376) & 2) != 0);
  int64_t v5 = *(const char **)(a1 + 576);
  if (v5) {
    xpc_dictionary_set_string(v4, "bundle-id", v5);
  }
  xpc_dictionary_set_int64(v4, launch_extension_property_pid, *(int *)(a1 + 1152));
  if (*(unsigned char *)sub_10001E040(a1) == 47)
  {
    int64_t v6 = (const char *)sub_10001E040(a1);
    xpc_dictionary_set_string(v4, "path", v6);
  }
  uint64_t v7 = *(void *)(a1 + 248);
  if ((void *)sub_1000301F4(v7) == qword_100075750)
  {
    int v8 = sub_1000301FC(v7);
    uint64_t v9 = sub_100020E4C(v8);
    if (v9)
    {
      uint64_t v10 = *(const char **)(v9 + 576);
      if (v10) {
        xpc_dictionary_set_string(v4, launch_extension_property_host_bundle_id, v10);
      }
    }
    xpc_dictionary_set_int64(v4, launch_extension_property_host_pid, v8);
    if ((a2 & 1) == 0) {
      goto LABEL_15;
    }
  }
  else if ((a2 & 1) == 0)
  {
    goto LABEL_15;
  }
  uint64_t v11 = *(void *)(a1 + 344);
  if (v11)
  {
    uint64_t v12 = *(void **)(v11 + 56);
    goto LABEL_16;
  }
LABEL_15:
  uint64_t v12 = 0;
LABEL_16:
  xpc_object_t v13 = xpc_array_create(0, 0);
  for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(unsigned char *)(i + 88) & 0x40) == 0)
    {
      int v15 = sub_100015DF0(v12, (const char *)(i + 168));
      xpc_object_t v16 = sub_100049138(i, v15);
      xpc_array_append_value(v13, v16);
      xpc_release(v16);
    }
  }
  for (uint64_t j = *(void *)(a1 + 176); j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(unsigned char *)(j + 88) & 0x40) == 0)
    {
      xpc_object_t v18 = sub_100049138(j, 0);
      xpc_array_append_value(v13, v18);
      xpc_release(v18);
    }
  }
  for (uint64_t k = *(void *)(a1 + 184); k; uint64_t k = *(void *)(k + 16))
  {
    if ((*(unsigned char *)(k + 88) & 0x40) == 0)
    {
      int v20 = sub_100015DF0(v12, (const char *)(k + 168));
      xpc_object_t v21 = sub_100049138(k, v20);
      xpc_array_append_value(v13, v21);
      xpc_release(v21);
    }
  }
  if (xpc_array_get_count(v13)) {
    xpc_dictionary_set_value(v4, launch_perfcheck_property_endpoints, v13);
  }
  xpc_release(v13);
  uint64_t v22 = *(void *)(a1 + 256);
  if (!v22) {
    uint64_t v22 = a1;
  }
  xpc_dictionary_set_string(v4, "label", (const char *)(v22 + 1392));
  if ((*(unsigned char *)(a1 + 1381) & 2) != 0) {
    xpc_dictionary_set_uuid(v4, "instance", (const unsigned __int8 *)(a1 + 408));
  }
  xpc_dictionary_set_int64(v4, "jp-priority", *(int *)(a1 + 920));
  xpc_dictionary_set_value(v4, "additional-properties", *(xpc_object_t *)(a1 + 640));
  uint64_t v23 = (const char *)sub_10001E034(a1);
  xpc_dictionary_set_string(v4, "program", v23);
  xpc_dictionary_set_uint64(v4, "process-type", *(unsigned int *)(a1 + 896));
  xpc_dictionary_set_BOOL(v4, "keep-alive", (*(void *)(a1 + 1376) & 0xCLL) != 0);
  xpc_dictionary_set_BOOL(v4, "run-at-load", (*(void *)(a1 + 1376) & 0x10) != 0);
  xpc_dictionary_set_BOOL(v4, "enable-transactions", *(void *)(a1 + 1376) & 0x100);
  xpc_dictionary_set_uint64(v4, "service-type", *(unsigned __int8 *)(a1 + 356));
  xpc_dictionary_set_value(v4, "persist-to-boot-mode", *(xpc_object_t *)(a1 + 648));
  return v4;
}

uint64_t sub_100022804(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }

  return sub_10001E034(a1);
}

char *sub_10002284C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  uint64_t result = *(char **)(a1 + 1136);
  if (!result || *(unsigned __int16 *)(a1 + 1186) <= 1u)
  {
    uint64_t v3 = (char *)sub_10001E034(a1);
    uint64_t v4 = *(void *)(a1 + 1376);
    int64_t v5 = strrchr(v3, 47);
    int64_t v6 = v5;
    if ((v4 & 2) != 0)
    {
      if (v5)
      {
        uint64_t v7 = strrchr(v5, 46);
        if (v7) {
          uint64_t v3 = v7;
        }
        else {
          uint64_t v3 = v6;
        }
      }
    }
    else if (v5)
    {
      uint64_t v3 = v5;
    }
    return v3 + 1;
  }
  return result;
}

uint64_t sub_1000228F4(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return *(void *)(a1 + 584);
}

uint64_t sub_100022930(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return *(void *)(a1 + 576);
}

uint64_t sub_10002296C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return a1 + 408;
}

uint64_t sub_1000229A8(uint64_t a1)
{
  return a1 + 1200;
}

uint64_t sub_1000229B0(uint64_t a1, BOOL *a2)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  *a2 = (*(_DWORD *)(a1 + 1376) & 0x8000) != 0;
  return (*(unsigned __int8 *)(a1 + 1377) >> 6) & 1;
}

uint64_t sub_1000229FC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return (*(unsigned __int8 *)(a1 + 1192) >> 1) & 1;
}

uint64_t sub_100022A3C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  return *(unsigned char *)(a1 + 1381) & 1;
}

uint64_t sub_100022A7C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 1381) >> 3) & 1;
}

FILE *sub_100022A88(FILE *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (qword_100075D50)
  {
    uint64_t v9 = result;
    uint64_t v10 = a2 + 1;
    sub_100046780(result, a2 + 1, "pending global attachments = {", a4, a5, a6, a7, a8);
    xpc_object_t v16 = (void *)qword_100075D50;
    if (qword_100075D50)
    {
      uint64_t v17 = a2 + 2;
      do
      {
        sub_100046780(v9, v17, "%s", v11, v12, v13, v14, v15, v16[2]);
        xpc_object_t v16 = (void *)*v16;
      }
      while (v16);
    }
    return (FILE *)sub_100046780(v9, v10, "}", v11, v12, v13, v14, v15);
  }
  return result;
}

uint64_t sub_100022B50(uint64_t a1, FILE *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }

  return sub_100022B98(a1, a2, a3);
}

uint64_t sub_100022B98(uint64_t a1, FILE *a2, uint64_t a3)
{
  int64_t v6 = sub_1000203FC(a1, 1);
  sub_100046780(a2, a3, "%s = {", v7, v8, v9, v10, v11, v6);
  free(v6);
  uint64_t v17 = a3 + 1;
  if ((*(unsigned char *)(a1 + 1381) & 2) != 0) {
    sub_100046780(a2, a3 + 1, "original = %s", v12, v13, v14, v15, v16, *(void *)(a1 + 256) + 1392);
  }
  sub_100046780(a2, a3 + 1, "active size_t count = %d", v12, v13, v14, v15, v16, *(__int16 *)(a1 + 300));
  if (*(_DWORD *)(a1 + 264)) {
    sub_100046780(a2, a3 + 1, "copy size_t count = %d", v18, v19, v20, v21, v22, *(unsigned int *)(a1 + 264));
  }
  if (sub_10001E040(a1))
  {
    uint64_t v28 = sub_10001E040(a1);
    sub_100046780(a2, a3 + 1, "path = %s", v29, v30, v31, v32, v33, v28);
  }
  unsigned int v34 = *(unsigned __int8 *)(a1 + 356) - 1;
  if (v34 > 6) {
    uint64_t v35 = "Unknown";
  }
  else {
    uint64_t v35 = off_100070960[(char)v34];
  }
  sub_100046780(a2, a3 + 1, "xpc_type_t type = %s", v23, v24, v25, v26, v27, v35);
  uint64_t v41 = *(void *)(a1 + 344);
  if (v41)
  {
    uint64_t v42 = *(void **)(v41 + 48);
    if (v42)
    {
      xpc_type_t type = xpc_get_type(v42);
      if (type == (xpc_type_t)&_xpc_type_array)
      {
        sub_100046780(a2, a3 + 1, "managed_by = {", v36, v37, v38, v39, v40);
        uint64_t v49 = *(void **)(*(void *)(a1 + 344) + 48);
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000;
        applier[2] = sub_100029400;
        applier[3] = &unk_100070848;
        applier[4] = a2;
        void applier[5] = a3;
        xpc_array_apply(v49, applier);
        sub_100046780(a2, a3 + 1, "}", v50, v51, v52, v53, v54, v881);
      }
      else if (type == (xpc_type_t)&_xpc_type_string)
      {
        int64_t string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(*(void *)(a1 + 344) + 48));
        sub_100046780(a2, a3 + 1, "managed_by = %s", v44, v45, v46, v47, v48, string_ptr);
      }
    }
    uint64_t v55 = *(void *)(a1 + 344);
    if (v55 && *(void *)(v55 + 56))
    {
      sub_100046780(a2, a3 + 1, "managedby_services = {", v36, v37, v38, v39, v40);
      uint64_t v56 = *(void **)(*(void *)(a1 + 344) + 56);
      v908[0] = _NSConcreteStackBlock;
      v908[1] = 0x40000000;
      v908[2] = sub_100029450;
      v908[3] = &unk_100070868;
      v908[4] = a2;
      v908[5] = a3;
      xpc_array_apply(v56, v908);
      sub_100046780(a2, a3 + 1, "}", v57, v58, v59, v60, v61);
    }
  }
  LOBYTE(v883) = sub_1000252F8(a1);
  sub_100046780(a2, a3 + 1, "state = %s", v62, v63, v64, v65, v66);
  if (*(void *)(a1 + 576))
  {
    uint64_t v883 = *(void *)(a1 + 576);
    sub_100046780(a2, a3 + 1, "bundle id = %s", v69, v70, v71, v72, v73);
  }
  if ((*(unsigned char *)(a1 + 1380) & 4) != 0)
  {
    uint64_t v883 = *(void *)(a1 + 584);
    sub_100046780(a2, a3 + 1, "extension point = %s", v69, v70, v71, v72, v73);
  }
  int v74 = *(_DWORD *)(a1 + 704);
  if (v74)
  {
    *(_OWORD *)object_addr = 0u;
    long long v907 = 0u;
    DWORD1(v907) = v74;
    long long v912 = 0u;
    long long v913 = 0u;
    *(_OWORD *)object_xpc_type_t type = 0u;
    long long v911 = 0u;
    LOBYTE(v883) = sub_100042920((uint64_t)object_addr, (char *)object_type);
    uint64_t v899 = *(unsigned int *)(a1 + 704);
    sub_100046780(a2, a3 + 1, "controller = %s.%d", v75, v76, v77, v78, v79);
  }
  sub_100046800(a2, v67, v68, v69, v70, v71, v72, v73, v883);
  LOBYTE(v884) = sub_10001E034(a1);
  sub_100046780(a2, a3 + 1, "prograuint64_t m = %s", v80, v81, v82, v83, v84);
  if (*(void *)(a1 + 1256))
  {
    uint64_t v884 = *(void *)(a1 + 1256);
    sub_100046780(a2, a3 + 2, "+ %s", v85, v86, v87, v88, v89);
  }
  if (*(_DWORD *)(a1 + 428) || *(void *)(a1 + 1264))
  {
    sub_100046780(a2, a3 + 1, "arguments = {", v85, v86, v87, v88, v89);
    if (*(_DWORD *)(a1 + 428))
    {
      unint64_t v95 = 0;
      do
        sub_100046780(a2, a3 + 2, "%s", v90, v91, v92, v93, v94, *(void *)(*(void *)(a1 + 432) + 8 * v95++));
      while (v95 < *(unsigned int *)(a1 + 428));
    }
    sub_100046780(a2, a3 + 1, "}", v90, v91, v92, v93, v94);
    if (*(void *)(a1 + 1264))
    {
      sub_100046800(a2, v96, v97, v98, v99, v100, v101, v102, v884);
      sub_100046780(a2, a3 + 1, "controller-supplied arguments = {", v103, v104, v105, v106, v107);
      if (xpc_array_get_count(*(xpc_object_t *)(a1 + 1264)))
      {
        size_t v113 = 0;
        do
        {
          string = xpc_array_get_string(*(xpc_object_t *)(a1 + 1264), v113);
          if (string)
          {
            LOBYTE(v884) = (_BYTE)string;
            sub_100046780(a2, a3 + 2, "%s", v115, v116, v117, v118, v119);
          }
          ++v113;
        }
        while (v113 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1264)));
      }
      sub_100046780(a2, a3 + 1, "}", v108, v109, v110, v111, v112);
    }
    sub_100046800(a2, v96, v97, v98, v99, v100, v101, v102, v884);
  }
  uint64_t v120 = *(const char **)(a1 + 440);
  if (!v120)
  {
    if (!*(void *)(a1 + 1272)) {
      goto LABEL_46;
    }
    uint64_t v120 = "(unspecified)";
  }
  sub_100046780(a2, a3 + 1, "working directory = %s", v85, v86, v87, v88, v89, v120);
  if (*(void *)(a1 + 1272))
  {
    uint64_t v885 = *(void *)(a1 + 1272);
    sub_100046780(a2, a3 + 2, "+ %s", v123, v124, v125, v126, v127);
  }
  sub_100046800(a2, v121, v122, v123, v124, v125, v126, v127, v885);
LABEL_46:
  if (*(void *)(a1 + 448))
  {
    uint64_t v884 = *(void *)(a1 + 448);
    sub_100046780(a2, a3 + 1, "stdin path = %s", v85, v86, v87, v88, v89);
  }
  if (*(void *)(a1 + 456))
  {
    uint64_t v884 = *(void *)(a1 + 456);
    sub_100046780(a2, a3 + 1, "stdout path = %s", v85, v86, v87, v88, v89);
  }
  if (*(void *)(a1 + 464))
  {
    uint64_t v884 = *(void *)(a1 + 464);
    sub_100046780(a2, a3 + 1, "stderr path = %s", v85, v86, v87, v88, v89);
  }
  if (*(void *)(a1 + 472))
  {
    uint64_t v884 = *(void *)(a1 + 472);
    sub_100046780(a2, a3 + 1, "container id = %s", v85, v86, v87, v88, v89);
  }
  if (*(void *)(a1 + 480))
  {
    uint64_t v884 = *(void *)(a1 + 480);
    sub_100046780(a2, a3 + 1, "sandbox profile = %s", v85, v86, v87, v88, v89);
  }
  if (*(void *)(a1 + 488))
  {
    uint64_t v884 = *(void *)(a1 + 488);
    sub_100046780(a2, a3 + 1, "subsystem root = %s", v85, v86, v87, v88, v89);
  }
  if (*(void *)(a1 + 1280))
  {
    sub_100046780(a2, a3 + 1, "controller-supplied environment = {", v85, v86, v87, v88, v89);
    *(void *)object_xpc_type_t type = a2;
    *(void *)&object_type[2] = 0;
    *(void *)&long long v911 = a3 + 2;
    xpc_dictionary_apply_f();
    sub_100046780(a2, a3 + 1, "}", v128, v129, v130, v131, v132);
    sub_100046800(a2, v133, v134, v135, v136, v137, v138, v139, v884);
  }
  if (qword_100076AD0)
  {
    sub_100046780(a2, a3 + 1, "global environment = {", v85, v86, v87, v88, v89);
    uint64_t v145 = (void *)qword_100076AD0;
    if (qword_100076AD0)
    {
      do
      {
        sub_10001A358((uint64_t)v145, a3 + 2, a2);
        uint64_t v145 = (void *)*v145;
      }
      while (v145);
    }
    sub_100046780(a2, a3 + 1, "}", v140, v141, v142, v143, v144);
    sub_100046800(a2, v146, v147, v148, v149, v150, v151, v152, v884);
  }
  if (*(void *)(*(void *)(a1 + 248) + 96))
  {
    sub_100046780(a2, a3 + 1, "inherited environment = {", v85, v86, v87, v88, v89);
    for (uint64_t i = *(void **)(*(void *)(a1 + 248) + 96); i; uint64_t i = (void *)*i)
      sub_10001A358((uint64_t)i, a3 + 2, a2);
    sub_100046780(a2, a3 + 1, "}", v153, v154, v155, v156, v157);
    sub_100046800(a2, v159, v160, v161, v162, v163, v164, v165, v884);
  }
  if (qword_100076AD8)
  {
    sub_100046780(a2, a3 + 1, "default environment = {", v85, v86, v87, v88, v89);
    long long v171 = (void *)qword_100076AD8;
    if (qword_100076AD8)
    {
      do
      {
        sub_10001A358((uint64_t)v171, a3 + 2, a2);
        long long v171 = (void *)*v171;
      }
      while (v171);
    }
    sub_100046780(a2, a3 + 1, "}", v166, v167, v168, v169, v170);
    sub_100046800(a2, v172, v173, v174, v175, v176, v177, v178, v884);
  }
  if (*(_WORD *)(a1 + 1016))
  {
    sub_100046780(a2, a3 + 1, "environment = {", v85, v86, v87, v88, v89);
    for (uint64_t j = *(void **)(a1 + 1008); j; uint64_t j = (void *)*j)
      sub_10001A358((uint64_t)j, a3 + 2, a2);
    sub_100046780(a2, a3 + 1, "}", v179, v180, v181, v182, v183);
    sub_100046800(a2, v185, v186, v187, v188, v189, v190, v191, v884);
  }
  v192 = sub_10002A624(*(void *)(a1 + 248), 2);
  sub_100046780(a2, a3 + 1, "domaiuint64_t n = %s", v193, v194, v195, v196, v197, v192);
  free(v192);
  if (*(void *)(a1 + 800))
  {
    uint64_t v886 = *(void *)(a1 + 800);
    sub_100046780(a2, a3 + 1, "usermach_port_name_t name = %s", v198, v199, v200, v201, v202);
    uint64_t v205 = *(void *)(a1 + 808);
    if (!v205) {
      goto LABEL_81;
    }
  }
  else
  {
    uint64_t v205 = *(void *)(a1 + 808);
    if (!v205) {
      goto LABEL_82;
    }
  }
  sub_100046780(a2, a3 + 1, "group = %s", v198, v199, v200, v201, v202, v205);
LABEL_81:
  sub_100046800(a2, v203, v204, v198, v199, v200, v201, v202, v886);
LABEL_82:
  if (*(unsigned char *)(a1 + 1380)) {
    sub_100046780(a2, a3 + 1, "umasuint64_t k = %o", v198, v199, v200, v201, v202, *(unsigned __int16 *)(a1 + 816));
  }
  uint64_t v206 = sub_10001EA18(a1);
  sub_100046780(a2, a3 + 1, "minimum runtime = %u", v207, v208, v209, v210, v211, v206);
  if ((*(unsigned char *)(a1 + 1382) & 8) != 0) {
    sub_100046780(a2, a3 + 1, "base minimum runtime = %u", v212, v213, v214, v215, v216, *(unsigned int *)(a1 + 836));
  }
  sub_100046780(a2, a3 + 1, "exit timeout = %u", v212, v213, v214, v215, v216, *(unsigned int *)(a1 + 832));
  if ((*(unsigned char *)(a1 + 1380) & 4) != 0)
  {
    sub_100046780(a2, a3 + 1, "voluntary exit timeout = %u", v217, v218, v219, v220, v221, *(unsigned int *)(a1 + 864));
    if (byte_100076AC8) {
      sub_100046780(a2, a3 + 1, "launch watchdog timeout = %u", v222, v223, v224, v225, v226, *(unsigned int *)(a1 + 868));
    }
    else {
      sub_100046780(a2, a3 + 1, "launch watchdog timeout = (globally disabled)", v222, v223, v224, v225, v226, v887);
    }
  }
  if (*(void *)(a1 + 888)) {
    sub_100046780(a2, a3 + 1, "exception handler endpoint = %s", v217, v218, v219, v220, v221, *(void *)(a1 + 888));
  }
  sub_100046780(a2, a3 + 1, "runs = %u", v217, v218, v219, v220, v221, *(unsigned int *)(a1 + 1024));
  uint64_t v227 = sub_1000250FC(a1);
  uint64_t v233 = a1 + 1040;
  if (v227) {
    uint64_t v233 = v227;
  }
  v234 = (char *)*(unsigned int *)(v233 + 4);
  if (v234)
  {
    v888 = v234;
    sub_100046780(a2, a3 + 1, "successive crashes = %u", v228, v229, v230, v231, v232);
  }
  if (*(_DWORD *)(a1 + 1152))
  {
    sub_100046780(a2, a3 + 1, "pid = %d", v228, v229, v230, v231, v232, *(unsigned int *)(a1 + 1152));
    v235 = sub_100024E98(*(_DWORD *)(a1 + 1160));
    sub_100046780(a2, a3 + 1, "immediate reasouint64_t n = %s", v236, v237, v238, v239, v240, v235);
    sub_100046780(a2, a3 + 1, "forks = %hu", v241, v242, v243, v244, v245, *(unsigned __int16 *)(a1 + 1184));
    sub_100046780(a2, a3 + 1, "execs = %hu", v246, v247, v248, v249, v250, *(unsigned __int16 *)(a1 + 1186));
    v256 = (void *)(a1 + 1188);
    v257 = (*(void *)(a1 + 1188) & (unint64_t)&_mh_execute_header) != 0 ? "1" : "0";
    sub_100046780(a2, a3 + 1, "initialized = %s", v251, v252, v253, v254, v255, v257);
    v263 = (*v256 & 0x200000000) != 0 ? "1" : "0";
    sub_100046780(a2, a3 + 1, "trampolined = %s", v258, v259, v260, v261, v262, v263);
    v269 = (*v256 & 0x400000000) != 0 ? "1" : "0";
    sub_100046780(a2, a3 + 1, "started suspended = %s", v264, v265, v266, v267, v268, v269);
    v275 = (*v256 & 0x800000000) != 0 ? "1" : "0";
    sub_100046780(a2, a3 + 1, "proxy started suspended = %s", v270, v271, v272, v273, v274, v275);
    v281 = (*v256 & 0x8000000000) != 0 ? "1" : "0";
    sub_100046780(a2, a3 + 1, "uses proxy = %s", v276, v277, v278, v279, v280, v281);
    if ((*(unsigned char *)(a1 + 1380) & 4) != 0)
    {
      if ((*v256 & 0x4000000000) != 0) {
        v282 = "1";
      }
      else {
        v282 = "0";
      }
      sub_100046780(a2, a3 + 1, "extension alive = %s", v228, v229, v230, v231, v232, v282);
    }
  }
  unsigned int v283 = *(_DWORD *)(a1 + 288);
  if (v283)
  {
    v888 = sub_100024E98(v283);
    sub_100046780(a2, a3 + 1, "pended spawuint64_t n = %s", v284, v285, v286, v287, v288);
  }
  unsigned int v289 = *(_DWORD *)(a1 + 292);
  if (v289)
  {
    v888 = sub_100024E98(v289);
    sub_100046780(a2, a3 + 1, "pended nondemand spawuint64_t n = %s", v290, v291, v292, v293, v294);
  }
  unsigned int v295 = *(_DWORD *)(a1 + 1128);
  if (v295)
  {
    v888 = sub_100024E98(v295);
    sub_100046780(a2, a3 + 1, "spawn reason filter = %s", v296, v297, v298, v299, v300);
  }
  int v301 = *(_DWORD *)(a1 + 1200);
  switch(v301)
  {
    case 2:
      v302 = "last exit code = (failed reap)";
      goto LABEL_131;
    case 1:
      v302 = "last exit code = (abandoned)";
      goto LABEL_131;
    case 0:
      v302 = "last exit code = (never exited)";
LABEL_131:
      sub_100046780(a2, a3 + 1, v302, v228, v229, v230, v231, v232, v888, v899);
      goto LABEL_132;
  }
  if (sub_100046FC4((_DWORD *)(a1 + 1200)))
  {
    int v303 = sub_10004700C((_DWORD *)(a1 + 1200));
    v888 = strsignal(v303);
    v302 = "last terminating signal = %s";
    goto LABEL_131;
  }
  if (sub_100046EEC(a1 + 1200))
  {
    uint64_t v454 = sub_100046F18((_DWORD *)(a1 + 1200));
    if ((v454 - 64) > 0xE) {
      sub_100046780(a2, a3 + 1, "last exit code = %d", v455, v456, v457, v458, v459, v454, v899);
    }
    else {
      sub_100046780(a2, a3 + 1, "last exit code = %d: %s", v455, v456, v457, v458, v459, v454, off_100070660[(v454 - 64)]);
    }
  }
  else
  {
    if (sub_1000471B4(a1 + 1200))
    {
      v302 = "last exit code = (extension watchdogged)";
      goto LABEL_131;
    }
    v874 = sub_100046DC4(a1 + 1200);
    v880 = "(unknown)";
    if (v874) {
      v880 = v874;
    }
    sub_100046780(a2, a3 + 1, "last exit reasouint64_t n = %s", v875, v876, v877, v878, v879, v880, v899);
  }
LABEL_132:
  if (sub_1000470FC((_DWORD *)(a1 + 1200)))
  {
    v311 = sub_100046DC4(a1 + 1200);
    v317 = "(unknown)";
    if (v311) {
      v317 = v311;
    }
    sub_100046780(a2, a3 + 1, "last jetsam exit details = %s", v312, v313, v314, v315, v316, v317);
  }
  if (*(void *)(a1 + 672))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "semaphores = {", v318, v319, v320, v321, v322);
    for (uint64_t k = *(uint64_t ***)(a1 + 672); k; uint64_t k = (uint64_t **)*k)
    {
      long long v924 = 0u;
      long long v925 = 0u;
      long long v922 = 0u;
      long long v923 = 0u;
      long long v920 = 0u;
      long long v921 = 0u;
      long long v918 = 0u;
      long long v919 = 0u;
      long long v916 = 0u;
      long long v917 = 0u;
      long long v914 = 0u;
      long long v915 = 0u;
      long long v912 = 0u;
      long long v913 = 0u;
      *(_OWORD *)object_xpc_type_t type = 0u;
      long long v911 = 0u;
      sub_100046780(a2, a3 + 2, "%s%s => %u", v323, v324, v325, v326, v327, k[3], object_type, *((unsigned __int8 *)k + 32));
    }
    sub_100046780(a2, a3 + 1, "}", v323, v324, v325, v326, v327);
  }
  if (*(void *)(a1 + 136))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "event triggers = {", v329, v330, v331, v332, v333);
    for (uint64_t m = *(void *)(a1 + 136); m; uint64_t m = *(void *)(m + 16))
      sub_10003D2A4(m, a2, a3 + 2, v334, v335, v336, v337, v338);
    sub_100046780(a2, a3 + 1, "}", v334, v335, v336, v337, v338);
  }
  if (*(void *)(a1 + 152))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "endpoints = {", v340, v341, v342, v343, v344);
    for (uint64_t n = *(void *)(a1 + 152); n; uint64_t n = *(void *)(n + 16))
    {
      if ((*(unsigned char *)(n + 88) & 0x40) == 0) {
        sub_10004953C(n, a2, a3 + 2, v345, v346, v347, v348, v349);
      }
    }
    sub_100046780(a2, a3 + 1, "}", v345, v346, v347, v348, v349);
  }
  if (*(void *)(a1 + 160))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "dynamic endpoints = {", v351, v352, v353, v354, v355);
    for (iuint64_t i = *(void *)(a1 + 160); ii; iuint64_t i = *(void *)(ii + 16))
    {
      if ((*(unsigned char *)(ii + 88) & 0x40) == 0) {
        sub_10004953C(ii, a2, a3 + 2, v356, v357, v358, v359, v360);
      }
    }
    sub_100046780(a2, a3 + 1, "}", v356, v357, v358, v359, v360);
  }
  if (*(void *)(a1 + 168))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "pid-local endpoints = {", v362, v363, v364, v365, v366);
    for (juint64_t j = *(void *)(a1 + 168); jj; juint64_t j = *(void *)(jj + 16))
    {
      if ((*(unsigned char *)(jj + 88) & 0x40) == 0) {
        sub_10004953C(jj, a2, a3 + 2, v367, v368, v369, v370, v371);
      }
    }
    sub_100046780(a2, a3 + 1, "}", v367, v368, v369, v370, v371);
  }
  if (*(void *)(a1 + 184))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "instance-specific endpoints = {", v373, v374, v375, v376, v377);
    for (kuint64_t k = *(void *)(a1 + 184); kk; kuint64_t k = *(void *)(kk + 16))
    {
      if ((*(unsigned char *)(kk + 88) & 0x40) == 0) {
        sub_10004953C(kk, a2, a3 + 2, v378, v379, v380, v381, v382);
      }
    }
    sub_100046780(a2, a3 + 1, "}", v378, v379, v380, v381, v382);
  }
  if (*(void *)(a1 + 176))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "event channels = {", v384, v385, v386, v387, v388);
    for (muint64_t m = *(void *)(a1 + 176); mm; muint64_t m = *(void *)(mm + 16))
    {
      if ((*(unsigned char *)(mm + 88) & 0x40) == 0) {
        sub_10004953C(mm, a2, a3 + 2, v389, v390, v391, v392, v393);
      }
    }
    sub_100046780(a2, a3 + 1, "}", v389, v390, v391, v392, v393);
  }
  if (*(void *)(a1 + 192))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "sockets = {", v395, v396, v397, v398, v399);
    for (nuint64_t n = *(void *)(a1 + 192); nn; nuint64_t n = *(void *)(nn + 16))
      sub_10001D128(nn, a2, a3 + 2, v400, v401, v402, v403, v404);
    sub_100046780(a2, a3 + 1, "}", v400, v401, v402, v403, v404);
  }
  if (*(void *)(a1 + 200))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "instances = {", v406, v407, v408, v409, v410);
    for (uint64_t i1 = *(void *)(a1 + 200); i1; uint64_t i1 = *(void *)(i1 + 40))
      sub_100046780(a2, a3 + 2, "%s,", v411, v412, v413, v414, v415, i1 + 1392);
    sub_100046780(a2, a3 + 1, "}", v411, v412, v413, v414, v415);
  }
  if (*(void *)(a1 + 648))
  {
    sub_100046800(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_100046780(a2, a3 + 1, "persist to boot modes = {", v417, v418, v419, v420, v421);
    v422 = *(void **)(a1 + 648);
    v905[0] = _NSConcreteStackBlock;
    v905[1] = 0x40000000;
    v905[2] = sub_100029514;
    v905[3] = &unk_100070888;
    v905[4] = a2;
    v905[5] = a3;
    xpc_array_apply(v422, v905);
    sub_100046780(a2, a3 + 1, "}", v423, v424, v425, v426, v427);
  }
  if (*(void *)(a1 + 1384)) {
    v428 = "1";
  }
  else {
    v428 = "0";
  }
  sub_100046780(a2, a3 + 1, "retain only = %s", v306, v307, v308, v309, v310, v428);
  sub_100046800(a2, v429, v430, v431, v432, v433, v434, v435, v890);
  mach_port_name_t v441 = *(_DWORD *)(a1 + 1340);
  if (v441 + 1 >= 2)
  {
    object_type[0] = 0;
    object_addr[0] = 0;
    if (mach_port_kernel_object(mach_task_self_, v441, object_type, object_addr)) {
      sub_100046780(a2, a3 + 1, "dext checkin port = %#x [unable to get port information]", v442, v443, v444, v445, v446, *(unsigned int *)(a1 + 1340), v900, v903);
    }
    else {
      sub_100046780(a2, a3 + 1, "dext checkin port = %#x [type %u, object %#x]", v442, v443, v444, v445, v446, *(unsigned int *)(a1 + 1340), object_type[0], object_addr[0]);
    }
    sub_100046800(a2, v447, v448, v449, v450, v451, v452, v453, v892);
  }
  unint64_t v460 = *(unsigned int *)(a1 + 896);
  if (v460 >= 0x100)
  {
    unint64_t v461 = v460 >> 8;
    if (v460 > 0x6FF) {
      v462 = "";
    }
    else {
      v462 = (const char *)qword_1000708A8[v461];
    }
    sub_100046780(a2, a3 + 1, "spawn xpc_type_t type = %s (%lu)", v436, v437, v438, v439, v440, v462, v461);
  }
  uint64_t v463 = *(unsigned int *)(a1 + 900);
  if (v463)
  {
    if (v463 > 6) {
      v464 = "";
    }
    else {
      v464 = (const char *)qword_1000708E0[v463];
    }
    sub_100046780(a2, a3 + 1, "spawn role = %s (%lu)", v436, v437, v438, v439, v440, v464, v463);
  }
  uint64_t v904 = a3 + 1;
  if (*(void *)(a1 + 904) || *(void *)(a1 + 1288))
  {
    sub_100046780(a2, a3 + 1, "binary order preference = {", v436, v437, v438, v439, v440);
    uint64_t v470 = *(void *)(a1 + 904);
    if (v470 && xpc_binprefs_count(*(void *)(a1 + 904)))
    {
      unsigned int v471 = 0;
      do
      {
        int v472 = xpc_binprefs_cpu_type(v470, v471);
        v478 = "(invalid)";
        if ((v472 & 0xFEFFFFFF) - 1 <= 0x11)
        {
          v479 = &off_1000706F8[v472 & 0xFEFFFFFF];
          if ((v472 & 0x1000000) == 0) {
            v479 = &off_100070790[v472];
          }
          v478 = *v479;
        }
        sub_100046780(a2, a3 + 2, "%s", v473, v474, v475, v476, v477, v478);
        ++v471;
      }
      while (v471 < xpc_binprefs_count(v470));
    }
    uint64_t v480 = *(void *)(a1 + 1288);
    if (v480 && xpc_binprefs_count(*(void *)(a1 + 1288)))
    {
      unsigned int v481 = 0;
      do
      {
        int v482 = xpc_binprefs_cpu_type(v480, v481);
        v488 = "(invalid)";
        if ((v482 & 0xFEFFFFFF) - 1 <= 0x11)
        {
          v489 = &off_1000706F8[v482 & 0xFEFFFFFF];
          if ((v482 & 0x1000000) == 0) {
            v489 = &off_100070790[v482];
          }
          v488 = *v489;
        }
        sub_100046780(a2, a3 + 2, "+ %s", v483, v484, v485, v486, v487, v488);
        ++v481;
      }
      while (v481 < xpc_binprefs_count(v480));
    }
    uint64_t v17 = a3 + 1;
    sub_100046780(a2, v904, "}", v465, v466, v467, v468, v469);
    sub_100046800(a2, v490, v491, v492, v493, v494, v495, v496, v891);
  }
  sub_100046780(a2, v17, "jetsam priority = %d", v436, v437, v438, v439, v440, *(unsigned int *)(a1 + 920));
  if ((*(_DWORD *)(a1 + 1312) & 0x80000000) == 0) {
    sub_100046780(a2, v17, "+ %d", v497, v498, v499, v500, v501, *(unsigned int *)(a1 + 1312));
  }
  int v502 = *(_DWORD *)(a1 + 924);
  if (v502 >= 1)
  {
    if ((*(_DWORD *)(a1 + 916) & 4) != 0) {
      v503 = "hard";
    }
    else {
      v503 = "soft";
    }
    v893 = v503;
    uint64_t v900 = *(unsigned int *)(a1 + 924);
LABEL_231:
    v504 = "jetsam memory limit (active, %s) = %d MB";
    goto LABEL_234;
  }
  if (!v502)
  {
    if ((*(_DWORD *)(a1 + 916) & 4) != 0) {
      v872 = "hard";
    }
    else {
      v872 = "soft";
    }
    v893 = v872;
    uint64_t v900 = 0xFFFFFFFFLL;
    goto LABEL_231;
  }
  v504 = "jetsam memory limit (active) = (unlimited)";
LABEL_234:
  sub_100046780(a2, v17, v504, v497, v498, v499, v500, v501, v893, v900);
  int v510 = *(_DWORD *)(a1 + 1316);
  if (v510 >= 1)
  {
    v894 = (const char *)*(unsigned int *)(a1 + 1316);
    v511 = "+ %d MB";
LABEL_236:
    sub_100046780(a2, v17, v511, v505, v506, v507, v508, v509, v894);
    goto LABEL_238;
  }
  if (v510 < 0)
  {
    v511 = "+ (unlimited)";
    goto LABEL_236;
  }
LABEL_238:
  int v512 = *(_DWORD *)(a1 + 928);
  if (v512 >= 1)
  {
    if ((*(_DWORD *)(a1 + 916) & 8) != 0) {
      v513 = "hard";
    }
    else {
      v513 = "soft";
    }
    v894 = v513;
    uint64_t v901 = *(unsigned int *)(a1 + 928);
LABEL_243:
    v514 = "jetsam memory limit (inactive, %s) = %d MB";
    goto LABEL_246;
  }
  if (!v512)
  {
    if ((*(_DWORD *)(a1 + 916) & 8) != 0) {
      v873 = "hard";
    }
    else {
      v873 = "soft";
    }
    v894 = v873;
    uint64_t v901 = 0xFFFFFFFFLL;
    goto LABEL_243;
  }
  v514 = "jetsam memory limit (inactive) = (unlimited)";
LABEL_246:
  sub_100046780(a2, v17, v514, v505, v506, v507, v508, v509, v894, v901);
  int v520 = *(_DWORD *)(a1 + 1316);
  if (v520 >= 1)
  {
    uint64_t v895 = *(unsigned int *)(a1 + 1316);
    v521 = "+ %d MB";
LABEL_248:
    sub_100046780(a2, v17, v521, v515, v516, v517, v518, v519, v895);
    goto LABEL_250;
  }
  if (v520 < 0)
  {
    v521 = "+ (unlimited)";
    goto LABEL_248;
  }
LABEL_250:
  v896 = sub_100024B78(a1);
  sub_100046780(a2, v17, "jetsamproperties category = %s", v522, v523, v524, v525, v526);
  if ((*(unsigned char *)(a1 + 1381) & 4) != 0) {
    sub_100046780(a2, v17, "submitted job. ignore execute allowed", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 932))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 932);
    sub_100046780(a2, v17, "jetsam thread limit = %d", v527, v528, v529, v530, v531);
  }
  if (*(void *)(a1 + 936))
  {
    v896 = *(const char **)(a1 + 936);
    sub_100046780(a2, v17, "jetsam address limit = %llu", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 944))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 944);
    sub_100046780(a2, v17, "jetsam soft port limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 948))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 948);
    sub_100046780(a2, v17, "jetsam hard port limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 952))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 952);
    sub_100046780(a2, v17, "jetsam soft file descriptor limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 956))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 956);
    sub_100046780(a2, v17, "jetsam hard file descriptor limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 960))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 960);
    sub_100046780(a2, v17, "jetsam soft kqworkloop limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 964))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 964);
    sub_100046780(a2, v17, "jetsam hard kqworkloop limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 968))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 968);
    sub_100046780(a2, v17, "jetsam wired memory limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(unsigned char *)(a1 + 1018) || *(_DWORD *)(a1 + 1020))
  {
    v896 = (const char *)*(unsigned __int8 *)(a1 + 1018);
    uint64_t v902 = *(unsigned int *)(a1 + 1020);
    v532 = "cpumouint64_t n = %d%% over %u seconds";
  }
  else
  {
    v532 = "cpumouint64_t n = default";
  }
  sub_100046780(a2, v17, v532, v527, v528, v529, v530, v531, v896, v902);
  if (*(void *)(a1 + 680))
  {
    sub_100046780(a2, v17, "resource limits = {", v533, v534, v535, v536, v537);
    v543 = *(uint64_t **)(a1 + 680);
    if (v543)
    {
      uint64_t v544 = a3 + 2;
      do
      {
        if (*((unsigned char *)v543 + 35))
        {
          long long v912 = 0u;
          long long v913 = 0u;
          *(_OWORD *)object_xpc_type_t type = 0u;
          long long v911 = 0u;
          if (v543[2] == 0x7FFFFFFFFFFFFFFFLL) {
            strcpy((char *)object_type, "(infinity)");
          }
          else {
            snprintf((char *)object_type, 0x40uLL, "%llu", v543[2]);
          }
          char v897 = sub_100043124(*((unsigned __int16 *)v543 + 16));
          sub_100046780(a2, v544, "%s (soft) => %s", v545, v546, v547, v548, v549);
        }
        if (*((unsigned char *)v543 + 34))
        {
          long long v912 = 0u;
          long long v913 = 0u;
          *(_OWORD *)object_xpc_type_t type = 0u;
          long long v911 = 0u;
          if (v543[3] == 0x7FFFFFFFFFFFFFFFLL) {
            strcpy((char *)object_type, "(infinity)");
          }
          else {
            snprintf((char *)object_type, 0x40uLL, "%llu", v543[3]);
          }
          char v897 = sub_100043124(*((unsigned __int16 *)v543 + 16));
          sub_100046780(a2, v544, "%s (hard) => %s", v550, v551, v552, v553, v554);
        }
        v543 = (uint64_t *)*v543;
      }
      while (v543);
    }
    uint64_t v17 = a3 + 1;
    sub_100046780(a2, v904, "}", v538, v539, v540, v541, v542);
    sub_100046800(a2, v555, v556, v557, v558, v559, v560, v561, v897);
  }
  if (*(_DWORD *)(a1 + 880)) {
    sub_100046780(a2, v17, "run interval = %u seconds", v533, v534, v535, v536, v537, *(unsigned int *)(a1 + 880));
  }
  if ((*(unsigned char *)(a1 + 1382) & 8) != 0) {
    sub_100046780(a2, v17, "exponential throttling grace limit = %u", v533, v534, v535, v536, v537, *(unsigned __int16 *)(a1 + 1028));
  }
  v562 = sub_1000401CC(a1);
  if (v562) {
    sub_100046780(a2, v17, "job state = %s", v563, v564, v565, v566, v567, v562);
  }
  uint64_t v568 = *(void *)(a1 + 1376);
  if ((v568 & 0x400000000000) != 0)
  {
    sub_100046780(a2, v17, "persona set at = %u", v563, v564, v565, v566, v567, *(unsigned int *)(a1 + 1328));
    uint64_t v568 = *(void *)(a1 + 1376);
  }
  if ((v568 & 0x2000000000000) == 0)
  {
    if (*(_DWORD *)(a1 + 720) != -101) {
      sub_100046780(a2, v17, "resolved uid = %d", v563, v564, v565, v566, v567, *(unsigned int *)(a1 + 720));
    }
    if (*(_DWORD *)(a1 + 724) != -101)
    {
      sub_100046780(a2, v17, "resolved gid = %d", v563, v564, v565, v566, v567, *(unsigned int *)(a1 + 724));
      if (*(_DWORD *)(a1 + 792))
      {
        sub_100046780(a2, v17, "resolved groups = {", v563, v564, v565, v566, v567);
        if (*(int *)(a1 + 792) >= 1)
        {
          uint64_t v574 = 0;
          do
            sub_100046780(a2, a3 + 2, "%d", v569, v570, v571, v572, v573, *(unsigned int *)(a1 + 728 + 4 * v574++));
          while (v574 < *(int *)(a1 + 792));
        }
        sub_100046780(a2, v17, "}", v569, v570, v571, v572, v573);
      }
    }
  }
  if (*(unsigned char *)(a1 + 1030)) {
    sub_100046780(a2, v17, "crash behavior = %x", v563, v564, v565, v566, v567, *(unsigned __int8 *)(a1 + 1030));
  }
  if ((*(unsigned char *)(a1 + 1383) & 8) != 0)
  {
    uint64_t v575 = sub_1000250FC(a1);
    uint64_t v581 = a1 + 1040;
    if (v575) {
      uint64_t v581 = v575;
    }
    size_t count = *(void **)(v581 + 24);
    if (count) {
      size_t count = (void *)xpc_array_get_count(count);
    }
    sub_100046780(a2, v17, "panic on consecutive crashes (%zd)", v576, v577, v578, v579, v580, count);
  }
  sub_100046780(a2, v17, "probabilistic guard malloc policy = {", v563, v564, v565, v566, v567);
  sub_100046780(a2, a3 + 2, "activation rate = 1/%u", v583, v584, v585, v586, v587, *(unsigned int *)(a1 + 1352));
  LODWORD(v898) = *(_DWORD *)(a1 + 1348);
  sub_100046780(a2, a3 + 2, "sample rate = 1/%u", v588, v589, v590, v591, v592);
  sub_100046780(a2, v17, "}", v593, v594, v595, v596, v597);
  int v603 = *(unsigned __int8 *)(a1 + 1344);
  if (*(unsigned char *)(a1 + 1344))
  {
    if (v603 == 1) {
      v604 = "1";
    }
    else {
      v604 = "0";
    }
    if (v603 == 2) {
      v605 = "managed";
    }
    else {
      v605 = v604;
    }
    sub_100046780(a2, v17, "multiple instances = %s", v598, v599, v600, v601, v602, v605);
  }
  if (*(void *)(a1 + 1360))
  {
    uint64_t v898 = *(void *)(a1 + 1360);
    sub_100046780(a2, v17, "cryptex = %s", v598, v599, v600, v601, v602);
  }
  if (*(void *)(a1 + 1368))
  {
    uint64_t v898 = *(void *)(a1 + 1368);
    sub_100046780(a2, v17, "conclave = %s", v598, v599, v600, v601, v602);
  }
  v606 = (void **)sub_100010724(0x80uLL);
  sub_10002958C((uint64_t)v606, (char)"partial import", *(_DWORD *)(a1 + 1376) & 1, v607, v608, v609, v610, v611);
  sub_10002958C((uint64_t)v606, (char)"xpc bundle", (*(void *)(a1 + 1376) >> 1) & 1, v612, v613, v614, v615, v616);
  sub_10002958C((uint64_t)v606, (char)"keepalive", (*(void *)(a1 + 1376) >> 2) & 1, v617, v618, v619, v620, v621);
  sub_10002958C((uint64_t)v606, (char)"runatload", (*(void *)(a1 + 1376) >> 4) & 1, v622, v623, v624, v625, v626);
  sub_10002958C((uint64_t)v606, (char)"low priority i/o", (*(void *)(a1 + 1376) >> 5) & 1, v627, v628, v629, v630, v631);
  sub_10002958C((uint64_t)v606, (char)"low priority background i/o", (*(void *)(a1 + 1376) >> 6) & 1, v632, v633, v634, v635, v636);
  sub_10002958C((uint64_t)v606, (char)"dataless file mode", *(unsigned char *)(a1 + 1332) != 0, v637, v638, v639, v640, v641);
  sub_10002958C((uint64_t)v606, (char)"exception handler", (*(void *)(a1 + 1376) >> 7) & 1, v642, v643, v644, v645, v646);
  sub_10002958C((uint64_t)v606, (char)"supports transactions", (*(void *)(a1 + 1376) >> 8) & 1, v647, v648, v649, v650, v651);
  sub_10002958C((uint64_t)v606, (char)"supports pressured exit", (*(void *)(a1 + 1376) >> 9) & 1, v652, v653, v654, v655, v656);
  sub_10002958C((uint64_t)v606, (char)"supports idle hysteresis", (*(void *)(a1 + 1376) >> 47) & 1, v657, v658, v659, v660, v661);
  sub_10002958C((uint64_t)v606, (char)"enter kdp before kill", (*(void *)(a1 + 1376) >> 10) & 1, v662, v663, v664, v665, v666);
  sub_10002958C((uint64_t)v606, (char)"wait for debugger", (*(void *)(a1 + 1376) >> 11) & 1, v667, v668, v669, v670, v671);
  sub_10002958C((uint64_t)v606, (char)"app", (*(void *)(a1 + 1376) >> 12) & 1, v672, v673, v674, v675, v676);
  sub_10002958C((uint64_t)v606, (char)"system app", (*(void *)(a1 + 1376) >> 13) & 1, v677, v678, v679, v680, v681);
  sub_10002958C((uint64_t)v606, (char)"inetd-compatible", (*(void *)(a1 + 1376) >> 14) & 1, v682, v683, v684, v685, v686);
  sub_10002958C((uint64_t)v606, (char)"inetd listener", (*(void *)(a1 + 1376) >> 15) & 1, v687, v688, v689, v690, v691);
  sub_10002958C((uint64_t)v606, (char)"abandon process group", (*(void *)(a1 + 1376) >> 16) & 1, v692, v693, v694, v695, v696);
  sub_10002958C((uint64_t)v606, (char)"event monitor", (*(void *)(a1 + 1376) >> 17) & 1, v697, v698, v699, v700, v701);
  sub_10002958C((uint64_t)v606, (char)"penalty box", (*(void *)(a1 + 1376) >> 18) & 1, v702, v703, v704, v705, v706);
  sub_10002958C((uint64_t)v606, (char)"role account", (*(void *)(a1 + 1376) >> 19) & 1, v707, v708, v709, v710, v711);
  sub_10002958C((uint64_t)v606, (char)"launch only once", (*(void *)(a1 + 1376) >> 20) & 1, v712, v713, v714, v715, v716);
  sub_10002958C((uint64_t)v606, (char)"system support", (*(void *)(a1 + 1376) >> 21) & 1, v717, v718, v719, v720, v721);
  sub_10002958C((uint64_t)v606, (char)"initial system support", (*(void *)(a1 + 1376) >> 22) & 1, v722, v723, v724, v725, v726);
  sub_10002958C((uint64_t)v606, (char)"inferred program", (*(void *)(a1 + 1376) >> 24) & 1, v727, v728, v729, v730, v731);
  sub_10002958C((uint64_t)v606, (char)"ios home screen app", (*(void *)(a1 + 1376) >> 29) & 1, v732, v733, v734, v735, v736);
  sub_10002958C((uint64_t)v606, (char)"abandon coalition", (*(void *)(a1 + 1376) >> 30) & 1, v737, v738, v739, v740, v741);
  sub_10002958C((uint64_t)v606, (char)"disable pointer auth", (*(void *)(a1 + 1376) >> 55) & 1, v742, v743, v744, v745, v746);
  sub_10002958C((uint64_t)v606, (char)"high bits aslr", (*(void *)(a1 + 1376) >> 33) & 1, v747, v748, v749, v750, v751);
  uint64_t v752 = sub_1000250FC(a1);
  v758 = (unsigned __int8 *)(a1 + 1040);
  if (v752) {
    v758 = (unsigned __int8 *)v752;
  }
  sub_10002958C((uint64_t)v606, (char)"reslide shared cache", *v758, v753, v754, v755, v756, v757);
  sub_10002958C((uint64_t)v606, (char)"disable resliding", (*(void *)(a1 + 1376) >> 53) & 1, v759, v760, v761, v762, v763);
  sub_10002958C((uint64_t)v606, (char)"extension", (*(void *)(a1 + 1376) >> 34) & 1, v764, v765, v766, v767, v768);
  sub_10002958C((uint64_t)v606, (char)"nano allocator", (*(void *)(a1 + 1376) >> 25) & 1, v769, v770, v771, v772, v773);
  sub_10002958C((uint64_t)v606, (char)"enable sec_transition shim", (*(void *)(a1 + 1376) >> 26) & 1, v774, v775, v776, v777, v778);
  sub_10002958C((uint64_t)v606, (char)"no initgroups", (*(void *)(a1 + 1376) >> 31) & 1, v779, v780, v781, v782, v783);
  sub_10002958C((uint64_t)v606, (char)"needs implicit endpoint", (*(void *)(a1 + 1376) >> 38) & 1, v784, v785, v786, v787, v788);
  sub_10002958C((uint64_t)v606, (char)"platform binary", (*(void *)(a1 + 1376) >> 40) & 1, v789, v790, v791, v792, v793);
  sub_10002958C((uint64_t)v606, (char)"is copy", (*(void *)(a1 + 1376) >> 41) & 1, v794, v795, v796, v797, v798);
  sub_10002958C((uint64_t)v606, (char)"disallow all lookups", (*(void *)(a1 + 1376) >> 43) & 1, v799, v800, v801, v802, v803);
  sub_10002958C((uint64_t)v606, (char)"always sigterm on shutdown", (*(void *)(a1 + 1376) >> 45) & 1, v804, v805, v806, v807, v808);
  sub_10002958C((uint64_t)v606, (char)"one-shot", (*(_DWORD *)(a1 + 368) >> 5) & 1, v809, v810, v811, v812, v813);
  sub_10002958C((uint64_t)v606, (char)"use maximum address space limit (for sanitizers)", HIWORD(*(void *)(a1 + 1376)) & 1, v814, v815, v816, v817, v818);
  sub_10002958C((uint64_t)v606, (char)"null bootstrap port", (*(void *)(a1 + 1376) >> 50) & 1, v819, v820, v821, v822, v823);
  sub_10002958C((uint64_t)v606, (char)"exponential throttling", (*(void *)(a1 + 1376) >> 51) & 1, v824, v825, v826, v827, v828);
  sub_10002958C((uint64_t)v606, (char)"abandon during shutdown", HIBYTE(*(void *)(a1 + 1376)) & 1, v829, v830, v831, v832, v833);
  sub_10002958C((uint64_t)v606, (char)"needs proxy", (*(void *)(a1 + 1376) >> 49) & 1, v834, v835, v836, v837, v838);
  sub_10002958C((uint64_t)v606, (char)"has spawn constraint", *(_DWORD *)(a1 + 624) != 0, v839, v840, v841, v842, v843);
  sub_10002958C((uint64_t)v606, (char)"tle system", *(unsigned __int8 *)(a1 + 984) == 1, v844, v845, v846, v847, v848);
  sub_10002958C((uint64_t)v606, (char)"has provenance", *(_DWORD *)(a1 + 608) != 0, v849, v850, v851, v852, v853);
  sub_100046800(a2, v854, v855, v856, v857, v858, v859, v860, v898);
  sub_100046780(a2, v17, "properties = %s", v861, v862, v863, v864, v865, *v606);
  sub_100010778(v606);
  return sub_100046780(a2, a3, "}", v866, v867, v868, v869, v870);
}

const char *sub_100024B78(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1376);
  if ((v1 & 0x400000000) != 0) {
    return "extension";
  }
  if ((v1 & 2) != 0)
  {
    if (sub_10002A744(*(void *)(a1 + 248))) {
      return "system xpcservice";
    }
    else {
      return "xpcservice";
    }
  }
  else if ((v1 & 0x2000) != 0)
  {
    return "system app";
  }
  else if ((v1 & 0x1000) != 0)
  {
    return "app";
  }
  else if (*(_DWORD *)(a1 + 896) == 1792)
  {
    return "DriverKit";
  }
  else
  {
    return "daemon";
  }
}

uint64_t sub_100024C04(uint64_t a1, FILE *a2, uint64_t a3)
{
  uint64_t v4 = a3 + 1;
  uint64_t v5 = a1 + 1392;
  int64_t v6 = sub_100024B78(a1);
  return sub_100046780(a2, v4, "%s : %s", v7, v8, v9, v10, v11, v5, v6);
}

uint64_t sub_100024C58(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296)) {
    sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  }
  *(void *)__str = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  if (*(_DWORD *)(a1 + 1152)) {
    snprintf(__str, 0x18uLL, "%d", *(_DWORD *)(a1 + 1152));
  }
  else {
    strcpy(__str, "0");
  }
  *(void *)uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  int v11 = *(_DWORD *)(a1 + 1200);
  if (v11 == 2)
  {
    v15[4] = 0;
    int v13 = 695363112;
    goto LABEL_12;
  }
  if (v11 == 1)
  {
    v15[4] = 0;
    int v13 = 694313256;
    goto LABEL_12;
  }
  if (v11)
  {
    if (sub_100046EEC(a1 + 1200))
    {
      sub_100046F18((_DWORD *)(a1 + 1200));
      snprintf(v15, 0x18uLL, "%d");
      return sub_100046780(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
    }
    if (sub_100046FC4((_DWORD *)(a1 + 1200)))
    {
      sub_10004700C((_DWORD *)(a1 + 1200));
      snprintf(v15, 0x18uLL, "-%d");
      return sub_100046780(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
    }
    if (sub_1000470FC((_DWORD *)(a1 + 1200)))
    {
      v15[4] = 0;
      if (sub_100047144(a1 + 1200)) {
        int v13 = 694513704;
      }
      else {
        int v13 = 695495208;
      }
    }
    else if (sub_10004719C((_DWORD *)(a1 + 1200)))
    {
      v15[4] = 0;
      int v13 = 695427880;
    }
    else
    {
      if (!sub_100047170(a1 + 1200))
      {
        __int16 v12 = 63;
        goto LABEL_9;
      }
      v15[4] = 0;
      int v13 = 695232040;
    }
LABEL_12:
    *(_DWORD *)uint64_t v15 = v13;
    return sub_100046780(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
  }
  __int16 v12 = 45;
LABEL_9:
  *(_WORD *)uint64_t v15 = v12;
  return sub_100046780(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
}

uint64_t sub_100024E50(uint64_t a1, const char *a2)
{
  for (uint64_t i = *(void *)(a1 + 144); i; uint64_t i = *(void *)(i + 16))
  {
    uint64_t v4 = (const char *)sub_10003D030(i);
    if (!strcmp(v4, a2)) {
      break;
    }
  }
  return i;
}

char *sub_100024E98(unsigned int a1)
{
  if (a1 >= 0x11) {
    sub_100050D0C();
  }
  return off_100070558[a1];
}

uint64_t sub_100024EC4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1128) = a2;
  return result;
}

BOOL sub_100024ECC(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 1128);
  if (v2) {
    BOOL v3 = v2 == a2;
  }
  else {
    BOOL v3 = 1;
  }
  return !v3;
}

BOOL sub_100024EE0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1128) != 0;
}

uint64_t sub_100024EF0(uint64_t a1, unsigned __int8 *uu1)
{
  for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 40))
  {
    if (!uuid_compare(uu1, (const unsigned __int8 *)(i + 408))) {
      break;
    }
  }
  return i;
}

uint64_t sub_100024F34(mach_port_context_t a1)
{
  if ((*(unsigned char *)(a1 + 1379) & 0x10) != 0) {
    sub_100050D0C();
  }
  uint64_t result = *(unsigned int *)(a1 + 1336);
  if (!result)
  {
    uint64_t result = sub_10000D56C(1u, 0, a1);
    *(_DWORD *)(a1 + 1336) = result;
  }
  return result;
}

uint64_t sub_100024F7C(mach_port_context_t guard)
{
  if ((*(unsigned char *)(guard + 1379) & 0x10) == 0) {
    sub_100050D0C();
  }
  uint64_t result = *(unsigned int *)(guard + 1336);
  if (result)
  {
    uint64_t result = sub_10000D68C(result, 0, guard);
    if (result) {
      sub_100050D28();
    }
    *(_DWORD *)(guard + 1336) = 0;
  }
  return result;
}

uint64_t sub_100024FC8(uint64_t a1)
{
  return *(unsigned char *)(a1 + 1383) & 1;
}

uint64_t sub_100024FD4(uint64_t a1)
{
  if (byte_100075AC4) {
    return sub_100025008(a1) ^ 1;
  }
  else {
    return 0;
  }
}

uint64_t sub_100025008(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 1382) & 2) != 0) {
    return 1;
  }
  if (sub_10003B5BC()) {
    sub_100050D0C();
  }
  int v7 = *(_DWORD *)(a1 + 700);
  if ((v7 || (v9 = *(void *)(a1 + 256)) != 0 && (int v7 = *(_DWORD *)(v9 + 700)) != 0) && v7 != -1)
  {
    uint64_t v8 = "it has a control port set";
LABEL_11:
    sub_10001E4BC(a1, 5, "service will use proxy because %s", v2, v3, v4, v5, v6, (char)v8);
    return 1;
  }
  if ((*(unsigned char *)(a1 + 1322) & 0xA) != 0 || *(void *)(a1 + 1256))
  {
    uint64_t v8 = "it is being debugged";
    goto LABEL_11;
  }
  if (*(void *)(a1 + 1272))
  {
    uint64_t v8 = "its working directory has been overridden";
    goto LABEL_11;
  }
  return 0;
}

uint64_t sub_1000250C8(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 1381) & 0x40) != 0) {
    return *(unsigned int *)(a1 + 1328);
  }
  else {
    return sub_100030B1C(*(void *)(a1 + 248), (const void *)(a1 + 1392));
  }
}

uint64_t sub_1000250E8(uint64_t a1)
{
  return *(void *)(a1 + 1360);
}

uint64_t sub_1000250F0(uint64_t a1)
{
  return *(unsigned char *)(a1 + 1384) & 1;
}

uint64_t sub_1000250FC(uint64_t a1)
{
  uint64_t result = sub_10001E15C(a1);
  if (result)
  {
    return os_map_str_find();
  }
  return result;
}

void sub_100025144(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v3 = *(void **)(a1 + 24);
  sub_100047E00(*(unsigned int *)(a1 + 16), v3);
  xpc_release(v3);
  sub_10001A174(v2);

  free((void *)a1);
}

xpc_object_t sub_1000251B0(void *a1, __uint64_t a2)
{
  __uint64_t v4 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
  xpc_object_t v5 = 0;
  if (xpc_array_get_count(a1))
  {
    size_t v6 = 0;
    do
    {
      uunint64_t int64 = xpc_array_get_uint64(a1, v6);
      if (v4 < uint64)
      {
        _os_assumes_log();
      }
      else if (v4 - uint64 < a2)
      {
        if (!v5) {
          xpc_object_t v5 = xpc_array_create(0, 0);
        }
        xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, uint64);
      }
      ++v6;
    }
    while (v6 < xpc_array_get_count(a1));
  }
  return v5;
}

void sub_100025270(uint64_t a1, int a2)
{
  int v2 = *(unsigned __int8 *)(a1 + 424);
  if (v2 != a2)
  {
    if (v2 == 2 && a2 != 0 && a2 != 3) {
      sub_10005166C();
    }
    *(unsigned char *)(a1 + 424) = a2;
    if (a2 == 1) {
      sub_10001E368(a1, 0, 0);
    }
    char v6 = sub_1000252F8(a1);
    sub_10001E4BC(a1, 5, "service state: %s", v7, v8, v9, v10, v11, v6);
  }
}

const char *sub_1000252F8(uint64_t a1)
{
  switch(*(unsigned char *)(a1 + 424))
  {
    case 1:
      uint64_t result = "spawn scheduled";
      break;
    case 2:
      uint64_t result = "spawning";
      break;
    case 3:
      if ((*(unsigned char *)(a1 + 1192) & 0x80) != 0) {
        uint64_t result = "xpcproxy";
      }
      else {
        uint64_t result = "spawned";
      }
      break;
    case 4:
      uint64_t result = "running";
      break;
    case 5:
      uint64_t result = "SIGTERMed";
      break;
    case 6:
      uint64_t result = "SIGKILLed";
      break;
    case 7:
      uint64_t result = "languishing";
      break;
    case 8:
      uint64_t result = "exited";
      break;
    default:
      uint64_t result = "not running";
      break;
  }
  return result;
}

uint64_t sub_1000253C8(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 424) != 1) {
    sub_100050D0C();
  }
  sub_100025270(a1, 2);
  if (*(unsigned char *)(a1 + 424) != 2) {
    sub_100050D0C();
  }
  if (*(void *)(a1 + 976))
  {
    __uint64_t v4 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    sub_10001E060(*(void *)(a1 + 976), v4 / 0xF4240);
  }
  uint64_t v5 = sub_1000250FC(a1);
  uint64_t v6 = a1 + 1040;
  if (v5) {
    uint64_t v6 = v5;
  }
  *(unsigned char *)(v6 + 1) = 0;
  *(void *)(a1 + 1376) &= ~0x800000uLL;
  *(_DWORD *)(a1 + 1160) = a2;
  *(void *)(a1 + 1188) = *(void *)(a1 + 1188) & 0xFFFFFFF7FFFFFFFFLL | ((unint64_t)((*(unsigned __int8 *)(a1 + 1322) >> 1) & 1) << 35);
  uint64_t result = sub_100025008(a1);
  uint64_t v8 = 0x8000000000;
  if (!result) {
    uint64_t v8 = 0;
  }
  *(void *)(a1 + 1188) = *(void *)(a1 + 1188) & 0xFFFFFD7FFFFFFFFFLL | v8;
  return result;
}

uint64_t sub_1000254AC(uint64_t a1)
{
  bzero(&v90, 0x728uLL);
  sub_100012A1C((uint64_t)&v90, 0);
  uint64_t v93 = a1;
  uint64_t v8 = *(void *)(a1 + 152);
  if (v8)
  {
    unint64_t v9 = 0;
    do
    {
      if ((*(unsigned char *)(v8 + 88) & 0x40) == 0)
      {
        *((_DWORD *)&v95[2] + v9++) = sub_100048818(v8, 1, v2, v3, v4, v5, v6, v7);
        if (v9 == 128)
        {
          sub_10001E4BC(a1, 4, "Skipping remaining service endpoints for importance boosting.", v3, v4, v5, v6, v7, v86);
          goto LABEL_20;
        }
      }
      uint64_t v8 = *(void *)(v8 + 16);
    }
    while (v8);
    if (v9 <= 0x7F) {
      goto LABEL_9;
    }
    goto LABEL_20;
  }
  unint64_t v9 = 0;
LABEL_9:
  uint64_t v10 = *(void *)(a1 + 176);
  if (v10)
  {
    while (1)
    {
      if ((*(unsigned char *)(v10 + 88) & 0x40) == 0)
      {
        *((_DWORD *)&v95[2] + v9++) = sub_100048818(v10, 1, v2, v3, v4, v5, v6, v7);
        if (v9 == 128) {
          break;
        }
      }
      uint64_t v10 = *(void *)(v10 + 16);
      if (!v10)
      {
        if (v9 > 0x7F) {
          goto LABEL_21;
        }
        goto LABEL_14;
      }
    }
LABEL_20:
    sub_10001E4BC(a1, 4, "Skipping remaining event endpoints for importance boosting.", v3, v4, v5, v6, v7, v86);
    goto LABEL_21;
  }
LABEL_14:
  uint64_t v11 = *(void *)(a1 + 184);
  if (!v11) {
    goto LABEL_22;
  }
  while (1)
  {
    if ((*(unsigned char *)(v11 + 88) & 0x40) == 0)
    {
      *((_DWORD *)&v95[2] + v9++) = sub_100048818(v11, 1, v2, v3, v4, v5, v6, v7);
      if (v9 == 128) {
        break;
      }
    }
    uint64_t v11 = *(void *)(v11 + 16);
    if (!v11) {
      goto LABEL_22;
    }
  }
LABEL_21:
  sub_10001E4BC(a1, 4, "Skipping remaining instance endpoints for importance boosting.", v3, v4, v5, v6, v7, v86);
LABEL_22:
  v95[66] = v9;
  __int16 v12 = *(char **)(a1 + 888);
  if (v12)
  {
    uint64_t v13 = sub_10002E9B8(*(void *)(a1 + 248), v12);
    if (v13)
    {
      mach_port_name_t v96 = sub_100048818(v13, 1, v14, v15, v16, v17, v18, v19);
      if (sub_10000D65C(v96)) {
        sub_100050D28();
      }
    }
    else
    {
      sub_10001E4BC(a1, 3, "Could not find exception endpoint for service: %s", v15, v16, v17, v18, v19, *(void *)(a1 + 888));
    }
  }
  mach_port_t v20 = v96;
  uint64_t v21 = (unint64_t *)(a1 + 1188);
  if ((*(void *)(a1 + 1188) & 0x800000000) != 0) {
    __int16 v22 = 16524;
  }
  else {
    __int16 v22 = 16396;
  }
  if (posix_spawnattr_setflags(&v90, v22)) {
    _os_assumes_log_ctx();
  }
  v105[0] = 0;
  if (posix_spawnattr_setsigmask(&v90, v105)) {
    _os_assumes_log_ctx();
  }
  v102[0] = -1;
  if (posix_spawnattr_setsigdefault(&v90, v102)) {
    _os_assumes_log_ctx();
  }
  if (posix_spawnattr_setprocesstype_np()) {
    _os_assumes_log_ctx();
  }
  if (*(_DWORD *)(a1 + 900) && posix_spawnattr_set_darwin_role_np()) {
    sub_100050D28();
  }
  if (*(void *)(a1 + 1368) && posix_spawnattr_set_conclave_id_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_importancewatch_port_np()) {
    _os_assumes_log_ctx();
  }
  if (posix_spawnattr_setjetsam_ext()) {
    _os_assumes_log_ctx();
  }
  uint64_t v23 = *(void *)(a1 + 976);
  if (v23)
  {
    unsigned int v24 = sub_10001E0B0(v23);
    if (v24)
    {
      uint64_t v25 = 0;
      long long v99 = 0u;
      long long v100 = 0u;
      uint64_t v26 = v24;
      *(_OWORD *)__str = 0u;
      long long v98 = 0u;
      do
      {
        __str[v25] = sub_10001E0B8(*(void *)(a1 + 976), v25);
        ++v25;
      }
      while (v26 != v25);
      if (posix_spawnattr_set_jetsam_ttr_np()) {
        _os_assumes_log_ctx();
      }
    }
  }
  *(void *)__str = sub_10003048C(*(void *)(a1 + 248), a1, (*(void *)(a1 + 1376) >> 30) & 1);
  *(void *)&__str[2] = v27;
  sub_1000101BC();
  *(void *)__str = sub_1000305EC(*(void *)(a1 + 248), a1);
  *(void *)&__str[2] = v28;
  sub_1000101BC();
  if ((*(unsigned char *)(a1 + 1381) & 0x40) != 0) {
    int v29 = *(_DWORD *)(a1 + 1328);
  }
  else {
    int v29 = sub_100030B1C(*(void *)(a1 + 248), (const void *)(a1 + 1392));
  }
  if (v29 != -1)
  {
    if (posix_spawnattr_set_persona_np()) {
      _os_assumes_log_ctx();
    }
    if (posix_spawnattr_set_persona_uid_np()) {
      _os_assumes_log_ctx();
    }
    if (posix_spawnattr_set_persona_gid_np()) {
      _os_assumes_log_ctx();
    }
  }
  if (v20 - 1 <= 0xFFFFFFFD && sub_10000D814(&v90, v20)) {
    sub_100050D28();
  }
  ++*(_DWORD *)(a1 + 1024);
  uint64_t v30 = mach_absolute_time();
  uint64_t v31 = sub_1000250FC(a1);
  uint64_t v32 = a1 + 1040;
  if (v31) {
    uint64_t v33 = v31;
  }
  else {
    uint64_t v33 = a1 + 1040;
  }
  *(void *)(v33 + 8) = v30;
  uint64_t v34 = sub_1000250FC(a1);
  if (v34) {
    uint64_t v35 = v34;
  }
  else {
    uint64_t v35 = a1 + 1040;
  }
  if (v35 == v32) {
    uint64_t v36 = a1 + 1200;
  }
  else {
    uint64_t v36 = v35 + 32;
  }
  int v37 = sub_100047058(v36);
  uint64_t v38 = sub_1000250FC(a1);
  if (v37)
  {
    if (v38) {
      uint64_t v44 = v38;
    }
    else {
      uint64_t v44 = a1 + 1040;
    }
    if (v44 == v32) {
      uint64_t v45 = (_DWORD *)(a1 + 1200);
    }
    else {
      uint64_t v45 = (_DWORD *)(v44 + 32);
    }
    if (!sub_1000470FC(v45) && (*(unsigned char *)(a1 + 1382) & 8) != 0)
    {
      uint64_t v46 = sub_1000250FC(a1);
      if (v46) {
        uint64_t v47 = v46;
      }
      else {
        uint64_t v47 = a1 + 1040;
      }
      sub_1000265D8((xpc_object_t *)(v47 + 16));
    }
    uint64_t v48 = sub_1000250FC(a1);
    if (v48) {
      uint64_t v49 = v48;
    }
    else {
      uint64_t v49 = a1 + 1040;
    }
    if (v49 == v32) {
      uint64_t v50 = (_DWORD *)(a1 + 1200);
    }
    else {
      uint64_t v50 = (_DWORD *)(v49 + 32);
    }
    if (!sub_1000470FC(v50)
      || ((uint64_t v51 = sub_1000250FC(a1)) != 0 ? (v52 = v51) : (v52 = a1 + 1040),
          v52 != v32 ? (uint64_t v53 = v52 + 32) : (uint64_t v53 = a1 + 1200),
          sub_100047114(v53)))
    {
      if ((*(unsigned char *)(a1 + 1383) & 8) != 0)
      {
        uint64_t v54 = sub_1000250FC(a1);
        if (v54) {
          uint64_t v55 = v54;
        }
        else {
          uint64_t v55 = a1 + 1040;
        }
        sub_1000265D8((xpc_object_t *)(v55 + 24));
      }
    }
  }
  else if ((*(unsigned char *)(a1 + 1383) & 8) != 0)
  {
    uint64_t v56 = v38 ? v38 : a1 + 1040;
    if (*(void *)(v56 + 24))
    {
      sub_10001E4BC(a1, 5, "Reseting consecutive crash history", v39, v40, v41, v42, v43, v86);
      xpc_release(*(xpc_object_t *)(v56 + 24));
      *(void *)(v56 + 24) = 0;
    }
  }
  char v57 = sub_100024E98(*(_DWORD *)(a1 + 1160));
  sub_10001E4BC(a1, 5, "launching: %s", v58, v59, v60, v61, v62, v57);
  sub_100014B88();
  uint64_t v63 = qword_100075D58;
  *(void *)(a1 + 24) = qword_100075D58;
  if (v63) {
    *(void *)(v63 + 32) = a1 + 24;
  }
  qword_100075D58 = a1;
  *(void *)(a1 + 32) = &qword_100075D58;
  if ((*(unsigned char *)(a1 + 1192) & 0x80) == 0)
  {
    v95[1] = sub_10000421C(a1, v94, v95) - 240;
    v94[1] = *(void *)(a1 + 1304);
    *(void *)(a1 + 1304) = 0;
    v91[140] = *(posix_spawn_file_actions_t *)(a1 + 720);
    int v92 = *(_DWORD *)(a1 + 792);
    __memcpy_chk();
    for (uint64_t i = 0; i != 3; ++i)
    {
      int v65 = *(_DWORD *)(a1 + 4 * i + 688);
      if (v65 != -1)
      {
        if (i == v65)
        {
          if (posix_spawn_file_actions_addinherit_np(v91, v65)) {
            sub_100050D28();
          }
        }
        else if (posix_spawn_file_actions_adddup2(v91, v65, i))
        {
          sub_100050D28();
        }
      }
    }
    unint64_t *v21 = *v21 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(v95[0] + 108) << 34);
    sub_1000262BC(a1);
    *v21 |= (unint64_t)&_mh_execute_header;
    *(_DWORD *)(a1 + 1156) = 0;
    uint64_t v66 = sub_1000159AC(&v90, 0x728uLL);
    uint64_t v67 = sub_100040010(a1);
    uint64_t v68 = sub_100014B94();
    v88[0] = _NSConcreteStackBlock;
    v88[1] = 0x40000000;
    v88[2] = sub_100026380;
    v88[3] = &unk_100070620;
    v88[4] = v66;
    char v69 = sub_10003B4B0(v67, v68, v88);
    uint64_t v75 = 0;
    if (v67 && (v69 & 1) == 0)
    {
      sub_10001E4BC(a1, 5, "couldn't handoff a spawn, asynced away", v70, v71, v72, v73, v74, v87);
      return 0;
    }
    return v75;
  }
  pid_t v89 = 0;
  uint64_t v76 = off_100075A80[0];
  *(void *)uint64_t v105 = "xpcproxy";
  uint64_t v106 = a1 + 1392;
  uint64_t v107 = 0;
  uint64_t v108 = 0;
  *(void *)uint64_t v102 = 0;
  uint64_t v103 = 0;
  uint64_t v104 = 0;
  if ((_UNKNOWN *)sub_1000301F4(*(void *)(a1 + 248)) == &unk_100075750)
  {
    uint64_t v77 = sub_1000301FC(*(void *)(a1 + 248));
    snprintf((char *)v102, 0x18uLL, "%lu", v77);
    uint64_t v107 = v102;
  }
  if (posix_spawn_file_actions_addopen(v91, 0, "/dev/console", 0, 0) == -1) {
    sub_100050DFC();
  }
  if (posix_spawn_file_actions_addopen(v91, 1, "/dev/console", 1, 0) == -1) {
    sub_100050DFC();
  }
  if (posix_spawn_file_actions_addopen(v91, 2, "/dev/console", 2, 0) == -1) {
    sub_100050DFC();
  }
  unint64_t v101 = 0;
  long long v99 = 0u;
  long long v100 = 0u;
  *(_OWORD *)__str = 0u;
  long long v98 = 0u;
  sub_10004B258((*(void *)(a1 + 1376) >> 24) & 0x400, (char *)__str);
  unsigned int v78 = *(_DWORD *)(a1 + 700);
  if (!v78)
  {
    uint64_t v79 = *(void *)(a1 + 256);
    if (!v79) {
      goto LABEL_135;
    }
    unsigned int v78 = *(_DWORD *)(v79 + 700);
  }
  if (v78 - 1 < 0xFFFFFFFE)
  {
    unint64_t v101 = __PAIR64__(v78, dword_100076A00);
    if (posix_spawnattr_set_registered_ports_np()) {
      sub_100050D28();
    }
    goto LABEL_136;
  }
LABEL_135:
  unint64_t v101 = 0;
LABEL_136:
  if (posix_spawnattr_set_launch_type_np() == -1) {
    sub_100050DFC();
  }
  uint64_t v75 = posix_spawnp(&v89, v76, v91, &v90, (char *const *)v105, (char *const *)qword_100076A28);
  if (!v75 && v89 <= 0)
  {
    sub_10001E4BC(a1, 3, "posix_spawnp() returned 0 but pid=%d", v80, v81, v82, v83, v84, v89);
    uint64_t v75 = 153;
  }
  sub_100026638((uint64_t)&v90, v75);
  sub_100020FCC(a1, v89, v75, 0);
  return v75;
}

void sub_100025EAC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = sub_100014B58();
  uint64_t v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v6);
  dispatch_time_t v8 = dispatch_time(0, 1000000000 * a2);
  dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
  sub_10001A0AC((void *)a1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_1000260B0;
  handler[3] = &unk_1000705E0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v7, handler);
  dispatch_source_set_mandatory_cancel_handler();
  dispatch_activate(v7);
  *(void *)(a1 + 824) = v7;
  *(_DWORD *)(a1 + 820) = a3;
  *(void *)(a1 + 1188) = *(void *)(a1 + 1188) & 0xFFFFFFFF000000FFLL | (a2 << 8);
  unint64_t v9 = sub_1000203FC(a1, 1);
  uint64_t v10 = (char **)sub_100010724(0x40uLL);
  sub_1000107B4((uint64_t)v10, "%s throttled", v11, v12, v13, v14, v15, v16, (char)v9);
  uint64_t v17 = sub_100046DC4(a1 + 1200);
  if (v17) {
    sub_1000107B4((uint64_t)v10, " after %s", v18, v19, v20, v21, v22, v23, (char)v17);
  }
  size_t v24 = sub_10000388C(1, *v10);
  if (!v25) {
    *(void *)(a1 + 840) = v24;
  }
  sub_100010778((void **)v10);
  free(v9);
  sub_1000261D0(a1, 1, v26, v27, v28, v29, v30, v31);
  sub_100025270(a1, 1);
  sub_10001E4BC(a1, 5, "service throttled by %llu seconds", v32, v33, v34, v35, v36, a2);
}

void sub_1000260B0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 824));
  *(void *)(v1 + 824) = 0;
  dispatch_time_t v8 = *(dispatch_semaphore_t **)(v1 + 840);
  if (v8)
  {
    sub_100003AE8(v8);
    *(void *)(v1 + 840) = 0;
  }
  sub_1000261D0(v1, 0, v2, v3, v4, v5, v6, v7);
  uint64_t v9 = sub_1000250FC(v1);
  uint64_t v10 = v1 + 1040;
  if (v9) {
    uint64_t v10 = v9;
  }
  *(unsigned char *)(v10 + 1) = 1;
  uint64_t v11 = *(unsigned int *)(v1 + 820);
  *(_DWORD *)(v1 + 820) = 0;
  int v12 = sub_10001E528(v1, v11);
  sub_10001E4BC(v1, 5, "deferred event: domain spawn response: %d", v13, v14, v15, v16, v17, v12);
  if (v12 && v12 != 36)
  {
    if (v12 == 139) {
      sub_100040E80("deferral event on service in penalty box");
    }
    xpc_strerror();
    sub_10001E4BC(v1, 3, "Deferred spawn of service failed: %d: %s", v18, v19, v20, v21, v22, v12);
  }
}

void sub_100026188(uint64_t a1)
{
  sub_10001A174(*(void **)(a1 + 32));
  uint64_t v2 = *(NSObject **)(a1 + 40);

  dispatch_release(v2);
}

void sub_1000261D0(uint64_t a1, integer_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (((*(unsigned char *)(a1 + 1383) & 0x40) == 0) == a2)
  {
    for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
      sub_100049A5C(i, a2, a3, a4, a5, a6, a7, a8);
    for (uint64_t j = *(void *)(a1 + 176); j; uint64_t j = *(void *)(j + 16))
      sub_100049A5C(j, a2, a3, a4, a5, a6, a7, a8);
    for (uint64_t k = *(void *)(a1 + 184); k; uint64_t k = *(void *)(k + 16))
      sub_100049A5C(k, a2, a3, a4, a5, a6, a7, a8);
    uint64_t v14 = 0x4000000000000000;
    if (!a2) {
      uint64_t v14 = 0;
    }
    *(void *)(a1 + 1376) = *(void *)(a1 + 1376) & 0xBFFFFFFFFFFFFFFFLL | v14;
  }
  else
  {
    uint64_t v10 = "unmarked";
    if (a2) {
      uint64_t v10 = "marked";
    }
    sub_10001E4BC(a1, 7, "Service already %s as throttled", a4, a5, a6, a7, a8, (char)v10);
  }
}

double sub_1000262BC(uint64_t a1)
{
  free(*(void **)(a1 + 1256));
  *(void *)(a1 + 1256) = 0;
  uint64_t v2 = *(void **)(a1 + 1264);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 1264) = 0;
  }
  free(*(void **)(a1 + 1272));
  *(void *)(a1 + 1272) = 0;
  uint64_t v3 = *(void **)(a1 + 1280);
  if (v3)
  {
    xpc_release(v3);
    *(void *)(a1 + 1280) = 0;
  }
  free(*(void **)(a1 + 1288));
  *(void *)(a1 + 1288) = 0;
  uint64_t v4 = *(void **)(a1 + 1304);
  if (v4)
  {
    xpc_release(v4);
    *(void *)(a1 + 1304) = 0;
  }
  mach_port_name_t v5 = *(_DWORD *)(a1 + 1296);
  if (v5)
  {
    if (sub_10000D678(v5)) {
      _os_assumes_log_ctx();
    }
    *(_DWORD *)(a1 + 1296) = 0;
  }
  *(_WORD *)(a1 + 1320) = 0;
  *(void *)&double result = 0xFFFFFFFFLL;
  *(void *)(a1 + 1312) = 0xFFFFFFFFLL;
  *(unsigned char *)(a1 + 1322) &= 0xC8u;
  return result;
}

void sub_100026380()
{
  uint64_t v0 = *(void *)(__chkstk_darwin() + 32);
  uint64_t v1 = sub_100014B94();
  dispatch_assert_queue_V2(v1);
  *(void *)(v0 + 1208) = _xpc_spawnattr_unpack_string(*(void *)(v0 + 1280), *(void *)(v0 + 1288), *(_DWORD *)(*(void *)(v0 + 1280) + 4));
  if (*(_DWORD *)(v0 + 1128) == -101) {
    uid_t v2 = 0;
  }
  else {
    uid_t v2 = *(_DWORD *)(v0 + 1128);
  }
  bzero(block, 0x1090uLL);
  uint64_t v3 = sub_10001ABC4(v2, block);
  if (v3)
  {
    LODWORD(v8) = v3;
    sub_10001FDA8(v0, v3, 0, 3019, 0, "launch_kern_credentials_resolve_by_uid(%d) failed", v6, v7, v2);
  }
  else
  {
    LODWORD(v8) = sub_100012B60(v0, *(void *)(v0 + 1280), *(void *)(v0 + 1288), (uint64_t)block, v4, v5, v6, v7);
    if (!v8)
    {
      LODWORD(v8) = sub_100013690((posix_spawnattr_t *)v0, *(void *)(v0 + 1280), *(void *)(v0 + 1288), *(xpc_object_t *)(v0 + 1264), v9, v10, v11, v12);
      if (!v8)
      {
        uint64_t v16 = *(void **)(v0 + 1272);
        if (!v16 || (LODWORD(v8) = sub_100013834(v0, v16), !v8))
        {
          LODWORD(v8) = sub_10001398C(v0, *(void *)(v0 + 1280), *(void *)(v0 + 1288), 0, 0);
          if (!v8)
          {
            if (((*(void *)(v0 + 1256) + 1156) & 3) != 0) {
              sub_100050D0C();
            }
            uint64_t v17 = &_posix_spawnp;
            if ((*(_DWORD *)(*(void *)(v0 + 1280) + 236) & 0x800) == 0) {
              uint64_t v17 = &_posix_spawn;
            }
            uint64_t v8 = ((uint64_t (*)(void))v17)();
            if (v8) {
              sub_10001FDA8(v0, v8, 0, 3055, 0, "posix_spawn(%s) failed", v18, v19, *(void *)(v0 + 1208));
            }
          }
        }
      }
    }
  }
  uint64_t v13 = *(void *)(v0 + 1256);
  int v14 = *(_DWORD *)(v13 + 1156);
  sub_100026638(v0, v8);
  free((void *)v0);
  uint64_t v15 = sub_100014B58();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100026704;
  block[3] = &unk_100070640;
  block[4] = v13;
  int v21 = v14;
  int v22 = v8;
  dispatch_async(v15, block);
}

void sub_1000265D8(xpc_object_t *a1)
{
  xpc_object_t v1 = *a1;
  if (!*a1)
  {
    xpc_object_t v1 = xpc_array_create(0, 0);
    *a1 = v1;
  }
  __uint64_t v3 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);

  xpc_array_set_uint64(v1, 0xFFFFFFFFFFFFFFFFLL, v3);
}

void sub_100026638(uint64_t a1, int a2)
{
  if (a2 && *(void *)(a1 + 1808))
  {
    unint64_t v3 = 0;
    do
    {
      if (sub_10000D6A8(*(_DWORD *)(a1 + 1296 + 4 * v3))) {
        _os_assumes_log_ctx();
      }
      ++v3;
    }
    while (v3 < *(void *)(a1 + 1808));
  }
  mach_port_name_t v4 = *(_DWORD *)(a1 + 1816);
  if (v4 + 1 >= 2 && sub_10000D678(v4)) {
    sub_100050D28();
  }
  free(*(void **)(a1 + 1280));
  uint64_t v5 = *(void **)(a1 + 1264);
  if (v5) {
    xpc_release(v5);
  }
  uint64_t v6 = *(void **)(a1 + 1272);
  if (v6) {
    xpc_release(v6);
  }

  sub_100012A74(a1);
}

uint64_t sub_100026704(uint64_t a1)
{
  return sub_100020FCC(*(void *)(a1 + 32), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), 0);
}

uint64_t sub_100026718(uint64_t a1)
{
  uint64_t result = sub_1000250FC(a1);
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 248);
    return sub_10002ABC8(v3);
  }
  return result;
}

double sub_100026760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10 = *(void *)(a1 + 1188);
  if ((v10 & 0x20000000000) != 0)
  {
    sub_10001E4BC(a1, 5, "already handled failed init, ignoring", a4, a5, a6, a7, a8, a9);
  }
  else
  {
    int v11 = a3;
    int v12 = a2;
    *(void *)(a1 + 1188) = v10 | 0x20000000000;
    if ((*(unsigned char *)(a1 + 1380) & 0x10) != 0) {
      sub_100021F08(a1, a2, a3, a4, a5, a6, a7, a8);
    }
    if (v12 != 111 || v11 == 75)
    {
      if (!v12) {
        sub_100050D0C();
      }
    }
    else
    {
      uint64_t v13 = *(void *)(a1 + 1376);
      if ((v13 & 0x40000000000) == 0)
      {
        if (*(_DWORD *)(a1 + 296)) {
          sub_100040E80("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
        }
        if ((v13 & 0x10000000000) != 0)
        {
          sub_10001E034(a1);
          sub_10001E4BC(a1, 65539, "Missing executable detected. Job: '%s' Executable: '%s'", v14, v15, v16, v17, v18, a1 + 112);
        }
      }
    }
    sub_10001E368(a1, 4, v12);
    return sub_1000262BC(a1);
  }
  return result;
}

_DWORD *sub_100026880(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  return sub_100003174(a3, *(_DWORD *)(a1 + 72), *(const char **)(a1 + 32), *(_DWORD *)(a1 + 76), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 80), HIDWORD(*(void *)(a1 + 80)), *(_DWORD *)(a1 + 88), *(_WORD *)(a1 + 92));
}

void sub_1000268D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if ((sub_1000438A4(*(_DWORD *)(a1 + 1152)) & 1) != 0 || (*(unsigned char *)(a1 + 1192) & 0xC) != 0)
  {
    sub_10001E4BC(a1, 5, "service is being debugged, not timing out launch", v10, v11, v12, v13, v14, a9);
  }
  else
  {
    if (*(void *)(a1 + 856))
    {
      sub_10001A5EC(a1);
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 856));
      dispatch_release(*(dispatch_object_t *)(a1 + 856));
      *(void *)(a1 + 856) = 0;
    }
    sub_10001E4BC(a1, 4, "Extension is hanging on launch. Killing.", v10, v11, v12, v13, v14, v33);
    sub_10001E4BC(a1, 5, "killing extension hanging on launch", v15, v16, v17, v18, v19, v34);
    uint64_t v20 = sub_10000D714();
    unsigned int v26 = sub_100021A18(a1, 2, v20, v21, v22, v23, v24, v25);
    char v27 = v26;
    if (v26 > 0x25 || ((1 << v26) & 0x2000000009) == 0)
    {
      strerror(v26);
      sub_10001E4BC(a1, 4, "Failed to kill hanging extension: %d: %s", v28, v29, v30, v31, v32, v27);
    }
  }
}

uint64_t sub_1000269F4(void *a1, int *a2)
{
  if (xpc_dictionary_get_BOOL(a1, "self"))
  {
    xpc_dictionary_get_audit_token();
    uint64_t v4 = sub_100020E4C(0);
    if (v4)
    {
      uint64_t v5 = v4;
      if (sub_100030190(*(void *)(v4 + 248), a1)) {
        return v5;
      }
      int v6 = 36;
    }
    else
    {
      int v6 = 135;
    }
    uint64_t v5 = 0;
LABEL_10:
    *a2 = v6;
    return v5;
  }
  xpc_object_t value = xpc_dictionary_get_value(a1, "service-port");
  if (!value) {
    goto LABEL_13;
  }
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_mach_send)
  {
LABEL_7:
    uint64_t v5 = 0;
    int v6 = 22;
    goto LABEL_10;
  }
  uint64_t right = xpc_mach_send_get_right();
  if ((right + 1) < 2)
  {
LABEL_13:
    int int64 = xpc_dictionary_get_int64(a1, "pid");
    if (int64)
    {
      uint64_t v5 = sub_100020E4C(int64);
      if (v5) {
        return v5;
      }
      goto LABEL_15;
    }
    uint64_t v17 = sub_1000300B8(a1, 1, a2);
    if (!v17) {
      return 0;
    }
    uint64_t v18 = (_DWORD *)v17;
    if (sub_100030190(v17, a1))
    {
      string = (char *)xpc_dictionary_get_string(a1, "name");
      if (!string) {
        goto LABEL_7;
      }
      uint64_t v20 = string;
      uint64_t v5 = (uint64_t)sub_10002E140(v18, string);
      if (v5) {
        goto LABEL_21;
      }
      uint64_t v5 = (uint64_t)sub_1000306D0((uint64_t)v18, v20);
      if (v5) {
        goto LABEL_21;
      }
      if (!xpc_dictionary_get_BOOL(a1, "unidomain")
        || (_UNKNOWN *)sub_1000301F4((uint64_t)v18) != &unk_1000755B8
        || (uint64_t v24 = sub_100041094()) == 0)
      {
LABEL_35:
        uint64_t v5 = 0;
LABEL_15:
        int v6 = 113;
        goto LABEL_10;
      }
      uint64_t v25 = (_DWORD *)v24;
      if (sub_100030190(v24, a1))
      {
        uint64_t v5 = (uint64_t)sub_10002E140(v25, v20);
        if (v5)
        {
LABEL_21:
          uuid = xpc_dictionary_get_uuid(a1, "_instance");
          if (!uuid) {
            return v5;
          }
          uint64_t v5 = *(void *)(v5 + 200);
          if (v5)
          {
            uint64_t v22 = uuid;
            while (uuid_compare(v22, (const unsigned __int8 *)(v5 + 408)))
            {
              uint64_t v5 = *(void *)(v5 + 40);
              if (!v5) {
                goto LABEL_35;
              }
            }
            return v5;
          }
          goto LABEL_35;
        }
        goto LABEL_35;
      }
    }
    uint64_t v5 = 0;
    int v6 = 36;
    goto LABEL_10;
  }
  uint64_t v23 = sub_10002FF04(right, 0, v10, v11, v12, v13, v14, v15);
  if (!v23)
  {
    uint64_t v5 = 0;
    int v6 = 135;
    goto LABEL_10;
  }

  return sub_1000494DC((uint64_t)v23);
}

xpc_object_t sub_100026C58(uint64_t a1, void *a2, int a3)
{
  int v6 = sub_100030ADC(*(void *)(a1 + 248));
  xpc_object_t result = xpc_retain(a2);
  *((void *)v6 + 3) = result;
  v6[8] = a3;
  uint64_t v8 = (void *)(a1 + 512);
  uint64_t v9 = *(void *)(a1 + 512);
  *(void *)int v6 = v9;
  if (v9) {
    *(void *)(v9 + 8) = v6;
  }
  *uint64_t v8 = v6;
  *((void *)v6 + 1) = v8;
  return result;
}

uint64_t sub_100026CC0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  xpc_object_t value = 0;
  sub_100011594();
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20)) {
    return 1;
  }
  int v13 = *(_DWORD *)(a1 + 700);
  if (!v13)
  {
    uint64_t v14 = *(void *)(a1 + 256);
    if (!v14)
    {
      BOOL v15 = 1;
      goto LABEL_10;
    }
    int v13 = *(_DWORD *)(v14 + 700);
  }
  BOOL v15 = v13 == 0;
  if ((v13 - 1) <= 0xFFFFFFFD && (*(unsigned char *)(a1 + 1322) & 4) == 0)
  {
    sub_10001E4BC(a1, 5, "blocking xpcproxy until controller configures the service", v8, v9, v10, v11, v12, (char)buffer);
    uint64_t v16 = a1;
    uint64_t v17 = a3;
    int v18 = 3;
LABEL_13:
    sub_100026C58(v16, v17, v18);
    return 0;
  }
LABEL_10:
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v20 = (unint64_t *)(a1 + 1188);
  uint64_t v21 = *(void *)(a1 + 1188);
  if ((v21 & 0x1000000000) == 0)
  {
    uint64_t v16 = a1;
    uint64_t v17 = a3;
    int v18 = 2;
    goto LABEL_13;
  }
  if ((v21 & 0x100000000) != 0) {
    return 37;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  buffer = 0;
  size_t v23 = sub_10000421C(a1, &value, &buffer);
  uint64_t v24 = buffer;
  *uint64_t v20 = *v20 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)buffer + 108) << 34);
  uint64_t v25 = dispatch_data_create(v24, v23, 0, _dispatch_data_destructor_free);
  xpc_object_t v26 = xpc_data_create_with_dispatch_data(v25);
  dispatch_release(v25);
  xpc_dictionary_set_value(reply, "blob", v26);
  xpc_release(v26);
  xpc_dictionary_set_value(reply, "ports", value);
  xpc_release(value);
  if (!v15) {
    xpc_dictionary_set_mach_send();
  }
  xpc_object_t v27 = xpc_array_create(0, 0);
  for (int64_t i = 0; i != 3; ++i)
  {
    int v29 = *(_DWORD *)(a1 + 4 * i + 688);
    if (v29 != -1)
    {
      xpc_array_set_fd(v27, 0xFFFFFFFFFFFFFFFFLL, v29);
      xpc_array_set_int64(v27, 0xFFFFFFFFFFFFFFFFLL, i);
    }
  }
  uint64_t v30 = *(void **)(a1 + 1304);
  if (v30 && xpc_array_get_count(v30))
  {
    size_t v31 = 0;
    do
    {
      xpc_object_t v32 = xpc_array_get_value(*(xpc_object_t *)(a1 + 1304), v31);
      xpc_array_append_value(v27, v32);
      ++v31;
    }
    while (v31 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1304)));
  }
  xpc_dictionary_set_value(reply, "fds", v27);
  xpc_release(v27);
  sub_100011594();
  sub_1000262BC(a1);
  uint64_t result = 0;
  *v20 |= (unint64_t)&_mh_execute_header;
  *a4 = reply;
  return result;
}

uint64_t sub_100026F7C(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20)) {
    return 1;
  }
  if ((*(unsigned char *)(a1 + 1192) & 2) != 0) {
    return 131;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(xdict, "pc");
  if (!uint64)
  {
    size_t v31 = "Failure info has no PC.";
LABEL_17:
    sub_10001E4BC(a1, 3, v31, v8, v9, v10, v11, v12, v32);
    return 22;
  }
  int v13 = uint64;
  uint64_t v14 = xpc_dictionary_get_uint64(xdict, "line");
  if (!v14)
  {
    size_t v31 = "Failure info has no line number.";
    goto LABEL_17;
  }
  int v15 = v14;
  uuid = xpc_dictionary_get_uuid(xdict, "uuid");
  if (!uuid)
  {
    size_t v31 = "Failure info has no image UUID.";
    goto LABEL_17;
  }
  uint64_t v17 = (unsigned __int8 *)uuid;
  BOOL v18 = xpc_dictionary_get_BOOL(xdict, "setup-event");
  char string = xpc_dictionary_get_string(xdict, "string");
  int64_t int64 = xpc_dictionary_get_int64(xdict, "code");
  if (!int64) {
    return 22;
  }
  uint64_t v21 = int64;
  int64_t v23 = xpc_dictionary_get_int64(xdict, "subcode");
  if (byte_100076A7A) {
    nullsub_23("xpcproxy failed", v22);
  }
  sub_10001FEBC(a1, v13, v15, v17, v21, v23, string);
  if (v18)
  {
    sub_10001E4BC(a1, 5, "Service setup event to handle failure and will not launch until it fires.", v24, v25, v26, v27, v28, v32);
    *(void *)(a1 + 1376) |= 0x40000uLL;
  }
  sub_100026760(a1, v21, v23, v24, v25, v26, v27, v28, v32);
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100027148(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if ((sub_10000FE40(a2, 13) & 1) == 0)
  {
    memset(v36, 0, sizeof(v36));
    char v24 = sub_10004296C(*(_DWORD *)(a2 + 20), (char *)v36);
    sub_10001E4BC(a1, 4, "denied kick request from %s - missing entitlement %s", v25, v26, v27, v28, v29, v24);
    return 144;
  }
  BOOL v8 = xpc_dictionary_get_BOOL(a3, "unthrottle");
  if (v8)
  {
    uint64_t v9 = sub_1000250FC(a1);
    uint64_t v10 = a1 + 1040;
    if (v9) {
      uint64_t v10 = v9;
    }
    *(unsigned char *)(v10 + 1) = 1;
  }
  BOOL v11 = xpc_dictionary_get_BOOL(a3, "suspended");
  BOOL v12 = xpc_dictionary_get_BOOL(a3, "kill");
  int v19 = *(_DWORD *)(a1 + 1152);
  if (v12)
  {
    if (v19)
    {
      uint64_t result = sub_100021858(a1, a2, v13, v14, v15, v16, v17, v18);
      if (result) {
        return result;
      }
      xpc_dictionary_set_BOOL(a3, "kill", 0);
      uint64_t v21 = a1;
      uint64_t v22 = a3;
      int v23 = 5;
      goto LABEL_25;
    }
  }
  else if (v19)
  {
    uint64_t v30 = a3;
LABEL_22:
    uint64_t result = (uint64_t)xpc_dictionary_create_reply(v30);
    if (!result) {
      return result;
    }
    char v33 = (void *)result;
    int64_t v34 = *(int *)(a1 + 1152);
    uint64_t v35 = "pid";
    goto LABEL_28;
  }
  if (v11) {
    *(unsigned char *)(a1 + 1322) |= 1u;
  }
  if (v8) {
    int v31 = sub_1000215D4(a1, 9);
  }
  else {
    int v31 = sub_100021748(a1, 9, v13, v14, v15, v16, v17, v18);
  }
  int v32 = v31;
  if (v31 == 36)
  {
    uint64_t v21 = a1;
    uint64_t v22 = a3;
    int v23 = 1;
LABEL_25:
    sub_100026C58(v21, v22, v23);
    return 0;
  }
  uint64_t v30 = a3;
  if (!v32) {
    goto LABEL_22;
  }
  uint64_t result = (uint64_t)xpc_dictionary_create_reply(a3);
  if (!result) {
    return result;
  }
  char v33 = (void *)result;
  int64_t v34 = v32;
  uint64_t v35 = "error";
LABEL_28:
  xpc_dictionary_set_int64(v33, v35, v34);
  uint64_t result = 0;
  *a4 = v33;
  return result;
}

uint64_t sub_100027354(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if ((sub_10000FE40(a2, 13) & 1) == 0)
  {
    memset(v40, 0, sizeof(v40));
    char v27 = sub_10004296C(*(_DWORD *)(a2 + 20), (char *)v40);
    sub_10001E4BC(a1, 4, "denied attach request from %s - missing entitlement %s", v28, v29, v30, v31, v32, v27);
    return 144;
  }
  BOOL v8 = xpc_dictionary_get_BOOL(a3, "kill");
  BOOL v9 = xpc_dictionary_get_BOOL(a3, "run");
  BOOL v10 = xpc_dictionary_get_BOOL(a3, "proxy");
  int v11 = xpc_dictionary_get_BOOL(a3, "pended");
  char v18 = *(unsigned char *)(a1 + 1322);
  char v19 = v18 | 1;
  char v20 = v18 & 0xFC | 2;
  if ((v10 & ~v11) == 0) {
    char v20 = v19;
  }
  *(unsigned char *)(a1 + 1322) = v20;
  int v21 = *(_DWORD *)(a1 + 1152);
  if ((v11 & 1) == 0 && (v8 || v10))
  {
    if (v21)
    {
      uint64_t v22 = sub_100021858(a1, a2, v12, v13, v14, v15, v16, v17);
      if (v22 != 37)
      {
        uint64_t v23 = v22;
        if (v22)
        {
          sub_1000262BC(a1);
          return v23;
        }
      }
      xpc_dictionary_set_BOOL(a3, "pended", 1);
      uint64_t v24 = a1;
      uint64_t v25 = a3;
      int v26 = 5;
      goto LABEL_23;
    }
    goto LABEL_16;
  }
  if (!v21)
  {
LABEL_16:
    if (!v9 || (int v35 = sub_10001E528(a1, 9), v35 == 36))
    {
      xpc_dictionary_set_BOOL(a3, "pended", 1);
      uint64_t v24 = a1;
      uint64_t v25 = a3;
      int v26 = 1;
LABEL_23:
      sub_100026C58(v24, v25, v26);
      return 0;
    }
    int v36 = v35;
    if (v35)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      if (reply)
      {
        xpc_object_t v38 = reply;
        xpc_dictionary_set_int64(reply, "error", v36);
        *a4 = v38;
      }
      sub_1000262BC(a1);
      return 0;
    }
  }
  xpc_object_t v33 = xpc_dictionary_create_reply(a3);
  if (!v33) {
    return 0;
  }
  xpc_object_t v34 = v33;
  xpc_dictionary_set_int64(v33, "pid", *(int *)(a1 + 1152));
  uint64_t v23 = 0;
  *a4 = v34;
  return v23;
}

uint64_t sub_1000275A0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unsigned int v75 = -1;
  if ((xpc_dictionary_expects_reply() & 1) == 0)
  {
    sub_100043D78(3, "no reply expected, failing");
    return 22;
  }
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string)
  {
    sub_100043D78(3, "no name, failing");
    return 22;
  }
  BOOL v9 = string;
  if ((sub_10000FE40(a2, 13) & 1) == 0)
  {
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    char v20 = sub_100042920(a2, (char *)&v76);
    sub_100043D78(3, "Non-entitled process tried to control service \"%s\": %s.%d", v9, v20, *(_DWORD *)(a2 + 20));
    return 144;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a3, "type");
  uint64_t v11 = xpc_dictionary_get_uint64(a3, "handle");
  if (uint64 == 5 && !v11)
  {
    sub_100043D78(5, "will attach to %s next time it is spawned", v9);
    uint64_t v12 = (const char **)&qword_100075D50;
    while (1)
    {
      uint64_t v12 = (const char **)*v12;
      if (!v12) {
        break;
      }
      if (!strcmp(v12[2], v9))
      {
        sub_100043D78(5, "canceling old global attach request to %s", v9);
        sub_100028BC4((uint64_t)v12);
        uint64_t v13 = *v12;
        if (*v12) {
          *((void *)v13 + 1) = v12[1];
        }
        *(void *)v12[1] = v13;
        *uint64_t v12 = (const char *)-1;
        v12[1] = (const char *)-1;
        xpc_release((xpc_object_t)v12[3]);
        free(v12);
        break;
      }
    }
    uint64_t v14 = sub_100013BB8(0x20uLL);
    uint64_t v15 = v14;
    uint64_t v16 = qword_100075D50;
    *uint64_t v14 = qword_100075D50;
    if (v16) {
      *(void *)(v16 + 8) = v14;
    }
    qword_100075D50 = (uint64_t)v14;
    v14[1] = &qword_100075D50;
LABEL_15:
    v15[2] = v9;
    xpc_object_t v17 = xpc_retain(a3);
    uint64_t v18 = 0;
    v15[3] = v17;
    return v18;
  }
  if (!a1)
  {
    uint64_t v43 = sub_1000300B8(a3, 1, (int *)&v75);
    if (!v43)
    {
      unsigned int v68 = v75;
      char v69 = (const char *)xpc_strerror();
      sub_100043D78(3, "couldn't find domain to attach to %s, error %d - %s", v9, v68, v69);
      return v75;
    }
    uint64_t v49 = v43;
    sub_10002A5B8(v43, 5, "will attach to %s next time it's created", v44, v45, v46, v47, v48, (char)v9);
    uint64_t v50 = (uint64_t *)(v49 + 48);
    uint64_t v51 = (const char **)(v49 + 48);
    while (1)
    {
      uint64_t v51 = (const char **)*v51;
      if (!v51) {
        break;
      }
      if (!strcmp(v51[2], v9))
      {
        sub_10002A5B8(v49, 5, "canceling old domain attach request to %s", v52, v53, v54, v55, v56, (char)v9);
        sub_100028BC4((uint64_t)v51);
        char v57 = *v51;
        if (*v51) {
          *((void *)v57 + 1) = v51[1];
        }
        *(void *)v51[1] = v57;
        *uint64_t v51 = (const char *)-1;
        v51[1] = (const char *)-1;
        xpc_release((xpc_object_t)v51[3]);
        free(v51);
        break;
      }
    }
    uint64_t v58 = sub_100013BB8(0x20uLL);
    uint64_t v15 = v58;
    uint64_t v59 = *v50;
    *uint64_t v58 = *v50;
    if (v59) {
      *(void *)(v59 + 8) = v58;
    }
    uint64_t *v50 = (uint64_t)v58;
    v58[1] = v50;
    goto LABEL_15;
  }
  if (*(_DWORD *)(a1 + 700))
  {
    long long v78 = 0u;
    long long v79 = 0u;
    long long v76 = 0u;
    long long v77 = 0u;
    v71[1] = 0;
    uint64_t v72 = 0;
    v71[0] = 0;
    HIDWORD(v72) = *(_DWORD *)(a1 + 704);
    int v73 = 0;
    int v74 = *(_DWORD *)(a1 + 708);
    char v21 = sub_100042920((uint64_t)v71, (char *)&v76);
    sub_100042920(a2, (char *)&v76);
    sub_10001E4BC(a1, 4, "Replacing controller %s[%d] with %s[%d]", v22, v23, v24, v25, v26, v21);
    sub_100028C3C(a1);
  }
  unsigned int mach_send = _xpc_dictionary_extract_mach_send();
  if (mach_send - 1 >= 0xFFFFFFFE)
  {
    sub_10001E4BC(a1, 4, "Got dead control port", v28, v29, v30, v31, v32, v70);
    uint64_t v18 = 57;
  }
  else
  {
    unsigned int v33 = mach_send;
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    *(_DWORD *)(a1 + 704) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 708) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 700) = v33;
    int v35 = sub_100014B58();
    int v36 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v33, 1uLL, v35);
    *(void *)(a1 + 712) = v36;
    dispatch_set_context(v36, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 712), (dispatch_function_t)sub_100028C88);
    dispatch_source_set_mandatory_cancel_handler_f();
    dispatch_activate(*(dispatch_object_t *)(a1 + 712));
    int64_t v42 = *(int *)(a1 + 1152);
    if (v42)
    {
      xpc_dictionary_set_int64(reply, "pid", v42);
      xpc_dictionary_set_BOOL(reply, "configurable", 0);
    }
    uint64_t v18 = 0;
    *a4 = reply;
  }
  if ((*(unsigned char *)(a1 + 1322) & 8) != 0)
  {
    sub_10001E4BC(a1, 5, "controller attached, spawning", v37, v38, v39, v40, v41, v70);
    uint64_t v60 = *(unsigned int *)(a1 + 820);
    *(_DWORD *)(a1 + 820) = 0;
    int v61 = sub_10001E528(a1, v60);
    if (v61)
    {
      char v62 = v61;
      if (v61 != 36)
      {
        if (v61 == 139) {
          sub_100040E80("deferral event on service waiting for controller");
        }
        xpc_strerror();
        sub_10001E4BC(a1, 3, "service spawn failed after attach: %d: %s", v63, v64, v65, v66, v67, v62);
      }
    }
    *(unsigned char *)(a1 + 1322) &= ~8u;
  }
  return v18;
}

uint64_t sub_100027A7C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  int v8 = *(_DWORD *)(a1 + 704);
  uint64_t v9 = a1;
  if (!v8)
  {
    uint64_t v9 = *(void *)(a1 + 256);
    if (!v9) {
      uint64_t v9 = a1;
    }
    int v8 = *(_DWORD *)(v9 + 704);
    if (!v8) {
      return 142;
    }
  }
  if (v8 != *(_DWORD *)(a2 + 20) || *(_DWORD *)(v9 + 708) != *(_DWORD *)(a2 + 28)) {
    return 142;
  }
  if ((*(unsigned char *)(a1 + 1322) & 4) != 0) {
    return 37;
  }
  char string = xpc_dictionary_get_string(a3, "program");
  if (string) {
    *(void *)(a1 + 1256) = sub_1000159F0(string);
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "argv");
  if (value)
  {
    uint64_t v12 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array) {
      *(void *)(a1 + 1264) = xpc_retain(v12);
    }
  }
  uint64_t v13 = xpc_dictionary_get_string(a3, "cwd");
  if (v13) {
    *(void *)(a1 + 1272) = sub_1000159F0(v13);
  }
  xpc_object_t v14 = xpc_dictionary_get_value(a3, "environment");
  if (v14)
  {
    uint64_t v15 = v14;
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary) {
      *(void *)(a1 + 1280) = xpc_retain(v15);
    }
  }
  int int64 = xpc_dictionary_get_int64(a3, "binpref");
  if (int64)
  {
    xpc_binprefs_alloc();
    *(void *)(a1 + 1288) = v17;
    xpc_binprefs_add(v17, int64, -1);
  }
  xpc_object_t v18 = xpc_dictionary_get_value(a3, "fds");
  if (v18)
  {
    char v19 = v18;
    if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array) {
      *(void *)(a1 + 1304) = xpc_retain(v19);
    }
  }
  mach_port_name_t mach_send = _xpc_dictionary_extract_mach_send();
  if (!mach_send) {
    goto LABEL_27;
  }
  if ((*(_DWORD *)(a1 + 1340) + 1) >= 2)
  {
    if (sub_10000D678(mach_send)) {
      sub_100050D28();
    }
    sub_10001E4BC(a1, 3, "Cannot set configure key endpoint on service: service has dext checkin port %#x", v28, v29, v30, v31, v32, *(_DWORD *)(a1 + 1340));
    return 22;
  }
  *(_DWORD *)(a1 + 1296) = mach_send;
LABEL_27:
  __int16 v21 = xpc_dictionary_get_int64(a3, "jetsam-flags");
  if (v21) {
    *(_WORD *)(a1 + 1320) = v21;
  }
  int v22 = xpc_dictionary_get_int64(a3, "jetsam-priority");
  if (v22 >= 1) {
    *(_DWORD *)(a1 + 1312) = v22;
  }
  int v23 = xpc_dictionary_get_int64(a3, "jetsam-memlimit");
  if (v23) {
    *(_DWORD *)(a1 + 1316) = v23;
  }
  if (xpc_dictionary_get_BOOL(a3, "nano-allocator")) {
    *(unsigned char *)(a1 + 1322) |= 0x10u;
  }
  BOOL v24 = xpc_dictionary_get_BOOL(a3, "sec-transition");
  char v25 = *(unsigned char *)(a1 + 1322);
  if (v24)
  {
    v25 |= 0x20u;
    *(unsigned char *)(a1 + 1322) = v25;
  }
  if ((v25 & 1) == 0) {
    char v25 = *(unsigned char *)(a1 + 1322) & 0xFE | xpc_dictionary_get_BOOL(a3, "suspended");
  }
  *(unsigned char *)(a1 + 1322) = v25 | 4;
  sub_10001E368(a1, 3, 0);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100027D58(uint64_t a1, uint64_t a2)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  int v4 = *(_DWORD *)(a1 + 704);
  if (!v4 || v4 != *(_DWORD *)(a2 + 20) || *(_DWORD *)(a1 + 708) != *(_DWORD *)(a2 + 28)) {
    return 1;
  }
  sub_100028C3C(a1);
  return 0;
}

uint64_t sub_100027DC8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_100030974(*(void *)(a1 + 248), 5, 0, a2);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_100028CD8(a1, a2, v8);
  }
  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    if (reply)
    {
      uint64_t v11 = reply;
      uint64_t v12 = sub_100024E98(*(_DWORD *)(a1 + 1160));
      uint64_t v13 = sub_100015BE4("%s", v12);
      xpc_dictionary_set_string(v11, "reason", v13);
      free(v13);
      uint64_t v9 = 0;
      *a4 = v11;
    }
    else
    {
      return 22;
    }
  }
  return v9;
}

uint64_t sub_100027EA0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_100030974(*(void *)(a1 + 248), 5, 0, a2);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_100028CD8(a1, a2, v8);
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_100028E0C;
    v11[3] = &unk_100070828;
    v11[4] = a1;
    return sub_100046548(a3, a4, (uint64_t)v11);
  }
  return v9;
}

uint64_t sub_100027F7C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 248);
  if ((void *)sub_1000301F4(v8) != qword_100075750) {
    return 125;
  }
  if (sub_1000301FC(v8) != *(_DWORD *)(a2 + 20)) {
    return 1;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "bootstrap");
  uint64_t v11 = *(void **)(a1 + 632);
  if (v11)
  {
    xpc_release(v11);
    *(void *)(a1 + 632) = 0;
  }
  if (value) {
    *(void *)(a1 + 632) = xpc_retain(value);
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100028054(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = *(void *)(a1 + 248);
  if ((void *)sub_1000301F4(v8) != qword_100075750) {
    return 125;
  }
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20)) {
    return 1;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v10 = *(void *)(a1 + 256);
  if (!v10) {
    uint64_t v10 = a1;
  }
  uint64_t v11 = *(void **)(v10 + 632);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v13 = reply;
  if (v11) {
    xpc_dictionary_set_value(reply, "bootstrap", v11);
  }
  memset(v14, 0, sizeof(v14));
  sub_100030478(v8, (uint64_t)v14);
  xpc_dictionary_set_data(v13, "creator", v14, 0x20uLL);
  uint64_t result = 0;
  *a4 = v13;
  return result;
}

uint64_t sub_100028150(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (*(_DWORD *)(a1 + 296)) {
    return 113;
  }
  uint64_t v9 = *(void *)(a1 + 344);
  v11 = v9 && (uint64_t v10 = *(void **)(v9 + 48)) != 0 && *(void *)(v9 + 56) && sub_10003ED80(a2, v10);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_object_t v13 = sub_100022470(a1, v11);
  xpc_dictionary_set_value(reply, "attrs", v13);
  xpc_release(v13);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100028214(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (!sub_10000FE40(a2, 3)) {
    return 144;
  }
  if (!*(_DWORD *)(a1 + 1152)) {
    return 3;
  }
  BOOL v8 = xpc_dictionary_get_BOOL(a3, "deferred");
  if ((*(unsigned char *)(a1 + 1192) & 2) != 0)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    xpc_dictionary_set_int64(reply, "pid", *(int *)(a1 + 1152));
    uint64_t result = 0;
    *a4 = reply;
  }
  else
  {
    if (v8) {
      return 3;
    }
    xpc_dictionary_set_BOOL(a3, "deferred", 1);
    sub_100026C58(a1, a3, 4);
    return 0;
  }
  return result;
}

uint64_t sub_1000282F0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (!sub_10000FE40(a2, 3)) {
    return 144;
  }
  if (*(_DWORD *)(a1 + 1024) && *(_DWORD *)(a1 + 1200))
  {
    if (sub_100046EEC(a1 + 1200))
    {
      uint64_t v8 = 1;
    }
    else if (sub_100046FA0((_DWORD *)(a1 + 1200)))
    {
      if (*(_DWORD *)(a1 + 1204)) {
        uint64_t v8 = 128;
      }
      else {
        uint64_t v8 = 64;
      }
    }
    else
    {
      uint64_t v8 = 64;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 1204);
  uint64_t v11 = *(void *)(a1 + 1208);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_object_t v13 = reply;
  if (*(_DWORD *)(a1 + 1024) && *(_DWORD *)(a1 + 364) == 80)
  {
    xpc_dictionary_set_uint64(reply, "termination-state", 0x80uLL);
    unsigned int v10 = 9;
    uint64_t v11 = 10;
LABEL_14:
    xpc_dictionary_set_uint64(v13, "os-namespace", v10);
    xpc_dictionary_set_uint64(v13, "os-code", v11);
    goto LABEL_15;
  }
  xpc_dictionary_set_uint64(reply, "termination-state", v8);
  if (v8 == 128) {
    goto LABEL_14;
  }
LABEL_15:
  uint64_t result = 0;
  *a4 = v13;
  return result;
}

uint64_t sub_100028444(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  BOOL v8 = xpc_dictionary_get_BOOL(xdict, "yesno");
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20)) {
    return 1;
  }
  uint64_t v14 = *(void *)(a1 + 848);
  if (v8)
  {
    if (v14)
    {
      sub_10001E4BC(a1, 5, "extension already attempting clean exit", v9, v10, v11, v12, v13, v20);
      return 36;
    }
    if (*(unsigned __int8 *)(a1 + 424) > 4u) {
      goto LABEL_12;
    }
    sub_10001E4BC(a1, 5, "extension attempting to exit cleanly", v9, v10, v11, v12, v13, v20);
    uint64_t v16 = sub_100014B58();
    *(void *)(a1 + 848) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v16);
    sub_10001A5C4(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 848), (void *)a1);
    uint64_t v17 = *(NSObject **)(a1 + 848);
    dispatch_time_t v18 = dispatch_time(0, 1000000000 * *(unsigned int *)(a1 + 864));
    dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 848), (dispatch_function_t)sub_100028E18);
    dispatch_activate(*(dispatch_object_t *)(a1 + 848));
  }
  else
  {
    if (!v14)
    {
      sub_10001E4BC(a1, 5, "extension already interrupted clean exit attempt", v9, v10, v11, v12, v13, v20);
      return 37;
    }
    if (*(unsigned __int8 *)(a1 + 424) >= 5u)
    {
LABEL_12:
      sub_10001E4BC(a1, 5, "extension is being stopped", v9, v10, v11, v12, v13, v20);
      return 124;
    }
    sub_10001E4BC(a1, 5, "extension canceled clean exit attempt", v9, v10, v11, v12, v13, v20);
    sub_10001A5EC(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 848));
    dispatch_release(*(dispatch_object_t *)(a1 + 848));
    *(void *)(a1 + 848) = 0;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100028634(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if ((*(unsigned char *)(a1 + 1380) & 4) == 0) {
    return 137;
  }
  if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a1 + 1152)) {
    return 1;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (!*(void *)(a1 + 856)) {
    return 37;
  }
  sub_10001E4BC(a1, 5, "extension checked in as alive", v8, v9, v10, v11, v12, v14);
  sub_10001A5EC(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 856));
  dispatch_release(*(dispatch_object_t *)(a1 + 856));
  *(void *)(a1 + 856) = 0;
  *(void *)(a1 + 1188) |= 0x4000000000uLL;
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100028710(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20)) {
    return 1;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v7 = sub_10001E04C(a1);
  uint64_t v8 = *(void *)(a1 + 256);
  if (v8) {
    uint64_t v7 = sub_10001E04C(v8);
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  if (v7)
  {
    uint64_t v10 = (void *)sub_100046114();
    xpc_dictionary_set_value(reply, "xpcservice-dict", v10);
    xpc_release(v10);
    xpc_dictionary_set_string(reply, "identifier", *(const char **)(a1 + 576));
  }
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_1000287DC(uint64_t a1, void *a2, void *a3)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  xpc_object_t v7 = reply;
  if ((*(unsigned char *)(a1 + 1381) & 2) != 0) {
    xpc_dictionary_set_uuid(reply, "instance", (const unsigned __int8 *)(a1 + 408));
  }
  uint64_t result = 0;
  *a3 = v7;
  return result;
}

uint64_t sub_100028850(uint64_t a1, _OWORD *a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  if (!uuid) {
    return 22;
  }
  uint64_t v9 = (unsigned __int8 *)uuid;
  if (!sub_10000FE40((uint64_t)a2, 29)) {
    return 144;
  }
  uint64_t v10 = *(void *)(a1 + 200);
  if (v10)
  {
    while (uuid_compare(v9, (const unsigned __int8 *)(v10 + 408)))
    {
      uint64_t v10 = *(void *)(v10 + 40);
      if (!v10) {
        goto LABEL_7;
      }
    }
    return 37;
  }
  else
  {
LABEL_7:
    unsigned int v13 = 0;
    sub_10002B8BC(*(void *)(a1 + 248), a1, v9, 0, 0, a2, (int *)&v13);
    uint64_t v11 = v13;
    if (!v13) {
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }
  return v11;
}

uint64_t sub_10002893C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  if (!uuid) {
    return 22;
  }
  uint64_t v9 = uuid;
  if (!sub_10000FE40(a2, 29)) {
    return 144;
  }
  mach_port_context_t v10 = *(void *)(a1 + 200);
  if (!v10) {
    return 113;
  }
  while (uuid_compare(v9, (const unsigned __int8 *)(v10 + 408)))
  {
    mach_port_context_t v10 = *(void *)(v10 + 40);
    if (!v10) {
      return 113;
    }
  }
  uint64_t result = sub_10002B6E0(*(void *)(v10 + 248), v10);
  if (!result)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    goto LABEL_15;
  }
  if (result == 36)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    sub_100024F34(v10);
    unsigned int v13 = (void *)xpc_mach_send_create_with_disposition();
    xpc_dictionary_set_value(reply, "monitor", v13);
    xpc_release(v13);
LABEL_15:
    uint64_t result = 0;
    *a4 = reply;
  }
  return result;
}

uint64_t sub_100028A50(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (!sub_10000FE40(a2, 29)) {
    return 144;
  }
  xpc_object_t empty = xpc_array_create_empty();
  for (uint64_t i = *(void *)(a1 + 200); i; uint64_t i = *(void *)(i + 40))
    xpc_array_set_uuid(empty, 0xFFFFFFFFFFFFFFFFLL, (const unsigned __int8 *)(i + 408));
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "uuids", empty);
  xpc_release(empty);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100028B04(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (!sub_10000FE40(a2, 38)) {
    return 144;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v9 = sub_1000203FC(a1, 1);
  if (v9)
  {
    mach_port_context_t v10 = v9;
    xpc_dictionary_set_string(reply, "service-name", v9);
    free(v10);
  }
  else
  {
    xpc_dictionary_set_string(reply, "service-name", "Unknown service");
  }
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

void sub_100028BC4(uint64_t a1)
{
  xpc_object_t reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 24));
  if (reply)
  {
    uid_t v2 = reply;
    xpc_dictionary_set_int64(reply, "error", 89);
    if ((xpc_pipe_routine_reply() & 0xFFFFFFDF) != 0) {
      _os_assumes_log();
    }
    xpc_release(v2);
  }
}

void sub_100028C3C(uint64_t a1)
{
  *(void *)(a1 + 704) = 0;
  *(_DWORD *)(a1 + 700) = 0;
  if ((*(unsigned char *)(a1 + 1322) & 4) != 0) {
    sub_1000262BC(a1);
  }

  sub_100005170(a1);
}

void sub_100028C8C(NSObject *a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(a1);
  if (sub_10000D678(handle)) {
    _os_assumes_log();
  }

  dispatch_release(a1);
}

void sub_100028CD8(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 124)
  {
    if (a3 == 154) {
      int v4 = 65539;
    }
    else {
      int v4 = 3;
    }
    memset(v16, 0, sizeof(v16));
    char v5 = sub_100042920(a2, (char *)v16);
    xpc_strerror();
    sub_10001E4BC(a1, v4, "Caller not allowed to perform action: %s.%d, actiouint64_t n = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u", v6, v7, v8, v9, v10, v5);
    xpc_strerror();
    sub_10001E4BC(a1, 5, "violation: %s.%d, actiouint64_t n = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u", v11, v12, v13, v14, v15, v5);
  }
}

uint64_t sub_100028E0C(uint64_t a1, FILE *a2)
{
  return sub_100022B98(*(void *)(a1 + 32), a2, 0);
}

void sub_100028E18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_10001A5EC(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 848));
  dispatch_release(*(dispatch_object_t *)(a1 + 848));
  *(void *)(a1 + 848) = 0;
  if (sub_1000438A4(*(_DWORD *)(a1 + 1152)))
  {
    sub_10001E4BC(a1, 5, "extension is being debugged; not timing out exit", v10, v11, v12, v13, v14, a9);
  }
  else
  {
    sub_10001E4BC(a1, 4, "Extension remained dirty for too long after trying to exit. Killing.", v10, v11, v12, v13, v14, v33);
    sub_10001E4BC(a1, 5, "extension timed out trying to exit; killing", v15, v16, v17, v18, v19, v34);
    uint64_t v20 = sub_10000D714();
    unsigned int v26 = sub_100021A18(a1, 1, v20, v21, v22, v23, v24, v25);
    char v27 = v26;
    if (v26 > 0x25 || ((1 << v26) & 0x2000000009) == 0)
    {
      strerror(v26);
      sub_10001E4BC(a1, 4, "Failed to kill extension. It may linger forever: %d: %s", v28, v29, v30, v31, v32, v27);
    }
  }
}

void sub_100028F24(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *(void *)(v1 + 1188);
  if ((v2 & 0x1000000000) != 0) {
    sub_100040E80("proc source registration handler invoked twice");
  }
  *(void *)(v1 + 1188) = v2 | 0x1000000000;

  sub_10001E368(v1, 2, 0);
}

uint64_t sub_100028F78(uint64_t a1, uint64_t a2, int a3, char a4)
{
  uint64_t v7 = sub_100043778();
  uint64_t v8 = v7;
  if (v7)
  {
    sub_100051690(v7, a1, a4);
  }
  else
  {
    sub_1000115A4();
    strsignal(a3);
    sub_10001E4BC(a1, 5, "signaled service for %s: %s", v9, v10, v11, v12, v13, a4);
  }
  return v8;
}

void sub_100029010(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001E4BC(a1, 5, "exceeded sigkill timeout: %u", a4, a5, a6, a7, a8, dword_100075A94);
  sub_10001E4BC(a1, 4, "Service did not exit %u seconds after SIGKILL.", v9, v10, v11, v12, v13, dword_100075A94);
  memset(buffer, 0, sizeof(buffer));
  if (sub_1000428A0(*(_DWORD *)(a1 + 1152), buffer))
  {
    _os_assumes_log();
  }
  else if (HIDWORD(buffer[0]) == 5)
  {
    sub_10001E4BC(a1, 5, "service is already a zombie", v14, v15, v16, v17, v18, v51);
    sub_10001F100(a1, 0);
    return;
  }
  sub_10001E4BC(a1, 5, "service is still not a zombie, abandoning", v14, v15, v16, v17, v18, v51);
  int v19 = (*(uint64_t (**)(uint64_t, void))(a1 + 536))(a1, *(void *)(a1 + 568));
  if (v19)
  {
    char v25 = v19;
    xpc_strerror();
    sub_10001E4BC(a1, 5, "cannot safely abandon: %d: %s", v26, v27, v28, v29, v30, v25);
    sub_10001E4BC(a1, 4, "Cannot safely abandon service instance. Leaving it to languish. This may lead to deadlocks.", v31, v32, v33, v34, v35, v53);
    sub_100025270(a1, 7);
    sub_10001E368(a1, 6, 0);
  }
  else
  {
    sub_10001E4BC(a1, 5, "abandoning", v20, v21, v22, v23, v24, v52);
    sub_10001E4BC(a1, 4, "Abandoning service instance. This may lead to deadlocks.", v36, v37, v38, v39, v40, v54);
    uintptr_t v41 = *(int *)(a1 + 1152);
    global_queue = dispatch_get_global_queue(0, 0);
    uint64_t v43 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v41, 0x80000000uLL, global_queue);
    dispatch_set_context(v43, v43);
    dispatch_source_set_event_handler_f(v43, (dispatch_function_t)sub_10002938C);
    dispatch_activate(v43);
    sub_10001F064(a1, v44, v45, v46, v47, v48, v49, v50);
  }
}

void sub_1000291F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!byte_100076A44
    || *(unsigned char *)(a1 + 1030)
    || (_UNKNOWN *)sub_1000301F4(*(void *)(a1 + 248)) == &unk_100075750
    && (uint64_t v18 = sub_100030018(), !sub_10002ABC8(v18)))
  {
    sub_10001E4BC(a1, 4, "Service did not exit %u seconds after SIGTERM. Sending SIGKILL.", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 832));
    memset(v26, 0, sizeof(v26));
    mach_error_t v9 = sub_1000437E0(*(_DWORD *)(a1 + 1152), (integer_t *)v26);
    if (v9)
    {
      int v10 = *(_DWORD *)(a1 + 1152);
      mach_error_string(v9);
      sub_10001E4BC(a1, 5, "could not get audit token for service (PID %d): %d: %s", v11, v12, v13, v14, v15, v10);
    }
    else
    {
      sub_100028F78(a1, (uint64_t)v26, 9, (char)"SIGTERM timeout");
    }
  }
  else
  {
    sub_10001E4BC(a1, 4, "Service did not exit %u seconds after SIGTERM. Terminating with a crash report.", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 832));
    int v19 = sub_1000435B4();
    if (v19)
    {
      char v20 = v19;
      strerror(v19);
      sub_10001E4BC(a1, 5, "could not terminate service after SIGTERM timeout: %d: %s", v21, v22, v23, v24, v25, v20);
    }
  }
  *(unsigned char *)(a1 + 1188) = 9;
  sub_100025270(a1, 6);
  uint64_t v16 = *(NSObject **)(a1 + 1176);
  dispatch_time_t v17 = dispatch_time(0, 1000000000 * dword_100075A94);
  dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 1176), (dispatch_function_t)sub_100029010);
}

void sub_10002938C(NSObject *a1)
{
  pid_t handle = dispatch_source_get_handle(a1);
  int v6 = 0;
  if (waitpid(handle, &v6, 0) == -1)
  {
    int v3 = *__error();
    int v4 = __error();
    char v5 = strerror(*v4);
    sub_100043D78(3, "Could not reap abandoned service instance: %d: %s", v3, v5);
  }
  dispatch_release(a1);
}

uint64_t sub_100029400(uint64_t a1, int a2, xpc_object_t xstring)
{
  int v3 = *(FILE **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40) + 2;
  int64_t string_ptr = xpc_string_get_string_ptr(xstring);
  sub_100046780(v3, v4, "%s", v6, v7, v8, v9, v10, string_ptr);
  return 1;
}

uint64_t sub_100029450(uint64_t a1, int a2, xpc_object_t xstring)
{
  int v3 = *(FILE **)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40) + 2;
  int64_t string_ptr = xpc_string_get_string_ptr(xstring);
  sub_100046780(v3, v4, "%s", v6, v7, v8, v9, v10, string_ptr);
  return 1;
}

xpc_type_t sub_1000294A0(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  char v5 = *(FILE **)a3;
  uint64_t v6 = *(void *)(a3 + 16);
  xpc_type_t result = xpc_get_type(object);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    return (xpc_type_t)sub_100046780(v5, v6, "%s => %s", v9, v10, v11, v12, v13, a1, string_ptr);
  }
  return result;
}

uint64_t sub_100029514(uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    char v5 = *(FILE **)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40) + 2;
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    sub_100046780(v5, v6, "%s", v8, v9, v10, v11, v12, string_ptr);
  }
  return 1;
}

void sub_10002958C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    if (*(void *)(a1 + 16)) {
      sub_1000107B4(a1, " | ", a3, a4, a5, a6, a7, a8, v10);
    }
    sub_1000107B4(a1, "%s", a3, a4, a5, a6, a7, a8, a2);
  }
}

void *sub_1000295EC(char *__s1)
{
  uint64_t v2 = 0;
  while (strcmp(__s1, (&off_100070998)[v2]))
  {
    v2 += 2;
    if (v2 == 16) {
      sub_100040E80("Unable to find boot task block for: %s", __s1);
    }
  }
  int v3 = (&off_100070998)[v2 + 1];
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100029B08;
  aBlock[3] = &unk_100070A18;
  aBlock[4] = v3;
  return _Block_copy(aBlock);
}

void sub_1000296AC()
{
  if (sub_100003EB8())
  {
    sub_100043D78(65541, "Boot mode forced.");
  }
  else
  {
    uint64_t v0 = getenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE");
    if (v0)
    {
      uint64_t v1 = v0;
      if (sub_100003D88(v0) != 7) {
        sub_100040E80("userspace reboot into boot mode not allowed: %s", v1);
      }
      sub_100043D78(65541, "Setting boot mode to %s", v1);
      sub_100003E08(7);
      if (setenv("XPC_IN_REM", "1", 1) == -1) {
        sub_100050DFC();
      }
      int v2 = unsetenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE");
      if (v2 < 0) {
        sub_100043D78(65540, "failed to unset env: XPC_USERSPACE_REBOOT_TO_BOOT_MODE: %d", v2);
      }
    }
  }
}

void sub_1000297AC()
{
  if (sub_100003F18(7))
  {
    uint64_t v0 = getenv("XPC_IN_REM_DEVELOPMENT");
    if (sub_100015D70(v0, "1"))
    {
      sub_100043D78(65541, "Not calling into AMFI to enable REM.");
    }
    else
    {
      sub_100043D78(65541, "Calling into AMFI to enable REM.");
      j__amfi_restricted_execution_mode_enable();
    }
  }
}

void sub_10002983C()
{
  sub_100003E88();
  os_variant_init_4launchd();
  _os_trace_update_with_datavolume_4launchd();

  sub_10004AEF0();
}

void sub_10002986C()
{
  int v0 = mkpath_np("/private/var/mobile/tmp", 0x1FFu);
  if (v0)
  {
    if (v0 == 17)
    {
      sub_1000442C4("fixup-mobile-tmp", 196613, "%s already exists, skipping", v1, v2, v3, v4, v5, (char)"/private/var/mobile/tmp");
      goto LABEL_16;
    }
    strerror(v0);
    uint64_t v36 = "could not set create %s: %s";
LABEL_15:
    sub_1000442C4("fixup-mobile-tmp", 196611, v36, v31, v32, v33, v34, v35, (char)"/private/var/mobile/tmp");
    goto LABEL_16;
  }
  if (chmod("/private/var/mobile/tmp", 0x3FFu) < 0)
  {
    uint64_t v11 = __error();
    strerror(*v11);
    sub_1000442C4("fixup-mobile-tmp", 196611, "could not chmod 1777 on %s: %s", v12, v13, v14, v15, v16, (char)"/private/var/mobile/tmp");
  }
  if (chown("/private/var/mobile/tmp", 0x1F5u, 0x1F5u) < 0)
  {
    dispatch_time_t v17 = __error();
    strerror(*v17);
    sub_1000442C4("fixup-mobile-tmp", 196611, "could not chown mobile/mobile %s: %s", v18, v19, v20, v21, v22, (char)"/private/var/mobile/tmp");
  }
  int v23 = open_dprotected_np("/private/var/mobile/tmp", 0, 0, 1);
  if (v23 == -1)
  {
    __error();
    uint64_t v37 = __error();
    strerror(*v37);
    uint64_t v36 = "could not open %s: %s";
    goto LABEL_15;
  }
  int v24 = v23;
  char v38 = 4;
  if (fcntl(v23, 64))
  {
    __error();
    uint64_t v25 = __error();
    strerror(*v25);
    sub_1000442C4("fixup-mobile-tmp", 196611, "could not set protection class on %s: %s", v26, v27, v28, v29, v30, (char)"/private/var/mobile/tmp");
  }
  if ((v24 & 0x80000000) == 0) {
    close(v24);
  }
LABEL_16:
  sub_1000442C4("fixup-mobile-tmp", 196613, "Finished boot task", v6, v7, v8, v9, v10, v38);
  byte_1000769D8 = 1;
}

uint64_t sub_100029A38()
{
  unsigned int v0 = sub_100040CC4("/");
  uint64_t v2 = v0;
  if ((v0 & 1) != 0 || (uint64_t result = sub_100040BEC("/private/preboot"), v2 = result, result))
  {
    sub_100043D78(65541, "Found roots installed cookie");
    uint64_t result = sysctlbyname("kern.roots_installed", 0, 0, &v2, 8uLL);
    if (result) {
      sub_100050D28();
    }
  }
  return result;
}

void sub_100029ABC()
{
  int v0 = exclaves_boot();
  if (v0)
  {
    if (v0 != 46) {
      sub_100043DF4(65541, "exclaves_boot failed: %d", v0);
    }
  }
}

uint64_t sub_100029B08(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t sub_100029B10()
{
  return 0;
}

uint64_t sub_100029B1C(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  switch(a2)
  {
    case 2:
      return *(_DWORD *)(a5 + 4) != 0;
    case 3:
      if (sub_100030D48(a5)) {
        return 0;
      }
      if ((a3 & 8) != 0)
      {
        uint64_t v9 = 1;
        if (!sub_100019178()) {
          return v9;
        }
      }
      if (a6 && (sub_100016B80(a6) & 1) != 0) {
        return 0;
      }
      if (*(_DWORD *)(a5 + 4)) {
        return 1;
      }
      int v13 = *(_DWORD *)(a5 + 20);
      if (v13 == getpid())
      {
        if (!a6) {
          return 0;
        }
      }
      else
      {
        BOOL v14 = sub_100019178();
        uint64_t v9 = !v14;
        if (!a6 || !v14) {
          return v9;
        }
      }
      BOOL v15 = *(_DWORD *)(a7 + 16) || (*(_WORD *)(a7 + 4) & 0x12) != 0;
      if ((a3 & 0x10) == 0 && v15) {
        return 122;
      }
      else {
        return 0;
      }
    case 4:
    case 7:
      if (sub_100030D48(a5)) {
        return 0;
      }
      if ((a3 & 8) == 0 || (uint64_t v9 = 1, sub_100019178()))
      {
        if ((a3 & 4) != 0) {
          return 125;
        }
        else {
          return *(_DWORD *)(a5 + 4) != 0;
        }
      }
      return v9;
    case 5:
      if (sub_100030D48(a5)) {
        return 0;
      }
      if ((a3 & 8) == 0) {
        return !sub_100019178();
      }
      uint64_t v9 = 1;
      if (sub_100019178()) {
        return !sub_100019178();
      }
      return v9;
    case 6:
      return 0;
    default:
      return 1;
  }
}

uint64_t sub_100029CF4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

void sub_100029CFC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v11);
  uint64_t v9 = a1[4];
  if (v9) {
    *(void *)(v9 + 40) = a1[5];
  }
  *(void *)a1[5] = v9;
  a1[4] = -1;
  a1[5] = -1;
  sub_10001A0AC(a1);
  uint64_t v10 = sub_100014B58();

  dispatch_async_f(v10, a1, (dispatch_function_t)sub_100030C70);
}

uint64_t sub_100029D8C(uint64_t a1, int a2, __int16 a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  if (a1 && (BOOL v13 = sub_100041068(a1)))
  {
    return sub_100029B1C(v13, a2, a3, v14, a5, a6, a7);
  }
  else
  {
    switch(a2)
    {
      case 1:
        if ((a3 & 0x100) == 0) {
          goto LABEL_10;
        }
        if (sub_10000FE40(a5, 16)) {
          uint64_t v16 = 0;
        }
        else {
          uint64_t v16 = 144;
        }
        break;
      case 2:
        uint64_t v16 = 45;
        break;
      case 3:
        if ((a3 & 8) == 0 || (uint64_t v16 = 1, sub_100019178()))
        {
          if ((a3 & 1) != 0 && a6 && !*(_DWORD *)(a7 + 16) && (*(_WORD *)(a7 + 4) & 0x12) == 0) {
            goto LABEL_29;
          }
          if (*(_DWORD *)(a5 + 12) != a4) {
            goto LABEL_30;
          }
          if (!a6) {
            goto LABEL_24;
          }
          uint64_t v17 = *(unsigned int *)(a7 + 16);
          if (!v17 && (*(_WORD *)(a7 + 4) & 0x12) == 0) {
            goto LABEL_29;
          }
          if (v17 != a4 || (*(_WORD *)(a7 + 4) & 2) != 0) {
            uint64_t v16 = 122;
          }
          else {
LABEL_24:
          }
            uint64_t v16 = !sub_100019178();
        }
        break;
      case 4:
      case 7:
        if ((a3 & 8) == 0) {
          goto LABEL_28;
        }
        goto LABEL_27;
      case 5:
        if ((a3 & 8) == 0 || (uint64_t v16 = 1, sub_100019178()))
        {
LABEL_27:
          uint64_t v16 = 1;
          if (sub_100019178())
          {
LABEL_28:
            if (*(_DWORD *)(a5 + 12) == a4) {
LABEL_29:
            }
              uint64_t v16 = 0;
            else {
LABEL_30:
            }
              uint64_t v16 = *(_DWORD *)(a5 + 4) != 0;
          }
        }
        break;
      case 6:
        if (*(_DWORD *)(a5 + 12) == a4) {
          uint64_t v16 = 0;
        }
        else {
          uint64_t v16 = 144;
        }
        break;
      default:
LABEL_10:
        uint64_t v16 = 1;
        break;
    }
    return v16;
  }
}

uint64_t sub_100029FAC(uint64_t a1)
{
  return *(int *)(a1 + 24);
}

uint64_t sub_100029FB8()
{
  return 45;
}

uint64_t sub_100029FC0(uint64_t a1)
{
  return *(int *)(a1 + 20);
}

void sub_100029FC8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v13);
  if (a1[27])
  {
    uint64_t v9 = sub_100013BB8(0x30uLL);
    v9[4] = dword_100076A00;
    *((void *)v9 + 3) = a1[27];
    a1[27] = 0;
    uint64_t v10 = sub_100014B58();
    dispatch_async_f(v10, v9, (dispatch_function_t)sub_100030D9C);
  }
  uint64_t v11 = a1[4];
  if (v11) {
    *(void *)(v11 + 40) = a1[5];
  }
  *(void *)a1[5] = v11;
  a1[4] = -1;
  a1[5] = -1;
  sub_10001A0AC(a1);
  uint64_t v12 = sub_100014B58();

  dispatch_async_f(v12, a1, (dispatch_function_t)sub_100030C70);
}

uint64_t sub_10002A0A4(uint64_t a1, int a2, char a3, unint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t result = 125;
  switch(a2)
  {
    case 1:
      if (!(a4 >> 31))
      {
        uint64_t v10 = *(unsigned int *)(a5 + 20);
        if ((v10 & 0x80000000) == 0 && v10 == a4) {
          return 0;
        }
      }
      if (sub_10000FE40(a5, 13)) {
        return 0;
      }
      uint64_t v11 = a5;
      uint64_t v12 = 2;
      return sub_10000FE40(v11, v12) ^ 1;
    case 2:
      return result;
    case 3:
      if (!a1) {
        return 131;
      }
      if (!a6) {
        return 147;
      }
      unint64_t v14 = *(void *)(a1 + 120);
      if (v14 >> 31 || (uint64_t v15 = *(unsigned int *)(a5 + 20), (v15 & 0x80000000) != 0) || v14 != v15)
      {
        if (sub_10000FE40(a5, 2)) {
          return 0;
        }
        else {
          return 144;
        }
      }
      else
      {
        if ((a3 & 1) == 0
          && (!sub_100016B80(a6) || *(_DWORD *)(a7 + 16) || (*(_WORD *)(a7 + 4) & 0x12) != 0))
        {
          uint64_t v17 = *(char **)(a1 + 240);
          if (!v17
            || !sub_100015CAC(a6, v17)
            || (size_t v18 = strlen(*(const char **)(a1 + 240)), a6[v18 - 1] != 47)
            && (size_t v19 = v18, strlen(a6) != v18)
            && a6[v19] != 47)
          {
            if ((sub_10000FE40(a5, 0) & 1) == 0 && !sub_10000FE40(a5, 1)) {
              return 147;
            }
          }
        }
        return 0;
      }
    case 4:
      if (!(a4 >> 31))
      {
        uint64_t v20 = *(unsigned int *)(a5 + 20);
        if ((v20 & 0x80000000) == 0 && v20 == a4) {
          return 0;
        }
      }
      uint64_t v11 = a5;
      uint64_t v12 = 0;
      return sub_10000FE40(v11, v12) ^ 1;
    case 5:
      if (!(a4 >> 31) && (uint64_t v21 = *(unsigned int *)(a5 + 20), (v21 & 0x80000000) == 0) && v21 == a4
        || (int v22 = *(_DWORD *)(a5 + 4)) == 0
        || a1 && v22 == *(_DWORD *)(a1 + 56))
      {
        if (sub_100019178()) {
          return 0;
        }
      }
      return 1;
    case 6:
      uint64_t v23 = *(unsigned int *)(a5 + 20);
      return (a4 & 0xFFFFFFFF80000000) != 0 || (int)v23 < 0 || v23 != a4;
    default:
      return 1;
  }
}

void sub_10002A2D4(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 1017) & 0x20) != 0) {
    sub_100040E80("system domain deallocated");
  }
  for (uint64_t i = 336; i != 520; i += 8)
  {
    if (*(void *)(a1 + i)) {
      sub_100040E80("domain deallocated with services");
    }
  }
  if (os_map_str_count()) {
    sub_100040E80("domain deallocated with service stubs");
  }
  os_map_str_destroy();
  if (*(void *)(a1 + 960))
  {
    os_map_str_clear();
    os_map_str_destroy();
    free(*(void **)(a1 + 960));
  }
  uint64_t v3 = *(mach_port_name_t **)(a1 + 88);
  if (v3)
  {
    do
    {
      uint64_t v4 = *(mach_port_name_t **)v3;
      sub_10002A54C(a1, v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  if (*(void *)(a1 + 32) != -1 || *(void *)(a1 + 40) != -1) {
    sub_100040E80("domain disposal while still in the domains list", v3);
  }
  if (*(void *)(a1 + 16) != -1 || *(void *)(a1 + 24) != -1) {
    sub_100040E80("domain disposal while still in the children list", v3);
  }
  if (*(void *)(a1 + 208)) {
    _os_assumes_log_ctx();
  }
  uint64_t v5 = *(void **)(a1 + 96);
  if (v5)
  {
    uint64_t v6 = (void *)*v5;
    uint64_t v7 = (void *)v5[1];
    if (*v5)
    {
      do
      {
        uint64_t v8 = v6;
        v6[1] = v7;
        *(void *)v5[1] = v6;
        *uint64_t v5 = -1;
        v5[1] = -1;
        j__free(v5);
        uint64_t v6 = (void *)*v8;
        uint64_t v7 = (void *)v8[1];
        uint64_t v5 = v8;
      }
      while (*v8);
    }
    else
    {
      uint64_t v8 = *(void **)(a1 + 96);
    }
    *uint64_t v7 = 0;
    *uint64_t v8 = -1;
    v8[1] = -1;
    j__free(v8);
  }
  uint64_t v9 = *(void ***)(a1 + 48);
  if (v9)
  {
    do
    {
      uint64_t v10 = (void **)*v9;
      if ((*(unsigned char *)(a1 + 1016) & 0x80) != 0) {
        sub_100047BA0(dword_100076A00, v9[3]);
      }
      xpc_release(v9[3]);
      uint64_t v11 = *v9;
      if (*v9) {
        v11[1] = v9[1];
      }
      *(void *)v9[1] = v11;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
  }
  free(*(void **)(a1 + 312));
  free(*(void **)(a1 + 968));
  uint64_t v12 = *(void **)(a1 + 248);
  if (v12) {
    xpc_release(v12);
  }
  char v13 = *(void **)(a1 + 240);
  if (v13) {
    free(v13);
  }
  unint64_t v14 = *(void **)(a1 + 984);
  if (v14) {
    sub_10001A174(v14);
  }
  uint64_t v15 = *(void **)(a1 + 168);
  if (v15)
  {
    sub_10001AF74(v15);
    *(void *)(a1 + 168) = 0;
  }
  uint64_t v16 = *(void **)(a1 + 136);

  xpc_release(v16);
}

BOOL sub_10002A518(id a1, const char *a2, void *a3)
{
  return 1;
}

void sub_10002A54C(uint64_t a1, mach_port_name_t *a2)
{
  --*(void *)(a1 + 80);
  uint64_t v2 = *(void *)a2;
  if (*(void *)a2) {
    *(void *)(v2 + 8) = *((void *)a2 + 1);
  }
  **((void **)a2 + 1) = v2;
  *(void *)a2 = -1;
  *((void *)a2 + 1) = -1;
  sub_10001A554(a2);
}

uint64_t sub_10002A580(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

void sub_10002A5B8(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v12 = sub_10002A624(a1, 2);
  sub_100044138(v12, a2, a3, &a9, v9);
  free(v12);
}

char *sub_10002A624(uint64_t a1, int a2)
{
  if ((a2 - 1) >= 2) {
    sub_100050D0C();
  }
  uint64_t v4 = (const char **)sub_100010724(0x80uLL);
  uint64_t v11 = v4;
  uint64_t v12 = *(void *)(a1 + 112);
  if ((_UNKNOWN *)v12 == &unk_1000755B8)
  {
    size_t v19 = "system";
  }
  else
  {
    if ((_UNKNOWN *)v12 != &unk_1000756C8)
    {
      sub_1000107B4((uint64_t)v4, "%s/%lu", v5, v6, v7, v8, v9, v10, *(void *)(v12 + 112));
      goto LABEL_8;
    }
    int v23 = *(_DWORD *)(a1 + 56);
    size_t v19 = "gui/%u";
  }
  sub_1000107B4((uint64_t)v4, v19, v5, v6, v7, v8, v9, v10, v23);
LABEL_8:
  if (a2 == 2)
  {
    uint64_t v20 = *(void **)(a1 + 112);
    if (v20 == &unk_100075750)
    {
      sub_1000107B4((uint64_t)v11, " [%s]", v13, v14, v15, v16, v17, v18, *(void *)(a1 + 312));
    }
    else if (v20 == &unk_1000756C8)
    {
      sub_1000107B4((uint64_t)v11, " [%lu]", v13, v14, v15, v16, v17, v18, *(void *)(a1 + 120));
    }
  }
  uint64_t v21 = sub_100010770(v11);
  sub_100010778((void **)v11);
  return v21;
}

BOOL sub_10002A744(uint64_t a1)
{
  return sub_100041068(a1) || *(void *)(a1 + 112) == (void)&unk_1000755B8;
}

uint64_t sub_10002A788(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = 0;
  while (*(void *)&dword_1000758E8[v2 + 2] != a1)
  {
    v2 += 4;
    if (v2 == 24)
    {
      *a2 = 112;
      return 0xFFFFFFFFLL;
    }
  }
  *a2 = 0;
  return dword_1000758E8[v2];
}

uint64_t sub_10002A7CC(int a1)
{
  uint64_t v1 = 0;
  while (dword_1000758E8[v1] != a1)
  {
    v1 += 4;
    if (v1 == 24) {
      return 0;
    }
  }
  return *(void *)&dword_1000758E8[v1 + 2];
}

void sub_10002A804(uint64_t a1, int a2)
{
  uint64_t v2 = *(uint64_t ***)(a1 + 208);
  if (v2)
  {
    do
    {
      uint64_t v4 = *v2;
      if (*((_DWORD *)v2 + 8) == a2)
      {
        sub_100047E00(*((unsigned int *)v2 + 4), v2[3]);
        uint64_t v5 = *v2;
        if (*v2) {
          v5[1] = (uint64_t)v2[1];
        }
        *v2[1] = (uint64_t)v5;
        void *v2 = (uint64_t *)-1;
        v2[1] = (uint64_t *)-1;
      }
      uint64_t v2 = (uint64_t **)v4;
    }
    while (v4);
  }
}

void sub_10002A878(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 208);
  if (v2)
  {
    do
    {
      uint64_t v4 = (void *)*v2;
      if (*((_DWORD *)v2 + 8) == a2)
      {
        uint64_t v5 = sub_100014B58();
        dispatch_async_f(v5, v2, (dispatch_function_t)sub_100030D9C);
        uint64_t v6 = (void *)*v2;
        if (*v2) {
          v6[1] = v2[1];
        }
        *(void *)v2[1] = v6;
        void *v2 = -1;
        v2[1] = -1;
      }
      uint64_t v2 = v4;
    }
    while (v4);
  }
}

void *sub_10002A8FC(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = v1 + 1;
  if (v1 < 0) {
    sub_100040E80("underflow of active count during activate");
  }
  if (v1)
  {
    return (void *)sub_10001A5C4(a1);
  }
  else
  {
    if ((*(unsigned char *)(a1 + 1016) & 0x10) != 0) {
      sub_100040E80("activation of deactivated domain");
    }
    return sub_10001A0AC((void *)a1);
  }
}

void sub_10002A97C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = v1 - 1;
  if (v1 <= 0) {
    sub_100040E80("underflow of active count during deactivate");
  }
  if (v1 == 1)
  {
    int v3 = *(_DWORD *)(a1 + 1016);
    if ((v3 & 1) == 0) {
      sub_100040E80("inactive domain is not shutting down");
    }
    if ((v3 & 0x10) != 0) {
      sub_100040E80("domain already deactivated");
    }
    for (uint64_t i = 336; i != 520; i += 8)
    {
      if (*(void *)(a1 + i)) {
        sub_100040E80("domain cleaning up with services still in list");
      }
    }
    if ((v3 & 0x800) != 0)
    {
      sub_10003B784();
      int v3 = *(_DWORD *)(a1 + 1016);
    }
    *(_DWORD *)(a1 + 1016) = v3 | 0x10;
    uint64_t v5 = *(void *)(a1 + 112);
    if (*(unsigned char *)(v5 + 128))
    {
      uint64_t v6 = *(void *)(a1 + 136);
      if (v6) {
        LODWORD(v6) = xpc_mach_send_get_right();
      }
      sub_100047754(v6);
      uint64_t v5 = *(void *)(a1 + 112);
    }
    (*(void (**)(uint64_t))(v5 + 96))(a1);
    sub_10001A174((void *)a1);
  }
  else
  {
    sub_10001A5EC(a1);
  }
}

void sub_10002AA9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_10002A5B8(a1, 5, "slaying domain", a4, a5, a6, a7, a8, v17);
  int v15 = *(_DWORD *)(a1 + 1016);
  if ((v15 & 3) != 0)
  {
    sub_10002A5B8(a1, 5, "already shutting down or slain", v10, v11, v12, v13, v14, a9);
  }
  else
  {
    if (*(void *)(a1 + 152))
    {
      sub_10001A5EC(a1);
      dispatch_set_context(*(dispatch_object_t *)(a1 + 152), *(void **)(a1 + 152));
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 152));
      *(void *)(a1 + 152) = 0;
      *(_DWORD *)(a1 + 184) = 0;
      int v15 = *(_DWORD *)(a1 + 1016);
    }
    if (*(void *)(a1 + 144))
    {
      if ((v15 & 0x200) != 0)
      {
        sub_10002A5B8(a1, 5, "uncorking exec source for disposal", v10, v11, v12, v13, v14, v18);
        dispatch_activate(*(dispatch_object_t *)(a1 + 144));
        *(_DWORD *)(a1 + 1016) &= ~0x200u;
      }
      sub_10001A5EC(a1);
      dispatch_release(*(dispatch_object_t *)(a1 + 144));
      *(void *)(a1 + 144) = 0;
      int v15 = *(_DWORD *)(a1 + 1016);
    }
    *(_DWORD *)(a1 + 1016) = v15 | 2;
    uint64_t v16 = sub_100014B58();
    dispatch_async_f(v16, (void *)a1, (dispatch_function_t)sub_10002ABD8);
  }
}

BOOL sub_10002ABC8(uint64_t a1)
{
  return (*(unsigned char *)(a1 + 1016) & 3) != 0;
}

void sub_10002ABD8(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 1016)) {
    sub_100040E80("multiple invocations of death handler for domain");
  }
  sub_10002A5B8(a1, 5, "shutting down", a4, a5, a6, a7, a8, v90);
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000755B8) {
    sub_100013EDC();
  }
  *(void *)(a1 + 272) = mach_absolute_time();
  *(_DWORD *)(a1 + 1016) |= 2u;
  sub_100013C94(a1, 3);
  uint64_t v14 = 0;
  do
  {
    uint64_t v92 = v14;
    unint64_t v15 = a1 + 8 * v14;
    uint64_t v16 = *(void *)(v15 + 648);
    if (v16)
    {
      char v17 = (uint64_t *)(v15 + 648);
      do
      {
        sub_10002A5B8(a1, 5, "removing unmanaged service: %s", v9, v10, v11, v12, v13, v16 + 112);
        sub_100031F78(a1, v16);
        if (*(void *)(v16 + 152))
        {
          sub_10002A5B8(a1, 3, "Unmanaged service with non-dynamic endpoints: %s", v19, v20, v21, v22, v23, v16 + 112);
          uint64_t v24 = *(void *)(v16 + 152);
          if (v24)
          {
            do
            {
              uint64_t v25 = *(void *)(v24 + 16);
              sub_10002A5B8(a1, 3, "Removing unexpected non-dynamic endpoint: %s", v19, v20, v21, v22, v23, v24 - 88);
              sub_100049C6C(v24, v26, v27, v28, v29, v30, v31, v32);
              uint64_t v24 = v25;
            }
            while (v25);
          }
        }
        if (*(void *)(v16 + 176))
        {
          sub_10002A5B8(a1, 3, "Unmanaged service with event endpoints: %s", v19, v20, v21, v22, v23, v16 + 112);
          uint64_t v33 = *(void *)(v16 + 176);
          if (v33)
          {
            do
            {
              uint64_t v34 = *(void *)(v33 + 16);
              sub_10002A5B8(a1, 3, "Removing unexpected event endpoint: %s", v19, v20, v21, v22, v23, v33 - 88);
              sub_100049C6C(v33, v35, v36, v37, v38, v39, v40, v41);
              uint64_t v33 = v34;
            }
            while (v34);
          }
        }
        uint64_t v42 = *(void *)(v16 + 160);
        if (v42)
        {
          do
          {
            uint64_t v43 = *(void *)(v42 + 16);
            sub_10002A5B8(a1, 5, "removing unmanaged endpoint: %s", v19, v20, v21, v22, v23, v42 - 88);
            sub_100049C6C(v42, v44, v45, v46, v47, v48, v49, v50);
            uint64_t v42 = v43;
          }
          while (v43);
        }
        uint64_t v51 = *(void *)(v16 + 168);
        if (v51)
        {
          do
          {
            uint64_t v52 = *(void *)(v51 + 16);
            sub_10002A5B8(a1, 5, "removing unmanaged pid-local endpoint: %s", v19, v20, v21, v22, v23, v51 - 88);
            sub_100049C6C(v51, v53, v54, v55, v56, v57, v58, v59);
            uint64_t v51 = v52;
          }
          while (v52);
        }
        if (*(__int16 *)(v16 + 300) >= 3) {
          sub_100040E80("extra activation on unmanaged service");
        }
        sub_100030E18(a1, v16, v18, v19, v20, v21, v22, v23);
        uint64_t v16 = *v17;
      }
      while (*v17);
    }
    uint64_t v14 = v92 + 1;
  }
  while (v92 != 6);
  sub_100013C94(a1, 4);
  uint64_t v65 = *(void *)(a1 + 328);
  while (v65)
  {
    uint64_t v66 = v65;
    uint64_t v65 = *(void *)(v65 + 104);
    sub_10002A5B8(a1, 5, "removing semi-active service: %s", v60, v61, v62, v63, v64, v66 + 112);
    int v67 = sub_10002B6E4(a1, v66);
    if (v67 && v67 != 36) {
      sub_100040E80("failure to remove semi-active service");
    }
  }
  sub_100013C94(a1, 5);
  for (uint64_t i = 0; i != 13; ++i)
  {
    uint64_t v74 = *(void *)(a1 + 8 * i + 544);
    while (v74)
    {
      while (1)
      {
        uint64_t v75 = v74;
        uint64_t v74 = *(void *)(v74 + 88);
        sub_10002A5B8(a1, 5, "removing active service: %s", v68, v69, v70, v71, v72, v75 + 112);
        int v76 = sub_10002B6E4(a1, v75);
        if (v76)
        {
          if (v76 != 36) {
            break;
          }
        }
        if (!v74) {
          goto LABEL_31;
        }
      }
      _os_assumes_log_ctx();
    }
LABEL_31:
    ;
  }
  sub_100013C94(a1, 6);
  for (uint64_t j = 0; j != 23; ++j)
  {
    uint64_t v78 = *(void *)(a1 + 8 * j + 336);
    while (v78)
    {
      uint64_t v79 = v78;
      uint64_t v78 = *(void *)(v78 + 120);
      if (!*(_WORD *)(v79 + 300) && (*(unsigned char *)(v79 + 368) & 1) == 0 && sub_10002B6E4(a1, v79)) {
        sub_100040E80("failed to remove inactive service");
      }
    }
  }
  os_map_str_clear();
  sub_100013C94(a1, 7);
  for (uint64_t k = 0; k != 31; ++k)
  {
    uint64_t v81 = *(void **)(a1 + 8 * k + 704);
    if (v81)
    {
      do
      {
        uint64_t v82 = (void *)v81[4];
        if (v81[9]) {
          sub_100031884(v81);
        }
        uint64_t v81 = v82;
      }
      while (v82);
    }
  }
  sub_100013C94(a1, 8);
  for (uint64_t m = *(void *)(a1 + 320); m; uint64_t m = *(void *)(m + 16))
    sub_10002AA9C(m);
  sub_100013C94(a1, 9);
  *(_DWORD *)(a1 + 1016) |= 1u;
  if (*(void *)(a1 + 152))
  {
    sub_10001A5EC(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 152), *(void **)(a1 + 152));
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 152));
    *(void *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 184) = 0;
  }
  if (*(void *)(a1 + 144))
  {
    if ((*(unsigned char *)(a1 + 1017) & 2) != 0)
    {
      sub_10002A5B8(a1, 5, "uncorking exec source for disposal", v84, v85, v86, v87, v88, v91);
      dispatch_activate(*(dispatch_object_t *)(a1 + 144));
      *(_DWORD *)(a1 + 1016) &= ~0x200u;
    }
    sub_10001A5EC(a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 144));
    *(void *)(a1 + 144) = 0;
  }
  sub_100013C94(a1, 10);
  sub_10002A804(a1, 1);
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000755B8 && qword_100076488) {
    dispatch_release((dispatch_object_t)qword_100076488);
  }
  pid_t v89 = *(NSObject **)(a1 + 160);
  if (v89)
  {
    dispatch_source_cancel(v89);
    *(void *)(a1 + 160) = 0;
  }
  sub_100013C94(a1, 11);

  sub_10002A97C(a1);
}

void sub_10002B104(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (sub_100041068(a1)) {
    sub_10002B104(*(void *)(a1 + 232), a2);
  }
  int v11 = *(unsigned __int16 *)(a1 + 204);
  *(_WORD *)(a1 + 204) = v11 + 1;
  sub_10002A8FC(a1);
  if (!v11 && *(void **)(a1 + 112) != qword_100075750)
  {
    sub_10002A5B8(a1, 5, "entering bootstrap mode", v12, v13, v14, v15, v16, a9);
  }
}

void sub_10002B1A4(uint64_t a1, uint64_t a2)
{
  if (sub_100041068(a1)) {
    sub_10002B1A4(*(void *)(a1 + 232), a2);
  }
  int v9 = *(unsigned __int16 *)(a1 + 204);
  BOOL v10 = v9-- != 0;
  *(_WORD *)(a1 + 204) = v9;
  if (v9 == 0 || !v10)
  {
    if (*(void **)(a1 + 112) != qword_100075750) {
      sub_10002A5B8(a1, 5, "exiting bootstrap mode", v4, v5, v6, v7, v8, v19);
    }
    sub_10002A878(a1, 1);
    sub_10002B268(a1);
    if ((*(unsigned char *)(a1 + 1016) & 0x40) != 0)
    {
      sub_10002B2F0(a1, v11, v12, v13, v14, v15, v16, v17);
      *(_DWORD *)(a1 + 1016) &= ~0x40u;
      uint64_t v18 = (rb_tree_t **)sub_10002B40C(a1);
      sub_10003D668(v18);
    }
  }

  sub_10002A97C(a1);
}

void sub_10002B268(uint64_t a1)
{
  for (uint64_t i = 0; i != 23; ++i)
  {
    uint64_t v3 = *(void *)(a1 + 8 * i + 336);
    if (v3)
    {
      do
      {
        uint64_t v4 = *(void *)(v3 + 120);
        sub_10001A0AC((void *)v3);
        if (*(_DWORD *)(v3 + 288)) {
          sub_100030DE4(v3, v5, v6, v7, v8, v9, v10, v11);
        }
        sub_10001A174((void *)v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
  }
}

void sub_10002B2F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a1 + 192) = v8 - 1;
  if (!v8) {
    sub_100040E80("underflow of on-demand count");
  }
  if (v8 <= 1)
  {
    if (*(_UNKNOWN **)(a1 + 112) != &unk_100075750) {
      sub_10002A5B8(a1, 5, "exiting ondemand mode", a4, a5, a6, a7, a8, v26);
    }
    for (uint64_t i = 0; i != 23; ++i)
    {
      uint64_t v11 = *(void *)(a1 + 8 * i + 336);
      if (v11)
      {
        do
        {
          uint64_t v12 = *(void *)(v11 + 120);
          if (*(_DWORD *)(v11 + 292))
          {
            sub_10001A0AC((void *)v11);
            int v19 = sub_100021748(v11, *(unsigned int *)(v11 + 292), v13, v14, v15, v16, v17, v18);
            if ((v19 & 0xFFFFFFFE) == 0x24) {
              int v25 = 0;
            }
            else {
              int v25 = v19;
            }
            if (v25)
            {
              if (v25 != 37) {
                sub_10001E4BC(v11, 3, "pended nondemand spawn failed: %d", v20, v21, v22, v23, v24, v25);
              }
            }
            *(_DWORD *)(v11 + 292) = 0;
            sub_10001A174((void *)v11);
          }
          uint64_t v11 = v12;
        }
        while (v12);
      }
    }
  }
}

void *sub_10002B40C(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 984);
  if (!result)
  {
    if (*(_UNKNOWN **)(a1 + 112) == &unk_1000755B8)
    {
      uint64_t result = sub_10003D5FC(0);
    }
    else
    {
      uint64_t v3 = a1;
      do
      {
        uint64_t v4 = v3;
        uint64_t v3 = *(void *)(v3 + 232);
      }
      while (v3);
      uint64_t v5 = (void *)sub_10002B40C(v4);
      uint64_t result = sub_10001A0AC(v5);
    }
    *(void *)(a1 + 984) = result;
  }
  return result;
}

uint64_t sub_10002B47C(uint64_t a1)
{
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000755B8) {
    byte_1000769F0 = 0;
  }
  uint64_t v2 = *(void **)(a1 + 168);
  if (v2)
  {
    sub_10001AF74(v2);
    *(void *)(a1 + 168) = 0;
  }
  sub_100011594();
  return *(void *)(a1 + 120);
}

void sub_10002B4E4(void *a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((_UNKNOWN *)a1[14] == &unk_1000755B8 || sub_100041068((uint64_t)a1))
  {
    uint64_t v11 = &qword_100076A30;
  }
  else
  {
    if ((*(unsigned char *)(a1[14] + 128) & 2) == 0) {
      return;
    }
    uint64_t v11 = &qword_100076A38;
  }
  uint64_t v12 = (void *)*v11;
  if (*v11)
  {
    sub_100017C00(a1, 1, a3, v12, a2, 0x2000, a7, a8);
  }
}

uint64_t sub_10002B594(_DWORD *a1, uint64_t a2)
{
  if (*(_DWORD **)(a2 + 248) != a1)
  {
    uint64_t v13 = sub_1000203FC(a2, 1);
    uint64_t v14 = sub_10002A624((uint64_t)a1, 1);
    sub_100040E80("%s is being added to a mismatched domain %s", v13, v14);
  }
  uint64_t v4 = (uint64_t *)&a1[2 * (sub_100015EDC((unsigned char *)(a2 + 1392)) % 0x17uLL) + 84];
  uint64_t v5 = *v4;
  *(void *)(a2 + 120) = *v4;
  if (v5) {
    *(void *)(v5 + 128) = a2 + 120;
  }
  uint64_t *v4 = a2;
  *(void *)(a2 + 128) = v4;
  ++a1[49];
  *(void *)(a2 + 248) = sub_10001A0AC(a1);
  if (!*(_DWORD *)(a2 + 296)) {
    *(_DWORD *)(a2 + 368) |= 6u;
  }
  ++*(_WORD *)(a2 + 300);
  sub_10002A8FC((uint64_t)a1);
  sub_100030E18((uint64_t)a1, a2, v6, v7, v8, v9, v10, v11);
  uint64_t result = sub_100020E0C(a2);
  if ((result & 1) == 0)
  {
    sub_10001E0D0(a2);
    return sub_10002154C(a2);
  }
  return result;
}

uint64_t sub_10002B6E4(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a2 + 368);
  if ((v4 & 0x600) == 0x200)
  {
    uint64_t v5 = *(void *)(a2 + 40);
    if (v5 == -1)
    {
      uint64_t v8 = *(void *)(a2 + 48);
      if (v8 == -1) {
        sub_100040E80("multiple attempts to remove service instance");
      }
    }
    else
    {
      if (!v5)
      {
        uint64_t v6 = *(void **)(a2 + 48);
        uint64_t v7 = *(void *)(a2 + 256);
        *(_DWORD *)(v7 + 240) = *(_DWORD *)(v7 + 224);
        *(void *)(v7 + 232) = *(void *)(v7 + 216);
        *(_DWORD *)(v7 + 224) = 5708;
        *(void *)(v7 + 208) = v6;
        *(void *)(v7 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
LABEL_9:
        *uint64_t v6 = v5;
        *(void *)(a2 + 40) = -1;
        *(void *)(a2 + 48) = -1;
        *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 64);
        *(void *)(a2 + 72) = *(void *)(a2 + 56);
        *(_DWORD *)(a2 + 64) = 5708;
        *(void *)(a2 + 56) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
        int v4 = *(_DWORD *)(a2 + 368) | 0x400;
        goto LABEL_10;
      }
      uint64_t v8 = *(void *)(a2 + 48);
    }
    *(void *)(v5 + 48) = v8;
    uint64_t v6 = *(void **)(a2 + 48);
    goto LABEL_9;
  }
LABEL_10:
  *(_DWORD *)(a2 + 368) = v4 | 0x10;
  if (v4)
  {
    int v16 = sub_100021E70(a2);
    if ((v16 - 36) >= 2)
    {
      if (v16 != 89) {
        sub_100040E80("inconsistency between domain and service semi-active state during semi-active bootout");
      }
      return 0;
    }
    return 36;
  }
  if (!*(_WORD *)(a2 + 300))
  {
    if (sub_1000221B4(a2)) {
      sub_100040E80("active service has zero active count");
    }
    sub_1000311A4(a1, a2, v19, v20, v21, v22, v23, v24);
    return 0;
  }
  if (*(__int16 *)(a2 + 300) <= 0) {
    sub_100050D0C();
  }
  if (sub_100024FC8(a2) && sub_100014184(0))
  {
    if (*(__int16 *)(a2 + 300) <= 0) {
      sub_100050D0C();
    }
    sub_1000318EC(a1, a2);
    sub_10001F064(a2, v9, v10, v11, v12, v13, v14, v15);
    return 0;
  }
  int v18 = sub_100021E70(a2);
  uint64_t result = 36;
  if (v18 && v18 != 37)
  {
    if (v18 == 89) {
      sub_100040E80("inconsistency between domain and service semi-active state during active bootout");
    }
    _os_assumes_log_ctx();
    return 36;
  }
  return result;
}

char *sub_10002B8BC(uint64_t a1, uint64_t a2, unsigned __int8 *uu1, int a4, uint64_t *a5, _OWORD *a6, int *a7)
{
  if (*(void *)(a2 + 248) != a1) {
    sub_100050D0C();
  }
  if (a5) {
    uint64_t v14 = *a5;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = sub_100024EF0(a2, uu1);
  if (v15)
  {
    uint64_t v21 = (char *)v15;
    if (!xpc_binprefs_equal(*(void *)(v15 + 904), v14))
    {
      uint64_t v27 = xpc_binprefs_copy_description(*((void *)v21 + 113));
      uint64_t v56 = xpc_binprefs_copy_description(v14);
      sub_10001E4BC((uint64_t)v21, 4, "Mismatched binprefs: %s != %s", v28, v29, v30, v31, v32, (char)v27);
      free(v27);
      free(v56);
    }
    if (((*((_DWORD *)v21 + 92) >> 5) & 1) != a4) {
      sub_10001E4BC((uint64_t)v21, 4, "One-shot property mismatch: requested=%d existing=%d", v22, v23, v24, v25, v26, a4);
    }
  }
  else
  {
    unint64_t v33 = *(unsigned int *)(a2 + 264);
    if (qword_100076A70 <= v33)
    {
      uint64_t v34 = **(void **)(*(void *)(a2 + 208) + 8);
      if (v34)
      {
        while (1)
        {
          if ((sub_100020E0C(v34) & 1) == 0) {
            sub_100050D0C();
          }
          if ((*(unsigned char *)(v34 + 368) & 0x10) == 0) {
            break;
          }
          uint64_t v34 = **(void **)(*(void *)(v34 + 48) + 8);
          if (!v34)
          {
            LODWORD(v33) = *(_DWORD *)(a2 + 264);
            goto LABEL_16;
          }
        }
        sub_10002A5B8(a1, 4, "Too many instances (%d >= %lu : %d), slaying '%s' to make room", v16, v17, v18, v19, v20, *(_DWORD *)(a2 + 264));
        int v49 = sub_10002B6E4(a1, v34);
        if (v49 && v49 != 36) {
          sub_100051704(a1, v49, v50, v51, v52, v53, v54, v55);
        }
      }
      else
      {
LABEL_16:
        sub_10002A5B8(a1, 4, "Too many instances (%d >= %lu : %d), but nothing to slay since all instances are already being removed.", v16, v17, v18, v19, v20, v33);
      }
    }
    sub_10002BC60(a1, a2);
    v57[0] = sub_10002BD38;
    v57[1] = sub_10002C1B0;
    v57[2] = sub_10002C2F8;
    v57[3] = sub_10002C494;
    v57[4] = sub_10002C4F8;
    v57[5] = sub_10002C5F8;
    v57[6] = a1;
    uint64_t v21 = sub_100005DF8(a2, uu1, 0xFFFFFFFFLL, (uint64_t)a5, a6, (uint64_t)v57, 0, a7);
    if (v21)
    {
      for (uint64_t i = *(void *)(a2 + 152); i; uint64_t i = *(void *)(i + 16))
      {
        if ((*(unsigned char *)(i + 88) & 0x40) == 0)
        {
          sub_1000490CC(i, (unint64_t)sub_10002C708, (unint64_t)v21, (unint64_t)v21);
          uint64_t v37 = v36;
          if (*(void *)(a1 + 976)) {
            size_t v38 = *(void *)(a1 + 976);
          }
          else {
            size_t v38 = a1;
          }
          sub_10002C948(v38, v21, v37, 64);
        }
      }
      sub_10002B594((_DWORD *)a1, (uint64_t)v21);
      uint64_t v39 = (char **)(a2 + 200);
      uint64_t v40 = *(void *)(a2 + 200);
      ++*(_DWORD *)(a2 + 264);
      *((void *)v21 + 5) = v40;
      if (v40) {
        uint64_t v41 = (void *)(v40 + 48);
      }
      else {
        uint64_t v41 = (void *)(a2 + 208);
      }
      void *v41 = v21 + 40;
      *uint64_t v39 = v21;
      *(_DWORD *)(a2 + 240) = *(_DWORD *)(a2 + 224);
      *(void *)(a2 + 232) = *(void *)(a2 + 216);
      *(_DWORD *)(a2 + 224) = 6463;
      *(void *)(a2 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
      *((_DWORD *)v21 + 20) = *((_DWORD *)v21 + 16);
      *((void *)v21 + 9) = *((void *)v21 + 7);
      *((_DWORD *)v21 + 16) = 6463;
      *((void *)v21 + 6) = v39;
      *((void *)v21 + 7) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
      *((_DWORD *)v21 + 92) |= 0x200u;
      *((void *)v21 + 32) = a2;
      sub_10001A0AC((void *)a2);
      if (a4) {
        *((_DWORD *)v21 + 92) |= 0x20u;
      }
    }
    else
    {
      int v42 = *a7;
      xpc_strerror();
      sub_10001E4BC(a2, 3, "Could not create copy of service: %d: %s", v43, v44, v45, v46, v47, v42);
    }
  }
  return v21;
}

uint64_t sub_10002BC60(uint64_t a1, uint64_t a2)
{
  if (*(_UNKNOWN **)(a1 + 112) == &unk_100075750)
  {
    uint64_t v2 = sub_1000055E4(a2);
    if (!v2) {
      return v2;
    }
    sub_10001E4BC(a2, 5, "initialized endpoint after lookup", v6, v7, v8, v9, v10, v16);
    if (*(__int16 *)(a2 + 300) >= 1) {
      sub_100040E80("lazy initialization of endpoint on active service");
    }
    if (*(unsigned char *)(a2 + 368)) {
      sub_100040E80("lazy initialization of endpoint on semi-active service");
    }
    if (!sub_1000319CC(a1, v2))
    {
      sub_100049778(v2);
      return v2;
    }
    sub_10001E4BC(a2, 3, "Failed to initialize implicit endpoint", v11, v12, v13, v14, v15, v17);
    sub_100031684(a1, v2);
  }
  return 0;
}

void sub_10002BD38(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  switch((int)a2)
  {
    case 0:
      if (*(_WORD *)(a1 + 300)) {
        sub_100040E80("will-spawn received on active service");
      }
      if (*(unsigned char *)(a1 + 368)) {
        sub_100040E80("multiple will-spawn events received");
      }
      sub_10002BC60(a4, a1);
      for (uint64_t i = *(void *)(a1 + 152); i; uint64_t i = *(void *)(i + 16))
        sub_100049B18(i);
      for (uint64_t j = *(void *)(a1 + 176); j; uint64_t j = *(void *)(j + 16))
        sub_100049B18(j);
      for (uint64_t k = *(void *)(a1 + 184); k; uint64_t k = *(void *)(k + 16))
        sub_100049B18(k);
      for (uint64_t m = *(void *)(a1 + 192); m; uint64_t m = *(void *)(m + 16))
        sub_10001CD2C(m);
      sub_1000220FC(a1);
      *(_DWORD *)(a1 + 368) |= 1u;
      uint64_t v14 = (uint64_t *)(*(void *)(a1 + 248) + 328);
      uint64_t v15 = *v14;
      *(void *)(a1 + 104) = *v14;
      if (v15) {
        *(void *)(v15 + 112) = a1 + 104;
      }
      *uint64_t v14 = a1;
      *(void *)(a1 + 112) = v14;
      sub_10000364C(a1);
      return;
    case 1:
      if ((*(unsigned char *)(a1 + 368) & 1) == 0) {
        sub_100040E80("out-of-order spawn event received");
      }
      uint64_t v16 = *(void *)(a1 + 104);
      if (v16) {
        *(void *)(v16 + 112) = *(void *)(a1 + 112);
      }
      **(void **)(a1 + 112) = v16;
      *(void *)(a1 + 104) = -1;
      *(void *)(a1 + 112) = -1;
      *(_DWORD *)(a1 + 368) &= ~1u;
      *(_DWORD *)(a1 + 292) = 0;
      if (!a3) {
        goto LABEL_25;
      }
      sub_10000376C(a1, a2, a3, a4, a5, a6, a7, a8, v39);
      if ((*(unsigned char *)(a1 + 368) & 0x10) != 0)
      {
        sub_1000311A4(a4, a1, v17, v18, v19, v20, v21, v22);
      }
      else
      {
        sub_1000314E8((void *)a1);
      }
      return;
    case 4:
      *(_DWORD *)(a1 + 360) = a3;
      *(_DWORD *)(a1 + 364) = a3;
      if (a3) {
        return;
      }
      int v23 = sub_1000221B4(a1);
      uint64_t v24 = sub_100030024(qword_100075750, v23);
      if (v24)
      {
        uint64_t v30 = v24;
        if ((*(unsigned char *)(v24 + 1017) & 2) != 0)
        {
          sub_10002A5B8(v24, 5, "uncorking exec source after service init", v25, v26, v27, v28, v29, v39);
          dispatch_activate(*(dispatch_object_t *)(v30 + 144));
          *(_DWORD *)(v30 + 1016) &= ~0x200u;
        }
      }
      if (!sub_100022A3C(a1)) {
        return;
      }
      if (!csops()) {
        goto LABEL_64;
      }
      if (*__error() != 3)
      {
        uint64_t v31 = __error();
        sub_100043DF4(65539, "csops returned %d", *v31);
LABEL_64:
        uint64_t v36 = (const char *)sub_100022804(a1);
        sub_100040EE4("unexpected exec of non-platform binary: %s: %s [%d]", v36, (const char *)(a1 + 1392), v23);
      }
      return;
    case 5:
      if (byte_1000769D9 && (*(unsigned char *)(a4 + 1016) & 3) == 0 && !*(_DWORD *)(a1 + 296))
      {
        int v32 = sub_1000221B4(a1);
        if (!v32) {
          sub_100050D0C();
        }
        if (v32 == dword_1000765C0)
        {
          uint64_t v37 = sub_1000229A8(a1);
          size_t v38 = sub_100046DC4(v37);
          sub_100043DF4(0x10000, "Obliterator task exited: %s", v38);
          sub_100043DF4(0x10000, "The system may be in an inconsistent half-obliterated state.");
          sub_100043DF4(0x10000, "Rebooting now, so the finish-obliteration boot task can clean things up.");
          sub_100043254(1, 0);
        }
      }
      int v33 = *(_DWORD *)(a1 + 368);
      if ((v33 & 0x120) != 0) {
        *(_DWORD *)(a1 + 368) = v33 | 0x10;
      }
      sub_10000376C(a1, a2, a3, a4, a5, a6, a7, a8, v39);
      for (uint64_t n = *(void *)(a1 + 192); n; uint64_t n = *(void *)(n + 16))
      {
        if (*(_WORD *)(n + 204)) {
          sub_10001CEAC(n);
        }
      }
      if ((*(unsigned char *)(a1 + 369) & 0x10) != 0)
      {
        sub_10002B2F0(a4, v34, a3, a4, a5, a6, a7, a8);
        *(_DWORD *)(a1 + 368) &= ~0x1000u;
      }
      goto LABEL_49;
    case 6:
      sub_10003115C(a1);
      return;
    case 7:
LABEL_25:
      sub_100031F78(a4, a1);
      return;
    case 8:
LABEL_49:
      sub_100030E18(a4, a1, a3, a4, a5, a6, a7, a8);
      return;
    default:
      return;
  }
}

uint64_t sub_10002C1B0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a3 + 1016);
  if ((v9 & 3) != 0)
  {
    sub_10002A5B8(a3, 5, "denying spawn, domain shutting down: %s", a4, a5, a6, a7, a8, a1 + 112);
    return 124;
  }
  int v12 = *(_DWORD *)(a1 + 368);
  if ((v12 & 2) != 0)
  {
    sub_10002A5B8(a3, 5, "pending spawn, service not yet activated: %s", a4, a5, a6, a7, a8, a1 + 112);
    goto LABEL_7;
  }
  if (*(_WORD *)(a1 + 300))
  {
    sub_10002A5B8(a3, 5, "pending spawn, service not yet quiesced: %s", a4, a5, a6, a7, a8, a1 + 112);
    goto LABEL_7;
  }
  if (*(_DWORD *)(a3 + 192))
  {
    uint64_t v13 = 0;
    while (dword_100075590[v13] != a2)
    {
      if (++v13 == 8)
      {
        if (*(_DWORD *)(a1 + 292) != a2)
        {
          *(_DWORD *)(a1 + 292) = a2;
          sub_10002A5B8(a3, 5, "pending spawn, domain in on-demand-only mode: %s", a4, a5, a6, a7, a8, a1 + 112);
        }
        return 36;
      }
    }
  }
  if ((v12 & 4) == 0)
  {
    sub_10002A5B8(a3, 5, "pending spawn, service not yet imported: %s", a4, a5, a6, a7, a8, a1 + 112);
LABEL_7:
    *(_DWORD *)(a1 + 288) = a2;
    return 36;
  }
  if ((v9 & 0x8000) != 0) {
    goto LABEL_7;
  }
  if (!*(_WORD *)(a3 + 204)) {
    return 0;
  }
  uint64_t result = sub_100024FD4(a1);
  if (result) {
    goto LABEL_7;
  }
  return result;
}

uint64_t sub_10002C2F8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a2 + 1016) & 3) != 0)
  {
    sub_10002A5B8(a2, 5, "resetting service: %s", a4, a5, a6, a7, a8, (_BYTE)a1 + 112);
    sub_1000318EC(a2, (uint64_t)a1);
    return 0;
  }
  if (a1[20])
  {
    sub_10002A5B8(a2, 4, "Service cannot reset: active unmanaged endpoints", a4, a5, a6, a7, a8, v39);
    sub_10002A5B8(a2, 5, "cannot reset service active unmanaged endpoints: %s", v11, v12, v13, v14, v15, (_BYTE)a1 + 112);
  }
  else if (a1[21])
  {
    sub_10002A5B8(a2, 4, "Service cannot reset: active PID-local endpoints", a4, a5, a6, a7, a8, v39);
    sub_10002A5B8(a2, 5, "cannot reset service active pid-local endpoints: %s", v16, v17, v18, v19, v20, (_BYTE)a1 + 112);
  }
  else
  {
    uint64_t v21 = a1[19];
    if (v21)
    {
      while ((*(unsigned char *)(v21 + 88) & 4) == 0)
      {
        uint64_t v21 = *(void *)(v21 + 16);
        if (!v21) {
          goto LABEL_12;
        }
      }
      sub_10002A5B8(a2, 4, "Service cannot reset: active endpoints", a4, a5, a6, a7, a8, v39);
      sub_10002A5B8(a2, 5, "cannot reset service active endpoints: %s", v24, v25, v26, v27, v28, (_BYTE)a1 + 112);
    }
    else
    {
LABEL_12:
      uint64_t v22 = a1[22];
      if (v22)
      {
        while ((*(unsigned char *)(v22 + 88) & 4) == 0)
        {
          uint64_t v22 = *(void *)(v22 + 16);
          if (!v22) {
            goto LABEL_15;
          }
        }
        sub_10002A5B8(a2, 4, "Service cannot reset: active event channels", a4, a5, a6, a7, a8, v39);
        sub_10002A5B8(a2, 5, "cannot reset service active event channels: %s", v29, v30, v31, v32, v33, (_BYTE)a1 + 112);
      }
      else
      {
LABEL_15:
        uint64_t v23 = a1[23];
        if (!v23) {
          return 0;
        }
        uint64_t result = 0;
        while ((*(unsigned char *)(v23 + 88) & 4) == 0)
        {
          uint64_t v23 = *(void *)(v23 + 16);
          if (!v23) {
            return result;
          }
        }
        sub_10002A5B8(a2, 4, "Service cannot reset: active instance endpoints", a4, a5, a6, a7, a8, v39);
        sub_10002A5B8(a2, 5, "cannot reset service: active instance endpoints: %s", v34, v35, v36, v37, v38, (_BYTE)a1 + 112);
      }
    }
  }
  return 16;
}

char *sub_10002C494(void *a1, const char *a2, void *a3, uint64_t a4, unsigned char *a5, size_t a6)
{
  uint64_t v8 = sub_100048C4C((uint64_t)a1, a2, a3, (uint64_t)sub_10002C708, a5, (uint64_t)a1);
  if (v8) {
    sub_10002C948(a6, a1, (uint64_t)v8, 0);
  }
  return v8;
}

char *sub_10002C4F8(uint64_t a1, const char *a2, void *a3, unsigned char *a4, uint64_t a5)
{
  if (*(unsigned char *)(a5 + 104)) {
    int v10 = *(_DWORD *)(a5 + 56);
  }
  else {
    int v10 = 0;
  }
  uint64_t v11 = sub_100014B58();
  uint64_t v12 = sub_10001B558(a1, a5, a2, v10, a3, v11, (uint64_t)sub_1000320CC, a1, (uint64_t)a4);
  if (sub_10001CEA4((uint64_t)v12))
  {
    sub_10001CEA4((uint64_t)v12);
    uint64_t v13 = (const char *)xpc_strerror();
    sub_100014CD8(a4, 4, "Ignored socket %s: %s", a2, v13);
    sub_10001A174(v12);
    return 0;
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 192);
    uint64_t v15 = (char **)(a1 + 192);
    uint64_t v14 = v16;
    *((void *)v12 + 2) = v16;
    if (v16) {
      *(void *)(v14 + 24) = v12 + 16;
    }
    *uint64_t v15 = v12;
    *((void *)v12 + 3) = v15;
  }
  return v12;
}

void sub_10002C5F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void **)(a2 + 112) != qword_100075750 && sub_1000055E4(a1)) {
    sub_10001E4BC(a1, 5, "created the implicit endpoint upfront", a4, a5, a6, a7, a8, v24);
  }
  uint64_t v10 = *(void *)(a1 + 192);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 16);
      uint64_t v12 = *(void *)(v10 + 56);
      sub_10002B104(a2, 9, a3, a4, a5, a6, a7, a8, v24);
      ++*(_WORD *)(v12 + 300);
      *(_DWORD *)(v12 + 368) |= 8u;
      sub_10001BC98(v10, v13, v14, v15, v16, v17, v18, v19);
      uint64_t v10 = v11;
    }
    while (v11);
  }
  uint64_t v20 = *(void **)(a1 + 152);
  while (v20)
  {
    uint64_t v21 = v20;
    uint64_t v22 = v20 + 2;
    uint64_t v20 = (void *)v20[2];
    if ((v22[9] & 0x40) == 0 && sub_1000319CC(a2, (uint64_t)v21))
    {
      uint64_t v23 = *v22;
      if (*v22) {
        *(void *)(v23 + 24) = v21[3];
      }
      *(void *)v21[3] = v23;
      *uint64_t v22 = -1;
      v22[1] = -1;
      sub_10001A174(v21);
    }
  }
}

void sub_10002C708(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a3 + 248);
  if ((*(unsigned char *)(a1 + 88) & 8) != 0) {
    uint64_t v11 = 8;
  }
  else {
    uint64_t v11 = 1;
  }
  if (a2 == 1)
  {
    if ((*(unsigned char *)(a3 + 369) & 8) != 0) {
      sub_10002A5B8(v10, 7, "Deactivated abandoned endpoint: %s", a4, a5, a6, a7, a8, a1 - 88);
    }
    if (sub_100049508(a1)) {
      *(unsigned char *)(a1 + 88) &= ~4u;
    }
    else {
      sub_100031684(v10, a1);
    }
    sub_100030E18(v10, a3, v31, v32, v33, v34, v35, v36);
  }
  else
  {
    if (a2) {
      return;
    }
    mach_port_name_t v12 = sub_100048818(a1, 4, a3, a4, a5, a6, a7, a8);
    if (byte_1000769D9)
    {
      mach_port_name_t v19 = v12;
      mach_port_seqno_t request_seqnop = 0;
      int v46 = 0;
      long long v44 = 0u;
      long long v45 = 0u;
      *(_OWORD *)trailer_infop = 0u;
      mach_msg_size_t msg_sizep = 0;
      mach_msg_type_number_t trailer_infopCnt = 52;
      mach_msg_id_t msg_idp = 0;
      if (mach_port_peek(mach_task_self_, v12, 0x3000000u, &request_seqnop, &msg_sizep, &msg_idp, trailer_infop, &trailer_infopCnt))
      {
LABEL_13:
        if (sub_10002B6E4(v10, a3)) {
          sub_100040E80("failed to boot out inactive service during obliteration; endpoint event");
        }
        return;
      }
      while (1)
      {
        sub_10002A5B8(v10, 5, "peeking at message: seqno = %u, pid = %d", v20, v21, v22, v23, v24, request_seqnop);
        if (!DWORD2(v45) || DWORD2(v45) == dword_1000765C0) {
          break;
        }
        ++request_seqnop;
        if (mach_port_peek(mach_task_self_, v19, 0x3000000u, &request_seqnop, &msg_sizep, &msg_idp, trailer_infop, &trailer_infopCnt))
        {
          goto LABEL_13;
        }
      }
      sub_10002A5B8(v10, 5, "port has message from obliterator or kernel", v25, v26, v27, v28, v29, v39);
    }
    int v37 = sub_100021748(a3, v11, v13, v14, v15, v16, v17, v18);
    if ((v37 & 0xFFFFFFFE) == 0x24) {
      int v38 = 0;
    }
    else {
      int v38 = v37;
    }
    if (v38)
    {
      if (v38 == 37) {
        sub_100040E80("endpoint event received for running service");
      }
      _os_assumes_log_ctx();
    }
  }
}

size_t sub_10002C948(size_t result, void *a2, uint64_t a3, char a4)
{
  if ((a4 & 4) != 0)
  {
    size_t v9 = result;
    size_t v10 = strlen((const char *)(a3 + 168));
    size_t v11 = v10 + 168;
    BOOL v12 = v10 >= 0xFFFFFFFFFFFFFF58;
    uint64_t result = v10 + 169;
    uint64_t v13 = v11 == -1;
    uint64_t v14 = v13 << 63 >> 63;
    BOOL v15 = v14 != v13;
    if (v12 || v15 || v14 < 0)
    {
      __break(1u);
    }
    else
    {
      uint64_t v16 = (char *)sub_100013BB8(result);
      uint64_t v17 = strcpy(v16 + 168, (const char *)(a3 + 168));
      *((void *)v16 + 9) = a3;
      uint64_t v20 = *(void *)(a3 + 64);
      mach_port_name_t v19 = (char **)(a3 + 64);
      uint64_t v18 = v20;
      *((void *)v16 + 6) = v20;
      if (v20) {
        *(void *)(v18 + 56) = v16 + 48;
      }
      *mach_port_name_t v19 = v16;
      *((void *)v16 + 7) = v19;
      uint64_t result = sub_100015EDC(v17);
      uint64_t v21 = (char **)(v9 + 8 * (result % 0x1F) + 704);
      uint64_t v22 = *v21;
      *((void *)v16 + 4) = *v21;
      if (v22) {
        *((void *)v22 + 5) = v16 + 32;
      }
      void *v21 = v16;
      *((void *)v16 + 5) = v21;
    }
  }
  else
  {
    uint64_t v5 = (void *)(a3 + 16);
    if (*(void *)(a3 + 16) != -1 || *(void *)(a3 + 24) != -1) {
      sub_100040E80("attempting to re-add an endpoint into service");
    }
    if ((a4 & 2) != 0)
    {
      uint64_t v23 = a2[21];
      uint64_t v6 = a2 + 21;
      uint64_t v7 = v23;
    }
    else if ((a4 & 0x10) != 0)
    {
      uint64_t v24 = a2[22];
      uint64_t v6 = a2 + 22;
      uint64_t v7 = v24;
    }
    else if ((a4 & 0x40) != 0)
    {
      uint64_t v25 = a2[23];
      uint64_t v6 = a2 + 23;
      uint64_t v7 = v25;
    }
    else if (a4)
    {
      uint64_t v26 = a2[20];
      uint64_t v6 = a2 + 20;
      uint64_t v7 = v26;
    }
    else
    {
      uint64_t v8 = a2[19];
      uint64_t v6 = a2 + 19;
      uint64_t v7 = v8;
    }
    *uint64_t v5 = v7;
    if (v7) {
      *(void *)(v7 + 24) = v5;
    }
    *uint64_t v6 = a3;
    *(void *)(a3 + 24) = v6;
  }
  return result;
}

uint64_t sub_10002CAAC(uint64_t a1, FILE *a2)
{
  uint64_t result = sub_10002CB2C(a1, a2);
  for (uint64_t i = 0; i != 23; ++i)
  {
    for (uint64_t j = *(void *)(a1 + 8 * i + 336); j; uint64_t j = *(void *)(j + 120))
      uint64_t result = sub_100022B50(j, a2, 0);
  }
  for (uint64_t k = *(void *)(a1 + 320); k; uint64_t k = *(void *)(k + 16))
    uint64_t result = sub_10002CAAC(k, a2);
  return result;
}

uint64_t sub_10002CB2C(uint64_t a1, FILE *a2)
{
  int v4 = sub_10002A624(a1, 1);
  sub_100046780(a2, 0, "%s = {", v5, v6, v7, v8, v9, v4);
  free(v4);
  sub_100046780(a2, 1, "xpc_type_t type = %s", v10, v11, v12, v13, v14, *(void *)(*(void *)(a1 + 112) + 112));
  sub_100046780(a2, 1, "pid_t handle = %lu", v15, v16, v17, v18, v19, *(void *)(a1 + 120));
  sub_100046780(a2, 1, "active size_t count = %d", v20, v21, v22, v23, v24, *(unsigned int *)(a1 + 188));
  if (*(_DWORD *)(a1 + 192)) {
    sub_100046780(a2, 1, "on-demand size_t count = %d", v25, v26, v27, v28, v29, *(unsigned int *)(a1 + 192));
  }
  if (*(_DWORD *)(a1 + 196)) {
    sub_100046780(a2, 1, "service size_t count = %u", v25, v26, v27, v28, v29, *(unsigned int *)(a1 + 196));
  }
  if (*(_DWORD *)(a1 + 200)) {
    sub_100046780(a2, 1, "active service size_t count = %u", v25, v26, v27, v28, v29, *(unsigned int *)(a1 + 200));
  }
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000755B8)
  {
    uint64_t v30 = sub_100003E88();
    if (v30) {
      sub_100046780(a2, 1, "boot mode = %s", v31, v32, v33, v34, v35, v30);
    }
    *(void *)&long long v366 = 0;
    if (sub_1000035E0((unint64_t *)&v366))
    {
      sub_100046780(a2, 1, "prob guard = true", v36, v37, v38, v39, v40);
      sub_100046780(a2, 1, "prob guard sample rate = %zu", v41, v42, v43, v44, v45, (void)v366);
    }
    sub_100046780(a2, 1, "maximum allowed shutdown time = %d s", v36, v37, v38, v39, v40, dword_100075A9C);
    sub_100046780(a2, 1, "service stats = {", v46, v47, v48, v49, v50);
    uint64_t v360 = _NSConcreteStackBlock;
    uint64_t v361 = 0x40000000;
    uint64_t v362 = sub_1000324E4;
    uint64_t v363 = &unk_100070AF8;
    uint64_t v364 = a2;
    uint64_t v365 = 0;
    sub_100003334();
    sub_100046780(a2, 1, "}", v51, v52, v53, v54, v55);
  }
  if (*(void *)(a1 + 240)) {
    sub_100046780(a2, 1, "originator = %s", v25, v26, v27, v28, v29, *(void *)(a1 + 240));
  }
  sub_100046780(a2, 1, "creator = %s[%d]", v25, v26, v27, v28, v29, *(void *)(a1 + 312), *(unsigned int *)(a1 + 300));
  sub_100046780(a2, 1, "creator euid = %d", v56, v57, v58, v59, v60, *(unsigned int *)(a1 + 284));
  if (*(void **)(a1 + 112) == qword_100075750) {
    sub_100046780(a2, 1, "uniqueid = %llu", v61, v62, v63, v64, v65, *(void *)(a1 + 128));
  }
  if (*(void *)(a1 + 968)) {
    sub_100046780(a2, 1, "sessiouint64_t n = %s", v61, v62, v63, v64, v65, *(void *)(a1 + 968));
  }
  uint64_t v66 = *(void *)(a1 + 976);
  if (v66) {
    sub_100046780(a2, 1, "endpoint destinatiouint64_t n = %s", v61, v62, v63, v64, v65, v66 + 1024);
  }
  sub_100046780(a2, 1, "security context = {", v61, v62, v63, v64, v65);
  if (*(unsigned char *)(a1 + 104))
  {
    uint64_t v346 = *(unsigned int *)(a1 + 56);
    uint64_t v72 = "uid = %u";
  }
  else
  {
    uint64_t v72 = "uid unset";
  }
  sub_100046780(a2, 2, v72, v67, v68, v69, v70, v71, v346);
  int v347 = *(_DWORD *)(a1 + 60);
  sub_100046780(a2, 2, "session uid = %d", v73, v74, v75, v76, v77);
  if (*(_DWORD *)(a1 + 64) != -1)
  {
    int v347 = *(_DWORD *)(a1 + 64);
    sub_100046780(a2, 2, "persona id = %u", v78, v79, v80, v81, v82);
  }
  sub_100046780(a2, 1, "}", v78, v79, v80, v81, v82);
  sub_100046800(a2, v83, v84, v85, v86, v87, v88, v89, v347);
  unint64_t v95 = *(void *)(a1 + 264);
  if (v95) {
    sub_100046780(a2, 1, "bringup time = %llu ms", v90, v91, v92, v93, v94, v95 / 0xF4240);
  }
  if (*(void *)(a1 + 248))
  {
    sub_100046780(a2, 1, "xpc service paths = {", v90, v91, v92, v93, v94);
    *(void *)&long long v366 = 0;
    *((void *)&v366 + 1) = a2;
    *(void *)&long long v367 = 2;
    xpc_dictionary_apply_f();
    sub_100046780(a2, 1, "}", v96, v97, v98, v99, v100);
  }
  sub_100046780(a2, 1, "death port = 0x%x", v90, v91, v92, v93, v94, *(unsigned int *)(a1 + 184));
  if (*(_WORD *)(a1 + 204))
  {
    LOWORD(v348) = *(_WORD *)(a1 + 204);
    sub_100046780(a2, 1, "in-progress bootstraps = %hu", v103, v104, v105, v106, v107);
  }
  if (*(void *)(a1 + 208))
  {
    sub_100046780(a2, 1, "pending requests = {", v103, v104, v105, v106, v107);
    for (uint64_t i = *(void **)(a1 + 208); i; uint64_t i = (void *)*i)
    {
      long long v368 = 0u;
      long long v369 = 0u;
      long long v366 = 0u;
      long long v367 = 0u;
      memset(v359, 0, sizeof(v359));
      xpc_dictionary_get_audit_token();
      LOBYTE(v348) = sub_100042920((uint64_t)v359, (char *)&v366);
      sub_100046780(a2, 2, "caller = %s.%d, event = %d", v114, v115, v116, v117, v118);
    }
    sub_100046780(a2, 1, "}", v108, v109, v110, v111, v112);
  }
  if (*(void *)(a1 + 320))
  {
    sub_100046780(a2, 1, "subdomains = {", v103, v104, v105, v106, v107);
    for (uint64_t j = *(void *)(a1 + 320); j; uint64_t j = *(void *)(j + 16))
    {
      if (*(void **)(j + 112) != qword_100075750 || !*(void *)(j + 248))
      {
        uint64_t v348 = sub_10002A624(j, 1);
        sub_100046780(a2, 2, "%s", v125, v126, v127, v128, v129);
        free(v348);
      }
    }
    sub_100046780(a2, 1, "}", v119, v120, v121, v122, v123);
  }
  if (*(void *)(a1 + 48))
  {
    sub_100046780(a2, 1, "pending attachments = {", v103, v104, v105, v106, v107);
    for (uint64_t k = *(void **)(a1 + 48); k; uint64_t k = (void *)*k)
      sub_100046780(a2, 2, "%s", v130, v131, v132, v133, v134, k[2]);
    sub_100046780(a2, 1, "}", v130, v131, v132, v133, v134);
  }
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000755B8) {
    sub_100022A88(a2, 0, v102, v103, v104, v105, v106, v107);
  }
  if (*(void *)(a1 + 96))
  {
    sub_100046800(a2, v101, v102, v103, v104, v105, v106, v107, (char)v348);
    sub_100046780(a2, 1, "environment = {", v136, v137, v138, v139, v140);
    for (uint64_t m = *(void **)(a1 + 96); m; uint64_t m = (void *)*m)
      sub_10001A358((uint64_t)m, 2, a2);
    sub_100046780(a2, 1, "}", v141, v142, v143, v144, v145);
  }
  sub_100046800(a2, v101, v102, v103, v104, v105, v106, v107, (char)v348);
  sub_100046780(a2, 1, "services = {", v147, v148, v149, v150, v151);
  for (uint64_t n = 0; n != 23; ++n)
  {
    for (iuint64_t i = *(void *)(a1 + 8 * n + 336); ii; iuint64_t i = *(void *)(ii + 120))
      sub_100024C58(ii, a2, 2, v152, v153, v154, v155, v156);
  }
  sub_100046780(a2, 1, "}", v152, v153, v154, v155, v156);
  if (os_map_str_count())
  {
    sub_100046800(a2, v159, v160, v161, v162, v163, v164, v165, v349);
    sub_100046780(a2, 1, "service stubs = {", v166, v167, v168, v169, v170);
    uint64_t v353 = _NSConcreteStackBlock;
    uint64_t v354 = 0x40000000;
    uint64_t v355 = sub_100032570;
    uint64_t v356 = &unk_100070B18;
    uint64_t v357 = a2;
    uint64_t v358 = 0;
    os_map_str_foreach();
    sub_100046780(a2, 1, "}", v171, v172, v173, v174, v175);
  }
  sub_100046800(a2, v159, v160, v161, v162, v163, v164, v165, v349);
  sub_100046780(a2, 1, "unmanaged processes = {", v176, v177, v178, v179, v180);
  for (juint64_t j = 0; jj != 7; ++jj)
  {
    for (kuint64_t k = *(void *)(a1 + 8 * jj + 648); kk; kuint64_t k = *(void *)(kk + 88))
    {
      sub_100046780(a2, 2, "%s = {", v181, v182, v183, v184, v185, kk + 1392);
      __int16 v350 = *(_WORD *)(kk + 300);
      sub_100046780(a2, 3, "active size_t count = %d", v188, v189, v190, v191, v192);
      sub_100046780(a2, 3, "dynamic endpoints = {", v193, v194, v195, v196, v197);
      for (muint64_t m = *(void *)(kk + 160); mm; muint64_t m = *(void *)(mm + 16))
        sub_10004953C(mm, a2, 4, v198, v199, v200, v201, v202);
      sub_100046780(a2, 3, "}", v198, v199, v200, v201, v202);
      sub_100046780(a2, 3, "pid-local endpoints = {", v204, v205, v206, v207, v208);
      for (nuint64_t n = *(void *)(kk + 168); nn; nuint64_t n = *(void *)(nn + 16))
        sub_10004953C(nn, a2, 4, v209, v210, v211, v212, v213);
      sub_100046780(a2, 3, "}", v209, v210, v211, v212, v213);
      sub_100046780(a2, 2, "}", v215, v216, v217, v218, v219);
    }
  }
  sub_100046780(a2, 1, "}", v181, v182, v183, v184, v185);
  sub_100046800(a2, v220, v221, v222, v223, v224, v225, v226, v350);
  sub_100046780(a2, 1, "endpoints = {", v227, v228, v229, v230, v231);
  for (uint64_t i1 = 0; i1 != 31; ++i1)
  {
    for (uint64_t i2 = *(void *)(a1 + 8 * i1 + 704); i2; uint64_t i2 = *(void *)(i2 + 32))
      sub_1000325B0(a2, i2, v232, v233, v234, v235, v236, v237);
  }
  sub_100046780(a2, 1, "}", v233, v234, v235, v236, v237);
  if (*(void *)(a1 + 976))
  {
    sub_100046800(a2, v240, v241, v242, v243, v244, v245, v246, v351);
    sub_100046780(a2, 1, "externally-hosted endpoints = {", v247, v248, v249, v250, v251);
    uint64_t v258 = 0;
    uint64_t v259 = *(void *)(a1 + 976);
    do
    {
      for (uint64_t i3 = *(void *)(v259 + 8 * v258 + 704); i3; uint64_t i3 = *(void *)(i3 + 32))
        sub_1000325B0(a2, i3, v252, v253, v254, v255, v256, v257);
      ++v258;
    }
    while (v258 != 31);
    sub_100046780(a2, 1, "}", v253, v254, v255, v256, v257);
  }
  sub_100046800(a2, v240, v241, v242, v243, v244, v245, v246, v351);
  sub_100046780(a2, 1, "task-special ports = {", v261, v262, v263, v264, v265);
  for (i4 = *(uint64_t **)(a1 + 88); i4; i4 = (uint64_t *)*i4)
  {
    uint64_t v272 = "exception";
    if (*((_DWORD *)i4 + 5) != 128) {
      uint64_t v272 = (const char *)mach_task_special_port_description();
    }
    uint64_t v273 = *((unsigned int *)i4 + 4);
    uint64_t v274 = sub_10003277C(a1, v273);
    if (v274)
    {
      uint64_t v280 = (const char *)(v274 + 1024);
    }
    else
    {
      v281 = sub_10002FF18(a1, v273, 0, v275, v276, v277, v278, v279);
      uint64_t v280 = (const char *)(v281 + 21);
      if (!v281) {
        uint64_t v280 = "(unknown)";
      }
    }
    sub_100046780(a2, 3, "%#8x %-4u %12s  %s", v275, v276, v277, v278, v279, *((unsigned int *)i4 + 4), *((unsigned int *)i4 + 5), v272, v280, v353, v354, v355, v356, v357, v358);
  }
  sub_100046780(a2, 1, "}", v266, v267, v268, v269, v270);
  sub_100030204(a1);
  if (os_map_str_count())
  {
    sub_100046780(a2, 1, "attractive services = {", v282, v283, v284, v285, v286);
    *(void *)&long long v366 = _NSConcreteStackBlock;
    *((void *)&v366 + 1) = 0x40000000;
    *(void *)&long long v367 = sub_1000327EC;
    *((void *)&v367 + 1) = &unk_100070B38;
    long long v368 = (unint64_t)a2;
    os_map_str_foreach();
    sub_100046780(a2, 1, "}", v287, v288, v289, v290, v291);
  }
  sub_100032650(a1, a2, 1, v282, v283, v284, v285, v286);
  uint64_t v292 = (void **)sub_100010724(0x80uLL);
  sub_10002958C((uint64_t)v292, (char)"shutting down", *(_DWORD *)(a1 + 1016) & 1, v293, v294, v295, v296, v297);
  sub_10002958C((uint64_t)v292, (char)"slain", (*(_DWORD *)(a1 + 1016) >> 1) & 1, v298, v299, v300, v301, v302);
  sub_10002958C((uint64_t)v292, (char)"uncorked", (*(_DWORD *)(a1 + 1016) >> 2) & 1, v303, v304, v305, v306, v307);
  sub_10002958C((uint64_t)v292, (char)"deactivated", (*(_DWORD *)(a1 + 1016) >> 4) & 1, v308, v309, v310, v311, v312);
  sub_10002958C((uint64_t)v292, (char)"inactive", (*(_DWORD *)(a1 + 1016) >> 5) & 1, v313, v314, v315, v316, v317);
  sub_10002958C((uint64_t)v292, (char)"in initial on-demand", (*(_DWORD *)(a1 + 1016) >> 6) & 1, v318, v319, v320, v321, v322);
  sub_10002958C((uint64_t)v292, (char)"exec hack", (*(_DWORD *)(a1 + 1016) >> 7) & 1, v323, v324, v325, v326, v327);
  sub_100046800(a2, v328, v329, v330, v331, v332, v333, v334, v352);
  sub_100046780(a2, 1, "properties = %s", v335, v336, v337, v338, v339, *v292);
  sub_100010778(v292);
  return sub_100046780(a2, 0, "}", v340, v341, v342, v343, v344);
}

uint64_t sub_10002D710(uint64_t a1, uint64_t a2)
{
  int v4 = (char *)sub_100010644(a2);
  uint64_t v5 = sub_10001063C(a2);
  uint64_t v6 = sub_10001060C(a2);
  uint64_t v43 = a1;
  xpc_object_t v44 = 0;
  uint64_t v37 = sub_10002BD38;
  uint64_t v38 = sub_10002C1B0;
  uint64_t v39 = sub_10002C2F8;
  uint64_t v40 = sub_10002C494;
  uint64_t v41 = sub_10002C4F8;
  uint64_t v42 = sub_10002C5F8;
  if (v6)
  {
    uint64_t v7 = sub_10002DB88(v6, &v44);
    unsigned int v45 = v7;
    xpc_object_t v8 = v44;
    if (v7)
    {
      uint64_t v33 = (const char *)v7;
      uint64_t v34 = xpc_strerror();
      uint64_t v32 = v4;
      uint64_t v9 = "Could not parse plist: path = %s, error = %d: %s";
LABEL_4:
      sub_10002DC18(a1, v8, 3, v9, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44);
      goto LABEL_22;
    }
  }
  else
  {
    xpc_object_t v8 = sub_10001062C(a2);
    xpc_object_t v44 = v8;
  }
  uint64_t v10 = (*(void *)(a2 + 48) >> 13) & 1;
  if ((sub_10002DCE8(v8, "Label") & 1) != 0 || sub_100010614(a2)) {
    uint64_t v11 = 128;
  }
  else {
    uint64_t v11 = 0;
  }
  if (*(void **)(a1 + 112) != qword_100075750) {
    v10 |= 0x80uLL;
  }
  unsigned int v12 = sub_10002DD24(a1, 3, v10, a2 + 16, (uint64_t)v4, v5);
  if (!v12)
  {
    if (sub_100015CAC(v4, "/System/Library/LaunchDaemons/com.apple.jetsamproperties")
      || sub_100015CAC(v4, "/AppleInternal/Library/LaunchDaemons/com.apple.jetsamproperties"))
    {
      unsigned int v45 = 0;
      goto LABEL_22;
    }
    uint64_t v16 = (*(void *)(a2 + 48) >> 10) & 0x22;
    int v17 = sub_100010620(a2);
    uint64_t v18 = 0x20000;
    if (!v17) {
      uint64_t v18 = 0;
    }
    unint64_t v19 = (v16 | v11 | v18) & 0xFFFFFFFFFFFFFDFFLL | ((((unint64_t)*(unsigned int *)(a2 + 48) >> 8) & 1) << 9);
    if (sub_100015CAC(v4, "/System/Library/LaunchAngels/")
      || sub_100015CAC(v4, "/AppleInternal/Library/LaunchAngels/")
      || (*(unsigned char *)(a2 + 50) & 4) != 0)
    {
      v19 |= 0x400uLL;
    }
    BOOL v20 = sub_100041068(a1);
    uint64_t v21 = *(void *)(a1 + 112);
    if ((_UNKNOWN *)v21 == &unk_1000755B8 || v20) {
      uint64_t v23 = v19 | 0x800;
    }
    else {
      uint64_t v23 = v19;
    }
    unint64_t v24 = v23 | ((unint64_t)(*(unsigned char *)(v21 + 128) & 2) << 11);
    BOOL v25 = sub_100015CAC(v4, "/Library/LaunchAgents/");
    uint64_t v26 = v24 | 0x12000;
    if (!v25) {
      uint64_t v26 = v24;
    }
    uint64_t v27 = v26 | (*(void *)(a2 + 48) >> 3) & 0x10000;
    if (sub_100015CAC(v4, "/System/Library/DeveloperModeLaunchDaemons/")) {
      unint64_t v28 = v27 | 0x4000;
    }
    else {
      unint64_t v28 = v27;
    }
    unsigned int v45 = 0;
    uint64_t v29 = sub_1000056B8((_DWORD *)a1, v8, v4, a2 + 16, (uint64_t)&v37, v28, (int *)&v45);
    if (v29)
    {
      sub_10002B594((_DWORD *)a1, v29);
      goto LABEL_22;
    }
    if ((int)v45 > 118)
    {
      if (v45 == 119 || v45 == 134) {
        goto LABEL_22;
      }
    }
    else
    {
      if (v45 == 17)
      {
        long long v48 = 0u;
        long long v49 = 0u;
        long long v46 = 0u;
        long long v47 = 0u;
        uint64_t v33 = sub_100042920(a2 + 16, (char *)&v46);
        uint64_t v34 = *(unsigned int *)(a2 + 36);
        uint64_t v32 = v4;
        uint64_t v9 = "Caller tried to import service with same label as an existing service: path = %s, caller = %s[%d]";
        goto LABEL_4;
      }
      if (v45 == 37) {
        goto LABEL_22;
      }
    }
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    uint64_t v30 = sub_100042920(a2 + 16, (char *)&v46);
    uint64_t v31 = *(unsigned int *)(a2 + 36);
    if (v45 == 152)
    {
      xpc_strerror();
      sub_10002DC18(a1, v8, 5, "Did not import service from caller: path = %s, caller = %s[%d], int error = %d: %s", v4);
      goto LABEL_22;
    }
    uint64_t v35 = v45;
    uint64_t v36 = xpc_strerror();
    uint64_t v33 = v30;
    uint64_t v34 = v31;
    uint64_t v32 = v4;
    uint64_t v9 = "Could not import service from caller: path = %s, caller = %s[%d], error = %d: %s";
    goto LABEL_4;
  }
  unsigned int v13 = v12;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  uint64_t v14 = sub_100042920(a2 + 16, (char *)&v46);
  if (v13 == 122)
  {
    sub_10002DC18(a1, v8, 3, "Caller specified a plist with bad ownership/permissions: path = %s, caller = %s[%d]", v4, v14, *(_DWORD *)(a2 + 36));
  }
  else if (v13 == 1)
  {
    sub_10002DE0C(a1, a2 + 16, 1, "service bootstrap (%s, io flags=%#llx, eval flags=%#llx)", v4, *(void *)(a2 + 48), v10);
  }
  unsigned int v45 = v13;
LABEL_22:
  if (v8) {
    xpc_release(v8);
  }
  return v45;
}

uint64_t sub_10002DB88(NSObject *a1, void *a2)
{
  size_t v9 = 0;
  buffer_ptr = 0;
  dispatch_data_t v3 = dispatch_data_create_map(a1, (const void **)&buffer_ptr, &v9);
  if (!v3) {
    return 12;
  }
  int v4 = v3;
  uint64_t v5 = (void *)xpc_create_from_plist();
  if (v5 && (uint64_t v6 = v5, xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary))
  {
    uint64_t v7 = 0;
    *a2 = v6;
  }
  else
  {
    uint64_t v7 = 109;
  }
  dispatch_release(v4);
  return v7;
}

void sub_10002DC18(uint64_t a1, xpc_object_t xdict, int a3, char *a4, ...)
{
  va_start(va, a4);
  if (xdict && (char string = xpc_dictionary_get_string(xdict, "Label")) != 0)
  {
    size_t v9 = string;
    uint64_t v10 = sub_10002A624(a1, 1);
    uint64_t v11 = sub_100015BE4("%s/%s", v10, v9);
    free(v10);
  }
  else
  {
    uint64_t v11 = sub_10002A624(a1, 1);
  }
  sub_100044138(v11, a3, a4, va, v4);
  free(v11);
}

const char *sub_10002DCE8(void *a1, const char *a2)
{
  uint64_t result = xpc_dictionary_get_string(a1, a2);
  if (result)
  {
    return (const char *)sub_100015CAC(result, "com.apple.");
  }
  return result;
}

uint64_t sub_10002DD24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = a1;
  do
  {
    uint64_t v13 = v12;
    uint64_t v12 = *(void *)(v12 + 232);
  }
  while (v12);
  if ((a2 - 1) <= 1 && (*(_DWORD *)(v13 + 1016) & 1) != 0
    || (a2 - 3) <= 1 && (*(unsigned char *)(a1 + 1016) & 3) != 0)
  {
    return 124;
  }
  if ((a3 & 0x88) != 0 && !sub_100032884(a4)) {
    return 154;
  }
  uint64_t v15 = *(void *)(a1 + 120);
  uint64_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 112)
                                                                                                + 104);

  return v16(a1, a2, a3, v15, a4, a5, a6);
}

void sub_10002DE0C(uint64_t a1, uint64_t a2, int a3, char *a4, ...)
{
  va_start(va, a4);
  if (a3 != 124)
  {
    if (a3 == 154) {
      int v6 = 65539;
    }
    else {
      int v6 = 3;
    }
    v13[0] = 0;
    va_copy((va_list)&v13[1], va);
    vasprintf(v13, a4, va);
    memset(v14, 0, sizeof(v14));
    char v7 = sub_100042920(a2, (char *)v14);
    xpc_strerror();
    sub_10002A5B8(a1, v6, "Caller not allowed to perform action: %s.%d, actiouint64_t n = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u", v8, v9, v10, v11, v12, v7);
    free(v13[0]);
  }
}

uint64_t sub_10002DF1C(uint64_t a1, uint64_t a2, NSObject *a3)
{
  int v6 = (const char *)sub_100010644(a2);
  uint64_t v7 = sub_10001063C(a2);
  uint64_t v8 = sub_10001060C(a2);
  xpc_object_t object = 0;
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0) {
    return 124;
  }
  uint64_t v10 = v8;
  uint64_t v11 = sub_10002DD24(a1, 4, 128, a2 + 16, (uint64_t)v6, v7);
  if (v11)
  {
    uint64_t v9 = v11;
    sub_10002DE0C(a1, a2 + 16, v11, "service bootout (%s)", v6);
    return v9;
  }
  if (v10)
  {
    uint64_t v12 = sub_10002DB88(v10, &object);
    if (v12)
    {
      uint64_t v9 = v12;
      xpc_strerror();
      sub_10002A5B8(a1, 3, "Could not parse plist: path = %s, int error = %d: %s:", v13, v14, v15, v16, v17, (char)v6);
      xpc_object_t v18 = object;
      goto LABEL_12;
    }
    xpc_object_t v18 = object;
  }
  else
  {
    xpc_object_t v18 = sub_10001062C(a2);
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary
    || (char string = (char *)xpc_dictionary_get_string(v18, "Label")) == 0)
  {
    uint64_t v9 = 109;
    goto LABEL_12;
  }
  uint64_t v21 = string;
  uint64_t v22 = sub_10002E140((_DWORD *)a1, string);
  if (!v22)
  {
    uint64_t v9 = 113;
    goto LABEL_12;
  }
  uint64_t v23 = (uint64_t)v22;
  uint64_t v24 = sub_1000201F8();
  if (v24)
  {
    uint64_t v9 = v24;
    sub_10002DE0C(a1, a2 + 16, v24, "service bootout (%s)", v21);
    goto LABEL_12;
  }
  sub_10002E2FC(v23, a2 + 16, (char)"booting out service");
  uint64_t v9 = sub_10002B6E4(a1, v23);
  if (v9 != 36)
  {
LABEL_25:
    if ((*(unsigned char *)(a2 + 49) & 8) != 0)
    {
      sub_1000302D8(a1, v21, 1);
      sub_10004B2A4();
    }
    goto LABEL_12;
  }
  if (!*(void *)(v23 + 280))
  {
    if (a3)
    {
      *(void *)(v23 + 280) = a3;
      dispatch_group_enter(a3);
    }
    goto LABEL_25;
  }
  uint64_t v9 = 37;
LABEL_12:
  if (v18) {
    xpc_release(v18);
  }
  return v9;
}

char *sub_10002E140(_DWORD *a1, char *a2)
{
  for (uint64_t i = *(char **)&a1[2 * (sub_100015EDC(a2) % 0x17uLL) + 84]; i; uint64_t i = (char *)*((void *)i + 15))
  {
    if (!strcmp(i + 1392, a2)) {
      break;
    }
  }
  uint64_t v5 = os_map_str_delete();
  if (v5)
  {
    uint64_t v6 = v5;
    v16[0] = sub_10002BD38;
    v16[1] = sub_10002C1B0;
    v16[2] = sub_10002C2F8;
    v16[3] = sub_10002C494;
    _OWORD v16[4] = sub_10002C4F8;
    v16[5] = sub_10002C5F8;
    void v16[6] = a1;
    sub_100047250(v5);
    uint64_t v7 = (void *)xpc_bundle_create();
    sub_10004725C(v6);
    xpc_bundle_populate();
    int v15 = 0;
    uint64_t i = sub_100006E30((uint64_t)a1, (uint64_t)v7, (_OWORD *)(v6 + 16), 0, (uint64_t)v16, *(void *)(v6 + 48), &v15);
    char v8 = sub_100047244(v6);
    if (i)
    {
      sub_10002A5B8((uint64_t)a1, 5, "Service stub initialized for %s", v9, v10, v11, v12, v13, v8);
      sub_10002B594(a1, (uint64_t)i);
    }
    else
    {
      sub_10002A5B8((uint64_t)a1, 5, "Service stub initialization failed for %s [%d]", v9, v10, v11, v12, v13, v8);
    }
    xpc_release(v7);
    sub_10001A174((void *)v6);
  }
  return i;
}

void sub_10002E2FC(uint64_t a1, uint64_t a2, char a3)
{
  bzero(v11, 0x400uLL);
  sub_1000328DC(*(_DWORD *)(a2 + 20), v11);
  sub_10001E4BC(a1, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v6, v7, v8, v9, v10, a3);
}

void sub_10002E3A4(uint64_t a1, char *a2, int a3)
{
  sub_1000302D8(a1, a2, a3);

  sub_10004B2A4();
}

uint64_t sub_10002E3CC(size_t a1, uint64_t a2)
{
  unsigned int v3 = 0;
  sub_10002E408(a1, a2, 0, &v3);
  if ((v3 & 0xFFFFFFFD) == 0x79) {
    return 0;
  }
  else {
    return v3;
  }
}

char *sub_10002E408(size_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v8 = sub_10001064C(a2);
  uint64_t v9 = sub_10001063C(a2);
  uint64_t property = (const char *)xpc_bundle_get_property();
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary();
  if ((*(unsigned char *)(a1 + 1016) & 3) == 0)
  {
    uint64_t v13 = info_dictionary;
    uint64_t v68 = a3;
    uint64_t v70 = a4;
    uint64_t v14 = (*(void *)(a2 + 48) >> 13) & 1;
    if ((sub_10002DCE8(info_dictionary, "CFBundleIdentifier") & 1) != 0
      || sub_100010614(a2))
    {
      uint64_t v15 = 128;
    }
    else
    {
      uint64_t v15 = 0;
    }
    uint64_t v16 = v14 | 0x80;
    if (*(void **)(a1 + 112) == qword_100075750) {
      uint64_t v16 = v14;
    }
    uint64_t v69 = v16;
    if ((*(unsigned char *)(a2 + 49) & 0x40) != 0 && sub_100015CF0(property, ".appex")) {
      v15 |= 0x40uLL;
    }
    v73[0] = 0;
    if (sub_100032A20(a1, v8, v73))
    {
      char v17 = xpc_bundle_get_property();
      xpc_strerror();
      sub_10002A5B8(a1, 3, "Could not get domain target from bundle: path = %s, int error = %d: %s", v18, v19, v20, v21, v22, v17);
LABEL_14:
      uint64_t v12 = 0;
      int v23 = 112;
LABEL_15:
      int v72 = v23;
LABEL_30:
      a4 = v70;
      goto LABEL_31;
    }
    uint64_t v67 = (_OWORD *)(a2 + 16);
    uint64_t v24 = (void *)v73[0];
    uint64_t v25 = a1;
    if ((void *)v73[0] != qword_100075750)
    {
      uint64_t v26 = (*(uint64_t (**)(_OWORD *))(v73[0] + 88))(v67);
      uint64_t v27 = sub_100030024(v24, v26);
      if (*(_UNKNOWN **)(v27 + 112) == &unk_1000755B8)
      {
        uint64_t v25 = v27;
        if (*(void *)(v27 + 968))
        {
          uint64_t v25 = sub_100041094();
          if (!v25) {
            goto LABEL_14;
          }
        }
      }
      else
      {
        uint64_t v25 = v27;
      }
    }
    int v28 = sub_100010620(a2);
    uint64_t v29 = 0x20000;
    if (!v28) {
      uint64_t v29 = 0;
    }
    uint64_t v66 = v29 | v15;
    if ((v15 & 0x40) != 0)
    {
      xpc_object_t value = xpc_dictionary_get_value(v13, "XPCService");
      if (value && (uint64_t v32 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary))
      {
        char string = xpc_dictionary_get_string(v32, "_RoleAccount");
        uint64_t v30 = v69;
        if (string && !strcmp(string, "mobile")) {
          uint64_t v30 = v14 | 0x10;
        }
      }
      else
      {
        uint64_t v30 = v69;
      }
      v66 &= ~0x80uLL;
    }
    else
    {
      uint64_t v30 = v69;
    }
    int v72 = sub_10002DD24(v25, 3, v30, (uint64_t)v67, (uint64_t)property, v9);
    if (v72)
    {
      uint64_t v33 = *(void *)(*(void *)(v25 + 112) + 112);
      xpc_strerror();
      sub_10002A5B8(a1, 3, "Path not allowed in target domain: xpc_type_t type = %s, path = %s error = %d: %s, origin = %s", v34, v35, v36, v37, v38, v33);
      goto LABEL_29;
    }
    int v40 = *(_DWORD *)(a2 + 48);
    v71[0] = sub_10002BD38;
    v71[1] = sub_10002C1B0;
    void v71[2] = sub_10002C2F8;
    v71[3] = sub_10002C494;
    v71[4] = sub_10002C4F8;
    v71[5] = sub_10002C5F8;
    v71[6] = v25;
    uint64_t v41 = (char *)xpc_dictionary_get_string(v13, "CFBundleIdentifier");
    if (!v41)
    {
      sub_10002A5B8(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v42, v43, v44, v45, v46, (char)property);
      uint64_t v12 = 0;
      int v23 = 107;
      goto LABEL_15;
    }
    char v47 = (char)v41;
    long long v48 = sub_10002E140((_DWORD *)v25, v41);
    if (v48)
    {
      uint64_t v12 = v48;
      long long v49 = (const char *)sub_10001E040((uint64_t)v48);
      if (strcmp(property, v49))
      {
        sub_10001E040((uint64_t)v12);
        sub_10002A5B8(a1, 4, "Attempt to re-bootstrap service from different path, will use existing: service = %s, existing = %s, conflicting = %s", v50, v51, v52, v53, v54, v47);
      }
      int v55 = 121;
      int v72 = 121;
    }
    else
    {
      uint64_t v60 = (2 * v40) & 0x200 | v66;
      if ((*(unsigned char *)(a2 + 49) & 0x40) == 0 && *(void **)(a1 + 112) == qword_100075750)
      {
        uint64_t v61 = sub_10001064C(a2);
        v73[0] = 0;
        if (!sub_100032A20(a1, v61, v73) && (void *)v73[0] == qword_100075750)
        {
          uint64_t v62 = (void *)xpc_bundle_get_info_dictionary();
          xpc_object_t v63 = xpc_dictionary_get_value(v62, "XPCService");
          if (v63)
          {
            uint64_t v64 = v63;
            if (xpc_get_type(v63) == (xpc_type_t)&_xpc_type_dictionary
              && !xpc_dictionary_get_value(v64, "_AdditionalSubServices")
              && !xpc_dictionary_get_value(v64, "_AdditionalServices")
              && !byte_100076A46)
            {
              if (v25 != a1) {
                sub_100050D0C();
              }
              sub_1000471F4(a1, v8, (uint64_t)v67, v60, &v72);
              if (v65)
              {
                sub_100047244(v65);
                os_map_str_insert();
                uint64_t v12 = 0;
                int v23 = 123;
                goto LABEL_15;
              }
LABEL_29:
              uint64_t v12 = 0;
              goto LABEL_30;
            }
          }
        }
      }
      uint64_t v12 = sub_100006E30(v25, v8, v67, v68, (uint64_t)v71, v60, &v72);
      if (!v12) {
        goto LABEL_30;
      }
      int v55 = v72;
      if (v25 == a1 && v72 != 121)
      {
        uint64_t v58 = (_DWORD *)a1;
LABEL_62:
        sub_10002B594(v58, (uint64_t)v12);
        goto LABEL_30;
      }
    }
    uint64_t v56 = *((void *)v12 + 19);
    if (v56)
    {
      do
      {
        if ((*(unsigned char *)(v56 + 88) & 0x40) == 0)
        {
          if (*(void *)(a1 + 976)) {
            uint64_t v57 = *(void *)(a1 + 976);
          }
          else {
            uint64_t v57 = a1;
          }
          if (!sub_100030744(v57, (char *)(v56 + 168))) {
            sub_10002C948(a1, v12, v56, 4);
          }
        }
        uint64_t v56 = *(void *)(v56 + 16);
      }
      while (v56);
      int v55 = v72;
    }
    if (v55) {
      goto LABEL_30;
    }
    uint64_t v58 = (_DWORD *)v25;
    goto LABEL_62;
  }
  uint64_t v12 = 0;
  int v72 = 124;
LABEL_31:
  *a4 = v72;
  return v12;
}

uint64_t sub_10002E9B8(uint64_t a1, char *a2)
{
  if (*(void *)(a1 + 976)) {
    a1 = *(void *)(a1 + 976);
  }
  return sub_100030744(a1, a2);
}

uint64_t sub_10002E9C8(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = sub_100047400();
  if (*((_DWORD *)v3 + 5) || *((_DWORD *)v3 + 3) || *((_DWORD *)v3 + 7))
  {
    sub_100043D78(65539, "Dropping coalition notification from unknown source (%llu)", a2);
    return 5;
  }
  else
  {
    sub_10001DAD0(a2);
    sub_1000145F8();
    return 0;
  }
}

BOOL sub_10002EA3C(uint64_t a1, uint64_t a2)
{
  BOOL result = 1;
  if (*(_UNKNOWN **)(a1 + 112) == &unk_100075750)
  {
    unint64_t v3 = *(void *)(a1 + 120);
    if (!(v3 >> 31))
    {
      uint64_t v4 = *(unsigned int *)(a2 + 20);
      if ((v4 & 0x80000000) == 0 && v3 == v4) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10002EA7C()
{
  qword_100076478 = (uint64_t)sub_10002EB7C((uint64_t)&unk_1000755B8, 0, 0, 0, 0, 0, (uint64_t)&qword_1000769A0);
  *(_DWORD *)(qword_100076478 + 1016) |= 0x2000u;
  byte_100076480 = os_variant_is_darwinos();
  sub_100047428(3, (uint64_t)sub_10002F1E8);
  sub_100047428(5, (uint64_t)sub_10002F648);
  sub_100047428(7, (uint64_t)sub_10002F7F0);
  sub_1000475C0((uint64_t)sub_10004D290, 0x830uLL);
  sub_1000475C0((uint64_t)sub_10004D4F4, 0x2CuLL);
  mach_port_t v0 = mach_host_self();
  uint64_t result = host_set_special_port(v0, 22, dword_100076A00);
  if (result) {
    return sub_100051760();
  }
  return result;
}

void *sub_10002EB7C(uint64_t a1, uint64_t a2, const char *a3, const char *a4, int a5, uint64_t a6, uint64_t a7)
{
  if ((void *)a1 == qword_100075750 && a2 == 0) {
    sub_100040E80("Can't create PID domain for PID 0");
  }
  size_t v15 = strlen(*(const char **)(a1 + 120));
  size_t v16 = v15;
  long long v80 = 0u;
  long long v81 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  *(_OWORD *)__str = 0u;
  long long v75 = 0u;
  *(void *)int v72 = 0;
  v73[0] = 0;
  *(void *)((char *)v73 + 5) = 0;
  if (a3)
  {
    snprintf(__str, 0x80uLL, ".%s", a3);
    size_t v17 = v16 + strlen(a3) + 22;
LABEL_8:
    snprintf(v72, 0x15uLL, ".%lu", a2);
    goto LABEL_9;
  }
  size_t v17 = v15 + 21;
  if ((_UNKNOWN *)a1 != &unk_1000755B8) {
    goto LABEL_8;
  }
LABEL_9:
  uint64_t v18 = sub_10001A698(v17);
  v18[14] = a1;
  v18[15] = a2;
  uint64_t v19 = v18 + 15;
  v18[29] = a6;
  snprintf((char *)v18 + 1024, v17, "%s%s%s", *(const char **)(a1 + 120), __str, v72);
  long long v20 = *(_OWORD *)a7;
  *(_OWORD *)(v18 + 37) = *(_OWORD *)(a7 + 16);
  *(_OWORD *)(v18 + 35) = v20;
  if (*(void *)(v18[14] + 88) && sub_100030024((void *)v18[14], *v19)) {
    sub_100040E80("refusing to add a duplicate domain: type=%s handle=%lu", *(const char **)(v18[14] + 112), v18[15]);
  }
  uint64_t v21 = (uint64_t *)(v18[14] + 8 * (sub_100015EA8(v19, 8) % 0xBuLL));
  uint64_t v22 = *v21;
  v18[4] = *v21;
  if (v22) {
    *(void *)(v22 + 40) = v18 + 4;
  }
  uint64_t *v21 = (uint64_t)v18;
  v18[5] = v21;
  os_map_str_init();
  if (a5) {
    *((_DWORD *)v18 + 46) = a5;
  }
  uint64_t v23 = sub_100020E4C(*(_DWORD *)(a7 + 20));
  if (v23)
  {
    uint64_t v24 = *(void *)(v23 + 248);
  }
  else if (sub_10003B7AC() == -1 {
         || (unsigned int v25 = sub_10003B8F8(), v25 == -3)
  }
         || (uint64_t v24 = sub_100030024(qword_100075640, v25)) == 0)
  {
    if ((uint64_t v26 = sub_100047400(), v26 != (long long *)a7)
      && (!v26
       || (*(void *)v26 == *(void *)a7 ? (BOOL v27 = *((void *)v26 + 1) == *(void *)(a7 + 8)) : (BOOL v27 = 0),
           v27 ? (BOOL v28 = *((void *)v26 + 2) == *(void *)(a7 + 16)) : (BOOL v28 = 0),
           v28 ? (BOOL v29 = *((void *)v26 + 3) == *(void *)(a7 + 24)) : (BOOL v29 = 0),
           !v29))
      || (uint64_t v24 = sub_10004740C()) == 0
      || *(void **)(v24 + 112) != qword_100075640)
    {
      uint64_t v24 = sub_100030024(qword_100075640, *(unsigned int *)(a7 + 4));
    }
  }
  if (v24) {
    uint64_t v30 = v24;
  }
  else {
    uint64_t v30 = a6;
  }
  memset(v71, 0, sizeof(v71));
  uint64_t v31 = sub_100042920(a7, (char *)v71);
  v18[39] = sub_1000159F0(v31);
  if (a4)
  {
    v18[121] = sub_1000159F0(a4);
    if ((void *)a1 == qword_100075640) {
      goto LABEL_49;
    }
  }
  else
  {
    if ((void *)a1 == qword_100075640)
    {
      v18[121] = sub_1000159F0("PostLogOutSync");
LABEL_49:
      int v32 = a2;
LABEL_50:
      *((_DWORD *)v18 + 14) = v32;
      *((unsigned char *)v18 + 104) |= 1u;
      goto LABEL_51;
    }
    v18[121] = 0;
  }
  if ((void *)a1 == qword_100075750)
  {
    int v32 = *(_DWORD *)(a7 + 4);
    if (v32 || *(_UNKNOWN **)(v30 + 112) != &unk_1000755B8) {
      goto LABEL_50;
    }
  }
LABEL_51:
  *((_DWORD *)v18 + 15) = -101;
  uint64_t v33 = (void *)v18[14];
  if (v33 != (void *)&unk_1000755B8)
  {
    if (v33 == qword_100075640)
    {
      uint64_t v35 = v18 + 7;
    }
    else if (v33 == qword_100075750)
    {
      uint64_t v35 = (_DWORD *)(v30 + 60);
    }
    else
    {
      uint64_t v34 = v18[29];
      if (!v34) {
        sub_100050D0C();
      }
      uint64_t v35 = (_DWORD *)(v34 + 60);
    }
    *((_DWORD *)v18 + 15) = *v35;
  }
  *((_DWORD *)v18 + 16) = -1;
  sub_10002FDEC((uint64_t)v18);
  sub_10002A8FC((uint64_t)v18);
  if (sub_100041068((uint64_t)v18) || (_UNKNOWN *)v18[14] == &unk_1000755B8)
  {
    sub_10002FC3C((uint64_t)v18, v36, v37, v38, v39, v40, v41, v42, v56);
    *((_DWORD *)v18 + 254) |= 0x40u;
  }
  if ((_UNKNOWN *)a1 == &unk_1000755B8)
  {
    if (a6) {
      sub_100050D0C();
    }
  }
  else
  {
    if ((void *)a1 == qword_100075750)
    {
      sub_10002FC3C((uint64_t)v18, v36, v37, v38, v39, v40, v41, v42, v56);
      long long v69 = 0u;
      long long v70 = 0u;
      long long v67 = 0u;
      long long v68 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      long long v61 = 0u;
      long long v62 = 0u;
      *(_OWORD *)tuint64_t n = 0u;
      long long v60 = 0u;
      int v43 = sub_1000428E0(a2, tn);
      if (v43 != 3)
      {
        if (v43) {
          _os_assumes_log_ctx();
        }
        else {
          v18[16] = *((void *)&v68 + 1);
        }
      }
      uint64_t v58 = 0;
      memset(buffer, 0, sizeof(buffer));
      int v44 = sub_100042A14(a2, buffer);
      if (v44 != 3)
      {
        if (v44) {
          _os_assumes_log_ctx();
        }
        else {
          *(_OWORD *)(v18 + 125) = buffer[0];
        }
      }
    }
    uint64_t v45 = *(void *)(a6 + 320);
    _OWORD v18[2] = v45;
    if (v45) {
      *(void *)(v45 + 24) = v18 + 2;
    }
    *(void *)(a6 + 320) = v18;
    _OWORD v18[3] = a6 + 320;
    sub_10001A0AC(v18);
    sub_10002A8FC(a6);
    sub_10001A174(v18);
  }
  tn[0] = -1;
  uint64_t v46 = v18[14];
  if ((_UNKNOWN *)v46 == &unk_1000755B8)
  {
    uint64_t v47 = sub_10000D56C(0x33u, 6u, (mach_port_context_t)v18);
  }
  else
  {
    if ((void *)v46 != qword_100075750) {
      goto LABEL_80;
    }
    uint64_t v47 = *((unsigned int *)v18 + 46);
    if (!v47)
    {
      task_name_for_pid(mach_task_self_, *(_DWORD *)v19, tn);
      uint64_t v47 = tn[0];
    }
  }
  sub_10003B11C((uint64_t)v18, v47, v37, v38, v39, v40, v41, v42, v56);
  uint64_t v46 = v18[14];
LABEL_80:
  if ((_UNKNOWN *)v46 == &unk_1000755B8)
  {
    sub_100031E10(v18, 0, dword_100076A00, 4, v39, v40, v41, v42);
LABEL_87:
    uint64_t v48 = (uint64_t)xpc_retain((xpc_object_t)qword_100076A08);
LABEL_89:
    v18[17] = v48;
    goto LABEL_90;
  }
  if (*(unsigned char *)(v46 + 128))
  {
    uint64_t v49 = sub_100016388((uint64_t)(v18 + 128), (mach_port_context_t)v18);
    mach_port_name_t v50 = v49;
    sub_100047688(v49, v18);
    sub_100031E10(v18, 0, v50, 4, v51, v52, v53, v54);
    uint64_t v48 = xpc_mach_send_create_with_disposition();
    goto LABEL_89;
  }
  if ((void *)v46 == qword_100075750)
  {
    if (!v30) {
      sub_100040E80("user cannot create its own domain");
    }
    if (sub_100031E10(v18, 0, *(_DWORD *)(*(void *)(v30 + 88) + 16), 4, v39, v40, v41, v42)) {
      sub_100051794();
    }
    goto LABEL_87;
  }
LABEL_90:
  sub_10002A5B8((uint64_t)v18, 5, "created", v38, v39, v40, v41, v42, v56);
  return v18;
}

uint64_t sub_10002F1E8(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  unsigned int v11 = 0;
  uint64_t v7 = sub_1000300B8(a3, a2 != 817, (int *)&v11);
  if (!v7) {
    return v11;
  }
  uint64_t v8 = v7;
  uint64_t v9 = (uint64_t *)sub_100047400();
  uint64_t result = 45;
  switch(a2)
  {
    case 800:
      uint64_t result = sub_100032C0C(v8, v9, a3, a4);
      break;
    case 801:
      uint64_t result = sub_100032E04((void *)v8, (uint64_t)v9, a3, a4);
      break;
    case 802:
      uint64_t result = sub_100033184(v8, (uint64_t)v9, a3, a4);
      break;
    case 803:
      uint64_t result = sub_10003338C(v8, v9, a3, a4);
      break;
    case 804:
      uint64_t result = sub_10003343C(v8, (uint64_t)v9, a3, a4);
      break;
    case 805:
      uint64_t result = sub_10003374C(v8, (uint64_t)v9, a3, a4);
      break;
    case 806:
      uint64_t result = sub_100033A64(v8, a3, a4);
      break;
    case 807:
      uint64_t result = sub_100033ACC(v8, a3, a4);
      break;
    case 808:
      uint64_t result = sub_100033B80(v8, (uint64_t)v9, a3, a4);
      break;
    case 809:
      uint64_t result = sub_100033D20(v8, (uint64_t)v9, a3, a4);
      break;
    case 811:
      uint64_t result = sub_100033EC0(v8, (uint64_t)v9, a3, a4);
      break;
    case 812:
      uint64_t result = sub_100034088(v8, (uint64_t)v9, a3, a4);
      break;
    case 813:
      uint64_t result = sub_1000342BC((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 814:
      uint64_t result = sub_1000343F0((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 815:
      uint64_t result = sub_100034740((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 816:
      uint64_t result = sub_1000345B4((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 817:
    case 818:
    case 823:
    case 824:
    case 827:
    case 836:
    case 845:
      return result;
    case 819:
      uint64_t result = sub_100034934(v8, (uint64_t)v9, a3, a4);
      break;
    case 820:
      uint64_t result = sub_100034A5C(v8, (uint64_t)v9, a3, a4);
      break;
    case 821:
      uint64_t result = sub_100034B58((void **)v8, (uint64_t)v9, a3, a4);
      break;
    case 822:
    case 826:
      uint64_t result = 142;
      break;
    case 825:
      uint64_t result = sub_100034F78(v8, (uint64_t)v9, a3, a4);
      break;
    case 828:
      uint64_t result = sub_1000351B8(v8, (uint64_t)v9, a3, a4);
      break;
    case 829:
      if (*(_UNKNOWN **)(v8 + 112) == &unk_1000755B8) {
        uint64_t result = sub_10001D894(a3, a4);
      }
      else {
        uint64_t result = 125;
      }
      break;
    case 830:
      uint64_t result = sub_10001D9E8(a3, a4);
      break;
    case 831:
      uint64_t result = sub_100035298((void **)v8, v9, a3);
      break;
    case 832:
      uint64_t result = sub_1000353DC((void **)v8, (uint64_t)v9, a3);
      break;
    case 833:
      uint64_t result = sub_100035650(v8, (uint64_t)v9, a3, a4);
      break;
    case 834:
      uint64_t result = sub_100035874(v8, (uint64_t)v9, a3, a4);
      break;
    case 835:
      uint64_t result = sub_100035988(v8, (uint64_t)v9, a3, a4);
      break;
    case 837:
      uint64_t result = sub_100035B7C(v8, (uint64_t)v9, a3, a4);
      break;
    case 838:
      uint64_t result = sub_100035C78((uint64_t)v9, a3, a4);
      break;
    case 839:
      uint64_t result = sub_100036078(v8, (uint64_t)v9, a3, a4);
      break;
    case 840:
      uint64_t result = sub_1000361F4(v8, (uint64_t)v9, a3, a4);
      break;
    case 841:
      uint64_t result = sub_100035D5C(v8, (uint64_t)v9, a3, a4);
      break;
    case 842:
      uint64_t result = sub_100035E64(v8, (uint64_t)v9, a3, a4);
      break;
    case 843:
      uint64_t result = sub_100035F6C(v8, (uint64_t)v9, a3);
      break;
    case 844:
      uint64_t result = sub_1000362EC((void *)v8, (uint64_t)v9, a3, a4);
      break;
    case 846:
      uint64_t result = sub_10003639C(v8, (uint64_t)v9, a3, a4);
      break;
    case 847:
      uint64_t result = sub_100036448(v8, (uint64_t)v9, a3);
      break;
    default:
      uint64_t result = 33;
      break;
  }
  return result;
}

uint64_t sub_10002F648(uint64_t a1, int a2, void *a3, void *a4)
{
  unsigned int v12 = 0;
  uint64_t v7 = sub_1000300B8(a3, 1, (int *)&v12);
  if (!v7) {
    return v12;
  }
  uint64_t v8 = v7;
  if ((*(unsigned char *)(v7 + 1016) & 3) != 0) {
    return 124;
  }
  if (*(void **)(v7 + 112) == qword_100075750) {
    return 45;
  }
  if (*(_WORD *)(v7 + 204))
  {
    if (*(void *)(v7 + 136)) {
      int right = xpc_mach_send_get_right();
    }
    else {
      int right = 0;
    }
    sub_100036864(v8, right, a3, 1);
    return 0;
  }
  else
  {
    unsigned int v11 = sub_100047400();
    uint64_t result = 126;
    switch(a2)
    {
      case 200:
      case 201:
      case 202:
      case 205:
        return result;
      case 203:
        return sub_100039628(v8, a3, a4);
      case 204:
        return sub_1000396AC(v8, (uint64_t)v11, a3, a4);
      case 206:
        return sub_1000397A0(v8, (uint64_t)v11, a3, a4);
      case 207:
        return sub_100039894(v8, (uint64_t)v11, a3, a4);
      case 208:
        return 45;
      case 209:
        if (xpc_dictionary_expects_reply())
        {
          sub_100047418();
          return 45;
        }
        uint64_t result = 22;
        break;
      case 211:
        return sub_100039B98(a3, a4);
      default:
        return 33;
    }
  }
  return result;
}

uint64_t sub_10002F7F0(uint64_t a1, int a2, void *a3, void *a4)
{
  unsigned int v33 = 0;
  uint64_t v7 = sub_1000300B8(a3, 1, (int *)&v33);
  if (!v7) {
    return v33;
  }
  uint64_t v13 = v7;
  if ((*(unsigned char *)(v7 + 1016) & 3) != 0) {
    return 124;
  }
  uint64_t v15 = *(void *)(v7 + 112);
  if ((_UNKNOWN *)v15 != &unk_1000755B8 && (*(unsigned char *)(v15 + 128) & 2) == 0)
  {
    sub_10002A5B8(v7, 3, "The launch_msg(3) API may only be used on the system or user domains.", v8, v9, v10, v11, v12, v32);
    return 125;
  }
  if (xpc_dictionary_get_BOOL(a3, "justdoit")) {
    *(_DWORD *)(v13 + 1016) |= 0x100u;
  }
  size_t v16 = sub_100047400();
  uint64_t v17 = (uint64_t)v16;
  if (a2 == 101)
  {
    v34[0] = v13;
    size_t v20 = sub_1000375E4(v34, *((_DWORD *)v16 + 5), 0);
    if (!v20)
    {
      uint64_t result = 113;
      goto LABEL_37;
    }
    uint64_t v21 = v20;
    uint64_t result = (uint64_t)sub_1000221F0(v20);
    if (result)
    {
      xpc_object_t v22 = (xpc_object_t)result;
      sub_10003AE48(v13, v21, (void *)result, 0);
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v24 = reply;
LABEL_19:
      xpc_dictionary_set_value(reply, "response", v22);
      xpc_release(v22);
      uint64_t result = 0;
      *a4 = v24;
    }
  }
  else
  {
    if (a2 != 100)
    {
      uint64_t result = 33;
      goto LABEL_37;
    }
    xpc_object_t value = xpc_dictionary_get_value(a3, "request");
    if (!value) {
      goto LABEL_15;
    }
    uint64_t v19 = value;
    xpc_object_t v36 = 0;
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string)
    {
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v34[0] = v13;
        v34[1] = v17;
        xpc_object_t object = 0;
        xpc_dictionary_apply_f();
        uint64_t v26 = *(void *)(v13 + 992);
        if (v26)
        {
          if (object)
          {
            xpc_release(object);
            uint64_t v26 = *(void *)(v13 + 992);
          }
          *(void *)(v13 + 992) = 0;
          xpc_object_t v27 = xpc_dictionary_create_reply(a3);
          xpc_dictionary_set_uint64(v27, "response", 0);
          if (*(void *)(v26 + 272)) {
            sub_100050F24();
          }
          *(void *)(v26 + 272) = v27;
        }
        else
        {
          xpc_object_t v30 = xpc_dictionary_create_reply(a3);
          xpc_object_t v31 = object;
          if (!object)
          {
            xpc_object_t v31 = xpc_uint64_create(0);
            xpc_object_t object = v31;
          }
          xpc_dictionary_set_value(v30, "response", v31);
          xpc_release(object);
          *a4 = v30;
        }
        uint64_t result = 0;
        goto LABEL_37;
      }
LABEL_15:
      uint64_t result = 22;
      goto LABEL_37;
    }
    int64_t string_ptr = (char *)xpc_string_get_string_ptr(v19);
    uint64_t result = sub_100039C64((_DWORD *)v13, v17, string_ptr, 0, &v36);
    if (result == 36)
    {
      uint64_t v28 = *(void *)(v13 + 992);
      if (v28)
      {
        *(void *)(v13 + 992) = 0;
        xpc_object_t v29 = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uint64(v29, "response", 0);
        uint64_t result = *(void *)(v28 + 272);
        if (result) {
          sub_100050F24();
        }
        *(void *)(v28 + 272) = v29;
      }
      else
      {
        uint64_t result = 36;
      }
      goto LABEL_37;
    }
    if (!result)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v24 = reply;
      xpc_object_t v22 = v36;
      goto LABEL_19;
    }
  }
LABEL_37:
  *(_DWORD *)(v13 + 1016) &= ~0x100u;
  return result;
}

void sub_10002FAE8(uint64_t a1)
{
  if (sub_10003B5BC())
  {
    if (sub_100041068(a1))
    {
      sub_10002A5B8(a1, 5, "going into initial on-demand mode for a multiuser device", v2, v3, v4, v5, v6, v17);
      sub_10002FC3C(a1, v7, v8, v9, v10, v11, v12, v13, v18);
      uint64_t v14 = sub_100014B58();
      uint64_t v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v14);
      dispatch_time_t v16 = dispatch_time(0, 45000000000);
      dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = sub_10002FC74;
      handler[3] = &unk_100070A78;
      handler[4] = a1;
      void handler[5] = v15;
      dispatch_source_set_event_handler(v15, handler);
      dispatch_source_set_mandatory_cancel_handler();
      dispatch_activate(v15);
      *(void *)(a1 + 160) = v15;
    }
  }
}

void sub_10002FC3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9 = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a1 + 192) = v9 + 1;
  if (!v9 && *(void **)(a1 + 112) != qword_100075750) {
    sub_10002A5B8(a1, 5, "entering ondemand mode", a4, a5, a6, a7, a8, a9);
  }
}

void sub_10002FC74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8(*(void *)(a1 + 32), 4, "timed out initial on-demand mode for a multiuser device", a4, a5, a6, a7, a8, v17);
  sub_10002B2F0(*(void *)(a1 + 32), v9, v10, v11, v12, v13, v14, v15);
  dispatch_time_t v16 = *(NSObject **)(a1 + 40);
  if (v16 != *(NSObject **)(*(void *)(a1 + 32) + 160)) {
    sub_100050D0C();
  }
  dispatch_source_cancel(v16);
  *(void *)(*(void *)(a1 + 32) + 160) = 0;
}

void sub_10002FCD0(uint64_t a1)
{
}

void sub_10002FCD8()
{
  if (qword_100076A30)
  {
    mach_port_t v0 = (void *)qword_100076478;
    *(_DWORD *)(qword_100076478 + 1016) |= 4u;
    v0[119] = sub_10004B24C();
    sub_10002FDEC((uint64_t)v0);
    sub_1000412A8((uint64_t)v0);
    sub_10002FAE8((uint64_t)v0);
    if (v0[121]) {
      sub_100050D0C();
    }
    v0[121] = sub_1000159F0("System");
    sub_10002B4E4(v0, &qword_1000769A0, 0, v1, v2, v3, v4, v5);
    if (signal(15, (void (__cdecl *)(int))1) == (void (__cdecl *)(int))-1) {
      sub_1000517B0();
    }
    uint64_t v6 = sub_100014B58();
    qword_100076488 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, v6);
    dispatch_set_context((dispatch_object_t)qword_100076488, v0);
    dispatch_source_set_event_handler_f((dispatch_source_t)qword_100076488, (dispatch_function_t)sub_10002FEC0);
    uint64_t v7 = qword_100076488;
    dispatch_activate(v7);
  }
}

uint64_t sub_10002FDEC(uint64_t result)
{
  uint64_t v1 = (_DWORD *)result;
  uint64_t v2 = *(void **)(result + 112);
  if (v2 == (void *)&unk_1000755B8)
  {
    if ((*(unsigned char *)(result + 1016) & 4) == 0) {
      return result;
    }
    uint64_t result = sub_10003B5BC();
    if (!result) {
      return result;
    }
    int v3 = v1[15];
    if (v3 == -101) {
      int v3 = -1;
    }
    int v6 = v3;
    uint64_t v7 = 0xFFFFFFFFLL;
LABEL_15:
    uint64_t result = sub_10003B654(&v6);
    v1[16] = result;
    v1[254] |= 0x800u;
    return result;
  }
  if (v2 == qword_100075640)
  {
    uint64_t result = sub_10003B5BC();
    if (!result) {
      return result;
    }
    unsigned int v5 = v1[14];
    int v4 = v1[15];
    if (v4 == -101) {
      int v4 = -1;
    }
    int v6 = v4;
    uint64_t v7 = v5;
    goto LABEL_15;
  }
  if (v2 == qword_100075750)
  {
    uint64_t result = sub_10003B5BC();
    if (result)
    {
      uint64_t result = sub_10003B7AC();
      v1[16] = result;
    }
  }
  return result;
}

void sub_10002FEC0(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8(a1, 196611, "System shutdown initiated by kernel - launchd got a SIGTERM", a4, a5, a6, a7, a8, v16);

  sub_10002ABD8(a1, v9, v10, v11, v12, v13, v14, v15);
}

void *sub_10002FF04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10002FF18(qword_100076478, a1, a2, a4, a5, a6, a7, a8);
}

void *sub_10002FF18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = 0;
  while (1)
  {
    uint64_t v12 = *(void **)(a1 + 8 * v11 + 704);
    if (v12) {
      break;
    }
LABEL_8:
    if (++v11 == 31)
    {
      if (a3)
      {
        uint64_t v14 = 0;
        while (1)
        {
          uint64_t v15 = *(void *)(a1 + 8 * v14 + 336);
          if (v15) {
            break;
          }
LABEL_19:
          if (++v14 == 23) {
            goto LABEL_20;
          }
        }
        while (1)
        {
          uint64_t v12 = *(void **)(v15 + 184);
          if (v12) {
            break;
          }
LABEL_18:
          uint64_t v15 = *(void *)(v15 + 120);
          if (!v15) {
            goto LABEL_19;
          }
        }
        while (1)
        {
          uint64_t v16 = v12[9] ? v12[9] : (uint64_t)v12;
          if (sub_100048818(v16, 2, a3, a4, a5, a6, a7, a8) == a2) {
            break;
          }
          uint64_t v12 = (void *)v12[2];
          if (!v12) {
            goto LABEL_18;
          }
        }
      }
      else
      {
LABEL_20:
        uint64_t v17 = *(void *)(a1 + 320);
        if (v17)
        {
          do
          {
            uint64_t v12 = (void *)sub_10002FF18(v17, a2, a3);
            if (v12) {
              break;
            }
            uint64_t v17 = *(void *)(v17 + 16);
          }
          while (v17);
        }
        else
        {
          return 0;
        }
      }
      return v12;
    }
  }
  while (1)
  {
    uint64_t v13 = v12[9] ? v12[9] : (uint64_t)v12;
    if (sub_100048818(v13, 2, a3, a4, a5, a6, a7, a8) == a2) {
      return v12;
    }
    uint64_t v12 = (void *)v12[4];
    if (!v12) {
      goto LABEL_8;
    }
  }
}

uint64_t sub_100030018()
{
  return qword_100076478;
}

uint64_t sub_100030024(void *a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (a1 == (void *)&unk_1000755B8) {
    return qword_100076478;
  }
  for (uint64_t result = a1[sub_100015EA8(&v3, 8) % 0xBuLL]; result; uint64_t result = *(void *)(result + 32))
  {
    if (*(void *)(result + 120) == v3) {
      break;
    }
  }
  return result;
}

uint64_t sub_1000300B8(void *a1, char a2, int *a3)
{
  memset(v11, 0, sizeof(v11));
  xpc_dictionary_get_audit_token();
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  int v6 = sub_100038E80(a1, &v14, (uint64_t *)&v13);
  int v12 = v6;
  if (v6)
  {
    int v7 = v6;
    uint64_t result = 0;
LABEL_3:
    *a3 = v7;
    return result;
  }
  unint64_t v9 = v13;
  uint64_t v10 = v14;
  uint64_t result = sub_100038F9C(v14, v13, (uint64_t)v11);
  if (!result)
  {
    if (a2)
    {
      uint64_t result = (uint64_t)sub_10003902C(v10, v9, 0, 0, (uint64_t)v11, &v12);
      int v7 = v12;
    }
    else
    {
      sub_100043D78(3, "Could not find domain from request: type=%s handle=%lu", (const char *)v10[14], v9);
      uint64_t result = 0;
      int v7 = 112;
    }
    goto LABEL_3;
  }
  return result;
}

BOOL sub_100030190(uint64_t a1, void *a2)
{
  int v2 = *(unsigned __int16 *)(a1 + 204);
  if (*(_WORD *)(a1 + 204))
  {
    if (*(void *)(a1 + 136)) {
      int right = xpc_mach_send_get_right();
    }
    else {
      int right = 0;
    }
    sub_100036864(a1, right, a2, 1);
  }
  return v2 == 0;
}

uint64_t sub_1000301F4(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t sub_1000301FC(uint64_t a1)
{
  return *(void *)(a1 + 120);
}

uint64_t sub_100030204(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 960);
  if (!result)
  {
    *(void *)(a1 + 960) = sub_100013BB8(0x18uLL);
    os_map_str_init();
    return *(void *)(a1 + 960);
  }
  return result;
}

BOOL sub_100030248(uint64_t a1, char *__s1)
{
  int v2 = *(void **)(a1 + 112);
  if (__s1)
  {
    if (v2 == &unk_1000755B8)
    {
      uint64_t v3 = "System";
    }
    else
    {
      uint64_t v3 = *(const char **)(a1 + 968);
      if (!v3) {
        sub_100040E80("non-system session had no name");
      }
    }
    return sub_100015D70(__s1, v3);
  }
  else if (v2 == &unk_1000755B8)
  {
    return *(void *)(a1 + 968) == 0;
  }
  else
  {
    return sub_100041068(a1);
  }
}

uint64_t sub_1000302D8(uint64_t a1, char *__s, int a3)
{
  if ((a3 - 1) >= 2) {
    sub_100050D0C();
  }
  if (!*(void *)(a1 + 952)) {
    return 125;
  }
  if (strchr(__s, 60))
  {
    sub_10002A5B8(a1, 4, "refusing to persist enabled/disabled state for '%s' as it contains illegal XML character '<'", v6, v7, v8, v9, v10, (char)__s);
    return 140;
  }
  else
  {
    int v12 = "Disabling";
    if (a3 == 2) {
      int v12 = "Enabling";
    }
    sub_10002A5B8(a1, 5, "%s service %s", v6, v7, v8, v9, v10, (char)v12);
    xpc_object_t value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 952), __s);
    if (!value
      || (uint64_t v14 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL)
      || (a3 == 1) != xpc_BOOL_get_value(v14))
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 952), __s, a3 == 1);
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 952), "_dirty", 1);
    }
    return 0;
  }
}

xpc_object_t sub_100030404(uint64_t a1, const char *a2)
{
  xpc_object_t result = *(xpc_object_t *)(a1 + 952);
  if (result)
  {
    xpc_object_t result = xpc_dictionary_get_value(result, a2);
    if (result)
    {
      uint64_t v3 = result;
      if (xpc_get_type(result) != (xpc_type_t)&_xpc_type_dictionary
        || (xpc_object_t result = xpc_dictionary_get_value(v3, "Disabled"), (v3 = result) != 0))
      {
        if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_BOOL) {
          return v3;
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

__n128 sub_100030478(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a1 + 280);
  long long v3 = *(_OWORD *)(a1 + 296);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_10003048C(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 312))
  {
    if (sub_100012768(*(void *)(a2 + 312))) {
      _os_assumes_log_ctx();
    }
    uint64_t v4 = *(void *)(a2 + 312);
    return sub_100011574(v4);
  }
  if (a3) {
    goto LABEL_6;
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_100075750)
  {
    if (*(void *)(a2 + 304))
    {
      uint64_t v9 = 0;
      long long v7 = 0u;
      long long v8 = 0u;
      v6[0] = 0;
      v6[1] = a2 + 1392;
      *(void *)&long long v7 = sub_100022930(a2);
      DWORD2(v7) = *(_DWORD *)(a2 + 896);
      long long v8 = *(_OWORD *)(a2 + 992);
      uint64_t v4 = sub_10001DCB8(*(const void **)(a2 + 304), v6);
      goto LABEL_10;
    }
LABEL_6:
    uint64_t v4 = (uint64_t)sub_10003057C(a2, 0);
LABEL_10:
    *(void *)(a2 + 312) = v4;
    return sub_100011574(v4);
  }
  return *(void *)(a1 + 1000);
}

unsigned char *sub_10003057C(uint64_t a1, unsigned int a2)
{
  uint64_t v7 = 0;
  long long v5 = 0u;
  long long v6 = 0u;
  v4[0] = a2;
  v4[1] = a1 + 1392;
  *(void *)&long long v5 = sub_100022930(a1);
  DWORD2(v5) = *(_DWORD *)(a1 + 896);
  long long v6 = *(_OWORD *)(a1 + 992);
  LOBYTE(v7) = *(uint64_t *)(a1 + 1376) < 0;
  return sub_10001DC50((uint64_t)v4);
}

uint64_t sub_1000305EC(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 320))
  {
    if (sub_100012768(*(void *)(a2 + 320)) != 1) {
      _os_assumes_log_ctx();
    }
    return sub_100011574(*(void *)(a2 + 320));
  }
  else if (*(_UNKNOWN **)(a1 + 112) == &unk_100075750)
  {
    return *(void *)(a1 + 1008);
  }
  else
  {
    long long v5 = sub_10003057C(a2, 1u);
    *(void *)(a2 + 320) = v5;
    uint64_t v3 = sub_100011574((uint64_t)v5);
    long long v6 = sub_10002284C(a2);
    if (v6)
    {
      strlen(v6);
      coalition_info_set_name();
    }
  }
  return v3;
}

const char *sub_1000306D0(uint64_t a1, char *a2)
{
  if (*(void **)(a1 + 112) != qword_100075750) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 232);
  if (*(void *)(v3 + 976)) {
    uint64_t v4 = *(void *)(v3 + 976);
  }
  else {
    uint64_t v4 = *(void *)(a1 + 232);
  }
  __n128 result = (const char *)sub_100030744(v4, a2);
  if (result)
  {
    uint64_t v5 = sub_1000494DC((uint64_t)result);
    __n128 result = (const char *)sub_1000228F4(v5);
    if (result)
    {
      if (!strcmp(result, "com.apple.keyboard-service")) {
        return (const char *)v5;
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_100030744(uint64_t a1, char *a2)
{
  for (uint64_t i = *(void *)(a1 + 8 * (sub_100015EDC(a2) % 0x1FuLL) + 704); i; uint64_t i = *(void *)(i + 32))
  {
    if ((*(unsigned char *)(i + 88) & 0x40) == 0 && sub_100015D70((char *)(i + 168), a2)) {
      break;
    }
  }
  return i;
}

uint64_t sub_1000307E8(uint64_t a1, uint64_t a2, const char *a3)
{
  for (uint64_t i = *(void *)(a2 + 176); i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(unsigned char *)(i + 88) & 0x40) == 0 && sub_100015D70((char *)(i + 168), a3)) {
      break;
    }
  }
  return i;
}

uint64_t sub_100030834(size_t a1, void *a2, const char *a3)
{
  uint64_t v6 = sub_1000307E8(a1, (uint64_t)a2, a3);
  if (!v6)
  {
    sub_100048970((unint64_t)a2, a3, (unint64_t)sub_10002C708, (unint64_t)a2);
    uint64_t v6 = v7;
    *(unsigned char *)(v7 + 88) |= 8u;
    sub_10002C948(a1, a2, v7, 16);
  }
  return v6;
}

uint64_t sub_1000308B8(uint64_t a1, uint64_t *a2, uint64_t *a3, void *a4, uint64_t a5)
{
  unint64_t v9 = *(void *)(a1 + 80) + a5;
  uint64_t result = (uint64_t)xpc_array_create(0, 0);
  if (v9 >> 62)
  {
    __break(1u);
  }
  else
  {
    uint64_t v11 = result;
    uint64_t result = (uint64_t)sub_100013BB8(4 * v9);
    uint64_t v12 = result;
    uint64_t v13 = *(uint64_t **)(a1 + 88);
    if (v13)
    {
      uint64_t v14 = 0;
      do
      {
        uint64_t result = xpc_array_set_mach_send();
        uint64_t v15 = v14 + 1;
        *(_DWORD *)(v12 + 4 * v14) = *((_DWORD *)v13 + 5);
        uint64_t v13 = (uint64_t *)*v13;
        ++v14;
      }
      while (v13);
    }
    else
    {
      uint64_t v15 = 0;
    }
    *a2 = v11;
    *a3 = v12;
    *a4 = v15;
  }
  return result;
}

uint64_t sub_100030974(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10002DD24(a1, a2, a3, a4, 0, 0);
}

uint64_t sub_100030980(_DWORD *a1, void *a2, char *a3, uint64_t a4, unint64_t a5, _DWORD *a6)
{
  int v9 = 0;
  v8[0] = sub_10002BD38;
  v8[1] = sub_10002C1B0;
  v8[2] = sub_10002C2F8;
  void v8[3] = sub_10002C494;
  v8[4] = sub_10002C4F8;
  v8[5] = sub_10002C5F8;
  void v8[6] = a1;
  uint64_t result = sub_1000056B8(a1, a2, a3, a4, (uint64_t)v8, a5, &v9);
  if (v9)
  {
    if (result) {
      sub_100050D0C();
    }
  }
  else if (!result)
  {
    sub_100050D0C();
  }
  *a6 = v9;
  return result;
}

uint64_t sub_100030A38()
{
  return byte_100076480;
}

const char *sub_100030A44(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 1016) & 3) == 0) {
    return 0;
  }
  if (sub_100014184(0)) {
    return "system shutdown";
  }
  if (sub_100014184(1)) {
    return "userspace reboot";
  }
  uint64_t v3 = *(void *)(a1 + 112);
  if ((_UNKNOWN *)v3 == &unk_100075750) {
    return "teardown of process-scoped services after host exited";
  }
  if ((*(unsigned char *)(v3 + 128) & 2) != 0) {
    return "logout";
  }
  return 0;
}

_DWORD *sub_100030ADC(uint64_t a1)
{
  int v2 = sub_100013BB8(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 136);
  if (v3) {
    LODWORD(v3) = xpc_mach_send_get_right();
  }
  v2[4] = v3;
  return v2;
}

uint64_t sub_100030B1C(uint64_t a1, const void *a2)
{
  uint64_t result = *(unsigned int *)(a1 + 64);
  if (result == -1)
  {
    if (!qword_100076AB0) {
      return 0xFFFFFFFFLL;
    }
    if (sub_100045ED4((rb_tree_t **)qword_100076AB0, a2) == (rb_tree_t **)&_xpc_BOOL_true) {
      uint64_t v4 = 4;
    }
    else {
      uint64_t v4 = 6;
    }
    bzero(v20, 0x800uLL);
    unint64_t v19 = 512;
    if (sub_10003B868(v4, (uint64_t)v20, (uint64_t *)&v19))
    {
      xpc_strerror();
      sub_10002A5B8(a1, 3, "Unable to find persona with type %d: %d - %s", v10, v11, v12, v13, v14, v4);
      return 0xFFFFFFFFLL;
    }
    if (*(_DWORD *)(a1 + 60) == -101) {
      int v15 = -1;
    }
    else {
      int v15 = *(_DWORD *)(a1 + 60);
    }
    if (!v19)
    {
LABEL_18:
      sub_10002A5B8(a1, 3, "No matching personas of type %d uid %d, found %zu", v5, v6, v7, v8, v9, v4);
      return 0xFFFFFFFFLL;
    }
    uint64_t v16 = 0;
    while (1)
    {
      int v17 = sub_10003B8F8();
      if (v17 != -3 && v17 == v15) {
        break;
      }
      if (++v16 >= v19) {
        goto LABEL_18;
      }
    }
    uint64_t result = v20[v16];
    if (result == -1) {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

void sub_100030C70(void *a1)
{
  uint64_t v2 = a1[29];
  uint64_t v3 = sub_10002A624((uint64_t)a1, 1);
  sub_10002A5B8(v2, 5, "removing child: %s", v4, v5, v6, v7, v8, (char)v3);
  free(v3);
  uint64_t v9 = a1[2];
  if (v9) {
    *(void *)(v9 + 24) = a1[3];
  }
  *(void *)a1[3] = v9;
  a1[2] = -1;
  a1[3] = -1;
  if ((*(unsigned char *)(v2 + 1017) & 0x10) != 0) {
    sub_100041420(v2, (uint64_t)a1);
  }
  sub_10001A174(a1);
  sub_10002A97C(v2);

  sub_10001A174(a1);
}

uint64_t sub_100030D48(uint64_t a1)
{
  if (sub_10000FE40(a1, 3)) {
    return 1;
  }

  return sub_10000FE40(a1, 4);
}

void sub_100030D9C(uint64_t a1)
{
  sub_100047E00(*(unsigned int *)(a1 + 16), *(void **)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 24));

  free((void *)a1);
}

uint64_t sub_100030DE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int *)(a1 + 288);
  if (!v8) {
    sub_100050D0C();
  }
  *(_DWORD *)(a1 + 288) = 0;

  return sub_100021748(a1, v8, a3, a4, a5, a6, a7, a8);
}

void sub_100030E18(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 248) != a1) {
    sub_100051868(a2, a1);
  }
  uint64_t v10 = *(unsigned int *)(a2 + 296);
  int v11 = (__int16)(*(_WORD *)(a2 + 300))--;
  if ((v11 - 32769) <= 0xFFFEFFFF) {
    sub_1000517F0(v10, a2);
  }
  if (v11 <= 0) {
    sub_10005182C(v10, a2);
  }
  if (v10) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  if (v12 >= v11)
  {
    int v13 = *(_DWORD *)(a2 + 368);
    if ((v13 & 2) != 0)
    {
      *(_DWORD *)(a2 + 368) = v13 & 0xFFFFFFFD;
      if (!v10) {
        goto LABEL_16;
      }
    }
    else
    {
      sub_10002A5B8(a1, 5, "service inactive: %s%s", a4, a5, a6, a7, a8, a2 + 112);
      uint64_t v14 = *(void *)(a2 + 88);
      if (v14) {
        *(void *)(v14 + 96) = *(void *)(a2 + 96);
      }
      **(void **)(a2 + 96) = v14;
      *(void *)(a2 + 88) = -1;
      *(void *)(a2 + 96) = -1;
      if (!*(_DWORD *)(a2 + 296))
      {
        --*(_DWORD *)(a1 + 200);
LABEL_16:
        uint64_t v16 = sub_1000229A8(a2);
        BOOL v17 = sub_1000471B4(v16);
        unsigned int v25 = *(_DWORD *)(a2 + 368) & 0xFFFFDFFF;
        if (!v17) {
          unsigned int v25 = *(_DWORD *)(a2 + 368);
        }
        int v26 = *(_DWORD *)(a2 + 296);
        *(_DWORD *)(a2 + 360) = -1;
        unsigned int v15 = v25 & 0xFFFFFF3F;
        *(_DWORD *)(a2 + 368) = v25 & 0xFFFFFF3F;
        *(_WORD *)(a2 + 300) = 0;
        if (!(v26 | v25 & 0x2000))
        {
          sub_100021EAC(a2, v18, v19, v20, v21, v22, v23, v24);
          unsigned int v15 = *(_DWORD *)(a2 + 368);
        }
        goto LABEL_20;
      }
    }
    *(_DWORD *)(a2 + 360) = -1;
    unsigned int v15 = *(_DWORD *)(a2 + 368) & 0xFFFFFF3F;
    *(_WORD *)(a2 + 300) = 0;
LABEL_20:
    *(_DWORD *)(a2 + 368) = v15 & 0xFFFFDFFF;
    xpc_object_t v27 = *(void **)(a2 + 272);
    if (v27)
    {
      *(void *)(a2 + 272) = 0;
      if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
        _os_assumes_log_ctx();
      }
      xpc_release(v27);
    }
    uint64_t v28 = *(NSObject **)(a2 + 328);
    if (v28)
    {
      *(void *)(a2 + 328) = 0;
      dispatch_group_leave(v28);
      dispatch_release(v28);
    }
    xpc_object_t v29 = *(NSObject **)(a2 + 336);
    if (v29)
    {
      dispatch_group_leave(v29);
      *(void *)(a2 + 336) = 0;
    }
    *(_DWORD *)(a2 + 368) &= ~0x8000u;
    sub_10003115C(a2);
    if (*(_DWORD *)(a2 + 296))
    {
      if (*(void *)(a2 + 160)) {
        sub_100040E80("unmanaged service deactivated with active dynamic endpoints");
      }
      if (*(void *)(a2 + 168)) {
        sub_100040E80("unmanaged service deactivated with active pid endpoints");
      }
      sub_10002A5B8(a1, 5, "removing inactive unmanaged service: %s", v31, v32, v33, v34, v35, a2 + 112);
      memset((void *)a2, 204, 0x570uLL);
      free((void *)a2);
      sub_10001A174((void *)a1);
    }
    else if ((*(unsigned char *)(a1 + 1016) & 1) != 0 || (*(unsigned char *)(a2 + 368) & 0x10) != 0)
    {
      int v43 = *(NSObject **)(a2 + 280);
      if (v43)
      {
        dispatch_group_leave(v43);
        *(void *)(a2 + 280) = 0;
      }
      sub_1000311A4(a1, a2, v30, v31, v32, v33, v34, v35);
    }
    else
    {
      sub_1000314E8((void *)a2);
      if (!*(_WORD *)(a1 + 204) && *(_DWORD *)(a2 + 288))
      {
        sub_100030DE4(a2, v36, v37, v38, v39, v40, v41, v42);
      }
    }
  }
}

void sub_10003115C(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 296) && (*(unsigned char *)(a1 + 369) & 0x40) != 0)
  {
    dispatch_group_leave((dispatch_group_t)qword_100076490);
    *(_DWORD *)(a1 + 368) &= ~0x4000u;
  }
}

void sub_1000311A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a2 + 248) != a1)
  {
    uint64_t v34 = sub_1000203FC(a2, 1);
    uint64_t v35 = sub_10002A624(a1, 1);
    sub_100040E80("%s is being removed from a mismatched domain %s", v34, v35);
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_100075750 || *(_WORD *)(a2 + 300)) {
    sub_10002A5B8(a1, 5, "removing service: %s", a4, a5, a6, a7, a8, a2 + 112);
  }
  *(_DWORD *)(a2 + 368) = *(_DWORD *)(a2 + 368) & 0xFFFFFFEE | 0x10;
  sub_1000315B8(a2, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = *(void *)(a2 + 152);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 16);
      sub_100031684(a1, v10);
      uint64_t v10 = v11;
    }
    while (v11);
  }
  uint64_t v12 = *(void *)(a2 + 176);
  if (v12)
  {
    do
    {
      uint64_t v13 = *(void *)(v12 + 16);
      sub_100031684(a1, v12);
      uint64_t v12 = v13;
    }
    while (v13);
  }
  uint64_t v14 = *(void *)(a2 + 184);
  if (v14)
  {
    do
    {
      uint64_t v15 = *(void *)(v14 + 16);
      sub_100031684(a1, v14);
      uint64_t v14 = v15;
    }
    while (v15);
  }
  uint64_t v16 = *(void **)(a2 + 192);
  if (v16)
  {
    uint64_t v18 = (void *)v16[2];
    uint64_t v19 = (void *)v16[3];
    BOOL v17 = v16 + 2;
    if (v18)
    {
      do
      {
        uint64_t v20 = v18;
        _OWORD v18[3] = v19;
        *(void *)v16[3] = v18;
        *BOOL v17 = -1;
        v17[1] = -1;
        sub_10001A174(v16);
        BOOL v17 = v20 + 2;
        uint64_t v18 = (void *)v20[2];
        uint64_t v19 = (void *)v20[3];
        uint64_t v16 = v20;
      }
      while (v18);
    }
    else
    {
      uint64_t v20 = *(void **)(a2 + 192);
    }
    *uint64_t v19 = 0;
    *BOOL v17 = -1;
    v17[1] = -1;
    sub_10001A174(v20);
  }
  uint64_t v21 = *(void *)(a2 + 200);
  if (v21)
  {
    do
    {
      uint64_t v22 = *(void *)(v21 + 40);
      sub_10002B6E4(a1);
      uint64_t v21 = v22;
    }
    while (v22);
  }
  if ((*(_DWORD *)(a2 + 368) & 0x600) == 0x200)
  {
    uint64_t v23 = *(void *)(a2 + 40);
    *(_DWORD *)(a2 + 368) |= 0x400u;
    uint64_t v24 = *(void **)(a2 + 48);
    if (v23)
    {
      *(void *)(v23 + 48) = v24;
      uint64_t v24 = *(void **)(a2 + 48);
    }
    else
    {
      uint64_t v25 = *(void *)(a2 + 256);
      *(_DWORD *)(v25 + 240) = *(_DWORD *)(v25 + 224);
      *(void *)(v25 + 232) = *(void *)(v25 + 216);
      *(_DWORD *)(v25 + 224) = 5474;
      *(void *)(v25 + 208) = v24;
      *(void *)(v25 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
    }
    void *v24 = v23;
    *(void *)(a2 + 40) = -1;
    *(void *)(a2 + 48) = -1;
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 64);
    *(void *)(a2 + 72) = *(void *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = 5474;
    *(void *)(a2 + 56) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
  }
  if (sub_100020E0C(a2))
  {
    int v26 = *(_DWORD **)(a2 + 256);
    --v26[66];
    sub_10001A174(v26);
  }
  xpc_object_t v27 = *(void **)(a1 + 96);
  if (v27)
  {
    do
    {
      uint64_t v28 = (void *)*v27;
      if (v27[2] == a2)
      {
        if (v28) {
          v28[1] = v27[1];
        }
        *(void *)v27[1] = v28;
        void *v27 = -1;
        v27[1] = -1;
        j__free(v27);
      }
      xpc_object_t v27 = v28;
    }
    while (v28);
  }
  uint64_t v29 = *(void *)(a2 + 120);
  if (v29) {
    *(void *)(v29 + 128) = *(void *)(a2 + 128);
  }
  **(void **)(a2 + 128) = v29;
  *(void *)(a2 + 120) = -1;
  *(void *)(a2 + 128) = -1;
  --*(_DWORD *)(a1 + 196);
  uint64_t v30 = *(void *)(a2 + 312);
  if (v30)
  {
    uint64_t v31 = (void *)sub_10001269C(v30);
    os_release(v31);
    *(void *)(a2 + 312) = 0;
  }
  uint64_t v32 = *(void *)(a2 + 320);
  if (v32)
  {
    uint64_t v33 = (void *)sub_10001269C(v32);
    os_release(v33);
    *(void *)(a2 + 320) = 0;
  }
  if (*(void *)(a1 + 72) == a2) {
    *(void *)(a1 + 72) = 0;
  }
  sub_100006D50((void *)a2);
  sub_10001A174((void *)a2);
  sub_10002A97C(a1);

  sub_10001A174((void *)a1);
}

void sub_1000314E8(void *a1)
{
  for (uint64_t i = a1[19]; i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(unsigned char *)(i + 88) & 4) != 0) {
      sub_100040E80("service deactivated with active endpoints");
    }
    sub_100049778(i);
  }
  for (uint64_t j = a1[22]; j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(unsigned char *)(j + 88) & 4) != 0) {
      sub_100040E80("service deactivated with active event endpoints");
    }
    sub_100049778(j);
  }
  for (uint64_t k = a1[23]; k; uint64_t k = *(void *)(k + 16))
  {
    if ((*(unsigned char *)(k + 88) & 4) != 0) {
      sub_100040E80("service deactivated with active instance endpoints");
    }
    sub_100049778(k);
  }
  for (uint64_t m = a1[24]; m; uint64_t m = *(void *)(m + 16))
    sub_10001CB34(m);

  sub_100021FB8((uint64_t)a1);
}

void sub_1000315B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 369) & 8) != 0)
  {
    uint64_t v9 = *(void *)(a1 + 160);
    if (v9)
    {
      do
      {
        uint64_t v10 = *(void *)(v9 + 16);
        sub_100049C6C(v9, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v9 = v10;
      }
      while (v10);
    }
    uint64_t v11 = *(void *)(a1 + 168);
    if (v11)
    {
      do
      {
        uint64_t v12 = *(void *)(v11 + 16);
        sub_100049C6C(v11, a2, a3, a4, a5, a6, a7, a8);
        uint64_t v11 = v12;
      }
      while (v12);
    }
  }
  uint64_t v13 = *(void *)(a1 + 152);
  if (v13)
  {
    do
    {
      uint64_t v14 = *(void *)(v13 + 16);
      sub_100049C6C(v13, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v13 = v14;
    }
    while (v14);
  }
  uint64_t v15 = *(void *)(a1 + 176);
  if (v15)
  {
    do
    {
      uint64_t v16 = *(void *)(v15 + 16);
      sub_100049C6C(v15, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v15 = v16;
    }
    while (v16);
  }
  uint64_t v17 = *(void *)(a1 + 184);
  if (v17)
  {
    do
    {
      uint64_t v18 = *(void *)(v17 + 16);
      sub_100049C6C(v17, a2, a3, a4, a5, a6, a7, a8);
      uint64_t v17 = v18;
    }
    while (v18);
  }
  uint64_t v19 = *(void *)(a1 + 192);
  if (v19)
  {
    do
    {
      uint64_t v20 = *(void *)(v19 + 16);
      sub_10001CF40(v19);
      uint64_t v19 = v20;
    }
    while (v20);
  }

  sub_100022140(a1);
}

void sub_100031684(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 72))
  {
    sub_100031884((void *)a2);
  }
  else
  {
    uint64_t v4 = *(void **)(a2 + 64);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)v4[6];
        sub_100031884(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    if ((*(unsigned char *)(a2 + 88) & 0x20) != 0)
    {
      int v6 = *(_DWORD *)(a2 + 80);
      if (v6)
      {
        if (*(void *)(a1 + 976)) {
          uint64_t v7 = *(void *)(a1 + 976);
        }
        else {
          uint64_t v7 = a1;
        }
        uint64_t v8 = *(void *)(v7 + 976);
        if (v8) {
          BOOL v9 = v6 == 4;
        }
        else {
          BOOL v9 = 1;
        }
        if (v9) {
          uint64_t v8 = v7;
        }
        uint64_t v10 = (mach_port_name_t *)(v8 + 88);
        do
        {
          uint64_t v10 = *(mach_port_name_t **)v10;
          if (!v10) {
            sub_100040E80("domain has no corresponding special port entry");
          }
        }
        while (v10[5] != v6);
        sub_10002A54C(v7, v10);
      }
      int v11 = *(_DWORD *)(a2 + 84);
      if (v11)
      {
        if (v11 == 24)
        {
          task_t v12 = mach_host_self();
          sub_100045844(v12, 0);
          uint64_t v13 = &qword_100076498;
        }
        else
        {
          uint64_t v14 = v11;
          mach_port_t v15 = mach_host_self();
          if (host_set_special_port(v15, v14, 0)) {
            _os_assumes_log();
          }
          uint64_t v13 = (uint64_t *)((char *)&unk_1000764A0 + 8 * v14);
        }
        *uint64_t v13 = 0;
      }
      if (sub_100041068(a1))
      {
        if (*(void *)(a1 + 168))
        {
          if (sub_10004B3A8((char *)(a2 + 168)))
          {
            uint64_t v22 = *(void *)(a1 + 168);
            if (v22)
            {
              if (sub_100049E24(a2, v22, v16, v17, v18, v19, v20, v21))
              {
                uint64_t v23 = sub_1000494DC(a2);
                xpc_strerror();
                sub_10001E4BC(v23, 4, "Failed to stash endpoint %s: %d - %s", v24, v25, v26, v27, v28, a2 - 88);
              }
            }
          }
        }
      }
      uint64_t v29 = *(void *)(a2 + 32);
      if (v29) {
        *(void *)(v29 + 40) = *(void *)(a2 + 40);
      }
      **(void **)(a2 + 40) = v29;
      *(void *)(a2 + 32) = -1;
      *(void *)(a2 + 40) = -1;
    }
    uint64_t v30 = *(void *)(a2 + 16);
    if (v30) {
      *(void *)(v30 + 24) = *(void *)(a2 + 24);
    }
    **(void **)(a2 + 24) = v30;
    *(void *)(a2 + 16) = -1;
    *(void *)(a2 + 24) = -1;
    sub_10001A174((void *)a2);
  }
}

void sub_100031884(void *a1)
{
  if (!a1[9]) {
    sub_100040E80("alias-removal attempt of non-aliased endpoint");
  }
  uint64_t v1 = a1[4];
  if (v1) {
    *(void *)(v1 + 40) = a1[5];
  }
  *(void *)a1[5] = v1;
  uint64_t v2 = a1[6];
  if (v2) {
    *(void *)(v2 + 56) = a1[7];
  }
  *(void *)a1[7] = v2;

  free(a1);
}

void sub_1000318EC(uint64_t a1, uint64_t a2)
{
  pid_t v4 = sub_1000221B4(a2);
  if (sub_10004372C(v4) && sub_100014184(1))
  {
    int v12 = sub_1000106F0("kern.darkboot");
    sub_10002A5B8(a1, 5, "Queried sysctl kern.darkboot: %u", v13, v14, v15, v16, v17, v12);
    if (v12 == 1)
    {
      sub_10002A5B8(a1, 5, "Setting sysctl kern.darkboot to %u", v18, v19, v20, v21, v22, 2);
      sub_1000106EC("kern.darkboot", 2);
    }
    sub_1000141A4("Abandoning service: %s", (const char *)(a2 + 1392));
  }
  *(_DWORD *)(a2 + 368) |= 0x800u;

  sub_1000315B8(a2, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_1000319CC(uint64_t a1, uint64_t a2)
{
  pid_t v4 = (const char *)sub_1000494DC(a2);
  if (*(void *)(a1 + 976)) {
    uint64_t v5 = *(void *)(a1 + 976);
  }
  else {
    uint64_t v5 = a1;
  }
  uint64_t v6 = sub_100030744(v5, (char *)(a2 + 168));
  if (v6)
  {
    if (*(void *)(v6 + 72)) {
      uint64_t v7 = *(void *)(v6 + 72);
    }
    else {
      uint64_t v7 = v6;
    }
    uint64_t v8 = sub_1000494DC(v7);
    if (sub_100049508(a2) && !sub_100049508(v7))
    {
      sub_10001E4BC(v8, 4, "Unmanaged endpoint \"%s\" was canceled to transfer the ownership to: %s", v10, v11, v12, v13, v14, v7 - 88);
      sub_100049C6C(v7, v21, v22, v23, v24, v25, v26, v27);
    }
    else
    {
      uint64_t v15 = sub_100048818(v7, 2, v9, v10, v11, v12, v13, v14);
      if (!sub_100031DC0(v15))
      {
        sub_10001E4BC((uint64_t)v4, 4, "The endpoint \"%s\" defined in plist already exists and is owned by: %s", v16, v17, v18, v19, v20, a2 - 88);
        return 37;
      }
      *(unsigned char *)(v7 + 88) |= 0x40u;
    }
  }
  if ((sub_1000052DC((uint64_t)v4, 3) & 1) == 0)
  {
    uint64_t v28 = a1;
    do
    {
      if (*(void *)(v28 + 976)) {
        uint64_t v29 = *(void *)(v28 + 976);
      }
      else {
        uint64_t v29 = v28;
      }
      uint64_t v30 = sub_100030744(v29, (char *)(a2 + 168));
      uint64_t v31 = sub_100031F38(v28);
      uint64_t v28 = v31;
      if (v30) {
        BOOL v32 = 1;
      }
      else {
        BOOL v32 = v31 == 0;
      }
    }
    while (!v32);
    if (v30)
    {
      uint64_t v33 = sub_1000494DC(v30);
      if (sub_1000052DC(v33, 3))
      {
        sub_10001E4BC((uint64_t)v4, 4, "The endpoint \"%s\" would shadow a trusted one owned by %s, ignoring", v34, v35, v36, v37, v38, a2 - 88);
        return 37;
      }
    }
  }
  if (*(void *)(a1 + 976)) {
    a1 = *(void *)(a1 + 976);
  }
  if ((*(unsigned char *)(a2 + 88) & 0x10) != 0)
  {
    if (sub_100041068(a1) || *(_UNKNOWN **)(a1 + 112) == &unk_1000755B8) {
      *(_DWORD *)(a2 + 84) = 24;
    }
    else {
      *(_DWORD *)(a2 + 80) = 128;
    }
  }
  uint64_t v40 = sub_1000494DC(a2);
  if (sub_1000052DC(v40, 2))
  {
    uint64_t v46 = (int *)(a2 + 84);
    if (*(_DWORD *)(a2 + 84) && !sub_100041068(a1) && *(_UNKNOWN **)(a1 + 112) != &unk_1000755B8)
    {
      int v47 = *v46;
LABEL_43:
      mach_host_special_port_description();
      sub_10001E4BC(v40, 3, "Non-system service tried to claim host-special port: %d: %s", v48, v49, v50, v51, v52, v47);
      int *v46 = 0;
    }
  }
  else
  {
    if (*(_DWORD *)(a2 + 80))
    {
      sub_10001E4BC(v40, 3, "Non-system service tried to claim task-special port: %d", v41, v42, v43, v44, v45, *(_DWORD *)(a2 + 80));
      *(_DWORD *)(a2 + 80) = 0;
    }
    uint64_t v46 = (int *)(a2 + 84);
    int v47 = *(_DWORD *)(a2 + 84);
    if (v47) {
      goto LABEL_43;
    }
  }
  uint64_t v53 = (uint64_t *)(a1 + 8 * (sub_100015EDC((unsigned char *)(a2 + 168)) % 0x1FuLL) + 704);
  uint64_t v54 = *v53;
  *(void *)(a2 + 32) = *v53;
  if (v54) {
    *(void *)(v54 + 40) = a2 + 32;
  }
  *uint64_t v53 = a2;
  *(void *)(a2 + 40) = v53;
  if (sub_100041068(a1))
  {
    uint64_t v61 = *(void *)(a1 + 168);
    if (v61) {
      sub_100049F00(a2, v61);
    }
  }
  if (*(_DWORD *)(a2 + 80))
  {
    mach_port_name_t v62 = sub_100048818(a2, 1, v55, v56, v57, v58, v59, v60);
    if (sub_100031E10((void *)a1, v4, v62, *(unsigned int *)(a2 + 80), v63, v64, v65, v66)) {
      *(_DWORD *)(a2 + 80) = 0;
    }
  }
  uint64_t v67 = *(int *)(a2 + 84);
  if (!v67) {
    goto LABEL_63;
  }
  uint64_t v73 = sub_1000494DC(a2);
  if (v67 == 24)
  {
    if (!qword_100076498)
    {
      qword_100076498 = a2;
      task_t v79 = mach_host_self();
      mach_port_t v86 = sub_100048818(a2, 1, v80, v81, v82, v83, v84, v85);
      sub_100045844(v79, v86);
      goto LABEL_63;
    }
    sub_10001E4BC(v73, 3, "Endpoint \"%s\" tried to steal host exception port from \"%s\"", v68, v69, v70, v71, v72, a2 - 88);
  }
  else
  {
    if (!qword_1000764A0[v67])
    {
      mach_port_t v87 = mach_host_self();
      mach_port_t v94 = sub_100048818(a2, 1, v88, v89, v90, v91, v92, v93);
      if (host_set_special_port(v87, v67, v94)) {
        _os_assumes_log();
      }
      qword_1000764A0[v67] = a2;
      goto LABEL_63;
    }
    mach_host_special_port_description();
    sub_10001E4BC(v73, 3, "Endpoint \"%s\" tried to steal host %s port (%d) from \"%s\"", v74, v75, v76, v77, v78, a2 - 88);
  }
  *(_DWORD *)(a2 + 84) = 0;
LABEL_63:
  uint64_t result = 0;
  *(unsigned char *)(a2 + 88) |= 0x20u;
  return result;
}

uint64_t sub_100031DC0(uint64_t name)
{
  pxpc_type_t type = 0;
  if (name)
  {
    if (mach_port_type(mach_task_self_, name, &ptype)) {
      return 1;
    }
    else {
      return (BYTE2(ptype) >> 4) & 1;
    }
  }
  return name;
}

uint64_t sub_100031E10(void *a1, const char *a2, mach_port_name_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (a1[122]) {
    uint64_t v10 = (void *)a1[122];
  }
  else {
    uint64_t v10 = a1;
  }
  uint64_t v11 = (void *)v10[122];
  if (v11) {
    BOOL v12 = a4 == 4;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    uint64_t v11 = v10;
  }
  uint64_t v13 = v11 + 11;
  while (1)
  {
    uint64_t v13 = (void *)*v13;
    if (!v13) {
      break;
    }
    if (*((_DWORD *)v13 + 5) == a4)
    {
      sub_10002FF18((uint64_t)v10, *((unsigned int *)v13 + 4), 0, a4, a5, a6, a7, a8);
      if (a2) {
        LOBYTE(a2) = (_BYTE)a2 + 112;
      }
      else {
        a2 = "(unknown)";
      }
      if (v8 != 128) {
        mach_task_special_port_description();
      }
      sub_10002A5B8((uint64_t)v10, 3, "service \"%s\" tried to claim task-%s port from endpoint \"%s\"", v14, v15, v16, v17, v18, (char)a2);
      return 17;
    }
  }
  uint64_t v19 = sub_10001A4FC(a3, a4);
  uint64_t v20 = (uint64_t *)v10[11];
  if (v20)
  {
    uint64_t v21 = *v20;
    *uint64_t v19 = *v20;
    if (v21) {
      *(void *)(v21 + 8) = v19;
    }
  }
  else
  {
    *uint64_t v19 = 0;
    uint64_t v20 = v10 + 11;
  }
  uint64_t v22 = 0;
  *uint64_t v20 = (uint64_t)v19;
  v19[1] = v20;
  ++v10[10];
  return v22;
}

uint64_t sub_100031F38(uint64_t a1)
{
  if (!sub_100015D70(*(char **)(a1 + 968), "PostLogOutSync")) {
    return *(void *)(a1 + 232);
  }
  uint64_t result = sub_100041094();
  if (!result) {
    return *(void *)(a1 + 232);
  }
  return result;
}

unint64_t sub_100031F78(unint64_t result, uint64_t a2)
{
  unint64_t v3 = result;
  if (*(void *)(a2 + 248) != result) {
    sub_100051940(a2, result);
  }
  int v4 = (__int16)(*(_WORD *)(a2 + 300))++;
  if ((v4 - 0x7FFF) <= 0xFFFEFFFF) {
    sub_1000518C8(a2);
  }
  if (v4 < 0) {
    sub_100051904(a2);
  }
  if (!v4)
  {
    if (*(_DWORD *)(a2 + 296))
    {
      int v9 = *(_DWORD *)(a2 + 296);
      uint64_t result = sub_100015EA8(&v9, 4);
      uint64_t v5 = (uint64_t *)(v3 + 8 * (result % 7) + 648);
      uint64_t v6 = *v5;
      *(void *)(a2 + 88) = *v5;
      if (v6) {
        *(void *)(v6 + 96) = a2 + 88;
      }
      *uint64_t v5 = a2;
      *(void *)(a2 + 96) = v5;
    }
    else
    {
      int v9 = sub_1000221B4(a2);
      uint64_t result = sub_100015EA8(&v9, 4);
      uint64_t v7 = (uint64_t *)(v3 + 8 * (result % 0xD) + 544);
      uint64_t v8 = *v7;
      *(void *)(a2 + 88) = *v7;
      if (v8) {
        *(void *)(v8 + 96) = a2 + 88;
      }
      *uint64_t v7 = a2;
      *(void *)(a2 + 96) = v7;
      ++*(_DWORD *)(v3 + 200);
    }
  }
  return result;
}

void sub_1000320CC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 248);
  BOOL v57 = 0;
  int v7 = sub_1000229B0(a3, &v57);
  if (a2 == 2)
  {
    if (byte_1000769D9)
    {
      if (sub_10002B6E4(v6, a3)) {
        sub_100040E80("failed to boot out inactive service during obliteration; socket event");
      }
      return;
    }
    if (v57) {
      int v18 = 0;
    }
    else {
      int v18 = v7;
    }
    if (v18 != 1)
    {
      int v26 = sub_100021748(a3, 2, v8, v9, v10, v11, v12, v13);
      if ((v26 & 0xFFFFFFFE) == 0x24) {
        int v27 = 0;
      }
      else {
        int v27 = v26;
      }
      if (v27)
      {
        if (v27 == 37) {
          sub_100040E80("socket event received for running service");
        }
        _os_assumes_log_ctx();
      }
      return;
    }
    unint64_t v60 = 0;
    uint64_t v61 = 0;
    if (*(unsigned char *)(a3 + 1384))
    {
      sub_10001E4BC(a3, 3, "Could not accept inetd connection to retain-only service", v9, v10, v11, v12, v13, v56);
      char v25 = 61;
LABEL_31:
      xpc_strerror();
      sub_10001E4BC(a3, 3, "Could not accept new inetd connection: %d: %s", v28, v29, v30, v31, v32, v25);
      return;
    }
    int v19 = sub_10001CF7C((void *)a1, (unsigned int **)&v61, &v60);
    int v59 = v19;
    if (v19)
    {
      char v25 = v19;
      if (v19 == 35) {
        sub_100040E80("EWOULDBLOCK returned on socket that should not block");
      }
      goto LABEL_31;
    }
    if (!v60)
    {
      sub_10001E4BC(a3, 3, "Got a socket event for an inetd service, but couldn't accept any sockets", v20, v21, v22, v23, v24, v56);
      if (!v60)
      {
LABEL_47:
        free(v61);
        return;
      }
    }
    unint64_t v33 = 0;
    while (1)
    {
      __s[0] = (char *)sub_10002BD38;
      __s[1] = (char *)sub_10002C1B0;
      __s[2] = (char *)sub_10002C2F8;
      __s[3] = (char *)sub_10002C494;
      __s[4] = (char *)sub_10002C4F8;
      __s[5] = (char *)sub_10002C5F8;
      __s[6] = (char *)v6;
      memset(out, 0, sizeof(out));
      uuid_generate(out);
      unsigned int v34 = *(_DWORD *)(a3 + 268);
      if (v34 && *(_DWORD *)(a3 + 264) >= v34)
      {
        char v50 = 67;
        int v59 = 67;
      }
      else
      {
        uint64_t v35 = sub_100005DF8(a3, out, *((unsigned int *)v61 + v33), 0, 0, (uint64_t)__s, 0, &v59);
        if (v35)
        {
          uint64_t v36 = (uint64_t)v35;
          *((_DWORD *)v35 + 92) |= 0x100u;
          sub_10002B594((_DWORD *)v6, (uint64_t)v35);
          ++*(_DWORD *)(a3 + 264);
          *(void *)(v36 + 256) = a3;
          sub_10001A0AC((void *)a3);
          int v43 = sub_100021748(v36, 2, v37, v38, v39, v40, v41, v42);
          if ((v43 & 0xFFFFFFFE) == 0x24) {
            int v44 = 0;
          }
          else {
            int v44 = v43;
          }
          int v59 = v44;
          if (v44)
          {
            xpc_strerror();
            sub_10001E4BC(v36, 3, "Could not spawn dedicated inetd instance: %d: %s", v45, v46, v47, v48, v49, v44);
          }
          goto LABEL_46;
        }
        char v50 = v59;
      }
      xpc_strerror();
      sub_10001E4BC(a3, 3, "Could not create new instance of inetd service: %d: %s", v51, v52, v53, v54, v55, v50);
LABEL_46:
      sub_10003E54C((int *)*((unsigned int *)v61 + v33++));
      if (v33 >= v60) {
        goto LABEL_47;
      }
    }
  }
  if (a2 != 1)
  {
    if (a2) {
      return;
    }
    __s[0] = 0;
    uint64_t v14 = (const char *)sub_10001CB18(a1, __s);
    if (v14)
    {
      *(void *)uuid_t out = 0;
      uint64_t v15 = sub_10001A1EC(__s[0], v14, 0, (size_t *)out, 0);
      if (v15)
      {
        uint64_t v16 = (char **)(v6 + 96);
        uint64_t v17 = *(void *)(v6 + 96);
        *(void *)uint64_t v15 = v17;
        if (v17) {
          *(void *)(v17 + 8) = v15;
        }
        *uint64_t v16 = v15;
        *((void *)v15 + 1) = v16;
        *((void *)v15 + 2) = a3;
      }
      else
      {
        sub_10001E4BC(a3, 3, "Service attempted to specify secure socket key with reserved name: %s", v9, v10, v11, v12, v13, (char)__s[0]);
      }
    }
    *(unsigned char *)(a1 + 48) |= 1u;
  }
  sub_100030E18(v6, a3, v8, v9, v10, v11, v12, v13);
  sub_10002B1A4(v6, 9);
}

BOOL sub_1000324B8(id a1, const char *a2, void *a3)
{
  return 1;
}

uint64_t sub_1000324E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(FILE **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40) + 2;
  uint64_t v6 = sub_100003000(a3);
  return sub_100046780(v4, v5, "%s (%d records)", v7, v8, v9, v10, v11, a2, v6);
}

uint64_t sub_10003253C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100046780(*(FILE **)(a3 + 8), *(void *)(a3 + 16), "%s", a4, a5, a6, a7, a8, a1);
}

uint64_t sub_100032570(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

uint64_t sub_1000325B0(FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a2 + 72);
  if (v9) {
    uint64_t v10 = *(void *)(a2 + 72);
  }
  else {
    uint64_t v10 = a2;
  }
  char v11 = *(unsigned char *)(v10 + 88);
  if (v9)
  {
    uint64_t v12 = 65;
  }
  else if (sub_100049508(a2))
  {
    uint64_t v12 = 77;
  }
  else
  {
    uint64_t v12 = 85;
  }
  uint64_t v13 = sub_100048818(v10, 2, a3, a4, a5, a6, a7, a8);
  uint64_t v19 = 65;
  if ((v11 & 4) == 0) {
    uint64_t v19 = 68;
  }
  return sub_100046780(a1, 2, "%#8x %4c%4c   %s", v14, v15, v16, v17, v18, v13, v12, v19, v10 + 168);
}

void *sub_100032650(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a3;
  sub_100046800(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v23);
  uint64_t result = *(void **)(a1 + 952);
  if (result && (uint64_t result = (void *)xpc_dictionary_get_count(result)) != 0)
  {
    sub_100046780(a2, 1, "disabled services = {", v11, v12, v13, v14, v15);
    xpc_object_t v17 = xpc_copy(*(xpc_object_t *)(a1 + 952));
    xpc_dictionary_set_value(v17, "_dirty", 0);
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_10003282C;
    applier[3] = &unk_100070B58;
    applier[4] = a2;
    xpc_dictionary_apply(v17, applier);
    xpc_release(v17);
    return (void *)sub_100046780(a2, 1, "}", v18, v19, v20, v21, v22);
  }
  else if ((v8 & 1) == 0)
  {
    return (void *)sub_100046780(a2, 1, "disabled services = (no disabled services)", v11, v12, v13, v14, v15);
  }
  return result;
}

uint64_t sub_10003277C(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void *)(a1 + 136);
  if (v4) {
    LODWORD(v4) = xpc_mach_send_get_right();
  }
  if (v4 != a2)
  {
    uint64_t v5 = *(void *)(v3 + 320);
    if (v5)
    {
      while (1)
      {
        uint64_t v6 = sub_10003277C(v5, a2);
        if (v6) {
          break;
        }
        uint64_t v5 = *(void *)(v5 + 16);
        if (!v5) {
          return 0;
        }
      }
      return v6;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t sub_1000327EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

uint64_t sub_10003282C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = *(FILE **)(a1 + 32);
  if (a3 == &_xpc_BOOL_true) {
    uint64_t v9 = "disabled";
  }
  else {
    uint64_t v9 = "enabled";
  }
  sub_100046780(v8, 2, "\"%s\" => %s", a4, a5, a6, a7, a8, a2, v9);
  return 1;
}

uint64_t sub_100032884(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 20);
  if (v2 == getpid()) {
    return 1;
  }

  return sub_10004369C(a1, 0x4000000);
}

uint64_t sub_1000328DC(int a1, char *a2)
{
  size_t v4 = 1024;
  int v5 = a1;
  while (1)
  {
    memset(buffer, 0, sizeof(buffer));
    uint64_t result = sub_1000428A0(v5, buffer);
    int v7 = result;
    if (v5 == a1)
    {
      if (v4 < 2) {
        goto LABEL_11;
      }
      uint64_t result = snprintf(a2, v4, "%s[%d]");
    }
    else
    {
      if (v4 < 2)
      {
LABEL_11:
        size_t v8 = 0;
        if (result) {
          return result;
        }
        goto LABEL_12;
      }
      uint64_t result = snprintf(a2, v4, "<-%s[%d]");
    }
    size_t v8 = (int)result;
    if (v4 <= (int)result) {
      size_t v8 = v4 - 1;
    }
    if (v7) {
      return result;
    }
LABEL_12:
    if (v5 != 1)
    {
      int v5 = DWORD1(buffer[0]);
      if (DWORD1(buffer[0]) > 1)
      {
        a2 += v8;
        v4 -= v8;
        if (v4) {
          continue;
        }
      }
    }
    return result;
  }
}

uint64_t sub_100032A20(uint64_t a1, uint64_t a2, void *a3)
{
  info_xpc_object_t dictionary = (void *)xpc_bundle_get_info_dictionary();
  if (!info_dictionary) {
    return 22;
  }
  xpc_object_t value = xpc_dictionary_get_value(info_dictionary, "XPCService");
  if (!value)
  {
    uint64_t v13 = 0;
    *a3 = qword_100075750;
    return v13;
  }
  int v7 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10002A5B8(a1, 3, "Invalid XPCService dictionary.", v8, v9, v10, v11, v12, v23);
    return 22;
  }
  char string = xpc_dictionary_get_string(v7, "ServiceType");
  if (!string)
  {
    uint64_t v16 = qword_100075750;
LABEL_14:
    uint64_t v13 = 0;
    *a3 = v16;
    goto LABEL_15;
  }
  uint64_t v15 = string;
  if (!strcmp(string, "System"))
  {
    uint64_t v16 = &unk_1000755B8;
    goto LABEL_14;
  }
  if (!strcmp(v15, "Application"))
  {
    uint64_t v16 = qword_100075750;
    goto LABEL_14;
  }
  uint64_t v13 = 22;
LABEL_15:
  if (xpc_dictionary_get_BOOL(v7, "_MultipleInstances") && (void *)*a3 != qword_100075750)
  {
    sub_10002A5B8(a1, 4, "MultipleInstance XPC services are not supported for any service type other than Application. Forcing service to PID domain.", v17, v18, v19, v20, v21, v23);
    *a3 = qword_100075750;
  }
  return v13;
}

uint64_t sub_100032B64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(qword_100076478 + 1016)) {
    return 124;
  }
  if ((a2 & 0x88) != 0 && !sub_100032884(a4)) {
    return 154;
  }
  uint64_t v8 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void, void))(a1 + 104);

  return v8(0, 1, a2, a3, a4, 0, 0);
}

uint64_t sub_100032C0C(uint64_t a1, uint64_t *a2, xpc_object_t xdict, void *a4)
{
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0) {
    return 124;
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, "paths");
  if (value)
  {
    uint64_t v10 = value;
    if ((xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(v10) == (xpc_type_t)&_xpc_type_array)
      && xpc_dictionary_expects_reply())
    {
      if (xpc_dictionary_get_BOOL(xdict, "enable")) {
        uint64_t v11 = 2048;
      }
      else {
        uint64_t v11 = 0;
      }
      if (xpc_dictionary_get_BOOL(xdict, "force")) {
        v11 |= 0x8000uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "legacy-load")) {
        v11 |= 0x100uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "angel")) {
        v11 |= 0x40000uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "managed-lwcr")) {
        v11 |= 0x80000uLL;
      }
      if (xpc_dictionary_get_BOOL(xdict, "by-cli")) {
        v11 |= 0x100000uLL;
      }
      if (*(void **)(a1 + 112) == qword_100075750)
      {
        char v22 = sub_100036580(a1, a2, v12, v13, v14, v15, v16, v17);
        if (v22)
        {
          if (v22 != 37)
          {
            char v23 = v22;
            xpc_strerror();
            sub_10002A5B8(a1, 5, "failed to uncork PID domain on first bootstrap: %d - %s", v24, v25, v26, v27, v28, v23);
          }
        }
      }
      uint64_t v18 = (void *)sub_10003B3E8(xdict);
      sub_1000174B4((void *)a1, 1, v18, v10, a2, v11, v19, v20);
      xpc_release(v18);
      return 0;
    }
    else
    {
      return 22;
    }
  }
  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(xdict);
    uint64_t result = 0;
    *a4 = reply;
  }
  return result;
}

uint64_t sub_100032E04(void *a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v8 = sub_10002DD24((uint64_t)a1, 4, 128, a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
LABEL_4:
    sub_10002DE0C((uint64_t)a1, a2, v9, "bootout");
    return v9;
  }
  if (xpc_dictionary_get_value(a3, "paths"))
  {
    xpc_object_t value = xpc_dictionary_get_value(a3, "paths");
    if (value)
    {
      uint64_t v11 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
      {
        if (xpc_dictionary_get_BOOL(a3, "disable")) {
          uint64_t v12 = 2048;
        }
        else {
          uint64_t v12 = 0;
        }
        if (xpc_dictionary_get_BOOL(a3, "no-einprogress")) {
          v12 |= 0x20000uLL;
        }
        if (xpc_dictionary_get_BOOL(a3, "by-cli")) {
          v12 |= 0x100000uLL;
        }
        uint64_t v13 = (void *)sub_10003B3E8(a3);
        sub_1000174B4(a1, 2, v13, v11, (uint64_t *)a2, v12, v14, v15);
        xpc_release(v13);
        return 0;
      }
    }
    return 22;
  }
  if (!xpc_dictionary_get_string(a3, "name"))
  {
    uint64_t v9 = sub_10002DD24((uint64_t)a1, 7, 128, a2, 0, 0);
    if (!v9)
    {
      sub_100036664((uint64_t)a1, a2, a3, a4);
      return v9;
    }
    goto LABEL_4;
  }
  uint64_t v30 = a1;
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 22;
  }
  uint64_t v17 = (char *)string;
  if (xpc_dictionary_get_BOOL(a3, "legacy-service-lookup")) {
    uint64_t v18 = sub_100036720(&v30, v17);
  }
  else {
    uint64_t v18 = sub_10002E140(a1, v17);
  }
  mach_port_context_t v20 = (mach_port_context_t)v18;
  if (!v18) {
    return 3;
  }
  bzero(v31, 0x400uLL);
  sub_1000328DC(*(_DWORD *)(a2 + 20), v31);
  sub_10001E4BC(v20, 65541, "bootout initiated by: %s", v21, v22, v23, v24, v25, (char)v31);
  xpc_dictionary_get_BOOL(a3, "attempt-unload-protected");
  uint64_t v9 = sub_1000201F8();
  if (v9)
  {
    sub_10002DE0C((uint64_t)v30, a2, v9, "bootout (%s)");
  }
  else
  {
    uint64_t v9 = sub_10002B6E4((uint64_t)v30, v20);
    BOOL v26 = xpc_dictionary_get_BOOL(a3, "no-einprogress");
    BOOL v27 = xpc_dictionary_get_BOOL(a3, "wait");
    if (v9 && (v9 != 36 || !v26))
    {
      if (v9 == 36 && v27)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        sub_100024F34(v20);
        uint64_t v29 = (void *)xpc_mach_send_create_with_disposition();
        xpc_dictionary_set_value(reply, "monitor", v29);
        xpc_release(v29);
        uint64_t v9 = 0;
        *a4 = reply;
      }
    }
    else
    {
      uint64_t v9 = 0;
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }
  return v9;
}

uint64_t sub_100033184(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(void **)(a1 + 112) != qword_100075750 || !xpc_dictionary_expects_reply()) {
    return 22;
  }
  sub_100011594();
  int v13 = *(_DWORD *)(a2 + 28);
  if (v13 > *(_DWORD *)(a1 + 308) || *(_DWORD *)(a2 + 20) != *(_DWORD *)(a1 + 300))
  {
    sub_10002A5B8(a1, 5, "exec count or caller mismatch: caller exec cnt = %u, creator exec cnt = %u, caller pid = %d, creator pid = %d", v8, v9, v10, v11, v12, v13);
    if (*(void *)(a1 + 216))
    {
      sub_10002A5B8(a1, 5, "rebirth already in progress", v15, v16, v17, v18, v19, v40);
      return 131;
    }
    else
    {
      sub_10002A5B8(a1, 5, "slaying domain for rebirth", v15, v16, v17, v18, v19, v40);
      *(_DWORD *)(a1 + 1016) |= 0x80u;
      *(void *)(a1 + 216) = xpc_retain(a3);
      sub_10002AA9C(a1, v20, v21, v22, v23, v24, v25, v26, v41);
      return 0;
    }
  }
  if ((*(unsigned char *)(a1 + 1016) & 8) != 0 || *(void *)(a1 + 248))
  {
    sub_10002A5B8(a1, 5, "domain already initialized", v8, v9, v10, v11, v12, v39);
    return 37;
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "paths");
  if (!value
    || (uint64_t v35 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    || (xpc_object_t v36 = xpc_dictionary_get_value(a3, "environment")) == 0
    || xpc_get_type(v36) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10002AA9C(a1, v28, v29, v30, v31, v32, v33, v34, v39);
    return 22;
  }
  char string = xpc_dictionary_get_string(a3, "origin");
  if (string) {
    *(void *)(a1 + 240) = sub_1000159F0(string);
  }
  *(void *)(a1 + 248) = xpc_retain(v35);
  xpc_dictionary_apply_f();
  *(_DWORD *)(a1 + 1016) |= 8u;
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_10003338C(uint64_t a1, uint64_t *a2, void *a3, void *a4)
{
  if (*(void **)(a1 + 112) != qword_100075750 || !xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v14 = sub_100036580(a1, a2, v8, v9, v10, v11, v12, v13);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t result = 0;
  if ((_BYTE)v14 && v14 != 37 && v14 != 124)
  {
    xpc_dictionary_set_int64(reply, "error", v14);
    uint64_t result = v14;
  }
  *a4 = reply;
  return result;
}

uint64_t sub_10003343C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  sub_100047418();
  if (xpc_dictionary_get_uint64(a3, "type") != 7)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 112)
                                                                                              + 104))(a1, 6, 0, *(void *)(a1 + 120), a2, 0, 0);
    if (v8)
    {
      uint64_t v9 = v8;
      sub_10002DE0C(a1, a2, v8, "endpoint lookup");
      return v9;
    }
  }
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0) {
    return 124;
  }
  if (*(_WORD *)(a1 + 204))
  {
    if (*(void *)(a1 + 136)) {
      int right = xpc_mach_send_get_right();
    }
    else {
      int right = 0;
    }
    uint64_t v15 = a1;
    uint64_t v16 = a3;
    int v17 = 1;
LABEL_15:
    sub_100036864(v15, right, v16, v17);
    return 0;
  }
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 22;
  }
  uint64_t v12 = (char *)string;
  uint int64 = xpc_dictionary_get_uint64(a3, "flags");
  uint64_t v14 = (uint64 & 0x10) != 0 ? xpc_dictionary_get_uint64(a3, "lookup-handle") : 0;
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  uint64_t v19 = (unsigned __int8 *)uuid;
  if (((uint64 & 4) != 0 || (uint64 & 0x20) != 0) && !uuid) {
    return 22;
  }
  size_t length = 0;
  int data = xpc_dictionary_get_data(a3, "cputypes", &length);
  unint64_t v21 = (unint64_t)data;
  if ((uint64 & 0x400) == 0 || (uint64_t v9 = 22, data) && length == 36 && *(void **)(a1 + 112) == qword_100075750)
  {
    if ((*(unsigned char *)(a1 + 1017) & 0x10) != 0
      && (uint64 & 0x10) == 0
      && *(_UNKNOWN **)(a1 + 112) == &unk_1000755B8
      && sub_10004B3A8(v12))
    {
      memset(v35, 0, sizeof(v35));
      sub_100042920(a2, (char *)v35);
      sub_10002A5B8(a1, 5, "pending lookup during user switch: mach_port_name_t name = %s, requestor = %s[%d]", v28, v29, v30, v31, v32, (char)v12);
      if (*(void *)(a1 + 136)) {
        int right = xpc_mach_send_get_right();
      }
      else {
        int right = 0;
      }
      uint64_t v15 = a1;
      uint64_t v16 = a3;
      int v17 = 2;
      goto LABEL_15;
    }
    uint64_t v22 = sub_1000368E0(a1, v12, v14, uint64, v19, v21, a2);
    unint64_t v33 = v21;
    uint64_t v23 = v14;
    int v25 = v24;
    xpc_object_t v26 = sub_100036B74(a3, v22, v24);
    if (sub_100036C08(v22, v25, v12, v23, uint64, v19, v33, a2)) {
      sub_100036C8C(a1, v26, (uint64_t)v12);
    }
    uint64_t v9 = 0;
    *a4 = v26;
  }
  return v9;
}

uint64_t sub_10003374C(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0) {
    return 124;
  }
  if (*(_WORD *)(a1 + 204))
  {
    if (*(void *)(a1 + 136)) {
      int right = xpc_mach_send_get_right();
    }
    else {
      int right = 0;
    }
    sub_100036864(a1, right, xdict, 1);
    return 0;
  }
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22;
  }
  uint64_t v11 = (char *)string;
  uint int64 = xpc_dictionary_get_uint64(xdict, "flags");
  uint64_t v18 = uint64;
  if (*(void **)(a1 + 112) == qword_100075750)
  {
    if (uint64) {
      sub_10002A5B8(a1, 4, "Ignoring lax activation attempt for unsupported domain: %s", v13, v14, v15, v16, v17, (char)v11);
    }
    v18 &= ~1uLL;
    if ((v18 & 0x20) == 0) {
      goto LABEL_9;
    }
  }
  else if ((uint64 & 0x20) == 0)
  {
LABEL_9:
    xpc_object_t object = 0;
    LOBYTE(__src) = 0;
    uint64_t v19 = sub_1000377B0(a1, a2, v11, v18, 0, &object, &__src);
    if (!v19)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(xdict);
      xpc_mach_send_get_right();
      xpc_dictionary_set_mach_recv();
      if ((_BYTE)__src) {
        xpc_dictionary_set_BOOL(reply, "non-launching", 1);
      }
      xpc_release(object);
      goto LABEL_40;
    }
    return v19;
  }
  int v21 = *(_DWORD *)(a2 + 20);
  xpc_object_t object = (xpc_object_t)a1;
  size_t v22 = sub_1000375E4((uint64_t *)&object, v21, 1);
  if (v22)
  {
    uint64_t v23 = v22;
    int v24 = (char *)sub_100013BB8(0x200uLL);
    int v25 = v24;
    uint64_t v26 = *(void *)(v23 + 192);
    if (!v26)
    {
      uint64_t v4 = 3;
      goto LABEL_35;
    }
    unint64_t v27 = 0;
    uint64_t v4 = 3;
    uint64_t v28 = v24;
    while (1)
    {
      if (!strcmp((const char *)(v26 + 208), v11))
      {
        uint64_t v43 = 0;
        __src = 0;
        uint64_t v4 = sub_10001CDE0(v26, &__src, 0, &v43);
        if (v4)
        {
          xpc_strerror();
          sub_10001E4BC(v23, 3, "Could not activate socket named \"%s\": %d: %s", v35, v36, v37, v38, v39, (char)v11);
          goto LABEL_34;
        }
        v27 += v43;
        if (v27 >= 0x80)
        {
          sub_10001E4BC(v23, 4, "Too many sockets for name \"%s\". Some will be skipped.", v29, v30, v31, v32, v33, (char)v11);
          sub_10001CEAC(v26);
          *(_WORD *)(v26 + 204) &= ~1u;
LABEL_34:
          if (v4)
          {
LABEL_35:
            free(v25);
            return v4;
          }
          xpc_object_t reply = xpc_dictionary_create_reply(xdict);
          xpc_object_t v40 = xpc_array_create(0, 0);
          if (v27)
          {
            char v41 = (int *)v25;
            do
            {
              int v42 = *v41++;
              xpc_array_set_fd(v40, 0xFFFFFFFFFFFFFFFFLL, v42);
              --v27;
            }
            while (v27);
          }
          xpc_dictionary_set_value(reply, "port", v40);
          xpc_release(v40);
          free(v25);
LABEL_40:
          uint64_t v4 = 0;
          *a4 = reply;
          return v4;
        }
        memcpy(v28, __src, 4 * v43);
        uint64_t v4 = 0;
        v28 += 4 * v43;
      }
      uint64_t v26 = *(void *)(v26 + 16);
      if (!v26) {
        goto LABEL_34;
      }
    }
  }
  return 113;
}

uint64_t sub_100033A64(uint64_t a1, xpc_object_t original, void *a3)
{
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0) {
    return 124;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (!reply) {
    return 22;
  }
  xpc_object_t v14 = reply;
  sub_10002FC3C(a1, v7, v8, v9, v10, v11, v12, v13, v15);
  uint64_t result = 0;
  *a3 = v14;
  return result;
}

uint64_t sub_100033ACC(uint64_t a1, xpc_object_t original, void *a3)
{
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0) {
    return 124;
  }
  if (!*(_DWORD *)(a1 + 192)) {
    return 34;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(original);
  if (!reply) {
    return 22;
  }
  uint64_t v7 = reply;
  if (!sub_10003B5BC())
  {
LABEL_8:
    sub_10002B2F0(a1, v8, v9, v10, v11, v12, v13, v14);
    uint64_t result = 0;
    *a3 = v7;
    return result;
  }
  char v15 = *(NSObject **)(a1 + 160);
  if (v15)
  {
    dispatch_source_cancel(v15);
    *(void *)(a1 + 160) = 0;
    goto LABEL_8;
  }
  sub_10002A5B8(a1, 4, "Ignoring a request to unset ondemand", v10, v11, v12, v13, v14, v16);
  xpc_release(v7);
  return 37;
}

uint64_t sub_100033B80(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "names");
  if (!value) {
    return 22;
  }
  uint64_t v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_array) {
    return 22;
  }
  uint64_t v12 = sub_10002DD24(a1, 4, 128, a2, 0, 0);
  if (v12)
  {
    if ((uint64_t v10 = v12, v12 != 1)
      || !sub_100041068(a1) && *(_UNKNOWN **)(a1 + 112) != &unk_1000755B8
      || (sub_100037D84(a2, v9) & 1) == 0)
    {
      sub_10002DE0C(a1, a2, v10, "enable service");
      return v10;
    }
  }
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (!reply) {
    return 22;
  }
  uint64_t v14 = reply;
  if (xpc_array_get_count(v9))
  {
    size_t v15 = 0;
    do
    {
      char string = (char *)xpc_array_get_string(v9, v15);
      if (string)
      {
        uint64_t v17 = string;
        if (sub_1000302D8(a1, string, 2))
        {
          xpc_dictionary_set_int64(v14, v17, 0);
          xpc_strerror();
          sub_10002A5B8(a1, 4, "Failed to enable service %s, error=%d - %s", v18, v19, v20, v21, v22, (char)v17);
        }
      }
      ++v15;
    }
    while (v15 < xpc_array_get_count(v9));
  }
  sub_10004B2A4();
  uint64_t v10 = 0;
  *a4 = v14;
  return v10;
}

uint64_t sub_100033D20(uint64_t a1, uint64_t a2, xpc_object_t xdict, void *a4)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "names");
  if (!value) {
    return 22;
  }
  uint64_t v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_array) {
    return 22;
  }
  uint64_t v12 = sub_10002DD24(a1, 4, 128, a2, 0, 0);
  if (v12)
  {
    if ((uint64_t v10 = v12, v12 != 1)
      || !sub_100041068(a1) && *(_UNKNOWN **)(a1 + 112) != &unk_1000755B8
      || (sub_100037D84(a2, v9) & 1) == 0)
    {
      sub_10002DE0C(a1, a2, v10, "disable service");
      return v10;
    }
  }
  xpc_object_t reply = xpc_dictionary_create_reply(xdict);
  if (!reply) {
    return 22;
  }
  uint64_t v14 = reply;
  if (xpc_array_get_count(v9))
  {
    size_t v15 = 0;
    do
    {
      char string = (char *)xpc_array_get_string(v9, v15);
      if (string)
      {
        uint64_t v17 = string;
        unsigned int v18 = sub_1000302D8(a1, string, 1);
        if (v18)
        {
          xpc_dictionary_set_int64(v14, v17, v18);
          xpc_strerror();
          sub_10002A5B8(a1, 4, "Failed to disable service %s, error=%d - %s", v19, v20, v21, v22, v23, (char)v17);
        }
      }
      ++v15;
    }
    while (v15 < xpc_array_get_count(v9));
  }
  sub_10004B2A4();
  uint64_t v10 = 0;
  *a4 = v14;
  return v10;
}

uint64_t sub_100033EC0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!*(void *)(a1 + 952)) {
    return 125;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 112)
                                                                                            + 104))(a1, 5, 0, *(void *)(a1 + 120), a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_10002DE0C(a1, a2, v8, "query service enabled state");
  }
  else if (*(_WORD *)(a1 + 204))
  {
    if (*(void *)(a1 + 136)) {
      int right = xpc_mach_send_get_right();
    }
    else {
      int right = 0;
    }
    sub_100036864(a1, right, a3, 1);
    return 0;
  }
  else
  {
    char string = xpc_dictionary_get_string(a3, "name");
    if (string
      && (uint64_t v12 = (char *)string,
          xpc_object_t value = xpc_dictionary_get_value(a3, "default-enabled"),
          (xpc_object_t reply = xpc_dictionary_create_reply(a3)) != 0))
    {
      size_t v15 = reply;
      char v16 = sub_10002E140((_DWORD *)a1, v12);
      if (!v16)
      {
        char v16 = (_DWORD *)sub_100041094();
        if (v16) {
          char v16 = sub_10002E140(v16, v12);
        }
      }
      xpc_dictionary_set_BOOL(v15, "loaded", v16 != 0);
      xpc_object_t v17 = sub_100030404(a1, v12);
      if (v17 == &_xpc_BOOL_true)
      {
        BOOL v18 = 0;
      }
      else
      {
        BOOL v18 = 1;
        if (v17 != &_xpc_BOOL_false && value) {
          BOOL v18 = xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(value);
        }
      }
      xpc_dictionary_set_BOOL(v15, "enabled", v18);
      uint64_t v9 = 0;
      *a4 = v15;
    }
    else
    {
      return 22;
    }
  }
  return v9;
}

uint64_t sub_100034088(uint64_t a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint64_t v8 = *(void **)(a1 + 112);
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22;
  }
  uint64_t v10 = (char *)string;
  uint64_t v11 = sub_10002DD24(a1, 4, (unint64_t)(v8 != qword_100075750) << 7, a2, 0, 0);
  if (v11)
  {
    uint64_t v12 = v11;
    sub_10002DE0C(a1, a2, v11, "kill service (%s)", v10);
    return v12;
  }
  if (xpc_dictionary_get_int64(xdict, "signal") - 32 < 0xFFFFFFE1
    || !xpc_dictionary_expects_reply())
  {
    return 22;
  }
  uint64_t v13 = sub_10002E140((_DWORD *)a1, v10);
  if (!v13)
  {
    uint64_t v13 = sub_1000306D0(a1, v10);
    if (!v13) {
      return 113;
    }
  }
  bzero(v23, 0x400uLL);
  sub_1000328DC(*(_DWORD *)(a2 + 20), (char *)v23);
  sub_10001E4BC((uint64_t)v13, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v14, v15, v16, v17, v18, (char)"signal service");
  int v19 = sub_1000221B4((uint64_t)v13);
  if (!v19) {
    return 3;
  }
  if ((v13[1381] & 0x10) != 0) {
    return 1;
  }
  memset(v23, 0, 32);
  uint64_t v12 = sub_1000437E0(v19, (integer_t *)v23);
  if (v12) {
    return v12;
  }
  if (*(void **)(a1 + 112) != qword_100075750
    || (unint64_t v21 = *(void *)(a1 + 120), v21 >> 31)
    || (uint64_t v22 = *(unsigned int *)(a2 + 20), (v22 & 0x80000000) != 0)
    || v21 != v22)
  {
    if (!sub_100019210()) {
      return 1;
    }
  }
  uint64_t v12 = sub_100043778();
  if (!v12) {
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v12;
}

uint64_t sub_1000342BC(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  unint64_t v21 = a1;
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22;
  }
  uint64_t v9 = (char *)string;
  if ((sub_10000FE40(a2, 14) & 1) == 0)
  {
    uint64_t v11 = 144;
    sub_10002DE0C((uint64_t)a1, a2, 144, "start service (%s)");
    return v11;
  }
  uint64_t v10 = sub_10002DD24((uint64_t)a1, 4, 8, a2, 0, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    sub_10002DE0C((uint64_t)a1, a2, v10, "start service (%s)");
    return v11;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v12 = sub_100036720(&v21, v9);
  if (!v12) {
    return 3;
  }
  unsigned int v19 = sub_100021748((uint64_t)v12, 10, v13, v14, v15, v16, v17, v18);
  if ((v19 & 0xFFFFFFFE) == 0x24) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v19;
  }
  if (v11 == 37 || !v11)
  {
    uint64_t v11 = 0;
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v11;
}

uint64_t sub_1000343F0(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  unint64_t v27 = a1;
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22;
  }
  uint64_t v9 = (char *)string;
  if ((sub_10000FE40(a2, 14) & 1) == 0)
  {
    uint64_t v11 = 144;
    sub_10002DE0C((uint64_t)a1, a2, 144, "service stop (%s)");
    return v11;
  }
  uint64_t v10 = sub_10002DD24((uint64_t)a1, 4, 8, a2, 0, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    sub_10002DE0C((uint64_t)a1, a2, v10, "service stop (%s)");
    return v11;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v12 = sub_100036720(&v27, v9);
  if (!v12) {
    return 3;
  }
  uint64_t v13 = (uint64_t)v12;
  if (!sub_10001E900()) {
    return 1;
  }
  bzero(v28, 0x400uLL);
  sub_1000328DC(*(_DWORD *)(a2 + 20), v28);
  sub_10001E4BC(v13, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v14, v15, v16, v17, v18, (char)"legacy-stop service");
  uint64_t v25 = sub_100021858(v13, a2, v19, v20, v21, v22, v23, v24);
  if (!v25 || (uint64_t v11 = v25, v25 == 89) || v25 == 37)
  {
    uint64_t v11 = 0;
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v11;
}

uint64_t sub_1000345B4(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint64_t v23 = a1;
  char string = xpc_dictionary_get_string(xdict, "name");
  if (!string) {
    return 22;
  }
  uint64_t v9 = (char *)string;
  uint64_t v10 = sub_10002DD24((uint64_t)a1, 4, 128, a2, 0, 0);
  if (v10)
  {
    uint64_t v11 = v10;
    sub_10002DE0C((uint64_t)a1, a2, v10, "service remove (%s)");
    return v11;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v12 = sub_100036720(&v23, v9);
  if (!v12) {
    return 3;
  }
  uint64_t v13 = (uint64_t)v12;
  uint64_t v14 = sub_1000201F8();
  if (v14)
  {
    uint64_t v11 = v14;
    sub_10002DE0C((uint64_t)v23, a2, v14, "service remove (%s)");
  }
  else
  {
    memset(v24, 0, sizeof(v24));
    char v16 = sub_100042920(a2, (char *)v24);
    sub_10001E4BC(v13, 5, "caller removing service: caller = %s[%d]", v17, v18, v19, v20, v21, v16);
    uint64_t v22 = sub_10002B6E4((uint64_t)v23, v13);
    if (v22 == 36 || (uint64_t v11 = v22, !v22))
    {
      uint64_t v11 = 0;
      *a4 = xpc_dictionary_create_reply(xdict);
    }
  }
  return v11;
}

uint64_t sub_100034740(_DWORD *a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_10002DD24((uint64_t)a1, 5, 8, a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_10002DE0C((uint64_t)a1, a2, v8, "service enumeration");
  }
  else if (xpc_dictionary_expects_reply())
  {
    char string = (char *)xpc_dictionary_get_string(a3, "name");
    if (string)
    {
      uint64_t v22 = a1;
      uint64_t v11 = sub_100036720(&v22, string);
      if (!v11) {
        return 113;
      }
      uint64_t v12 = v11;
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v14 = sub_1000221F0((uint64_t)v12);
      sub_100037EB4(v12, v14);
      xpc_dictionary_set_value(reply, "service", v14);
      xpc_release(v14);
    }
    else
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_value(reply, "services", v15);
      xpc_release(v15);
      for (uint64_t i = 0; i != 23; ++i)
      {
        for (uint64_t j = *(void *)&a1[2 * i + 84]; j; uint64_t j = *(void *)(j + 120))
        {
          xpc_object_t v18 = xpc_dictionary_create(0, 0, 0);
          int v19 = sub_1000221B4(j);
          xpc_dictionary_set_int64(v18, "pid", v19);
          uint64_t v20 = sub_1000229A8(j);
          xpc_dictionary_set_int64(v18, "status", *(int *)(v20 + 28));
          xpc_dictionary_set_value(v15, (const char *)(j + 1392), v18);
          xpc_release(v18);
        }
      }
    }
    uint64_t v9 = 0;
    *a4 = reply;
  }
  else
  {
    return 22;
  }
  return v9;
}

uint64_t sub_100034934(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8 = sub_10002DD24(a1, 4, 8, a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_10002DE0C(a1, a2, v8, "set domain environment");
  }
  else if (xpc_dictionary_expects_reply() {
         && (xpc_object_t value = xpc_dictionary_get_value(a3, "envvars")) != 0
  }
         && (uint64_t v11 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary))
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100038098;
    v13[3] = &unk_100070B78;
    v13[4] = a1;
    void v13[5] = a2;
    xpc_dictionary_apply(v11, v13);
    uint64_t v9 = 0;
    *a4 = xpc_dictionary_create_reply(a3);
  }
  else
  {
    return 22;
  }
  return v9;
}

uint64_t sub_100034A5C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_10002DD24(a1, 5, 8, a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_10002DE0C(a1, a2, v8, "get domain environment");
  }
  else if (xpc_dictionary_expects_reply() && (char string = xpc_dictionary_get_string(a3, "envvar")) != 0)
  {
    uint64_t v11 = string;
    uint64_t v12 = (void *)(a1 + 96);
    while (1)
    {
      uint64_t v12 = (void *)*v12;
      if (!v12) {
        break;
      }
      if (sub_10001A3D0((uint64_t)v12, v11))
      {
        uint64_t v13 = sub_10001A430((uint64_t)v12);
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_string(reply, "value", v13);
        uint64_t v9 = 0;
        *a4 = reply;
        return v9;
      }
    }
    return 3;
  }
  else
  {
    return 22;
  }
  return v9;
}

uint64_t sub_100034B58(void **a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint int64 = xpc_dictionary_get_uint64(xdict, "flags");
  if (a1[14] != &unk_1000755B8) {
    return 125;
  }
  uint64_t v10 = uint64;
  if ((uint64 & 0x100000000000000) != 0) {
    uint64_t v11 = xpc_dictionary_get_uint64(xdict, "userreboot_purpose");
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v12 = sub_10002DD24((uint64_t)a1, 4, 128, a2, 0, 0);
  if (v12 == 150) {
    int v13 = 0;
  }
  else {
    int v13 = v12;
  }
  if (v13)
  {
    uint64_t v9 = v12;
    if (v13 == 1)
    {
      if (sub_10000FE40(a2, 20)) {
        goto LABEL_12;
      }
      uint64_t v9 = 1;
    }
    sub_10002DE0C((uint64_t)a1, a2, v9, "reboot");
    return v9;
  }
LABEL_12:
  sub_100011580();
  uint64_t v9 = 22;
  if (xpc_dictionary_expects_reply() && (v10 & 2) == 0)
  {
    bzero(v64, 0x400uLL);
    sub_1000328DC(*(_DWORD *)(a2 + 20), v64);
    if ((v10 & 0x8000000000000000) != 0)
    {
      uint64_t v19 = 0;
      BOOL v20 = 0;
      int v21 = 0;
      uint64_t v22 = "System reboot";
      uint64_t v23 = "system reboot";
      goto LABEL_22;
    }
    if ((v10 & 0x2000000000000000) == 0)
    {
      if ((v10 & 0x4000000000000000) == 0)
      {
        uint64_t v19 = 0;
        BOOL v20 = 0;
        int v21 = 0;
        uint64_t v22 = "System shutdown";
        uint64_t v23 = "system shutdown";
        goto LABEL_22;
      }
      if (sub_10000FE40(a2, 12))
      {
        uint64_t v19 = 0;
        BOOL v20 = 0;
        int v21 = 0;
        uint64_t v22 = "Obliteration";
        uint64_t v23 = "obliteration";
        goto LABEL_22;
      }
      return 144;
    }
    if (!sub_10000FE40(a2, 18)) {
      return 144;
    }
    if (sub_100003F18(7))
    {
      uint64_t v46 = "cannot userspace reboot while in REM";
LABEL_34:
      sub_10002A5B8((uint64_t)a1, 65540, v46, v14, v15, v16, v17, v18, v61);
      return 45;
    }
    if ((v11 & 0xFFFFFFFFFFFFFFFELL) == 4)
    {
      if (!byte_100076480)
      {
        uint64_t v46 = "attempted to enter REM in unsupported variant";
        goto LABEL_34;
      }
      sub_10002A5B8((uint64_t)a1, 65540, "attempting to enter REM", v14, v15, v16, v17, v18, v61);
      BOOL v52 = v11 == 5;
      uint64_t v53 = "";
      if (v11 == 5) {
        uint64_t v53 = " (development)";
      }
      sub_10002A5B8((uint64_t)a1, 65540, "attempting to enter REM%s", v47, v48, v49, v50, v51, (char)v53);
      uint64_t v19 = 7;
    }
    else
    {
      uint64_t v19 = 0;
      BOOL v52 = 0;
    }
    if ((v10 & 0x200000000000000) != 0) {
      goto LABEL_51;
    }
    BOOL v20 = v52;
    int v21 = 1;
    uint64_t v22 = "Userspace reboot";
    uint64_t v23 = "userspace reboot";
LABEL_22:
    if ((v10 & 0x200000000000000) != 0)
    {
      if ((v10 & 0x4000000000000000) == 0 || !byte_1000769D9) {
        goto LABEL_51;
      }
    }
    else
    {
      sub_10002A5B8((uint64_t)a1, 196613, "%s initiated by: %s", v14, v15, v16, v17, v18, (char)v22);
      sub_10002A5B8((uint64_t)a1, 5, "%s: flags = 0x%llx, caller = %s", v25, v26, v27, v28, v29, (char)v23);
      if (byte_100076A45)
      {
        sub_10002A5B8((uint64_t)a1, 65540, "system is in sudden shutdown mode. All processes will be SIGKILLed immediately.", v30, v31, v32, v33, v34, v62);
        sub_10002A5B8((uint64_t)a1, 5, "system is in sudden shutdown mode. All processes will be SIGKILLed immediately.", v35, v36, v37, v38, v39, v63);
      }
      if ((v10 & 0x4000000000000000) == 0)
      {
        uint64_t v40 = sub_1000415F8((uint64_t)a1, v19);
        if (v40)
        {
          uint64_t v9 = v40;
          sub_10002A5B8((uint64_t)a1, 65539, "failed to persist services: %d", v41, v42, v43, v44, v45, v40);
          return v9;
        }
        uint64_t v9 = sub_100014114(v21, 0, v10);
        if (v9) {
          return v9;
        }
        sub_100045990(v19);
        sub_1000459A8(v20);
        sub_1000383AC((mach_port_context_t)a1);
LABEL_51:
        uint64_t v9 = 0;
        *a4 = xpc_dictionary_create_reply(xdict);
        return v9;
      }
      if (!byte_1000769D9)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(xdict);
        dword_1000765C0 = *(_DWORD *)(a2 + 20);
        sub_100038290(a1, (uint64_t)reply, v55, v56, v57, v58, v59, v60);
        return 0;
      }
    }
    return 37;
  }
  return v9;
}

uint64_t sub_100034F78(uint64_t a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (a2 && (int v9 = *(_DWORD *)(a2 + 20), v9 != getpid()))
  {
    if (!xpc_dictionary_expects_reply()) {
      return 22;
    }
    int v10 = 0;
  }
  else
  {
    int v10 = 1;
  }
  int int64 = xpc_dictionary_get_int64(xdict, "which");
  if (!sub_100043124(int64)) {
    return 22;
  }
  if (xpc_dictionary_get_BOOL(xdict, "print"))
  {
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 0x40000000;
    v22[2] = sub_100038654;
    v22[3] = &unk_100070BB8;
    int v23 = int64;
    return sub_100046548(xdict, a4, (uint64_t)v22);
  }
  uint64_t v12 = sub_10002DD24(a1, 4, 8, a2, 0, 0);
  if (v12)
  {
    uint64_t v4 = v12;
    sub_10002DE0C(a1, a2, v12, "modify rlimits");
    return v4;
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, "hardlimit");
  if (!value) {
    return 22;
  }
  uint64_t v14 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64) {
    return 22;
  }
  xpc_object_t v16 = xpc_dictionary_get_value(xdict, "softlimit");
  if (!v16) {
    return 22;
  }
  uint64_t v17 = v16;
  if (xpc_get_type(v16) != (xpc_type_t)&_xpc_type_int64) {
    return 22;
  }
  int64_t v18 = xpc_int64_get_value(v14);
  int64_t v19 = xpc_int64_get_value(v17);
  if (v19 < 0) {
    unint64_t v20 = -1;
  }
  else {
    unint64_t v20 = v19;
  }
  if (v18 < 0) {
    int64_t v18 = -1;
  }
  sub_100042EE4(int64, v20, v18, 0);
  if (v10)
  {
    xpc_object_t empty = xpc_dictionary_create_empty();
    *a4 = empty;
    xpc_dictionary_set_int64(empty, "softlimit", v20);
    xpc_dictionary_set_int64(*a4, "hardlimit", v18);
    return 0;
  }
  else
  {
    uint64_t v4 = 0;
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v4;
}

uint64_t sub_1000351B8(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v8 = sub_10002DD24(a1, 5, 128, a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_10002DE0C(a1, a2, v8, "domain print");
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    _OWORD v11[2] = sub_1000387EC;
    v11[3] = &unk_100070BD8;
    v11[4] = a3;
    void v11[5] = a1;
    return sub_100046548(a3, a4, (uint64_t)v11);
  }
  return v9;
}

uint64_t sub_100035298(void **a1, _OWORD *a2, void *a3)
{
  if (sub_10000FE40((uint64_t)a2, 2))
  {
    if (a1[14] == qword_100075750)
    {
      if (xpc_dictionary_expects_reply() && (char string = xpc_dictionary_get_string(a3, "path")) != 0)
      {
        uint64_t v8 = string;
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        _OWORD v11[2] = sub_100038AF0;
        v11[3] = &unk_100070C18;
        v11[4] = a1;
        void v11[5] = sub_1000159F0(string);
        void v11[6] = xpc_dictionary_create_reply(a3);
        xpc_object_t value = xpc_dictionary_get_value(a3, "overlay");
        sub_100017C08(a1, v8, value, a2, (uint64_t)v11);
        return 0;
      }
      else
      {
        return 22;
      }
    }
    else
    {
      return 125;
    }
  }
  else
  {
    uint64_t v6 = 144;
    sub_10002DE0C((uint64_t)a1, (uint64_t)a2, 144, "pid-extend");
  }
  return v6;
}

uint64_t sub_1000353DC(void **a1, uint64_t a2, void *a3)
{
  if (a1[14] != &unk_1000755B8) {
    return 125;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if ((sub_10000FE40(a2, 2) & 1) == 0)
  {
    uint64_t v3 = 144;
    sub_10002DE0C((uint64_t)a1, a2, 144, "extension removal");
    return v3;
  }
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 22;
  }
  uint64_t v8 = (char *)string;
  memset(v31, 0, sizeof(v31));
  sub_100042920(a2, (char *)v31);
  sub_10002A5B8((uint64_t)a1, 5, "%s: caller = %s.%d, extensiouint64_t n = %s", v9, v10, v11, v12, v13, (char)"remove all extension instances");
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v15 = dispatch_group_create();
  dispatch_group_enter(v15);
  xpc_object_t v16 = sub_10001A054(a1, 19, (uint64_t)v15, (uint64_t)reply);
  uint64_t v17 = sub_100014B58();
  dispatch_group_notify_f(v15, v17, v16, (dispatch_function_t)sub_100038BA8);
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  for (uint64_t i = 0; i != 11; ++i)
  {
    for (uint64_t j = qword_100075750[i]; j; uint64_t j = *(void *)(j + 32))
    {
      uint64_t v27 = sub_10002E140((_DWORD *)j, v8);
      if (v27)
      {
        if (sub_100038C44(*((void *)v27 + 31), (uint64_t)v27, v15) != 36) {
          ++v23;
        }
        ++v24;
      }
    }
  }
  if (!v24)
  {
    uint64_t v28 = sub_10002E140(a1, v8);
    if (v28 || (uint64_t v29 = (_DWORD *)sub_100041094()) != 0 && (v28 = sub_10002E140(v29, v8)) != 0)
    {
      sub_100038C44(*((void *)v28 + 31), (uint64_t)v28, v15);
      LOBYTE(v24) = 1;
    }
    else
    {
      xpc_dictionary_set_int64(reply, "error", 3);
      LOBYTE(v24) = 0;
    }
  }
  sub_10002A5B8((uint64_t)a1, 5, "total of %lu extension (%s) instances were found to remove, of which %lu were removed instantly", v18, v19, v20, v21, v22, v24);
  dispatch_group_leave(v15);
  return 0;
}

uint64_t sub_100035650(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (sub_10000FE40(a2, 2))
  {
    xpc_object_t value = xpc_dictionary_get_value(a3, "names");
    if (value
      && (uint64_t v10 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
      && (xpc_object_t reply = xpc_dictionary_create_reply(a3)) != 0)
    {
      uint64_t v13 = reply;
      xpc_object_t v14 = xpc_array_create(0, 0);
      for (uint64_t i = 0; i != 11; ++i)
      {
        for (uint64_t j = qword_100075750[i]; j; uint64_t j = *(void *)(j + 32))
        {
          if (xpc_array_get_count(v10))
          {
            size_t v17 = 0;
            do
            {
              char string = (char *)xpc_array_get_string(v10, v17);
              if (string)
              {
                uint64_t v19 = sub_10002E140((_DWORD *)j, string);
                if (v19)
                {
                  if (!*((_DWORD *)v19 + 74))
                  {
                    if (sub_1000221B4((uint64_t)v19))
                    {
                      int v20 = memorystatus_control();
                      if (v20)
                      {
                        if (v20 != 24) {
                          _os_assumes_log_ctx();
                        }
                      }
                    }
                  }
                }
              }
              ++v17;
            }
            while (v17 < xpc_array_get_count(v10));
          }
        }
      }
      xpc_dictionary_set_value(v13, "instances", v14);
      xpc_release(v14);
      uint64_t v4 = 0;
      *a4 = v13;
    }
    else
    {
      return 22;
    }
  }
  else
  {
    uint64_t v4 = 144;
    sub_10002DE0C(a1, a2, 144, "copy busy extensions");
  }
  return v4;
}

uint64_t sub_100035874(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint64_t v9 = sub_10002DD24(a1, 5, 128, a2, 0, 0);
  if (v9)
  {
    uint64_t v4 = v9;
    sub_10002DE0C(a1, a2, v9, "dump state");
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    _OWORD v11[2] = sub_100038D48;
    v11[3] = &unk_100070C38;
    v11[4] = a1;
    return sub_100046548(a3, a4, (uint64_t)v11);
  }
  return v4;
}

uint64_t sub_100035988(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint int64 = xpc_dictionary_get_uint64(a3, "uid");
  if (*(unsigned char *)(qword_100076478 + 1016))
  {
    uint64_t v4 = 124;
    sub_10002DE0C(a1, a2, 124, "get user context");
  }
  else
  {
    unsigned int v10 = uint64;
    uint64_t v11 = uint64;
    uint64_t v12 = off_1000756A8(0, 1, 256, uint64, a2, 0, 0);
    if (v12)
    {
      uint64_t v4 = v12;
      sub_10002DE0C(a1, a2, v12, "get user context");
    }
    else
    {
      uint64_t v14 = sub_100030024(qword_100075640, v11);
      if (!v14)
      {
        uint64_t v14 = (uint64_t)sub_100038D50(v10, a2);
        if (!v14) {
          sub_100050CD4();
        }
      }
      if (*(_WORD *)(v14 + 204))
      {
        if (*(void *)(a1 + 136)) {
          int right = xpc_mach_send_get_right();
        }
        else {
          int right = 0;
        }
        sub_100036864(v14, right, a3, 1);
        return 0;
      }
      else
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        uint64_t v17 = *(void *)(v14 + 976);
        uint64_t v18 = v14 + 88;
        do
          uint64_t v18 = *(void *)v18;
        while (v18 && *(_DWORD *)(v18 + 20) != 4);
        if (!v17) {
          uint64_t v17 = v14;
        }
        uint64_t v19 = v17 + 88;
        while (1)
        {
          uint64_t v19 = *(void *)v19;
          if (!v19) {
            break;
          }
          if (*(_DWORD *)(v19 + 20) == 128)
          {
            xpc_dictionary_set_mach_send();
            break;
          }
        }
        xpc_dictionary_set_mach_send();
        uint64_t v4 = 0;
        *a4 = reply;
      }
    }
  }
  return v4;
}

uint64_t sub_100035B7C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  uint64_t v9 = sub_10002DD24(a1, 5, 128, a2, 0, 0);
  if (v9)
  {
    uint64_t v4 = v9;
    sub_10002DE0C(a1, a2, v9, "dump jetsam property category");
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    _OWORD v11[2] = sub_100038DAC;
    v11[3] = &unk_100070C58;
    v11[4] = a1;
    return sub_100046548(a3, a4, (uint64_t)v11);
  }
  return v4;
}

uint64_t sub_100035C78(uint64_t a1, void *a2, void *a3)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  uint int64 = xpc_dictionary_get_uint64(a2, "uid");
  if (*(unsigned char *)(qword_100076478 + 1016)) {
    return 124;
  }
  unsigned int v7 = uint64;
  uint64_t v8 = uint64;
  uint64_t result = off_1000756A8(0, 1, 256, uint64, a1, 0, 0);
  if (!result)
  {
    if (sub_100030024(qword_100075640, v8))
    {
      return 17;
    }
    else
    {
      sub_100038D50(v7, a1);
      xpc_object_t reply = xpc_dictionary_create_reply(a2);
      uint64_t result = 0;
      *a3 = reply;
    }
  }
  return result;
}

uint64_t sub_100035D5C(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (!sub_10000FE40(a2, 18)) {
    return 144;
  }
  memset(v16, 0, sizeof(v16));
  char v10 = sub_100042920(a2, (char *)v16);
  sub_10002A5B8(a1, 196613, "Active user switch initiated by: %s[%d]", v11, v12, v13, v14, v15, v10);
  uint64_t v8 = sub_1000412A0(a1);
  if (!v8) {
    *a4 = xpc_dictionary_create_reply(a3);
  }
  return v8;
}

uint64_t sub_100035E64(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (!sub_10000FE40(a2, 18)) {
    return 144;
  }
  memset(v16, 0, sizeof(v16));
  char v10 = sub_100042920(a2, (char *)v16);
  sub_10002A5B8(a1, 196613, "Active user login, initiated by: %s[%d]", v11, v12, v13, v14, v15, v10);
  uint64_t v8 = sub_100041320(a1);
  if (!v8) {
    *a4 = xpc_dictionary_create_reply(a3);
  }
  return v8;
}

uint64_t sub_100035F6C(uint64_t a1, uint64_t a2, void *a3)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  if (!sub_10000FE40(a2, 18)) {
    return 144;
  }
  memset(v15, 0, sizeof(v15));
  char v8 = sub_100042920(a2, (char *)v15);
  sub_10002A5B8(a1, 196613, "Active user logout, initiated by: %s[%d]", v9, v10, v11, v12, v13, v8);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v6 = sub_1000410C8(a1, reply);
  xpc_release(reply);
  return v6;
}

uint64_t sub_100036078(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "properties");
  if (!value) {
    return 22;
  }
  uint64_t v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 22;
  }
  xpc_object_t v12 = xpc_dictionary_get_value(a3, "flags");
  if (!v12) {
    return 22;
  }
  uint64_t v13 = v12;
  if (xpc_get_type(v12) != (xpc_type_t)&_xpc_type_uint64) {
    return 22;
  }
  char v14 = xpc_uint64_get_value(v13);
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  char v15 = v14;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v10 = sub_100038E80(v9, &v28, (uint64_t *)&v27);
  unsigned int v26 = v10;
  if (!v10)
  {
    unint64_t v17 = v27;
    xpc_object_t v16 = v28;
    uint64_t v18 = sub_100038F9C(v28, v27, a2);
    if (v18)
    {
      sub_10002A5B8(v18, 5, "Domain creation failed: it already exists", v19, v20, v21, v22, v23, v25);
      return 37;
    }
    else
    {
      sub_10003902C(v16, v17, 0, v15, a2, (int *)&v26);
      uint64_t v10 = v26;
      if (v26)
      {
        uint64_t v24 = (const char *)xpc_strerror();
        sub_100043D78(4, "Domain creation failed: %d %s", v10, v24);
      }
      else
      {
        *a4 = xpc_dictionary_create_reply(a3);
      }
    }
  }
  return v10;
}

uint64_t sub_1000361F4(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if ((*(unsigned char *)(a1 + 1016) & 3) != 0)
  {
    uint64_t v8 = 124;
LABEL_6:
    sub_10002DE0C(a1, a2, v8, "unpend launches");
    return v8;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 112)
                                                                                            + 104))(a1, 4, 0, *(void *)(a1 + 120), a2, 0, 0);
  if (v8) {
    goto LABEL_6;
  }
  if ((*(unsigned char *)(a1 + 1017) & 0x80) == 0) {
    return 37;
  }
  sub_10002A5B8(a1, 5, "unpending launches", v9, v10, v11, v12, v13, v15);
  *(_DWORD *)(a1 + 1016) &= ~0x8000u;
  sub_10002B268(a1);
  uint64_t v8 = 0;
  *a4 = xpc_dictionary_create_reply(a3);
  return v8;
}

uint64_t sub_1000362EC(void *a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  char string = xpc_dictionary_get_string(a3, "query");
  if (!string) {
    return 22;
  }
  uint64_t v9 = string;
  xpc_object_t empty = xpc_array_create_empty();
  sub_100039274(a1, v9, empty, a2);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "services", empty);
  xpc_release(empty);
  uint64_t result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_10003639C(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (sub_10000FE40(a2, 4))
  {
    char string = xpc_dictionary_get_string(a3, "mount-point");
    uint64_t v9 = sub_10000E564(string);
    if (!v9) {
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }
  else
  {
    uint64_t v9 = 144;
    sub_10002DE0C(a1, a2, 144, "load-jetsam-properties");
  }
  return v9;
}

uint64_t sub_100036448(uint64_t a1, uint64_t a2, void *a3)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (!sub_10000FE40(a2, 32)) {
    return 144;
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    return 125;
  }
  char string = xpc_dictionary_get_string(a3, "cryptex");
  if (!string) {
    return 22;
  }
  uint64_t v8 = string;
  uint64_t v9 = dispatch_group_create();
  dispatch_group_enter(v9);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  uint64_t v11 = sub_100014B58();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000393A0;
  block[3] = &unk_100070C78;
  block[4] = reply;
  void block[5] = a1;
  block[6] = v9;
  dispatch_group_notify(v9, v11, block);
  sub_100039410(a1, v8, v9, a2);
  dispatch_group_leave(v9);
  return 0;
}

uint64_t sub_100036580(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 1016);
  if ((v8 & 4) != 0) {
    return 37;
  }
  if ((v8 & 3) != 0)
  {
    sub_10002A5B8(a1, 5, "domain shutting down, not uncorking", a4, a5, a6, a7, a8, v14);
    return 124;
  }
  else if ((v8 & 8) != 0 && *(void *)(a1 + 248))
  {
    sub_10002A5B8(a1, 5, "uncorking domain", a4, a5, a6, a7, a8, v14);
    sub_100011594();
    sub_1000174B4((void *)a1, 1, 0, *(void **)(a1 + 248), a2, 9216, v12, v13);
    xpc_release(*(xpc_object_t *)(a1 + 248));
    uint64_t result = 0;
    *(void *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 1016) |= 4u;
  }
  else
  {
    sub_10002A5B8(a1, 5, "domain is not initialized, can't uncork", a4, a5, a6, a7, a8, v14);
    return 131;
  }
  return result;
}

xpc_object_t sub_100036664(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  bzero(v22, 0x400uLL);
  sub_1000328DC(*(_DWORD *)(a2 + 20), v22);
  sub_10002A5B8(a1, 65541, "bootout initiated by: %s", v8, v9, v10, v11, v12, (char)v22);
  sub_10002AA9C(a1, v13, v14, v15, v16, v17, v18, v19, v21);
  xpc_object_t result = xpc_dictionary_create_reply(a3);
  *a4 = result;
  return result;
}

_DWORD *sub_100036720(_DWORD **a1, char *a2)
{
  xpc_object_t result = sub_10002E140(*a1, a2);
  if (!result)
  {
    if (*((_UNKNOWN **)*a1 + 14) == &unk_1000755B8)
    {
      xpc_object_t result = (_DWORD *)sub_100041094();
      if (result)
      {
        int v5 = result;
        xpc_object_t result = sub_10002E140(result, a2);
        if (result) {
          *a1 = v5;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_100036794(char *a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    size_t v16 = 0;
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    unsigned int v7 = sub_10001A1EC(a1, string_ptr, 0, &v16, 0);
    if (v7)
    {
      uint64_t v15 = *(void *)(a3 + 96);
      uint64_t v14 = (char **)(a3 + 96);
      uint64_t v13 = v15;
      *(void *)unsigned int v7 = v15;
      if (v15) {
        *(void *)(v13 + 8) = v7;
      }
      *uint64_t v14 = v7;
      *((void *)v7 + 1) = v14;
    }
    else
    {
      sub_10002A5B8(a3, 3, "Service attempted to %s environment variable with reserved name: %s", v8, v9, v10, v11, v12, (char)"set");
    }
  }
}

xpc_object_t sub_100036864(uint64_t a1, int a2, void *a3, int a4)
{
  uint64_t v8 = sub_100013BB8(0x30uLL);
  v8[4] = a2;
  xpc_object_t result = xpc_retain(a3);
  *((void *)v8 + 3) = result;
  v8[8] = a4;
  if (!a1) {
    sub_100050D0C();
  }
  uint64_t v12 = *(void *)(a1 + 208);
  uint64_t v11 = (void *)(a1 + 208);
  uint64_t v10 = v12;
  *(void *)uint64_t v8 = v12;
  if (v12) {
    *(void *)(v10 + 8) = v8;
  }
  *uint64_t v11 = v8;
  *((void *)v8 + 1) = v11;
  return result;
}

uint64_t sub_1000368E0(uint64_t a1, char *a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v12 = sub_100020E4C(*(_DWORD *)(a7 + 20));
  if (v12)
  {
    uint64_t v13 = v12;
    if (sub_100022A7C(v12)) {
      return 0;
    }
    if ((*(unsigned char *)(v13 + 369) & 0x80) != 0) {
      return 0;
    }
  }
  uint64_t v15 = a1;
  if ((a4 & 8) != 0)
  {
    uint64_t v15 = a1;
    if (sub_100015D70(*(char **)(a1 + 968), "PostLogOutSync")) {
      uint64_t v15 = sub_100031F38(a1);
    }
  }
  while (1)
  {
    if (sub_100015D70(*(char **)(a1 + 968), "PostLogOutSync")
      && (*(_UNKNOWN **)(v15 + 112) == &unk_1000755B8 || sub_100041068(v15))
      && !sub_1000191C0())
    {
      uint64_t v14 = 0;
      int v17 = 1;
      goto LABEL_31;
    }
    uint64_t v14 = sub_100036ED4(v15, a2, a3, a4, a5, a6, a7, 1);
    int v17 = v16;
    if ((a4 & 0x10) != 0 || v16 != 3 || *(void **)(a1 + 112) == qword_100075750) {
      break;
    }
    uint64_t v15 = sub_100031F38(v15);
    if (!v15)
    {
      if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8
        || !sub_10004B3A8(a2)
        || ((uint64_t v18 = sub_100041094()) == 0
          ? (uint64_t v14 = 0, v17 = 3)
          : (uint64_t v14 = sub_100036ED4(v18, a2, a3, a4, a5, a6, a7, 0), v17 = v19),
            v17))
      {
        uint64_t v14 = 0;
        int v17 = 3;
        goto LABEL_31;
      }
      memset(v29, 0, sizeof(v29));
      sub_100042920(a7, (char *)v29);
      sub_10002A5B8(a1, 4, "rerouted lookup to a foreground user endpoint: mach_port_name_t name = %s, caller = %s[%d]", v20, v21, v22, v23, v24, (char)a2);
      break;
    }
  }
  if (!v17)
  {
    if (v14)
    {
      uint64_t v25 = *(void *)(v14 + 96);
      if (v25)
      {
        if (*(void *)(v25 + 1384))
        {
          int v17 = 3;
          uint64_t v14 = 0;
        }
      }
    }
  }
LABEL_31:
  if (v17) {
    sub_100036D40(a1, (uint64_t)a2, a5, a3, a4, a7, v17);
  }
  return v14;
}

xpc_object_t sub_100036B74(void *a1, uint64_t a2, int a3)
{
  if (a3)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    xpc_dictionary_set_int64(reply, "error", a3);
  }
  else
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    uint64_t v12 = (void *)sub_100049250(a2, 1, v6, v7, v8, v9, v10, v11);
    xpc_dictionary_set_value(reply, "port", v12);
    if (*(char *)(a2 + 88) < 0) {
      xpc_dictionary_set_BOOL(reply, "non-launching", 1);
    }
  }
  return reply;
}

uint64_t sub_100036C08(uint64_t a1, int a2, char *a3, uint64_t a4, unint64_t a5, unsigned __int8 *a6, unint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = sub_100041094();
  if (result)
  {
    sub_100036ED4(result, a3, a4, a5, a6, a7, a8, 0);
    return v15 == 0;
  }
  return result;
}

void sub_100036C8C(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "error");
  uint64_t v6 = "Unexpected error when looking up endpoint: %s";
  if (int64 == 3) {
    uint64_t v6 = "System session daemon must not initiate XPC to the User session: endpoint = %s";
  }
  if (int64 == 159) {
    uint64_t v7 = sub_100015BE4("Sandbox violation: endpoint = %s");
  }
  else {
    uint64_t v7 = sub_100015BE4(v6, a3);
  }
  uint64_t v8 = v7;
  xpc_strerror();
  sub_10002A5B8(a1, 3, "%s (%s)", v9, v10, v11, v12, v13, (char)v8);

  free(v8);
}

void sub_100036D40(uint64_t a1, uint64_t a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a7 != 145)
  {
    uint64_t v13 = (void **)sub_100010724(0x100uLL);
    uint64_t v20 = v13;
    uint64_t v21 = "failed lookup";
    if (a7 == 159) {
      uint64_t v21 = "denied lookup";
    }
    sub_1000107B4((uint64_t)v13, "%s: mach_port_name_t name = %s, ", v14, v15, v16, v17, v18, v19, (char)v21);
    if (a4) {
      sub_1000107B4((uint64_t)v20, "pid_t handle = %llu, ", v22, v23, v24, v25, v26, v27, a4);
    }
    memset(out, 0, 37);
    if ((a5 & 0x24) != 0)
    {
      uuid_unparse(a3, out);
      sub_1000107B4((uint64_t)v20, "instance = %s, ", v28, v29, v30, v31, v32, v33, (char)out);
    }
    else if (!a5)
    {
LABEL_10:
      memset(v46, 0, sizeof(v46));
      char v34 = sub_100042920(a6, (char *)v46);
      xpc_strerror();
      sub_1000107B4((uint64_t)v20, "requestor = %s[%d], int error = %d: %s", v35, v36, v37, v38, v39, v40, v34);
      sub_10002A5B8(a1, 4, "%s", v41, v42, v43, v44, v45, (char)*v20);
      sub_100010778(v20);
      return;
    }
    sub_1000107B4((uint64_t)v20, "flags = 0x%llx, ", v22, v23, v24, v25, v26, v27, a5);
    goto LABEL_10;
  }
}

uint64_t sub_100036ED4(uint64_t a1, char *a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, uint64_t a7, int a8)
{
  uint64_t v64 = a1;
  if (*(void *)(a1 + 976)) {
    uint64_t v14 = *(void *)(a1 + 976);
  }
  else {
    uint64_t v14 = a1;
  }
  if ((a4 & 2) != 0)
  {
    if (a8 && !sub_1000191C0()) {
      goto LABEL_47;
    }
    *(void *)&long long v66 = a1;
    size_t v22 = sub_1000375E4((uint64_t *)&v66, a3, 0);
    if (v22) {
      goto LABEL_14;
    }
    uint64_t v29 = sub_100020E4C(a3);
    if (!v29) {
      goto LABEL_32;
    }
    size_t v22 = v29;
    uint64_t v30 = *(void *)(v29 + 248);
    if (*(void **)(v30 + 112) != qword_100075750) {
      goto LABEL_14;
    }
    uint64_t v31 = (uint64_t *)(v30 + 88);
    do
      uint64_t v31 = (uint64_t *)*v31;
    while (v31 && *((_DWORD *)v31 + 5) != 4);
    uint64_t v65 = sub_10003277C(qword_100076478, *((unsigned int *)v31 + 4));
    if (v65) {
      size_t v22 = sub_1000375E4(&v65, a3, 1);
    }
    if (v22)
    {
LABEL_14:
      uint64_t v23 = *(void *)(v22 + 168);
      if (v23)
      {
        while ((*(unsigned char *)(v23 + 88) & 0x40) != 0 || !sub_100015D70((char *)(v23 + 168), a2))
        {
          uint64_t v23 = *(void *)(v23 + 16);
          if (!v23) {
            goto LABEL_18;
          }
        }
        goto LABEL_23;
      }
LABEL_18:
      sub_10002A5B8(a1, 5, "could not find endpoint in pid namespace: pid = %d, mach_port_name_t name = %s", v17, v18, v19, v20, v21, a3);
    }
    else
    {
LABEL_32:
      sub_10002A5B8(a1, 5, "could not find active service for lookup: pid = %d, mach_port_name_t name = %s", v17, v18, v19, v20, v21, a3);
    }
    goto LABEL_33;
  }
  if ((a4 & 0x10) != 0)
  {
    *(void *)&long long v66 = a1;
    size_t v24 = sub_1000375E4((uint64_t *)&v66, *(_DWORD *)(a7 + 20), 0);
    if (!v24)
    {
      uint64_t v23 = 0;
      int v28 = 113;
      goto LABEL_66;
    }
    uint64_t v25 = sub_100024E50(v24, a2);
    if (v25)
    {
      uint64_t v26 = sub_10003D00C(v25, a3);
      if (v26)
      {
        uint64_t v27 = sub_100012758(v26);
        uint64_t v23 = sub_1000307E8(v27, v27, a2);
        if (v23)
        {
LABEL_23:
          int v28 = 0;
          goto LABEL_66;
        }
LABEL_34:
        int v28 = 3;
        goto LABEL_66;
      }
    }
LABEL_33:
    uint64_t v23 = 0;
    goto LABEL_34;
  }
  if ((a4 & 0x24) != 0)
  {
    if (*(void **)(v14 + 112) == qword_100075750)
    {
      if (a8 && !sub_1000191C0()) {
        goto LABEL_47;
      }
    }
    else if (a8 && !sub_1000191C0())
    {
LABEL_47:
      uint64_t v23 = 0;
      int v28 = 159;
      goto LABEL_66;
    }
    uint64_t v32 = sub_100030744(v14, a2);
    uint64_t v23 = v32;
    int v28 = v33;
    if (v33)
    {
      if (v33 != 3) {
        goto LABEL_66;
      }
      uint64_t v32 = sub_100037488(v14, a2);
      if (!v32) {
        goto LABEL_66;
      }
    }
    if (*(void *)(v32 + 72))
    {
      sub_10002A5B8(v14, 3, "Cannot look up instances for shared endpoints.", v17, v18, v19, v20, v21, v63);
LABEL_65:
      uint64_t v23 = 0;
      int v28 = 137;
      goto LABEL_66;
    }
    uint64_t v34 = sub_1000494DC(v32);
    uint64_t v40 = v34;
    if ((*(unsigned char *)(v34 + 369) & 2) != 0)
    {
      sub_10001E4BC(v34, 3, "Cannot look up instances for sub-instances.", v35, v36, v37, v38, v39, v63);
      goto LABEL_65;
    }
    uint64_t v41 = sub_100024EF0(v34, a5);
    if (!v41)
    {
      if (sub_100024ECC(v40, 1))
      {
        uint64_t v23 = 0;
        int v28 = 45;
        goto LABEL_66;
      }
      *(void *)&long long v67 = 0;
      long long v66 = a6;
      LODWORD(v65) = 0;
      uint64_t v41 = (uint64_t)sub_10002B8BC(*(void *)(v40 + 248), v40, a5, (a4 >> 5) & 1, (uint64_t *)&v66, (_OWORD *)a7, (int *)&v65);
      if (!v41)
      {
        uint64_t v23 = 0;
        if (v65) {
          int v28 = v65;
        }
        else {
          int v28 = 137;
        }
        goto LABEL_66;
      }
    }
    uint64_t v23 = *(void *)(v41 + 184);
    if (v23)
    {
      int v28 = 3;
      while ((*(unsigned char *)(v23 + 88) & 0x40) != 0 || !sub_100015D70((char *)(v23 + 168), a2))
      {
        uint64_t v23 = *(void *)(v23 + 16);
        if (!v23) {
          goto LABEL_66;
        }
      }
      goto LABEL_23;
    }
    goto LABEL_34;
  }
  if ((a4 & 0x100) == 0)
  {
    if (*(void **)(v14 + 112) == qword_100075750)
    {
      if (a8 && !sub_1000191C0()) {
        goto LABEL_88;
      }
    }
    else if (a8 && !sub_1000191C0())
    {
LABEL_88:
      uint64_t v23 = 0;
      int v28 = 159;
      goto LABEL_61;
    }
  }
  uint64_t v23 = sub_100030744(v14, a2);
  int v28 = v42;
LABEL_61:
  if (v28 == 3)
  {
    uint64_t v43 = sub_100037488(v14, a2);
    if (v43)
    {
      unint64_t v44 = a4 & 0x100;
      goto LABEL_68;
    }
  }
LABEL_66:
  if (v28) {
    return v23;
  }
  unint64_t v44 = a4 & 0x100;
  uint64_t v43 = v23;
LABEL_68:
  if (*(void *)(v43 + 72)) {
    uint64_t v23 = *(void *)(v43 + 72);
  }
  else {
    uint64_t v23 = v43;
  }
  if (v44)
  {
    uint64_t v50 = sub_100020E4C(*(_DWORD *)(a7 + 20));
    if (!v50)
    {
      sub_10002A5B8(v64, 5, "Unable to find managed service for pid %d. Trying unmanaged services", v45, v46, v47, v48, v49, *(_DWORD *)(a7 + 20));
      uint64_t v50 = sub_1000374EC(&v64, *(_DWORD *)(a7 + 20));
    }
    uint64_t v51 = sub_1000494DC(v23);
    if (!v50 || v50 != v51) {
      goto LABEL_79;
    }
  }
  if ((a4 & 8) == 0 || sub_100041068(v14) || *(_UNKNOWN **)(v14 + 112) == &unk_1000755B8)
  {
    if ((a4 & 0x200) != 0 || ((a4 >> 7) & 1) == *(unsigned __int8 *)(v23 + 88) >> 7)
    {
      if (sub_100049250(v23, 1, v16, v17, v18, v19, v20, v21))
      {
        if (!v23) {
          sub_100050CD4();
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      sub_100042920(a7, (char *)&v66);
      sub_10002A5B8(v14, 4, "failed lookup due to non-launching property mismatch: mach_port_name_t name = %s, requestor = %s.%d", v52, v53, v54, v55, v56, (char)a2);
      sub_100042920(a7, (char *)&v66);
      sub_10002A5B8(v14, 5, "failed lookup due to non-launching property mismatch: mach_port_name_t name = %s, requestor = %s.%d", v57, v58, v59, v60, v61, (char)a2);
      return 0;
    }
  }
  else
  {
LABEL_79:
    sub_100036D40(v14, (uint64_t)a2, a5, a3, a4, a7, 1);
    return 0;
  }
  return v23;
}

uint64_t sub_100037488(uint64_t a1, char *a2)
{
  if (*(void **)(a1 + 112) != qword_100075750) {
    return 0;
  }
  uint64_t v4 = sub_10002E140((_DWORD *)a1, a2);
  if (!v4) {
    return 0;
  }

  return sub_10002BC60(a1, (uint64_t)v4);
}

uint64_t sub_1000374EC(uint64_t *a1, int a2)
{
  int v9 = a2;
  unint64_t v3 = sub_100015EA8(&v9, 4);
  uint64_t v4 = *a1;
  uint64_t i = *(void *)(*a1 + 8 * (v3 % 0xD) + 544);
  if (i)
  {
    while (1)
    {
      int v6 = sub_1000221B4(i);
      int v7 = v9;
      if (v6 == v9) {
        break;
      }
      uint64_t i = *(void *)(i + 88);
      if (!i)
      {
        uint64_t v4 = *a1;
        goto LABEL_6;
      }
    }
  }
  else
  {
    int v7 = v9;
LABEL_6:
    int v10 = v7;
    for (uint64_t i = *(void *)(v4 + 8 * (sub_100015EA8(&v10, 4) % 7uLL) + 648); i; uint64_t i = *(void *)(i + 88))
    {
      if (*(_DWORD *)(i + 296) == v10) {
        break;
      }
    }
  }
  return i;
}

size_t sub_1000375E4(uint64_t *a1, int a2, int a3)
{
  uint64_t v6 = sub_1000374EC(a1, a2);
  if (v6) {
    return v6;
  }
  if (sub_100020F1C(a2))
  {
    uint64_t v6 = sub_1000374EC(a1, a2);
    if (v6) {
      return v6;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (!a3) {
    return v6;
  }
  uint64_t v8 = (void *)*a1;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)__str = 0u;
  long long v26 = 0u;
  memset(buffer, 0, sizeof(buffer));
  int v9 = sub_1000428A0(a2, buffer);
  if (v9)
  {
    if (v9 == 3) {
      return 0;
    }
    snprintf(__str, 0x80uLL, "com.apple.xpc.launchd.unmanaged.confusing.%d.%d");
  }
  else
  {
    snprintf(__str, 0x80uLL, "com.apple.xpc.launchd.unmanaged.%s.%d");
  }
  size_t v10 = strlen(__str);
  size_t v11 = v10 + 1392;
  BOOL v12 = v10 >= 0xFFFFFFFFFFFFFA90;
  size_t result = v10 + 1393;
  uint64_t v13 = v11 == -1;
  uint64_t v14 = v13 << 63 >> 63;
  BOOL v15 = v14 != v13;
  if (!v12 && !v15 && (v14 & 0x8000000000000000) == 0)
  {
    uint64_t v6 = (uint64_t)sub_100013BB8(result);
    size_t result = strlen(__str);
    uint64_t v16 = result == -1;
    uint64_t v17 = v16 << 63 >> 63;
    if (v17 == v16 && (v17 & 0x8000000000000000) == 0)
    {
      strlcpy((char *)(v6 + 1392), __str, result + 1);
      *(void *)(v6 + 248) = sub_10001A0AC(v8);
      *(_DWORD *)(v6 + 296) = a2;
      sub_100031F78((unint64_t)v8, v6);
      sub_10001E4BC(v6, 5, "added unmanaged active", v18, v19, v20, v21, v22, v23);
      return v6;
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_1000377B0(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, void *a5, xpc_object_t *a6, unsigned char *a7)
{
  uint64_t v92 = a1;
  size_t v14 = sub_1000375E4(&v92, *(_DWORD *)(a2 + 20), 1);
  if (v14)
  {
    uint64_t v15 = v14;
    if (*(void *)(a1 + 976)) {
      size_t v16 = *(void *)(a1 + 976);
    }
    else {
      size_t v16 = a1;
    }
    if ((a4 & 2) == 0)
    {
      if ((a4 & 0x10) != 0)
      {
        if (*(_DWORD *)(v14 + 296))
        {
          uint64_t v25 = 45;
          goto LABEL_55;
        }
        uint64_t v17 = sub_1000307E8(v14, v14, a3);
        if (!v17) {
          uint64_t v17 = sub_100030834(v16, (void *)v15, a3);
        }
        uint64_t v25 = sub_100048A34(v17, v38, v39, v40, v41, v42, v43, v44);
        if (v25) {
          goto LABEL_55;
        }
      }
      else
      {
        if ((*(unsigned char *)(v14 + 369) & 2) == 0) {
          goto LABEL_39;
        }
        uint64_t v17 = *(void *)(v14 + 184);
        if (!v17) {
          goto LABEL_39;
        }
        while ((*(unsigned char *)(v17 + 88) & 0x40) != 0 || !sub_100015D70((char *)(v17 + 168), a3))
        {
          uint64_t v17 = *(void *)(v17 + 16);
          if (!v17) {
            goto LABEL_39;
          }
        }
        if (sub_100048A34(v17, v18, v19, v20, v21, v22, v23, v24))
        {
LABEL_39:
          uint64_t v58 = sub_100030744(v16, a3);
          if (!v65)
          {
            uint64_t v66 = v58;
            uint64_t v67 = sub_100048818(v58, 2, v59, v60, v61, v62, v63, v64);
            if (!sub_100031DC0(v67))
            {
              if (*(void *)(v66 + 72))
              {
                sub_10002A5B8(v16, 3, "Service \"%s\" tried to register for aliased endpoint: %s", v68, v69, v70, v71, v72, v15 + 112);
              }
              else
              {
                if ((a4 & 0x200) == 0 && ((a4 >> 8) & 1) != *(unsigned __int8 *)(v66 + 88) >> 7)
                {
                  size_t v91 = v16;
                  sub_10002A5B8(v16, 3, "Preventing \"%s\" from registering for %s due to non-launching property mismatch", v68, v69, v70, v71, v72, v15 + 112);
                  goto LABEL_43;
                }
                if (sub_1000494DC(v66) == v15)
                {
                  if (a5)
                  {
                    sub_10002A5B8(v16, 3, "Service tried to register a port for an endpoint declared in its launchd.plist(5): service = %s, endpoint = %s", v75, v76, v77, v78, v79, v15 + 112);
                    uint64_t v25 = 56;
                    goto LABEL_55;
                  }
                  size_t v91 = v16;
                  uint64_t v83 = sub_100048A34(v66, v73, v74, v75, v76, v77, v78, v79);
                  if (v83 != 3)
                  {
                    uint64_t v25 = v83;
                    if (v83) {
                      goto LABEL_55;
                    }
                    *(_DWORD *)(v15 + 368) |= 0x2000u;
                    *(unsigned char *)(v66 + 88) |= 4u;
                    if (a6)
                    {
                      uint64_t v90 = (void *)sub_100049250(v66, 4, v84, v85, v86, v87, v88, v89);
                      *a6 = xpc_retain(v90);
                    }
                    if (a7) {
                      *a7 = *(unsigned char *)(v66 + 88) >> 7;
                    }
                    goto LABEL_36;
                  }
LABEL_43:
                  uint64_t v25 = 1;
                  if (!sub_1000191C0())
                  {
LABEL_55:
                    sub_100031F78(a1, v15);
                    sub_100037CCC(a1, (char)a3, a4, a2);
                    goto LABEL_56;
                  }
                  if (*(_WORD *)(v15 + 300) == 32766)
                  {
                    uint64_t v25 = 12;
                    goto LABEL_55;
                  }
                  if (a5)
                  {
                    xpc_retain(a5);
                  }
                  else
                  {
                    sub_10000D56C(0x12u, 2u, 0);
                    a5 = (void *)xpc_mach_send_create_with_disposition();
                  }
                  uint64_t v82 = sub_1000489B8(v15, a3, a5, (uint64_t)sub_10002C708, v15);
                  if (a6) {
                    *a6 = a5;
                  }
                  else {
                    xpc_release(a5);
                  }
                  v82[88] |= 4u;
                  sub_10002C948(v91, (void *)v15, (uint64_t)v82, 1);
                  sub_1000319CC(v91, (uint64_t)v82);
LABEL_36:
                  sub_100031F78(a1, v15);
                  sub_100031F78(a1, v15);
                  uint64_t v25 = 0;
LABEL_56:
                  sub_100030E18(a1, v15, v52, v53, v54, v55, v56, v57);
                  return v25;
                }
                sub_10002A5B8(v16, 3, "Service \"%s\" tried to register for endpoint \"%s\" already registered by owner: %s", v75, v76, v77, v78, v79, v15 + 112);
              }
LABEL_54:
              uint64_t v25 = 1;
              goto LABEL_55;
            }
            *(unsigned char *)(v66 + 88) |= 0x40u;
          }
          size_t v91 = v16;
          if (a4) {
            goto LABEL_43;
          }
          goto LABEL_54;
        }
        *(_DWORD *)(v15 + 368) |= 0x2000u;
      }
      *(unsigned char *)(v17 + 88) |= 4u;
      if (a6)
      {
        uint64_t v81 = (void *)sub_100049250(v17, 4, v45, v46, v47, v48, v49, v50);
        *a6 = xpc_retain(v81);
      }
      goto LABEL_36;
    }
    if (sub_1000191C0())
    {
      for (uint64_t i = *(void *)(v15 + 168); i; uint64_t i = *(void *)(i + 16))
      {
        if ((*(unsigned char *)(i + 88) & 0x40) == 0 && sub_100015D70((char *)(i + 168), a3))
        {
          uint64_t v37 = sub_100048818(i, 2, v31, v32, v33, v34, v35, v36);
          if (!sub_100031DC0(v37))
          {
            uint64_t v25 = 37;
            goto LABEL_55;
          }
          *(unsigned char *)(i + 88) |= 0x40u;
        }
      }
      if (a5)
      {
        xpc_retain(a5);
      }
      else
      {
        sub_10000D56C(0x12u, 6u, 0);
        a5 = (void *)xpc_mach_send_create_with_disposition();
      }
      uint64_t v51 = sub_1000489B8(v15, a3, a5, (uint64_t)sub_10002C708, v15);
      if (a6) {
        *a6 = a5;
      }
      else {
        xpc_release(a5);
      }
      v51[88] |= 5u;
      sub_10002C948(v16, (void *)v15, (uint64_t)v51, 2);
      goto LABEL_36;
    }
    uint64_t v25 = 1;
    sub_10002DE0C(a1, a2, 1, "pid-local registration");
    uint64_t v26 = a1;
    char v27 = (char)a3;
    uint64_t v28 = a4;
    uint64_t v29 = a2;
  }
  else
  {
    uint64_t v25 = 113;
    uint64_t v26 = a1;
    char v27 = (char)a3;
    uint64_t v28 = a4;
    uint64_t v29 = a2;
  }
  sub_100037CCC(v26, v27, v28, v29);
  return v25;
}

void sub_100037CCC(uint64_t a1, char a2, uint64_t a3, uint64_t a4)
{
  memset(v11, 0, sizeof(v11));
  sub_100042920(a4, (char *)v11);
  xpc_strerror();
  sub_10002A5B8(a1, 4, "failed activation: mach_port_name_t name = %s, flags = 0x%llx, requestor = %s[%d], error = %d: %s", v6, v7, v8, v9, v10, a2);
}

uint64_t sub_100037D84(uint64_t a1, void *a2)
{
  uint64_t result = (uint64_t)sub_100043720(a1);
  if (result)
  {
    xpc_object_t array = xpc_dictionary_get_array((xpc_object_t)result, "com.apple.private.xpc.launchd.enable-disable-system-services");
    if (!array) {
      return 0;
    }
    int v5 = array;
    if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array || xpc_get_type(a2) != (xpc_type_t)&_xpc_type_array) {
      sub_100043938("Given object not of required type.");
    }
    size_t count = xpc_array_get_count(v5);
    size_t v7 = xpc_array_get_count(a2);
    if (!count) {
      return 0;
    }
    size_t v8 = v7;
    if (!v7) {
      return 1;
    }
    BOOL v9 = 0;
    size_t v10 = 0;
LABEL_8:
    char string = xpc_array_get_string(a2, v10);
    if (string)
    {
      BOOL v12 = string;
      char v13 = 0;
      unint64_t v14 = 1;
      while (1)
      {
        uint64_t v15 = xpc_array_get_string(v5, v14 - 1);
        if (!v15) {
          break;
        }
        int v16 = strcmp(v12, v15);
        v13 |= v16 == 0;
        if (v16)
        {
          if (v14++ < count) {
            continue;
          }
        }
        if (v13)
        {
          BOOL v9 = ++v10 >= v8;
          if (v10 != v8) {
            goto LABEL_8;
          }
        }
        return v9;
      }
    }
    return v9;
  }
  return result;
}

void sub_100037EB4(void *a1, void *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  for (uint64_t i = a1[19]; i; uint64_t i = *(void *)(i + 16))
  {
    if ((*(unsigned char *)(i + 88) & 0x40) == 0) {
      xpc_dictionary_set_mach_send();
    }
  }
  for (uint64_t j = a1[20]; j; uint64_t j = *(void *)(j + 16))
  {
    if ((*(unsigned char *)(j + 88) & 0x40) == 0) {
      xpc_dictionary_set_mach_send();
    }
  }
  if (xpc_dictionary_get_count(v4)) {
    xpc_dictionary_set_value(a2, "MachServices", v4);
  }
  xpc_release(v4);
  xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
  for (uint64_t k = a1[21]; k; uint64_t k = *(void *)(k + 16))
  {
    if ((*(unsigned char *)(k + 88) & 0x40) == 0) {
      xpc_dictionary_set_mach_send();
    }
  }
  if (xpc_dictionary_get_count(v7)) {
    xpc_dictionary_set_value(a2, "PerJobMachServices", v7);
  }
  xpc_release(v7);
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  for (uint64_t m = a1[24]; m; uint64_t m = *(void *)(m + 16))
  {
    unint64_t v13 = 0;
    uint64_t v14 = 0;
    xpc_object_t v11 = xpc_array_create(0, 0);
    sub_10001CE90(m, &v14, &v13);
    if (v13)
    {
      for (unint64_t n = 0; n < v13; ++n)
        xpc_array_set_fd(v11, 0xFFFFFFFFFFFFFFFFLL, *(_DWORD *)(v14 + 4 * n));
    }
    xpc_dictionary_set_value(v9, (const char *)(m + 208), v11);
    xpc_release(v11);
  }
  if (xpc_dictionary_get_count(v9)) {
    xpc_dictionary_set_value(a2, "Sockets", v9);
  }
  xpc_release(v9);
}

uint64_t sub_100038098(uint64_t a1, const char *a2, void *a3)
{
  if (!sub_10001A45C(a2)) {
    goto LABEL_7;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  if ((*(unsigned char *)(v6 + 1016) & 3) == 0)
  {
    int v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void, void))(*(void *)(v6 + 112)
                                                                                               + 104))(v6, 4, 4, *(void *)(v6 + 120), v7, 0, 0);
    if (v9)
    {
      int v8 = v9;
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      goto LABEL_6;
    }
LABEL_7:
    xpc_type_t type = xpc_get_type(a3);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v15 = *(void *)(a1 + 32);
      int64_t string_ptr = xpc_string_get_string_ptr(a3);
      uint64_t v11 = v15;
      BOOL v12 = (char *)a2;
      uint64_t v14 = 1;
    }
    else
    {
      if (type != (xpc_type_t)&_xpc_type_null) {
        return 1;
      }
      uint64_t v11 = *(void *)(a1 + 32);
      BOOL v12 = (char *)a2;
      int64_t string_ptr = 0;
      uint64_t v14 = 0;
    }
    sub_100038188(v11, v12, string_ptr, v14);
    return 1;
  }
  int v8 = 124;
LABEL_6:
  sub_10002DE0C(v6, v7, v8, "set dyld environment variable");
  return 1;
}

void sub_100038188(uint64_t a1, char *__s, const char *a3, uint64_t a4)
{
  int v8 = (char **)(a1 + 96);
  int v9 = (void *)(a1 + 96);
  while (1)
  {
    int v9 = (void *)*v9;
    if (!v9) {
      break;
    }
    if (sub_10001A3D0((uint64_t)v9, __s))
    {
      size_t v10 = (void *)*v9;
      if (*v9) {
        v10[1] = v9[1];
      }
      *(void *)v9[1] = v10;
      *int v9 = -1;
      v9[1] = -1;
      j__free(v9);
      break;
    }
  }
  if (a3)
  {
    size_t v18 = 0;
    uint64_t v11 = sub_10001A1EC(__s, a3, a4, &v18, 0);
    if (v11)
    {
      uint64_t v17 = *v8;
      *(void *)uint64_t v11 = *v8;
      if (v17) {
        *((void *)v17 + 1) = v11;
      }
      *int v8 = v11;
      *((void *)v11 + 1) = v8;
    }
    else
    {
      sub_10002A5B8(a1, 3, "Service tried to %s global environment variable with reserved name: %s", v12, v13, v14, v15, v16, (char)"set");
    }
  }
}

void sub_100038290(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8((uint64_t)a1, 65540, "Wipe them out. All of them.", a4, a5, a6, a7, a8, v18[0]);
  sub_100043DF4(5, "starting obliteration");
  byte_100076ABA = 1;
  qword_100076490 = (uint64_t)dispatch_group_create();
  dispatch_group_enter((dispatch_group_t)qword_100076490);
  sub_10001A0AC(a1);
  size_t v10 = qword_100076490;
  uint64_t v11 = sub_100014B58();
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  _OWORD v18[2] = sub_100038404;
  _OWORD v18[3] = &unk_100070B98;
  v18[4] = a1;
  v18[5] = a2;
  dispatch_group_notify(v10, v11, v18);
  sub_1000384A0((uint64_t)a1, qword_100076490, v12, v13, v14, v15, v16, v17);
  byte_100076A79 = 1;
  byte_1000769D9 = 1;
  dispatch_group_leave((dispatch_group_t)qword_100076490);
}

uint64_t sub_1000383AC(mach_port_context_t guard)
{
  if (*(_UNKNOWN **)(guard + 112) != &unk_1000755B8) {
    sub_100050D0C();
  }
  uint64_t result = *(unsigned int *)(guard + 184);
  if (result)
  {
    uint64_t result = sub_10000D68C(result, 0, guard);
    if (result) {
      sub_100050D28();
    }
    *(_DWORD *)(guard + 184) = 0;
  }
  return result;
}

void sub_100038404(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8(*(void *)(a1 + 32), 5, "obliteration complete, sending reply", a4, a5, a6, a7, a8, v10);
  if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  sub_10001A174(*(void **)(a1 + 32));
  int v9 = *(void **)(a1 + 40);

  xpc_release(v9);
}

void sub_1000384A0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 328);
  if (v10)
  {
    do
    {
      uint64_t v11 = *(void *)(v10 + 104);
      sub_10002A5B8(a1, 5, "obliterating semi-active service: %s", a4, a5, a6, a7, a8, v10 + 112);
      int v12 = sub_100021E70(v10);
      if ((v12 - 36) >= 2)
      {
        if (v12 != 89) {
          sub_100040E80("inconsistency between domain and service semi-active state during obliterate");
        }
      }
      else
      {
        dispatch_group_enter(a2);
        *(_DWORD *)(v10 + 368) |= 0x4000u;
      }
      uint64_t v10 = v11;
    }
    while (v11);
  }
  for (uint64_t i = 0; i != 13; ++i)
  {
    for (uint64_t j = *(void *)(a1 + 8 * i + 544); j; uint64_t j = *(void *)(j + 88))
    {
      if (sub_1000221B4(j) == dword_1000765C0)
      {
        sub_10002A5B8(a1, 5, "skipping over obliterator: %s", v15, v16, v17, v18, v19, j + 112);
      }
      else
      {
        sub_10002A5B8(a1, 5, "obliterating active service: %s", v15, v16, v17, v18, v19, j + 112);
        unsigned int v20 = sub_100021E70(j);
        if (v20 > 0x25 || ((1 << v20) & 0x2000010001) == 0) {
          sub_100040E80("failed to stop active service %s: %d", (const char *)(j + 1392), v20);
        }
        dispatch_group_enter(a2);
        *(_DWORD *)(j + 368) |= 0x4000u;
      }
    }
  }
  sub_10002FC3C(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v22);
  for (uint64_t k = *(void *)(a1 + 320); k; uint64_t k = *(void *)(k + 16))
    sub_1000384A0(k, a2);
}

char *sub_100038654(uint64_t a1, FILE *a2)
{
  int v3 = *(_DWORD *)(a1 + 32);
  if (v3)
  {
    return sub_1000386B8(a2, v3);
  }
  else
  {
    for (uint64_t i = 0; i != 9; ++i)
      uint64_t result = sub_1000386B8(a2, i);
  }
  return result;
}

char *sub_1000386B8(FILE *a1, int a2)
{
  rlim_t v11 = -2;
  rlim_t v12 = -2;
  sub_100042E88(a2, &v11, &v12);
  uint64_t result = sub_100043124(a2);
  if (result)
  {
    uint64_t v10 = result;
    *(_OWORD *)__str = 0u;
    long long v16 = 0u;
    if (v12 == -1) {
      strcpy(__str, "unlimited");
    }
    else {
      snprintf(__str, 0x20uLL, "%lld", v12);
    }
    *(_OWORD *)uint64_t v13 = 0u;
    long long v14 = 0u;
    if (v11 == -1) {
      strcpy(v13, "unlimited");
    }
    else {
      snprintf(v13, 0x20uLL, "%lld", v11);
    }
    return (char *)sub_100046780(a1, 1, "%-12s%-15s%-15s", v5, v6, v7, v8, v9, v10, v13, __str);
  }
  return result;
}

xpc_type_t sub_1000387EC(uint64_t a1, FILE *a2)
{
  BOOL v4 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "version");
  BOOL v5 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "variant");
  BOOL v6 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "disabled");
  BOOL v7 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "cache");
  if (v4)
  {
    uint64_t v13 = off_100075AC8;
LABEL_5:
    uint64_t v56 = *v13;
    long long v14 = "%s";
    return (xpc_type_t)sub_100046780(a2, 0, v14, v8, v9, v10, v11, v12, v56);
  }
  if (v5)
  {
    uint64_t v13 = off_100075AD0;
    goto LABEL_5;
  }
  if (v7)
  {
    if (sub_100019B70()) {
      uint64_t v21 = "system services must be in cache";
    }
    else {
      uint64_t v21 = "disk will be searched for uncached services";
    }
    sub_100046780(a2, 0, v21, v16, v17, v18, v19, v20);
    if (qword_1000769C0)
    {
      sub_100046710(a2, 0, "cached daemons = {", v22, v23, v24, v25, v26);
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 0x40000000;
      v57[2] = sub_100038A78;
      v57[3] = &unk_100070BF8;
      v57[4] = a2;
      sub_100045F0C((rb_tree_t **)qword_1000769C0, (uint64_t)v57);
      char v27 = "}";
    }
    else
    {
      char v27 = "(no daemon cache)";
    }
    sub_100046780(a2, 0, v27, v22, v23, v24, v25, v26);
    if (qword_1000769C8)
    {
      sub_100046800(a2, v29, v30, v31, v32, v33, v34, v35, (char)v56);
      sub_100046710(a2, 0, "framework cache = ", v36, v37, v38, v39, v40);
      sub_100015F3C(a2, 0, 1, (void *)qword_1000769C8, v41, v42, v43, v44);
    }
    else
    {
      sub_100046780(a2, 0, "(no framework cache)", v31, v32, v33, v34, v35);
    }
    if (qword_1000769D0)
    {
      sub_100046800(a2, v45, v46, v8, v9, v10, v11, v12, (char)v56);
      sub_100046710(a2, 0, "bundle cache = ", v47, v48, v49, v50, v51);
      return sub_100015F3C(a2, 0, 1, (void *)qword_1000769D0, v52, v53, v54, v55);
    }
    long long v14 = "(no bundle cache)";
    return (xpc_type_t)sub_100046780(a2, 0, v14, v8, v9, v10, v11, v12, v56);
  }
  uint64_t v28 = *(void *)(a1 + 40);
  if (v6)
  {
    return (xpc_type_t)sub_100032650(v28, a2, 0, v8, v9, v10, v11, v12);
  }
  else
  {
    return (xpc_type_t)sub_10002CB2C(v28, a2);
  }
}

void sub_100038A78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100046710(*(FILE **)(a1 + 32), 1, "\"%s\" => ", a4, a5, a6, a7, a8, a2);
  uint64_t v9 = (void *)sub_100046114();
  sub_100015F3C(*(FILE **)(a1 + 32), 1, 0, v9, v10, v11, v12, v13);

  xpc_release(v9);
}

void sub_100038AF0(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 && a3 != 121)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    uint64_t v5 = *(void *)(a1 + 40);
    xpc_strerror();
    sub_10002A5B8(v4, 5, "failed to add extension %s: %d - %s", v6, v7, v8, v9, v10, v5);
  }
  if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  xpc_release(*(xpc_object_t *)(a1 + 48));
  uint64_t v11 = *(void **)(a1 + 40);

  free(v11);
}

void sub_100038BA8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[1];
  uint64_t v10 = (void *)a1[2];
  sub_10002A5B8(*a1, 5, "extension removal request finished, sending reply", a4, a5, a6, a7, a8, v11);
  if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  dispatch_release(v9);
  xpc_release(v10);

  sub_10001A12C(a1);
}

uint64_t sub_100038C44(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t v5 = sub_10002B6E4(a1, a2);
  uint64_t v6 = v5;
  if (v5)
  {
    if (v5 == 36)
    {
      dispatch_retain(a3);
      dispatch_group_enter(a3);
      if (*(void *)(a2 + 328))
      {
        sub_10001E4BC(a2, 5, "An extension-removal request is already in flight; chaining", v7, v8, v9, v10, v11, v20);
        uint64_t v12 = *(NSObject **)(a2 + 328);
        uint64_t v13 = sub_100014B58();
        dispatch_group_notify_f(v12, v13, a3, (dispatch_function_t)sub_100038D10);
      }
      else
      {
        *(void *)(a2 + 328) = a3;
      }
    }
    else
    {
      xpc_strerror();
      sub_10001E4BC(a2, 4, "An extension-removal request failed, error: %d - %s", v14, v15, v16, v17, v18, v6);
    }
  }
  return v6;
}

void sub_100038D10(NSObject *a1)
{
  dispatch_group_leave(a1);

  dispatch_release(a1);
}

uint64_t sub_100038D48(uint64_t a1, FILE *a2)
{
  return sub_10002CAAC(*(void *)(a1 + 32), a2);
}

void *sub_100038D50(unsigned int a1, uint64_t a2)
{
  int v2 = sub_10002EB7C((uint64_t)qword_100075640, a1, 0, 0, 0, qword_100076478, a2);
  sub_10002B4E4(v2, &qword_1000769A0, 0, v3, v4, v5, v6, v7);
  return v2;
}

uint64_t sub_100038DAC(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100038DB4(*(void *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100038DB4(uint64_t result, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (*(_UNKNOWN **)(result + 112) == &unk_1000755B8)
  {
    if (qword_100076960) {
      uint64_t result = sub_100046780(a2, 0, "JetsamProperties loaded from path : %s", a4, a5, a6, a7, a8, qword_100076960);
    }
    else {
      uint64_t result = sub_100046780(a2, 0, "JetsamProperties not loaded", a4, a5, a6, a7, a8);
    }
  }
  for (uint64_t i = 0; i != 23; ++i)
  {
    for (uint64_t j = *(void *)(v9 + 8 * i + 336); j; uint64_t j = *(void *)(j + 120))
      uint64_t result = sub_100024C04(j, a2, 0);
  }
  for (uint64_t k = *(void *)(v9 + 320); k; uint64_t k = *(void *)(k + 16))
    uint64_t result = sub_100038DB4(k, a2);
  return result;
}

uint64_t sub_100038E80(void *a1, void *a2, uint64_t *a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "type");
  if (!value) {
    return 22;
  }
  uint64_t v7 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_uint64) {
    return 22;
  }
  uint64_t v9 = xpc_uint64_get_value(v7);
  xpc_object_t v10 = xpc_dictionary_get_value(a1, "handle");
  if (!v10) {
    return 22;
  }
  uint64_t v11 = v10;
  if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_uint64) {
    return 22;
  }
  uint64_t v12 = xpc_uint64_get_value(v11);
  uint64_t v13 = 0;
  uint64_t result = 125;
  while (dword_1000758E8[v13] != v9)
  {
    v13 += 4;
    if (v13 == 24) {
      return result;
    }
  }
  uint64_t v14 = *(void **)&dword_1000758E8[v13 + 2];
  if (!v14) {
    return 125;
  }
  if (v9 == 3) {
    return 45;
  }
  if (v14 == qword_100075750 && v12 == 0) {
    return 112;
  }
  uint64_t result = 0;
  *a2 = v14;
  *a3 = v12;
  return result;
}

uint64_t sub_100038F9C(void *a1, uint64_t a2, uint64_t a3)
{
  if (a1 == (void *)&unk_1000757D8)
  {
    uint64_t v5 = sub_100020E4C(*(_DWORD *)(a3 + 20));
    if (v5) {
      return *(void *)(v5 + 248);
    }
    a2 = *(unsigned int *)(a3 + 12);
    a1 = qword_100075640;
  }
  else if (a1 == (void *)&unk_100075860)
  {
    uint64_t result = sub_10004740C();
    if (!result) {
      return qword_100076478;
    }
    return result;
  }

  return sub_100030024(a1, a2);
}

void *sub_10003902C(void *a1, unint64_t a2, char *a3, char a4, uint64_t a5, int *a6)
{
  if (!a1[13])
  {
    uint64_t v14 = 0;
    goto LABEL_5;
  }
  int v12 = sub_100032B64((uint64_t)a1, (unint64_t)(a1 != qword_100075750) << 7, a2, a5);
  if (v12)
  {
    int v13 = v12;
    sub_10002DE0C(qword_100076478, a5, v12, "domain creation");
    uint64_t v14 = 0;
    *a6 = v13;
    return v14;
  }
  if (a1 != qword_100075750)
  {
    uint64_t v16 = sub_100015BE4("%s/%lu", (const char *)a1[15], a2);
    sub_100036D40(qword_100076478, (uint64_t)v16, 0, 0, 0, a5, 112);
    *a6 = 112;
    free(v16);
    return 0;
  }
  memset(v36, 0, sizeof(v36));
  uint64_t v18 = "(premature birth)";
  if (!(a2 >> 31))
  {
    uint64_t v19 = *(unsigned int *)(a5 + 20);
    if ((v19 & 0x80000000) == 0 && v19 == a2)
    {
      uint64_t v20 = sub_100020E4C(a2);
      if (v20) {
        uint64_t v21 = sub_10002284C(v20);
      }
      else {
        uint64_t v21 = sub_100042920(a5, (char *)v36);
      }
      uint64_t v18 = v21;
    }
  }
  uint64_t v22 = sub_100030024(qword_100075750, a2);
  if (v22)
  {
    BOOL v23 = sub_100015D70(a3, *(const char **)(v22 + 968));
    uint64_t v14 = 0;
    if (v23) {
      int v15 = 37;
    }
    else {
      int v15 = 134;
    }
    goto LABEL_6;
  }
  uint64_t v24 = sub_10002EB7C((uint64_t)qword_100075750, a2, v18, a3, 0, qword_100076478, a5);
  uint64_t v14 = v24;
  if (a4)
  {
    sub_10002A5B8((uint64_t)v24, 5, "Will be pending launches until told otherwise", v25, v26, v27, v28, v29, v35);
    *((_DWORD *)v14 + 254) |= 0x8000u;
    sub_10002B4E4(v14, (uint64_t *)a5, 0, v30, v31, v32, v33, v34);
    return v14;
  }
  sub_10002B4E4(v24, (uint64_t *)a5, 0, v25, v26, v27, v28, v29);
  if (!v14)
  {
LABEL_5:
    int v15 = 112;
LABEL_6:
    *a6 = v15;
  }
  return v14;
}

void sub_100039274(void *a1, const char *a2, void *a3, uint64_t a4)
{
  if (!(*(unsigned int (**)(void *, uint64_t, void, void, uint64_t, void, void))(a1[14] + 104))(a1, 5, 0, a1[15], a4, 0, 0))
  {
    for (uint64_t i = 0; i != 23; ++i)
    {
      for (uint64_t j = a1[i + 42]; j; uint64_t j = *(void *)(j + 120))
      {
        int v10 = strtonum(a2, 1, 0x7FFFFFFFLL, 0);
        if (v10)
        {
          if (sub_1000221B4(j) != v10) {
            continue;
          }
        }
        else if (!sub_100015D50((char *)(j + 1392), a2))
        {
          uint64_t v11 = (char *)sub_100022804(j);
          if (!sub_100015D50(v11, a2)) {
            continue;
          }
        }
        int v12 = sub_1000203FC(j, 1);
        xpc_array_set_string(a3, 0xFFFFFFFFFFFFFFFFLL, v12);
        free(v12);
      }
    }
    for (uint64_t k = a1[40]; k; uint64_t k = *(void *)(k + 16))
      sub_100039274(k, a2, a3, a4);
  }
}

void sub_1000393A0(uint64_t a1)
{
  if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  xpc_release(*(xpc_object_t *)(a1 + 32));
  int v2 = *(NSObject **)(a1 + 48);

  dispatch_release(v2);
}

uint64_t sub_100039410(uint64_t a1, const char *a2, NSObject *a3, uint64_t a4)
{
  for (uint64_t i = 0; i != 13; ++i)
  {
    uint64_t v8 = *(void *)(a1 + 8 * i + 544);
    if (v8)
    {
      do
      {
        uint64_t v9 = *(void *)(v8 + 88);
        int v10 = (char *)sub_1000250E8(v8);
        if (sub_100015D70(v10, a2))
        {
          memset(v30, 0, sizeof(v30));
          char v11 = sub_1000250E8(v8);
          sub_100042920(a4, (char *)v30);
          sub_10001E4BC(v8, 5, "Terminating with cryptex %s, caller = %s[%d]", v12, v13, v14, v15, v16, v11);
          dispatch_group_enter(a3);
          uint64_t v17 = *(NSObject **)(v8 + 336);
          if (v17)
          {
            uint64_t v18 = sub_100014B58();
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000;
            block[2] = sub_100039620;
            block[3] = &unk_100070C98;
            block[4] = a3;
            dispatch_group_notify(v17, v18, block);
          }
          else
          {
            *(void *)(v8 + 336) = a3;
          }
          *(_DWORD *)(v8 + 368) |= 0x8000u;
          int v19 = sub_100021E70(v8);
          char v20 = v19;
          if ((v19 - 36) > 0x35 || ((1 << (v19 - 36)) & 0x20000000000003) == 0)
          {
            if (v19)
            {
              xpc_strerror();
              sub_10002A5B8(a1, 3, "Error during cryptex termination: %d - %s", v21, v22, v23, v24, v25, v20);
            }
          }
        }
        uint64_t v8 = v9;
      }
      while (v9);
    }
  }
  uint64_t result = *(void *)(a1 + 320);
  if (result)
  {
    do
    {
      uint64_t v27 = *(void *)(result + 16);
      sub_100039410();
      uint64_t result = v27;
    }
    while (v27);
  }
  return result;
}

void sub_100039620(uint64_t a1)
{
}

uint64_t sub_100039628(uint64_t a1, void *a2, void *a3)
{
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000755B8) {
    a1 = *(void *)(a1 + 232);
  }
  uint64_t v6 = *(void **)(a1 + 136);
  xpc_object_t reply = xpc_dictionary_create_reply(a2);
  xpc_dictionary_set_value(reply, "parent", v6);
  uint64_t result = 0;
  *a3 = reply;
  return result;
}

uint64_t sub_1000396AC(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 4294966992;
  }
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 4294966992;
  }
  uint64_t v9 = (char *)string;
  xpc_object_t value = xpc_dictionary_get_value(a3, "port");
  if (!value) {
    return 1102;
  }
  char v11 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_mach_send) {
    return 1102;
  }
  uint64_t int64 = xpc_dictionary_get_uint64(a3, "flags");
  uint64_t v14 = sub_1000377B0(a1, a2, v9, ((2 * (uint64 & 1)) | (uint64 >> 6) & 1) ^ 1, v11, 0, 0);
  uint64_t result = sub_100039BF8(v14);
  if (!result)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    uint64_t result = 0;
    *a4 = reply;
  }
  return result;
}

uint64_t sub_1000397A0(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 4294966992;
  }
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 4294966992;
  }
  uint64_t v9 = (char *)string;
  uint64_t int64 = xpc_dictionary_get_uint64(a3, "flags");
  xpc_object_t object = 0;
  uint64_t v11 = sub_1000377B0(a1, a2, v9, ((2 * (uint64 & 1)) | (uint64 >> 6) & 1) ^ 1, 0, &object, 0);
  uint64_t v12 = sub_100039BF8(v11);
  if (!v12)
  {
    xpc_object_t reply = xpc_dictionary_create_reply(a3);
    xpc_mach_send_get_right();
    xpc_dictionary_set_mach_recv();
    xpc_release(object);
    *a4 = reply;
  }
  return v12;
}

uint64_t sub_100039894(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (!xpc_dictionary_expects_reply()) {
    return 4294966992;
  }
  sub_100047418();
  if (xpc_dictionary_get_uint64(a3, "type") != 7)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, void, void))(*(void *)(a1 + 112)
                                                                                              + 104))(a1, 6, 0, *(void *)(a1 + 120), a2, 0, 0);
    if (v8)
    {
      uint64_t v9 = v8;
      sub_10002DE0C(a1, a2, v8, "endpoint lookup");
      return v9;
    }
  }
  char string = xpc_dictionary_get_string(a3, "name");
  if (!string) {
    return 4294966992;
  }
  uint64_t v11 = (char *)string;
  unsigned int int64 = xpc_dictionary_get_int64(a3, "targetpid");
  if ((int64 & 0x80000000) != 0) {
    return 22;
  }
  uuid = (unsigned __int8 *)xpc_dictionary_get_uuid(a3, "instance");
  uunsigned int int64 = xpc_dictionary_get_uint64(a3, "flags");
  uint64_t v15 = uint64;
  uint64_t v16 = uint64 >> 3;
  if ((((uint64 >> 3) & 4) != 0 || (uint64 & 0x100) != 0) && !uuid) {
    return 22;
  }
  if ((*(unsigned char *)(a1 + 1017) & 0x10) != 0
    && (uint64 & 0x10) == 0
    && *(_UNKNOWN **)(a1 + 112) == &unk_1000755B8
    && sub_10004B3A8(v11))
  {
    memset(v37, 0, sizeof(v37));
    sub_100042920(a2, (char *)v37);
    sub_10002A5B8(a1, 5, "pending bootstrap lookup during user switch: mach_port_name_t name = %s, requestor = %s[%d]", v24, v25, v26, v27, v28, (char)v11);
    if (*(void *)(a1 + 136)) {
      int right = xpc_mach_send_get_right();
    }
    else {
      int right = 0;
    }
    sub_100036864(a1, right, a3, 2);
    return 0;
  }
  else
  {
    unint64_t v17 = (v15 & 8 | (2 * (v15 & 1)) | (v15 >> 7) & 1 | v16 & 0x64) ^ 1;
    uint64_t v18 = sub_1000368E0(a1, v11, int64, v17, uuid, 0, a2);
    uint64_t v20 = v19;
    if (v19)
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      unsigned int v22 = sub_100039BF8(v20);
      xpc_dictionary_set_int64(reply, "error", v22);
    }
    else
    {
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      uint64_t v36 = (void *)sub_100049250(v18, 1, v30, v31, v32, v33, v34, v35);
      xpc_dictionary_set_value(reply, "port", v36);
      if (*(char *)(v18 + 88) < 0) {
        xpc_dictionary_set_BOOL(reply, "non-launching", 1);
      }
    }
    if (sub_100036C08(v18, v20, v11, int64, v17, uuid, 0, a2)) {
      sub_100036C8C(a1, reply, (uint64_t)v11);
    }
    uint64_t v9 = 0;
    *a4 = reply;
  }
  return v9;
}

uint64_t sub_100039B98(void *a1, void *a2)
{
  if (!xpc_dictionary_expects_reply()) {
    return 4294966992;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  xpc_dictionary_set_value(reply, "rootport", *(xpc_object_t *)(qword_100076478 + 136));
  uint64_t result = 0;
  *a2 = reply;
  return result;
}

uint64_t sub_100039BF8(uint64_t result)
{
  if ((int)result <= 36)
  {
    if (!result) {
      return result;
    }
    if (result != 1)
    {
      if (result == 3) {
        return 1102;
      }
      return 1105;
    }
    return 1100;
  }
  if ((int)result > 144)
  {
    if (result != 159)
    {
      if (result == 145) {
        return 1102;
      }
      return 1105;
    }
    return 1100;
  }
  if (result != 37)
  {
    if (result == 56) {
      return 1101;
    }
    return 1105;
  }
  return 1103;
}

uint64_t sub_100039C64(_DWORD *a1, uint64_t a2, char *__s1, void *a4, xpc_object_t *a5)
{
  if (!strcmp(__s1, "SubmitJob"))
  {
    if (!a4
      || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_dictionary && xpc_get_type(a4) != (xpc_type_t)&_xpc_type_array)
    {
      return 22;
    }
    if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_array)
    {
      *a5 = xpc_array_create(0, 0);
      if (xpc_array_get_count(a4))
      {
        size_t v45 = 0;
        do
        {
          xpc_object_t value = xpc_array_get_value(a4, v45);
          int v47 = sub_10003AAD4(a1, a2, value, 0);
          xpc_array_set_uint64(*a5, 0xFFFFFFFFFFFFFFFFLL, v47);
          ++v45;
        }
        while (v45 < xpc_array_get_count(a4));
      }
      return 0;
    }
    v96[0] = 0;
    uint64_t v21 = sub_10003AAD4(a1, a2, a4, v96);
    if (!v21)
    {
      unsigned int v22 = v96[0];
      if (!v96[0]) {
        goto LABEL_80;
      }
      int v23 = v96[0][92];
      if ((v23 & 8) == 0) {
        goto LABEL_80;
      }
      v96[0][92] = v23 & 0xFFFFFFF7;
      *((void *)a1 + 124) = v22;
      return 36;
    }
    return v21;
  }
  if (!strcmp(__s1, "RemoveJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22;
    }
    int64_t string_ptr = (char *)xpc_string_get_string_ptr(a4);
    unint64_t v95 = a1;
    uint64_t v25 = sub_100036720(&v95, string_ptr);
    if (v25)
    {
      uint64_t v26 = (uint64_t)v25;
      uint64_t v27 = v95;
      uint64_t v21 = sub_10002DD24((uint64_t)v95, 4, 8, a2, 0, 0);
      if (v21 || (uint64_t v21 = sub_1000201F8(), v21))
      {
        mach_port_t v94 = string_ptr;
        uint64_t v28 = "service removal (%s)";
LABEL_41:
        uint64_t v43 = (uint64_t)v27;
LABEL_54:
        sub_10002DE0C(v43, a2, v21, v28, v94);
        return v21;
      }
      bzero(v96, 0x400uLL);
      sub_1000328DC(*(_DWORD *)(a2 + 20), (char *)v96);
      sub_10001E4BC(v26, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v82, v83, v84, v85, v86, (char)"legacy-remove service");
      uint64_t v87 = sub_10002B6E4((uint64_t)v27, v26);
      uint64_t v21 = v87;
      if (v87)
      {
        if (v87 != 36)
        {
          xpc_strerror();
          sub_10001E4BC(v26, 3, "Could not stop service: mach_port_name_t name = %s, error = %d: %s", v88, v89, v90, v91, v92, (char)string_ptr);
        }
        return v21;
      }
      goto LABEL_90;
    }
    return 3;
  }
  if (!strcmp(__s1, "StartJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22;
    }
    uint64_t v29 = (char *)xpc_string_get_string_ptr(a4);
    v96[0] = a1;
    uint64_t v30 = sub_100036720(v96, v29);
    if (!v30) {
      return 3;
    }
    uint64_t v31 = (uint64_t)v30;
    a1 = v96[0];
    uint64_t v32 = sub_10002DD24((uint64_t)v96[0], 4, 8, a2, 0, 0);
    if (v32)
    {
      uint64_t v21 = v32;
      mach_port_t v94 = v29;
      uint64_t v28 = "service start (%s)";
LABEL_53:
      uint64_t v43 = (uint64_t)a1;
      goto LABEL_54;
    }
    uint64_t v69 = sub_100021748(v31, 9, v33, v34, v35, v36, v37, v38);
    uint64_t v21 = v69;
    if (v69 > 0x25 || ((1 << v69) & 0x3000000001) == 0) {
      return v21;
    }
LABEL_80:
    xpc_object_t v70 = xpc_uint64_create(0);
    uint64_t v21 = 0;
LABEL_81:
    *a5 = v70;
    return v21;
  }
  if (!strcmp(__s1, "StopJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22;
    }
    uint64_t v39 = (char *)xpc_string_get_string_ptr(a4);
    unint64_t v95 = a1;
    uint64_t v40 = sub_100036720(&v95, v39);
    if (v40)
    {
      uint64_t v41 = (uint64_t)v40;
      uint64_t v27 = v95;
      uint64_t v42 = sub_10002DD24((uint64_t)v95, 4, 8, a2, 0, 0);
      if (v42)
      {
        uint64_t v21 = v42;
        mach_port_t v94 = v39;
        uint64_t v28 = "service stop (%s)";
        goto LABEL_41;
      }
      bzero(v96, 0x400uLL);
      sub_1000328DC(*(_DWORD *)(a2 + 20), (char *)v96);
      sub_10001E4BC(v41, 5, "%s: caller = %s, xpc_object_t value = 0x%llx", v71, v72, v73, v74, v75, (char)"legacy-stop service");
      uint64_t v21 = sub_100021858(v41, a2, v76, v77, v78, v79, v80, v81);
      if (v21) {
        return v21;
      }
LABEL_90:
      xpc_object_t v70 = xpc_uint64_create(0);
      goto LABEL_81;
    }
    return 3;
  }
  if (!strcmp(__s1, "GetJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string) {
      return 22;
    }
    uint64_t v51 = (char *)xpc_string_get_string_ptr(a4);
    uint64_t v49 = a1;
    uint64_t v50 = a2;
    uint64_t v52 = 0;
LABEL_62:
    return sub_10003A568(v49, v50, v51, v52, a5, v10, v11, v12);
  }
  if (!strcmp(__s1, "GetJobs"))
  {
    uint64_t v48 = sub_10002DD24((uint64_t)a1, 5, 128, a2, 0, 0);
    if (!v48)
    {
      xpc_object_t v57 = xpc_dictionary_create(0, 0, 0);
      for (uint64_t i = 0; i != 23; ++i)
      {
        for (uint64_t j = *(void *)&a1[2 * i + 84]; j; uint64_t j = *(void *)(j + 120))
        {
          xpc_object_t v60 = sub_1000221F0(j);
          uint64_t v61 = (const char *)(j + 1392);
          if (v60)
          {
            uint64_t v62 = v60;
            xpc_dictionary_set_value(v57, v61, v60);
            xpc_release(v62);
          }
          else
          {
            xpc_dictionary_set_uint64(v57, v61, 0x99uLL);
          }
        }
      }
      uint64_t v21 = 0;
      *a5 = v57;
      return v21;
    }
    uint64_t v21 = v48;
    uint64_t v28 = "all services read";
    goto LABEL_53;
  }
  if (!strcmp(__s1, "CheckIn"))
  {
    uint64_t v49 = a1;
    uint64_t v50 = a2;
    uint64_t v51 = 0;
    uint64_t v52 = 1;
    goto LABEL_62;
  }
  if (!strcmp(__s1, "SetUserEnvironment"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary)
    {
      return sub_10003A71C((uint64_t)a1, a2, (uint64_t)a4, a5, v53, v54, v55, v56);
    }
    return 22;
  }
  if (!strcmp(__s1, "UnsetUserEnvironment"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
    {
      uint64_t v63 = (char *)xpc_string_get_string_ptr(a4);
      return sub_10003A7EC((uint64_t)a1, a2, v63, v64, v65, v66, v67, v68);
    }
    return 22;
  }
  if (strcmp(__s1, "Shutdown"))
  {
    if (!strcmp(__s1, "SingleUser"))
    {
      uint64_t v93 = "LAUNCH_KEY_SINGLEUSER never did anything anyway.";
    }
    else
    {
      if (strcmp(__s1, "GetResourceLimits") && strcmp(__s1, "SetResourceLimits"))
      {
        if (!strcmp(__s1, "GetResourceUsageSelf"))
        {
          uint64_t v18 = (uint64_t)a1;
          uint64_t v19 = a2;
          int v20 = 0;
          goto LABEL_95;
        }
        if (!strcmp(__s1, "GetResourceUsageChildren"))
        {
          uint64_t v18 = (uint64_t)a1;
          uint64_t v19 = a2;
          int v20 = -1;
LABEL_95:
          return sub_10003A9F4(v18, v19, v20, a5);
        }
        return 22;
      }
      uint64_t v93 = "rlimit(3)? Really?";
    }
    sub_10002A5B8((uint64_t)a1, 5, v93, v13, v14, v15, v16, v17, (char)v94);
    return 126;
  }

  return sub_10003A89C((mach_port_context_t)a1, a2, a5);
}

void sub_10003A504(char *__s1, void *a2, uint64_t a3)
{
  uint64_t v6 = *(_DWORD **)a3;
  uint64_t v7 = *(void *)(a3 + 8);
  xpc_object_t v10 = 0;
  int v8 = sub_100039C64(v6, v7, __s1, a2, &v10);
  if (v8) {
    xpc_object_t v10 = xpc_uint64_create(v8);
  }
  uint64_t v9 = *(void **)(a3 + 16);
  if (v9) {
    xpc_release(v9);
  }
  *(void *)(a3 + 16) = v10;
}

uint64_t sub_10003A568(_DWORD *a1, uint64_t a2, char *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = a4;
  uint64_t v24 = a1;
  if (!a3 || !a4)
  {
    if (a3) {
      uint64_t v12 = (uint64_t)sub_100036720(&v24, a3);
    }
    else {
      uint64_t v12 = sub_1000375E4((uint64_t *)&v24, *(_DWORD *)(a2 + 20), 0);
    }
    uint64_t v13 = (void *)v12;
    if (!v12 || *(_DWORD *)(v12 + 296)) {
      return 3;
    }
    if (v9)
    {
      if (sub_1000221B4(v12) != *(_DWORD *)(a2 + 20))
      {
        memset(v25, 0, sizeof(v25));
        char v18 = sub_100042920(a2, (char *)v25);
        sub_10002A5B8((uint64_t)v24, 3, "Unprivileged caller tried to check into job's endpoints: caller = %s.%d, owner = %s", v19, v20, v21, v22, v23, v18);
        return 1;
      }
      xpc_object_t v15 = sub_1000221F0((uint64_t)v13);
      sub_10003AE48((uint64_t)v24, (uint64_t)v13, v15, 1);
    }
    else
    {
      uint64_t v16 = v24;
      uint64_t v17 = sub_10002DD24((uint64_t)v24, 5, 8, a2, 0, 0);
      if (v17)
      {
        uint64_t v11 = v17;
        sub_10002DE0C((uint64_t)v16, a2, v17, "service read");
        return v11;
      }
      sub_1000221B4((uint64_t)v13);
      xpc_object_t v15 = sub_1000221F0((uint64_t)v13);
      sub_100037EB4(v13, v15);
    }
    uint64_t v11 = 0;
    *a5 = v15;
    return v11;
  }
  sub_10002A5B8((uint64_t)a1, 3, "Caller tried to check into a named job: %s", a4, (uint64_t)a5, a6, a7, a8, (char)a3);
  return 1;
}

uint64_t sub_10003A71C(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(*(void *)(a1 + 112) + 128) & 2) != 0)
  {
    uint64_t v9 = sub_10002DD24(a1, 4, 8, a2, 0, 0);
    if (v9)
    {
      sub_10002DE0C(a1, a2, v9, "set domain environment");
    }
    else
    {
      *a4 = xpc_uint64_create(0);
      xpc_dictionary_apply_f();
    }
  }
  else
  {
    sub_10002A5B8(a1, 3, "LAUNCH_KEY_SETUSERENVIRONMENT is only valid for user domains.", (uint64_t)a4, a5, a6, a7, a8, v13);
    return 125;
  }
  return v9;
}

uint64_t sub_10003A7EC(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(*(void *)(a1 + 112) + 128) & 2) != 0)
  {
    sub_10002A5B8(a1, 3, "LAUNCH_KEY_UNSETUSERENVIRONMENT is only valid for user domains.", a4, a5, a6, a7, a8, v13);
    return 125;
  }
  else
  {
    uint64_t v11 = sub_10002DD24(a1, 4, 8, a2, 0, 0);
    if (v11) {
      sub_10002DE0C(a1, a2, v11, "unset domain environment");
    }
    else {
      sub_100038188(a1, a3, 0, 0);
    }
  }
  return v11;
}

uint64_t sub_10003A89C(mach_port_context_t a1, uint64_t a2, xpc_object_t *a3)
{
  uint64_t v6 = sub_10002DD24(a1, 4, 8, a2, 0, 0);
  if (v6)
  {
    uint64_t v7 = v6;
    sub_10002DE0C(a1, a2, v6, "domain shutdown");
  }
  else if ((*(unsigned char *)(a1 + 1016) & 3) != 0)
  {
    return 37;
  }
  else
  {
    bzero(v19, 0x400uLL);
    sub_1000328DC(*(_DWORD *)(a2 + 20), v19);
    sub_10002A5B8(a1, 196613, "legacy shutdown initiated by: %s", v8, v9, v10, v11, v12, (char)v19);
    sub_10002A5B8(a1, 5, "legacy shutdown, caller = %s", v13, v14, v15, v16, v17, (char)v19);
    uint64_t v7 = sub_10000D68C(*(_DWORD *)(a1 + 184), -1, a1);
    if (v7)
    {
      _os_assumes_log_ctx();
    }
    else
    {
      *(_DWORD *)(a1 + 184) = 0;
      *a3 = xpc_uint64_create(0);
    }
  }
  return v7;
}

uint64_t sub_10003A9F4(uint64_t a1, uint64_t a2, int a3, xpc_object_t *a4)
{
  uint64_t v8 = sub_10002DD24(a1, 5, 8, a2, 0, 0);
  if (v8)
  {
    uint64_t v9 = v8;
    sub_10002DE0C(a1, a2, v8, "read resource usage");
  }
  else
  {
    memset(&v12, 0, sizeof(v12));
    int v10 = getrusage(a3, &v12);
    if (v10)
    {
      if (v10 == -1) {
        sub_1000517B0();
      }
      return *__error();
    }
    else
    {
      uint64_t v9 = 0;
      *a4 = xpc_data_create(&v12, 0x90uLL);
    }
  }
  return v9;
}

uint64_t sub_10003AAD4(_DWORD *a1, uint64_t a2, xpc_object_t object, void *a4)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v15 = sub_10003AC70(a1, object, a2);
    uint64_t v17 = v16;
    if (v16 == 134 && sub_100041068((uint64_t)a1))
    {
      char v18 = a1;
      do
      {
        uint64_t v19 = v18;
        char v18 = (_DWORD *)*((void *)v18 + 29);
      }
      while (v18);
      uint64_t v15 = sub_10003AC70(v19, object, a2);
      uint64_t v17 = v20;
    }
    uint64_t result = 0;
    if (v17)
    {
      if (v17 != 17 && v17 != 37)
      {
        xpc_dictionary_get_string(object, "Label");
        long long v29 = 0u;
        long long v30 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        char v21 = sub_100042920(a2, (char *)&v27);
        xpc_strerror();
        sub_10002A5B8((uint64_t)a1, 3, "Could not import service from caller: caller = %s[%d], service = %s, int error = %d: %s", v22, v23, v24, v25, v26, v21);
        return v17;
      }
    }
    else if (a4)
    {
      *a4 = v15;
    }
  }
  else
  {
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    char v8 = sub_100042920(a2, (char *)&v27);
    sub_10002A5B8((uint64_t)a1, 3, "Could not import service from caller: caller = %s[%d], job is not a dictionary", v9, v10, v11, v12, v13, v8);
    return 22;
  }
  return result;
}

void *sub_10003AC70(_DWORD *a1, void *a2, uint64_t a3)
{
  int v13 = sub_10002DD24((uint64_t)a1, 3, 8, a3, 0, 0);
  if (v13) {
    return 0;
  }
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)__str = 0u;
  long long v16 = 0u;
  memset(v14, 0, sizeof(v14));
  char v8 = sub_100042920(a3, (char *)v14);
  snprintf(__str, 0x80uLL, "(submitted by %s[%d])", v8, *(_DWORD *)(a3 + 20));
  if (sub_10002DCE8(a2, "Label")) {
    unint64_t v9 = 640;
  }
  else {
    unint64_t v9 = 512;
  }
  v12[0] = sub_10002BD38;
  v12[1] = sub_10002C1B0;
  v12[2] = sub_10002C2F8;
  v12[3] = sub_10002C494;
  void v12[4] = sub_10002C4F8;
  void v12[5] = sub_10002C5F8;
  v12[6] = a1;
  uint64_t v10 = (void *)sub_1000056B8(a1, a2, __str, a3, (uint64_t)v12, v9, &v13);
  if (v10)
  {
    uint64_t v6 = v10;
    sub_10001A0AC(v10);
    sub_10002B594(a1, (uint64_t)v6);
    uint64_t v11 = v6[172];
    sub_10001A174(v6);
    if ((v11 & 0x10000000) != 0) {
      return 0;
    }
  }
  else
  {
    if (!v13) {
      sub_100050CF0();
    }
    return 0;
  }
  return v6;
}

void sub_10003AE48(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  for (uint64_t i = *(void *)(a2 + 192); i; uint64_t i = *(void *)(i + 16))
  {
    xpc_object_t value = xpc_dictionary_get_value(v8, (const char *)(i + 208));
    if (value)
    {
      xpc_object_t v11 = xpc_retain(value);
    }
    else
    {
      xpc_object_t v11 = xpc_array_create(0, 0);
      xpc_dictionary_set_value(v8, (const char *)(i + 208), v11);
    }
    *(void *)&long long v32 = 0;
    xpc_object_t object = 0;
    if (sub_10001CDE0(i, &v32, 0, &object))
    {
      xpc_strerror();
      sub_10001E4BC(a2, 3, "Could not activate socket group: %s: %d: %s", v12, v13, v14, v15, v16, i - 48);
    }
    else if (object)
    {
      for (unint64_t j = 0; j < (unint64_t)object; ++j)
        xpc_array_set_fd(v11, 0xFFFFFFFFFFFFFFFFLL, *(_DWORD *)(v32 + 4 * j));
    }
    xpc_release(v11);
  }
  xpc_dictionary_set_value(a3, "Sockets", v8);
  xpc_release(v8);
  if (a4)
  {
    xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
    if ((*(unsigned char *)(a2 + 369) & 2) != 0) {
      sub_10001E4BC(a2, 4, "The launch(3) APIs cannot be used to check in MultipleInstance endpoints.", v18, v19, v20, v21, v22, v31);
    }
    for (uint64_t k = *(void *)(a2 + 152); k; uint64_t k = *(void *)(k + 16))
    {
      xpc_object_t object = 0;
      *(void *)&long long v25 = -1;
      *((void *)&v25 + 1) = -1;
      long long v32 = v25;
      long long v33 = v25;
      DWORD1(v33) = 0;
      DWORD1(v33) = sub_1000221B4(a2);
      if (sub_1000377B0(a1, (uint64_t)&v32, (char *)(k + 168), 0, 0, &object, 0))
      {
        sub_10001E4BC(a2, 3, "Failed to activate endpoint for legacy check-in. Please just don't use this API: %s", v26, v27, v28, v29, v30, k - 88);
      }
      else
      {
        sub_10001E4BC(a2, 4, "Endpoint has been activated through legacy launch(3) APIs. Please switch to XPC or bootstrap_check_in(): %s", v26, v27, v28, v29, v30, k - 88);
        xpc_mach_send_get_right();
        xpc_dictionary_set_mach_recv();
        xpc_release(object);
      }
    }
    xpc_dictionary_set_value(a3, "MachServices", v23);
    xpc_release(v23);
  }
}

void sub_10003B09C(char *a1, xpc_object_t object, uint64_t a3)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    int64_t string_ptr = xpc_string_get_string_ptr(object);
    sub_100038188(a3, a1, string_ptr, 0);
  }
}

void sub_10003B11C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(_DWORD *)(a1 + 184) = a2;
  uintptr_t v11 = a2;
  uint64_t v12 = sub_100014B58();
  *(void *)(a1 + 152) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v11, 1uLL, v12);
  sub_10001A5C4(a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 152), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 152), (dispatch_function_t)sub_10002ABD8);
  dispatch_source_set_mandatory_cancel_handler_f();
  dispatch_activate(*(dispatch_object_t *)(a1 + 152));
  if (*(void **)(a1 + 112) == qword_100075750)
  {
    uintptr_t v20 = *(void *)(a1 + 120);
    uint64_t v21 = sub_100014B58();
    *(void *)(a1 + 144) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v20, 0x20000000uLL, v21);
    sub_10001A5C4(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 144), (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 144), (dispatch_function_t)sub_10003B320);
    uint64_t v22 = sub_100020E4C(*(_DWORD *)(a1 + 120));
    if (v22 && !sub_1000229FC(v22))
    {
      sub_10002A5B8(a1, 5, "deferring exec source uncork", v23, v24, v25, v26, v27, v28);
      *(_DWORD *)(a1 + 1016) |= 0x200u;
    }
    else
    {
      sub_10002A5B8(a1, 5, "uncorking exec source upfront", v23, v24, v25, v26, v27, v28);
      dispatch_activate(*(dispatch_object_t *)(a1 + 144));
    }
  }
  if ((a2 - 1) > 0xFFFFFFFD || sub_100031DC0(a2))
  {
    sub_10002AA9C(a1, v13, v14, v15, v16, v17, v18, v19, a9);
  }
}

void sub_10003B2C8(NSObject *a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(a1);
  if (handle - 1 <= 0xFFFFFFFD && sub_10000D678(handle)) {
    _os_assumes_log();
  }

  dispatch_release(a1);
}

void sub_10003B320(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10002A5B8(a1, 5, "domain exec event", a4, a5, a6, a7, a8, v16);
  *(_DWORD *)(a1 + 1016) |= 0x80u;

  sub_10002ABD8(a1, v9, v10, v11, v12, v13, v14, v15);
}

char *sub_10003B370()
{
  return sub_10002A624(v0, 1);
}

char *sub_10003B38C(uint64_t a1, uint64_t a2)
{
  return sub_1000203FC(a2, 1);
}

char *sub_10003B3B0(uint64_t a1)
{
  return sub_1000203FC(a1, 1);
}

void sub_10003B3D4()
{
  qword_1000765C8 = 0;
  qword_1000765D0 = 0;
}

uint64_t sub_10003B3E8(void *a1)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  if (!reply) {
    sub_100050D0C();
  }
  uint64_t v3 = (uint64_t)reply;
  os_unfair_lock_lock_with_options();
  if ((void *)qword_1000765C8 == a1) {
    qword_1000765D0 = v3;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000765D8);
  return v3;
}

void sub_10003B450(uint64_t a1)
{
  os_unfair_lock_lock_with_options();
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_1000765D8);
  qword_1000765C8 = a1;
  qword_1000765D0 = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000765D8);
}

uint64_t sub_10003B4B0(uint64_t a1, NSObject *a2, void *a3)
{
  os_unfair_lock_lock_with_options();
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_1000765D8);
  if (qword_1000765D0) {
    BOOL v6 = qword_1000765D0 == a1;
  }
  else {
    BOOL v6 = 0;
  }
  uint64_t v7 = v6;
  if (v6)
  {
    os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_1000765D8);
    qword_1000765C8 = 0;
    qword_1000765D0 = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000765D8);
    xpc_dictionary_handoff_reply();
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000765D8);
    dispatch_async(a2, a3);
  }
  return v7;
}

uint64_t sub_10003B570()
{
  if ((*(unsigned char *)(sub_100030018() + 1016) & 4) == 0) {
    sub_100050D0C();
  }
  uint32_t multiuser_flags = 0;
  mach_port_t v0 = mach_host_self();
  if (host_get_multiuser_config_flags(v0, &multiuser_flags)) {
    return 0;
  }
  else {
    return multiuser_flags & 0x3FFFFFFF;
  }
}

uint64_t sub_10003B5BC()
{
  if ((*(unsigned char *)(sub_100030018() + 1016) & 4) == 0) {
    sub_100050D0C();
  }
  if (qword_1000765E0 != -1) {
    dispatch_once(&qword_1000765E0, &stru_100070CD8);
  }
  return byte_1000765E8;
}

void sub_10003B610(id a1)
{
  uint32_t multiuser_flags = 0;
  mach_port_t v1 = mach_host_self();
  if (host_get_multiuser_config_flags(v1, &multiuser_flags)) {
    BOOL v2 = 0;
  }
  else {
    BOOL v2 = (multiuser_flags & 0x80000000) != 0;
  }
  char v3 = v2;
  byte_1000765E8 = v3;
}

uint64_t sub_10003B654(int *a1)
{
  int v1 = *a1;
  memset(v3, 0, sizeof(v3));
  int v4 = v1;
  if (v1 == -101) {
    strcpy(&v3[12], "system");
  }
  else {
    snprintf(&v3[12], 0xFFuLL, "user.%d", v1);
  }
  if (kpersona_alloc() == -1) {
    sub_100050E38();
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10003B784()
{
  uint64_t result = kpersona_dealloc();
  if (result == -1) {
    return sub_100050E38();
  }
  return result;
}

uint64_t sub_10003B7AC()
{
  if (kpersona_pidinfo()) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t sub_10003B868(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v10 = *a3;
  int v4 = kpersona_find_by_type();
  if (v4 < 0)
  {
    int v6 = v4;
    int v7 = *__error();
    xpc_object_t v8 = __error();
    uint64_t v9 = strerror(*v8);
    sub_100043D78(4, "kpersona_find_by_type() failed with ret %d errno %d - %s", v6, v7, v9);
    *a3 = 0;
    return *__error();
  }
  else
  {
    uint64_t result = 0;
    *a3 = v10;
  }
  return result;
}

uint64_t sub_10003B8F8()
{
  if (kpersona_info()) {
    return 4294967293;
  }
  else {
    return 0;
  }
}

_DWORD *sub_10003B9B4()
{
  return sub_100047428(11, (uint64_t)sub_10003B9CC);
}

uint64_t sub_10003B9CC(uint64_t a1, int a2, void *a3, void *a4)
{
  int v7 = sub_100047400();
  if (!sub_10000FE40((uint64_t)v7, 37)) {
    return 144;
  }
  int v8 = *((_DWORD *)v7 + 5);
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  memset(buffer, 0, sizeof(buffer));
  uint64_t result = sub_1000428E0(v8, buffer);
  if (!result)
  {
    uint64_t v14 = 0;
    uint64_t result = sub_10003F00C(v8, &v14);
    if (result)
    {
      if (v14) {
        sub_100050D0C();
      }
    }
    else if (*((void *)&v16 + 1) == *(void *)(*(void *)v14 + 1144))
    {
      if (a2 == 1200)
      {
        uint64_t v10 = *(void *)v14;
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_object_t v12 = reply;
        uint64_t v13 = *(void **)(v10 + 640);
        if (v13) {
          xpc_dictionary_set_value(reply, "additional-properties", v13);
        }
        uint64_t result = 0;
        *a4 = v12;
      }
      else
      {
        return 33;
      }
    }
    else
    {
      return 113;
    }
  }
  return result;
}

FILE *sub_10003BB08(const char *a1)
{
  if (byte_100076A63) {
    return 0;
  }
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/launchd.log", a1);
  if (!access(__str, 0))
  {
    bzero(v9, 0x400uLL);
    snprintf(v9, 0x400uLL, "%s/launchd.log.1", a1);
    if (!access(v9, 0))
    {
      bzero(v8, 0x400uLL);
      snprintf(v8, 0x400uLL, "%s/launchd.log.2", a1);
      renamex_np(v9, v8, 0x10u);
    }
    renamex_np(__str, v9, 0x10u);
  }
  int v4 = open(__str, 536872449, 438);
  if (v4 < 0)
  {
    int v6 = __error();
    sub_10000FD44("launchd.log: open(%s): %d\n", __str, *v6);
    return 0;
  }
  uint64_t v5 = fdopen(v4, "w");
  int v1 = v5;
  if (v5)
  {
    setvbuf(v5, 0, 0, 0x4000uLL);
  }
  else
  {
    int v7 = __error();
    sub_10000FD44("launchd.log: fdopen(%s): %d\n", __str, *v7);
  }
  return v1;
}

uint64_t *sub_10003BCA8(void *a1, unsigned char *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    uint64_t v7 = 0;
    long long v8 = 0uLL;
    uint64_t v21 = 0;
    uint64_t v22 = &v21;
    uint64_t v23 = 0x2000000000;
    char v24 = 0;
    uint64_t v17 = 0;
    long long v18 = &v17;
    uint64_t v19 = 0x2000000000;
    char v20 = 0;
    applier = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10003BFB0;
    xpc_object_t v12 = &unk_100070D20;
    uint64_t v15 = a2;
    long long v16 = &v7;
    uint64_t v13 = &v21;
    uint64_t v14 = &v17;
    xpc_dictionary_apply(a1, &applier);
    if (*((unsigned char *)v22 + 24))
    {
      if (*((unsigned char *)v18 + 24))
      {
        sub_100014CD8(a2, 3, "Found unsupported directives");
      }
      else if ((_BYTE)v7)
      {
        if (v8 != 0)
        {
          _Block_object_dispose(&v17, 8);
          _Block_object_dispose(&v21, 8);
          if (BYTE1(v7)) {
            int v6 = (long long *)((char *)&v8 + 8);
          }
          else {
            int v6 = &v8;
          }
          if (*(void *)v6) {
            return (uint64_t *)sub_10003BCA8(*(void *)v6, a2);
          }
          else {
            return 0;
          }
        }
        sub_100014CD8(a2, 3, "Either %s or %s must be present");
      }
      else
      {
        sub_100014CD8(a2, 3, "Missing conditions");
      }
    }
    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
    xpc_object_t empty = (uint64_t *)xpc_dictionary_create_empty();
    applier = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10003BF54;
    xpc_object_t v12 = &unk_100070CF8;
    uint64_t v13 = (uint64_t *)a2;
    uint64_t v14 = empty;
    xpc_dictionary_apply(a1, &applier);
    return empty;
  }
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    xpc_object_t empty = (uint64_t *)xpc_array_create_empty();
    applier = _NSConcreteStackBlock;
    uint64_t v10 = 0x40000000;
    uint64_t v11 = sub_10003C168;
    xpc_object_t v12 = &unk_100070D40;
    uint64_t v13 = (uint64_t *)a2;
    uint64_t v14 = empty;
    xpc_array_apply(a1, &applier);
    return empty;
  }

  return (uint64_t *)xpc_copy(a1);
}

uint64_t sub_10003BF54(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v5 = (void *)sub_10003BCA8(a3, *(void *)(a1 + 32));
  if (v5)
  {
    int v6 = v5;
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 40), a2, v5);
    xpc_release(v6);
  }
  return 1;
}

uint64_t sub_10003BFB0(void *a1, char *__s1, void *a3)
{
  int v6 = (unsigned char *)a1[6];
  uint64_t v7 = a1[7];
  BOOL v8 = sub_100015D70(__s1, "#IfFeatureFlagEnabled");
  BOOL v9 = sub_100015D70(__s1, "#IfFeatureFlagDisabled");
  if (v8 || v9)
  {
    if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string)
    {
      int64_t string_ptr = (char *)xpc_string_get_string_ptr(a3);
      uint64_t v14 = strchr(string_ptr, 47);
      if (v14)
      {
        uint64_t v15 = v14;
        if (!strchr(v14 + 1, 47))
        {
          long long v16 = sub_100015A48(string_ptr, v15 - string_ptr);
          char v17 = j___os_feature_enabled_impl();
          free(v16);
          *(unsigned char *)(v7 + 1) |= v8 ^ v17;
          char v11 = 1;
          *(unsigned char *)uint64_t v7 = 1;
          goto LABEL_12;
        }
        sub_100014CD8(v6, 3, "Feature flag string must not have multiple '/' separators: %s");
      }
      else
      {
        sub_100014CD8(v6, 3, "Feature flag string must have domain/feature format: %s");
      }
    }
    else
    {
      xpc_type_t type = xpc_get_type(a3);
      xpc_type_get_name(type);
      sub_100014CD8(v6, 3, "Expected string for a feature flag, got %s");
    }
    goto LABEL_11;
  }
  if (!sub_100015D70(__s1, "#Then"))
  {
    if (sub_100015D70(__s1, "#Else"))
    {
      *(void *)(v7 + 16) = a3;
      goto LABEL_10;
    }
LABEL_11:
    char v11 = 0;
    goto LABEL_12;
  }
  *(void *)(v7 + 8) = a3;
LABEL_10:
  char v11 = 1;
LABEL_12:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) |= v11;
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) |= v11 ^ 1;
  return 1;
}

uint64_t sub_10003C168(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = (void *)sub_10003BCA8(a3, *(void *)(a1 + 32));
  if (v4)
  {
    uint64_t v5 = v4;
    xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v4);
    xpc_release(v5);
  }
  return 1;
}

void sub_10003C1B4(void *a1)
{
  if (a1[2] != -1 || a1[3] != -1) {
    sub_100050D0C();
  }
  if (a1[6]) {
    sub_100050D0C();
  }
  int v1 = (void *)a1[5];

  sub_10001A174(v1);
}

void sub_10003C210(void *a1)
{
  if (a1[5]) {
    sub_100050D0C();
  }
  if (sub_100045F90(a1[4])) {
    sub_100050D0C();
  }
  if (sub_100045F90(a1[7])) {
    sub_100050D0C();
  }
  if (a1[6])
  {
    uint64_t v2 = a1[2];
    if (v2) {
      *(void *)(v2 + 24) = a1[3];
    }
    *(void *)a1[3] = v2;
    a1[2] = -1;
    a1[3] = -1;
  }
  sub_10001A174((void *)a1[4]);
  char v3 = (void *)a1[7];

  sub_10001A174(v3);
}

uint64_t sub_10003C2BC(uint64_t result)
{
  if (*(void *)(result + 16)) {
    sub_100050D0C();
  }
  return result;
}

void sub_10003C2DC(void *a1)
{
  if (a1[2] != -1 || a1[3] != -1) {
    sub_100050D0C();
  }
  if (a1[4] != -1 || a1[5] != -1) {
    sub_100050D0C();
  }
  int v1 = (void *)a1[7];

  xpc_release(v1);
}

_DWORD *sub_10003C33C()
{
  return sub_100047428(4, (uint64_t)sub_10003C354);
}

uint64_t sub_10003C354(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7 = sub_100047400();
  int v8 = a2 - 400;
  uint64_t v9 = (uint64_t)v7;
  uint64_t v10 = 45;
  switch(v8)
  {
    case 0:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      uint64_t v98 = 0;
      uint64_t v10 = sub_10003D710(a3, 0, *(_DWORD *)(v9 + 20), 1, &v98);
      if (!v10)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        *a4 = reply;
        if (v98) {
          uint64_t v12 = *(void *)(v98 + 72);
        }
        else {
          uint64_t v12 = 0;
        }
        xpc_dictionary_set_uint64(reply, "token", v12);
        return 0;
      }
      return v10;
    case 1:
      int v13 = *((_DWORD *)v7 + 5);
      uint64_t v14 = a3;
      uint64_t v15 = a4;
      return sub_10003D968(v14, v15, v13);
    case 2:
      uint64_t v17 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v17) {
        return 1;
      }
      uint64_t v18 = v17;
      char string = xpc_dictionary_get_string(a3, "stream");
      uint int64 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22;
      if (!string) {
        return v10;
      }
      uint64_t v21 = uint64;
      if (!uint64 || !xpc_dictionary_expects_reply()) {
        return v10;
      }
      uint64_t v22 = *(void *)(v18 + 144);
      if (!v22) {
        return 3;
      }
      while (1)
      {
        uint64_t v23 = *(void *)(v22 + 40);
        if (!strcmp((const char *)(v23 + 40), string)) {
          break;
        }
        uint64_t v22 = *(void *)(v22 + 16);
        uint64_t v10 = 3;
        if (!v22) {
          return v10;
        }
      }
      uint64_t v69 = *(void *)(v23 + 16);
      if (!v69) {
        goto LABEL_107;
      }
      while (*(void *)(v69 + 72) != v21)
      {
        uint64_t v69 = *(void *)(v69 + 32);
        if (!v69) {
          goto LABEL_107;
        }
      }
      xpc_object_t v30 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_string(v30, "name", (const char *)(v69 + 88));
      goto LABEL_28;
    case 3:
      uint64_t v24 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v24) {
        return 1;
      }
      uint64_t v25 = v24;
      uint64_t v26 = xpc_dictionary_get_string(a3, "stream");
      if (!v26) {
        return 22;
      }
      uint64_t v27 = v26;
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      uint64_t v28 = *(void *)(v25 + 144);
      if (!v28) {
        goto LABEL_23;
      }
      while (strcmp((const char *)(*(void *)(v28 + 40) + 40), v27))
      {
        uint64_t v28 = *(void *)(v28 + 16);
        if (!v28)
        {
LABEL_23:
          if ((*(unsigned char *)(v25 + 368) & 0x10) != 0) {
            return 124;
          }
          if (!sub_10000FE40(v9, 7)) {
            return 3;
          }
          LODWORD(v98) = 0;
          uint64_t v29 = sub_10003CBBC(v25, v27, 1, (int *)&v98);
          uint64_t v10 = v98;
          if (v98) {
            return v10;
          }
          uint64_t v28 = (uint64_t)v29;
          if (!v29) {
            sub_100050D0C();
          }
          break;
        }
      }
      xpc_object_t v30 = xpc_dictionary_create_reply(a3);
      sub_10003DB0C(v30, v28);
LABEL_28:
      uint64_t v10 = 0;
      goto LABEL_29;
    case 4:
      uint64_t v31 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v31) {
        return 1;
      }
      uint64_t v32 = v31;
      long long v33 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v34 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22;
      if (!v33) {
        return v10;
      }
      uint64_t v35 = v34;
      if (!v34 || !xpc_dictionary_expects_reply()) {
        return v10;
      }
      uint64_t v22 = *(void *)(v32 + 144);
      if (!v22) {
        return 3;
      }
      while (1)
      {
        uint64_t v36 = *(void *)(v22 + 40);
        if (!strcmp((const char *)(v36 + 40), v33)) {
          break;
        }
        uint64_t v22 = *(void *)(v22 + 16);
        uint64_t v10 = 3;
        if (!v22) {
          return v10;
        }
      }
      uint64_t v70 = *(void *)(v36 + 16);
      if (!v70) {
        goto LABEL_107;
      }
      while (*(void *)(v70 + 72) != v35)
      {
        uint64_t v70 = *(void *)(v70 + 32);
        if (!v70) {
          goto LABEL_107;
        }
      }
      BOOL v75 = xpc_dictionary_get_BOOL(a3, "state");
      char v82 = *(unsigned char *)(v70 + 80);
      *(unsigned char *)(v70 + 80) = v82 & 0xFE | v75;
      if (v75)
      {
        if ((v82 & 2) != 0) {
          uint64_t v83 = 11;
        }
        else {
          uint64_t v83 = 8;
        }
        unsigned int v84 = sub_100021748(*(void *)(v70 + 48), v83, v76, v77, v78, v79, v80, v81);
        if (v84 > 0x25 || ((1 << v84) & 0x3000000001) == 0)
        {
          char v86 = v84;
          uint64_t v87 = *(void *)(v70 + 48);
          xpc_strerror();
          sub_10001E4BC(v87, 3, "Could not spawn service in response to XPC event state change: %d: %s", v88, v89, v90, v91, v92, v86);
        }
        if ((*(unsigned char *)(v70 + 80) & 2) != 0)
        {
          sub_10003D5CC((void *)v70);
          sub_10001A174((void *)v70);
        }
      }
      uint64_t v10 = 0;
      *a4 = xpc_dictionary_create_reply(a3);
      return v10;
    case 5:
    case 7:
      return v10;
    case 6:
      uint64_t v37 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v37) {
        return 1;
      }
      uint64_t v38 = v37;
      uint64_t v39 = xpc_dictionary_get_string(a3, "stream");
      if (!v39) {
        return 22;
      }
      uint64_t v40 = v39;
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      uint64_t v41 = *(void *)(v38 + 144);
      if (!v41)
      {
LABEL_44:
        BOOL v42 = (*(unsigned char *)(v38 + 368) & 0x10) == 0;
        unsigned int v43 = 124;
        goto LABEL_109;
      }
      while (strcmp((const char *)(*(void *)(v41 + 40) + 40), v40))
      {
        uint64_t v41 = *(void *)(v41 + 16);
        if (!v41) {
          goto LABEL_44;
        }
      }
      if (*(unsigned char *)(v41 + 56))
      {
        xpc_object_t v74 = xpc_dictionary_create_reply(a3);
        if ((xpc_pipe_routine_reply() & 0xFFFFFFDF) != 0) {
          _os_assumes_log();
        }
        xpc_release(v74);
        return 0;
      }
      else
      {
        if (*(void *)(v41 + 48))
        {
          if ((xpc_pipe_routine_reply() & 0xFFFFFFDF) != 0) {
            _os_assumes_log();
          }
          xpc_release(*(xpc_object_t *)(v41 + 48));
          *(void *)(v41 + 48) = 0;
        }
        uint64_t v10 = 0;
        *(void *)(v41 + 48) = xpc_dictionary_create_reply(a3);
      }
      return v10;
    case 8:
      uint64_t v44 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v44) {
        return 1;
      }
      uint64_t v45 = v44;
      uint64_t v46 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v47 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22;
      if (!v46) {
        return v10;
      }
      uint64_t v48 = v47;
      if (!v47 || !xpc_dictionary_expects_reply()) {
        return v10;
      }
      uint64_t v49 = *(void *)(v45 + 144);
      if (!v49) {
        return 3;
      }
      while (1)
      {
        uint64_t v50 = *(void *)(v49 + 40);
        if (!strcmp((const char *)(v50 + 40), v46)) {
          break;
        }
        uint64_t v49 = *(void *)(v49 + 16);
        uint64_t v10 = 3;
        if (!v49) {
          return v10;
        }
      }
      uint64_t v71 = *(void *)(v50 + 16);
      if (!v71)
      {
LABEL_103:
        char v72 = *(unsigned char *)(v49 + 56);
        goto LABEL_108;
      }
      while (*(void *)(v71 + 72) != v48)
      {
        uint64_t v71 = *(void *)(v71 + 32);
        if (!v71) {
          goto LABEL_103;
        }
      }
      xpc_dictionary_set_string(a3, "name", (const char *)(v71 + 88));
      int int64 = xpc_dictionary_get_int64(a3, "subscriber-pid");
      uint64_t v98 = 0;
      uint64_t v10 = sub_10003D710(a3, v49, int64, 0, &v98);
      if (!v10)
      {
        xpc_object_t v30 = xpc_dictionary_create_reply(a3);
        sub_10003DB0C(v30, v49);
        if (v98) {
          uint64_t v94 = *(void *)(v98 + 72);
        }
        else {
          uint64_t v94 = 0;
        }
        xpc_dictionary_set_uint64(v30, "token", v94);
LABEL_29:
        *a4 = v30;
      }
      return v10;
    case 9:
      uint64_t v51 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v51) {
        return 1;
      }
      uint64_t v52 = v51;
      uint64_t v53 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v54 = xpc_dictionary_get_uint64(a3, "token");
      uint64_t v10 = 22;
      if (!v53) {
        return v10;
      }
      uint64_t v55 = v54;
      if (!v54 || !xpc_dictionary_expects_reply()) {
        return v10;
      }
      uint64_t v22 = *(void *)(v52 + 144);
      if (!v22) {
        return 3;
      }
      break;
    case 10:
      xpc_object_t v57 = &stru_100070DE8;
      return sub_10003DBC4(a3, a4, (uint64_t)v7, (uint64_t)v57);
    case 11:
      xpc_object_t v57 = &stru_100070E50;
      return sub_10003DBC4(a3, a4, (uint64_t)v7, (uint64_t)v57);
    case 12:
      uint64_t v58 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (!v58) {
        return 1;
      }
      uint64_t v59 = v58;
      xpc_object_t v60 = xpc_dictionary_get_string(a3, "stream");
      uint64_t v61 = xpc_dictionary_get_string(a3, "name");
      xpc_object_t value = xpc_dictionary_get_value(a3, "descriptor");
      int v63 = xpc_dictionary_get_int64(a3, "subscriber-pid");
      uint64_t v10 = 22;
      if (!v60) {
        return v10;
      }
      if (!v61) {
        return v10;
      }
      int v64 = v63;
      if (!v63
        || !value
        || xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary
        || !xpc_dictionary_expects_reply())
      {
        return v10;
      }
      uint64_t v65 = sub_100020E4C(v64);
      if (!v65) {
        return 113;
      }
      uint64_t v66 = *(void *)(v59 + 144);
      if (!v66) {
        return 3;
      }
      uint64_t v67 = (void *)v65;
      uint64_t v10 = 3;
      while (strcmp((const char *)(*(void *)(v66 + 40) + 40), v60))
      {
        uint64_t v66 = *(void *)(v66 + 16);
        if (!v66) {
          return v10;
        }
      }
      unint64_t v95 = sub_10003D3EC(v67, v60, v61, value, 0);
      xpc_object_t v96 = xpc_dictionary_create_reply(a3);
      xpc_object_t v30 = v96;
      if (v95)
      {
        sub_10003DB0C(v96, v66);
        uint64_t v97 = *((void *)v95 + 9);
      }
      else
      {
        uint64_t v97 = 0;
      }
      xpc_dictionary_set_uint64(v30, "token", v97);
      goto LABEL_28;
    default:
      return 33;
  }
  while (1)
  {
    uint64_t v56 = *(void *)(v22 + 40);
    if (!strcmp((const char *)(v56 + 40), v53)) {
      break;
    }
    uint64_t v22 = *(void *)(v22 + 16);
    uint64_t v10 = 3;
    if (!v22) {
      return v10;
    }
  }
  uint64_t v73 = *(void *)(v56 + 16);
  if (v73)
  {
    while (*(void *)(v73 + 72) != v55)
    {
      uint64_t v73 = *(void *)(v73 + 32);
      if (!v73) {
        goto LABEL_107;
      }
    }
    xpc_dictionary_set_string(a3, "name", (const char *)(v73 + 88));
    int v13 = xpc_dictionary_get_int64(a3, "subscriber-pid");
    uint64_t v14 = a3;
    uint64_t v15 = a4;
    return sub_10003D968(v14, v15, v13);
  }
  else
  {
LABEL_107:
    char v72 = *(unsigned char *)(v22 + 56);
LABEL_108:
    BOOL v42 = (v72 & 1) == 0;
    unsigned int v43 = 132;
LABEL_109:
    if (v42) {
      return 3;
    }
    else {
      return v43;
    }
  }
}

void *sub_10003CBBC(uint64_t a1, const void *a2, char a3, int *a4)
{
  int v8 = sub_10002B40C(*(void *)(a1 + 248));
  uint64_t v27 = 0;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x2000000000;
  xpc_object_t v30 = 0;
  xpc_object_t v30 = sub_10003CDA8((uint64_t)v8, a2);
  uint64_t v9 = v28[3];
  if ((a3 & 1) == 0 && !v9)
  {
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000;
    _OWORD v26[2] = sub_10003CE6C;
    v26[3] = &unk_100070D68;
    v26[4] = &v27;
    v26[5] = a2;
    sub_10003CE00((uint64_t)v8, (uint64_t)v26);
    uint64_t v9 = v28[3];
  }
  if (v9)
  {
    uint64_t v25 = sub_1000203FC(*(void *)(v9 + 32), 2);
    sub_10001E4BC(a1, 3, "Event stream %s is already monitored by %s, ignoring", v10, v11, v12, v13, v14, (char)a2);
    free(v25);
    uint64_t v15 = 0;
    if (a4)
    {
      int v16 = 17;
LABEL_14:
      *a4 = v16;
    }
  }
  else if (sub_1000052DC(a1, 5))
  {
    uint64_t v15 = sub_10001A7A8(0);
    uint64_t v22 = sub_10001A828((const char *)a2);
    v15[5] = v22;
    *((void *)v22 + 4) = v15;
    uint64_t v23 = *(void *)(a1 + 144);
    v15[2] = v23;
    if (v23) {
      *(void *)(v23 + 24) = v15 + 2;
    }
    *(void *)(a1 + 144) = v15;
    v15[3] = a1 + 144;
    sub_100045E1C(v8[4], a2, v15);
    _OWORD v15[4] = a1;
    *((unsigned char *)v15 + 56) = v15[7] & 0xF9 | (2 * (a3 & 3));
    sub_10003CEB4((uint64_t)v15, (uint64_t)v8);
    if (a4)
    {
      int v16 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    sub_10001E4BC(a1, 3, "Non-system service tried to claim event stream %s", v17, v18, v19, v20, v21, (char)a2);
    uint64_t v15 = 0;
    if (a4)
    {
      int v16 = 150;
      goto LABEL_14;
    }
  }
  _Block_object_dispose(&v27, 8);
  return v15;
}

rb_tree_t **sub_10003CDA8(uint64_t a1, const void *a2)
{
  uint64_t v3 = a1;
  uint64_t result = sub_100045ED4(*(rb_tree_t ***)(a1 + 32), a2);
  if (!result)
  {
    while (1)
    {
      uint64_t v3 = *(void *)(v3 + 48);
      if (!v3) {
        break;
      }
      uint64_t result = sub_100045ED4(*(rb_tree_t ***)(v3 + 32), a2);
      if (result && ((_BYTE)result[7] & 2) == 0) {
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sub_10003CE00(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 40);
  if (v3)
  {
    uint64_t v4 = result;
    do
    {
      uint64_t v5 = *(void *)(v3 + 16);
      (*(void (**)(uint64_t))(a2 + 16))(a2);
      uint64_t v3 = v5;
    }
    while (v5);
    uint64_t result = *(void *)(v4 + 40);
    if (result)
    {
      do
      {
        uint64_t v6 = *(void *)(result + 16);
        sub_10003CE00();
        uint64_t result = v6;
      }
      while (v6);
    }
  }
  return result;
}

rb_tree_t **sub_10003CE6C(rb_tree_t **result, uint64_t a2)
{
  if (!*((void *)result[4]->opaque[1] + 3))
  {
    uint64_t v2 = result;
    uint64_t result = sub_100045ED4(*(rb_tree_t ***)(a2 + 32), result[5]);
    *((void *)v2[4]->opaque[1] + 3) = result;
  }
  return result;
}

uint64_t sub_10003CEB4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100045ED4(*(rb_tree_t ***)(a2 + 56), (const void *)(*(void *)(a1 + 40) + 40));
  if (v4)
  {
    uint64_t v5 = v4;
    sub_10001A0AC(v4);
    uint64_t v6 = v5[2];
    if (v6)
    {
      do
      {
        uint64_t v7 = (rb_tree_t *)v6->opaque[4];
        if ((*(unsigned char *)(a1 + 56) & 4) != 0 && !sub_1000052DC((uint64_t)v6->opaque[6], 6))
        {
          sub_10001E4BC((uint64_t)v6->opaque[6], 4, "Rejecting untrusted event subscription on stream %s", v8, v9, v10, v11, v12, *(unsigned char *)(a1 + 40) + 40);
          sub_10003D5CC(v6);
          sub_10001A174(v6);
        }
        else
        {
          sub_10003D1B4(v6, 0, 1);
          if ((sub_10003DDA8(v6, a1, 1) & 1) == 0) {
            sub_100050D0C();
          }
        }
        uint64_t v6 = v7;
      }
      while (v7);
    }
    sub_100045E1C(*(void *)(a2 + 56), v5 + 5, 0);
    sub_10001A174(v5);
    return 1;
  }
  else
  {
    if ((*(unsigned char *)(a1 + 56) & 2) != 0) {
      return 0;
    }
    uint64_t v14 = *(void *)(a2 + 40);
    if (!v14)
    {
      return 0;
    }
    else
    {
      do
      {
        uint64_t result = sub_10003CEB4(a1, v14);
        if (result) {
          break;
        }
        uint64_t v14 = *(void *)(v14 + 16);
      }
      while (v14);
    }
  }
  return result;
}

uint64_t sub_10003D00C(uint64_t a1, uint64_t a2)
{
  for (uint64_t result = *(void *)(*(void *)(a1 + 40) + 16); result; uint64_t result = *(void *)(result + 32))
  {
    if (*(void *)(result + 72) == a2) {
      break;
    }
  }
  return result;
}

uint64_t sub_10003D030(uint64_t a1)
{
  return *(void *)(a1 + 40) + 40;
}

uint64_t sub_10003D03C(uint64_t a1)
{
  return *(unsigned char *)(a1 + 56) & 1;
}

void sub_10003D048(uint64_t a1)
{
  uint64_t v2 = sub_10002B40C(*(void *)(*(void *)(a1 + 32) + 248));
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    *(void *)(v3 + 24) = *(void *)(a1 + 24);
  }
  **(void **)(a1 + 24) = v3;
  *(void *)(a1 + 16) = -1;
  *(void *)(a1 + 24) = -1;
  sub_100045E1C(v2[4], (const void *)(*(void *)(a1 + 40) + 40), 0);
  uint64_t v4 = *(void **)(*(void *)(a1 + 40) + 16);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)v4[4];
      uint64_t v6 = sub_10002B40C(*(void *)(v4[6] + 248));
      uint64_t v7 = sub_10003D144((uint64_t)v6, (const void *)(*(void *)(a1 + 40) + 40));
      sub_10003D1B4(v4, 0, 1);
      sub_10003D274(v4, (uint64_t)v7);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  uint64_t v8 = *(void **)(a1 + 48);
  if (v8)
  {
    xpc_dictionary_set_int64(v8, "error", 124);
    if ((xpc_pipe_routine_reply() & 0xFFFFFFDF) != 0) {
      _os_assumes_log();
    }
    xpc_release(*(xpc_object_t *)(a1 + 48));
    *(void *)(a1 + 48) = 0;
  }
}

void *sub_10003D144(uint64_t a1, const void *a2)
{
  uint64_t v4 = sub_100045ED4(*(rb_tree_t ***)(a1 + 56), a2);
  if (!v4)
  {
    uint64_t v4 = sub_10001A828((const char *)a2);
    sub_100045E1C(*(void *)(a1 + 56), a2, v4);
    sub_10001A174(v4);
  }
  return v4;
}

void sub_10003D1B4(void *a1, int a2, int a3)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[8];
  a1[8] = 0;
  a1[9] = 0;
  if (v3) {
    *(void *)(v3 + 40) = a1[5];
  }
  *(void *)a1[5] = v3;
  a1[4] = -1;
  a1[5] = -1;
  --*(_DWORD *)(v4 + 24);
  if (*(void *)(v4 + 32))
  {
    if (a3)
    {
      uint64_t v5 = *(void *)(v4 + 32);
      sub_10003D6A4(v5);
    }
  }
  else if (a2 && !*(void *)(v4 + 16))
  {
    uint64_t v6 = *((void *)sub_10002B40C(*(void *)(a1[6] + 248)) + 7);
    sub_100045E1C(v6, (const void *)(v4 + 40), 0);
  }
}

void sub_10003D274(void *a1, uint64_t a2)
{
  if (*(void *)(a2 + 32)) {
    sub_100050D0C();
  }

  sub_10003DE34(a1, a2);
}

uint64_t sub_10003D2A4(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100046780(a2, a3, "%s => {", a4, a5, a6, a7, a8, a1 + 88);
  if (*(unsigned char *)(a1 + 80)) {
    int v16 = "1";
  }
  else {
    int v16 = "0";
  }
  sub_100046780(a2, a3 + 1, "keepalive = %s", v11, v12, v13, v14, v15, v16);
  sub_100046780(a2, a3 + 1, "service = %s", v17, v18, v19, v20, v21, *(void *)(a1 + 48) + 1392);
  sub_100046780(a2, a3 + 1, "streauint64_t m = %s", v22, v23, v24, v25, v26, *(void *)(a1 + 64) + 40);
  uint64_t v32 = *(void *)(*(void *)(a1 + 64) + 32);
  if (v32) {
    sub_100046780(a2, a3 + 1, "monitor = %s", v27, v28, v29, v30, v31, *(void *)(v32 + 32) + 1392);
  }
  sub_100046710(a2, a3 + 1, "descriptor = ", v27, v28, v29, v30, v31);
  sub_100015F3C(a2, a3 + 1, 0, *(void **)(a1 + 56), v33, v34, v35, v36);

  return sub_100046780(a2, a3, "}", v37, v38, v39, v40, v41);
}

char *sub_10003D3E4(void *a1, const void *a2, const char *a3, void *a4)
{
  return sub_10003D3EC(a1, a2, a3, a4, 1);
}

char *sub_10003D3EC(void *a1, const void *a2, const char *a3, void *a4, int a5)
{
  uint64_t v10 = sub_10002B40C(a1[31]);
  uint64_t v11 = sub_10003CDA8((uint64_t)v10, a2);
  uint64_t v12 = (uint64_t)v11;
  if (v11 && ((_BYTE)v11[7] & 4) != 0 && (sub_1000052DC((uint64_t)a1, 6) & 1) == 0)
  {
    sub_10001E4BC((uint64_t)a1, 4, "Rejecting untrusted event subscription on stream %s", v13, v14, v15, v16, v17, (char)a2);
    return 0;
  }
  uint64_t v18 = (char **)(a1 + 17);
  size_t v19 = strlen(a3);
  uint64_t v20 = (char *)sub_10001A878(v19 + 1);
  strcpy(v20 + 88, a3);
  *((void *)v20 + 6) = a1;
  *((void *)v20 + 7) = xpc_retain(a4);
  v20[80] = v20[80] & 0xFD | (2 * (strcmp((const char *)a2, "com.apple.launchd.helper") == 0));
  uint64_t v21 = a1[17];
  *((void *)v20 + 2) = v21;
  if (v21) {
    *(void *)(v21 + 24) = v20 + 16;
  }
  uint64_t *v18 = v20;
  *((void *)v20 + 3) = v18;
  if (v12)
  {
    if ((sub_10003DDA8(v20, v12, a5) & 1) == 0) {
      sub_100050D0C();
    }
  }
  else
  {
    uint64_t v22 = sub_10003D144((uint64_t)v10, a2);
    sub_10003D274(v20, (uint64_t)v22);
  }
  uint64_t v23 = sub_100030834(a1[31], a1, (const char *)a2);
  int v24 = strcmp((const char *)a2, "com.apple.iokit.matching");
  if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    BOOL v25 = xpc_dictionary_get_BOOL(a4, "IOMatchLaunchStream");
    if (v24)
    {
LABEL_15:
      sub_1000490BC(v23);
      return v20;
    }
  }
  else
  {
    BOOL v25 = 0;
    if (v24) {
      goto LABEL_15;
    }
  }
  if (v25) {
    goto LABEL_15;
  }
  return v20;
}

uint64_t sub_10003D5B4(uint64_t a1)
{
  return *(unsigned char *)(a1 + 80) & 1;
}

uint64_t sub_10003D5C0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 80) >> 1) & 1;
}

void sub_10003D5CC(void *a1)
{
  uint64_t v1 = a1[2];
  if (v1) {
    *(void *)(v1 + 24) = a1[3];
  }
  *(void *)a1[3] = v1;
  a1[2] = -1;
  a1[3] = -1;
  sub_10003D1B4(a1, 1, 1);
}

void *sub_10003D5FC(uint64_t a1)
{
  uint64_t v2 = sub_10001A7E8(0);
  uint64_t v3 = v2;
  if (a1)
  {
    uint64_t v4 = (void *)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 40);
    v2[2] = v5;
    v2[6] = a1;
    if (v5) {
      *(void *)(v5 + 24) = v2 + 2;
    }
    void *v4 = v2;
    v2[3] = v4;
  }
  v2[4] = sub_100045FAC();
  v3[7] = sub_100045FAC();
  v3[8] = 1;
  return v3;
}

rb_tree_t **sub_10003D668(rb_tree_t **result)
{
  if (((_BYTE)result[9] & 1) == 0)
  {
    *((unsigned char *)result + 72) |= 1u;
    return sub_100045F0C((rb_tree_t **)result[4], (uint64_t)&stru_100070DA8);
  }
  return result;
}

void sub_10003D68C(id a1, const char *a2, id a3)
{
  if (*(void *)(*((void *)a3 + 5) + 16)) {
    sub_10003D6A4((uint64_t)a3);
  }
}

uint64_t sub_10003D6A4(uint64_t a1)
{
  *(unsigned char *)(a1 + 56) |= 1u;
  if (*(void *)(a1 + 48))
  {
    if ((xpc_pipe_routine_reply() & 0xFFFFFFDF) != 0) {
      _os_assumes_log();
    }
    xpc_release(*(xpc_object_t *)(a1 + 48));
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v2 = *(void *)(a1 + 32);

  return sub_10002154C(v2);
}

uint64_t sub_10003D710(void *a1, uint64_t a2, int a3, int a4, void *a5)
{
  if (a3)
  {
    uint64_t v9 = (void *)sub_100020E4C(a3);
    if (!v9) {
      return 113;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  char string = (char *)xpc_dictionary_get_string(a1, "stream");
  uint64_t v12 = xpc_dictionary_get_string(a1, "name");
  xpc_object_t value = xpc_dictionary_get_value(a1, "descriptor");
  uint int64 = xpc_dictionary_get_uint64(a1, "token");
  uint64_t result = 22;
  if (string && v12)
  {
    if (value && xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
      return 22;
    }
    if (v9)
    {
      uint64_t v15 = (void *)sub_10003D904((uint64_t)v9, string, v12);
      if (!a2) {
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v15 = 0;
      if (!a2) {
        goto LABEL_20;
      }
    }
    if (!v15 && uint64)
    {
      uint64_t v15 = *(void **)(*(void *)(a2 + 40) + 16);
      if (!v15) {
        goto LABEL_27;
      }
      while (v15[9] != uint64)
      {
        uint64_t v15 = (void *)v15[4];
        if (!v15) {
          goto LABEL_27;
        }
      }
LABEL_21:
      if (value)
      {
        uint64_t v16 = (void *)v15[7];
        if (v16)
        {
          if (xpc_equal(value, v16)) {
            goto LABEL_30;
          }
        }
      }
      sub_100043D78(5, "Remove subscription with token %llu", v15[9]);
      uint64_t v17 = v15[2];
      if (v17) {
        *(void *)(v17 + 24) = v15[3];
      }
      *(void *)v15[3] = v17;
      v15[2] = -1;
      v15[3] = -1;
      sub_10003D1B4(v15, 1, a4);
      sub_10001A174(v15);
LABEL_27:
      if (value) {
        uint64_t v15 = sub_10003D3EC(v9, string, v12, value, a4);
      }
      else {
        uint64_t v15 = 0;
      }
LABEL_30:
      uint64_t result = 0;
      *a5 = v15;
      return result;
    }
LABEL_20:
    if (!v15) {
      goto LABEL_27;
    }
    goto LABEL_21;
  }
  return result;
}

uint64_t sub_10003D904(uint64_t a1, char *__s2, const char *a3)
{
  for (uint64_t i = *(void *)(a1 + 136); i; uint64_t i = *(void *)(i + 16))
  {
    if (!strcmp((const char *)(*(void *)(i + 64) + 40), __s2) && !strcmp((const char *)(i + 88), a3)) {
      break;
    }
  }
  return i;
}

uint64_t sub_10003D968(void *a1, void *a2, int a3)
{
  uint64_t v5 = sub_100020E4C(a3);
  if (!v5) {
    return 113;
  }
  uint64_t v6 = v5;
  if (!xpc_dictionary_expects_reply()) {
    return 22;
  }
  char string = (char *)xpc_dictionary_get_string(a1, "stream");
  uint64_t v8 = xpc_dictionary_get_string(a1, "name");
  if (!string)
  {
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    for (uint64_t i = *(void *)(v6 + 136); i; uint64_t i = *(void *)(i + 16))
    {
      uint64_t v13 = (const char *)(*(void *)(i + 64) + 40);
      xpc_object_t value = xpc_dictionary_get_value(v10, v13);
      if (!value)
      {
        xpc_object_t value = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_value(v10, v13, value);
        xpc_release(value);
      }
      xpc_dictionary_set_value(value, (const char *)(i + 88), *(xpc_object_t *)(i + 56));
    }
    goto LABEL_18;
  }
  if (!v8)
  {
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    for (uint64_t j = *(void *)(v6 + 136); j; uint64_t j = *(void *)(j + 16))
    {
      if (!strcmp((const char *)(*(void *)(j + 64) + 40), string)) {
        xpc_dictionary_set_value(v10, (const char *)(j + 88), *(xpc_object_t *)(j + 56));
      }
    }
    goto LABEL_18;
  }
  uint64_t v9 = sub_10003D904(v6, string, v8);
  if (v9)
  {
    xpc_object_t v10 = xpc_retain(*(xpc_object_t *)(v9 + 56));
LABEL_18:
    xpc_object_t reply = xpc_dictionary_create_reply(a1);
    xpc_dictionary_set_value(reply, "event", v10);
    xpc_release(v10);
    uint64_t result = 0;
    *a2 = reply;
    return result;
  }
  return 3;
}

void sub_10003DB0C(void *a1, uint64_t a2)
{
  xpc_object_t v4 = xpc_array_create(0, 0);
  for (uint64_t i = *(void *)(*(void *)(a2 + 40) + 16); i; uint64_t i = *(void *)(i + 32))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(void *)(i + 72));
    xpc_array_append_value(v4, *(xpc_object_t *)(i + 56));
  }
  xpc_dictionary_set_value(a1, "events", v4);
  xpc_release(v4);
  uint64_t v6 = sub_10002B40C(*(void *)(*(void *)(a2 + 32) + 248));
  xpc_dictionary_set_BOOL(a1, "initial-load-completed", v6[72] & 1);
  *(unsigned char *)(a2 + 56) &= ~1u;
}

uint64_t sub_10003DBC4(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = sub_100020E4C(*(_DWORD *)(a3 + 20));
  if (!v7) {
    return 1;
  }
  uint64_t v8 = v7;
  uint int64 = xpc_dictionary_get_uint64(a1, "token");
  if (!uint64) {
    return 22;
  }
  uint64_t v10 = uint64;
  uint64_t v11 = sub_10002B40C(*(void *)(v8 + 248));
  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x2000000000;
  char v22 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  uint64_t v20 = 0;
  uint64_t v12 = (rb_tree_t **)*((void *)v11 + 4);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = sub_10003DD30;
  v16[3] = &unk_100070E10;
  v16[5] = &v17;
  void v16[6] = v10;
  _OWORD v16[4] = v21;
  sub_100045F0C(v12, (uint64_t)v16);
  uint64_t v13 = v18[3];
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  if (!v13) {
    return 3;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  (*(void (**)(uint64_t, uint64_t, xpc_object_t))(a4 + 16))(a4, v13, reply);
  uint64_t result = 0;
  *a2 = reply;
  return result;
}

void sub_10003DD1C(id a1, _launch_service_s *a2, void *a3)
{
}

void *sub_10003DD30(void *result, uint64_t a2, uint64_t a3)
{
  if (!*(unsigned char *)(*(void *)(result[4] + 8) + 24))
  {
    uint64_t v3 = *(void **)(*(void *)(a3 + 40) + 16);
    if (v3)
    {
      while (v3[9] != result[6])
      {
        uint64_t v3 = (void *)v3[4];
        if (!v3) {
          return result;
        }
      }
      *(void *)(*(void *)(result[5] + 8) + 24) = v3[6];
      *(unsigned char *)(*(void *)(result[4] + 8) + 24) = 1;
    }
  }
  return result;
}

void sub_10003DD90(id a1, _launch_service_s *a2, void *a3)
{
}

uint64_t sub_10003DDA8(void *a1, uint64_t a2, int a3)
{
  if ((*(unsigned char *)(a2 + 56) & 4) == 0 || (uint64_t result = sub_1000052DC(a1[6], 6), result))
  {
    sub_10003DE34(a1, *(void *)(a2 + 40));
    uint64_t v7 = sub_10002B40C(*(void *)(*(void *)(a2 + 32) + 248));
    uint64_t v8 = v7[8];
    a1[9] = v8;
    v7[8] = v8 + 1;
    if (v8 == -1) {
      v7[8] = 1;
    }
    if (a3) {
      sub_10003D6A4(a2);
    }
    return 1;
  }
  return result;
}

void sub_10003DE34(void *a1, uint64_t a2)
{
  if (a1[8]) {
    sub_100050D0C();
  }
  uint64_t v2 = *(void *)(a2 + 16);
  a1[4] = v2;
  a1[8] = a2;
  if (v2) {
    *(void *)(v2 + 40) = a1 + 4;
  }
  *(void *)(a2 + 16) = a1;
  a1[5] = a2 + 16;
  int v3 = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a2 + 24) = v3 + 1;
  if (v3 == 512) {
    sub_100043D78(4, "Accumulated more than %d subscriptions for stream %s", 512, (const char *)(a2 + 40));
  }
}

_DWORD *sub_10003DEB0()
{
  return sub_100047428(8, (uint64_t)sub_10003DEC8);
}

uint64_t sub_10003DEC8(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7 = sub_100047400();
  switch(a2)
  {
    case 902:
      regiounint64_t n = 0;
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      if (!sub_10000FE40((uint64_t)v7, 23)) {
        return 144;
      }
      if (!xpc_dictionary_get_string(a3, "monitor_id")) {
        return 22;
      }
      uint64_t v8 = sub_100003324();
      if (!v8) {
        return 96;
      }
      uint64_t v9 = (_DWORD *)v8;
      xpc_object_t value = xpc_dictionary_get_value(a3, "shmem");
      if (!value) {
        return 22;
      }
      vm_size_t v11 = xpc_shmem_map(value, &region);
      size_t v12 = v11;
      uint64_t v44 = (char *)region;
      if (region && v11 >= vm_page_size)
      {
        unint64_t v13 = v11 / 0x33;
        if (sub_100003008((uint64_t)v9) < (v11 / 0x33)) {
          LODWORD(v13) = sub_100003008((uint64_t)v9);
        }
        int v14 = sub_100003008((uint64_t)v9);
        xpc_object_t v15 = xpc_dictionary_create(0, 0, 0);
        xxpc_object_t array = xpc_array_create(0, 0);
        if (v13)
        {
          size_t v42 = v12;
          uint64_t v16 = 0;
          uint64_t v41 = v13;
          uint64_t v17 = 51 * v13;
          unsigned int v18 = v14 - v13;
          do
          {
            uint64_t v19 = sub_100003010(v9, v18);
            uint64_t v20 = *(const char **)v19;
            xpc_object_t v21 = xpc_dictionary_get_value(v15, *(const char **)v19);
            if (v21)
            {
              unsigned int count = xpc_uint64_get_value(v21);
            }
            else
            {
              unsigned int count = xpc_array_get_count(xarray);
              xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, v20);
              xpc_dictionary_set_uint64(v15, v20, count);
            }
            uint64_t v23 = &v44[v16];
            *(_DWORD *)uint64_t v23 = count;
            *(_OWORD *)(v23 + 4) = *(_OWORD *)(v19 + 8);
            *(void *)(v23 + 20) = *(void *)(v19 + 24);
            v23[28] = *(unsigned char *)(v19 + 32);
            *(void *)(v23 + 29) = *(void *)(v19 + 33);
            *(void *)(v23 + 37) = *(void *)(v19 + 41);
            *(_DWORD *)(v23 + 45) = *(_DWORD *)(v19 + 49);
            *(_WORD *)(v23 + 49) = *(_WORD *)(v19 + 53);
            v16 += 51;
            ++v18;
          }
          while (v17 != v16);
          uint64_t v24 = v41;
          size_t v12 = v42;
        }
        else
        {
          uint64_t v24 = 0;
        }
        xpc_release(v15);
        uint64_t v39 = v9[5];
        sub_100002F54(v9);
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uint64(reply, "count", v24);
        xpc_dictionary_set_uint64(reply, "dropped-count", v39);
        xpc_dictionary_set_value(reply, "labels", xarray);
        xpc_release(xarray);
        uint64_t v25 = 0;
        *a4 = reply;
      }
      else
      {
        if (*__error()) {
          _os_assumes_log();
        }
        uint64_t v25 = 22;
      }
      if (region && v12) {
        munmap(region, v12);
      }
      return v25;
    case 903:
      if (!xpc_dictionary_expects_reply() || !xpc_dictionary_get_string(a3, "monitor_id")) {
        return 22;
      }
      uint64_t v26 = sub_100003324();
      xpc_object_t v27 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_BOOL(v27, "enabled", v26 != 0);
      goto LABEL_47;
    case 904:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      uint64_t v28 = 4294967195;
      xpc_object_t v27 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_BOOL(v27, "enabled", 1);
      uint64_t v29 = sub_100041094();
      if (v29)
      {
        uint64_t v30 = v29;
        if (!sub_100030974(v29, 6, 0, (uint64_t)v7)) {
          uint64_t v28 = *(unsigned int *)(v30 + 56);
        }
      }
      xpc_dictionary_set_uint64(v27, "foreground_uid", v28);
      uint64_t v31 = sub_100020E4C(*((_DWORD *)v7 + 5));
      if (v31)
      {
        uint64_t v32 = *(void *)(v31 + 248);
        if (v32) {
          goto LABEL_28;
        }
LABEL_45:
        uint64_t v34 = 0;
        goto LABEL_46;
      }
      uint64_t v32 = sub_10004740C();
      if (!v32) {
        goto LABEL_45;
      }
LABEL_28:
      unsigned int v33 = *(_DWORD *)(v32 + 60);
      if (v33 == -101) {
        uint64_t v34 = 0;
      }
      else {
        uint64_t v34 = v33;
      }
LABEL_46:
      xpc_dictionary_set_uint64(v27, "session_uid", v34);
LABEL_47:
      uint64_t v25 = 0;
      *a4 = v27;
      return v25;
    case 905:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      if (!sub_10000FE40((uint64_t)v7, 23)) {
        return 144;
      }
      char string = xpc_dictionary_get_string(a3, "monitor_id");
      uint int64 = xpc_dictionary_get_uint64(a3, "capacity");
      uint64_t v25 = 22;
      if (!string || !uint64) {
        return v25;
      }
      uint64_t v37 = sub_100003288(string, uint64);
      goto LABEL_40;
    case 906:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      if (!sub_10000FE40((uint64_t)v7, 23)) {
        return 144;
      }
      if (!xpc_dictionary_get_string(a3, "monitor_id")) {
        return 22;
      }
      uint64_t v37 = sub_1000032EC();
LABEL_40:
      uint64_t v25 = v37;
      if (!v37) {
        *a4 = xpc_dictionary_create_reply(a3);
      }
      return v25;
    default:
      return 33;
  }
}

char *sub_10003E3A4(int a1)
{
  bzero(v4, 0x400uLL);
  if (a1 < 0)
  {
    int v3 = __error();
    uint64_t result = 0;
    *int v3 = 9;
  }
  else
  {
    while (fcntl(a1, 50, v4) == -1)
    {
      if (*__error() != 35) {
        return 0;
      }
    }
    return sub_1000159F0(v4);
  }
  return result;
}

void *sub_10003E464(int a1, uint64_t a2, void *a3, ssize_t *a4)
{
  uint64_t v8 = sub_100013BB8(*(void *)(a2 + 96));
  ssize_t v9 = read(a1, v8, *(void *)(a2 + 96));
  ssize_t v10 = v9;
  if (v9 != *(void *)(a2 + 96))
  {
    if (v9 && (v9 != -1 || *__error())) {
      _os_assumes_log();
    }
    goto LABEL_8;
  }
  vm_size_t v11 = (void *)xpc_create_from_plist();
  size_t v12 = v11;
  if (v11)
  {
    if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_release(v12);
LABEL_8:
      size_t v12 = 0;
      goto LABEL_9;
    }
    if (a3 && a4)
    {
      *a4 = v10;
      *a3 = v8;
      return v12;
    }
  }
LABEL_9:
  free(v8);
  return v12;
}

int *sub_10003E54C(int *result)
{
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = (int *)close((int)result);
    if (result)
    {
      if (*__error()) {
        _os_assumes_log();
      }
      uint64_t result = __error();
      if (*result == 9) {
        sub_100050D0C();
      }
    }
  }
  return result;
}

void *sub_10003E594(const char *a1)
{
  return sub_10003E5A0(a1, 0, 0);
}

void *sub_10003E5A0(const char *a1, void *a2, ssize_t *a3)
{
  if (!a1) {
    return 0;
  }
  uint64_t v5 = (int *)open(a1, 0);
  if (v5 == -1) {
    return 0;
  }
  uint64_t v6 = v5;
  memset(&v10, 0, sizeof(v10));
  int v7 = fstat((int)v5, &v10);
  if (v7 | v10.st_uid || (v10.st_mode & 0x12) != 0) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = sub_10003E464((int)v6, (uint64_t)&v10, a2, a3);
  }
  sub_10003E54C(v6);
  return v8;
}

uint8_t *sub_10003E660(mach_header_64 *a1, const char *a2, const char *a3)
{
  if (!a1) {
    a1 = _NSGetMachExecuteHeader();
  }
  unint64_t size = 0;
  memset(&v7, 0, sizeof(v7));
  if (!dladdr(a1, &v7)) {
    return 0;
  }
  uint64_t result = getsectiondata((const mach_header_64 *)v7.dli_fbase, a2, a3, &size);
  if (result) {
    return (uint8_t *)xpc_create_from_plist();
  }
  return result;
}

int *sub_10003E6D4(FILE *a1)
{
  uint64_t result = (int *)fclose(a1);
  if (result)
  {
    if (*__error()) {
      _os_assumes_log();
    }
    uint64_t result = __error();
    if (*result == 9) {
      sub_100050D0C();
    }
  }
  return result;
}

BOOL sub_10003E718(const char *a1)
{
  memset(&v4, 0, sizeof(v4));
  int v1 = stat(a1, &v4);
  if (v1)
  {
    uint64_t v2 = __error();
    if (v1 == -1 && *v2 != 2) {
      sub_100050E38();
    }
  }
  return v1 == 0;
}

void sub_10003E78C()
{
  uint64_t v8 = 0;
  size_t v9 = 0;
  if (!byte_100076A60 && sub_10003E718("/System/Library/xpc/WorkloadProperties.plist"))
  {
    mach_port_t v0 = sub_10003E65C("/System/Library/xpc/WorkloadProperties.plist", &v8, (ssize_t *)&v9);
    int v1 = v0;
    if (v0 && xpc_get_type(v0) == (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_object_t dictionary = xpc_dictionary_get_dictionary(v1, "SystemCallMasks");
      if (!dictionary
        || (int v3 = dictionary,
            long long v21 = 0u,
            long long v22 = 0u,
            *(_OWORD *)uint64_t v20 = 0u,
            v23[0] = 12,
            sysctlnametomib("kern.syscall_rejection_masks", v20, v23)))
      {
        xpc_release(v1);
        goto LABEL_9;
      }
      uint64_t v16 = 0;
      uint64_t v17 = &v16;
      uint64_t v18 = 0x2000000000;
      int v19 = 0;
      *(void *)&long long applier = _NSConcreteStackBlock;
      *((void *)&applier + 1) = 0x40000000;
      *(_OWORD *)&void v12[8] = *(_OWORD *)v20;
      *(void *)&long long v11 = sub_10003E9A4;
      *((void *)&v11 + 1) = &unk_100070EA0;
      *(void *)size_t v12 = &v16;
      long long v13 = v21;
      long long v14 = v22;
      size_t v15 = v23[0];
      xpc_dictionary_apply(v3, &applier);
      int v4 = *((_DWORD *)v17 + 6);
      _Block_object_dispose(&v16, 8);
      xpc_release(v1);
      if (!v4)
      {
LABEL_9:
        uint64_t v5 = v8;
        size_t v6 = v9;
        long long v11 = 0u;
        *(_OWORD *)size_t v12 = 0u;
        long long applier = 0u;
        *(void *)&v12[16] = 12;
        if (sysctlnametomib("kern.workload_config", (int *)&applier, (size_t *)&v12[16]))
        {
          free(v8);
        }
        else
        {
          int v7 = sysctl((int *)&applier, *(u_int *)&v12[16], 0, 0, v5, v6);
          free(v8);
          if (v7) {
            sub_100040E80("error parsing the workload properties plist in the kernel (%u)", v7);
          }
        }
        return;
      }
    }
    else
    {
      xpc_release(v1);
      int v4 = 109;
    }
    sub_100040E80("error parsing the workload properties plist in launchd (%u)", v4);
  }
}

uint64_t sub_10003E9A4(uint64_t a1, char *__str, void *a3)
{
  __endptr = 0;
  strtol(__str, &__endptr, 10);
  if (*__str && !*__endptr)
  {
    xpc_object_t array = xpc_dictionary_get_array(a3, "SystemCalls");
    if (array)
    {
      uint64_t v18 = array;
      int v19 = (void **)sub_100010724(0x800uLL);
      sub_1000107B4((uint64_t)v19, "%s:", v20, v21, v22, v23, v24, v25, (char)__str);
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = sub_10003EBA8;
      applier[3] = &unk_100070E78;
      applier[4] = *(void *)(a1 + 32);
      void applier[5] = v19;
      xpc_array_apply(v18, applier);
      if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        sub_100010778(v19);
      }
      else
      {
        uint64_t v26 = sub_100010770((const char **)v19);
        sub_100010778(v19);
        size_t v27 = strlen(v26);
        int v28 = sysctl((int *)(a1 + 40), *(_DWORD *)(a1 + 88), 0, 0, v26, v27);
        free(v26);
        if (!v28) {
          return 1;
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v28;
        sub_1000442C4("com.apple.xpc.workload_properties", 65541, "sysctl failed with error (%i)", v29, v30, v31, v32, v33, *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      }
    }
    else
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 109;
      sub_1000442C4("com.apple.xpc.workload_properties", 65541, "invalid syscall mask array type (%i)", v13, v14, v15, v16, v17, *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    }
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 109;
    sub_1000442C4("com.apple.xpc.workload_properties", 65541, "invalid syscall mask key: %s (%i)", v6, v7, v8, v9, v10, (char)__str);
  }
  return 0;
}

BOOL sub_10003EBA8(uint64_t a1, char a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v12 = *(void *)(a1 + 40);
    char string_ptr = xpc_string_get_string_ptr(object);
    sub_1000107B4(v12, " %s", v14, v15, v16, v17, v18, v19, string_ptr);
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 109;
    sub_1000442C4("com.apple.xpc.workload_properties", 65541, "invalid syscall mask value at index: %zu  (%i)", v6, v7, v8, v9, v10, a2);
  }
  return type == (xpc_type_t)&_xpc_type_string;
}

void sub_10003EC6C(uint64_t a1)
{
  int v1 = *(void **)(a1 + 344);
  if (v1)
  {
    if (v1[9]) {
      sub_100050D0C();
    }
    uint64_t v3 = v1[8];
    if (v3)
    {
      do
      {
        uint64_t v4 = *(void *)(v3 + 24);
        sub_10003ED1C(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    uint64_t v5 = (void *)v1[6];
    if (v5)
    {
      xpc_release(v5);
      v1[6] = 0;
    }
    uint64_t v6 = (void *)v1[7];
    if (v6) {
      xpc_release(v6);
    }
    uint64_t v7 = v1[4];
    if (v7) {
      *(void *)(v7 + 40) = v1[5];
    }
    *(void *)v1[5] = v7;
    *(void *)(a1 + 344) = 0;
    free(v1);
  }
}

void sub_10003ED1C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    xpc_release(v2);
    *(void *)(a1 + 16) = 0;
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 8));
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    *(void *)(v3 + 32) = *(void *)(a1 + 32);
  }
  **(void **)(a1 + 32) = v3;

  free((void *)a1);
}

BOOL sub_10003ED80(uint64_t a1, void *a2)
{
  if (!a2) {
    sub_100050D0C();
  }
  xpc_object_t v3 = sub_100043720(a1);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v3;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    char string = xpc_dictionary_get_string(v4, "com.apple.private.xpc.launchd.job-manager");
    BOOL v5 = sub_10003EE04(a2, string);
  }
  else
  {
    BOOL v5 = 0;
  }
  xpc_release(v4);
  return v5;
}

BOOL sub_10003EE04(void *a1, const char *a2)
{
  BOOL v2 = 0;
  if (!a1 || !a2) {
    return v2;
  }
  if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_string)
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(a1)) {
      return 0;
    }
    size_t v7 = 0;
    do
    {
      char string = (char *)xpc_array_get_string(a1, v7);
      BOOL v2 = sub_100015D70(string, a2);
      if (v2) {
        break;
      }
      ++v7;
    }
    while (v7 < xpc_array_get_count(a1));
    return v2;
  }
  char string_ptr = (char *)xpc_string_get_string_ptr(a1);

  return sub_100015D70(string_ptr, a2);
}

unsigned __int8 *sub_10003EEE0(void *a1, _DWORD *a2, char *a3, _DWORD *a4)
{
  memset(v5, 0, sizeof(v5));
  return sub_10003EF20(a1, a2, 1, 0x40200uLL, (uint64_t)v5, a3, a4);
}

unsigned __int8 *sub_10003EF20(void *a1, _DWORD *a2, char a3, unint64_t a4, uint64_t a5, char *a6, _DWORD *a7)
{
  char string = xpc_dictionary_get_string(a1, "Label");
  if (string && sub_100015CAC(string, "com.apple.")) {
    a4 |= 0x80uLL;
  }
  int v19 = 0;
  uint64_t v15 = sub_100030980(a2, a1, a6, a5, a4, &v19);
  uint64_t v16 = v15;
  int v17 = v19;
  if (v19)
  {
    if (v15) {
      sub_100050D0C();
    }
    uint64_t result = 0;
  }
  else
  {
    if (!v15) {
      sub_100050D0C();
    }
    if ((a3 & 1) == 0) {
      sub_100024EC4(v15, 15);
    }
    sub_10002B590(*(void *)(v16 + 248), v16);
    uint64_t result = sub_1000400B0(v16);
  }
  *a7 = v17;
  return result;
}

uint64_t sub_10003F00C(int a1, unsigned __int8 **a2)
{
  uint64_t v3 = sub_100020E4C(a1);
  if (!v3) {
    return 113;
  }
  uint64_t v4 = *(unsigned __int8 **)(v3 + 344);
  if (!v4) {
    uint64_t v4 = sub_10003F054(v3);
  }
  uint64_t result = 0;
  *a2 = v4;
  return result;
}

unsigned __int8 *sub_10003F054(uint64_t a1)
{
  if (*(void *)(a1 + 344)) {
    sub_100050D0C();
  }
  BOOL v2 = sub_1000400B0(a1);
  uint64_t v9 = v2;
  *((_DWORD *)v2 + 3) = *(_DWORD *)(a1 + 364);
  int v10 = *(_DWORD *)(a1 + 352);
  if (v10) {
    sub_10003FEA4((uint64_t)v2, v10, v3, v4, v5, v6, v7, v8);
  }
  *(_DWORD *)(a1 + 352) = 0;
  return v9;
}

_DWORD *sub_10003F0A8()
{
  return sub_100047428(10, (uint64_t)sub_10003F0C0);
}

uint64_t sub_10003F0C0(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7 = sub_100047400();
  if (!sub_10000FE40((uint64_t)v7, 27)) {
    return 144;
  }
  switch(a2)
  {
    case 1000:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      xpc_object_t value = (uint64_t *)xpc_dictionary_get_value(a3, "plist");
      uint64_t v9 = value;
      if (!value) {
        goto LABEL_7;
      }
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
      {
        uint64_t v9 = 0;
LABEL_7:
        uint64_t v10 = 22;
LABEL_140:
        if (v10) {
          return v10;
        }
        LODWORD(v165) = 0;
        if (xpc_dictionary_get_BOOL(a3, "monitor"))
        {
          uint64_t v145 = sub_1000401F8(v9, (int *)&v165);
          uint64_t v146 = v145;
          uint64_t v10 = v165;
          if (v165)
          {
            if (v145) {
              sub_100050D0C();
            }
            goto LABEL_147;
          }
          uint64_t v147 = sub_10003B3E8(a3);
          if (v146) {
            xpc_dictionary_set_mach_recv();
          }
        }
        else
        {
          uint64_t v147 = sub_10003B3E8(a3);
        }
        uint64_t v10 = sub_1000403D4((uint64_t)v9, v147);
        if (!v10) {
          return v10;
        }
LABEL_147:
        uint64_t v148 = *(void *)(*v9 + 248);
        uint64_t v149 = *v9 + 1392;
        xpc_strerror();
        sub_10002A5B8(v148, 3, "Start job failed: service = %s, int error = %d: %s", v150, v151, v152, v153, v154, v149);
        sub_10002B6E0(v148, *v9);
        return v10;
      }
      char string = xpc_dictionary_get_string(v9, "Label");
      LODWORD(v165) = 0;
      uint64_t v130 = (_DWORD *)sub_1000300B8(a3, 0, (int *)&v165);
      int v131 = v165;
      if (v165)
      {
        uint64_t v132 = (const char *)xpc_strerror();
        sub_100043D78(3, "Submit job failed. Unable to find domain. Service = %s, int error = %d: %s", string, v131, v132);
        unsigned int v133 = v165;
        if (!v165) {
          sub_100050CF0();
        }
        goto LABEL_138;
      }
      uint64_t v138 = (uint64_t)v130;
      uint64_t v139 = sub_100040530(v9, v130, 0, (uint64_t)v7, (int *)&v165);
      uint64_t v9 = (uint64_t *)v139;
      if (!v165)
      {
        if (!v139) {
          sub_100050CD4();
        }
        unsigned int v133 = 0;
        goto LABEL_139;
      }
      if (v139) {
        sub_100050D0C();
      }
      xpc_strerror();
      sub_10002A5B8(v138, 3, "Submit job failed: service = %s, int error = %d: %s", v140, v141, v142, v143, v144, (char)string);
      unsigned int v133 = v165;
      if (v165)
      {
LABEL_138:
        uint64_t v9 = 0;
LABEL_139:
        uint64_t v10 = v133;
        goto LABEL_140;
      }
      goto LABEL_171;
    case 1001:
      LODWORD(v165) = 0;
      uint64_t v76 = (uint64_t *)sub_100040694(a3, (int *)&v165);
      if (!v76) {
        return v165;
      }
      uint64_t v77 = v76;
      uint64_t v78 = sub_1000401F8(v76, (int *)&v165);
      uint64_t v10 = v165;
      if (!v165)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_mach_recv();
        sub_10004071C((uint64_t)v77, reply, 0);
        goto LABEL_119;
      }
      if (v78) {
        sub_100050D0C();
      }
      uint64_t v79 = *v77;
      xpc_strerror();
      sub_10001E4BC(v79, 3, "Could not monitor job: int error = %d: %s", v80, v81, v82, v83, v84, v10);
      return v165;
    case 1002:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      LODWORD(v165) = 0;
      uint64_t v28 = sub_100040694(a3, (int *)&v165);
      if (!v28) {
        return v165;
      }
      uint64_t v29 = (uint64_t *)v28;
      mach_port_name_t v30 = xpc_dictionary_copy_mach_send();
      if (!v30) {
        return 22;
      }
      for (uint64_t i = v29[8]; i; uint64_t i = *(void *)(i + 24))
      {
        if (*(_DWORD *)i == v30) {
          break;
        }
      }
      if (sub_10000D678(v30)) {
        sub_100050D28();
      }
      if (i)
      {
        if (*(void *)(i + 16))
        {
          uint64_t v37 = *v29;
          uint64_t v38 = "job is already monitored";
          int v39 = 5;
          goto LABEL_123;
        }
        char v135 = *(unsigned char *)(i + 40);
        xpc_object_t v136 = xpc_dictionary_create_reply(a3);
        xpc_object_t v137 = v136;
        if (v135)
        {
          sub_10004071C((uint64_t)v29, v136, 0);
          uint64_t v10 = 0;
          *a4 = v137;
          *(unsigned char *)(i + 40) &= ~1u;
        }
        else
        {
          uint64_t v10 = 0;
          *(void *)(i + 16) = v136;
        }
      }
      else
      {
        sub_10001E4BC(*v29, 5, "job is not monitored, can't poll", v32, v33, v34, v35, v36, v162);
        return 3;
      }
      return v10;
    case 1003:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      unsigned int v164 = 0;
      uint64_t v40 = (uint64_t *)sub_100040694(a3, (int *)&v164);
      if (!v40) {
        return v164;
      }
      uint64_t v41 = *v40;
      size_t v42 = (void *)v40[6];
      if (v42 && sub_10003ED80((uint64_t)v7, v42))
      {
        long long v167 = 0u;
        long long v168 = 0u;
        long long v165 = 0u;
        long long v166 = 0u;
        char v43 = sub_100042920((uint64_t)v7, (char *)&v165);
        sub_10001E4BC(v41, 5, "removing job: caller = %s", v44, v45, v46, v47, v48, v43);
        unsigned int v49 = sub_10002B6E0(*(void *)(v41 + 248), v41);
        unsigned int v164 = v49;
        if (v49 == 36) {
          return v164;
        }
        char v50 = v49;
        if (!v49)
        {
          *a4 = xpc_dictionary_create_reply(a3);
          return v164;
        }
      }
      else
      {
        char v50 = -112;
        unsigned int v164 = 144;
      }
      xpc_strerror();
      sub_10001E4BC(v41, 3, "Could not remove job: int error = %d: %s", v121, v122, v123, v124, v125, v50);
      return v164;
    case 1004:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      uint64_t v51 = xpc_dictionary_get_string(a3, "manager");
      if (!v51) {
        return 22;
      }
      uint64_t v52 = v51;
      xpc_object_t v53 = xpc_array_create(0, 0);
      for (uint64_t j = qword_1000765F0; j; uint64_t j = *(void *)(j + 32))
      {
        if (sub_10003EE04(*(void **)(j + 48), v52)) {
          xpc_array_set_uuid(v53, 0xFFFFFFFFFFFFFFFFLL, (const unsigned __int8 *)(j + 16));
        }
      }
      xpc_object_t v55 = xpc_dictionary_create_reply(a3);
      xpc_object_t reply = v55;
      xpc_object_t v57 = "handles";
      goto LABEL_116;
    case 1005:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      uint64_t v85 = xpc_dictionary_get_string(a3, "label");
      if (!v85) {
        return 22;
      }
      char v86 = (char *)v85;
      LODWORD(v165) = 0;
      uint64_t v87 = (_DWORD *)sub_1000300B8(a3, 0, (int *)&v165);
      uint64_t v10 = v165;
      if (v165) {
        return v10;
      }
      uint64_t v88 = (uint64_t)v87;
      uint64_t v73 = (uint64_t)sub_10002E140(v87, v86);
      if (v73) {
        goto LABEL_78;
      }
      sub_10002A5B8(v88, 3, "Could not find job with label %s", v89, v90, v91, v92, v93, (char)v86);
      return 113;
    case 1006:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      LODWORD(v165) = 0;
      uint64_t v96 = sub_100040694(a3, (int *)&v165);
      if (!v96) {
        return v165;
      }
      uint64_t v97 = v96;
      if (*(_DWORD *)(v96 + 8) == 1)
      {
        xpc_object_t v98 = xpc_dictionary_create_reply(a3);
        sub_10004071C(v97, v98, 0);
        LODWORD(v165) = xpc_pipe_routine_reply();
        if ((v165 | 0x20) != 0x20) {
          _os_assumes_log_ctx();
        }
        xpc_release(v98);
      }
      else
      {
        if (*(void *)(v96 + 72))
        {
          uint64_t v37 = *(void *)v96;
          uint64_t v38 = "Start job failed: another start request is already inflight";
          int v39 = 3;
LABEL_123:
          sub_10001E4BC(v37, v39, v38, v32, v33, v34, v35, v36, v162);
          return 37;
        }
        uint64_t v134 = sub_10003B3E8(a3);
        sub_1000403D4(v97, v134);
      }
      return 0;
    case 1007:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      xpc_object_t v99 = xpc_dictionary_get_value(a3, "overlay");
      uint64_t v100 = v99;
      if (v99)
      {
        if (xpc_get_type(v99) != (xpc_type_t)&_xpc_type_dictionary) {
          return 22;
        }
      }
      uint64_t v101 = xpc_dictionary_get_string(a3, "path");
      if (!v101) {
        return 22;
      }
      uint64_t v102 = v101;
      unsigned int v164 = 0;
      uint64_t v103 = sub_1000300B8(a3, 0, (int *)&v164);
      uint64_t v10 = v164;
      if (!v164)
      {
        uint64_t v104 = (void *)v103;
        uint64_t v105 = sub_1000159F0(v102);
        xpc_object_t v106 = xpc_dictionary_create_reply(a3);
        *(void *)&long long v165 = _NSConcreteStackBlock;
        *((void *)&v165 + 1) = 0x40000000;
        *(void *)&long long v166 = sub_100040934;
        *((void *)&v166 + 1) = &unk_100070F00;
        *(void *)&long long v167 = v106;
        *((void *)&v167 + 1) = v104;
        *(void *)&long long v168 = v105;
        sub_100017C08(v104, v102, v100, v7, (uint64_t)&v165);
      }
      return v10;
    case 1008:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      int int64 = xpc_dictionary_get_int64(a3, "pid");
      if (int64 < 1) {
        return 22;
      }
      *(void *)&long long v165 = 0;
      uint64_t v10 = sub_10003F00C(int64, (unsigned __int8 **)&v165);
      if (!v10)
      {
        xpc_object_t reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uuid(reply, "job-handle", (const unsigned __int8 *)(v165 + 16));
        goto LABEL_119;
      }
      if ((void)v165) {
        sub_100050D0C();
      }
      return v10;
    case 1009:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      LODWORD(v165) = 0;
      uint64_t v58 = sub_100040694(a3, (int *)&v165);
      if (!v58) {
        return v165;
      }
      uint64_t v59 = (uint64_t *)v58;
      xpc_object_t v60 = *(void **)(v58 + 48);
      char v61 = v60 && *(void *)(v58 + 56) && sub_10003ED80((uint64_t)v7, v60);
      uint64_t v126 = *v59;
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_object_t v53 = sub_100022470(v126, v61);
      xpc_object_t v57 = "attrs";
      xpc_object_t v55 = reply;
LABEL_116:
      xpc_dictionary_set_value(v55, v57, v53);
      uint64_t v127 = v53;
      goto LABEL_117;
    case 1010:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      unsigned int v164 = 0;
      uint64_t v108 = sub_100040694(a3, (int *)&v164);
      if (!v108) {
        return v164;
      }
      uint64_t v109 = (uint64_t *)v108;
      uuid = (unsigned __int8 *)xpc_dictionary_get_uuid(a3, "instance-uuid");
      *(void *)&long long v165 = 0;
      *((void *)&v165 + 1) = xpc_dictionary_get_string(a3, "sandbox-profile");
      *(void *)&long long v166 = xpc_dictionary_get_dictionary(a3, "envvars");
      uint64_t v111 = *v109;
      uint64_t v112 = sub_10002B8BC(*(void *)(*v109 + 248), *v109, uuid, 1, (uint64_t *)&v165, v7, (int *)&v164);
      if (v112)
      {
        uint64_t v113 = (uint64_t)v112;
        if (sub_100024EE0(v111)) {
          sub_100024EC4(v113, 15);
        }
        uint64_t v95 = (uint64_t)sub_1000400B0(v113);
        if (v95) {
          goto LABEL_106;
        }
      }
      uint64_t v114 = *v109;
      char v115 = v164;
      xpc_strerror();
      sub_10001E4BC(v114, 4, "instance creation failed: %d %s", v116, v117, v118, v119, v120, v115);
      return v164;
    case 1011:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      xpc_object_t v62 = xpc_dictionary_create_reply(a3);
      int v63 = sub_100040A34((uint64_t)v7, a3, v62);
      if (v63) {
        xpc_dictionary_set_int64(v62, "error", v63);
      }
      uint64_t v10 = 0;
      *a4 = v62;
      return v10;
    case 1012:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      xpc_object_t v64 = xpc_dictionary_get_value(a3, "endpoint");
      if (!v64 || xpc_get_type(v64) != (xpc_type_t)&_xpc_type_mach_send) {
        return 22;
      }
      uint64_t right = xpc_mach_send_get_right();
      if ((right - 1) > 0xFFFFFFFD) {
        return 113;
      }
      char v72 = sub_10002FF04(right, 1, v66, v67, v68, v69, v70, v71);
      if (!v72) {
        return 113;
      }
      uint64_t v73 = sub_1000494DC((uint64_t)v72);
LABEL_78:
      uint64_t v94 = *(void *)(v73 + 344);
      if (!v94)
      {
        uint64_t v95 = (uint64_t)sub_10003F054(v73);
LABEL_106:
        uint64_t v94 = v95;
      }
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_uuid(reply, "job-handle", (const unsigned __int8 *)(v94 + 16));
      goto LABEL_118;
    case 1013:
      LODWORD(v165) = 0;
      uint64_t v95 = sub_100040694(a3, (int *)&v165);
      if (v95) {
        goto LABEL_106;
      }
      return v165;
    case 1014:
      if (!xpc_dictionary_expects_reply()) {
        return 22;
      }
      xpc_object_t array = xpc_dictionary_get_array(a3, "all-jobs");
      if (!array) {
        return 22;
      }
      uint64_t v12 = array;
      if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array) {
        return 22;
      }
      size_t count = xpc_array_get_count(v12);
      if (count >> 61)
      {
        __break(1u);
LABEL_171:
        sub_100050CF0();
      }
      uint64_t v14 = sub_100013BB8(8 * count);
      if (!xpc_array_get_count(v12))
      {
        xpc_array_get_count(v12);
        size_t v16 = 0;
        goto LABEL_150;
      }
      size_t v15 = 0;
      size_t v16 = 0;
      break;
    case 1015:
      LODWORD(v165) = 0;
      uint64_t v74 = sub_100040694(a3, (int *)&v165);
      if (!v74) {
        return v165;
      }
      uint64_t v75 = v74;
      xpc_object_t reply = xpc_dictionary_create_reply(a3);
      sub_10004071C(v75, reply, 1);
      goto LABEL_118;
    default:
      return 33;
  }
  do
  {
    xpc_object_t v17 = xpc_array_get_value(v12, v15);
    LODWORD(v165) = 0;
    uint64_t v18 = sub_1000300B8(v17, 0, (int *)&v165);
    uint64_t v10 = v165;
    if (v165)
    {
      free(v14);
      return v10;
    }
    if (v16)
    {
      if (*v14 == v18) {
        goto LABEL_23;
      }
      uint64_t v19 = 1;
      while (v16 != v19)
      {
        uint64_t v20 = v14[v19++];
        if (v20 == v18)
        {
          if (v19 - 1 < v16) {
            goto LABEL_23;
          }
          break;
        }
      }
    }
    v14[v16++] = v18;
LABEL_23:
    ++v15;
  }
  while (v15 < xpc_array_get_count(v12));
  if (v16 > xpc_array_get_count(v12)) {
    sub_100050D0C();
  }
  if (v16)
  {
    for (uint64_t k = 0; k != v16; ++k)
      sub_10002B104(v14[k], 47, v21, v22, v23, v24, v25, v26, v162);
    char v163 = 0;
    goto LABEL_151;
  }
LABEL_150:
  char v163 = 1;
LABEL_151:
  xpc_object_t empty = xpc_array_create_empty();
  if (xpc_array_get_count(v12))
  {
    size_t v156 = 0;
    do
    {
      xpc_object_t v157 = xpc_array_get_value(v12, v156);
      xpc_object_t v158 = xpc_dictionary_create_empty();
      int v159 = sub_100040A34((uint64_t)v7, v157, v158);
      if (v159) {
        xpc_dictionary_set_int64(v158, "error", v159);
      }
      xpc_array_set_value(empty, 0xFFFFFFFFFFFFFFFFLL, v158);
      xpc_release(v158);
      ++v156;
    }
    while (v156 < xpc_array_get_count(v12));
  }
  if ((v163 & 1) == 0)
  {
    uint64_t v160 = v14;
    do
    {
      uint64_t v161 = *v160++;
      sub_10002B1A4(v161, 47);
      --v16;
    }
    while (v16);
  }
  free(v14);
  xpc_object_t reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "results", empty);
  uint64_t v127 = empty;
LABEL_117:
  xpc_release(v127);
LABEL_118:
  uint64_t v10 = 0;
LABEL_119:
  *a4 = reply;
  return v10;
}

void sub_10003FDB4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 344);
  if (v9)
  {
    if (a2 == 9)
    {
      sub_10003FEA4(v9, 4, a3, a4, a5, a6, a7, a8);
      sub_10003EC6C(a1);
    }
    else
    {
      if (a2 == 5)
      {
        if (*(_DWORD *)(v9 + 8) != 1) {
          return;
        }
        int v10 = 3;
      }
      else
      {
        if (a2 != 4) {
          return;
        }
        if (a3)
        {
          *(_DWORD *)(v9 + 12) = a3;
          int v10 = 2;
        }
        else
        {
          int v10 = 1;
        }
      }
      sub_10003FEA4(v9, v10, a3, a4, a5, a6, a7, a8);
    }
  }
  else
  {
    switch(a2)
    {
      case 9:
        int v11 = 4;
        break;
      case 5:
        if (*(_DWORD *)(a1 + 352) != 1) {
          return;
        }
        int v11 = 3;
        break;
      case 4:
        if (a3) {
          int v11 = 2;
        }
        else {
          int v11 = 1;
        }
        break;
      default:
        return;
    }
    *(_DWORD *)(a1 + 352) = v11;
  }
}

void sub_10003FEA4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    sub_100050D0C();
  }
  *(_DWORD *)(a1 + 8) = a2;
  uint64_t v9 = *(void *)a1;
  int v10 = *(char **)(v9 + 344);
  if (v10)
  {
    uint64_t v11 = *((int *)v10 + 2);
    if (v11 > 4) {
      LOBYTE(v10) = 0;
    }
    else {
      int v10 = (&off_100070F20)[v11];
    }
  }
  sub_10001E4BC(v9, 5, "job state = %s", a4, a5, a6, a7, a8, (char)v10);
  uint64_t v12 = *(void **)(a1 + 72);
  if (v12)
  {
    sub_10004071C(a1, *(xpc_object_t *)(a1 + 72), 0);
    xpc_dictionary_set_uuid(v12, "job-handle", (const unsigned __int8 *)(a1 + 16));
    if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
      _os_assumes_log_ctx();
    }
    xpc_release(*(xpc_object_t *)(a1 + 72));
    *(void *)(a1 + 72) = 0;
  }
  for (uint64_t i = *(void *)(a1 + 64); i; uint64_t i = *(void *)(i + 24))
  {
    *(unsigned char *)(i + 40) |= 1u;
    if (*(void *)(i + 16))
    {
      sub_10004071C(a1, *(xpc_object_t *)(i + 16), 0);
      if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
        _os_assumes_log_ctx();
      }
      xpc_release(*(xpc_object_t *)(i + 16));
      *(void *)(i + 16) = 0;
      *(unsigned char *)(i + 40) &= ~1u;
    }
  }
}

uint64_t sub_100040010(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 344);
  if (v1) {
    return *(void *)(v1 + 72);
  }
  else {
    return 0;
  }
}

uint64_t sub_100040028(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_array)
  {
    uint64_t result = (uint64_t)xpc_get_type(object);
    if ((_UNKNOWN *)result != &_xpc_type_string) {
      return result;
    }
    goto LABEL_6;
  }
  uint64_t result = xpc_array_get_count(object);
  if (result)
  {
    uint64_t result = sub_100015E70(object);
    if (result)
    {
LABEL_6:
      uint64_t v5 = sub_1000400B0(a1);
      uint64_t result = (uint64_t)xpc_retain(object);
      *((void *)v5 + 6) = result;
    }
  }
  return result;
}

unsigned __int8 *sub_1000400B0(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 **)(a1 + 344);
  if (!v1)
  {
    uint64_t v1 = (unsigned __int8 *)sub_100013BB8(0x50uLL);
    *(void *)(a1 + 344) = v1;
    *(void *)uint64_t v1 = a1;
    uuid_generate(v1 + 16);
    uint64_t v3 = qword_1000765F0;
    *((void *)v1 + 4) = qword_1000765F0;
    if (v3) {
      *(void *)(v3 + 40) = v1 + 32;
    }
    qword_1000765F0 = (uint64_t)v1;
    *((void *)v1 + 5) = &qword_1000765F0;
  }
  return v1;
}

uint64_t sub_10004011C(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 344);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 48);
    if (v3) {
      return sub_100040028(a2, v3);
    }
  }
  return result;
}

uint64_t sub_10004013C(uint64_t a1, xpc_object_t object)
{
  uint64_t result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_array)
  {
    uint64_t result = xpc_array_get_count(object);
    if (result)
    {
      uint64_t result = sub_100015E70(object);
      if (result)
      {
        uint64_t v5 = sub_1000400B0(a1);
        uint64_t result = (uint64_t)xpc_retain(object);
        *((void *)v5 + 7) = result;
      }
    }
  }
  return result;
}

uint64_t sub_1000401AC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 344);
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 56);
    if (v3) {
      return sub_10004013C(a2, v3);
    }
  }
  return result;
}

char *sub_1000401CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 344);
  if (v1 && (uint64_t v2 = *(int *)(v1 + 8), v2 <= 4)) {
    return (&off_100070F20)[v2];
  }
  else {
    return 0;
  }
}

void *sub_1000401F8(uint64_t *a1, int *a2)
{
  mach_port_name_t v4 = sub_10000D56C(0x12u, 1u, 0);
  if (!v4)
  {
LABEL_11:
    uint64_t v15 = *a1;
    int v14 = 12;
    xpc_strerror();
    sub_10001E4BC(v15, 3, "Failed to create a job monitor. int error = %d: %s", v16, v17, v18, v19, v20, 12);
    uint64_t v7 = 0;
    goto LABEL_12;
  }
  mach_port_name_t v5 = v4;
  mach_port_t poly = 0;
  int v6 = sub_10000D61C(v4, &poly);
  if (v6 || !poly)
  {
    if (!v6) {
      _os_assumes_log();
    }
    if (sub_10000D68C(v5, 0, 0)) {
      sub_100050D28();
    }
    goto LABEL_11;
  }
  uint64_t v7 = sub_100013BB8(0x30uLL);
  *(_DWORD *)uint64_t v7 = v5;
  uint64_t reply_with_port = _xpc_dictionary_create_reply_with_port();
  v7[2] = reply_with_port;
  if (!reply_with_port) {
    sub_100050D0C();
  }
  uint64_t v11 = a1[8];
  int v10 = a1 + 8;
  uint64_t v9 = v11;
  void v7[3] = v11;
  if (v11) {
    *(void *)(v9 + 32) = v7 + 3;
  }
  *int v10 = v7;
  v7[4] = v10;
  uint64_t v12 = sub_100014B58();
  uint64_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v5, 1uLL, v12);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_100040644;
  handler[3] = &unk_100070EC0;
  handler[4] = v7;
  dispatch_source_set_event_handler(v13, handler);
  dispatch_source_set_mandatory_cancel_handler();
  dispatch_activate(v13);
  int v14 = 0;
  v7[1] = v13;
LABEL_12:
  *a2 = v14;
  return v7;
}

uint64_t sub_1000403D4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 72)) {
    sub_100050D0C();
  }
  if (*(_DWORD *)(a1 + 8) == 1) {
    sub_100050D0C();
  }
  uint64_t v3 = *(void **)a1;
  *(void *)(a1 + 72) = a2;
  sub_10001A0AC(v3);
  uint64_t v4 = *(void *)a1;
  if (sub_100005DD8(*(void *)a1))
  {
    uint64_t v5 = 137;
  }
  else
  {
    uint64_t v6 = sub_1000215D4(v4, 15);
    if (v6 == 36) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    if (!v7)
    {
      uint64_t v5 = v7;
      goto LABEL_18;
    }
    uint64_t v5 = v6;
    if (v7 == 37)
    {
      if (sub_1000221B4(*(void *)a1))
      {
        uint64_t v5 = 0;
        goto LABEL_18;
      }
      uint64_t v5 = 37;
    }
  }
  if (*(void *)(a1 + 72))
  {
    xpc_strerror();
    sub_10001E4BC((uint64_t)v3, 3, "Start job failed: int error = %d: %s", v8, v9, v10, v11, v12, v5);
    uint64_t v13 = *(void **)(a1 + 72);
    xpc_dictionary_set_int64(v13, "error", (int)v5);
    if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
      _os_assumes_log_ctx();
    }
    *(void *)(a1 + 72) = 0;
    xpc_release(v13);
  }
LABEL_18:
  sub_10001A174(v3);
  return v5;
}

unsigned __int8 *sub_100040530(void *a1, _DWORD *a2, char a3, uint64_t a4, int *a5)
{
  uint64_t result = (unsigned __int8 *)xpc_dictionary_get_value(a1, "_ManagedBy");
  if (result)
  {
    if (sub_10003ED80(a4, result))
    {
      memset(v21, 0, sizeof(v21));
      uint64_t v11 = sub_100042920(a4, (char *)v21);
      long long v19 = 0u;
      long long v20 = 0u;
      long long v17 = 0u;
      long long v18 = 0u;
      long long v15 = 0u;
      long long v16 = 0u;
      *(_OWORD *)__str = 0u;
      long long v14 = 0u;
      snprintf(__str, 0x80uLL, "(submitted by %s.%d)", v11, *(_DWORD *)(a4 + 20));
      return sub_10003EF20(a1, a2, a3, 0x200uLL, a4, __str, a5);
    }
    uint64_t result = 0;
    int v12 = 144;
  }
  else
  {
    int v12 = 109;
  }
  *a5 = v12;
  return result;
}

void sub_100040644(uint64_t a1)
{
}

void sub_10004064C(uint64_t a1)
{
  mach_port_name_t handle = dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  if (sub_10000D678(handle)) {
    sub_100050D28();
  }
  uint64_t v3 = *(NSObject **)(a1 + 32);

  dispatch_release(v3);
}

uint64_t sub_100040694(void *a1, int *a2)
{
  if (!a2) {
    sub_100050D0C();
  }
  uuid = xpc_dictionary_get_uuid(a1, "job-handle");
  if (uuid)
  {
    uint64_t v4 = qword_1000765F0;
    if (qword_1000765F0)
    {
      uint64_t v5 = uuid;
      while (uuid_compare((const unsigned __int8 *)(v4 + 16), v5))
      {
        uint64_t v4 = *(void *)(v4 + 32);
        if (!v4) {
          goto LABEL_7;
        }
      }
      int v6 = 0;
    }
    else
    {
LABEL_7:
      int v6 = 3;
    }
  }
  else
  {
    uint64_t v4 = 0;
    int v6 = 22;
  }
  *a2 = v6;
  return v4;
}

void sub_10004071C(uint64_t a1, xpc_object_t xdict, char a3)
{
  uint64_t v6 = *(void *)a1;
  xpc_dictionary_set_uint64(xdict, "job-state", *(unsigned int *)(a1 + 8));
  uint64_t v7 = *(void **)(v6 + 640);
  if (v7) {
    xpc_dictionary_set_value(xdict, "additional-properties", v7);
  }
  xpc_dictionary_set_BOOL(xdict, "removing", (*(_DWORD *)(v6 + 368) & 0x10) != 0);
  if (sub_100020E0C(v6))
  {
    uint64_t v8 = (const unsigned __int8 *)sub_10002296C(v6);
    xpc_dictionary_set_uuid(xdict, "instance", v8);
  }
  switch(*(_DWORD *)(a1 + 8))
  {
    case 1:
      int v9 = sub_1000221B4(v6);
      xpc_dictionary_set_int64(xdict, "pid", v9);
      if (a3) {
        goto LABEL_10;
      }
      break;
    case 2:
      int64_t v10 = *(int *)(a1 + 12);
      uint64_t v11 = "spawn-error";
      xpc_object_t v12 = xdict;
      goto LABEL_16;
    case 3:
      xpc_dictionary_set_int64(xdict, "wait4-status", 0);
      xpc_dictionary_set_uint64(xdict, "os-reason-ns", 7uLL);
      xpc_dictionary_set_uint64(xdict, "os-reason-code", 5uLL);
      xpc_dictionary_set_uint64(xdict, "os-reason-flags", 0);
LABEL_10:
      uint64_t v13 = sub_1000229A8(v6);
      if (sub_100046FA0((_DWORD *)v13))
      {
        xpc_dictionary_set_int64(xdict, "wait4-status", *(int *)(v13 + 28));
        xpc_dictionary_set_uint64(xdict, "os-reason-ns", *(unsigned int *)(v13 + 4));
        xpc_dictionary_set_uint64(xdict, "os-reason-code", *(void *)(v13 + 8));
        uint64_t v14 = *(void *)(v13 + 16);
        xpc_dictionary_set_uint64(xdict, "os-reason-flags", v14);
      }
      break;
    case 4:
      uint64_t v11 = "error";
      xpc_object_t v12 = xdict;
      int64_t v10 = 113;
LABEL_16:
      xpc_dictionary_set_int64(v12, v11, v10);
      break;
    default:
      return;
  }
}

void sub_100040934(uint64_t a1, uint64_t a2, int a3)
{
  if (a2)
  {
    uint64_t v5 = sub_1000400B0(a2);
    xpc_dictionary_set_uuid(*(xpc_object_t *)(a1 + 32), "job-handle", v5 + 16);
    sub_100024EC4(a2, 15);
  }
  else
  {
    if (!a3) {
      sub_100050D0C();
    }
    xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "error", a3);
    uint64_t v6 = *(void *)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    xpc_strerror();
    sub_10002A5B8(v6, 4, "Could not submit extension %s: %d - %s", v8, v9, v10, v11, v12, v7);
  }
  if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  xpc_release(*(xpc_object_t *)(a1 + 32));
  uint64_t v13 = *(void **)(a1 + 48);

  free(v13);
}

uint64_t sub_100040A34(uint64_t a1, xpc_object_t object, void *a3)
{
  if (!object) {
    return 22;
  }
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    return 22;
  }
  xpc_object_t value = xpc_dictionary_get_value(object, "plist");
  if (!value) {
    return 22;
  }
  uint64_t v8 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 22;
  }
  char string = xpc_dictionary_get_string(v8, "Label");
  unsigned int v25 = 0;
  uint64_t v10 = (_DWORD *)sub_1000300B8(object, 0, (int *)&v25);
  uint64_t result = v25;
  if (!v25)
  {
    uint64_t v11 = sub_100040530(v8, v10, 1, a1, (int *)&v25);
    uint64_t v12 = v11;
    if (v25)
    {
      if (v11) {
        sub_100050D0C();
      }
LABEL_10:
      xpc_strerror();
      sub_10002A5B8((uint64_t)v10, 3, "Submit job failed: service = %s, int error = %d: %s", v13, v14, v15, v16, v17, string);
      if (v12) {
        sub_10002B6E0(v10, *(void *)v12);
      }
      return v25;
    }
    if (xpc_dictionary_get_BOOL(object, "monitor"))
    {
      long long v18 = sub_1000401F8((uint64_t *)v12, (int *)&v25);
      long long v19 = v18;
      if (v25)
      {
        if (v18) {
          sub_100050D0C();
        }
        goto LABEL_10;
      }
      xpc_dictionary_set_uuid(a3, "job-handle", v12 + 16);
      if (v19) {
        xpc_dictionary_set_mach_recv();
      }
    }
    else
    {
      xpc_dictionary_set_uuid(a3, "job-handle", v12 + 16);
    }
    sub_10002A5B8((uint64_t)v10, 5, "Submit job succeeded: service = %s", v20, v21, v22, v23, v24, string);
    return 0;
  }
  return result;
}

BOOL sub_100040BEC(const char *a1)
{
  uint64_t v7 = 0;
  if (sub_100042A54("kern.bootobjectspath", (char **)&v7)) {
    BOOL v2 = v7 == 0;
  }
  else {
    BOOL v2 = 1;
  }
  if (v2)
  {
    sub_100043D78(65540, "Unable to get boot-object-path. Giving up");
    return 0;
  }
  else
  {
    uint64_t v4 = sub_100015BE4("%s/%s/%s", a1, (const char *)v7, ".roots-installed");
    BOOL v5 = sub_10003E718(v4);
    BOOL v3 = v5;
    if (v5) {
      sub_100043D78(65541, "Found cookie: %s");
    }
    else {
      sub_100043D78(65541, "No cookie: %s");
    }
    free(v7);
    free(v4);
  }
  return v3;
}

uint64_t sub_100040CC4(const char *a1)
{
  BOOL v2 = sub_100015BE4("%s/%s", a1, ".DarwinDepot");
  if (sub_10003E718(v2) || (free(v2), BOOL v2 = sub_100015BE4("%s/%s", a1, ".roots-installed"), sub_10003E718(v2)))
  {
    sub_100043D78(65541, "Found cookie: %s", v2);
    uint64_t v3 = 1;
  }
  else
  {
    sub_100043D78(65541, "No cookie from system volume");
    uint64_t v3 = 0;
  }
  free(v2);
  return v3;
}

uint64_t sub_100040D80(uint64_t result)
{
  if (result)
  {
    mach_port_t port = 0;
    mach_port_t v1 = mach_host_self();
    if (host_get_special_port(v1, -1, 3, &port))
    {
      _os_assumes_log();
      return 0;
    }
    else
    {
      memset(v3, 0, sizeof(v3));
      __strlcpy_chk();
      if (sub_10004D31C(port, (const char *)v3)) {
        _os_assumes_log();
      }
      if (mach_port_deallocate(mach_task_self_, port)) {
        _os_assumes_log();
      }
      return 0;
    }
  }
  return result;
}

void sub_100040E80(char *a1, ...)
{
  va_start(va, a1);
  v2[0] = 0;
  va_copy((va_list)&v2[1], va);
  vasprintf(v2, a1, va);
  if (!v2[0]) {
    v2[0] = a1;
  }
  sub_100040EC4();
}

void sub_100040EC4()
{
  mach_port_t v0 = (char *)abort_with_reason();
  sub_100040EE4(v0);
}

void sub_100040EE4(char *a1, ...)
{
  va_start(va, a1);
  v2[0] = 0;
  va_copy((va_list)&v2[1], va);
  vasprintf(v2, a1, va);
  if (!v2[0]) {
    v2[0] = a1;
  }
  sub_100043E48();
  syscall(55, 3072, v2[0]);
  _os_avoid_tail_call();
  __break(1u);
}

void *sub_100040F40(uint64_t a1)
{
  if ((_UNKNOWN *)sub_1000301F4(a1) != &unk_1000755B8) {
    sub_100050D0C();
  }
  unsigned int v2 = sub_100040FB4();
  uint64_t result = sub_10002EB7C((uint64_t)qword_100075640, v2, 0, "iOSUser", 0, a1, (uint64_t)&qword_1000769A0);
  *((unsigned char *)result + 104) &= ~1u;
  return result;
}

uint64_t sub_100040FB4()
{
  __chkstk_darwin();
  uint64_t result = sub_10003B570();
  if (!result)
  {
    bzero(v4, 0x1090uLL);
    int v1 = sub_10001AD1C();
    if (v1)
    {
      int v2 = v1;
      uint64_t v3 = (const char *)xpc_strerror();
      sub_100040E80("unable to resolve 'mobile': %d - %s", v2, v3);
    }
    return v5;
  }
  return result;
}

BOOL sub_100041068(uint64_t a1)
{
  return *(_UNKNOWN **)(a1 + 112) == &unk_100075640 && sub_100015D70(*(char **)(a1 + 968), "iOSUser");
}

uint64_t sub_100041094()
{
  uint64_t v0 = sub_100040FB4();

  return sub_100030024(qword_100075640, v0);
}

uint64_t sub_1000410C8(uint64_t a1, void *a2)
{
  if ((_UNKNOWN *)sub_1000301F4(a1) != &unk_1000755B8) {
    sub_100050D0C();
  }
  if ((*(unsigned char *)(a1 + 1017) & 0x10) == 0)
  {
    unsigned int v4 = sub_100040FB4();
    if (sub_100030024(qword_100075640, v4))
    {
      *(_DWORD *)(a1 + 1016) |= 0x1000u;
      if (a2)
      {
        if (*(void *)(a1 + 176)) {
          sub_100050D0C();
        }
        *(void *)(a1 + 176) = xpc_retain(a2);
      }
      sub_1000106EC("kern.willuserspacereboot", 1);
      for (uint64_t i = *(void *)(a1 + 320); i; uint64_t i = *(void *)(i + 16))
      {
        if (*(void **)(i + 112) == qword_100075640)
        {
          if (sub_100015D70(*(char **)(i + 968), "iOSUser"))
          {
            if (*(void **)(i + 112) != qword_100075640 || !sub_100015D70(*(char **)(i + 968), "iOSUser")) {
              sub_100050D0C();
            }
            if (*(void *)(i + 168)) {
              sub_100050D0C();
            }
            *(void *)(i + 168) = sub_1000123B8();
          }
          sub_10002AA9C(i, v6, v7, v8, v9, v10, v11, v12, v16);
        }
      }
      return 0;
    }
    return 37;
  }
  uint64_t v13 = *(void **)(a1 + 176);
  if (!v13) {
    return 37;
  }
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_null)
  {
    if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
      _os_assumes_log_ctx();
    }
    return 0;
  }
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 176), "error", 89);
  if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
    _os_assumes_log_ctx();
  }
  xpc_release(*(xpc_object_t *)(a1 + 176));
  xpc_object_t v14 = xpc_retain(a2);
  uint64_t result = 0;
  *(void *)(a1 + 176) = v14;
  return result;
}

uint64_t sub_1000412A0(uint64_t a1)
{
  return sub_1000410C8(a1, 0);
}

void *sub_1000412A8(uint64_t a1)
{
  if ((_UNKNOWN *)sub_1000301F4(a1) != &unk_1000755B8) {
    sub_100050D0C();
  }
  int v2 = sub_100040F40(a1);
  uint64_t v3 = *(void **)(a1 + 952);
  if (!v3) {
    sub_100050D0C();
  }
  v2[119] = xpc_retain(v3);
  sub_10002B4E4(v2, &qword_1000769A0, 0, v4, v5, v6, v7, v8);
  sub_10002FAE8((uint64_t)v2);
  return v2;
}

uint64_t sub_100041320(uint64_t a1)
{
  if ((_UNKNOWN *)sub_1000301F4(a1) != &unk_1000755B8) {
    sub_100050D0C();
  }
  if ((*(unsigned char *)(a1 + 1017) & 0x10) == 0) {
    return 29;
  }
  unsigned int v3 = sub_100040FB4();
  if (sub_100030024(qword_100075640, v3)) {
    return 37;
  }
  if (sub_10002ABC8(a1)) {
    return 16;
  }
  uint64_t v4 = *(void **)(a1 + 176);
  if (v4)
  {
    xpc_release(v4);
    *(void *)(a1 + 176) = 0;
  }
  *(_DWORD *)(a1 + 1016) &= ~0x1000u;
  uint64_t v5 = sub_1000412A8(a1);
  if ((void *)v5[14] != qword_100075640 || (uint64_t v6 = v5, !sub_100015D70((char *)v5[121], "iOSUser"))) {
    sub_100050D0C();
  }
  if (v6[21]) {
    sub_100050D0C();
  }
  uint64_t v7 = v6[29];
  v6[21] = *(void *)(v7 + 168);
  *(void *)(v7 + 168) = 0;
  sub_10002A878(a1, 2);
  return 0;
}

uint64_t sub_100041420(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if ((*(unsigned char *)(result + 1017) & 0x10) != 0 && *(void **)(a2 + 112) == qword_100075640)
  {
    uint64_t result = sub_100015D70(*(char **)(a2 + 968), "iOSUser");
    if (result)
    {
      if (*(void **)(a2 + 112) != qword_100075640
        || (uint64_t result = sub_100015D70(*(char **)(a2 + 968), "iOSUser"), (result & 1) == 0))
      {
        sub_100050D0C();
      }
      uint64_t v4 = *(void *)(a2 + 232);
      if (*(void *)(v4 + 168)) {
        sub_100050D0C();
      }
      *(void *)(v4 + 168) = *(void *)(a2 + 168);
      *(void *)(a2 + 168) = 0;
    }
  }
  if ((*(unsigned char *)(v2 + 1017) & 0x10) != 0)
  {
    uint64_t v5 = *(void *)(v2 + 320);
    if (v5)
    {
      while (*(void **)(v5 + 112) != qword_100075640)
      {
        uint64_t v5 = *(void *)(v5 + 16);
        if (!v5) {
          goto LABEL_12;
        }
      }
    }
    else
    {
LABEL_12:
      if ((_UNKNOWN *)sub_1000301F4(v2) != &unk_1000755B8) {
        sub_100050D0C();
      }
      unsigned int v6 = sub_100040FB4();
      if (sub_100030024(qword_100075640, v6)) {
        sub_100050D0C();
      }
      uint64_t v7 = *(void **)(v2 + 176);
      if (v7)
      {
        if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
        {
          uint32_t v21 = sub_100040FB4();
          sub_100014A1C(v21);
          if ((xpc_pipe_routine_reply() | 0x20) != 0x20) {
            _os_assumes_log_ctx();
          }
          xpc_release(*(xpc_object_t *)(v2 + 176));
          uint64_t result = (uint64_t)xpc_null_create();
          *(void *)(v2 + 176) = result;
        }
        else
        {
          uint64_t result = (uint64_t)xpc_get_type(*(xpc_object_t *)(v2 + 176));
          if ((_UNKNOWN *)result != &_xpc_type_null) {
            sub_100050D0C();
          }
        }
      }
      else
      {
        uint32_t v8 = sub_100040FB4();
        sub_100014A1C(v8);
        sub_1000447E0("keybag", 0, v9, v10, v11, v12, v13, v14, v22);
        sub_1000447E0("usermanagerd-switch", 0, v15, v16, v17, v18, v19, v20, v23);
        uint64_t result = sub_100041320(v2);
        if (result) {
          return _os_assumes_log_ctx();
        }
      }
    }
  }
  return result;
}

uint64_t sub_1000415F8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)qword_1000765F8;
  if (qword_1000765F8)
  {
    if (xpc_get_type((xpc_object_t)qword_1000765F8) != (xpc_type_t)&_xpc_type_array) {
      sub_100040E80("invalid type for persistent services");
    }
    xpc_array_apply(v4, &stru_100070F68);
    xpc_release(v4);
    qword_1000765F8 = 0;
  }
  if (qword_100076600)
  {
    xpc_release((xpc_object_t)qword_100076600);
    qword_100076600 = 0;
  }
  if (qword_100076608)
  {
    xpc_release((xpc_object_t)qword_100076608);
    qword_100076608 = 0;
  }
  if (a2)
  {
    qword_1000765F8 = (uint64_t)xpc_array_create_empty();
    qword_100076600 = (uint64_t)xpc_array_create_empty();
    sub_1000418C0(a1, (void *)qword_1000765F8, a2);
    for (uint64_t i = *(void *)(a1 + 320); i; uint64_t i = *(void *)(i + 16))
      sub_1000418C0(i, (void *)qword_1000765F8, a2);
    unsigned int v6 = (void *)sub_10000F338();
    applier[0] = (size_t)_NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = (size_t)sub_1000420C8;
    applier[3] = (size_t)&unk_100070FA0;
    applier[4] = qword_100076600;
    xpc_array_apply(v6, applier);
    xpc_object_t empty = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(empty, "services", (xpc_object_t)qword_1000765F8);
    xpc_dictionary_set_value(empty, "jetsam-properties", (xpc_object_t)qword_100076600);
    applier[0] = 0;
    serializatiounint64_t n = xpc_make_serialization();
    if (serialization)
    {
      uint64_t v9 = (void *)serialization;
      sub_100043D78(65541, "persistent object size is %zu bytes", applier[0]);
      size_t v10 = applier[0];
      size_t v11 = applier[0] + 16;
      if (applier[0] >= 0xFFFFFFFFFFFFFFF0)
      {
        sub_100043D78(65539, "overflow detected");
        free(v9);
        a2 = 84;
LABEL_19:
        xpc_release(empty);
        return a2;
      }
      uint64_t v12 = (void *)sub_10004315C(applier[0] + 16);
      *(_DWORD *)uint64_t v12 = 772498902;
      v12[1] = v11;
      memcpy(v12 + 2, v9, v10);
      uint64_t readonly = xpc_shmem_create_readonly();
      if (readonly)
      {
        uint64_t v14 = readonly;
        uint64_t v15 = sub_100003D20(a2);
        size_t count = xpc_array_get_count((xpc_object_t)qword_1000765F8);
        sub_100043D78(65541, "gathered %zu services to persist into %s", count, v15);
        size_t v17 = xpc_array_get_count((xpc_object_t)qword_100076600);
        sub_100043D78(65541, "gathered %zu jetsam property overlays to persist into %s", v17, v15);
        qword_100076608 = v14;
        sub_100041A8C(2);
        return 0;
      }
      free(v12);
      sub_100043D78(65539, "failed to create shmem");
    }
    else
    {
      sub_100043D78(65539, "failed to serialize persistent object: %p");
    }
    a2 = 12;
    goto LABEL_19;
  }
  return a2;
}

void sub_1000418C0(uint64_t a1, void *a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 112);
  if ((_UNKNOWN *)v6 != &unk_1000755B8)
  {
    if ((void *)v6 == qword_100075640)
    {
      if (sub_100041068(a1)) {
        goto LABEL_4;
      }
      uint64_t v6 = *(void *)(a1 + 112);
    }
    sub_100043D78(65541, "Skipped persisting services in domain: %s", *(const char **)(v6 + 112));
    return;
  }
LABEL_4:
  uint64_t v7 = sub_100003D20(a3);
  for (uint64_t i = 0; i != 23; ++i)
  {
    for (uint64_t j = *(int8x16_t **)(a1 + 8 * i + 336); j; uint64_t j = (int8x16_t *)j[7].i64[1])
    {
      int v14 = 0;
      int v10 = sub_10002A788(*(void *)(a1 + 112), &v14);
      if (!v14 && (j[86].i8[5] & 4) != 0)
      {
        int v11 = v10;
        uint64_t v12 = (void *)j[40].i64[1];
        if (v12)
        {
          if (sub_100041FAC(v12, v7))
          {
            if (!j[41].i64[0] || !sub_100042080()) {
              sub_100040E80("failed to serialize service plist: %s", j[87].i8);
            }
            *(_OWORD *)keys = *(_OWORD *)off_100070F88;
            uint64_t v18 = "plist";
            xpc_object_t values = xpc_uint64_create(v11);
            int8x16_t v16 = vextq_s8(j[41], j[41], 8uLL);
            xpc_object_t v13 = xpc_dictionary_create((const char *const *)keys, &values, 3uLL);
            xpc_array_append_value(a2, v13);
            sub_100043D78(65541, "persisting service %s (%s) into %s", j[87].i8, *(const char **)(*(void *)(a1 + 112) + 112), v7);
          }
        }
      }
    }
  }
}

uint64_t sub_100041A8C(uint64_t result)
{
  unint64_t v1 = 0;
  BOOL v2 = 1;
  unsigned int v3 = &qword_100075950;
  do
  {
    if (*(v3 - 1) == qword_100075998 && *v3 == result) {
      break;
    }
    BOOL v2 = v1 < 4;
    v3 += 2;
    ++v1;
  }
  while (v1 != 5);
  if (!v2) {
    sub_100050D0C();
  }
  qword_100075998 = result;
  return result;
}

uint64_t sub_100041AF8()
{
  return qword_100076608;
}

void sub_100041B04()
{
  kern_return_t v0;
  mem_entry_name_port_t v1;
  int v2;
  char *v3;
  mach_vm_size_t v4;
  void *v5;
  xpc_object_t array;
  void *v7;
  xpc_object_t v8;
  void *v9;
  size_t count;
  size_t v11;
  uint64_t v12;
  mach_msg_type_number_t init_port_setCnt;
  mach_port_array_t init_port_set;

  sub_100041A8C(3);
  if (qword_100076610) {
    sub_100050D0C();
  }
  if (qword_100076618) {
    sub_100050D0C();
  }
  init_port_set = 0;
  init_port_setCnt = 0;
  uint64_t v0 = mach_ports_lookup(mach_task_self_, &init_port_set, &init_port_setCnt);
  if (v0) {
    sub_100040E80("mach_ports_lookup() failed: %d", v0);
  }
  if (init_port_setCnt < 2 || (unint64_t v1 = init_port_set[1], v1 + 1 <= 1))
  {
    BOOL v2 = 65541;
    uint64_t v12 = 2;
    unsigned int v3 = "no mach port for persistent services: %d";
LABEL_7:
    sub_100043D78(v2, v3, v12);
    return;
  }
  init_port_set = 0;
  if (sub_100042D8C(v1, 0x10uLL, (mach_vm_address_t *)&init_port_set, 1))
  {
    unsigned int v3 = "failed to map persistent services header";
    goto LABEL_11;
  }
  if (*init_port_set != 772498902)
  {
    sub_100043D78(65539, "persistent services header magic is invalid");
LABEL_16:
    sub_100043D78(65539, "failed to validate services header: %d", 22);
    if (munmap(init_port_set, 0x10uLL) == -1) {
      goto LABEL_26;
    }
    return;
  }
  uint64_t v4 = *((void *)init_port_set + 1);
  if (v4 <= 0xF)
  {
    sub_100043D78(65539, "persistent services header size is less than header size");
    goto LABEL_16;
  }
  if (sub_100042E04(v4, (mach_vm_address_t *)&init_port_set, 1))
  {
    sub_100043D78(65539, "failed to map persistent services");
    if (munmap(init_port_set, 0x10uLL) == -1) {
      goto LABEL_26;
    }
  }
  else
  {
    if (*init_port_set == 772498902)
    {
      if (*((void *)init_port_set + 1) > 0xFuLL)
      {
        init_port_setCnt = 0;
        uint64_t v5 = (void *)sub_10004212C((uint64_t)init_port_set, (int *)&init_port_setCnt);
        if (munmap(init_port_set, *((void *)init_port_set + 1)) == -1) {
          sub_100050E38();
        }
        if (init_port_setCnt)
        {
          if (v5) {
            sub_100050D0C();
          }
          uint64_t v12 = init_port_setCnt;
          unsigned int v3 = "failed to restore persistent object: %d";
        }
        else
        {
          xpc_object_t array = xpc_dictionary_get_array(v5, "services");
          if (!array) {
            sub_100040E80("no services found in persistent object");
          }
          uint64_t v7 = array;
          uint32_t v8 = xpc_dictionary_get_array(v5, "jetsam-properties");
          if (!v8) {
            sub_100040E80("no jetsam property overlays found in persistent object");
          }
          uint64_t v9 = v8;
          if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
          {
            size_t count = xpc_array_get_count(v7);
            sub_100043D78(65541, "validating %zu persistent services", count);
            if (xpc_array_apply(v7, &stru_100070FE0))
            {
              if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
              {
                int v11 = xpc_array_get_count(v9);
                sub_100043D78(65541, "validating %zu jetsam property overlays", v11);
                qword_100076618 = (uint64_t)v9;
                qword_100076610 = (uint64_t)v7;
                return;
              }
              sub_100043D78(65539, "jetsam properties object is not an array");
              unsigned int v3 = "persistent jetsam properties object is invalid";
              goto LABEL_11;
            }
          }
          else
          {
            sub_100043D78(65539, "persistent services object is not an array");
          }
          unsigned int v3 = "persistent services object is invalid";
        }
LABEL_11:
        BOOL v2 = 65539;
        goto LABEL_7;
      }
      sub_100043D78(65539, "persistent services header size is less than header size");
    }
    else
    {
      sub_100043D78(65539, "persistent services header magic is invalid");
    }
    sub_100043D78(65539, "failed to validate remapped services header: %d", 22);
    if (munmap(init_port_set, *((void *)init_port_set + 1)) == -1) {
LABEL_26:
    }
      sub_100050E38();
  }
}

void sub_100041E98()
{
  sub_100041A8C(4);
  if (qword_100076618)
  {
    size_t count = xpc_array_get_count((xpc_object_t)qword_100076618);
    sub_100043D78(65541, "restoring %zu jetsam property overlays", count);
    xpc_array_apply((xpc_object_t)qword_100076618, &stru_100071020);
    xpc_release((xpc_object_t)qword_100076618);
    qword_100076618 = 0;
  }
  if (qword_100076610)
  {
    size_t v1 = xpc_array_get_count((xpc_object_t)qword_100076610);
    sub_100043D78(65541, "restoring %zu persistent services", v1);
    xpc_array_apply((xpc_object_t)qword_100076610, &stru_100071060);
    xpc_release((xpc_object_t)qword_100076610);
    qword_100076610 = 0;
  }
}

BOOL sub_100041F4C(id a1, unint64_t a2, void *a3)
{
  if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100040E80("invalid type for persistent service[%zu]", a2);
  }
  xpc_release(a3);
  return 1;
}

BOOL sub_100041FAC(void *a1, char *a2)
{
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    char string_ptr = xpc_string_get_string_ptr(a1);
    return sub_100015D70(a2, string_ptr);
  }
  else
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(a1)) {
      return 0;
    }
    size_t v7 = 0;
    do
    {
      xpc_object_t value = xpc_array_get_value(a1, v7);
      uint64_t v4 = sub_100041FAC(value, a2);
      if (v4) {
        break;
      }
      ++v7;
    }
    while (v7 < xpc_array_get_count(a1));
    return v4;
  }
}

BOOL sub_100042080()
{
  serializatiounint64_t n = (void *)xpc_make_serialization();
  size_t v1 = serialization;
  if (serialization) {
    free(serialization);
  }
  return v1 != 0;
}

uint64_t sub_1000420C8(uint64_t a1, uint64_t a2, void *a3)
{
  if (!sub_100042080()) {
    sub_100040E80("failed to serialize jetsam properties[%zu]", a2);
  }
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), a3);
  return 1;
}

uint64_t sub_10004212C(uint64_t a1, int *a2)
{
  uint64_t v3 = xpc_create_from_serialization();
  if (v3)
  {
    int v4 = 0;
  }
  else
  {
    sub_100043D78(65539, "failed to deserialize persistent object");
    int v4 = 22;
  }
  *a2 = v4;
  return v3;
}

BOOL sub_100042190(id a1, unint64_t a2, void *a3)
{
  if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100043D78(65539, "services[%zu] is not a dictionary");
    return 0;
  }
  if (!xpc_dictionary_get_dictionary(a3, "plist"))
  {
    sub_100043D78(65539, "services[%zu] is missing or has invalid plist key");
    return 0;
  }
  if (!xpc_dictionary_get_uint64(a3, "xpc-domain"))
  {
    sub_100043D78(65539, "services[%zu] is missing or has invalid xpc-domain key");
    return 0;
  }
  if (!xpc_dictionary_get_string(a3, "origin"))
  {
    sub_100043D78(65539, "services[%zu] is missing or has invalid origin key");
    return 0;
  }
  return 1;
}

BOOL sub_100042258(id a1, unint64_t a2, void *a3)
{
  int v4 = sub_10000E328(a3);
  if (v4) {
    sub_100043D78(65539, "failed to merge persisted jetsam property overlay[%zu]: %d", a2, v4);
  }
  return 1;
}

BOOL sub_1000422A8(id a1, unint64_t a2, void *a3)
{
  uint int64 = xpc_dictionary_get_uint64(a3, "xpc-domain");
  xpc_object_t value = xpc_dictionary_get_value(a3, "plist");
  char string = (char *)xpc_dictionary_get_string(a3, "origin");
  size_t v7 = xpc_dictionary_get_string(value, "Label");
  uint32_t v8 = (void *)sub_10002A7CC(uint64);
  if (v8 == (void *)&unk_1000755B8)
  {
    uint64_t v10 = sub_100030018();
    if (!v10)
    {
LABEL_15:
      sub_100043D78(65539, "failed to lookup domain for persisted service");
      goto LABEL_16;
    }
  }
  else
  {
    if (v8 != qword_100075640) {
      sub_100050D0C();
    }
    uint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = qword_100075640[v9];
      if (v10) {
        break;
      }
LABEL_7:
      if (++v9 == 11) {
        goto LABEL_15;
      }
    }
    while (!sub_100041068(v10))
    {
      uint64_t v10 = *(void *)(v10 + 32);
      if (!v10) {
        goto LABEL_7;
      }
    }
  }
  int v15 = 0;
  int v11 = sub_10003EEE0(value, (_DWORD *)v10, string, &v15);
  int v12 = v15;
  if (!v15)
  {
    sub_100043D78(65541, "successfully submitted persisted service: %s to %s domain");
    return 1;
  }
  if (v11) {
    sub_100050D0C();
  }
  xpc_object_t v13 = (const char *)xpc_strerror();
  sub_100043D78(65539, "persisted submit job failed: service = %s, int error = %d: %s", v7, v12, v13);
  if (v15) {
LABEL_16:
  }
    sub_100043D78(65539, "failed to restore service[%zu]: %d");
  return 1;
}

void sub_10004245C()
{
  mach_port_t v0 = mach_host_self();
  host_reboot(v0, 4096);
  __break(1u);
}

void *sub_100042478(int a1)
{
  if (a1)
  {
    if (dlopen("/usr/lib/system/libsystem_notify.dylib", 1)) {
      notify_set_options();
    }
    if (!dlopen("/usr/lib/system/libsystem_info.dylib", 1))
    {
LABEL_8:
      uint64_t result = dlopen("/usr/lib/system/libsystem_trace.dylib", 1);
      if (!result) {
        return result;
      }
      goto LABEL_9;
    }
  }
  else
  {
    notify_set_options();
  }
  si_search_module_set_flags();
  si_search_module_set_flags();
  if (a1) {
    goto LABEL_8;
  }
LABEL_9:

  return (void *)_os_trace_set_mode(256);
}

char *sub_100042530(uint64_t a1, uint64_t a2)
{
  return sub_100042538(a1, a2, 11);
}

char *sub_100042538(uint64_t a1, uint64_t a2, uint64_t a3)
{
  bzero(v11, 0x408uLL);
  sub_1000427EC(a1, a2, a3, (int8x8_t *)v11);
  if ((v6 & 0x80000000) == 0)
  {
    if (!v6) {
      return sub_100015A48(&size_4, size - 8);
    }
    return 0;
  }
  if (*__error() != 34) {
    return 0;
  }
  uint32_t v8 = (int8x8_t *)sub_100013BB8(size);
  sub_1000427EC(a1, a2, a3, v8);
  if (v9)
  {
    if (*__error() != 3 && *__error()) {
      _os_assumes_log();
    }
    size_t v7 = 0;
  }
  else
  {
    size_t v7 = sub_100015A48((const char *)&v8[1], v8->u32[1] - 8);
  }
  free(v8);
  return v7;
}

xpc_object_t sub_10004267C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  bzero(&v12, 0x408uLL);
  if (a3 != 16 && a3 != 7) {
    return 0;
  }
  sub_1000427EC(a1, a2, a3, (int8x8_t *)&v12);
  if (v6 < 0)
  {
    if (*__error() != 34) {
      return 0;
    }
    uint32_t v8 = (int8x8_t *)sub_100013BB8(size);
    sub_1000427EC(a1, a2, a3, v8);
    if (v9)
    {
      if (*__error() != 3 && *__error()) {
        _os_assumes_log();
      }
    }
    else
    {
      uint64_t v11 = v8->u32[1];
      if (v11 && v8->i32[0])
      {
        xpc_object_t v7 = xpc_data_create(&v8[1], v11 - 8);
LABEL_19:
        free(v8);
        return v7;
      }
    }
    xpc_object_t v7 = 0;
    goto LABEL_19;
  }
  if (v6) {
    return 0;
  }
  xpc_object_t v7 = 0;
  if (size && v12) {
    return xpc_data_create(&size_4, size - 8);
  }
  return v7;
}

int8x8_t sub_1000427EC(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t *a4)
{
  if (a2) {
    csops_audittoken();
  }
  else {
    csops();
  }
  int8x8_t result = vrev32_s8(*a4);
  *a4 = result;
  return result;
}

xpc_object_t sub_100042848(uint64_t a1, uint64_t a2)
{
  xpc_object_t result = sub_10004267C(a1, a2, 16);
  if (result)
  {
    uint64_t v3 = result;
    bytes_ptr = xpc_data_get_bytes_ptr(result);
    size_t length = xpc_data_get_length(v3);
    uint64_t v6 = xpc_create_from_ce_der((unint64_t)bytes_ptr, length);
    xpc_release(v3);
    return (xpc_object_t)v6;
  }
  return result;
}

uint64_t sub_1000428A0(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 13, 1uLL, buffer, 64) == 64) {
    return 0;
  }
  else {
    return *__error();
  }
}

uint64_t sub_1000428E0(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 18, 1uLL, buffer, 192) == 192) {
    return 0;
  }
  else {
    return *__error();
  }
}

const char *sub_100042920(uint64_t a1, char *a2)
{
  int v3 = sub_1000428A0(*(_DWORD *)(a1 + 20), a2);
  int v4 = "(dead-on-arrival)";
  if (v3 != 3) {
    int v4 = "(confusing)";
  }
  if (v3) {
    return v4;
  }
  else {
    return a2 + 16;
  }
}

char *sub_10004296C(int a1, char *a2)
{
  long long buffer = 0u;
  memset(v8, 0, sizeof(v8));
  int v4 = sub_1000428A0(a1, &buffer);
  uint64_t v5 = "(unknown)";
  if (!v4) {
    uint64_t v5 = (const char *)v8;
  }
  snprintf(a2, 0x20uLL, "%s[%d]", v5, a1);
  return a2;
}

uint64_t sub_100042A14(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40) {
    return 0;
  }
  else {
    return *__error();
  }
}

size_t sub_100042A54(const char *a1, char **a2)
{
  *__error() = 0;
  memset(v12, 0, sizeof(v12));
  size_t size = 128;
  int v4 = sysctlbyname(a1, v12, &size, 0, 0);
  int v5 = v4;
  if (size)
  {
    if (!v4) {
      goto LABEL_6;
    }
  }
  else
  {
    size_t size = 128;
    *__error() = 12;
    if (!v5) {
      goto LABEL_6;
    }
  }
  if (*__error() != 12) {
    return 0;
  }
LABEL_6:
  if (size != 128 || *__error() != 12)
  {
    uint64_t v10 = 0;
    uint32_t v8 = (char *)v12;
    if (v5) {
      goto LABEL_13;
    }
LABEL_16:
    *a2 = strdup(v8);
    goto LABEL_17;
  }
  int v6 = sysctlbyname(a1, 0, &size, 0, 0);
  size_t result = 0;
  if (v6) {
    return result;
  }
  if (size < 0x81)
  {
    uint64_t v10 = 0;
    uint32_t v8 = (char *)v12;
    goto LABEL_16;
  }
  uint32_t v8 = (char *)sub_100013BB8(size);
  int v9 = sysctlbyname(a1, v8, &size, 0, 0);
  uint64_t v10 = v8;
  if (!v9) {
    goto LABEL_16;
  }
LABEL_13:
  size_t size = 0;
LABEL_17:
  free(v10);
  return size;
}

uint64_t sub_100042BE4(const char *a1, void *a2)
{
  size_t v8 = 0;
  int v4 = sysctlbyname(a1, 0, &v8, 0, 0);
  uint64_t result = 0;
  if (!v4)
  {
    if (v8 == 8)
    {
      return 8 * (sysctlbyname(a1, a2, &v8, 0, 0) == 0);
    }
    else if (v8 == 4)
    {
      int v7 = 0;
      int v6 = sysctlbyname(a1, &v7, &v8, 0, 0);
      uint64_t result = 0;
      if (!v6)
      {
        *a2 = v7;
        return 8;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int *sub_100042CB0(const char *a1, int a2)
{
  int v4 = a2;
  uint64_t result = (int *)sysctlbyname(a1, 0, 0, &v4, 4uLL);
  if (result)
  {
    int v3 = (int)result;
    uint64_t result = __error();
    if (v3 == -1 && *result != 2) {
      return (int *)sub_100050E38();
    }
  }
  return result;
}

unint64_t sub_100042D14(char *a1, const char *a2, uint64_t a3)
{
  int v5 = strstr(a1, a2);
  if (v5)
  {
    __endptr = 0;
    int v6 = &v5[strlen(a2)];
    unint64_t v7 = strtoul(v6, &__endptr, 10);
    if (v6 != __endptr) {
      return v7;
    }
  }
  return a3;
}

unint64_t sub_100042D84(char *a1, const char *a2)
{
  return sub_100042D14(a1, a2, 0);
}

uint64_t sub_100042D8C(mem_entry_name_port_t object, mach_vm_size_t size, mach_vm_address_t *a3, int a4)
{
  mach_vm_address_t address = 0;
  uint64_t result = mach_vm_map(mach_task_self_, &address, size, 0, 1, object, 0, a4 ^ 1, 67, 67, 2u);
  if (!result) {
    *a3 = address;
  }
  return result;
}

uint64_t sub_100042E04(mach_vm_size_t size, mach_vm_address_t *a2, int a3)
{
  vm_prot_t v6 = 67;
  cur_protectiounint64_t n = 67;
  target_mach_vm_address_t address = 0;
  uint64_t result = mach_vm_remap(mach_task_self_, &target_address, size, 0, 16385, mach_task_self_, *a2, a3 ^ 1, &cur_protection, &v6, 2u);
  if (!result) {
    *a2 = target_address;
  }
  return result;
}

uint64_t sub_100042E88(int a1, rlim_t *a2, rlim_t *a3)
{
  v8.rlim_t rlim_cur = 0;
  v8.rlim_t rlim_max = 0;
  uint64_t result = getrlimit(a1, &v8);
  if (!result)
  {
    rlim_t rlim_cur = v8.rlim_cur;
    if (v8.rlim_cur == 0x7FFFFFFFFFFFFFFFLL) {
      rlim_t rlim_cur = -1;
    }
    if (v8.rlim_max == 0x7FFFFFFFFFFFFFFFLL) {
      rlim_t rlim_max = -1;
    }
    else {
      rlim_t rlim_max = v8.rlim_max;
    }
    *a2 = rlim_cur;
    *a3 = rlim_max;
  }
  return result;
}

uint64_t sub_100042EE4(int a1, unint64_t a2, uint64_t a3, int a4)
{
  if (a2 >= 0x7FFFFFFFFFFFFFFFLL) {
    unint64_t v6 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v6 = a2;
  }
  if (a3 < 0) {
    uint64_t v7 = -1;
  }
  else {
    uint64_t v7 = a3;
  }
  if (a3 >= 0) {
    rlim_t v8 = v7;
  }
  else {
    rlim_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (a1 == 8)
  {
    int v9 = "kern.maxfilesperproc";
    uint64_t v10 = "kern.maxfiles";
    goto LABEL_14;
  }
  if (a1 == 7)
  {
    int v9 = "kern.maxprocperuid";
    uint64_t v10 = "kern.maxproc";
LABEL_14:
    sub_100042FE0(v10, v8, a4);
    sub_100042FE0(v9, v6, a4);
  }
  v14.rlim_t rlim_cur = v6;
  v14.rlim_t rlim_max = v8;
  if (a4)
  {
    v13.rlim_t rlim_cur = 0;
    v13.rlim_t rlim_max = 0;
    if (!getrlimit(a1, &v13))
    {
      rlim_t rlim_max = 0x7FFFFFFFFFFFFFFFLL;
      if (v13.rlim_max == 0x7FFFFFFFFFFFFFFFLL || (rlim_t rlim_max = v13.rlim_max, v8 < v13.rlim_max)) {
        v14.rlim_t rlim_max = rlim_max;
      }
    }
  }
  uint64_t result = setrlimit(a1, &v14);
  if (result) {
    return _os_assumes_log();
  }
  return result;
}

uint64_t sub_100042FE0(const char *a1, unint64_t a2, int a3)
{
  unsigned int v10 = 0x7FFFFFFF;
  size_t v9 = 4;
  uint64_t result = sysctlbyname(a1, &v10, &v9, 0, 0);
  if (!a3 || !result && v9 == 4 && (v10 & 0x80000000) == 0 && v10 < a2)
  {
    if (a2 >> 31) {
      int v7 = 0x7FFFFFFF;
    }
    else {
      int v7 = a2;
    }
    int v8 = v7;
    return sysctlbyname(a1, 0, 0, &v8, 4uLL);
  }
  return result;
}

uint64_t sub_100043088(char *__s2, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t result = strcmp((&off_1000759A0)[v8], __s2);
    if (!result) {
      break;
    }
    v8 += 2;
    if (v8 == 18) {
      return result;
    }
  }
  int v10 = (int)(&off_1000759A0)[v8 + 1];

  return sub_100042EE4(v10, a2, a3, a4);
}

char *sub_100043124(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&off_1000759A0)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 18) {
      return 0;
    }
  }
  return (&off_1000759A0)[v1];
}

vm_address_t sub_10004315C(uint64_t a1)
{
  vm_address_t address = 0;
  if (vm_allocate(mach_task_self_, &address, (a1 + vm_page_size - 1) & -(uint64_t)vm_page_size, -268435453)) {
    _os_assumes_log();
  }
  return address;
}

vm_address_t sub_1000431C8(uint64_t a1)
{
  vm_address_t address = 0;
  if (vm_allocate(mach_task_self_, &address, (a1 + vm_page_size - 1) & -(uint64_t)vm_page_size, -268435455)) {
    _os_assumes_log();
  }
  return address;
}

uint64_t sub_100043234(int a1)
{
  return sub_100015F0C(a1, (uint64_t)&unk_100071080, 27);
}

uint64_t sub_100043244(int a1)
{
  return sub_100015F0C(a1, (uint64_t)&unk_100071230, 26);
}

void sub_100043254(int a1, int a2)
{
  if (a1 == 1)
  {
    sub_100011594();
    reboot(a2);
    if (*__error() == 16) {
      sub_1000432FC();
    }
    goto LABEL_8;
  }
  if (a1 == 2) {
    sub_10004245C();
  }
  if (a1 != 3)
  {
    sub_100011594();
    sub_100043310(a2);
LABEL_8:
    __error();
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  sub_100011594();
  sub_1000458EC("recovery-mode", v3, v4, v5, v6, v7, v8, v9, v10);
  __break(1u);
}

void sub_1000432FC()
{
  while (1)
    pause();
}

uint64_t sub_100043310(char a1)
{
  posix_spawnattr_t v14 = 0;
  BOOL v2 = _NSGetArgv();
  uint64_t v3 = "-s";
  if ((a1 & 2) == 0) {
    uint64_t v3 = 0;
  }
  __argv[0] = **v2;
  __argv[1] = v3;
  __argv[2] = 0;
  pid_t v12 = 0;
  sub_100014A1C(0);
  v11[0] = 1;
  if ((sub_10003B5BC() & 1) == 0 && sysctlbyname("vm.shared_region_pivot", 0, 0, v11, 4uLL) == -1) {
    goto LABEL_21;
  }
  unsetenv("MallocProbGuard");
  unsetenv("XPC_IN_REM");
  unsetenv("XPC_IN_REM_DEVELOPMENT");
  if (setenv("XPC_USERSPACE_REBOOTED", "1", 1) == -1) {
    goto LABEL_19;
  }
  if (posix_spawnattr_init(&v14)) {
    _os_assumes_log();
  }
  if (posix_spawnattr_setflags(&v14, 16448)) {
    _os_assumes_log();
  }
  int v4 = sub_10004599C();
  if (!v4)
  {
LABEL_17:
    xpc_object_t empty = xpc_dictionary_create_empty();
    xpc_dictionary_set_BOOL(empty, "on-system-volume", 1);
    xpc_dictionary_set_string(empty, "signing-identifier", "com.apple.xpc.launchd");
    xpc_dictionary_set_int64(empty, "validation-category", 1);
    xpc_object_t v7 = sub_1000117E0(1, 0, empty);
    uint64_t v8 = (void *)sub_100011890(v7);
    xpc_data_get_bytes_ptr(v8);
    xpc_data_get_length(v8);
    if (amfi_launch_constraint_set_spawnattr())
    {
LABEL_20:
      _os_assert_log();
      _os_crash();
      __break(1u);
LABEL_21:
      __error();
      _os_assert_log();
      _os_crash();
      __break(1u);
      goto LABEL_22;
    }
    uint64_t v9 = _NSGetEnviron();
    posix_spawn(&v12, "/sbin/launchd", 0, &v14, __argv, *v9);
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_19:
    __error();
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_20;
  }
  uint64_t v5 = sub_100003D20(v4);
  if (setenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE", v5, 1) == -1)
  {
LABEL_22:
    __error();
    _os_assert_log();
    _os_crash();
    __break(1u);
LABEL_23:
    __error();
    _os_assert_log();
    _os_crash();
    __break(1u);
    goto LABEL_24;
  }
  if (!sub_1000459B4() || setenv("XPC_IN_REM_DEVELOPMENT", "1", 1) != -1)
  {
    _OWORD v11[2] = 0;
    if (!sub_100041AF8()) {
      _os_assumes_log();
    }
    v11[0] = 0;
    v11[1] = _xpc_shmem_get_mach_port();
    if (posix_spawnattr_set_registered_ports_np() == -1) {
      goto LABEL_23;
    }
    goto LABEL_17;
  }
LABEL_24:
  __error();
  _os_assert_log();
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

uint64_t sub_1000435B4()
{
  uint64_t result = terminate_with_reason();
  if (result)
  {
    if (*__error() == 3) {
      return 0;
    }
    else {
      return *__error();
    }
  }
  return result;
}

uint64_t sub_100043604()
{
  uint64_t v0 = kill(-1, 9);
  if (v0)
  {
    if (*__error() == 1)
    {
      sub_100043D78(65540, "kill(-1, SIGKILL) returned EPERM (expected at most twice)");
    }
    else if (v0 == -1)
    {
      sub_100050E38();
    }
  }
  return v0;
}

uint64_t sub_100043670()
{
  return proc_terminate_with_audittoken();
}

uint64_t sub_10004369C(uint64_t a1, int a2)
{
  if (!csops_audittoken()) {
    return a2 == 0;
  }
  if (*__error() == 3) {
    return 0;
  }
  uint64_t result = *__error();
  if (result)
  {
    _os_assumes_log();
    return 0;
  }
  return result;
}

xpc_object_t sub_100043720(uint64_t a1)
{
  return sub_100042848(*(unsigned int *)(a1 + 20), a1);
}

BOOL sub_10004372C(pid_t a1)
{
  if (a1 < 1) {
    return 0;
  }
  if (kill(a1, 0)) {
    return *__error() != 3;
  }
  return 1;
}

uint64_t sub_100043778()
{
  return proc_signal_with_audittoken();
}

uint64_t sub_1000437A4(pid_t a1, int *a2, int a3, rusage *a4)
{
  if (wait4(a1, a2, a3, a4) == -1) {
    return *__error();
  }
  else {
    return 0;
  }
}

uint64_t sub_1000437E0(int pid, integer_t *a2)
{
  tunint64_t n = 0;
  mach_msg_type_number_t task_info_outCnt = 8;
  uint64_t v3 = task_name_for_pid(mach_task_self_, pid, &tn);
  if (!v3)
  {
    uint64_t v3 = task_info(tn, 0xFu, a2, &task_info_outCnt);
    mach_port_deallocate(mach_task_self_, tn);
  }
  return v3;
}

uint64_t sub_100043860()
{
  int v0 = memorystatus_control();
  uint64_t result = 0;
  if (v0 != 24) {
    return *__error();
  }
  return result;
}

uint64_t sub_1000438A4(int a1)
{
  long long v3 = 0u;
  long long v4 = 0u;
  memset(v2, 0, sizeof(v2));
  if (!sub_1000428A0(a1, v2)) {
    return (v3 >> 1) & 1;
  }
  _os_assumes_log();
  return 0;
}

uint64_t sub_10004392C()
{
  return qword_100075AF8;
}

void sub_100043938(const char *a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v5 = 0u;
  long long v6 = 0u;
  long long v3 = 0u;
  long long v4 = 0u;
  *(_OWORD *)__str = 0u;
  long long v2 = 0u;
  snprintf(__str, 0xA0uLL, "XPC API Misuse: %s", a1);
  qword_100075AF8 = (uint64_t)__str;
  __break(1u);
}

void sub_100043990(uint64_t a1)
{
  free(*(void **)(a1 + 24));
  long long v2 = *(void **)(a1 + 48);

  free(v2);
}

uint64_t sub_1000439CC(const char *a1)
{
  if (byte_100076630) {
    int v1 = 3;
  }
  else {
    int v1 = 65539;
  }
  sub_100043D78(v1, "%s", a1);
  return 1;
}

void sub_100043A1C()
{
  if (qword_100076620 != -1) {
    dispatch_once_f(&qword_100076620, 0, (dispatch_function_t)sub_100043D04);
  }
  mkdir(off_100075A70[0], 0x1C0u);
  if (!byte_100076A63)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "/private/%s", "/var/run/syslog");
    long long v14 = 0u;
    memset(v15, 0, sizeof(v15));
    long long v12 = 0u;
    long long v13 = 0u;
    sockaddr v10 = (sockaddr)0;
    long long v11 = 0u;
    v10.sa_family = 1;
    strncpy(v10.sa_data, __str, 0x67uLL);
    long long v2 = (int *)socket(1, 2, 0);
    if (v2 == -1)
    {
      int v6 = *__error();
      __error();
      long long v7 = (const char *)xpc_strerror();
      sub_100043D78(65539, "Could not create system logger socket: int error = %d: %s", v6, v7);
      goto LABEL_4;
    }
    long long v3 = v2;
    if (unlink(v10.sa_data) == -1 && *__error() != 2)
    {
      __error();
      __error();
      xpc_strerror();
      sub_100043D78(65539, "Could not unlink previous system logger socket: int error = %d: %s");
    }
    else
    {
      int v4 = bind((int)v3, &v10, 0x6Au);
      if (!v4) {
        goto LABEL_17;
      }
      int v5 = v4;
      while (*__error() == 35 || *__error() == 4)
      {
        int v5 = bind((int)v3, &v10, 0x6Au);
        if (!v5) {
          goto LABEL_17;
        }
      }
      if (v5 != -1)
      {
LABEL_17:
        if (chmod(v10.sa_data, 0x1B6u) == -1)
        {
          int v8 = *__error();
          __error();
          long long v9 = (const char *)xpc_strerror();
          sub_100043D78(65539, "Could not make system logger socket world-writable: int error = %d: %s", v8, v9);
          if (unlink(v10.sa_data) == -1) {
            sub_100050DFC();
          }
        }
        else
        {
          _os_log_simple_reinit_4launchd();
          dword_100075A30 = (int)v3;
        }
        goto LABEL_4;
      }
      __error();
      __error();
      xpc_strerror();
      sub_100043D78(65539, "Could not bind to system logger socket: int error = %d: %s");
    }
    sub_10003E54C(v3);
  }
LABEL_4:
  dispatch_activate((dispatch_object_t)qword_100076628);
  byte_100076630 = 1;
  int v0 = off_100075A88;
  pid_t v1 = getpid();
  sub_100043D78(65541, "launchd logging initialized. name: %s pid: %d", v0, v1);
}

void sub_100043D04()
{
  int v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  qword_100076638 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.logq", v0);
  qword_100076628 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, (dispatch_queue_t)qword_100076638);
  dispatch_source_set_event_handler((dispatch_source_t)qword_100076628, &stru_100071470);
  qword_1000769E0 = 0;
  qword_1000769E8 = (uint64_t)&qword_1000769E0;
}

void sub_100043D78(int a1, char *a2, ...)
{
  va_start(va, a2);
  sub_100044138(0, a1, a2, va, v2);
}

void sub_100043DB8()
{
  sub_100043DF4(5, "bye");
  int v0 = qword_100076638;

  dispatch_suspend(v0);
}

void sub_100043DF4(int a1, char *a2, ...)
{
  va_start(va, a2);
  sub_100044138(0, a1, a2, va, v2);
  dispatch_sync((dispatch_queue_t)qword_100076638, &stru_100071430);
}

void sub_100043E48()
{
}

void sub_100043E5C(id a1)
{
  sub_100043EA0();
  if (qword_100076640)
  {
    int v1 = fileno((FILE *)qword_100076640);
    fcntl(v1, 51);
  }
}

uint64_t sub_100043EA0()
{
  uint64_t v15 = 0;
  int8x16_t v16 = &v15;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_100076648);
  if (qword_1000769E0)
  {
    *int8x16_t v16 = qword_1000769E0;
    int8x16_t v16 = (uint64_t *)qword_1000769E8;
    qword_1000769E0 = 0;
    qword_1000769E8 = (uint64_t)&qword_1000769E0;
  }
  unint64_t v0 = qword_100076650;
  qword_100076650 = 0;
  uint64_t v1 = qword_100076658;
  qword_100076658 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100076648);
  uint64_t v2 = v15;
  if (v15)
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    while (1)
    {
      uint64_t v5 = qword_100076660;
      if (!qword_100076660) {
        goto LABEL_14;
      }
      if (*(_DWORD *)(qword_100076660 + 16) != *(_DWORD *)(v2 + 16)
        || !sub_100015D70(*(char **)(qword_100076660 + 24), *(const char **)(v2 + 24))
        || !sub_100015D70(*(char **)(v5 + 48), *(const char **)(v2 + 48)))
      {
        break;
      }
      ++qword_100076668;
LABEL_16:
      uint64_t v15 = *(void *)(v15 + 80);
      if (!v15) {
        int8x16_t v16 = &v15;
      }
      sub_10001A174((void *)v2);
      ++v3;
      uint64_t v2 = v15;
      if (!v15) {
        goto LABEL_21;
      }
    }
    int v6 = (void *)qword_100076660;
    if (qword_100076660)
    {
      if (qword_100076668)
      {
        long long v7 = sub_100015BE4("Last log repeated %llu times", qword_100076668);
        int v8 = sub_1000442FC(5, 0, (__darwin_time_t)v7, 0);
        sub_1000443F8((uint64_t)v8, 0);
        sub_10001A174(v8);
        int v6 = (void *)qword_100076660;
      }
      sub_10001A174(v6);
      qword_100076660 = 0;
    }
LABEL_14:
    qword_100076660 = (uint64_t)sub_10001A0AC((void *)v2);
    qword_100076668 = 0;
    int v14 = 0;
    sub_1000443F8(v2, &v14);
    if (v14) {
      ++v4;
    }
    goto LABEL_16;
  }
  uint64_t v4 = 0;
  uint64_t v3 = 0;
LABEL_21:
  if (v3 == v0)
  {
    if (v1)
    {
LABEL_23:
      long long v9 = sub_100015BE4("%lld file logs dropped [in-flight %lld]: %lld os_log_simple logs dropped", v1, v0, v4);
      int v10 = 4;
      goto LABEL_27;
    }
  }
  else
  {
    _os_assumes_log();
    if (v1) {
      goto LABEL_23;
    }
  }
  if (v0 < dword_100075AC0) {
    goto LABEL_29;
  }
  long long v9 = sub_100015BE4("Flushed %lld logs [limit: %d]", v0, dword_100075AC0);
  int v10 = 5;
LABEL_27:
  long long v11 = sub_1000442FC(v10, 0, (__darwin_time_t)v9, 0);
  long long v12 = v11;
  if (v11)
  {
    sub_1000443F8((uint64_t)v11, 0);
    sub_10001A174(v12);
  }
LABEL_29:
  uint64_t result = qword_100076640;
  if (qword_100076640) {
    return fflush((FILE *)qword_100076640);
  }
  return result;
}

void sub_100044138(const char *a1, int a2, char *a3, va_list a4, uint64_t a5)
{
  if ((a2 & 0xFFFEu) <= 5)
  {
    void v13[5] = v5;
    void v13[6] = v6;
    v13[0] = 0;
    if (vasprintf(v13, a3, a4) != -1)
    {
      int v10 = sub_1000442FC(a2, a1, (__darwin_time_t)v13[0], a5);
      long long v11 = v10;
      if (!byte_100076630 && BYTE4(v10[1].tv_sec))
      {
        long long v12 = sub_1000446D8((uint64_t)v10);
        sub_10000FCC0("%s|%s", off_100075A88, v12);
        BYTE4(v11[1].tv_sec) = 0;
        free(v12);
      }
      if (qword_100076620 != -1) {
        dispatch_once_f(&qword_100076620, 0, (dispatch_function_t)sub_100043D04);
      }
      os_unfair_lock_lock((os_unfair_lock_t)&unk_100076648);
      if ((unint64_t)qword_100076650 >> 4 > 0x270)
      {
        ++qword_100076658;
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_100076648);
        sub_10001A174(v11);
      }
      else
      {
        v11[5].tv_sec = 0;
        *(void *)qword_1000769E8 = v11;
        qword_1000769E8 = (uint64_t)&v11[5];
        ++qword_100076650;
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_100076648);
        dispatch_source_merge_data((dispatch_source_t)qword_100076628, 1uLL);
      }
    }
  }
}

void sub_1000442C4(const char *a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_100044138(a1, a2, a3, &a9, v9);
}

timeval *sub_1000442FC(int a1, const char *a2, __darwin_time_t a3, uint64_t a4)
{
  uint64_t v9 = (char *)sub_10001A904(0);
  int v10 = (timeval *)v9;
  if ((a1 & 0x10000) != 0 || (!byte_100076ABA ? (BOOL v11 = dword_100075A30 == -1) : (BOOL v11 = 1), v11)) {
    v9[20] = 1;
  }
  if ((a1 & 0x20000) != 0) {
    v9[23] = 1;
  }
  *(_WORD *)(v9 + 21) = 257;
  *((_DWORD *)v9 + 4) = (unsigned __int16)a1;
  if (a2) {
    long long v12 = sub_1000159F0(a2);
  }
  else {
    long long v12 = 0;
  }
  *(void *)&v10[1].tv_usec = v12;
  v10[3].tv_sec = a3;
  gettimeofday(v10 + 2, 0);
  if (!a4) {
    a4 = v4;
  }
  *(void *)&v10[3].tv_usec = a4;
  v10[4].tv_sec = os_log_simple_now();
  __uint64_t v14 = 0;
  pthread_threadid_np(0, &v14);
  *(void *)&v10[4].tv_usec = v14;
  return v10;
}

void sub_1000443F8(uint64_t a1, _DWORD *a2)
{
  if (*(unsigned char *)(a1 + 21))
  {
    if (dword_100075A30 == -1 || byte_100076A63 != 0)
    {
      int v5 = 0;
      if (!a2) {
        goto LABEL_12;
      }
LABEL_11:
      *a2 = v5;
      goto LABEL_12;
    }
    if (!(void)xmmword_100076690)
    {
      *(void *)&xmmword_100076690 = getpid();
      *(void *)&long long v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      long long buffer = 0u;
      pid_t v6 = getpid();
      proc_pidinfo(v6, 17, 0, &buffer, 56);
      *((void *)&xmmword_100076690 + 1) = v15;
      *(void *)&xmmword_1000766A0 = (int)v16;
      uuid_copy((unsigned __int8 *)&xmmword_1000766B0 + 8, (const unsigned __int8 *)&buffer);
      uuid_copy(byte_1000766C8, (const unsigned __int8 *)&buffer);
      uuid_clear((unsigned __int8 *)&xmmword_1000766D0 + 8);
      _dyld_get_shared_cache_uuid();
      qword_1000766E8 = (uint64_t)_NSGetMachExecuteHeader();
    }
    long long v18 = xmmword_1000766B0;
    long long v19 = unk_1000766C0;
    long long v20 = xmmword_1000766D0;
    uint64_t v21 = qword_1000766E0;
    long long buffer = xmmword_100076670;
    long long v15 = unk_100076680;
    long long v16 = xmmword_100076690;
    long long v17 = xmmword_1000766A0;
    LOBYTE(buffer) = os_log_simple_type_from_asl();
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    *((void *)&buffer + 1) = *(void *)(a1 + 24);
    *(void *)&long long v15 = v7;
    uint64_t v9 = *(void *)(a1 + 72);
    *((void *)&v15 + 1) = *(void *)(a1 + 64);
    *((void *)&v17 + 1) = v9;
    *(void *)&long long v18 = v8 - qword_1000766E8;
    int v5 = _os_log_simple_send();
    if (a2) {
      goto LABEL_11;
    }
  }
LABEL_12:
  int v10 = sub_1000446D8(a1);
  if (v10)
  {
    BOOL v11 = v10;
    if (*(unsigned char *)(a1 + 20)) {
      sub_10000FD44("%s|%s", off_100075A88, v10);
    }
    if (*(unsigned char *)(a1 + 23))
    {
      if (*(_DWORD *)(a1 + 16) < 8u)
      {
        if (record_system_event_as_kernel())
        {
          __error();
          sub_100043D78(3, "Unable to record system event. Result: %d errno: %d Message: %s");
        }
      }
      else
      {
        sub_100043D78(3, "Log level out of bounds for system state conversion: %d");
      }
    }
    if (*(unsigned char *)(a1 + 22))
    {
      long long v12 = (FILE *)qword_100076640;
      if (qword_100076640 || (long long v12 = sub_10003BB08(off_100075A70[0]), (qword_100076640 = (uint64_t)v12) != 0))
      {
        size_t v13 = strlen(v11);
        fwrite(v11, 1uLL, v13, v12);
        if (qword_100075AB8 >= 1)
        {
          qword_1000766F0 += v13;
          if (qword_1000766F0 >= qword_100075AB8)
          {
            sub_10003E6D4((FILE *)qword_100076640);
            qword_100076640 = 0;
            qword_1000766F0 = 0;
          }
        }
      }
    }
    free(v11);
  }
  else
  {
    sub_10000FB9C("_launch_log_format failed");
  }
}

char *sub_1000446D8(uint64_t a1)
{
  *(void *)__str = 0;
  uint64_t v5 = 0;
  memset(v6, 0, sizeof(v6));
  memset(&v3, 0, sizeof(v3));
  localtime_r((const time_t *)(a1 + 32), &v3);
  snprintf(__str, 0x1BuLL, "%04d-%02d-%02d %02d:%02d:%02d.%06d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday, v3.tm_hour, v3.tm_min, v3.tm_sec, *(_DWORD *)(a1 + 40));
  if (*(void *)(a1 + 24)) {
    return sub_100015BE4("%s (%s) <%s>: %s\n");
  }
  else {
    return sub_100015BE4("%s <%s>: %s\n");
  }
}

void *sub_1000447D8()
{
  return sub_100042478(0);
}

void sub_1000447E0(char *key, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!qword_100076AC0) {
    sub_100040E80("boot task dictionary is not populated");
  }
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100076AC0, key);
  if (!value) {
    sub_100040E80("undefined boot task %s", key);
  }
  long long v12 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100040E80("boot task %s is not a dictionary", key);
  }
  if (sub_1000448D8(key, v12))
  {
    sub_1000449E0(key, v12, a2, v13, v14, v15, v16, v17);
  }
  else
  {
    sub_1000442C4(key, 196613, "Skipping boot-task", v13, v14, v15, v16, v17, a9);
  }
}

uint64_t sub_1000448D8(const char *a1, xpc_object_t xdict)
{
  if (xpc_dictionary_get_BOOL(xdict, "PerformAlways")) {
    return 1;
  }
  if (!byte_100076A80 || (uint64_t result = xpc_dictionary_get_BOOL(xdict, "PerformAfterUserspaceReboot"), result))
  {
    BOOL v5 = xpc_dictionary_get_BOOL(xdict, "PerformInRestore");
    if (byte_100076A64) {
      BOOL v6 = !v5;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6) {
      return 0;
    }
    BOOL v7 = xpc_dictionary_get_BOOL(xdict, "PerformInLeanTestEnvironment");
    if (byte_100076A61 && !v7)
    {
      sub_100043D78(65543, "%s not set, Skipping boot-task: %s", "PerformInLeanTestEnvironment", a1);
      return 0;
    }
    LODWORD(result) = xpc_dictionary_get_BOOL(xdict, "PerformInBaseSystem");
    if (byte_100076A65) {
      return result;
    }
    else {
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000449E0(const char *a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000442C4(a1, 196613, "Doing boot task", a4, a5, a6, a7, a8, v67);
  sub_1000115B0(570425413, a1);
  if (xpc_dictionary_get_string(a2, "Block"))
  {
    if (xpc_dictionary_get_string(a2, "Program")) {
      sub_100050D0C();
    }
    if (xpc_dictionary_get_value(a2, "ProgramArguments")) {
      sub_100050D0C();
    }
    char string = (char *)xpc_dictionary_get_string(a2, "Block");
    if (!string) {
      sub_100040E80("Malformed boot-task (missing block key): %s", a1);
    }
    long long v12 = (void (**)(void))sub_1000295EC(string);
    v12[2]();
    _Block_release(v12);
    return sub_1000115B0(570425414, a1);
  }
  xpc_object_t value = xpc_dictionary_get_value(a2, "RebootOnExitCode");
  if (value)
  {
    uint64_t v15 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
    {
      int v16 = xpc_int64_get_value(v15);
      sub_100043D78(65543, "%s: will reboot if exits with code: %d", a1, v16);
    }
  }
  if (xpc_dictionary_get_BOOL(a2, "RemoveOnSuccess"))
  {
    uint64_t v17 = sub_1000459C0(a2);
    memset(&v73, 0, sizeof(v73));
    if (stat(v17, &v73)) {
      return sub_1000115B0(570425414, a1);
    }
  }
  *(_OWORD *)&v73.st_dev = *(_OWORD *)off_1000714D0;
  *(_OWORD *)&v73.st_uid = *(_OWORD *)&off_1000714E0;
  long long v18 = sub_1000459C0(a2);
  if (!v18) {
    sub_100040E80("boot task has no program");
  }
  long long v19 = v18;
  xpc_object_t v20 = xpc_dictionary_get_value(a2, "ProgramArguments");
  if (v20)
  {
    uint64_t v21 = v20;
    if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_array) {
      goto LABEL_105;
    }
    xpc_object_t v22 = xpc_retain(v21);
  }
  else
  {
    xpc_object_t v22 = xpc_array_create(0, 0);
  }
  char v23 = v22;
  if (!xpc_array_get_count(v22)) {
    xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v19);
  }
  if (xpc_dictionary_get_BOOL(a2, "PassLaunchBootModeAsArgument"))
  {
    uint64_t v24 = (const char *)sub_100003E88();
    if (v24) {
      xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v24);
    }
  }
  size_t count = xpc_array_get_count(v23);
  size_t v26 = count + 1;
  uint64_t v27 = count == -1;
  if (v27 << 63 >> 63 != v27 || v27 | (v26 >> 61))
  {
    __break(1u);
LABEL_105:
    sub_100040E80("boot task argument vector is not an array");
  }
  size_t v28 = count;
  uint64_t v29 = (char **)sub_100013BB8(8 * v26);
  if (v28)
  {
    for (size_t i = 0; i != v28; ++i)
    {
      uint64_t v31 = xpc_array_get_string(v23, i);
      if (v31) {
        v29[i] = (char *)v31;
      }
    }
  }
  posix_spawnattr_t v72 = 0;
  if (posix_spawnattr_init(&v72)) {
    sub_100050D28();
  }
  if (posix_spawnattr_setflags(&v72, 16524)) {
    sub_100050D28();
  }
  if ((a3 & 1) == 0)
  {
    xpc_dictionary_get_BOOL(a2, "AllowCrash");
    xpc_object_t v32 = xpc_dictionary_get_value(a2, "RebootOnExitCode");
    if (!v32 || xpc_get_type(v32) != (xpc_type_t)&_xpc_type_int64) {
      xpc_dictionary_get_BOOL(a2, "RequireSuccess");
    }
    if (posix_spawnattr_set_crash_behavior_np()) {
      sub_100050D28();
    }
  }
  if (posix_spawnattr_setprocesstype_np()) {
    sub_100050D28();
  }
  if (posix_spawnattr_set_launch_type_np()) {
    sub_100050D28();
  }
  sigset_t v71 = 0;
  if (posix_spawnattr_setsigmask(&v72, &v71)) {
    sub_100050D28();
  }
  sigset_t v70 = -1;
  if (posix_spawnattr_setsigdefault(&v72, &v70)) {
    sub_100050D28();
  }
  posix_spawn_file_actions_t v69 = 0;
  if (posix_spawn_file_actions_init(&v69) == -1) {
    sub_100050DFC();
  }
  if (posix_spawn_file_actions_addopen(&v69, 0, "/dev/console", 0x20000, 0) == -1) {
    sub_100050DFC();
  }
  if (posix_spawn_file_actions_addopen(&v69, 1, "/dev/console", 131073, 0) == -1) {
    sub_100050DFC();
  }
  if (posix_spawn_file_actions_addopen(&v69, 2, "/dev/console", 131074, 0) == -1) {
    sub_100050DFC();
  }
  task_t v33 = mach_host_self();
  mach_port_t v34 = sub_10000D8D4(v33);
  task_t v35 = mach_host_self();
  sub_100045844(v35, 0);
  if ((a3 & 4) != 0)
  {
    if (qword_100076700)
    {
      uint64_t v75 = 0;
      mach_mach_port_t port = _xpc_shmem_get_mach_port();
      if (posix_spawnattr_set_registered_ports_np() == -1) {
        sub_100050DFC();
      }
    }
    else
    {
      sub_100043D78(65539, "Skipping setting up shared memory with cache loader");
    }
  }
  pid_t v68 = 0;
  int v36 = posix_spawnp(&v68, v19, &v69, &v72, v29, (char *const *)&v73);
  if (posix_spawn_file_actions_destroy(&v69) == -1) {
    sub_100050DFC();
  }
  if (posix_spawnattr_destroy(&v72) == -1) {
    sub_100050DFC();
  }
  free(v29);
  xpc_release(v23);
  task_t v37 = mach_host_self();
  sub_100045844(v37, v34);
  if (v36)
  {
    BOOL v43 = (a3 & 1) == 0 && xpc_dictionary_get_BOOL(a2, "RequireRun");
    if (v36 != 2)
    {
      strerror(v36);
      sub_1000442C4(a1, 196611, "posix_spawn(): %d: %s", v53, v54, v55, v56, v57, v36);
      if (!v43) {
        return sub_1000115B0(570425414, a1);
      }
      memset(&v73, 0, 64);
      uint64_t v58 = strerror(v36);
      snprintf((char *)&v73, 0x40uLL, "posix_spawn: %d: %s", v36, v58);
      uint64_t v52 = (const char *)&v73;
LABEL_70:
      sub_1000458F4(a1, v52);
    }
    if (v43) {
      int v50 = 196611;
    }
    else {
      int v50 = 196613;
    }
    uint64_t v51 = "optional";
    if (v43) {
      uint64_t v51 = "required";
    }
    sub_1000442C4(a1, v50, "%s boot task not present", v38, v39, v40, v41, v42, (char)v51);
    if (v43)
    {
      uint64_t v52 = "required boot task executable not found";
      goto LABEL_70;
    }
  }
  else
  {
    uint64_t v44 = v68;
    uint64_t v45 = xpc_dictionary_get_string(a2, "CSIdentityOverride");
    mach_mach_port_t port = 0;
    if (csops() || (mach_port & 0x4000000) == 0)
    {
      xpc_object_t v64 = sub_1000459C0(a2);
      sub_100040EE4("boot task is not a platform binary (%s, %s)", a1, v64);
    }
    *__error() = 0;
    uint64_t v46 = sub_100042530(v44, 0);
    uint64_t v47 = sub_1000459C0(a2);
    uint64_t v48 = v47;
    if (!v46)
    {
      uint64_t v65 = __error();
      sub_100040E80("failed to get the code signing identity for a boot-task (%s, %s) errno: %d", a1, v48, *v65);
    }
    if (v45)
    {
      unsigned int v49 = sub_1000159F0(v45);
    }
    else
    {
      uint64_t v59 = strrchr(v47, 47);
      if (v59) {
        xpc_object_t v60 = v59 + 1;
      }
      else {
        xpc_object_t v60 = v48;
      }
      unsigned int v49 = sub_100015BE4("com.apple.%s", v60);
    }
    char v61 = v49;
    if (!v49) {
      sub_100050D0C();
    }
    if (strcmp(v49, v46))
    {
      uint64_t v66 = sub_1000459C0(a2);
      sub_100040EE4("code signing identity mismatch for a boot-task (%s, %s) observed=%s expected=%s", a1, v66, v46, v61);
    }
    free(v46);
    free(v61);
    if (kill(v68, 19) == -1 && *__error()) {
      sub_100050D28();
    }
    int64_t v62 = v68;
    if (xpc_dictionary_get_BOOL(a2, "Async"))
    {
      if (a3) {
        sub_100040E80("Async boot task %s must not have flags", a1);
      }
      xpc_object_t empty = (xpc_object_t)qword_1000769F8;
      if (!qword_1000769F8)
      {
        xpc_object_t empty = xpc_dictionary_create_empty();
        qword_1000769F8 = (uint64_t)empty;
      }
      xpc_dictionary_set_int64(empty, a1, v62);
    }
    else
    {
      sub_100045A54(a1, a2, a3, v62);
    }
  }
  return sub_1000115B0(570425414, a1);
}

void sub_10004519C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000447E0("exclaves-boot", 0, a3, a4, a5, a6, a7, a8, v183);
  bzero(&v211, 0x878uLL);
  if (statfs("/", &v211) == -1)
  {
    __error();
    _os_assumes_log();
  }
  else if (v211.f_flags)
  {
    sub_1000447E0("fsck", 0, v8, v9, v10, v11, v12, v13, v184);
  }
  sub_1000447E0("mount-phase-1", 0, v8, v9, v10, v11, v12, v13, v184);
  sub_1000447E0("data-protection", 0, v14, v15, v16, v17, v18, v19, v185);
  sub_1000447E0("finish-obliteration", 0, v20, v21, v22, v23, v24, v25, v186);
  sub_1000447E0("detect-installed-roots", 0, v26, v27, v28, v29, v30, v31, v187);
  sub_1000447E0("select-boot-mode", 0, v32, v33, v34, v35, v36, v37, v188);
  sub_1000447E0("commit-boot-mode", 0, v38, v39, v40, v41, v42, v43, v189);
  if (sub_100030A38()) {
    sub_1000447E0("rem-enable-fuse", 0, v44, v45, v46, v47, v48, v49, v190);
  }
  sub_1000447E0("restore-datapartition", 0, v44, v45, v46, v47, v48, v49, v190);
  sub_1000447E0("mount-phase-2", 0, v50, v51, v52, v53, v54, v55, v191);
  sub_1000447E0("init-with-data-volume", 0, v56, v57, v58, v59, v60, v61, v192);
  sub_1000447E0("fixup-mobile-tmp", 0, v62, v63, v64, v65, v66, v67, v193);
  sub_1000447E0("MSUEarlyBootTask", 0, v68, v69, v70, v71, v72, v73, v194);
  sub_1000447E0("fips", 0, v74, v75, v76, v77, v78, v79, v195);
  if (os_variant_is_darwinos()) {
    sub_1000447E0("darwinos-boot-task", 0, v80, v81, v82, v83, v84, v85, v196);
  }
  sub_1000447E0("keybag", 0, v80, v81, v82, v83, v84, v85, v196);
  sub_1000447E0("usermanagerd", 0, v86, v87, v88, v89, v90, v91, v197);
  sub_1000447E0("dirs_cleaner", 0, v92, v93, v94, v95, v96, v97, v198);
  sub_100043A1C();
  if (!(byte_100076A64 | byte_100076A65)) {
    nullsub_23(v98, v99);
  }
  sub_1000447E0("xpcroleaccountd", 0, v100, v101, v102, v103, v104, v105, v199);
  sub_1000447E0("init_featureflags", 0, v106, v107, v108, v109, v110, v111, v200);
  j__libSystem_init_after_boot_tasks_4launchd();
  if (!byte_100076A64 && !byte_100076A65 && !byte_100076A80)
  {
    int v118 = ne_session_initialize_necp_drop_all();
    if (v118)
    {
      int v119 = v118;
      uint64_t v120 = strerror(v118);
      sub_100043D78(65539, "Could not opt into Always-On VPN: %d: %s", v119, v120);
    }
  }
  sub_1000447E0("auearlyboot", 0, v112, v113, v114, v115, v116, v117, v201);
  sub_1000447E0("tzinit", 0, v121, v122, v123, v124, v125, v126, v202);
  sub_1000447E0("finish-restore", 0, v127, v128, v129, v130, v131, v132, v203);
  sub_1000447E0("finish-demo-restore", 0, v133, v134, v135, v136, v137, v138, v204);
  sub_10004AC2C();
  sub_1000447E0("sysstatuscheck", 0, v139, v140, v141, v142, v143, v144, v205);
  sub_1000447E0("prng_seedctl", 0, v145, v146, v147, v148, v149, v150, v206);
  if (!byte_100076A64)
  {
    char v207 = -74;
    uint64_t v151 = (int *)open("/var/run/utmpx", 512);
    if (v151 != -1) {
      sub_10003E54C(v151);
    }
    remove((const std::__fs::filesystem::path *)"/etc/nologin", v152);
  }
  xpc_object_t v153 = sub_1000196B4();
  uint64_t v160 = v153;
  if (v153)
  {
    bytes_ptr = (void *)xpc_data_get_bytes_ptr(v153);
    size_t length = xpc_data_get_length(v160);
    xpc_object_t v163 = xpc_shmem_create(bytes_ptr, (length + vm_page_size - 1) & -(uint64_t)vm_page_size);
    if (!v163) {
      sub_100050D0C();
    }
    qword_100076700 = (uint64_t)v163;
  }
  sub_1000447E0("launchd_cache_loader", 4, v154, v155, v156, v157, v158, v159, v207);
  uint64_t v165 = qword_100076700;
  if (qword_100076700)
  {
    xpc_release((xpc_object_t)qword_100076700);
    qword_100076700 = 0;
  }
  nullsub_23(v165, v164);
  sub_1000447E0("workload-properties-init", 0, v166, v167, v168, v169, v170, v171, v208);
  sub_1000447E0("init-exclavekit", 0, v172, v173, v174, v175, v176, v177, v209);
  if (qword_1000769F8)
  {
    xpc_dictionary_apply((xpc_object_t)qword_1000769F8, &stru_100071550);
    xpc_release((xpc_object_t)qword_1000769F8);
    qword_1000769F8 = 0;
  }
  sub_1000197EC(v160);
  if (v160) {
    xpc_release(v160);
  }
  sub_1000442C4("boot", 196613, "Early boot complete. Continuing system boot.", v178, v179, v180, v181, v182, v210);
  sub_10002FCD8();
  sub_100041E98();
}

void sub_10004559C()
{
  if (!byte_100076A80 && sysctlbyname("kern.hostname", 0, 0, "localhost", 0xAuLL) == -1) {
    sub_100050DFC();
  }
  sub_100010FCC();
  if (!byte_100076A80)
  {
    long long v5 = 0u;
    long long v6 = 0u;
    LODWORD(v5) = 3174252;
    unint64_t v0 = (int *)socket(2, 2, 0);
    if (v0 == -1)
    {
      sub_100050E38();
    }
    else
    {
      uint64_t v1 = v0;
      if (ioctl((int)v0, 0xC0206911uLL, &v5) == -1) {
        goto LABEL_17;
      }
      LOWORD(v6) = v6 | 1;
      if (ioctl((int)v1, 0x80206910uLL, &v5) == -1) {
        goto LABEL_17;
      }
      memset((char *)&v7[1] + 4, 0, 32);
      *(_OWORD *)((char *)v7 + 4) = 0u;
      *((void *)&v7[3] + 1) = 0;
      strcpy((char *)v7, "lo0");
      DWORD1(v7[1]) = 16777343;
      LOWORD(v7[1]) = 528;
      DWORD1(v7[3]) = 255;
      LOWORD(v7[3]) = 528;
      if (ioctl((int)v1, 0x8040691AuLL, v7) == -1) {
LABEL_17:
      }
        sub_1000519A0(v1);
      else {
        sub_10003E54C(v1);
      }
    }
    if (!byte_100076A80)
    {
      uint64_t v2 = (int *)socket(30, 2, 0);
      if (v2 == -1)
      {
        sub_100050E38();
      }
      else
      {
        tm v3 = v2;
        long long v5 = 0u;
        long long v6 = 0u;
        LODWORD(v5) = 3174252;
        if (ioctl((int)v2, 0xC0206911uLL, &v5) == -1) {
          goto LABEL_19;
        }
        memset(v7, 0, sizeof(v7));
        long long v8 = 0u;
        long long v9 = 0u;
        uint64_t v11 = 0;
        long long v10 = 0u;
        strcpy((char *)v7, "lo0");
        *(in6_addr *)((char *)&v7[1] + 8) = in6addr_loopback;
        LOWORD(v7[1]) = 7708;
        *(void *)&long long v9 = -1;
        *((void *)&v9 + 1) = -1;
        WORD4(v8) = 7708;
        uint64_t v12 = -1;
        if (ioctl((int)v3, 0x8080691AuLL, v7) != -1) {
          goto LABEL_14;
        }
        if (*__error() != 17) {
LABEL_19:
        }
          sub_1000519A0(v3);
        else {
LABEL_14:
        }
          sub_10003E54C(v3);
      }
    }
  }
  uint64_t v4 = sub_100014B58();
  dispatch_async(v4, &stru_100071510);
}

uint64_t sub_100045844(task_t a1, mach_port_t new_port)
{
  if (byte_100076AB8) {
    exception_mask_t v3 = 7168;
  }
  else {
    exception_mask_t v3 = 10240;
  }
  if (mach_task_self_ == a1)
  {
    return task_set_exception_ports(a1, v3, new_port, -1610612732, 1);
  }
  else
  {
    mach_port_t v5 = mach_host_self();
    return host_set_exception_ports(v5, v3, new_port, -1610612732, 1);
  }
}

void sub_1000458EC(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
}

void sub_1000458F4(const char *a1, const char *a2)
{
  if (a2) {
    uint64_t v2 = sub_100015BE4("%s - %s", a1, a2);
  }
  else {
    uint64_t v2 = sub_1000159F0(a1);
  }
  exception_mask_t v3 = v2;
  long long v6 = 0u;
  long long v7 = 0u;
  *(_OWORD *)__str = 0u;
  long long v5 = 0u;
  snprintf(__str, 0x40uLL, "boot task failure: %s", v2);
  pthread_setname_np(__str);
  sub_100043D78(196608, "Boot task failed: %s", v3);
  sub_100043D78(196608, "Panicking in 3 seconds.");
  sleep(3u);
  sub_100040EE4("boot task failure: %s", v3);
}

uint64_t sub_100045990(uint64_t result)
{
  dword_1000766F8 = result;
  return result;
}

uint64_t sub_10004599C()
{
  return dword_1000766F8;
}

uint64_t sub_1000459A8(uint64_t result)
{
  byte_1000766FC = result;
  return result;
}

uint64_t sub_1000459B4()
{
  return byte_1000766FC;
}

char *sub_1000459C0(void *a1)
{
  uint64_t result = (char *)xpc_dictionary_get_string(a1, "Program");
  if (!result)
  {
    uint64_t result = (char *)xpc_dictionary_get_value(a1, "ProgramArguments");
    if (result)
    {
      exception_mask_t v3 = result;
      if (xpc_get_type(result) == (xpc_type_t)&_xpc_type_array)
      {
        uint64_t result = (char *)xpc_array_get_count(v3);
        if (result)
        {
          return (char *)xpc_array_get_string(v3, 0);
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void sub_100045A54(const char *a1, void *a2, char a3, pid_t pid)
{
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  memset(v37, 0, sizeof(v37));
  long long v7 = sub_10004680C((uint64_t)v35, pid, (uint64_t)v37);
  if (LODWORD(v35[0]) != 3)
  {
    uint64_t v32 = sub_1000459C0(a2);
    sub_100040E80("failed to reap boot-task (%s, %s)", a1, v32);
  }
  long long v8 = v7;
  if (a3)
  {
    BOOL v11 = 0;
    BOOL v10 = 0;
    BOOL v9 = 0;
  }
  else
  {
    BOOL v9 = xpc_dictionary_get_BOOL(a2, "RequireSuccess");
    BOOL v10 = xpc_dictionary_get_BOOL(a2, "RebootOnSuccess");
    BOOL v11 = xpc_dictionary_get_BOOL(a2, "AssumeSingleUserSuccess");
    xpc_object_t value = xpc_dictionary_get_value(a2, "RebootOnExitCode");
    if (value)
    {
      uint64_t v13 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
      {
        int v14 = xpc_int64_get_value(v13);
        goto LABEL_8;
      }
    }
  }
  int v14 = -1;
LABEL_8:
  BOOL v15 = sub_100046EEC((uint64_t)v35) && sub_100046F18(v35) == 0;
  if (xpc_dictionary_get_BOOL(a2, "RemoveOnSuccess"))
  {
    uint64_t v16 = sub_1000459C0(a2);
    if (v16 && v15)
    {
      uint64_t v18 = (const std::__fs::filesystem::path *)v16;
      sub_100043D78(65543, "%s: exited successfully, removing", a1);
      if (remove(v18, v19) == -1 && *__error() != 2 && *__error()) {
        _os_assumes_log();
      }
    }
  }
  if (sub_100046EEC((uint64_t)v35) && sub_100046F18(v35) == v14)
  {
    char v34 = v14;
    uint64_t v33 = "rebooting on exit code: %d";
LABEL_37:
    sub_1000442C4(a1, 196615, v33, v20, v21, v22, v23, v24, v34);
    sub_100043254(1, 0, 0);
  }
  if (v15)
  {
    int v25 = 1;
  }
  else
  {
    if (sub_100046EEC((uint64_t)v35)) {
      int v31 = 196615;
    }
    else {
      int v31 = 196611;
    }
    sub_1000442C4(a1, v31, "exited due to %s", v26, v27, v28, v29, v30, (char)v8);
    if (byte_100076A62) {
      int v25 = v11;
    }
    else {
      int v25 = 0;
    }
    if ((v25 & 1) == 0 && v9)
    {
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)__str = 0u;
      long long v39 = 0u;
      snprintf(__str, 0x80uLL, "exited due to %s", v8);
      sub_1000458F4(a1, __str);
    }
  }
  if ((v10 & v25) == 1)
  {
    uint64_t v33 = "rebooting after success";
    goto LABEL_37;
  }
  free(v8);
}

BOOL sub_100045D80(id a1, const char *a2, void *a3)
{
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100076AC0, a2);
  LODWORD(a3) = xpc_int64_get_value(a3);
  sub_100043D78(196615, "waiting for boot-task %s with pid %d", a2, a3);
  sub_100045A54(a2, value, 0, (pid_t)a3);
  return 1;
}

uint64_t sub_100045E04(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return strcmp(*(const char **)(a2 + 24), *(const char **)(a3 + 24));
}

uint64_t sub_100045E10(int a1, uint64_t a2, char *__s2)
{
  return strcmp(*(const char **)(a2 + 24), __s2);
}

void sub_100045E1C(uint64_t a1, const void *a2, void *a3)
{
  if (*(_DWORD *)(a1 + 24) == 4981)
  {
    node = (void **)rb_tree_find_node(*(rb_tree_t **)(a1 + 16), a2);
    if (node)
    {
      long long v7 = node;
      rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), node);
      os_release(v7[4]);
      free(v7[3]);
      free(v7);
    }
    if (a3)
    {
      long long v8 = sub_100013BB8(0x28uLL);
      _OWORD v8[3] = sub_1000159F0((const char *)a2);
      v8[4] = os_retain(a3);
      if (rb_tree_insert_node(*(rb_tree_t **)(a1 + 16), v8) != v8) {
        sub_100050D0C();
      }
    }
  }
  else
  {
    __break(1u);
  }
}

rb_tree_t **sub_100045ED4(rb_tree_t **result, const void *a2)
{
  if (*((_DWORD *)result + 6) == 4981)
  {
    uint64_t result = (rb_tree_t **)rb_tree_find_node(result[2], a2);
    if (result) {
      return (rb_tree_t **)result[4];
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

rb_tree_t **sub_100045F0C(rb_tree_t **result, uint64_t a2)
{
  if (*((_DWORD *)result + 6) == 4981)
  {
    exception_mask_t v3 = result;
    uint64_t result = (rb_tree_t **)rb_tree_iterate(result[2], 0, 1u);
    if (result)
    {
      uint64_t v4 = result;
      do
      {
        (*(void (**)(uint64_t, rb_tree_t *, rb_tree_t *))(a2 + 16))(a2, v4[3], v4[4]);
        uint64_t result = (rb_tree_t **)rb_tree_iterate(v3[2], v4, 1u);
        uint64_t v4 = result;
      }
      while (result);
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

size_t sub_100045F90(size_t result)
{
  if (*(_DWORD *)(result + 24) == 4981) {
    return rb_tree_count(*(rb_tree_t **)(result + 16));
  }
  __break(1u);
  return result;
}

void *sub_100045FAC()
{
  unint64_t v0 = sub_10001A658(0);
  uint64_t v1 = (rb_tree_t *)sub_100013BB8(0x40uLL);
  v0[2] = v1;
  rb_tree_init(v1, (const rb_tree_ops_t *)&off_100075A38);
  *((_DWORD *)v0 + 6) = 4981;
  return v0;
}

void sub_100045FF8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 24) == 4981)
  {
    *(_DWORD *)(a1 + 24) = 0;
    uint64_t v2 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), 0, 1u);
    if (v2)
    {
      exception_mask_t v3 = v2;
      do
      {
        uint64_t v4 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), v3, 1u);
        rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), v3);
        os_release(v3[4]);
        free(v3[3]);
        free(v3);
        exception_mask_t v3 = v4;
      }
      while (v4);
    }
    long long v5 = *(void **)(a1 + 16);
    free(v5);
  }
  else
  {
    __break(1u);
  }
}

void sub_1000460A4()
{
  if (xpc_make_serialization()) {
    sub_100050D0C();
  }
  sub_100050D0C();
}

uint64_t sub_100046114()
{
  uint64_t result = xpc_create_from_serialization();
  if (!result) {
    sub_100050D0C();
  }
  return result;
}

void sub_100046140(uint64_t a1, const void *a2, void *a3)
{
  long long v6 = sub_100045ED4(*(rb_tree_t ***)(a1 + 16), a2);
  xpc_object_t v7 = v6;
  if (!v6)
  {
    if (sub_100045F90(*(void *)(a1 + 16)) >= *(void *)(a1 + 24))
    {
      v17[0] = 0;
      v17[1] = v17;
      v17[2] = 0x2000000000;
      v17[3] = -1;
      uint64_t v13 = 0;
      int v14 = &v13;
      uint64_t v15 = 0x2000000000;
      uint64_t v16 = 0;
      long long v8 = *(rb_tree_t ***)(a1 + 16);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = sub_1000464D4;
      v12[3] = &unk_100071598;
      void v12[4] = v17;
      void v12[5] = &v13;
      sub_100045F0C(v8, (uint64_t)v12);
      char string = xpc_dictionary_get_string((xpc_object_t)v14[3], "key");
      pointer = (void *)xpc_dictionary_get_pointer();
      (*(void (**)(const char *, void *))(a1 + 40))(string, pointer);
      sub_100045E1C(*(void *)(a1 + 16), string, 0);
      os_release(pointer);
      if (sub_100045F90(*(void *)(a1 + 16)) >= *(void *)(a1 + 24)) {
        sub_100050D0C();
      }
      _Block_object_dispose(&v13, 8);
      _Block_object_dispose(v17, 8);
    }
    xpc_object_t v7 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v7, "key", (const char *)a2);
  }
  os_retain(a3);
  xpc_dictionary_set_pointer();
  uint64_t v11 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = v11 + 1;
  xpc_dictionary_set_uint64(v7, "timestamp", v11);
  if (!v6)
  {
    sub_100045E1C(*(void *)(a1 + 16), a2, v7);
    xpc_release(v7);
  }
}

rb_tree_t **sub_100046328(uint64_t a1, const void *a2)
{
  uint64_t result = sub_100045ED4(*(rb_tree_t ***)(a1 + 16), a2);
  if (result)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(void *)(a1 + 32) = v4 + 1;
    xpc_dictionary_set_uint64(result, "timestamp", v4);
    pointer = (void *)xpc_dictionary_get_pointer();
    return (rb_tree_t **)os_retain(pointer);
  }
  return result;
}

void *sub_10004639C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10001AA24(0);
  void v4[2] = sub_100045FAC();
  v4[3] = a1;
  v4[4] = 1;
  v4[5] = a2;
  return v4;
}

void sub_1000463E8(uint64_t a1)
{
  uint64_t v2 = *(rb_tree_t ***)(a1 + 16);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10004646C;
  v3[3] = &unk_100071570;
  _OWORD v3[4] = a1;
  sub_100045F0C(v2, (uint64_t)v3);
  os_release(*(void **)(a1 + 16));
}

void sub_10004646C(uint64_t a1, uint64_t a2)
{
  pointer = (void *)xpc_dictionary_get_pointer();
  (*(void (**)(uint64_t, void *))(*(void *)(a1 + 32) + 40))(a2, pointer);

  os_release(pointer);
}

uint64_t sub_1000464D4(uint64_t a1, int a2, xpc_object_t object)
{
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100050D0C();
  }
  uint64_t result = xpc_dictionary_get_uint64(object, "timestamp");
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (result < *(void *)(v6 + 24))
  {
    *(void *)(v6 + 24) = result;
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = object;
  }
  return result;
}

uint64_t sub_100046548(void *a1, void *a2, uint64_t a3)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, "shmem");
  if (!value) {
    return 22;
  }
  regiounint64_t n = 0;
  vm_size_t v7 = xpc_shmem_map(value, &region);
  if (region) {
    BOOL v8 = v7 >= vm_page_size;
  }
  else {
    BOOL v8 = 0;
  }
  if (v8)
  {
    BOOL v10 = fmemopen(region, v7, "w");
    if (v10)
    {
      uint64_t v11 = v10;
      (*(void (**)(uint64_t, FILE *))(a3 + 16))(a3, v10);
      unint64_t v12 = ftello(v11);
      if (v12 <= 0x40000000)
      {
        uint64_t v13 = v12;
        xpc_object_t reply = xpc_dictionary_create_reply(a1);
        *a2 = reply;
        xpc_dictionary_set_uint64(reply, "bytes-written", v13);
        uint64_t v9 = 0;
      }
      else
      {
        uint64_t v9 = 153;
      }
      sub_10003E6D4(v11);
    }
    else
    {
      if (*__error()) {
        _os_assumes_log();
      }
      uint64_t v9 = 9;
    }
  }
  else
  {
    if (*__error()) {
      _os_assumes_log();
    }
    uint64_t v9 = 22;
  }
  if (region)
  {
    if (!v7) {
      sub_100050D0C();
    }
    munmap(region, v7);
  }
  return v9;
}

uint64_t sub_100046694(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v8 = a2;
    uint64_t v9 = (FILE *)result;
    do
    {
      uint64_t result = sub_1000466E4(v9, "\t", a3, a4, a5, a6, a7, a8, v10);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t sub_1000466E4(FILE *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vfprintf(a1, a2, &a9);
}

uint64_t sub_100046710(FILE *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if (a2)
  {
    uint64_t v10 = a2;
    do
    {
      sub_1000466E4(a1, "\t", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
      --v10;
    }
    while (v10);
  }
  return vfprintf(a1, a3, va);
}

uint64_t sub_100046780(FILE *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  if (a2)
  {
    uint64_t v10 = a2;
    do
    {
      sub_1000466E4(a1, "\t", (uint64_t)a3, a4, a5, a6, a7, a8, v18);
      --v10;
    }
    while (v10);
  }
  vfprintf(a1, a3, va);
  return sub_1000466E4(a1, "\n", v11, v12, v13, v14, v15, v16, v18);
}

uint64_t sub_100046800(FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_1000466E4(a1, "\n", a3, a4, a5, a6, a7, a8, a9);
}

char *sub_10004680C(uint64_t a1, pid_t pid, uint64_t a3)
{
  *(void *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  uint32_t flags = 0;
  if (j__proc_get_dirty(pid, &flags)) {
    _os_assumes_log();
  }
  *(unsigned char *)(a1 + 48) = *(unsigned char *)(a1 + 48) & 0xFC | flags & 2 | ((flags & 4) != 0);
  uint64_t v6 = (_DWORD *)(a1 + 4);
  if (j__proc_pidinfo(pid, 25, 1uLL, (void *)(a1 + 4), 24) != 24 && *__error() != 2 && *__error()) {
    _os_assumes_log();
  }
  if (j__proc_pid_rusage(pid, 6, (rusage_info_t *)a3)) {
    _os_assumes_log();
  }
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a3 + 80);
  if ((*(unsigned char *)(a1 + 48) & 3) == 2 && *v6 == 1)
  {
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != 2 && v7 != 7) {
      *(void *)(a1 + 8) = 9;
    }
  }
  size_t v8 = *(unsigned int *)(a1 + 24);
  if (v8 >= 0x1401) {
    sub_100040E80("retrieved exit reason with invalid reason buffer size");
  }
  if (v8)
  {
    uint64_t v9 = sub_100013BB8(0x20uLL);
    *((void *)v9 + 3) = sub_100013BB8(v8);
    v9[5] = v8;
    if (proc_pidinfo(pid, 24, 1uLL, v9, 32) == 32) {
      goto LABEL_21;
    }
    if (*__error()) {
      _os_assumes_log();
    }
    free(*((void **)v9 + 3));
    free(v9);
  }
  uint64_t v9 = 0;
LABEL_21:
  if (sub_1000437A4(pid, (int *)(a1 + 28), 0, 0))
  {
    _os_assumes_log();
    int v10 = 2;
  }
  else
  {
    int v10 = 3;
  }
  *(_DWORD *)a1 = v10;
  if (!v9)
  {
LABEL_63:
    uint64_t v38 = sub_100046DC4(a1);
    if (!v38) {
      uint64_t v38 = "(unknown reason)";
    }
    char v34 = sub_1000159F0(v38);
    goto LABEL_66;
  }
  uint64_t v11 = (char *)sub_100046DC4(a1);
  uint64_t v12 = (int *)*((void *)v9 + 3);
  if (!v12) {
    goto LABEL_30;
  }
  uint64_t v13 = v9[5];
  if (!v13) {
    goto LABEL_30;
  }
  unint64_t v14 = (unint64_t)v12 + v13;
  uint64_t v15 = v12 + 4;
  if (v12 + 4 <= (int *)((char *)v12 + v13))
  {
    unint64_t v16 = *((void *)v9 + 3);
    do
    {
      unint64_t v42 = (unint64_t)v15 + *(unsigned int *)(v16 + 4);
      if (v42 > v14 || *(_DWORD *)v16 == -242132755) {
        break;
      }
      if (*(_DWORD *)v16 == 4098) {
        goto LABEL_28;
      }
      uint64_t v15 = (_DWORD *)(v42 + 16);
      unint64_t v16 = v42;
    }
    while (v42 + 16 <= v14);
  }
  unint64_t v16 = 0;
  unint64_t v14 = 0;
LABEL_28:
  if (v16 + 16 > v14 || (uint64_t v17 = *(unsigned int *)(v16 + 4), v16 + 16 + v17 > v14))
  {
LABEL_30:
    char v18 = 0;
    goto LABEL_31;
  }
  int v43 = *(_DWORD *)v16;
  if ((*(_DWORD *)v16 & 0xFFFFFFF0) == 0x20) {
    int v43 = 17;
  }
  if (v43 <= 2309)
  {
    if (v43 == 17 || v43 == 19) {
      goto LABEL_97;
    }
    goto LABEL_94;
  }
  if (v43 != 2312)
  {
    if (v43 == 2310 && v17 == 112 && (*(unsigned char *)(v16 + 8) & 0x8F) == 0)
    {
      LODWORD(v17) = 104;
      goto LABEL_97;
    }
LABEL_94:
    unsigned int v45 = *(_DWORD *)(v16 + 8) & 0xF;
    BOOL v28 = v17 >= v45;
    int v46 = v17 - v45;
    if (v28) {
      LODWORD(v17) = v46;
    }
    else {
      LODWORD(v17) = 0;
    }
    goto LABEL_97;
  }
  if (v17 != 32 || (*(unsigned char *)(v16 + 8) & 0x8F) != 0) {
    goto LABEL_94;
  }
  LODWORD(v17) = 24;
LABEL_97:
  uint64_t v47 = (char *)(v16 + 16);
  if (strnlen((const char *)(v16 + 16), v17) >= v17) {
    char v18 = 0;
  }
  else {
    char v18 = v47;
  }
LABEL_31:
  uint64_t v19 = 0;
  v50[0] = 0;
  if (*v9 == 2)
  {
    unint64_t v20 = (unint64_t)v12 + v9[5];
    uint64_t v21 = v12 + 4;
    if ((unint64_t)(v12 + 4) > v20) {
      goto LABEL_33;
    }
    uint64_t v48 = v18;
    uint64_t v22 = 0;
    int v23 = -1;
    do
    {
      uint64_t v24 = v12[1];
      int v25 = (_DWORD *)((char *)v21 + v24);
      if ((unint64_t)v21 + v24 > v20) {
        break;
      }
      int v26 = *v12;
      if (*v12 == -242132755) {
        break;
      }
      if ((v26 & 0xFFFFFFF0) == 0x20) {
        int v26 = 17;
      }
      if (v26 == 54)
      {
        unsigned int v31 = v12[2] & 0xF;
        BOOL v28 = v24 >= v31;
        int v32 = v24 - v31;
        if (!v28) {
          int v32 = 0;
        }
        if (v32 != 4) {
          sub_100040E80("PID size for exit reason mismatch");
        }
        int v23 = v12[4];
      }
      else if (v26 == 55)
      {
        unsigned int v27 = v12[2] & 0xF;
        BOOL v28 = v24 >= v27;
        unsigned int v29 = v24 - v27;
        size_t v30 = v28 ? v29 : 0;
        uint64_t v22 = v12 + 4;
        if (strnlen((const char *)v12 + 16, v30) >= v30) {
          sub_100040E80("kernel returned invalid sender procname for signal");
        }
      }
      uint64_t v21 = v25 + 4;
      uint64_t v12 = v25;
    }
    while ((unint64_t)(v25 + 4) <= v20);
    char v18 = v48;
    if (!v22 || v23 == -1) {
LABEL_33:
    }
      asprintf(v50, "(signal info malformed)");
    else {
      asprintf(v50, "sent by %s[%d]");
    }
    uint64_t v19 = v50[0];
    uint64_t v6 = (_DWORD *)(a1 + 4);
  }
  uint64_t v33 = 0;
  char v34 = 0;
  v50[0] = v11;
  v50[1] = v18;
  v50[2] = v19;
  do
  {
    uint64_t v35 = v50[v33];
    if (v35)
    {
      if (v34) {
        uint64_t v36 = sub_100015BE4("%s | %s", v34, v35);
      }
      else {
        uint64_t v36 = sub_1000159F0(v35);
      }
      uint64_t v37 = v36;
      free(v34);
      char v34 = v37;
    }
    ++v33;
  }
  while (v33 != 3);
  free(v19);
  free(*((void **)v9 + 3));
  free(v9);
  if (!v34) {
    goto LABEL_63;
  }
LABEL_66:
  int v39 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 3)
  {
    if (*v6 || (*(unsigned char *)(a1 + 28) & 0x7F) != 0) {
      return v34;
    }
    free(v34);
    int v40 = sub_100046F18((_DWORD *)a1);
    char v34 = sub_100015BE4("exit(%d)", v40);
    int v39 = *(_DWORD *)a1;
  }
  if (!v39) {
    sub_100050D0C();
  }
  return v34;
}

const char *sub_100046DC4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)a1 != 3 || v2 != 0)
  {
    switch(v2)
    {
      case 0:
        if (*(_DWORD *)a1 != 3) {
          goto LABEL_16;
        }
        int v4 = *(_DWORD *)(a1 + 28) & 0x7F;
        goto LABEL_9;
      case 1:
        goto LABEL_13;
      case 2:
        goto LABEL_11;
      case 7:
        uint64_t result = (const char *)xpc_exit_reason_get_label();
        if (!result) {
          goto LABEL_16;
        }
        return result;
      case 9:
        uint64_t v7 = &unk_1000715B8;
        uint64_t v8 = *(void *)(a1 + 8);
        uint64_t v9 = 1;
        goto LABEL_20;
      default:
        goto LABEL_16;
    }
  }
  int v4 = *(_DWORD *)(a1 + 28) & 0x7F;
  if (!v4) {
    return "exit()";
  }
LABEL_9:
  if (!v4 || v4 == 127) {
    goto LABEL_16;
  }
LABEL_11:
  int v5 = sub_10004700C((_DWORD *)a1);
  uint64_t result = (const char *)sub_100043234(v5);
  if (result) {
    return result;
  }
  if (v2 != 1)
  {
LABEL_16:
    return (const char *)sub_100043244(v2);
  }
LABEL_13:
  uint64_t v7 = &unk_1000715C8;
  LODWORD(v8) = v1;
  uint64_t v9 = 3;
LABEL_20:
  uint64_t result = (const char *)sub_100015F0C(v8, (uint64_t)v7, v9);
  if (!result) {
    goto LABEL_16;
  }
  return result;
}

BOOL sub_100046EEC(uint64_t a1)
{
  return *(_DWORD *)a1 == 3 && !*(_DWORD *)(a1 + 4) && (*(unsigned char *)(a1 + 28) & 0x7F) == 0;
}

uint64_t sub_100046F18(_DWORD *a1)
{
  if (*a1 != 3 || a1[1] || (int v1 = a1[7], (v1 & 0x7F) != 0)) {
    sub_100050D0C();
  }
  return BYTE1(v1);
}

uint64_t sub_100046F54(uint64_t a1)
{
  return sub_10000D440(*(void *)(a1 + 40) - *(void *)(a1 + 32));
}

uint64_t sub_100046F60(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

double sub_100046F68(uint64_t a1)
{
  *(void *)(a1 + 48) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)a1 = 1;
  return result;
}

uint64_t sub_100046F84(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4)) {
    return (*(unsigned __int8 *)(a1 + 16) >> 6) & 1;
  }
  else {
    return 0;
  }
}

BOOL sub_100046FA0(_DWORD *a1)
{
  return *a1 == 3 || a1[1] != 0;
}

BOOL sub_100046FC4(_DWORD *a1)
{
  int v1 = a1[1];
  if (v1 == 2) {
    return 1;
  }
  if (v1 || *a1 != 3) {
    return 0;
  }
  if ((a1[7] & 0x7F) != 0) {
    return (a1[7] & 0x7F) != 127;
  }
  return 0;
}

uint64_t sub_10004700C(_DWORD *a1)
{
  int v1 = a1[1];
  if (v1 == 2) {
    return a1[2];
  }
  if (v1 || *a1 != 3 || ((uint64_t result = a1[7] & 0x7F, result != 127) ? (v3 = result == 0) : (v3 = 1), v3)) {
    sub_100050D0C();
  }
  return result;
}

uint64_t sub_100047058(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 != 2)
  {
    if (v2)
    {
LABEL_9:
      if ((*(unsigned char *)(a1 + 17) & 2) != 0) {
        return 1;
      }
      return v2 == 30;
    }
    if (*(_DWORD *)a1 != 3)
    {
      int v2 = 0;
      return v2 == 30;
    }
    int v2 = 0;
    if ((*(_DWORD *)(a1 + 28) & 0x7F) == 0 || (*(_DWORD *)(a1 + 28) & 0x7F) == 0x7F) {
      return v2 == 30;
    }
  }
  unsigned int v3 = sub_10004700C((_DWORD *)a1) - 4;
  if (v3 < 9 && ((0x1D7u >> v3) & 1) != 0) {
    return 1;
  }
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2) {
    goto LABEL_9;
  }
  return v2 == 30;
}

uint64_t sub_1000470F0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 17) >> 2) & 1;
}

BOOL sub_1000470FC(_DWORD *a1)
{
  int v1 = a1[1];
  return (*a1 == 3 || v1 != 0) && v1 == 1;
}

BOOL sub_100047114(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  if (!v2 || v1 != 1) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  return v5 == 2 || v5 == 7;
}

BOOL sub_100047144(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  return v2 && v1 == 1 && *(void *)(a1 + 8) == 9;
}

BOOL sub_100047170(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  return v2 && v1 == 9 && *(void *)(a1 + 8) == 10;
}

BOOL sub_10004719C(_DWORD *a1)
{
  int v1 = a1[1];
  return (*a1 == 3 || v1 != 0) && v1 == 3;
}

BOOL sub_1000471B4(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  if (v1) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *(_DWORD *)a1 == 3;
  }
  return v2 && v1 == 7 && *(void *)(a1 + 8) == 3;
}

void sub_1000471E0(uint64_t a1)
{
}

__n128 sub_1000471F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v7 = sub_100012858(a1, a2, a5);
  if (v7)
  {
    uint64_t v9 = v7;
    int v10 = sub_10001A994(0);
    __n128 result = *(__n128 *)a3;
    long long v11 = *(_OWORD *)(a3 + 16);
    v10[1] = *(_OWORD *)a3;
    v10[2] = v11;
    *((void *)v10 + 6) = a4;
    *((void *)v10 + 7) = v9;
  }
  return result;
}

uint64_t sub_100047244(uint64_t a1)
{
  return *(void *)(a1 + 56) + 40;
}

uint64_t sub_100047250(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 16);
}

uint64_t sub_10004725C(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 56) + 24);
}

uint64_t sub_100047268()
{
  return 5;
}

uint64_t *sub_100047290(uint64_t a1, int a2)
{
  if (dword_10007671C) {
    return (uint64_t *)5;
  }
  __n128 result = sub_1000472D8(a2, 1);
  if (result)
  {
    dispatch_source_merge_data((dispatch_source_t)result[3], 0x45uLL);
    return 0;
  }
  return result;
}

uint64_t *sub_1000472D8(int a1, int a2)
{
  int v5 = a1;
  for (__n128 result = (uint64_t *)qword_100076788[sub_100015EA8(&v5, 4) % 0x35uLL]; result; __n128 result = (uint64_t *)*result)
  {
    if (*((unsigned __int8 *)result + 40) == a2 && *((_DWORD *)result + 4) == a1) {
      break;
    }
  }
  return result;
}

uint64_t sub_10004736C()
{
  return 5;
}

uint64_t sub_100047394()
{
  return 5;
}

uint64_t sub_1000473BC()
{
  return 5;
}

double sub_1000473E4()
{
  qword_100076728 = 0;
  double result = 0.0;
  xmmword_100076708 = 0u;
  unk_100076718 = 0u;
  return result;
}

long long *sub_100047400()
{
  return &xmmword_100076708;
}

uint64_t sub_10004740C()
{
  return qword_100076728;
}

void sub_100047418()
{
  byte_100076730 = 1;
}

_DWORD *sub_100047428(int a1, uint64_t a2)
{
  if (qword_100076738 != -1) {
    dispatch_once_f(&qword_100076738, 0, (dispatch_function_t)sub_10004750C);
  }
  uint64_t v4 = qword_100076740;
  if (qword_100076740 == qword_100075A58)
  {
    qword_100076748 = (uint64_t)sub_100013C20((void *)qword_100076748, 8 * (int)qword_100076740, 16 * qword_100076740);
    double result = sub_100013C20((void *)qword_100076750, 4 * (int)qword_100075A58, 8 * qword_100075A58);
    qword_100076750 = (uint64_t)result;
    qword_100075A58 *= 2;
    uint64_t v4 = qword_100076740;
  }
  else
  {
    double result = (_DWORD *)qword_100076750;
  }
  *(void *)(qword_100076748 + 8 * v4) = a2;
  result[v4] = a1;
  qword_100076740 = v4 + 1;
  return result;
}

void *sub_10004750C()
{
  double result = (void *)sub_10004768C(dword_100076A00, 0);
  if ((unint64_t)qword_100075A58 >> 61
    || (double result = sub_100013BB8(8 * qword_100075A58),
        qword_100076748 = (uint64_t)result,
        (unint64_t)qword_100075A58 >> 62)
    || (double result = sub_100013BB8(4 * qword_100075A58),
        qword_100076750 = (uint64_t)result,
        (unint64_t)qword_100075A60 >> 61))
  {
    __break(1u);
  }
  else
  {
    double result = sub_100013BB8(8 * qword_100075A60);
    qword_100076760 = (uint64_t)result;
    *double result = sub_10004BB78;
    qword_100076758 = 1;
    qword_100076768 = 40;
  }
  return result;
}

void *sub_1000475C0(uint64_t a1, unint64_t a2)
{
  if (qword_100076738 != -1) {
    dispatch_once_f(&qword_100076738, 0, (dispatch_function_t)sub_10004750C);
  }
  uint64_t v4 = qword_100076758;
  double result = (void *)qword_100076760;
  if (qword_100076758 == qword_100075A60)
  {
    double result = sub_100013C20((void *)qword_100076760, 8 * (int)qword_100076758, 16 * qword_100076758);
    qword_100076760 = (uint64_t)result;
    qword_100075A60 *= 2;
    uint64_t v4 = qword_100076758;
  }
  result[v4] = a1;
  qword_100076758 = v4 + 1;
  if (qword_100076768 < a2) {
    qword_100076768 = a2;
  }
  return result;
}

uint64_t sub_10004768C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_100013BB8(0x30uLL);
  v4[4] = a1;
  *((unsigned char *)v4 + 40) = 0;
  *((void *)v4 + 4) = a2;
  sub_100014B58();
  uint64_t f = dispatch_mach_create_f();
  *((void *)v4 + 3) = f;
  if (dword_100076A00 == a1) {
    qword_100076930 = f;
  }
  if (sub_10000D65C(a1)) {
    _os_assumes_log();
  }
  sub_100047AB8((uint64_t)v4);
  uint64_t v6 = *((void *)v4 + 3);

  return _dispatch_mach_connect(v6, a1, 0, 0);
}

uint64_t *sub_100047754(int a1)
{
  int v1 = sub_1000472D8(a1, 0);
  if (!v1) {
    sub_100040E80("attempt to remove non-existent server port");
  }
  BOOL v2 = v1;
  dispatch_mach_cancel();

  return sub_1000479C0(v2);
}

uint64_t sub_1000477A8(mach_port_name_t a1, int a2, uint64_t a3)
{
  if (a2 != 69) {
    sub_100050D0C();
  }
  int v5 = sub_100013BB8(0x30uLL);
  _DWORD v5[4] = a1;
  *((unsigned char *)v5 + 40) = 1;
  uint64_t v6 = sub_100014B58();
  uint64_t v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0, 0, v6);
  dispatch_set_context(v7, v5);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_10004794C;
  handler[3] = &unk_100071600;
  handler[4] = a3;
  void handler[5] = v7;
  dispatch_source_set_event_handler(v7, handler);
  long long v11 = _NSConcreteStackBlock;
  uint64_t v12 = 0x40000000;
  uint64_t v13 = sub_100047A18;
  unint64_t v14 = &unk_100071620;
  uint64_t v15 = v7;
  dispatch_source_set_mandatory_cancel_handler();
  dispatch_activate(v7);
  if (sub_10000D600(a1)) {
    _os_assumes_log();
  }
  mach_port_name_t name = 0;
  uint64_t v8 = sub_10000D6C8(a1, dword_100076A00, &name);
  if (name)
  {
    sub_100043D78(4, "Attempt to share port-destroyed. Ignoring.");
    if (sub_10000D678(name)) {
      _os_assumes_log();
    }
  }
  *((void *)v5 + 3) = v7;
  sub_100047AB8((uint64_t)v5);
  return v8;
}

uint64_t *sub_10004794C(uint64_t a1)
{
  BOOL v2 = *(NSObject **)(a1 + 40);
  context = (NSObject **)dispatch_get_context(v2);
  if (v2 != context[3]) {
    sub_100050D0C();
  }
  uint64_t v4 = (uint64_t *)context;
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));

  return sub_1000479C0(v4);
}

uint64_t *sub_1000479C0(uint64_t *result)
{
  uint64_t v1 = *result;
  if (*result == -1)
  {
    uint64_t v2 = result[1];
    if (v2 == -1) {
      sub_100040E80("multiple removals of port entry");
    }
    goto LABEL_5;
  }
  if (v1)
  {
    uint64_t v2 = result[1];
LABEL_5:
    *(void *)(v1 + 8) = v2;
  }
  *(void *)result[1] = v1;
  *double result = -1;
  result[1] = -1;
  return result;
}

void sub_100047A18(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(a1 + 32);
  context = dispatch_get_context(v2);
  if (v2 != *((NSObject **)context + 3)) {
    sub_100050D0C();
  }
  uint64_t v4 = context;
  char v5 = *((unsigned char *)context + 41);
  mach_port_name_t v6 = *((_DWORD *)context + 4);
  if (v5)
  {
    sub_100043D78(4, "Abandoning send right to 0x%x (canceled notification)", v6);
  }
  else if (sub_10000D678(v6))
  {
    _os_assumes_log();
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));

  free(v4);
}

unint64_t sub_100047AB8(uint64_t a1)
{
  int v5 = *(_DWORD *)(a1 + 16);
  unint64_t result = sub_100015EA8(&v5, 4);
  unsigned int v3 = &qword_100076788[result % 0x35];
  uint64_t v4 = *v3;
  *(void *)a1 = *v3;
  if (v4) {
    *(void *)(v4 + 8) = a1;
  }
  *unsigned int v3 = a1;
  *(void *)(a1 + 8) = v3;
  return result;
}

uint64_t *sub_100047B40(int a1)
{
  uint64_t v1 = sub_1000472D8(a1, 1);
  if (!v1) {
    sub_100040E80("attempt to cancel notification on non-existent port entry");
  }
  uint64_t v2 = v1;
  dispatch_source_cancel((dispatch_source_t)v1[3]);
  *((unsigned char *)v2 + 41) |= 1u;

  return sub_1000479C0(v2);
}

void sub_100047BA0(unsigned int a1, void *a2)
{
  unsigned int v3 = sub_10001A0D8(a2, 0, a1);
  sub_100047C0C(a2, "dispatching request");
  uint64_t v4 = sub_100014B58();

  dispatch_async_f(v4, v3, (dispatch_function_t)sub_100047CE8);
}

void sub_100047C0C(void *a1, const char *a2)
{
  long long v7 = 0u;
  long long v8 = 0u;
  if (byte_100076ABB)
  {
    memset(v9, 0, sizeof(v9));
    uint int64 = xpc_dictionary_get_uint64(a1, "subsystem");
    int v5 = xpc_dictionary_get_uint64(a1, "routine");
    xpc_dictionary_get_audit_token();
    mach_port_name_t v6 = sub_100042920((uint64_t)&v7, (char *)v9);
    sub_100043D78(5, "ipc: caller = %s.%d, subsysteuint64_t m = %d, routine = %d, %s", v6, DWORD1(v8), uint64, v5, a2);
  }
}

void sub_100047CE8(uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = sub_1000472D8(*(_DWORD *)(a1 + 16), 0);
  if (v4) {
    qword_100076728 = v4[4];
  }
  sub_100047C0C(v2, "processing dispatched request");
  sub_100047E00(v3, v2);
  qword_100076728 = 0;

  sub_10001A1AC((void **)a1);
}

void sub_100047D68(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  bzero(__str, 0x800uLL);
  vsnprintf(__str, 0x800uLL, a2, &a9);
  sub_100047C0C(a1, __str);
}

void sub_100047E00(uint64_t a1, void *a2)
{
  if (byte_100076780 == 1) {
    sub_100040E80("attempt to re-enter the server layer");
  }
  uint64_t v4 = sub_1000472D8(a1, 0);
  if (v4) {
    qword_100076728 = v4[4];
  }
  xpc_object_t value = xpc_dictionary_get_value(a2, "mig-request");
  if (value)
  {
    mach_port_name_t v6 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_data)
    {
      byte_100076A10 = 1;
      xpc_data_get_bytes_ptr(v6);
      if (xpc_data_get_length(v6) <= 0x17) {
        sub_100040E80("Message buffer was shorter than mach_msg_header");
      }
      size_t v7 = qword_100076768;
      __chkstk_darwin();
      bzero((char *)&v8 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
      bzero((char *)&v8 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0), v7);
      if (_xpc_pipe_handle_mig()) {
        _os_assumes_log();
      }
      byte_100076A10 = 0;
    }
  }
  else
  {
    sub_100048130(a1, 0, a2);
  }
  qword_100076728 = 0;
}

uint64_t sub_100047F8C(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = sub_10000D6FC((uint64_t)a1);
  long long v5 = *(_OWORD *)(v4 + 16);
  xmmword_100076708 = *(_OWORD *)v4;
  unk_100076718 = v5;
  qword_100076770 = (uint64_t)a1;
  qword_100076778 = ((a1[1] + 3) & 0x1FFFFFFFCLL) + 52;
  if (qword_100076758)
  {
    uint64_t v6 = 0;
    while (!(*(unsigned int (**)(_DWORD *, uint64_t))(qword_100076760 + 8 * v6))(a1, a2))
    {
      if (++v6 >= (unint64_t)qword_100076758) {
        goto LABEL_5;
      }
    }
    uint64_t result = 1;
  }
  else
  {
LABEL_5:
    memset(v9, 0, sizeof(v9));
    size_t v7 = sub_100042920((uint64_t)&xmmword_100076708, (char *)v9);
    sub_100043D78(65540, "%s.%d sent an invalid request: msgh_bits = 0x%x, msgh_size_t size = %u, msgh_remote_port = 0x%x, msgh_local_port = 0x%x, msgh_id = 0x%x", v7, *(_DWORD *)(v4 + 20), *a1, a1[1], a1[2], a1[3], a1[5]);
    if (byte_100076A7D)
    {
      sub_100043D78(65541, "Killing sender of bogus IPC message: %s.%d", v7, *(_DWORD *)(v4 + 20));
      if (sub_1000435B4()) {
        _os_assumes_log();
      }
    }
    uint64_t result = 0;
  }
  qword_100076770 = 0;
  qword_100076778 = 0;
  return result;
}

void sub_100048130(uint64_t a1, uint64_t a2, xpc_object_t xdict)
{
  if (byte_100076780 == 1) {
    sub_100040E80("reentrant call into server layer", a2, xdict);
  }
  uint64_t v4 = a2;
  byte_100076780 = 1;
  byte_100076730 = 0;
  xpc_dictionary_set_value(xdict, "mig-request", 0);
  xpc_object_t xdicta = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  xpc_dictionary_get_audit_token();
  xmmword_100076708 = 0u;
  unk_100076718 = 0u;
  if (v4)
  {
    if (v4 <= 0x513)
    {
      uint64_t v6 = (unsigned __int16)v4 / 0x64u;
      if (((0x861uLL >> v6) & 1) == 0)
      {
        int v7 = dword_100053DBC[v6];
        xpc_dictionary_set_uint64(xdict, "subsystem", v7);
        xpc_dictionary_set_uint64(xdict, "routine", v4);
        goto LABEL_9;
      }
    }
LABEL_13:
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    int v10 = sub_100042920((uint64_t)&xmmword_100076708, (char *)&v22);
    sub_100047C0C(xdict, "xpc demux failed");
    sub_100043D78(65541, "%s.%d sent an invalid request", v10, dword_10007671C);
    if (byte_100076A7D)
    {
      sub_100043D78(65541, "Killing sender of bogus IPC message: %s.%d", v10, dword_10007671C);
      if (sub_1000435B4()) {
        _os_assumes_log();
      }
    }
    goto LABEL_16;
  }
  uint int64 = xpc_dictionary_get_uint64(xdict, "subsystem");
  int v7 = uint64;
  if (!uint64) {
    goto LABEL_13;
  }
  if (uint64 > 12) {
    goto LABEL_13;
  }
  uint64_t v4 = xpc_dictionary_get_uint64(xdict, "routine");
  if (!v4) {
    goto LABEL_13;
  }
LABEL_9:
  if (!qword_100076740) {
    goto LABEL_13;
  }
  uint64_t v9 = 0;
  while (*(_DWORD *)(qword_100076750 + 4 * v9) != v7)
  {
    if (qword_100076740 == ++v9) {
      goto LABEL_13;
    }
  }
  int v11 = (*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, xpc_object_t *))(qword_100076748 + 8 * v9))(a1, v4, xdict, &xdicta);
  if (v11)
  {
    int v18 = v11;
    sub_100047D68(xdict, "demux int error = %d", v12, v13, v14, v15, v16, v17, v11);
    xpc_object_t reply = xpc_dictionary_create_reply(xdict);
    if (reply)
    {
      unint64_t v20 = reply;
      xpc_dictionary_set_int64(reply, "error", v18);
      xpc_object_t xdicta = v20;
    }
  }
  sub_100047C0C(xdict, "xpc demux succeeded");
  if (xdicta)
  {
    sub_100047C0C(xdict, "sending reply");
    if (byte_100076730 == 1)
    {
      xpc_dictionary_set_uint64(xdicta, "req_pid", dword_10007671C);
      xpc_dictionary_set_uint64(xdicta, "rec_execcnt", dword_100076724);
    }
    if ((xpc_pipe_routine_reply() & 0xFFFFFFDF) != 0) {
      _os_assumes_log();
    }
    xpc_release(xdicta);
  }
LABEL_16:
  byte_100076780 = 0;
}

void sub_100048464(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 24));
    free((void *)a1);
  }
  else
  {
    mach_port_name_t v3 = *(_DWORD *)(a1 + 16);
    if (a2 == 7)
    {
      uint64_t msg = dispatch_mach_msg_get_msg();
      long long v5 = (const void *)*(unsigned int *)(msg + 8);
      if ((v5 + 1) >= 2) {
        sub_1000519D4(v5);
      }
      int v6 = *(_DWORD *)(msg + 12);
      if ((v6 + 1) >= 2)
      {
        if (v3 != v6) {
          sub_1000519FC(v5);
        }
        if (sub_10000D678(v3)) {
          _os_assumes_log();
        }
        if (sub_10000D68C(v3, 0, *(void *)(a1 + 32))) {
          sub_100050D28();
        }
      }
    }
    else if (a2 == 2)
    {
      qword_100076728 = *(void *)(a1 + 32);
      sub_100048558();
      qword_100076728 = 0;
    }
  }
}

void sub_100048558()
{
  dispatch_mach_msg_get_msg();
  uint64_t v0 = 0;
  sub_100040E80("Message buffer was shorter than mach_msg_header");
}

void sub_100048704(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 16) != -1 || *(void *)(a1 + 24) != -1) {
    sub_100040E80("endpoint deallocation while still in service list");
  }
  if (*(void *)(a1 + 32) != -1 || *(void *)(a1 + 40) != -1) {
    sub_100040E80("endpoint deallocation while still in domain list");
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  if (v9) {
    sub_100040E80("endpoint deallocation while still active");
  }
  if ((v9 & 2) != 0) {
    sub_100040E80("endpoint deallocation while still being watched");
  }
  if ((v9 & 0x20) == 0 && (*(unsigned char *)(a1 + 88) & 0x20) != 0) {
    sub_100040E80("endpoint deallocation without cancellation");
  }
  if (*(void *)(a1 + 104))
  {
    if ((v9 & 0x88) == 0)
    {
      mach_port_name_t v10 = sub_100048818(a1, 4, a3, a4, a5, a6, a7, a8);
      if (sub_10000D68C(v10, 0, *(void *)(a1 + 112))) {
        _os_assumes_log_ctx();
      }
    }
    int v11 = *(void **)(a1 + 104);
    xpc_release(v11);
  }
}

uint64_t sub_100048818(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  uint64_t result = sub_1000492A8(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    return xpc_mach_send_get_right();
  }
  return result;
}

uint64_t sub_100048860(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 1;
}

void sub_100048898(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v19 = (const char **)sub_100010724(0x40uLL);
  uint64_t v20 = *(void *)(a1 + 96);
  if (v20)
  {
    uint64_t v21 = sub_1000203FC(v20, 1);
    sub_1000107B4((uint64_t)v19, "%s - ", v22, v23, v24, v25, v26, v27, (char)v21);
    free(v21);
  }
  sub_1000107B4((uint64_t)v19, "%s", v13, v14, v15, v16, v17, v18, a1 - 88);
  BOOL v28 = sub_100010770(v19);
  sub_100010778((void **)v19);
  sub_100044138(v28, a2, a3, &a9, v9);
  free(v28);
}

__n128 sub_100048970(unint64_t a1, const char *a2, unint64_t a3, unint64_t a4)
{
  int v7 = (__n128 *)sub_10001A758(a2);
  v7[6].n128_u64[0] = a1;
  v7[9].n128_u64[0] = a3;
  v7[9].n128_u64[1] = a4;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  v7[1] = result;
  v7[2] = result;
  return result;
}

char *sub_1000489B8(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = sub_10001A758(a2);
  *((void *)v9 + 12) = a1;
  *((void *)v9 + 18) = a4;
  *((void *)v9 + 19) = a5;
  *(void *)&long long v10 = -1;
  *((void *)&v10 + 1) = -1;
  *((_OWORD *)v9 + 1) = v10;
  *((_OWORD *)v9 + 2) = v10;
  *((void *)v9 + 13) = xpc_retain(a3);
  *((_WORD *)v9 + 80) |= 8u;
  sub_100048A34((uint64_t)v9, v11, v12, v13, v14, v15, v16, v17);
  return v9;
}

uint64_t sub_100048A34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  if (v9) {
    return 37;
  }
  if ((v9 & 8) != 0)
  {
    uint64_t v12 = *(void **)(a1 + 104);
    uintptr_t right = xpc_mach_send_get_right();
    uint64_t v14 = sub_100014B58();
    uint64_t v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, right, 1uLL, v14);
    xpc_retain(v12);
    dispatch_set_context(v15, (void *)a1);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_10004A110;
    handler[3] = &unk_1000716E0;
    handler[4] = v15;
    dispatch_source_set_event_handler(v15, handler);
    v16[5] = _NSConcreteStackBlock;
    void v16[6] = 0x40000000;
    void v16[7] = sub_10004A194;
    v16[8] = &unk_100071700;
    v16[9] = v15;
    v16[10] = v12;
    dispatch_source_set_mandatory_cancel_handler();
    dispatch_activate(v15);
    sub_10001A0AC((void *)a1);
    if (*(void *)(a1 + 120)) {
      sub_100050D0C();
    }
    *(void *)(a1 + 120) = v15;
  }
  else
  {
    mach_port_name_t v10 = sub_100048818(a1, 1, a3, a4, a5, a6, a7, a8);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_100049BB4;
    v16[3] = &unk_100071660;
    _OWORD v16[4] = a1;
    if (sub_1000477A8(v10, 69, (uint64_t)v16)) {
      _os_assumes_log_ctx();
    }
    sub_10000D59C(v10, *(void *)(a1 + 112));
  }
  uint64_t result = 0;
  *(_WORD *)(a1 + 160) |= 1u;
  return result;
}

char *sub_100048C4C(uint64_t a1, const char *a2, xpc_object_t object, uint64_t a4, unsigned char *a5, uint64_t a6)
{
  if (object == &_xpc_BOOL_false) {
    return 0;
  }
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_BOOL && type != (xpc_type_t)&_xpc_type_dictionary) {
    return 0;
  }
  xpc_type_t v14 = type;
  uint64_t v15 = sub_10001A758(a2);
  uint64_t v16 = v15;
  *((void *)v15 + 12) = a1;
  *((void *)v15 + 18) = a4;
  *((void *)v15 + 19) = a6;
  *(void *)&long long v17 = -1;
  *((void *)&v17 + 1) = -1;
  *((_OWORD *)v15 + 1) = v17;
  *((_OWORD *)v15 + 2) = v17;
  if (v14 == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_100048DD8;
    applier[3] = &unk_100071640;
    applier[4] = v15;
    size_t applier[5] = a5;
    xpc_dictionary_apply(object, applier);
  }
  if (v16[88] < 0 && (*((_WORD *)v16 + 80) & 4) != 0)
  {
    sub_100014CD8(a5, 3, "%s: _ExperimentalNonLaunching is not compatible with HideUntilCheckIn, ignoring", v16 + 168);
    sub_10001A174(v16);
    return 0;
  }
  if (strlen(v16 + 168) >= 0xFF) {
    sub_100014CD8(a5, 4, "The endpoint name %s is too long to support some features", v16 + 168);
  }
  __int16 v18 = *((_WORD *)v16 + 80);
  if ((v18 & 4) == 0) {
    *((_WORD *)v16 + 80) = v18 | 0x200;
  }
  return v16;
}

uint64_t sub_100048DD8(uint64_t a1, const char *a2, xpc_object_t object)
{
  uint64_t v6 = *(void *)(a1 + 32);
  long long v5 = *(unsigned char **)(a1 + 40);
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_int64)
  {
    if (type == (xpc_type_t)&_xpc_type_BOOL)
    {
      if (!strcasecmp(a2, "ResetAtClose"))
      {
        __int16 v11 = *(_WORD *)(v6 + 160) & 0xFFEF | (16 * (object == &_xpc_BOOL_true));
      }
      else if (!strcasecmp(a2, "HideUntilCheckIn"))
      {
        sub_100014CD8(v5, 4, "The HideUntilCheckIn property is an architectural performance issue. Please transition away from it.");
        __int16 v11 = *(_WORD *)(v6 + 160) & 0xFFFB | (4 * (object == &_xpc_BOOL_true));
      }
      else
      {
        if (strcasecmp(a2, "_ExperimentalNonLaunching"))
        {
          if (!strcasecmp(a2, "ExceptionServer"))
          {
            sub_100014CD8(v5, 3, "An empty dictionary needs to be used as the value for %s.");
            return 1;
          }
          goto LABEL_20;
        }
        if (object != &_xpc_BOOL_true) {
          return 1;
        }
        *(unsigned char *)(v6 + 88) |= 0x80u;
        __int16 v11 = *(_WORD *)(v6 + 160) | 0x400;
      }
      *(_WORD *)(v6 + 160) = v11;
      return 1;
    }
    if (type != (xpc_type_t)&_xpc_type_string)
    {
      if (type != (xpc_type_t)&_xpc_type_dictionary) {
        return 1;
      }
      if (!strcmp(a2, "ExceptionServer"))
      {
        if (xpc_dictionary_get_count(object)) {
          sub_100014CD8(v5, 3, "Non-empty dictionary property on MachService: %s");
        }
        else {
          *(unsigned char *)(v6 + 88) |= 0x10u;
        }
        return 1;
      }
LABEL_20:
      sub_100014CD8(v5, 3, "Unrecognized MachService property: %s");
      return 1;
    }
    if (!strcasecmp(a2, "TaskSpecialPort"))
    {
      xpc_string_get_string_ptr(object);
      int v12 = mach_task_special_port_for_id();
      if (v12 <= 0) {
        sub_100014CD8(v5, 3, "Tried to set an unknown task-special port: %s");
      }
    }
    else
    {
      if (strcasecmp(a2, "HostSpecialPort")) {
        goto LABEL_20;
      }
      xpc_string_get_string_ptr(object);
      int v12 = mach_host_special_port_for_id();
      if (v12 <= 0) {
        sub_100014CD8(v5, 3, "Tried to set an unknown host-special port: %s");
      }
    }
    uint64_t v10 = v6;
    int value = v12;
LABEL_34:
    sub_100049FA0(v10, value, v5);
    return 1;
  }
  if (!strcasecmp(a2, "TaskSpecialPort"))
  {
    int value = xpc_int64_get_value(object);
    uint64_t v10 = v6;
    goto LABEL_34;
  }
  if (strcasecmp(a2, "HostSpecialPort")) {
    goto LABEL_20;
  }
  int64_t v8 = xpc_int64_get_value(object);
  if (v8 < 8)
  {
    mach_host_special_port_description();
    sub_100014CD8(v5, 3, "Tried to set a reserved host-special port: %lld: %s");
  }
  else if ((unint64_t)v8 > 0x23)
  {
    sub_100014CD8(v5, 3, "Tried to set an invalid host-special port: %lld");
  }
  else
  {
    *(_DWORD *)(v6 + 84) = v8;
  }
  return 1;
}

uint64_t sub_1000490BC(uint64_t result)
{
  *(_WORD *)(result + 160) |= 0x200u;
  return result;
}

__n128 sub_1000490CC(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  int64_t v8 = (__n128 *)sub_10001A758((const char *)(a1 + 168));
  v8[6].n128_u64[0] = a3;
  v8[9].n128_u64[0] = a2;
  v8[9].n128_u64[1] = a4;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  v8[1] = result;
  v8[2] = result;
  v8[10].n128_u16[0] = v8[10].n128_u16[0] & 0xFFEB | *(_WORD *)(a1 + 160) & 0x14;
  return result;
}

xpc_object_t sub_100049138(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, launch_perfcheck_property_endpoint_name, (const char *)(a1 + 168));
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_active, *(_WORD *)(a1 + 160) & 1);
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_needs_activation, (*(_WORD *)(a1 + 160) & 0x200) != 0);
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_event, (*(unsigned char *)(a1 + 88) & 8) != 0);
  xpc_dictionary_set_BOOL(v4, "XPCServiceEndpointNonLaunching", *(unsigned char *)(a1 + 88) >> 7);
  if (a2)
  {
    __int16 v11 = (void *)sub_100049250(a1, 1, v5, v6, v7, v8, v9, v10);
    if (v11)
    {
      int v12 = v11;
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_mach_send) {
        xpc_dictionary_set_value(v4, "XPCServiceEndpointPort", v12);
      }
    }
  }
  return v4;
}

uint64_t sub_100049250(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  if ((*(_WORD *)(a1 + 160) & 5) == 4) {
    return 0;
  }

  return sub_1000492A8(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1000492A8(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(void *)(a1 + 104))
  {
    int v9 = a2 & 7;
    switch(v9)
    {
      case 1:
        __int16 v10 = *(_WORD *)(a1 + 160);
        if ((v10 & 8) != 0) {
          sub_100050D0C();
        }
        if (v10) {
          sub_100050D0C();
        }
        if ((v10 & 0x20) != 0)
        {
          sub_100048898(a1, 4, "Refusing to make a port for a canceled endpoint", a4, a5, a6, a7, a8, v17);
        }
        else
        {
          v18.reserved[1] = 0;
          *(_OWORD *)&v18.uint32_t flags = xmmword_100053DF0;
          uint64_t v11 = *(void *)(*(void *)(a1 + 96) + 248);
          strlen((const char *)(a1 + 168));
          int v12 = (const char **)sub_1000301F4(v11);
          if (sub_10002A744(v11))
          {
            char v13 = 1;
          }
          else if (v12 == (const char **)&unk_100075640 || v12 == (const char **)&unk_1000756C8)
          {
            char v13 = 2;
          }
          else
          {
            if (v12 != (const char **)&unk_100075750) {
              sub_100040E80("Endpoint with unexpected domain type \"%s\"", v12[14]);
            }
            char v13 = 5;
          }
          memset(v19, 0, sizeof(v19));
          char v20 = v13;
          __strlcpy_chk();
          v18.uint32_t flags = 1079;
          v18.reserved[0] = (uint64_t)v19;
          if ((sub_1000052DC(*(void *)(a1 + 96), 4) & 1) == 0) {
            v18.uint32_t flags = 9271;
          }
          mach_port_context_t v15 = qword_100075A68++;
          sub_10000D538(&v18, v15);
          *(void *)(a1 + 112) = v15;
          *(void *)(a1 + 104) = xpc_mach_send_create_with_disposition();
          if ((*(_WORD *)(a1 + 160) & 0x402) == 2) {
            sub_100049918((void *)a1);
          }
        }
        break;
      case 2:
        break;
      case 4:
        sub_100040E80("GET_PORT_FORCE for endpoint %s but port not yet made", (const char *)(a1 + 168));
      default:
        sub_100040E80("Invalid get_port() flags");
    }
  }
  return *(void *)(a1 + 104);
}

uint64_t sub_1000494DC(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  return *(void *)(a1 + 96);
}

BOOL sub_100049508(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  return (*(_WORD *)(a1 + 160) & 8) == 0;
}

uint64_t sub_10004953C(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface", a2);
  }
  sub_100046780(a2, a3, "\"%s\" = {", a4, a5, a6, a7, a8, a1 + 168);
  uint64_t v22 = sub_100048818(a1, 2, v11, v12, v13, v14, v15, v16);
  pxpc_type_t type = 0;
  if (v22 && (mach_port_type(mach_task_self_, v22, &ptype) || (ptype & 0x100000) != 0))
  {
    *(unsigned char *)(a1 + 88) |= 0x40u;
    uint64_t v23 = " (dead)";
  }
  else
  {
    uint64_t v23 = "";
  }
  sub_100046780(a2, a3 + 1, "mach_port_t port = 0x%x%s", v17, v18, v19, v20, v21, v22, v23);
  uint64_t v29 = *(unsigned int *)(a1 + 84);
  if (v29)
  {
    uint64_t v68 = mach_host_special_port_description();
    sub_100046780(a2, a3 + 1, "host-special mach_port_t port = %u (%s)", v30, v31, v32, v33, v34, v29, v68);
  }
  else
  {
    uint64_t v35 = *(unsigned int *)(a1 + 80);
    if (v35)
    {
      if (v35 == 128)
      {
        uint64_t v36 = "exception";
      }
      else
      {
        uint64_t v36 = (const char *)mach_task_special_port_description();
        uint64_t v35 = *(unsigned int *)(a1 + 80);
      }
      sub_100046780(a2, a3 + 1, "task-special mach_port_t port = %u (%s)", v24, v25, v26, v27, v28, v35, v36);
    }
  }
  if (*(_WORD *)(a1 + 160)) {
    uint64_t v37 = "1";
  }
  else {
    uint64_t v37 = "0";
  }
  sub_100046780(a2, a3 + 1, "active = %s", v24, v25, v26, v27, v28, v37);
  if ((*(_WORD *)(a1 + 160) & 8) != 0) {
    int v43 = "0";
  }
  else {
    int v43 = "1";
  }
  sub_100046780(a2, a3 + 1, "managed = %s", v38, v39, v40, v41, v42, v43);
  if ((*(_WORD *)(a1 + 160) & 0x10) != 0) {
    uint64_t v49 = "1";
  }
  else {
    uint64_t v49 = "0";
  }
  sub_100046780(a2, a3 + 1, "reset = %s", v44, v45, v46, v47, v48, v49);
  if ((*(_WORD *)(a1 + 160) & 4) != 0) {
    uint64_t v55 = "1";
  }
  else {
    uint64_t v55 = "0";
  }
  sub_100046780(a2, a3 + 1, "hide = %s", v50, v51, v52, v53, v54, v55);
  if ((*(_WORD *)(a1 + 160) & 2) != 0) {
    uint64_t v61 = "1";
  }
  else {
    uint64_t v61 = "0";
  }
  sub_100046780(a2, a3 + 1, "watching = %s", v56, v57, v58, v59, v60, v61);
  if ((*(_WORD *)(a1 + 160) & 0x400) != 0) {
    sub_100046780(a2, a3 + 1, "non-launching = 1", v62, v63, v64, v65, v66);
  }
  return sub_100046780(a2, a3, "}", v62, v63, v64, v65, v66);
}

void *sub_100049778(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  __int16 v2 = *(_WORD *)(a1 + 160);
  if ((v2 & 8) != 0) {
    sub_100040E80("attempt to watch unmanaged endpoint");
  }
  if ((v2 & 2) != 0) {
    sub_100040E80("attempt to watch endpoint that is already watched");
  }
  if (v2) {
    sub_100040E80("attempt to watch an active endpoint");
  }
  if ((v2 & 0x50) == 0x10)
  {
    sub_100049854((void *)a1);
    __int16 v2 = *(_WORD *)(a1 + 160);
  }
  *(_WORD *)(a1 + 160) = v2 & 0xFFBD | 2;
  __n128 result = (void *)sub_100024ECC(*(void *)(a1 + 96), 1);
  if (result) {
    *(_WORD *)(a1 + 160) |= 0x400u;
  }
  if (*(void *)(a1 + 104) && (*(_WORD *)(a1 + 160) & 0x400) == 0)
  {
    return sub_100049918((void *)a1);
  }
  return result;
}

void sub_100049854(void *a1)
{
  if (a1[16]) {
    sub_100050D0C();
  }
  if (a1[15]) {
    sub_100050D0C();
  }
  uint64_t v2 = a1[13];
  if (v2)
  {
    uint64_t v3 = a1[14];
    a1[13] = 0;
    sub_10001A0AC(a1);
    xpc_object_t v4 = sub_100014B58();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_10004A008;
    block[3] = &unk_100071680;
    block[4] = v2;
    void block[5] = v3;
    block[6] = a1;
    dispatch_async(v4, block);
  }
}

void *sub_100049918(void *a1)
{
  uint64_t v2 = (void *)a1[13];
  uintptr_t right = xpc_mach_send_get_right();
  xpc_object_t v4 = sub_100014B58();
  uint64_t v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_recv, right, 0x8000uLL, v4);
  dispatch_set_context(v5, a1);
  xpc_retain(v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_10004A088;
  handler[3] = &unk_1000716A0;
  handler[4] = v5;
  dispatch_source_set_event_handler(v5, handler);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10004A0BC;
  void v7[3] = &unk_1000716C0;
  _OWORD v7[4] = v5;
  void v7[5] = v2;
  dispatch_source_set_cancel_handler(v5, v7);
  dispatch_activate(v5);
  __n128 result = sub_10001A0AC(a1);
  if (a1[16]) {
    sub_100050D0C();
  }
  a1[16] = v5;
  return result;
}

void sub_100049A5C(uint64_t a1, integer_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_name_t v10 = sub_100048818(a1, 2, a3, a4, a5, a6, a7, a8);
  if (v10 - 1 <= 0xFFFFFFFD)
  {
    integer_t port_info = a2;
    if (mach_port_set_attributes(mach_task_self_, v10, 9, &port_info, 1u))
    {
      uint64_t v16 = "mark";
      if (!port_info) {
        uint64_t v16 = "unmark";
      }
      sub_10001E4BC(*(void *)(a1 + 96), 4, "Failed to %s endpoint '%s' as throttled", v11, v12, v13, v14, v15, (char)v16);
    }
    if (a2) {
      __int16 v17 = 2048;
    }
    else {
      __int16 v17 = 0;
    }
    *(_WORD *)(a1 + 160) = *(_WORD *)(a1 + 160) & 0xF7FF | v17;
  }
}

void sub_100049B18(uint64_t a1)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  __int16 v2 = *(_WORD *)(a1 + 160);
  if ((v2 & 8) != 0) {
    sub_100040E80("attempt to ignore unmanaged endpoint");
  }
  if ((v2 & 2) == 0) {
    sub_100040E80("attempt to ignore endpoint that is already ignored");
  }
  *(_WORD *)(a1 + 160) = v2 & 0xFFFD;
  uint64_t v3 = *(NSObject **)(a1 + 128);
  if ((v2 & 0x400) != 0 || !*(void *)(a1 + 104))
  {
    if (v3) {
      sub_100040E80("endpoint %s has unexpected receive_source", (const char *)(a1 + 168));
    }
  }
  else
  {
    dispatch_source_cancel(v3);
    *(void *)(a1 + 128) = 0;
  }
}

uint64_t sub_100049BB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 32);
  if ((*(_WORD *)(v8 + 160) & 0x10) != 0)
  {
    sub_100049854(*(void **)(a1 + 32));
  }
  else
  {
    mach_port_name_t v9 = sub_100048818(*(void *)(a1 + 32), 4, a3, a4, a5, a6, a7, a8);
    sub_10000D5B4(v9, *(void *)(v8 + 112));
    if (sub_10000D6A8(v9)) {
      _os_assumes_log_ctx();
    }
  }
  __int16 v17 = *(_WORD *)(v8 + 160);
  *(_WORD *)(v8 + 160) = v17 & 0xFFBE | 0x40;
  if ((v17 & 0x100) != 0)
  {
    sub_100049D4C(v8, v10, v11, v12, v13, v14, v15, v16);
    *(_WORD *)(v8 + 160) &= ~0x100u;
  }
  uint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 144);
  uint64_t v18 = *(void *)(v8 + 152);

  return v19(v8, 1, v18);
}

void sub_100049C6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    sub_100040E80("alias endpoint given to endpoint interface");
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  *(_WORD *)(a1 + 160) = v9 | 0x20;
  if ((v9 & 2) != 0)
  {
    sub_100049B18(a1);
  }
  else if (v9)
  {
    if ((v9 & 8) != 0)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
      *(void *)(a1 + 120) = 0;
    }
    else
    {
      int v10 = sub_100048818(a1, 4, a3, a4, a5, a6, a7, a8);
      sub_100047B40(v10);
    }
    *(_WORD *)(a1 + 160) = *(_WORD *)(a1 + 160) & 0xFF7E | 0x80;
    uint64_t v12 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 144);
    uint64_t v11 = *(void *)(a1 + 152);
    v12(a1, 1, v11);
  }
}

void sub_100049D30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = *(_WORD *)(a1 + 160);
  if ((v8 & 0x100) == 0)
  {
    if (v8) {
      *(_WORD *)(a1 + 160) = v8 | 0x100;
    }
    else {
      sub_100049D4C(a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
}

void sub_100049D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_msg_return_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned char msg[32];

  if (*(_WORD *)(a1 + 160)) {
    sub_100040E80("attempt to drain active endpoint");
  }
  mach_port_name_t v9 = sub_100048818(a1, 2, a3, a4, a5, a6, a7, a8);
  if (v9 - 1 <= 0xFFFFFFFD)
  {
    mach_port_name_t v10 = v9;
    int v11 = 20;
    do
    {
      memset(msg, 0, sizeof(msg));
      uint64_t v12 = mach_msg((mach_msg_header_t *)msg, 258, 0, 0x20u, v10, 0, 0);
      if (v12)
      {
        if (v12 == 268451843) {
          return;
        }
      }
      else
      {
        sub_100048898(a1, 5, "draining message: id = 0x%x", v13, v14, v15, v16, v17, msg[20]);
        mach_msg_destroy((mach_msg_header_t *)msg);
      }
      --v11;
    }
    while (v11);
  }
}

uint64_t sub_100049E24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(void *)(a1 + 72)) {
    return 0;
  }
  __int16 v9 = *(_WORD *)(a1 + 160);
  if ((v9 & 8) != 0) {
    return 0;
  }
  if ((v9 & 0x20) == 0) {
    sub_100050D0C();
  }
  if ((v9 & 2) != 0) {
    sub_100050D0C();
  }
  int v11 = sub_100048818(a1, 2, a3, a4, a5, a6, a7, a8);
  if ((v11 - 1) > 0xFFFFFFFD) {
    return 0;
  }
  if ((*(_WORD *)(a1 + 160) & 0x80) != 0)
  {
    int v19 = v11;
    int v20 = sub_1000221B4(*(void *)(a1 + 96));
    sub_100040E80("Unable to stash abandoned service port 0x%x owner PID %d (%s)", v19, v20, (const char *)(a1 + 168));
  }
  uint64_t result = sub_10001AE98(a2, (const char *)(a1 + 168), v11, *(void *)(a1 + 112));
  if (!result)
  {
    sub_100048898(a1, 5, "Saved the port to stash", v13, v14, v15, v16, v17, v21);
    uint64_t v18 = *(void **)(a1 + 104);
    if (!v18) {
      sub_100050D0C();
    }
    xpc_release(v18);
    uint64_t result = 0;
    *(void *)(a1 + 104) = 0;
  }
  return result;
}

void sub_100049F00(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 72))
  {
    __int16 v3 = *(_WORD *)(a1 + 160);
    if ((v3 & 8) == 0)
    {
      if (*(void *)(a1 + 104)) {
        sub_100050D0C();
      }
      if (v3) {
        sub_100050D0C();
      }
      if ((v3 & 2) != 0) {
        sub_100050D0C();
      }
      uint64_t v10 = 0;
      if (sub_10001AF18(a2, a1 + 168, &v10) - 1 <= 0xFFFFFFFD)
      {
        *(void *)(a1 + 112) = v10;
        *(void *)(a1 + 104) = xpc_mach_send_create_with_disposition();
        sub_100048898(a1, 5, "Restored the port from stash", v4, v5, v6, v7, v8, v9);
      }
    }
  }
}

void sub_100049FA0(uint64_t a1, int a2, unsigned char *a3)
{
  if (a2 < 7 || a2 == 9)
  {
    sub_100014CD8(a3, 3, "Tried to set a reserved task special port: %d");
  }
  else if (a2 > 11)
  {
    sub_100014CD8(a3, 3, "Bogus TaskSpecialPort number: %d");
  }
  else
  {
    *(_DWORD *)(a1 + 80) = a2;
  }
}

void sub_10004A008(uint64_t a1)
{
  mach_port_name_t right = xpc_mach_send_get_right();
  if (sub_10000D68C(right, 0, *(void *)(a1 + 40))) {
    _os_assumes_log_ctx();
  }
  xpc_release(*(xpc_object_t *)(a1 + 32));
  __int16 v3 = *(void **)(a1 + 48);

  sub_10001A174(v3);
}

uint64_t sub_10004A088(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  __int16 v3 = (uint64_t (*)(void *, void, uint64_t))context[18];
  uint64_t v2 = context[19];

  return v3(context, 0, v2);
}

void sub_10004A0BC(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  sub_10001A174(context);
  xpc_release(*(xpc_object_t *)(a1 + 40));
  __int16 v3 = *(NSObject **)(a1 + 32);

  dispatch_release(v3);
}

void sub_10004A110(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  *((_WORD *)context + 80) = *((_WORD *)context + 80) & 0xFFDE | 0x20;
  sub_10001A0AC(context);
  (*((void (**)(void *, uint64_t, void))context + 18))(context, 1, *((void *)context + 19));
  dispatch_source_cancel(*((dispatch_source_t *)context + 15));
  *((void *)context + 15) = 0;

  sub_10001A174(context);
}

void sub_10004A194(uint64_t a1)
{
  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  sub_10001A174(context);
  xpc_release(*(xpc_object_t *)(a1 + 40));
  __int16 v3 = *(NSObject **)(a1 + 32);

  dispatch_release(v3);
}

uint64_t sub_10004A1E8(uint64_t a1)
{
  return _os_parse_boot_arg_from_buffer_string(qword_100076938, a1, 0, 0);
}

char *sub_10004A200()
{
  if (sub_100042A54("kern.bootargs", (char **)&qword_100076938)) {
    BOOL v0 = qword_100076938 == 0;
  }
  else {
    BOOL v0 = 1;
  }
  if (v0) {
    sub_100040E80("no bootargs string");
  }
  uint64_t v1 = sub_10003E660(0, "__TEXT", "__config");
  qword_100076940 = (uint64_t)v1;
  if (!v1 || xpc_get_type(v1) != (xpc_type_t)&_xpc_type_dictionary) {
    sub_100040E80("launchd built improperly: no __TEXT,__config");
  }
  byte_100076A80 = getenv("XPC_USERSPACE_REBOOTED") != 0;
  byte_100076A66 = os_variant_has_internal_content();
  if (sub_100015D50((char *)qword_100076938, "rd=md0")
    || sub_100011260("Restore")
    || sub_100011260("Ramdisk")
    || sub_100011260("RamDisk"))
  {
    byte_100076A63 = 1;
    byte_100076A64 = 1;
  }
  if (byte_100076A65 && byte_100076A80) {
    sub_100040E80("after the userspace reboot, os_variant_is_basesystem() should not be true");
  }
  if (byte_100076A61)
  {
    byte_100076A63 = 0;
    byte_100076A65 = 0;
    byte_100076A64 = 0;
  }
  if (os_variant_is_darwinos()) {
    byte_100076A64 = 0;
  }
  uint64_t v2 = (char *)qword_100076938;
  byte_100076A68 = strstr((char *)qword_100076938, "-v") != 0;
  __int16 v3 = strstr(v2, "-no-corpses");
  byte_100076AB8 = v3 != 0;
  if (v3)
  {
    if (_os_alloc_once_table[2] == -1)
    {
      uint64_t v4 = _os_alloc_once_table[3];
      char v5 = 1;
    }
    else
    {
      uint64_t v4 = _os_alloc_once();
      char v5 = byte_100076AB8;
      uint64_t v2 = (char *)qword_100076938;
    }
    *(unsigned char *)(v4 + 42) = v5;
  }
  qword_100076AA8 = sub_100042D14(v2, "launchd_force_data_status=", 0);
  byte_100075AC4 = sub_100042D14((char *)qword_100076938, "launchd_proxyless_spawn=", 1) != 0;
  qword_100076A70 = sub_100042D14((char *)qword_100076938, "launchd_instance_limit=", 0);
  byte_100076A81 = sub_100042D84((char *)qword_100076938, "launchd_usr_abandon_unmanaged=") != 0;
  byte_100076A82 = sub_100042D84((char *)qword_100076938, "launchd_verbose_coalition_logs=") != 0;
  if (sub_100015D50((char *)qword_100076938, "launchd_upward_connections_support=")) {
    byte_100076A90 = sub_100042D84((char *)qword_100076938, "launchd_upward_connections_support=") != 0;
  }
  byte_100076A60 = sub_100042D14((char *)qword_100076938, "launchd_workload_properties_disabled=", 0) != 0;
  uint64_t v6 = (char *)qword_100076938;
  if (strstr((char *)qword_100076938, "launchd_automation="))
  {
    byte_100076A67 = sub_100042D84(v6, "launchd_automation=") != 0;
    uint64_t v6 = (char *)qword_100076938;
  }
  else if (strstr(v6, "BATS_TESTPLAN_ID="))
  {
    byte_100076A67 = 1;
  }
  if (sub_100015D50(v6, "launch_prob_guard_self="))
  {
    BOOL v7 = sub_100042D84((char *)qword_100076938, "launch_prob_guard_self=") != 0;
    qword_100076A98 = (uint64_t)xpc_BOOL_create(v7);
  }
  if (sub_100015D50((char *)qword_100076938, "launch_prob_guard_sample_rate_self="))
  {
    uint64_t v8 = sub_100042D84((char *)qword_100076938, "launch_prob_guard_sample_rate_self=");
    qword_100076AA0 = (uint64_t)xpc_uint64_create(v8);
  }
  sub_100003B8C(qword_100076938, (uint64_t (*)(const char *, void **))sub_100042A54);
  int v30 = 0;
  size_t v29 = 4;
  sysctlbyname("kern.minimalboot", &v30, &v29, 0, 0);
  if (v30) {
    byte_1000769F0 = 1;
  }
  __str = 0;
  if (sub_100042A54("kern.osrelease", &__str)) {
    qword_100076A20 = strtoul(__str, 0, 0);
  }
  free(__str);
  bufsize_t size = 1024;
  _NSGetExecutablePath(byte_100076AE0, &bufsize);
  char v9 = strrchr(byte_100076AE0, 47);
  uint64_t v10 = "launchd";
  if (v9) {
    uint64_t v10 = v9 + 1;
  }
  qword_100076A18 = (uint64_t)v10;
  byte_100076AB9 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "LogServiceLifecycle");
  byte_100076ABB = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "LogIPC");
  sub_10004B3D4(&byte_100076ABA, "LogToConsole", "launchd_log_serial=");
  byte_100076A7B = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "UseGuardMalloc");
  byte_100076A7C = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "UseNanoAllocator");
  byte_100076A7D = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "AbortOnUnknownIPC");
  byte_100076A7E = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "RequireDomainBinding");
  byte_100076A69 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "LogToFlatFile");
  sub_10004B44C(&qword_100075AB8, "LogFileMaxSize");
  sub_10004B4A0(&dword_100075AC0, "LogFileVerboseMetaLimit", "launchd_log_verbose_meta_limit=");
  byte_100076A78 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "LogAllBootstrapErrors");
  byte_100076A79 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "PureOnDemand");
  if (!qword_100076A70)
  {
    uint64_t v33 = 0;
    sub_10004B44C(&v33, "MultipleInstanceLimit");
    unint64_t v11 = v33;
    if (v33 <= 0)
    {
      int v32 = 0;
      size_t v31 = 4;
      if (sysctlbyname("kern.maxproc", &v32, &v31, 0, 0)) {
        sub_100050D28();
      }
      if (v32 <= 0) {
        sub_100050D0C();
      }
      unint64_t v11 = (unint64_t)v32 >> 1;
    }
    qword_100076A70 = v11;
  }
  sub_10004B4A0(&dword_100075A90, "SIGTERMTimeout", 0);
  sub_10004B4A0(&dword_100075A94, "SIGKILLTimeout", 0);
  byte_100076A44 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "CrashOnSIGTERMTimeout");
  if ((os_variant_has_internal_diagnostics() & 1) == 0) {
    byte_100076A44 = 0;
  }
  byte_100076AC8 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "ExtensionWatchdog");
  sub_10004B4A0(&dword_100075A98, "ExtensionWatchdogTimeout", 0);
  sub_10004B4A0(&dword_100075A9C, "ShutdownTimeout", 0);
  sub_10004B4A0(&dword_100075AB4, "HighWatermark", 0);
  uint64_t v33 = 0;
  if (os_parse_boot_arg_from_buffer_int() && !v33) {
    dword_100075AB4 = -1;
  }
  byte_100076A47 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "DisableAllMemoryLimit");
  byte_100076A48 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, "DisableExtensionMemoryLimit");
  if (os_variant_allows_internal_security_policies()
    && !access("/usr/local/share/launchd-disable-memory-limits", 0))
  {
    byte_100076A47 = 1;
  }
  sub_10004B4A0(&dword_100075AB0, "SyncInterval", "launchd_sync_interval=");
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100076940, "Bootstrap");
  if (value)
  {
    uint64_t v13 = (uint64_t)value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary) {
      qword_100076948 = v13;
    }
  }
  sub_10004B3D4(&byte_100076A45, "SuddenShutdown", "launchd_sudden_shutdown=");
  sub_10004B3D4(&byte_100076A46, "ServiceStubsDisabled", "launch_service_stubs_disabled=");
  if (sub_100042D14((char *)qword_100076938, "launchd_disable_all_timeouts=", 0))
  {
    dword_100075A94 = 600;
    byte_100076AC8 = 0;
    dword_100075A9C = 0;
    dword_100076EE0 = 0;
  }
  if (!qword_100076948) {
    goto LABEL_77;
  }
  xpc_object_t v14 = xpc_dictionary_get_value((xpc_object_t)qword_100076948, "Paths");
  if (v14)
  {
    uint64_t v15 = (uint64_t)v14;
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_array) {
      qword_100076A30 = v15;
    }
  }
  xpc_object_t v16 = xpc_dictionary_get_value((xpc_object_t)qword_100076948, "UserPaths");
  if (v16)
  {
    uint64_t v17 = (uint64_t)v16;
    if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_array) {
      qword_100076A38 = v17;
    }
  }
  xpc_object_t v18 = sub_10004B1F4();
  xpc_object_t v19 = v18;
  if (byte_100076A65)
  {
    if (!v18) {
      xpc_object_t v19 = xpc_dictionary_create(0, 0, 0);
    }
    xpc_dictionary_set_string(v19, "__OSINSTALL_ENVIRONMENT", "1");
  }
  if (v19) {
    xpc_dictionary_apply_f();
  }
  xpc_object_t v20 = xpc_dictionary_get_value((xpc_object_t)qword_100076948, "ChildDefaults");
  if (v20 && xpc_get_type(v20) == (xpc_type_t)&_xpc_type_dictionary) {
    xpc_dictionary_apply_f();
  }
  xpc_object_t v21 = sub_10004B19C();
  if (v21)
  {
    uint64_t result = (char *)xpc_dictionary_get_count(v21);
    unint64_t v23 = (unint64_t)(result + 2);
    uint64_t v24 = (unint64_t)result >= 0xFFFFFFFFFFFFFFFELL;
    if (v24 << 63 >> 63 != v24 || v24 | (v23 >> 61))
    {
      __break(1u);
      return result;
    }
    qword_100076A28 = (uint64_t)sub_100013BB8(8 * v23);
    uint64_t v33 = 1;
    *(void *)qword_100076A28 = "XPC_FLAGS=0x0000000000000000";
    xpc_dictionary_apply_f();
    *(void *)(qword_100076A28 + 8 * v33) = 0;
  }
  else
  {
LABEL_77:
    uint64_t v25 = sub_100013BB8(0x10uLL);
    qword_100076A28 = (uint64_t)v25;
    *uint64_t v25 = "XPC_FLAGS=0x0000000000000000";
    v25[1] = 0;
  }
  if (!qword_100076940)
  {
    qword_100076AC0 = 0;
    goto LABEL_89;
  }
  xpc_object_t v26 = xpc_dictionary_get_value((xpc_object_t)qword_100076940, "Boot");
  qword_100076AC0 = (uint64_t)v26;
  if (!v26 || (uint64_t result = (char *)xpc_get_type(v26), result != (char *)&_xpc_type_dictionary)) {
LABEL_89:
  }
    sub_100040E80("no boot tasks");
  return result;
}

xpc_object_t sub_10004AC14(char *key)
{
  xpc_object_t result = (xpc_object_t)qword_100076940;
  if (qword_100076940) {
    return xpc_dictionary_get_value((xpc_object_t)qword_100076940, key);
  }
  return result;
}

void *sub_10004AC2C()
{
  if (!byte_100076A63)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/disabled.migrated", off_100075A78[0]);
    memset(&v11, 0, sizeof(v11));
    if (stat(__str, &v11))
    {
      *(_OWORD *)xpc_object_t v14 = off_100071760;
      uint64_t v1 = fts_open(v14, 92, 0);
      if (v1)
      {
        uint64_t v2 = v1;
        __int16 v3 = fts_read(v1);
        if (v3)
        {
          uint64_t v4 = v3;
          uint64_t v5 = 0;
          do
          {
            int fts_info = v4->fts_info;
            if (fts_info == 6)
            {
              --v5;
            }
            else if (fts_info == 1)
            {
              if (v5) {
                fts_set(v2, v4, 4);
              }
              bzero(from, 0x400uLL);
              bzero(to, 0x400uLL);
              if (!strcmp(v4->fts_name, "com.apple.launchd"))
              {
                snprintf(from, 0x400uLL, "%s/overrides.plist", v4->fts_path);
                snprintf(to, 0x400uLL, "%s/disabled.plist", off_100075A78[0]);
                BOOL v7 = copyfile_state_alloc();
                if (copyfile(from, to, v7, 8u) == -1) {
                  sub_100050E38();
                }
                if (copyfile_state_free(v7) == -1) {
                  sub_100050E38();
                }
              }
              ++v5;
            }
            uint64_t v4 = fts_read(v2);
          }
          while (v4);
        }
        if (fts_close(v2) == -1) {
          sub_100050DFC();
        }
      }
      else
      {
        int v8 = *__error();
        __error();
        char v9 = (const char *)xpc_strerror();
        sub_100043D78(4, "failed to fts_open(/private/var/db/launchd.db, 0x%x): %d: %s", 92, v8, v9);
      }
      uint64_t v10 = (int *)open(__str, 512, 438);
      if (v10 == -1)
      {
        if (*__error() != 30 && *__error()) {
          _os_assumes_log();
        }
      }
      else
      {
        sub_10003E54C(v10);
      }
    }
  }
  qword_100076950 = (uint64_t)sub_100015BE4("%s/disabled.plist", off_100075A78[0]);
  xpc_object_t result = sub_10003E594((const char *)qword_100076950);
  qword_100076958 = (uint64_t)result;
  if (!result)
  {
    xpc_object_t result = xpc_dictionary_create(0, 0, 0);
    qword_100076958 = (uint64_t)result;
  }
  return result;
}

void sub_10004AEF0()
{
  BOOL v0 = sub_10003E594("/private/etc/com.apple.xpc.launchd.limits.plist");
  if (v0)
  {
    uint64_t v1 = v0;
    xpc_dictionary_apply_f();
    xpc_release(v1);
  }
  qword_100076AB0 = (uint64_t)sub_100045FAC();
  uint64_t v2 = sub_10003E594("/System/Library/UserManagement/com.apple.xpc.launchd.personas.plist");
  if (v2)
  {
    __int16 v3 = v2;
    xpc_object_t value = xpc_dictionary_get_value(v2, "SystemPersonaServices");
    if (value)
    {
      uint64_t v5 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array) {
        xpc_array_apply(v5, &stru_100071790);
      }
    }
    xpc_release(v3);
  }
  bzero(&v8[52], 0x3CCuLL);
  strcpy(v8, "/System/Library/xpc/foreground_user_endpoints.plist");
  qword_100076A88 = (uint64_t)sub_10003E594(v8);
  sub_100042A54("hw.targettype", (char **)&qword_100076A50);
  int is_darwinos = os_variant_is_darwinos();
  BOOL v7 = "";
  if (is_darwinos) {
    BOOL v7 = ".darwin";
  }
  qword_100076A58 = (uint64_t)v7;
  sub_10000EBFC();
}

void *sub_10004B064(char *a1, xpc_object_t object)
{
  xpc_object_t v2 = object;
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_int64)
  {
LABEL_6:
    int64_t value = xpc_int64_get_value(v2);
    uint64_t v6 = a1;
    int64_t v7 = value;
    goto LABEL_7;
  }
  xpc_object_t result = xpc_get_type(v2);
  if (result != &_xpc_type_array) {
    return result;
  }
  if (xpc_array_get_count(v2) == 1)
  {
    xpc_object_t v2 = xpc_array_get_value(v2, 0);
    xpc_object_t result = xpc_get_type(v2);
    if (result != &_xpc_type_int64) {
      return result;
    }
    goto LABEL_6;
  }
  xpc_object_t result = (void *)xpc_array_get_count(v2);
  if (result != (void *)2) {
    return result;
  }
  xpc_object_t v8 = xpc_array_get_value(v2, 0);
  xpc_object_t v9 = xpc_array_get_value(v2, 1uLL);
  xpc_object_t result = xpc_get_type(v8);
  if (result != &_xpc_type_int64) {
    return result;
  }
  xpc_object_t result = xpc_get_type(v9);
  if (result != &_xpc_type_int64) {
    return result;
  }
  int64_t v10 = xpc_int64_get_value(v8);
  int64_t v7 = xpc_int64_get_value(v9);
  uint64_t v6 = a1;
  int64_t value = v10;
LABEL_7:

  return (void *)sub_100043088(v6, value, v7, 0);
}

xpc_object_t sub_10004B19C()
{
  if (!qword_100076948) {
    return 0;
  }
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100076948, "Self");
  if (!value) {
    return 0;
  }
  xpc_object_t v1 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0;
  }
  return v1;
}

xpc_object_t sub_10004B1F4()
{
  if (!qword_100076948) {
    return 0;
  }
  xpc_object_t value = xpc_dictionary_get_value((xpc_object_t)qword_100076948, "Child");
  if (!value) {
    return 0;
  }
  xpc_object_t v1 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary) {
    return 0;
  }
  return v1;
}

uint64_t sub_10004B24C()
{
  return qword_100076958;
}

uint64_t sub_10004B258(uint64_t a1, char *__str)
{
  uint64_t result = snprintf(__str, 0x40uLL, "XPC_FLAGS=0x%llx", a1);
  *(void *)qword_100076A28 = __str;
  return result;
}

void sub_10004B2A4()
{
  BOOL v0 = (void *)qword_100076958;
  if (qword_100076958)
  {
    xpc_object_t v1 = (const char *)qword_100076950;
    if (xpc_dictionary_get_BOOL((xpc_object_t)qword_100076958, "_dirty"))
    {
      xpc_dictionary_set_value(v0, "_dirty", 0);
      xpc_object_t v2 = xpc_copy(v0);
      __int16 v3 = sub_1000159F0(v1);
      uint64_t v4 = sub_100014B70();
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000;
      _OWORD v5[2] = sub_10004B6DC;
      v5[3] = &unk_1000717B0;
      _DWORD v5[4] = v2;
      void v5[5] = v3;
      dispatch_async(v4, v5);
    }
  }
}

void sub_10004B370()
{
  sub_10004B2A4();
  BOOL v0 = sub_100014B70();

  dispatch_sync(v0, &stru_100071740);
}

uint64_t sub_10004B3A8(char *key)
{
  if (byte_100076A90) {
    return 1;
  }
  uint64_t result = qword_100076A88;
  if (qword_100076A88) {
    return xpc_dictionary_get_BOOL((xpc_object_t)qword_100076A88, key);
  }
  return result;
}

BOOL sub_10004B3D4(unsigned char *a1, char *key, char *__s2)
{
  if (__s2 && (uint64_t v6 = (char *)qword_100076938, strstr((char *)qword_100076938, __s2))) {
    BOOL result = sub_100042D84(v6, __s2) != 0;
  }
  else {
    BOOL result = xpc_dictionary_get_BOOL((xpc_object_t)qword_100076940, key);
  }
  *a1 = result;
  return result;
}

void *sub_10004B44C(void *a1, const char *a2)
{
  BOOL result = xpc_dictionary_get_value((xpc_object_t)qword_100076940, a2);
  if (result)
  {
    uint64_t v4 = result;
    BOOL result = xpc_get_type(result);
    if (result == &_xpc_type_int64)
    {
      BOOL result = (void *)xpc_int64_get_value(v4);
      *a1 = result;
    }
  }
  return result;
}

void *sub_10004B4A0(_DWORD *a1, char *key, char *__s2)
{
  if (__s2)
  {
    uint64_t v6 = (char *)qword_100076938;
    if (strstr((char *)qword_100076938, __s2))
    {
      BOOL result = (void *)sub_100042D84(v6, __s2);
LABEL_7:
      *a1 = result;
      return result;
    }
  }
  BOOL result = xpc_dictionary_get_value((xpc_object_t)qword_100076940, key);
  if (result)
  {
    xpc_object_t v8 = result;
    BOOL result = xpc_get_type(result);
    if (result == &_xpc_type_int64)
    {
      BOOL result = (void *)xpc_int64_get_value(v8);
      goto LABEL_7;
    }
  }
  return result;
}

void *sub_10004B534(char *a1, xpc_object_t object, uint64_t a3)
{
  BOOL result = xpc_get_type(object);
  if (result == (void *)&_xpc_type_string)
  {
    size_t v10 = 0;
    char string_ptr = xpc_string_get_string_ptr(object);
    BOOL result = sub_10001A1EC(a1, string_ptr, 0, &v10, 1);
    if (result)
    {
      if (a3) {
        xpc_object_t v8 = &qword_100076AD8;
      }
      else {
        xpc_object_t v8 = &qword_100076AD0;
      }
      uint64_t v9 = *v8;
      *BOOL result = *v8;
      if (v9) {
        *(void *)(v9 + 8) = result;
      }
      *xpc_object_t v8 = (uint64_t)result;
      result[1] = v8;
    }
  }
  return result;
}

uint64_t sub_10004B5E0(const char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_string)
  {
    uint64_t result = strcmp(a1, "MallocStackLogging");
    if (result)
    {
      char string_ptr = xpc_string_get_string_ptr(object);
      uint64_t result = (uint64_t)sub_100015BE4("%s=%s", a1, string_ptr);
      uint64_t v8 = *a3;
      *(void *)(qword_100076A28 + 8 * *a3) = result;
      *a3 = v8 + 1;
    }
  }
  return result;
}

BOOL sub_10004B674(id a1, unint64_t a2, void *a3)
{
  if (a3 && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v4 = qword_100076AB0;
    char string_ptr = xpc_string_get_string_ptr(a3);
    sub_100045E1C(v4, string_ptr, &_xpc_BOOL_true);
  }
  return 1;
}

void sub_10004B6DC(uint64_t a1)
{
  xpc_object_t v2 = *(void **)(a1 + 32);
  __int16 v3 = fopen(*(const char **)(a1 + 40), "w");
  if (v3)
  {
    uint64_t v4 = v3;
    fprintf(v3, "%s\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">");
    if (xpc_dictionary_get_count(v2))
    {
      fwrite("<dict>\n", 7uLL, 1uLL, v4);
      xpc_dictionary_apply_f();
      uint64_t v5 = "</dict>\n";
    }
    else
    {
      uint64_t v5 = "<dict/>\n";
    }
    fwrite(v5, 8uLL, 1uLL, v4);
    fwrite("</plist>\n", 9uLL, 1uLL, v4);
    sub_10003E6D4(v4);
  }
  else if (*__error())
  {
    _os_assumes_log();
  }
  xpc_release(*(xpc_object_t *)(a1 + 32));
  uint64_t v6 = *(void **)(a1 + 40);

  free(v6);
}

void *sub_10004B7F0(char *a1, xpc_object_t object, FILE *a3)
{
  xpc_object_t v4 = object;
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary
    || (uint64_t result = xpc_dictionary_get_value(v4, "Disabled"), (v4 = result) != 0))
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_BOOL || (uint64_t result = xpc_get_type(v4), result == &_xpc_type_string))
    {
      uint64_t result = strchr(a1, 60);
      if (!result)
      {
        fprintf(a3, "\t<key>%s</key>\n", a1);
        if (v4 == &_xpc_BOOL_true)
        {
          uint64_t v8 = "\t<true/>\n";
          size_t v9 = 9;
        }
        else
        {
          if (v4 != &_xpc_BOOL_false)
          {
            char string_ptr = xpc_string_get_string_ptr(v4);
            return (void *)fprintf(a3, "\t<string>%s</string>\n", string_ptr);
          }
          uint64_t v8 = "\t<false/>\n";
          size_t v9 = 10;
        }
        return (void *)fwrite(v8, v9, 1uLL, a3);
      }
    }
  }
  return result;
}

uint64_t (*sub_10004B934(uint64_t a1))()
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 73) >= 0xFFFFFFF7) {
    return off_1000717D0[5 * (v1 - 64) + 5];
  }
  else {
    return 0;
  }
}

_DWORD *sub_10004B968(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_100047268();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t *sub_10004B9CC(uint64_t *result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) != 0 && *((_DWORD *)result + 6) == 1 && *((_DWORD *)result + 1) == 40)
  {
    if (*((unsigned __int16 *)result + 19) << 16 == 0x100000)
    {
      uint64_t result = sub_100047290(*((unsigned int *)result + 3), *((_DWORD *)result + 7));
      *(_DWORD *)(a2 + 32) = result;
      return result;
    }
    int v3 = -300;
  }
  else
  {
    int v3 = -304;
  }
  *(_DWORD *)(a2 + 32) = v3;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_10004BA54(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_10004736C();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

_DWORD *sub_10004BAB8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_100047394();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

_DWORD *sub_10004BB14(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_1000473BC();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t sub_10004BB78(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 73) >= 0xFFFFFFF7
    && (uint64_t v5 = (void (*)(void))off_1000717D0[5 * (v4 - 64) + 5]) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sub_10004BC04(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 440) >= 0xFFFFFFD8) {
    return (uint64_t)*(&off_100071958 + 5 * (v1 - 400) + 5);
  }
  else {
    return 0;
  }
}

_DWORD *sub_10004BC38(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 552 || (uint64_t result = memchr(result + 8, 0, 0x200uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(void *)(a2 + 32) = 0x14000000000000;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004BCF4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_10000FDBC();
    *(_DWORD *)(a2 + 32) = result;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_10004BD58(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 168 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(void *)(a2 + 32) = 0x10000000000000;
  uint64_t result = (_DWORD *)sub_10000FDC4();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 64;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_10004BE24(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 184) {
    goto LABEL_7;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }
  uint64_t result = (uint64_t)memchr((void *)(result + 48), 0, 0x80uLL);
  if (!result)
  {
LABEL_7:
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  uint64_t result = sub_10000FDC4();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_10004BED4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 188 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  uint64_t result = (_DWORD *)sub_10000FDD4();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004BF94(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0 && result[1] == 164 && (uint64_t result = memchr(result + 8, 0, 0x80uLL)) != 0)
  {
    uint64_t result = (_DWORD *)sub_10000FDBC();
    *(_DWORD *)(a2 + 32) = result;
  }
  else
  {
    *(_DWORD *)(a2 + 32) = -304;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_10004C01C(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(void *)(a2 + 32) = 0x14000000000000;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_10004C0AC(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 40)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  uint64_t result = sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004C164(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(_DWORD *)(a2 + 68) = 16777473;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  int v3 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 84) << 7;
  *(_DWORD *)(a2 + 56) = v3 << 7;
  *(_DWORD *)(a2 + 72) = 4 * *(_DWORD *)(a2 + 92);
  *(NDR_record_t *)(a2 + 76) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 96;
  *(_DWORD *)(a2 + 24) = 3;
  return result;
}

uint64_t sub_10004C244(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 40)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }
  *(void *)(a2 + 32) = 0x14000000000000;
  uint64_t result = sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004C2FC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 96) = 0;
  *(void *)(a2 + 32) = 0x11000000000000;
  *(void *)(a2 + 44) = 0x10000000000000;
  *(_DWORD *)(a2 + 60) = 16777473;
  *(_DWORD *)(a2 + 76) = (*(unsigned __int8 *)(a2 + 77) << 8) | 0x2110001;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  int v3 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a2 + 80) = v3;
  *(NDR_record_t *)(a2 + 84) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 100;
  *(_DWORD *)(a2 + 24) = 4;
  return result;
}

_DWORD *sub_10004C3E8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_10000FDBC();
    *(_DWORD *)(a2 + 32) = result;
    NDR_record_t v3 = NDR_record;
    if (!result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 164;
      return result;
    }
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_10004C464(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_10000FDC4();
    *(_DWORD *)(a2 + 32) = result;
    NDR_record_t v3 = NDR_record;
    if (!result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 44;
      return result;
    }
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_10004C4EC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0
    && (uint64_t v3 = result[1], v3 >= 0x30)
    && v3 <= 0x830
    && ((unsigned int v4 = result[11], v4 <= 0x800) ? (v5 = (int)v3 - 48 >= v4) : (v5 = 0),
        (unsigned int v6 = ((v4 + 3) & 0xFFFFFFFC) + 48, v5) ? (v7 = v3 == v6) : (v7 = 0),
        v7 && (uint64_t result = memchr(result + 12, 0, v3 - 48)) != 0))
  {
    uint64_t result = (_DWORD *)sub_10000FDBC();
    *(_DWORD *)(a2 + 32) = result;
  }
  else
  {
    *(_DWORD *)(a2 + 32) = -304;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_10004C5A0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_10004C634(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 196) {
    goto LABEL_8;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_9;
  }
  uint64_t result = (uint64_t)memchr((void *)(result + 60), 0, 0x80uLL);
  if (!result)
  {
LABEL_8:
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  uint64_t result = sub_10000FDBC();
  *(_DWORD *)(a2 + 32) = result;
LABEL_10:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_10004C6F8(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    int v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(unsigned char *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 60))
  {
    int v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004C7E0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_10004C88C(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned char *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    int v3 = -300;
    goto LABEL_8;
  }
  uint64_t result = sub_10000FDBC();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_10004C920(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0 && result[1] == 164 && (uint64_t result = memchr(result + 8, 0, 0x80uLL)) != 0)
  {
    uint64_t result = (_DWORD *)sub_10000FDBC();
    *(_DWORD *)(a2 + 32) = result;
    NDR_record_t v3 = NDR_record;
    if (!result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_10004C9C8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 84) = 0;
  *(_DWORD *)(a2 + 36) = (*(unsigned __int8 *)(a2 + 37) << 8) | 0x2110001;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(_DWORD *)(a2 + 68) = 16777473;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  int v3 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 56) = v3 << 7;
  *(_DWORD *)(a2 + 72) = 4 * *(_DWORD *)(a2 + 92);
  *(NDR_record_t *)(a2 + 76) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 96;
  *(_DWORD *)(a2 + 24) = 3;
  return result;
}

uint64_t sub_10004CAB0(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 188) {
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_10;
  }
  uint64_t result = (uint64_t)memchr((void *)(result + 60), 0, 0x80uLL);
  if (!result)
  {
LABEL_9:
    int v3 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_11;
  }
  *(void *)(a2 + 32) = 0x14000000000000;
  uint64_t result = sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_11:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004CBA0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    NDR_record_t v3 = NDR_record;
  }
  else
  {
    uint64_t result = (_DWORD *)sub_10000FDBC();
    *(_DWORD *)(a2 + 32) = result;
    NDR_record_t v3 = NDR_record;
    if (!result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_10004CC24(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 160 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(void *)(a2 + 32) = 0x14000000000000;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_10004CCD8(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 176) {
    goto LABEL_7;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_8;
  }
  uint64_t result = (uint64_t)memchr((void *)(result + 48), 0, 0x80uLL);
  if (!result)
  {
LABEL_7:
    int v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  uint64_t result = sub_10000FDBC();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_10004CD84(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    int v3 = -304;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_8;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    int v3 = -300;
    goto LABEL_7;
  }
  uint64_t result = sub_10000FDBC();
  *(_DWORD *)(a2 + 32) = result;
LABEL_8:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_10004CE10(uint64_t result, uint64_t a2)
{
  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 68)
  {
    int v3 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_11;
  }
  if (*(unsigned char *)(result + 39) != 1
    || *(unsigned __int16 *)(result + 54) << 16 != 1114112
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 64))
  {
    int v3 = -300;
    goto LABEL_10;
  }
  *(void *)(a2 + 32) = 0x10000000000000;
  uint64_t result = sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_11:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 52;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004CEFC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(void *)(a2 + 32) = 0x11000000000000;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void sub_10004CF88(uint64_t a1, uint64_t a2)
{
  if ((*(_DWORD *)a1 & 0x80000000) == 0 || *(_DWORD *)(a1 + 24) != 3 || *(_DWORD *)(a1 + 4) != 88)
  {
    int v5 = -304;
LABEL_12:
    *(_DWORD *)(a2 + 32) = v5;
    goto LABEL_13;
  }
  if (*(unsigned char *)(a1 + 39) != 1
    || *(_WORD *)(a1 + 54) != 529
    || *(unsigned __int16 *)(a1 + 70) << 16 != 1114112
    || *(_DWORD *)(a1 + 40) != *(_DWORD *)(a1 + 80)
    || *(_DWORD *)(a1 + 56) != *(_DWORD *)(a1 + 84))
  {
    int v5 = -300;
    goto LABEL_12;
  }
  *(_DWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = (*(unsigned __int8 *)(a2 + 53) << 8) | 0x2110001;
  int v4 = sub_10000FDBC();
  mig_deallocate(*(void *)(a1 + 44), (4 * *(_DWORD *)(a1 + 56)));
  *(void *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  if (v4)
  {
    *(_DWORD *)(a2 + 32) = v4;
LABEL_13:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return;
  }
  int v6 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 56) = v6;
  *(NDR_record_t *)(a2 + 60) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 76;
  *(_DWORD *)(a2 + 24) = 2;
}

_DWORD *sub_10004D0F8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 52) = 0;
  *(_DWORD *)(a2 + 36) = (*(unsigned __int8 *)(a2 + 37) << 8) | 0x2140001;
  uint64_t result = (_DWORD *)sub_10000FDBC();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004D1AC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 188 || (uint64_t result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(void *)(a2 + 32) = 0x13000000000000;
  uint64_t result = (_DWORD *)sub_10000FDC8();
  if (result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_10004D290(_DWORD *a1, uint64_t a2)
{
  int v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  int v4 = a1[5];
  if ((v4 - 440) >= 0xFFFFFFD8
    && (int v5 = (void (*)(void))*(&off_100071958 + 5 * (v4 - 400) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sub_10004D31C(unsigned int a1, const char *a2)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  memset(&reply_port, 0, sizeof(reply_port));
  NDR_record_t v8 = NDR_record;
  if (&_mig_strncpy_zerofill) {
    int v3 = mig_strncpy_zerofill((char *)v9 + 8, a2, 128);
  }
  else {
    int v3 = mig_strncpy((char *)v9 + 8, a2, 128);
  }
  LODWORD(v9[0]) = 0;
  DWORD1(v9[0]) = v3;
  reply_port.msgh_bits = 5395;
  reply_port.msgh_size_t size = ((v3 + 3) & 0xFFFFFFFC) + 40;
  *(void *)&reply_port.msgh_remote_mach_port_t port = __PAIR64__(mig_get_reply_port(), a1);
  *(void *)&reply_port.msgh_voucher_mach_port_t port = 0xB4700000000;
  uint64_t v4 = mach_msg2_internal();
  uint64_t v5 = v4;
  if ((v4 - 268435458) <= 0xE && ((1 << (v4 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(reply_port.msgh_local_port);
  }
  else if (v4)
  {
    mig_dealloc_reply_port(reply_port.msgh_local_port);
  }
  else
  {
    uint64_t v5 = 4294966995;
    mach_msg_destroy(&reply_port);
  }
  return v5;
}

uint64_t sub_10004D4F4(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a2 = *(_DWORD *)a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  int v3 = *(_DWORD *)(a1 + 20) + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  if (*(_DWORD *)(a1 + 20) == 5300)
  {
    if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 44)
    {
      *(_DWORD *)(a2 + 32) = -304;
      *(NDR_record_t *)(a2 + 24) = NDR_record;
    }
    else
    {
      *(_DWORD *)(a2 + 32) = sub_10002E9C8(*(unsigned int *)(a1 + 12), *(void *)(a1 + 32));
    }
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

void *sub_10004D5B4(void *result, unint64_t a2, uint64_t *a3)
{
  *a3 = 0;
  uint64_t v9 = 0;
  if (a2 <= 1 || *result != 7) {
    return &unk_100071FF8;
  }
  unint64_t v3 = (unint64_t)&result[4 * a2];
  uint64_t v4 = (void *)(v3 - 32);
  if (v3 >= 0x20 && v4 >= result)
  {
    if (*v4 == 8)
    {
      BOOL v7 = result + 4;
      NDR_record_t v8 = &result[4 * a2];
      int v6 = (void *)sub_1000509E4((uint64_t)result, (unint64_t *)&v7, &v9);
      if (v6 == &unk_100071FD8)
      {
        if (v7 == v8)
        {
          ccder_sizeof();
          *a3 = ccder_sizeof();
        }
        else
        {
          return &unk_100072018;
        }
      }
      return v6;
    }
    return &unk_100071FF8;
  }
  __break(0x5519u);
  return result;
}

void *sub_10004D694(void *a1, unsigned char *a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  unint64_t v21 = 0;
  unint64_t v22 = 0;
  if (a5 > a6) {
    goto LABEL_30;
  }
  unint64_t v21 = a5;
  unint64_t v22 = a6;
  if (a6 > a5)
  {
    unint64_t v12 = a3 + 32 * a4;
    uint64_t v13 = (void *)(v12 - 32);
    uint64_t v14 = a4;
    while ((--v14 & 0x8000000000000000) == 0)
    {
      if ((unint64_t)(v13 + 4) > v12 || (unint64_t)v13 < a3) {
        goto LABEL_30;
      }
      int v15 = 4;
      switch(*v13)
      {
        case 1:
          uint64_t v18 = 0;
          uint64_t v19 = 0;
          ccder_blob_reserve_tl();
          int v6 = &unk_100071FF8;
          int v15 = 1;
          goto LABEL_6;
        case 2:
        case 3:
          if ((unint64_t)v13 >= v12 || v13[1] + v13[2] < v13[1]) {
            goto LABEL_30;
          }
          if ((ccder_blob_encode_body_tl() & 1) == 0) {
            return &unk_100071FF8;
          }
LABEL_5:
          int v15 = 4;
          goto LABEL_6;
        case 4:
          if (sub_100050B98()) {
            goto LABEL_5;
          }
          return &unk_100071FF8;
        case 5:
        case 7:
          if ((ccder_blob_encode_tl() & 1) == 0) {
            return &unk_100071FF8;
          }
          goto LABEL_5;
        case 9:
          if ((unint64_t)v13 >= v12 || v13[1] + v13[2] < v13[1]) {
            goto LABEL_30;
          }
          int v15 = 4;
          if ((ccder_blob_encode_body_tl() & 1) == 0) {
            return &unk_100071FF8;
          }
LABEL_6:
          v13 -= 4;
          if (v15 != 4) {
            return v6;
          }
          break;
        default:
          goto LABEL_6;
      }
    }
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  if ((ccder_blob_reserve_tl() & 1) == 0) {
    return &unk_100072018;
  }
  if (!a4)
  {
LABEL_30:
    __break(0x5519u);
    JUMPOUT(0x10004D988);
  }
  ccder_sizeof();
  ccder_sizeof();
  if ((ccder_blob_encode_tl() & 1) == 0) {
    return &unk_100072018;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int v6 = sub_10004F40C(a1, a2, &v18, a5, a6);
  if (v6 != (void *)&unk_100071FD8) {
    cc_clear();
  }
  return v6;
}

uint64_t sub_10004D9AC(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = result;
  if (!*(unsigned char *)(a2 + 33))
  {
LABEL_6:
    long long v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v4 = *(_OWORD *)a2;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
    uint64_t v11 = *(void *)(a2 + 48);
LABEL_7:
    *(void *)(v4 + 48) = v11;
    return result;
  }
  unint64_t v6 = *(void *)a2;
  unint64_t v7 = *(void *)a2 + 64;
  uint64_t v8 = *(void *)a3;
  switch(*(void *)a3 & 0xBFFFFFFFFFFFFFFFLL)
  {
    case 0uLL:
      uint64_t v9 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v9) {
        goto LABEL_6;
      }
      if (v6 >= v7) {
        goto LABEL_319;
      }
      uint64_t result = v9(v6, "[%s]: %s\n", "der_vm_execute_nocopy", "noop");
      goto LABEL_6;
    case 1uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v33 = *(_OWORD *)(a2 + 16);
      long long v131 = *(_OWORD *)a2;
      long long v132 = v33;
      LOBYTE(v133) = *(unsigned char *)(a2 + 32);
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 34);
      *(uint64_t *)((char *)&v130[1] + 6) = *(void *)(a2 + 48);
      *((void *)&v131 + 1) = 0;
      *(void *)&long long v132 = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        __s1 = *(void **)(a3 + 8);
        uint64_t v34 = (size_t *)(a3 + 16);
      }
      else
      {
        __s1 = (void *)(a3 + 8);
        uint64_t v34 = (size_t *)(a3 + 248);
      }
      size_t v60 = *v34;
      uint64_t v61 = *(void *)(a2 + 16);
      if (v61)
      {
        unint64_t v6 = 0;
        long long v62 = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
        *(_OWORD *)(result + 32) = v62;
        *(_OWORD *)uint64_t result = *(_OWORD *)a2;
        uint64_t v63 = *(void *)(a2 + 40);
        *(void *)(result + 48) = *(void *)(a2 + 48);
        *(unsigned char *)(result + 33) = 0;
        unint64_t v64 = v61 - 1;
        *(void *)(result + 8) = 0;
        *(void *)(result + 16) = 0;
        if (__s1) {
          BOOL v65 = v60 == 0;
        }
        else {
          BOOL v65 = 1;
        }
        char v66 = v65;
        uint64_t v122 = *(void *)(a2 + 8);
        uint64_t v123 = v63;
        while (1)
        {
          unint64_t v67 = (v6 + v64) >> 1;
          if (v66) {
            goto LABEL_327;
          }
          unint64_t v68 = *(void *)(v122 + 8 * v67);
          uint64_t v69 = (const void *)(v123 + v68);
          if (!v69) {
            goto LABEL_88;
          }
          if (v60 >= HIDWORD(v68)) {
            size_t v70 = HIDWORD(v68);
          }
          else {
            size_t v70 = v60;
          }
          if (v60 < HIDWORD(v68)) {
            int v71 = -1;
          }
          else {
            int v71 = 1;
          }
          uint64_t result = memcmp(__s1, v69, v70);
          if (v60 != HIDWORD(v68) && result == 0) {
            int v73 = v71;
          }
          else {
            int v73 = result;
          }
          if (!v73)
          {
            *(unsigned char *)(v4 + 33) = 1;
            unint64_t v107 = *(void *)(v4 + 40);
            unint64_t v108 = v107 + (HIDWORD(v68) + v68);
            if (v108 <= *(void *)(v4 + 48) && v107 <= v108)
            {
              *(void *)(v4 + 40) = v108;
              return result;
            }
            while (1)
            {
              do
              {
LABEL_319:
                __break(0x5519u);
LABEL_320:
                uint64_t v121 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
                if (v121) {
                  v121(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
                }
              }
              while (v6 && v6 >= v6 + 64);
              (*(void (**)(unint64_t, const char *, ...))(v6 + 32))(v6, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
LABEL_318:
              v129[0] = 0;
              v129[1] = 0;
            }
          }
          if (v73 < 0)
          {
LABEL_327:
            if (v6 + v64 < 2) {
              return result;
            }
            unint64_t v64 = v67 - 1;
            if (v6 > v67 - 1) {
              return result;
            }
          }
          else
          {
LABEL_88:
            unint64_t v6 = v67 + 1;
            if (v67 + 1 > v64) {
              return result;
            }
          }
        }
      }
      v129[0] = 0;
      v129[1] = 0;
      long long v128 = *(_OWORD *)(a2 + 40);
      uint64_t result = sub_10005042C(v6, 0, 0, v129, (uint64_t *)&v128);
      if (result)
      {
        if (v60)
        {
          if (v129[0] < v129[1])
          {
            if (v6 && v6 >= v7) {
              goto LABEL_319;
            }
            while (1)
            {
              __s2 = 0;
              size_t v127 = 0;
              long long v125 = 0uLL;
              uint64_t result = sub_1000505D4(v6, &__s2, &v125, v129);
              if (!result) {
                break;
              }
              if (__s1 && __s2)
              {
                size_t v82 = v127;
                size_t v83 = v60 >= v127 ? v127 : v60;
                uint64_t result = memcmp(__s1, __s2, v83);
                if (!result && v60 == v82)
                {
                  *(_OWORD *)((char *)v130 + 6) = v125;
                  LOBYTE(v85) = 1;
                  goto LABEL_296;
                }
              }
              if (v129[0] >= v129[1]) {
                goto LABEL_256;
              }
            }
            uint64_t v85 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
            if (v85)
            {
              uint64_t result = v85(v6, "[%s]: %s\n", "der_vm_execute_select_key", "invalid dictionary element");
              LOBYTE(v85) = 0;
            }
LABEL_296:
            long long v116 = v132;
            *(_OWORD *)uint64_t v4 = v131;
            *(_OWORD *)(v4 + 16) = v116;
            *(unsigned char *)(v4 + 32) = v133;
            *(unsigned char *)(v4 + 33) = (_BYTE)v85;
            goto LABEL_257;
          }
LABEL_256:
          long long v110 = v132;
          *(_OWORD *)uint64_t v4 = v131;
          *(_OWORD *)(v4 + 16) = v110;
          *(unsigned char *)(v4 + 32) = v133;
          *(unsigned char *)(v4 + 33) = 0;
LABEL_257:
          *(_OWORD *)(v4 + 34) = *(_OWORD *)v130;
          uint64_t v11 = *(uint64_t *)((char *)&v130[1] + 6);
          goto LABEL_7;
        }
        uint64_t v102 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v102) {
          goto LABEL_256;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v103 = "key length is invalid";
      }
      else
      {
        uint64_t v102 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v102) {
          goto LABEL_256;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v103 = "dictionary decoding failure";
      }
      uint64_t result = v102(v6, "[%s]: %s\n", "der_vm_execute_select_key", v103);
      goto LABEL_256;
    case 2uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v19 = *(_OWORD *)(a2 + 32);
      long long v20 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v19;
      *(_OWORD *)uint64_t result = v20;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      uint64_t v21 = *(void *)(a3 + 8);
      long long v131 = 0uLL;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      uint64_t result = sub_10005042C(v6, 0, 0, &v131, v130);
      if (!result)
      {
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v55 = "array decoding failure";
        goto LABEL_231;
      }
      BOOL v22 = (unint64_t)v131 < *((void *)&v131 + 1);
      if ((unint64_t)v131 < *((void *)&v131 + 1) && v21 >= 1)
      {
        while (1)
        {
          uint64_t result = sub_10005042C(v6, 0, 0, 0, (uint64_t *)&v131);
          if ((result & 1) == 0) {
            break;
          }
          uint64_t v23 = v21 - 1;
          BOOL v22 = (unint64_t)v131 < *((void *)&v131 + 1);
          if ((unint64_t)v131 >= *((void *)&v131 + 1) || v21-- <= 1) {
            goto LABEL_150;
          }
        }
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v55 = "encountered invalid element in an array";
LABEL_231:
        uint64_t v56 = "der_vm_execute_select_index";
        return v54(v6, "[%s]: %s\n", v56, v55);
      }
      uint64_t v23 = v21;
LABEL_150:
      if (v22 && v23 == 0)
      {
        if (!v6 || v6 < v7)
        {
          uint64_t result = sub_10005042C(v6, 0, (void *)(v4 + 40), 0, (uint64_t *)&v131);
          *(unsigned char *)(v4 + 33) = result;
          return result;
        }
        goto LABEL_319;
      }
      return result;
    case 3uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      return sub_10004F858(result, (long long *)a2, a3);
    case 4uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v25 = *(_OWORD *)(a2 + 32);
      long long v26 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v25;
      *(_OWORD *)uint64_t result = v26;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        uint64_t v27 = *(void *)(a3 + 8);
        uint64_t v28 = (size_t *)(a3 + 16);
      }
      else
      {
        uint64_t v27 = a3 + 8;
        uint64_t v28 = (size_t *)(a3 + 248);
      }
      size_t v57 = *v28;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      long long v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range();
      if (result)
      {
        if (!v57) {
          goto LABEL_310;
        }
        uint64_t v58 = (const void *)v131;
        if (v57 > *((void *)&v131 + 1) - (void)v131)
        {
LABEL_65:
          *(unsigned char *)(v4 + 33) = 0;
          return result;
        }
        uint64_t result = v27;
        size_t v104 = v57;
        goto LABEL_226;
      }
      uint64_t v59 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v59) {
        return result;
      }
      uint64_t result = v59(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_319;
      }
      uint64_t v55 = "string decode failure";
      uint64_t v56 = "der_vm_execute_match_string_prefix";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 5uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v35 = *(_OWORD *)(a2 + 32);
      long long v36 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v35;
      *(_OWORD *)uint64_t result = v36;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      long long v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range();
      if ((result & 1) == 0)
      {
        uint64_t v74 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v74) {
          goto LABEL_189;
        }
        uint64_t v75 = "Unknown BOOLean encoding";
        goto LABEL_188;
      }
      if (*((void *)&v131 + 1) - (void)v131 == 1)
      {
        if ((unint64_t)v131 >= *((void *)&v131 + 1)) {
          goto LABEL_319;
        }
        BOOL v18 = *(void *)(a3 + 8) == (*(unsigned char *)v131 != 0);
        goto LABEL_237;
      }
      uint64_t v74 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (v74)
      {
        uint64_t v75 = "BOOLean should be exactly 1 byte";
LABEL_188:
        uint64_t result = v74(v6, "[%s]: %s\n", "der_decode_BOOLean", v75);
      }
LABEL_189:
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_319;
      }
      uint64_t v55 = "BOOL decode failure";
      uint64_t v56 = "der_vm_execute_match_BOOL";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 6uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v37 = *(_OWORD *)(a2 + 32);
      long long v38 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v37;
      *(_OWORD *)uint64_t result = v38;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        uint64_t v39 = *(const void **)(a3 + 8);
        uint64_t v40 = (size_t *)(a3 + 16);
      }
      else
      {
        uint64_t v39 = (const void *)(a3 + 8);
        uint64_t v40 = (size_t *)(a3 + 248);
      }
      size_t v76 = *v40;
      uint64_t v77 = *(void *)(a2 + 24);
      long long v78 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      long long v131 = v78;
      uint64_t result = sub_10005042C(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!result || v77 == v130[0]) {
        goto LABEL_114;
      }
      if (v130[0] != 12)
      {
        if (v130[0] == 0x2000000000000010 || v130[0] == 0x6000000000000010)
        {
          v130[0] = v4;
          v130[1] = a3;
          long long v99 = *(_OWORD *)(a2 + 16);
          long long v131 = *(_OWORD *)a2;
          long long v132 = v99;
          long long v133 = *(_OWORD *)(a2 + 32);
          uint64_t v134 = *(void *)(a2 + 48);
          uint64_t v100 = sub_10004F9B8;
          return (uint64_t)sub_10004ECD0((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
        }
LABEL_114:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v54)
        {
          if (v6 >= v7) {
            goto LABEL_319;
          }
          uint64_t v55 = "Unexpected type to match against";
          uint64_t v56 = "der_vm_execute_string_value_allowed";
          return v54(v6, "[%s]: %s\n", v56, v55);
        }
        return result;
      }
      uint64_t result = sub_10004F858((uint64_t)&v131, (long long *)a2, a3);
      if (BYTE1(v133)) {
        goto LABEL_310;
      }
      unint64_t v6 = *(void *)a2;
      *(_OWORD *)uint64_t v129 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)uint64_t v130 = 0uLL;
      if ((ccder_blob_decode_range() & 1) == 0) {
        goto LABEL_320;
      }
      uint64_t result = v130[0];
      if (v130[1] == v130[0]) {
        return result;
      }
      uint64_t v111 = (unsigned char *)(v130[1] - 1);
      if (!v130[1] || (unint64_t)v111 < v130[0]) {
        goto LABEL_319;
      }
      if (*v111 != 42) {
        return result;
      }
      size_t v104 = ~v130[0] + v130[1];
      if (!v104) {
        goto LABEL_310;
      }
      if (v104 > v76) {
        goto LABEL_65;
      }
      uint64_t v58 = v39;
      goto LABEL_226;
    case 7uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v41 = *(_OWORD *)(a2 + 32);
      long long v42 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v41;
      *(_OWORD *)uint64_t result = v42;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      long long v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range();
      if ((result & 1) == 0)
      {
        int v43 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v43) {
          goto LABEL_120;
        }
        uint64_t v44 = "unknown number encoding";
        goto LABEL_119;
      }
      if (*((void *)&v131 + 1) - (void)v131 < 9uLL)
      {
        if ((unint64_t)v131 >= *((void *)&v131 + 1))
        {
          uint64_t v95 = 0;
        }
        else
        {
          uint64_t v94 = 0;
          uint64_t v95 = 0;
          do
          {
            if (!v94 && *(char *)v131 < 0) {
              uint64_t v95 = -1;
            }
            uint64_t v96 = (unsigned __int8 *)(v131 + v94);
            if ((unint64_t)(v131 + v94) >= *((void *)&v131 + 1)
              || (unint64_t)v96 < (unint64_t)v131)
            {
              goto LABEL_319;
            }
            uint64_t v95 = *v96 | (unint64_t)(v95 << 8);
            ++v94;
          }
          while (*((void *)&v131 + 1) - (void)v131 != v94);
        }
        BOOL v18 = v95 == *(void *)(a3 + 8);
        goto LABEL_237;
      }
      int v43 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (v43)
      {
        uint64_t v44 = "number too large";
LABEL_119:
        uint64_t result = v43(v6, "[%s]: %s\n", "der_decode_number", v44);
      }
LABEL_120:
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_319;
      }
LABEL_123:
      uint64_t v55 = "BOOL decode failure";
      uint64_t v56 = "der_vm_execute_match_integer";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 8uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v45 = *(_OWORD *)(a2 + 32);
      long long v46 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v45;
      *(_OWORD *)uint64_t result = v46;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      uint64_t v47 = (const void *)(a3 + 8);
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        uint64_t v49 = *(void *)(a3 + 8);
        uint64_t v48 = (size_t *)(a3 + 16);
      }
      else
      {
        uint64_t v48 = (size_t *)(a3 + 248);
        uint64_t v49 = a3 + 8;
      }
      size_t v79 = *v48;
      uint64_t v80 = *(void *)(a2 + 24);
      long long v81 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      long long v131 = v81;
      uint64_t result = sub_10005042C(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!result || v80 == v130[0]) {
        goto LABEL_127;
      }
      if (v130[0] != 12)
      {
        if (v130[0] == 0x2000000000000010 || v130[0] == 0x6000000000000010)
        {
          v130[0] = v4;
          v130[1] = a3;
          long long v101 = *(_OWORD *)(a2 + 16);
          long long v131 = *(_OWORD *)a2;
          long long v132 = v101;
          long long v133 = *(_OWORD *)(a2 + 32);
          uint64_t v134 = *(void *)(a2 + 48);
          uint64_t v100 = sub_10004FB6C;
          return (uint64_t)sub_10004ECD0((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
        }
LABEL_127:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v54)
        {
          if (v6 >= v7) {
            goto LABEL_319;
          }
          uint64_t v55 = "Unexpected type to match against";
          uint64_t v56 = "der_vm_execute_string_prefix_value_allowed";
          return v54(v6, "[%s]: %s\n", v56, v55);
        }
        return result;
      }
      if ((*(unsigned char *)(a3 + 7) & 0x40) != 0)
      {
        uint64_t v47 = *(const void **)(a3 + 8);
        uint64_t v112 = (size_t *)(a3 + 16);
      }
      else
      {
        uint64_t v112 = (size_t *)(a3 + 248);
      }
      unint64_t v6 = *(void *)a2;
      size_t v113 = *v112;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      long long v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range();
      if (result)
      {
        if (!v113) {
          goto LABEL_310;
        }
        if (v113 <= *((void *)&v131 + 1) - (void)v131)
        {
          uint64_t result = memcmp(v47, (const void *)v131, v113);
          if (!result) {
            goto LABEL_310;
          }
        }
      }
      else
      {
        uint64_t v114 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v114)
        {
          v114(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
          uint64_t v115 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
          if (v115)
          {
            if (v6 && v6 >= v6 + 64) {
              goto LABEL_319;
            }
            v115(v6, "[%s]: %s\n", "der_vm_execute_match_string_prefix", "string decode failure");
          }
        }
      }
      unint64_t v6 = *(void *)a2;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      long long v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range();
      if ((result & 1) == 0) {
        goto LABEL_320;
      }
      if (v79)
      {
        uint64_t v58 = (const void *)v131;
        if (v79 > *((void *)&v131 + 1) - (void)v131) {
          goto LABEL_65;
        }
        uint64_t result = v49;
        size_t v104 = v79;
LABEL_226:
        uint64_t result = memcmp((const void *)result, v58, v104);
        BOOL v18 = result == 0;
LABEL_237:
        char v105 = v18;
        goto LABEL_311;
      }
      goto LABEL_310;
    case 9uLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v29 = *(_OWORD *)(a2 + 32);
      long long v30 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v29;
      *(_OWORD *)uint64_t result = v30;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      long long v131 = 0uLL;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      uint64_t result = sub_10005042C(v6, 0, 0, &v131, v130);
      if ((result & 1) == 0)
      {
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v55 = "dictionary decoding failure";
        goto LABEL_249;
      }
      if ((*(unsigned char *)(a3 + 7) & 0x40) != 0)
      {
        size_t v31 = *(const void **)(a3 + 8);
        int v32 = (void **)(a3 + 16);
      }
      else
      {
        size_t v31 = (const void *)(a3 + 8);
        int v32 = (void **)(a3 + 248);
      }
      uint64_t v87 = (char *)*v32;
      if (!*v32)
      {
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v55 = "key length is invalid";
        goto LABEL_249;
      }
      if ((unint64_t)v131 >= *((void *)&v131 + 1)) {
        return result;
      }
      if (v6 && v6 >= v7) {
        goto LABEL_318;
      }
      while (2)
      {
        v129[0] = 0;
        v129[1] = 0;
        long long v128 = 0uLL;
        uint64_t result = sub_1000505D4(v6, v129, &v128, &v131);
        if (result)
        {
          uint64_t v88 = (char *)v129[1];
          if (v129[1])
          {
            uint64_t v89 = v129[0];
            uint64_t v90 = (char *)v129[1] - 1;
            uint64_t v91 = (char *)v129[0] + (unint64_t)v129[1] - 1;
            if (v91 < v129[0] || v91 >= (char *)v129[0] + (unint64_t)v129[1]) {
              goto LABEL_319;
            }
            if (*v91 == 42)
            {
              if (v129[1] == (void *)1 || v90 <= v87 && (uint64_t result = memcmp(v129[0], v31, (size_t)v90), !result))
              {
LABEL_164:
                *(unsigned char *)(v4 + 33) = 1;
                *(_OWORD *)(v4 + 40) = v128;
              }
LABEL_165:
              if ((unint64_t)v131 >= *((void *)&v131 + 1)) {
                return result;
              }
              continue;
            }
          }
          else
          {
            uint64_t v89 = v129[0];
          }
          if (v31 && v89)
          {
            uint64_t v93 = v87 >= v129[1] ? v129[1] : v87;
            uint64_t result = memcmp(v31, v89, (size_t)v93);
            if (v87 == v88 && !result) {
              goto LABEL_164;
            }
          }
          goto LABEL_165;
        }
        break;
      }
      uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54) {
        return result;
      }
      uint64_t v55 = "invalid dictionary element";
LABEL_249:
      uint64_t v56 = "der_vm_execute_select_longest_matching_key";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 0xAuLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v50 = *(_OWORD *)(a2 + 32);
      long long v51 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v50;
      *(_OWORD *)uint64_t result = v51;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      uint64_t v52 = *(void *)(a2 + 24);
      long long v53 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      long long v131 = v53;
      uint64_t result = sub_10005042C(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!result || v52 == v130[0]) {
        goto LABEL_58;
      }
      if (v130[0] == 0x6000000000000010 || v130[0] == 0x2000000000000010)
      {
        v130[0] = v4;
        v130[1] = a3;
        long long v106 = *(_OWORD *)(a2 + 16);
        long long v131 = *(_OWORD *)a2;
        long long v132 = v106;
        long long v133 = *(_OWORD *)(a2 + 32);
        uint64_t v134 = *(void *)(a2 + 48);
        uint64_t v100 = sub_10004FD84;
        return (uint64_t)sub_10004ECD0((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
      }
      if (v130[0] != 2)
      {
LABEL_58:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 >= v7) {
          goto LABEL_319;
        }
        uint64_t v55 = "Unexpected type to match against";
        uint64_t v56 = "der_vm_execute_integer_value_allowed";
        return v54(v6, "[%s]: %s\n", v56, v55);
      }
      unint64_t v6 = *(void *)a2;
      *(_OWORD *)uint64_t v130 = *(_OWORD *)(a2 + 40);
      long long v131 = 0uLL;
      uint64_t result = ccder_blob_decode_range();
      if ((result & 1) == 0)
      {
        uint64_t v97 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v97)
        {
          uint64_t v98 = "unknown number encoding";
          goto LABEL_274;
        }
LABEL_275:
        uint64_t v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54) {
          return result;
        }
        if (v6 && v6 >= v6 + 64) {
          goto LABEL_319;
        }
        goto LABEL_123;
      }
      if (*((void *)&v131 + 1) - (void)v131 >= 9uLL)
      {
        uint64_t v97 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v97)
        {
          uint64_t v98 = "number too large";
LABEL_274:
          uint64_t result = v97(v6, "[%s]: %s\n", "der_decode_number", v98);
          goto LABEL_275;
        }
        goto LABEL_275;
      }
      if ((unint64_t)v131 >= *((void *)&v131 + 1))
      {
        uint64_t v118 = 0;
      }
      else
      {
        uint64_t v117 = 0;
        uint64_t v118 = 0;
        do
        {
          if (!v117 && *(char *)v131 < 0) {
            uint64_t v118 = -1;
          }
          int v119 = (unsigned __int8 *)(v131 + v117);
          if ((unint64_t)(v131 + v117) >= *((void *)&v131 + 1)
            || (unint64_t)v119 < (unint64_t)v131)
          {
            goto LABEL_319;
          }
          uint64_t v118 = *v119 | (unint64_t)(v118 << 8);
          ++v117;
        }
        while (*((void *)&v131 + 1) - (void)v131 != v117);
      }
      if (v118 != *(void *)(a3 + 8)) {
        return result;
      }
LABEL_310:
      char v105 = 1;
LABEL_311:
      *(unsigned char *)(v4 + 33) = v105;
      return result;
    case 0xBuLL:
      if (a2 + 56 < a2) {
        goto LABEL_319;
      }
      long long v12 = *(_OWORD *)(a2 + 32);
      long long v13 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v12;
      *(_OWORD *)uint64_t result = v13;
      *(void *)(result + 48) = *(void *)(a2 + 48);
      *(unsigned char *)(result + 33) = 0;
      *(void *)(result + 8) = 0;
      *(void *)(result + 16) = 0;
      uint64_t v14 = *(void *)(a3 + 8);
      if ((unint64_t)(v14 - 7) < 0xFFFFFFFFFFFFFFFALL) {
        return result;
      }
      uint64_t v15 = *(void *)(a2 + 24);
      long long v16 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      long long v131 = v16;
      uint64_t result = sub_10005042C(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!result) {
        return result;
      }
      if (v15 == v130[0])
      {
        int v17 = 1;
LABEL_13:
        BOOL v18 = v17 == v14;
        goto LABEL_237;
      }
      if (v130[0] > 0x200000000000000FLL)
      {
        if (v130[0] == 0x6000000000000010 || v130[0] == 0x2000000000000010)
        {
          int v17 = 2;
          goto LABEL_13;
        }
      }
      else
      {
        int v17 = 5;
        switch(v130[0])
        {
          case 1:
            goto LABEL_13;
          case 2:
            int v17 = 3;
            goto LABEL_13;
          case 4:
            int v17 = 6;
            goto LABEL_13;
          case 0xCLL:
            int v17 = 4;
            goto LABEL_13;
          default:
            return result;
        }
      }
      return result;
    default:
      if (v6) {
        BOOL v120 = v6 >= v7;
      }
      else {
        BOOL v120 = 0;
      }
      if (v120) {
        goto LABEL_319;
      }
      (*(void (**)(unint64_t, const char *, ...))(v6 + 32))(v6, "[%s]: %s\n", "der_vm_execute_nocopy", "unhandled opcode");
      goto LABEL_318;
  }
}

uint64_t sub_10004EB30@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  if (a2 && a2 + 256 < a2)
  {
    __break(0x5519u);
  }
  else
  {
    long long v3 = *(_OWORD *)(result + 16);
    v4[0] = *(_OWORD *)result;
    v4[1] = v3;
    void v4[2] = *(_OWORD *)(result + 32);
    uint64_t v5 = *(void *)(result + 48);
    return sub_10004D9AC(a3, (unint64_t)v4, a2);
  }
  return result;
}

uint64_t sub_10004EB88(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 33);
}

uint64_t sub_10004EB90(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = 0;
  if (!*(unsigned char *)(a1 + 33)) {
    return 0;
  }
  uint64_t v4 = *(void *)a1;
  long long v7 = *(_OWORD *)(a1 + 40);
  uint64_t result = sub_10005042C(v4, &v8, 0, 0, (uint64_t *)&v7);
  if (!result) {
    return result;
  }
  uint64_t v6 = v8;
  if (a2) {
    *a2 = v8;
  }
  if (*(void *)(a1 + 24) == v6) {
    return 1;
  }
  if (v6 > 0x200000000000000FLL)
  {
    if (v6 == 0x6000000000000010 || v6 == 0x2000000000000010) {
      return 2;
    }
    return 0;
  }
  uint64_t result = 5;
  switch(v6)
  {
    case 1:
      return result;
    case 2:
      uint64_t result = 3;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return 0;
    case 4:
      uint64_t result = 6;
      break;
    case 12:
      uint64_t result = 4;
      break;
    default:
      return v6 == 0xA000000000000010;
  }
  return result;
}

void *sub_10004ECD0(unint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a1 + 56 < a1) {
    goto LABEL_41;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  uint64_t v15 = sub_10004F000;
  long long v16 = &unk_100071FB8;
  uint64_t v17 = a2;
  uint64_t v18 = a3;
  if (!*(unsigned char *)(a1 + 33)) {
    return &unk_100071FF8;
  }
  unint64_t v4 = *(void *)a1;
  unint64_t v5 = *(void *)a1 + 64;
  unint64_t v30 = 0;
  v31[0] = 0;
  unint64_t v29 = 0;
  long long v28 = *(_OWORD *)(a1 + 40);
  if ((sub_10005042C(v4, v31, 0, &v29, (uint64_t *)&v28) & 1) == 0)
  {
    long long v7 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
    if (!v7) {
      return &unk_100072018;
    }
    if (!v4 || v4 < v5)
    {
      uint64_t v8 = "iterable decoding failure";
      goto LABEL_39;
    }
    goto LABEL_41;
  }
  if (*(void *)(a1 + 24) == v31[0])
  {
LABEL_6:
    int v6 = 1;
    goto LABEL_14;
  }
  int v6 = 2;
  if (v31[0] != 0x6000000000000010 && v31[0] != 0x2000000000000010)
  {
    if (v31[0] == 0xA000000000000010) {
      goto LABEL_6;
    }
    long long v13 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
    if (!v13) {
      return &unk_100071FF8;
    }
    if (!v4 || v4 < v5)
    {
      v13(v4, "[%s]: %s\n", "der_vm_iterate_b", "iteration over a non-iterable type");
      return &unk_100071FF8;
    }
LABEL_41:
    __break(0x5519u);
    JUMPOUT(0x10004EFD0);
  }
  while (1)
  {
LABEL_14:
    if (v29 >= v30) {
      return &unk_100071FD8;
    }
    long long v10 = *(_OWORD *)(a1 + 16);
    long long v11 = *(_OWORD *)(a1 + 32);
    v19[0] = *(_OWORD *)a1;
    v19[1] = v10;
    v19[2] = v11;
    uint64_t v20 = *(void *)(a1 + 48);
    long long v21 = v19[0];
    long long v22 = v10;
    long long v23 = v11;
    uint64_t v24 = v20;
    int v25 = v6;
    int v26 = 0;
    uint64_t v27 = 0;
    if ((sub_10005042C(*(void *)a1, v31, (void *)&v23 + 1, 0, (uint64_t *)&v29) & 1) == 0) {
      break;
    }
    if (*((void *)&v22 + 1) == v31[0])
    {
      int v9 = 1;
    }
    else if (v31[0] > 0x200000000000000FLL)
    {
      if (v31[0] == 0x6000000000000010 || v31[0] == 0x2000000000000010) {
        int v9 = 2;
      }
      else {
LABEL_23:
      }
        int v9 = 0;
    }
    else
    {
      int v9 = 5;
      switch(v31[0])
      {
        case 1:
          break;
        case 2:
          int v9 = 3;
          break;
        case 4:
          int v9 = 6;
          break;
        case 0xCLL:
          int v9 = 4;
          break;
        default:
          goto LABEL_23;
      }
    }
    int v26 = v9;
    if ((v15((uint64_t)v14, (uint64_t)v19) & 1) == 0) {
      return &unk_100071FD8;
    }
  }
  long long v7 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
  if (!v7) {
    return &unk_100072018;
  }
  if (v4 && v4 >= v5) {
    goto LABEL_41;
  }
  uint64_t v8 = "encountered invalid element in an iterable";
LABEL_39:
  v7(v4, "[%s]: %s\n", "der_vm_iterate_b", v8);
  return &unk_100072018;
}

uint64_t sub_10004F000(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 120) = *(void *)(a1 + 32);
  int v2 = *(uint64_t (**)(_OWORD *))(a1 + 40);
  long long v3 = *(_OWORD *)(a2 + 80);
  v8[4] = *(_OWORD *)(a2 + 64);
  v8[5] = v3;
  long long v4 = *(_OWORD *)(a2 + 112);
  void v8[6] = *(_OWORD *)(a2 + 96);
  void v8[7] = v4;
  long long v5 = *(_OWORD *)(a2 + 16);
  v8[0] = *(_OWORD *)a2;
  v8[1] = v5;
  long long v6 = *(_OWORD *)(a2 + 48);
  v8[2] = *(_OWORD *)(a2 + 32);
  _OWORD v8[3] = v6;
  return v2(v8);
}

uint64_t sub_10004F050(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (ccder_blob_decode_range()) {
    return 0;
  }
  long long v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3) {
    v3(v1, "[%s]: %s\n", "der_decode_number", "unknown number encoding");
  }
  if (v1)
  {
    if (v1 >= v1 + 64) {
      __break(0x5519u);
    }
  }
  long long v4 = (unint64_t *)(*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_integer_from_context", "Attempting to select an integer value from a non-integer DER object");
  return sub_10004F174(v4);
}

uint64_t sub_10004F174(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (ccder_blob_decode_range()) {
    return 0;
  }
  long long v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3) {
    v3(v1, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
  }
  if (v1)
  {
    if (v1 >= v1 + 64) {
      __break(0x5519u);
    }
  }
  uint64_t v4 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
  return sub_10004F22C(v4);
}

uint64_t sub_10004F22C(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (ccder_blob_decode_range())
  {
    int v2 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v2)
    {
      long long v3 = "BOOLean should be exactly 1 byte";
      goto LABEL_6;
    }
  }
  else
  {
    int v2 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v2)
    {
      long long v3 = "Unknown BOOLean encoding";
LABEL_6:
      v2(v1, "[%s]: %s\n", "der_decode_BOOLean", v3);
    }
  }
  if (v1 && v1 >= v1 + 64) {
    __break(0x5519u);
  }
  uint64_t v4 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_BOOL_from_context", "Attempting to select a BOOLean value from a non-BOOLean DER object");
  return sub_10004F314(v4);
}

void *sub_10004F314(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (ccder_blob_decode_range()) {
    return 0;
  }
  long long v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3) {
    v3(v1, "[%s]: %s\n", "der_decode_data", "Unknown data encoding");
  }
  if (v1)
  {
    if (v1 >= v1 + 64) {
      __break(0x5519u);
    }
  }
  uint64_t v4 = (void *)(*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_data_from_context", "Attempting to select a data value from a non-data DER object");
  return sub_10004F3CC(v4, v5, v6, v7);
}

void *sub_10004F3CC(void *result, void *a2, unint64_t a3, unint64_t a4)
{
  char v4 = 0;
  if (a3 <= a4) {
    return sub_10004F40C(result, &v4, a2, a3, a4);
  }
  __break(0x5519u);
  return result;
}

void *sub_10004F40C(void *result, unsigned char *a2, void *a3, unint64_t a4, unint64_t a5)
{
  long long v5 = result;
  if (!a3) {
    goto LABEL_16;
  }
  *a3 = 0;
  if (a4 > a5)
  {
    __break(0x5519u);
    return result;
  }
  a3[1] = a4;
  a3[2] = a5;
  if (a4 && a4 < a5)
  {
    if (a5 - a4 >= 5 && (*(_DWORD *)a4 == 1836597052 ? (BOOL v10 = *(unsigned char *)(a4 + 4) == 108) : (BOOL v10 = 0), v10))
    {
      long long v16 = (void (*)(void *, const char *, ...))result[3];
      if (v16) {
        v16(result, "[%s]: %s\n", "CEValidateWithOptions", "xml-looking blob was passed in");
      }
      return &unk_100071FE8;
    }
    else
    {
      v18[1] = a5;
      _OWORD v18[2] = 0;
      v18[0] = a4;
      if (ccder_blob_decode_tl())
      {
        long long v25 = 0uLL;
        if (ccder_blob_decode_range())
        {
          long long v19 = 0;
          uint64_t v20 = 0;
          if (ccder_blob_decode_range())
          {
            if ((unint64_t)(v20 - (void)v19) < 9)
            {
              uint64_t v17 = (void (*)(void *, const char *, ...))v5[3];
              if (v17) {
                v17(v5, "[%s]: entitlements blob has unexpected version %lld\n", "validate_VNext", 0);
              }
              return &unk_100072018;
            }
            long long v11 = (void (*)(void *, const char *, ...))v5[3];
            if (v11)
            {
              long long v12 = "number too large";
LABEL_31:
              uint64_t v15 = "der_decode_number";
              goto LABEL_32;
            }
          }
          else
          {
            long long v11 = (void (*)(void *, const char *, ...))v5[3];
            if (v11)
            {
              long long v12 = "unknown number encoding";
              goto LABEL_31;
            }
          }
          return &unk_100072018;
        }
        long long v11 = (void (*)(void *, const char *, ...))v5[3];
        if (!v11) {
          return &unk_100072018;
        }
        long long v12 = "entitlements blob does not have CCDER_ENTITLEMENTS coding";
        uint64_t v15 = "validate_VNext";
LABEL_32:
        v11(v5, "[%s]: %s\n", v15, v12);
        return &unk_100072018;
      }
      long long v25 = 0uLL;
      unint64_t v23 = a4;
      unint64_t v24 = a5;
      if ((ccder_blob_decode_range() & 1) == 0)
      {
        long long v11 = (void (*)(void *, const char *, ...))v5[3];
        if (!v11) {
          return &unk_100072018;
        }
        long long v12 = "entitlements blob does not have CCDER_CONSTRUCTED_SET coding";
        uint64_t v15 = "validate_V0";
        goto LABEL_32;
      }
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      long long v19 = v5;
      uint64_t v20 = 0x2000000000000011;
      LOBYTE(v22) = *a2;
      if (sub_10004FF1C((uint64_t)&v19, v18))
      {
        *a3 = 1;
        uint64_t v14 = &off_100072070;
      }
      else
      {
        uint64_t v14 = &off_100072078;
      }
      return *v14;
    }
  }
  else
  {
LABEL_16:
    long long v13 = (void (*)(void *, const char *, ...))result[3];
    if (v13) {
      v13(result, "[%s]: %s\n", "CEValidateWithOptions", "invalid arguments passed in");
    }
    return &unk_100071FF8;
  }
}

uint64_t sub_10004F754(uint64_t result, void *a2, uint64_t a3)
{
  if (!a3 || !*a2 || !a2[1] || !a2[2])
  {
    uint64_t v8 = &off_100072068;
    return (uint64_t)*v8;
  }
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  unint64_t v5 = a2[1];
  unint64_t v4 = a2[2];
  if (*a2 == 2)
  {
    if (v5 <= v4)
    {
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)a3 = result;
      *(_OWORD *)(a3 + 24) = xmmword_100053E40;
      *(void *)(a3 + 40) = v5;
      *(void *)(a3 + 48) = v4;
      long long v6 = *(_OWORD *)(a3 + 16);
      v9[0] = *(_OWORD *)a3;
      v9[1] = v6;
      v9[2] = *(_OWORD *)(a3 + 32);
      unint64_t v10 = v4;
      sub_10004D9AC((uint64_t)v11, (unint64_t)v9, (uint64_t)&unk_100053E50);
      long long v7 = v11[1];
      *(_OWORD *)a3 = v11[0];
      *(_OWORD *)(a3 + 16) = v7;
      *(_OWORD *)(a3 + 32) = v11[2];
      unint64_t v4 = v12;
LABEL_12:
      *(void *)(a3 + 48) = v4;
      uint64_t v8 = &off_100072070;
      return (uint64_t)*v8;
    }
  }
  else if (v5 <= v4)
  {
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *(void *)a3 = result;
    *(_OWORD *)(a3 + 24) = xmmword_100053E30;
    *(void *)(a3 + 40) = v5;
    goto LABEL_12;
  }
  __break(0x5519u);
  return result;
}

uint64_t sub_10004F858(uint64_t a1, long long *a2, uint64_t a3)
{
  unint64_t v4 = *(void *)a2;
  long long v5 = a2[2];
  long long v6 = *a2;
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v6;
  *(void *)(a1 + 48) = *((void *)a2 + 6);
  *(unsigned char *)(a1 + 33) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if ((*(unsigned char *)(a3 + 7) & 0x40) != 0)
  {
    uint64_t v7 = *(void *)(a3 + 8);
    uint64_t v8 = (uint64_t *)(a3 + 16);
  }
  else
  {
    uint64_t v7 = a3 + 8;
    uint64_t v8 = (uint64_t *)(a3 + 248);
  }
  uint64_t v9 = *v8;
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    char v11 = 0;
    if (v7 && v9) {
      char v11 = 0;
    }
    if (!v9) {
      char v11 = 1;
    }
    *(unsigned char *)(a1 + 33) = v11;
  }
  else
  {
    unint64_t v12 = *(uint64_t (**)(unint64_t, const char *, ...))(v4 + 24);
    if (v12)
    {
      uint64_t result = v12(v4, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      long long v13 = *(uint64_t (**)(unint64_t, const char *, ...))(v4 + 24);
      if (v13)
      {
        if (v4 && v4 >= v4 + 64) {
          __break(0x5519u);
        }
        else {
          return v13(v4, "[%s]: %s\n", "der_vm_execute_match_string", "string decode failure");
        }
      }
    }
  }
  return result;
}

uint64_t sub_10004F9B8(uint64_t *a1)
{
  int v2 = (void *)a1[15];
  uint64_t v3 = v2[1];
  if ((*(unsigned char *)(v3 + 7) & 0x40) != 0)
  {
    unint64_t v4 = *(const void **)(v3 + 8);
    long long v5 = (size_t *)(v3 + 16);
  }
  else
  {
    unint64_t v4 = (const void *)(v3 + 8);
    long long v5 = (size_t *)(v3 + 248);
  }
  if (*((_DWORD *)a1 + 29) != 4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = *(void (**)(uint64_t, const char *, ...))(*a1 + 24);
    if (v9) {
      v9(v8, "[%s]: %s\n", "string_value_allowed_iterate", "Unexpected type to match against during iteration");
    }
    return 1;
  }
  size_t v6 = *v5;
  sub_10004F858((uint64_t)v17, (long long *)(a1 + 7), v3);
  if (v17[33])
  {
    uint64_t result = 0;
    *(unsigned char *)(*v2 + 33) = 1;
    return result;
  }
  unint64_t v10 = a1[7];
  long long v18 = *((_OWORD *)a1 + 6);
  long long v19 = 0;
  unint64_t v20 = 0;
  if ((ccder_blob_decode_range() & 1) == 0)
  {
    uint64_t v15 = *(void (**)(unint64_t, const char *, ...))(v10 + 24);
    if (v15) {
      v15(v10, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
    }
    if (!v10 || v10 < v10 + 64) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (v20 - (unint64_t)v19 < 2) {
    return 1;
  }
  size_t v11 = v20 - (void)v19 - 1;
  unint64_t v12 = (unsigned char *)(v20 - 1);
  if (v20 - 1 >= v20 || v12 < v19)
  {
LABEL_26:
    __break(0x5519u);
LABEL_27:
    uint64_t v16 = (*(uint64_t (**)(unint64_t, const char *, ...))(v10 + 32))(v10, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
    return sub_10004FB6C(v16);
  }
  if (*v12 != 42 || v11 > v6) {
    return 1;
  }
  int v14 = memcmp(v19, v4, v11);
  uint64_t result = 1;
  if (!v14)
  {
    *(unsigned char *)(*v2 + 33) = 1;
    return 0;
  }
  return result;
}

uint64_t sub_10004FB6C(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = (void *)a1[15];
  uint64_t v4 = v3[1];
  int v5 = *((_DWORD *)a1 + 29);
  if ((*(unsigned char *)(v4 + 7) & 0x40) == 0)
  {
    if (v5 == 4)
    {
      uint64_t v6 = *(void *)(v4 + 248);
      goto LABEL_6;
    }
LABEL_9:
    uint64_t v8 = *(void (**)(uint64_t, const char *, ...))(v2 + 24);
    if (v8) {
      v8(v2, "[%s]: %s\n", "string_prefix_allowed_iterate", "Unexpected type to match against during iteration");
    }
    return 1;
  }
  if (v5 != 4) {
    goto LABEL_9;
  }
  uint64_t v6 = *(void *)(v4 + 16);
LABEL_6:
  unint64_t v7 = a1[7];
  if (ccder_blob_decode_range())
  {
    if (!v6)
    {
LABEL_19:
      uint64_t result = 0;
      *(unsigned char *)(*v3 + 33) = 1;
      return result;
    }
  }
  else
  {
    uint64_t v9 = *(void (**)(unint64_t, const char *, ...))(v7 + 24);
    if (v9)
    {
      v9(v7, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      unint64_t v10 = *(void (**)(unint64_t, const char *, ...))(v7 + 24);
      if (v10)
      {
        if (v7 && v7 >= v7 + 64)
        {
LABEL_24:
          __break(0x5519u);
          goto LABEL_25;
        }
        v10(v7, "[%s]: %s\n", "der_vm_execute_match_string_prefix", "string decode failure");
      }
    }
  }
  unint64_t v7 = a1[7];
  if (ccder_blob_decode_range())
  {
    if (v6) {
      return 1;
    }
    goto LABEL_19;
  }
  unint64_t v12 = *(void (**)(unint64_t, const char *, ...))(v7 + 24);
  if (v12) {
    v12(v7, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
  }
  if (v7 && v7 >= v7 + 64) {
    goto LABEL_24;
  }
LABEL_25:
  uint64_t v13 = (*(uint64_t (**)(unint64_t, const char *, ...))(v7 + 32))(v7, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
  return sub_10004FD84(v13);
}

uint64_t sub_10004FD84(uint64_t *a1)
{
  if (*((_DWORD *)a1 + 29) != 3)
  {
    uint64_t v5 = *a1;
    uint64_t v6 = *(void (**)(uint64_t, const char *, ...))(v5 + 24);
    if (v6) {
      v6(v5, "[%s]: %s\n", "integer_allowed_iterate", "Unexpected type to match against during iteration");
    }
    return 0;
  }
  unint64_t v1 = (void *)a1[15];
  uint64_t v2 = v1[1];
  unint64_t v3 = a1[7];
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    uint64_t result = 1;
    if (!*(void *)(v2 + 8))
    {
      *(unsigned char *)(*v1 + 33) = 1;
      return 0;
    }
  }
  else
  {
    unint64_t v7 = *(uint64_t (**)(unint64_t, const char *, ...))(v3 + 24);
    if (v7) {
      uint64_t result = v7(v3, "[%s]: %s\n", "der_decode_number", "unknown number encoding");
    }
    uint64_t v8 = *(void (**)(unint64_t, const char *, ...))(v3 + 24);
    if (v8)
    {
      if (v3 && v3 >= v3 + 64)
      {
        __break(0x5519u);
        return result;
      }
      v8(v3, "[%s]: %s\n", "der_vm_execute_match_integer", "BOOL decode failure");
    }
    return 1;
  }
  return result;
}

uint64_t sub_10004FF1C(uint64_t a1, uint64_t *a2)
{
  unint64_t v2 = *(void *)a1;
  unint64_t v3 = *(void *)a1 + 64;
  if (*(int *)(a1 + 20) > 12)
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (!v4) {
      return 0;
    }
    if (v2 < v3) {
      goto LABEL_33;
    }
LABEL_95:
    __break(0x5519u);
    JUMPOUT(0x1000503FCLL);
  }
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v24 = 0;
  if (v2) {
    BOOL v5 = v2 >= v3;
  }
  else {
    BOOL v5 = 0;
  }
  if (v5) {
    goto LABEL_95;
  }
  if ((sub_10005042C(v2, &v26, &v24, 0, a2) & 1) == 0)
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (!v4) {
      return 0;
    }
    goto LABEL_33;
  }
  if (v26 != *(void *)(a1 + 8))
  {
    switch(v26)
    {
      case 1:
        unint64_t v30 = 0;
        unint64_t v31 = 0;
        if (ccder_blob_decode_range())
        {
          if (v31 - (void)v30 == 1) {
            break;
          }
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0;
          }
        }
        else
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0;
          }
        }
        goto LABEL_33;
      case 2:
        unint64_t v30 = 0;
        unint64_t v31 = 0;
        if ((ccder_blob_decode_range() & 1) == 0)
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0;
          }
          goto LABEL_33;
        }
        unint64_t v22 = v31 - (void)v30;
        if (v31 - (unint64_t)v30 >= 9)
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0;
          }
          goto LABEL_33;
        }
        if ((unint64_t)v30 < v31)
        {
          unint64_t v23 = v30;
          while ((unint64_t)v23 < v31 && v23 >= v30)
          {
            ++v23;
            if (!--v22) {
              goto LABEL_89;
            }
          }
          goto LABEL_95;
        }
        break;
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_51;
      case 4:
        if (*(unsigned char *)(a1 + 24))
        {
          unint64_t v30 = 0;
          unint64_t v31 = 0;
          if ((sub_10005053C(v2, &v30) & 1) == 0) {
            return 0;
          }
          break;
        }
        uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
        if (!v4) {
          return 0;
        }
        goto LABEL_33;
      case 12:
        unint64_t v30 = 0;
        unint64_t v31 = 0;
        if (ccder_blob_decode_range())
        {
          if (!memchr(v30, 0, v31 - (void)v30)) {
            break;
          }
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0;
          }
        }
        else
        {
          uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4) {
            return 0;
          }
        }
        goto LABEL_33;
      default:
        if (v26 == 0x2000000000000010)
        {
          unint64_t v7 = *(void *)a1;
          unint64_t v20 = *(void *)a1 + 64;
          unint64_t v30 = 0;
          unint64_t v31 = 0;
          if (ccder_blob_decode_sequence_tl())
          {
            do
            {
              if ((unint64_t)v30 >= v31) {
                goto LABEL_89;
              }
              ++*(_DWORD *)(a1 + 20);
              char v21 = sub_10004FF1C(a1, &v30);
              --*(_DWORD *)(a1 + 20);
            }
            while ((v21 & 1) != 0);
            uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
            if (!v4) {
              return 0;
            }
            if (v7 < v20) {
              goto LABEL_43;
            }
          }
          else
          {
            uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
            if (!v4) {
              return 0;
            }
            if (v7 < v20) {
              goto LABEL_43;
            }
          }
          goto LABEL_95;
        }
LABEL_51:
        uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
        if (!v4) {
          return 0;
        }
        goto LABEL_33;
    }
LABEL_89:
    if (v24 == v25) {
      return 1;
    }
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (!v4) {
      return 0;
    }
LABEL_33:
    unint64_t v18 = v2;
    goto LABEL_34;
  }
  unint64_t v7 = *(void *)a1;
  unint64_t v8 = *(void *)a1 + 64;
  unint64_t v30 = 0;
  unint64_t v31 = 0;
  if (!ccder_blob_decode_range())
  {
    uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
    if (!v4) {
      return 0;
    }
    if (v7 < v8) {
      goto LABEL_43;
    }
    goto LABEL_95;
  }
  if ((unint64_t)v30 >= v31) {
    goto LABEL_89;
  }
  uint64_t v9 = 0;
  size_t v10 = 0;
  while (1)
  {
    long long v28 = 0;
    size_t v29 = 0;
    long long v27 = 0uLL;
    if ((sub_1000505D4(v7, &v28, &v27, &v30) & 1) == 0)
    {
      uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
      if (!v4) {
        return 0;
      }
      if (v7 < v8) {
        goto LABEL_43;
      }
      goto LABEL_95;
    }
    unint64_t v12 = v28;
    size_t v11 = v29;
    if (memchr(v28, 0, v29))
    {
      uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
      if (!v4) {
        return 0;
      }
      if (v7 < v8) {
        goto LABEL_43;
      }
      goto LABEL_95;
    }
    if (*(unsigned char *)(a1 + 16) && v9 && v10)
    {
      if (!v12) {
        break;
      }
      size_t v13 = v10 >= v11 ? v11 : v10;
      int v14 = memcmp(v9, v12, v13);
      BOOL v15 = v10 != v11 && v14 == 0;
      int v16 = (v10 < v11) << 31;
      if (!v15) {
        int v16 = v14;
      }
      if ((v16 & 0x80000000) == 0) {
        break;
      }
    }
    ++*(_DWORD *)(a1 + 20);
    char v17 = sub_10004FF1C(a1, &v27);
    --*(_DWORD *)(a1 + 20);
    if ((v17 & 1) == 0)
    {
      uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
      if (!v4) {
        return 0;
      }
      if (v7 < v8) {
        goto LABEL_43;
      }
      goto LABEL_95;
    }
    uint64_t v9 = v28;
    size_t v10 = v29;
    if ((unint64_t)v30 >= v31) {
      goto LABEL_89;
    }
  }
  uint64_t v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
  if (v4)
  {
    if (v7 >= v8) {
      goto LABEL_95;
    }
LABEL_43:
    unint64_t v18 = v7;
LABEL_34:
    v4(v18, "[%s]: %s\n");
  }
  return 0;
}

uint64_t sub_10005042C(uint64_t a1, void *a2, void *a3, void *a4, uint64_t *a5)
{
  uint64_t v11 = *a5;
  uint64_t v10 = a5[1];
  if ((ccder_blob_decode_tag() & 1) == 0)
  {
    size_t v13 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v13)
    {
      int v14 = "could not decode tag for next DER sub-sequence";
LABEL_8:
      v13(a1, "[%s]: %s\n", "der_decode_next", v14);
    }
    return 0;
  }
  if ((ccder_blob_decode_len() & 1) == 0)
  {
    size_t v13 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v13)
    {
      int v14 = "could not decode size for next DER sub-sequence";
      goto LABEL_8;
    }
    return 0;
  }
  uint64_t v12 = *a5;
  if (a2) {
    *a2 = 0;
  }
  if (a3)
  {
    *a3 = v11;
    a3[1] = v12;
  }
  if (a4)
  {
    *a4 = v12;
    a4[1] = v12;
  }
  *a5 = v12;
  a5[1] = v10;
  return 1;
}

uint64_t sub_10005053C(uint64_t a1, void *a2)
{
  uint64_t v4 = ccder_blob_decode_range();
  if (v4)
  {
    if (a2)
    {
      *a2 = 0;
      a2[1] = 0;
    }
  }
  else
  {
    BOOL v5 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v5) {
      v5(a1, "[%s]: %s\n", "der_decode_data", "Unknown data encoding");
    }
  }
  return v4;
}

uint64_t sub_1000505D4(uint64_t a1, void *a2, _OWORD *a3, void *a4)
{
  if (ccder_blob_decode_sequence_tl())
  {
    if (ccder_blob_decode_range())
    {
      if (a2)
      {
        *a2 = 0;
        a2[1] = 0;
      }
      else if (MEMORY[8])
      {
        if ((ccder_blob_decode_tag() & 1) == 0)
        {
          unint64_t v8 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
          if (!v8) {
            return 0;
          }
          uint64_t v9 = "unable to decode value tag for key-value pair";
          goto LABEL_12;
        }
        if ((ccder_blob_decode_len() & 1) == 0)
        {
          unint64_t v8 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
          if (!v8) {
            return 0;
          }
          uint64_t v9 = "unable to decode value size for key-value pair";
          goto LABEL_12;
        }
        if (!*a4)
        {
          *a3 = 0uLL;
          return 1;
        }
        unint64_t v8 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
        if (v8)
        {
          uint64_t v9 = "key-value pair contains extra elements";
          goto LABEL_12;
        }
        return 0;
      }
    }
    else
    {
      uint64_t v10 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
      if (v10) {
        v10(a1, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      }
    }
    unint64_t v8 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v8)
    {
      uint64_t v9 = "dictionary key is not a valid string";
      goto LABEL_12;
    }
  }
  else
  {
    unint64_t v8 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v8)
    {
      uint64_t v9 = "key / value decoding failure";
LABEL_12:
      v8(a1, "[%s]: %s\n", "der_decode_key_value", v9);
    }
  }
  return 0;
}

void *sub_100050760(void *a1, uint64_t a2, uint64_t *a3)
{
  if (!a1) {
    return &unk_100071FF8;
  }
  switch(*a1)
  {
    case 1:
      a1[2] = 1;
      goto LABEL_30;
    case 2:
    case 9:
LABEL_30:
      *a3 = ccder_sizeof();
      return &unk_100071FD8;
    case 4:
      unint64_t v7 = a1[1];
      unint64_t v8 = HIBYTE(v7);
      if ((HIBYTE(v7) + 1) > 1u)
      {
        uint64_t v15 = 8;
      }
      else
      {
        if (v8 == BYTE6(v7))
        {
          if (v8 == BYTE5(v7))
          {
            if (v8 == BYTE4(v7))
            {
              if (v8 == BYTE3(v7))
              {
                if (v8 == BYTE2(v7))
                {
                  if (BYTE1(v7) == v8) {
                    uint64_t v9 = 2;
                  }
                  else {
                    uint64_t v9 = 3;
                  }
                  uint64_t v10 = 1;
                  if (BYTE1(v7) != v8) {
                    uint64_t v10 = 2;
                  }
                }
                else
                {
                  uint64_t v10 = 3;
                  uint64_t v9 = 4;
                }
              }
              else
              {
                uint64_t v10 = 4;
                uint64_t v9 = 5;
              }
            }
            else
            {
              uint64_t v10 = 5;
              uint64_t v9 = 6;
            }
          }
          else
          {
            uint64_t v10 = 6;
            uint64_t v9 = 7;
          }
        }
        else
        {
          uint64_t v10 = 7;
          uint64_t v9 = 8;
        }
        if ((((v7 >> (8 * v10 - 8)) ^ v8) & 0x80) != 0) {
          uint64_t v15 = v9;
        }
        else {
          uint64_t v15 = v10;
        }
      }
      *a3 = ccder_sizeof();
      a1[2] = v15;
      return &unk_100071FD8;
    case 5:
      goto LABEL_17;
    case 7:
      return (void *)sub_1000509E4();
    default:
      return &unk_100071FF8;
  }
  while (1)
  {
LABEL_17:
    uint64_t v11 = *(void **)a2;
    unint64_t v12 = *(void *)(a2 + 8);
    if (*(void *)a2 >= v12) {
      return &unk_100072018;
    }
    size_t v13 = v11 + 4;
    if ((unint64_t)(v11 + 4) > v12 || v11 >= v13)
    {
LABEL_45:
      __break(0x5519u);
      JUMPOUT(0x1000509C0);
    }
    *(void *)a2 = v13;
    if (!v11) {
      return &unk_100072018;
    }
    if (*v11 == 6) {
      break;
    }
    if (v11 >= v13) {
      goto LABEL_45;
    }
    uint64_t result = (void *)sub_100050760();
    if (result != &unk_100071FD8) {
      return result;
    }
  }
  *a3 = ccder_sizeof();
  a1[2] = 0;
  return &unk_100071FD8;
}

uint64_t sub_1000509E4(uint64_t result, unint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  uint64_t v6 = 0;
  unint64_t v7 = *a2;
  unint64_t v8 = a2[1];
  if (*a2 >= v8) {
    return (uint64_t)&unk_100072018;
  }
  while (1)
  {
    uint64_t v9 = (void *)(v7 + 32);
    if (v7 + 32 > v8 || v7 > (unint64_t)v9)
    {
LABEL_28:
      __break(0x5519u);
      return result;
    }
    *a2 = (unint64_t)v9;
    if (!v7) {
      return (uint64_t)&unk_100072018;
    }
    if (*(void *)v7 != 5) {
      break;
    }
    *(unsigned char *)(v7 + 24) = 1;
    if ((unint64_t)v9 >= v8) {
      return (uint64_t)&unk_100072018;
    }
    unint64_t v10 = v7 + 64;
    if (v7 + 64 > v8 || (unint64_t)v9 > v10) {
      goto LABEL_28;
    }
    *a2 = v10;
    if (v7 == -32 || *v9 != 3 || !*(void *)(v7 + 48)) {
      return (uint64_t)&unk_100072018;
    }
    uint64_t v11 = ccder_sizeof();
    uint64_t result = 0;
    uint64_t v15 = 0;
    if (v10 < v8)
    {
      unint64_t v12 = v7 + 96;
      if (v7 + 96 > v8 || v10 > v12) {
        goto LABEL_28;
      }
      *a2 = v12;
      uint64_t result = v7 + 64;
    }
    uint64_t result = (uint64_t)sub_100050760((void *)result, (uint64_t)a2, &v15);
    if ((_UNKNOWN *)result != &unk_100071FD8) {
      return result;
    }
    unint64_t v13 = *a2;
    unint64_t v8 = a2[1];
    if (*a2 >= v8) {
      return (uint64_t)&unk_100072018;
    }
    unint64_t v14 = v13 + 32;
    if (v13 + 32 > v8 || v13 > v14) {
      goto LABEL_28;
    }
    *a2 = v14;
    if (v13)
    {
      if (*(void *)v13 == 6)
      {
        *(unsigned char *)(v13 + 24) = 1;
        *(void *)(v7 + 16) = v15 + v11;
        uint64_t result = ccder_sizeof();
        v6 += result;
        unint64_t v7 = v14;
        if (v14 < v8) {
          continue;
        }
      }
    }
    return (uint64_t)&unk_100072018;
  }
  if (*(void *)v7 != 8) {
    return (uint64_t)&unk_100072018;
  }
  *a3 = ccder_sizeof();
  *(void *)(v5 + 16) = v6;
  return (uint64_t)&unk_100071FD8;
}

uint64_t sub_100050B98()
{
  return ccder_blob_reserve_tl();
}

void sub_100050CD4()
{
}

void sub_100050CF0()
{
}

void sub_100050D0C()
{
}

void sub_100050D28()
{
}

uint64_t sub_100050D44(uint64_t a1)
{
  uint64_t result = _os_assumes_log_ctx();
  *(void *)(a1 + 1376) |= 1uLL;
  return result;
}

void sub_100050D8C(int a1)
{
  qword_100075AF8 = (uint64_t)"Bug in libxpc: mach_port_construct() failed";
  qword_100075B28 = a1;
  __break(1u);
}

void sub_100050DB4(int a1)
{
  qword_100075AF8 = (uint64_t)"Bug in libxpc: mach_port_assert_attributes() failed";
  qword_100075B28 = a1;
  __break(1u);
}

void sub_100050DDC()
{
  qword_100075AF8 = (uint64_t)"Configuration error: failed to fetch our own audit token";
  __break(1u);
}

void sub_100050DFC()
{
}

void sub_100050E1C()
{
}

uint64_t sub_100050E38()
{
  return _os_assumes_log();
}

void sub_100050E58(const char *a1)
{
  _os_assumes_log();
  int v2 = *__error();
  __error();
  unint64_t v3 = (const char *)xpc_strerror();
  sub_100043D78(4, "Failed to set %s: %d - %s", a1, v2, v3);
}

void sub_100050EB4()
{
}

void sub_100050ED0()
{
}

void sub_100050EEC()
{
}

void sub_100050F08()
{
}

void sub_100050F24()
{
}

uint64_t sub_1000515CC()
{
  return _os_assumes_log_ctx();
}

uint64_t sub_10005160C()
{
  return _os_assumes_log_ctx();
}

void sub_10005164C()
{
}

void sub_10005166C()
{
}

uint64_t sub_100051690(int a1, uint64_t a2, char a3)
{
  strerror(a1);
  sub_10001E4BC(a2, 5, "could not signal service for %s: %d: %s", v5, v6, v7, v8, v9, a3);
  return _os_assumes_log_ctx();
}

uint64_t sub_100051704(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_assumes_log_ctx();
}

uint64_t sub_100051760()
{
  return _os_assumes_log_ctx();
}

void sub_100051794()
{
}

uint64_t sub_1000517B0()
{
  return _os_assumes_log_ctx();
}

void sub_1000517F0(uint64_t a1, uint64_t a2)
{
  sub_10003B38C(a1, a2);
  uint64_t v4 = sub_10003B370();
  sub_100015BE4("overflow of service activation count during deactivation. Managed:%d. Domain: %s. Service:%s", v3, v2, v4);
  _os_crash();
  __break(1u);
}

void sub_10005182C(uint64_t a1, uint64_t a2)
{
  sub_10003B38C(a1, a2);
  uint64_t v4 = sub_10003B370();
  sub_100015BE4("underflow of service activation count during deactivate. Managed:%d. Domain: %s. Service:%s", v3, v2, v4);
  _os_crash();
  __break(1u);
}

void sub_100051868(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1000203FC(a1, 1);
  uint64_t v5 = sub_10002A624(a2, 1);
  sub_100015BE4("%s is being deactivated by a mismatched domain %s. Managed:%d.", v4, v5, *(_DWORD *)(a1 + 296) != 0);
  _os_crash();
  __break(1u);
}

void sub_1000518C8(uint64_t a1)
{
  sub_10003B3B0(a1);
  int v3 = sub_10003B370();
  sub_100015BE4("overflow of service activation count during activate. Managed:%d. Domain:'%s'. Service:'%s'", v2, v1, v3);
  _os_crash();
  __break(1u);
}

void sub_100051904(uint64_t a1)
{
  sub_10003B3B0(a1);
  int v3 = sub_10003B370();
  sub_100015BE4("underflow of service activation count during activate. Managed:%d. Domain:'%s'. Service:'%s'", v2, v1, v3);
  _os_crash();
  __break(1u);
}

void sub_100051940(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_1000203FC(a1, 1);
  uint64_t v5 = sub_10002A624(a2, 1);
  sub_100015BE4("%s is being activated by a mismatched domain %s. Managed:%d.", v4, v5, *(_DWORD *)(a1 + 296) != 0);
  _os_crash();
  __break(1u);
}

int *sub_1000519A0(int *a1)
{
  return sub_10003E54C(a1);
}

void sub_1000519D4(unsigned int a1)
{
  qword_100075AF8 = (uint64_t)"libdispatch bug: Unknown send-right";
  qword_100075B28 = a1;
  __break(1u);
}

void sub_1000519FC(const void *aBlock)
{
  qword_100075AF8 = (uint64_t)"libdispatch bug: Unknown receive-right";
  qword_100075B28 = aBlock;
  __break(1u);
  _Block_copy(aBlock);
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

char ***_NSGetArgv(void)
{
  return __NSGetArgv();
}

char ***_NSGetEnviron(void)
{
  return __NSGetEnviron();
}

int _NSGetExecutablePath(char *buf, uint32_t *bufsize)
{
  return __NSGetExecutablePath(buf, bufsize);
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return __NSGetMachExecuteHeader();
}

int *__error(void)
{
  return ___error();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return ___tolower(a1);
}

uint64_t __udivti3()
{
  return ___udivti3();
}

uint64_t _dyld_get_image_uuid()
{
  return __dyld_get_image_uuid();
}

uint64_t _dyld_get_shared_cache_range()
{
  return __dyld_get_shared_cache_range();
}

uint64_t _dyld_get_shared_cache_uuid()
{
  return __dyld_get_shared_cache_uuid();
}

uint64_t _os_alloc_once()
{
  return __os_alloc_once();
}

uint64_t _os_assert_log()
{
  return __os_assert_log();
}

uint64_t _os_assumes_log()
{
  return __os_assumes_log();
}

uint64_t _os_assumes_log_ctx()
{
  return __os_assumes_log_ctx();
}

uint64_t _os_avoid_tail_call()
{
  return __os_avoid_tail_call();
}

uint64_t _os_crash()
{
  return __os_crash();
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

uint64_t _os_log_simple()
{
  return __os_log_simple();
}

uint64_t _os_log_simple_reinit_4launchd()
{
  return __os_log_simple_reinit_4launchd();
}

uint64_t _os_log_simple_send()
{
  return __os_log_simple_send();
}

uint64_t _os_trace_update_with_datavolume_4launchd()
{
  return __os_trace_update_with_datavolume_4launchd();
}

uint64_t _xpc_dictionary_create_reply_with_port()
{
  return __xpc_dictionary_create_reply_with_port();
}

uint64_t _xpc_dictionary_extract_mach_send()
{
  return __xpc_dictionary_extract_mach_send();
}

uint64_t _xpc_fd_get_port()
{
  return __xpc_fd_get_port();
}

uint64_t _xpc_pipe_handle_mig()
{
  return __xpc_pipe_handle_mig();
}

uint64_t _xpc_shmem_get_mach_port()
{
  return __xpc_shmem_get_mach_port();
}

uint64_t abort_with_reason()
{
  return _abort_with_reason();
}

int accept(int a1, sockaddr *a2, socklen_t *a3)
{
  return _accept(a1, a2, a3);
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

uint64_t amfi_launch_constraint_set_spawnattr()
{
  return _amfi_launch_constraint_set_spawnattr();
}

uint64_t amfi_restricted_execution_mode_enable()
{
  return _amfi_restricted_execution_mode_enable();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return _arc4random_uniform(__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  return _basename_r(a1, a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return _bind(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

uint64_t cc_clear()
{
  return _cc_clear();
}

uint64_t ccder_blob_decode_len()
{
  return _ccder_blob_decode_len();
}

uint64_t ccder_blob_decode_range()
{
  return _ccder_blob_decode_range();
}

uint64_t ccder_blob_decode_sequence_tl()
{
  return _ccder_blob_decode_sequence_tl();
}

uint64_t ccder_blob_decode_tag()
{
  return _ccder_blob_decode_tag();
}

uint64_t ccder_blob_decode_tl()
{
  return _ccder_blob_decode_tl();
}

uint64_t ccder_blob_encode_body_tl()
{
  return _ccder_blob_encode_body_tl();
}

uint64_t ccder_blob_encode_tl()
{
  return _ccder_blob_encode_tl();
}

uint64_t ccder_blob_reserve_tl()
{
  return _ccder_blob_reserve_tl();
}

uint64_t ccder_sizeof()
{
  return _ccder_sizeof();
}

int chdir(const char *a1)
{
  return _chdir(a1);
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

int chown(const char *a1, uid_t a2, gid_t a3)
{
  return _chown(a1, a2, a3);
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return _class_createInstance(cls, extraBytes);
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return _clock_gettime_nsec_np(__clock_id);
}

int close(int a1)
{
  return _close(a1);
}

uint64_t coalition_create()
{
  return _coalition_create();
}

uint64_t coalition_info_resource_usage()
{
  return _coalition_info_resource_usage();
}

uint64_t coalition_info_set_name()
{
  return _coalition_info_set_name();
}

uint64_t coalition_ledger_set_logical_writes_limit()
{
  return _coalition_ledger_set_logical_writes_limit();
}

uint64_t coalition_reap()
{
  return _coalition_reap();
}

uint64_t coalition_terminate()
{
  return _coalition_terminate();
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return _connect(a1, a2, a3);
}

int copyfile(const char *from, const char *to, copyfile_state_t state, copyfile_flags_t flags)
{
  return _copyfile(from, to, state, flags);
}

copyfile_state_t copyfile_state_alloc(void)
{
  return _copyfile_state_alloc();
}

int copyfile_state_free(copyfile_state_t a1)
{
  return _copyfile_state_free(a1);
}

uint64_t csops()
{
  return _csops();
}

uint64_t csops_audittoken()
{
  return _csops_audittoken();
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  return _dirname_r(a1, a2);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return _dispatch_data_create(buffer, size, queue, destructor);
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  return _dispatch_data_create_map(data, buffer_ptr, size_ptr);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return _dispatch_get_context(object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

uint64_t dispatch_mach_cancel()
{
  return _dispatch_mach_cancel();
}

uint64_t dispatch_mach_create_f()
{
  return _dispatch_mach_create_f();
}

uint64_t dispatch_mach_msg_get_msg()
{
  return _dispatch_mach_msg_get_msg();
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return _dispatch_queue_attr_make_initially_inactive(attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return _dispatch_queue_create_with_target_V2(label, attr, target);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  return _dispatch_source_get_data(source);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  return _dispatch_source_get_handle(source);
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

uint64_t dispatch_source_set_mandatory_cancel_handler()
{
  return _dispatch_source_set_mandatory_cancel_handler();
}

uint64_t dispatch_source_set_mandatory_cancel_handler_f()
{
  return _dispatch_source_set_mandatory_cancel_handler_f();
}

void dispatch_source_set_registration_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

int dladdr(const void *a1, Dl_info *a2)
{
  return _dladdr(a1, a2);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return _dlopen(__path, __mode);
}

int dup(int a1)
{
  return _dup(a1);
}

int dup2(int a1, int a2)
{
  return _dup2(a1, a2);
}

uint64_t dyld_image_header_containing_address()
{
  return _dyld_image_header_containing_address();
}

uint64_t exclaves_boot()
{
  return _exclaves_boot();
}

void exit(int a1)
{
}

int fchmodat(int a1, const char *a2, mode_t a3, int a4)
{
  return _fchmodat(a1, a2, a3, a4);
}

int fchownat(int a1, const char *a2, uid_t a3, gid_t a4, int a5)
{
  return _fchownat(a1, a2, a3, a4, a5);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return _fdopen(a1, a2);
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

int fileno(FILE *a1)
{
  return _fileno(a1);
}

FILE *__cdecl fmemopen(void *__buf, size_t __size, const char *__mode)
{
  return _fmemopen(__buf, __size, __mode);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

void free(void *a1)
{
}

void freeaddrinfo(addrinfo *a1)
{
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

off_t ftello(FILE *__stream)
{
  return _ftello(__stream);
}

int fts_close(FTS *a1)
{
  return _fts_close(a1);
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  return _fts_open(a1, a2, a3);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  return _fts_read(a1);
}

int fts_set(FTS *a1, FTSENT *a2, int a3)
{
  return _fts_set(a1, a2, a3);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

const char *__cdecl gai_strerror(int a1)
{
  return _gai_strerror(a1);
}

int getaddrinfo(const char *a1, const char *a2, const addrinfo *a3, addrinfo **a4)
{
  return _getaddrinfo(a1, a2, a3, a4);
}

int getdtablesize(void)
{
  return _getdtablesize();
}

gid_t getegid(void)
{
  return _getegid();
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

uid_t geteuid(void)
{
  return _geteuid();
}

int getgrnam_r(const char *a1, group *a2, char *a3, size_t a4, group **a5)
{
  return _getgrnam_r(a1, a2, a3, a4, a5);
}

int getgrouplist(const char *a1, int a2, int *a3, int *a4)
{
  return _getgrouplist(a1, a2, a3, a4);
}

pid_t getpid(void)
{
  return _getpid();
}

const char *getprogname(void)
{
  return _getprogname();
}

int getpwnam_r(const char *a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return _getpwnam_r(a1, a2, a3, a4, a5);
}

int getpwuid_r(uid_t a1, passwd *a2, char *a3, size_t a4, passwd **a5)
{
  return _getpwuid_r(a1, a2, a3, a4, a5);
}

int getrlimit(int a1, rlimit *a2)
{
  return _getrlimit(a1, a2);
}

int getrusage(int a1, rusage *a2)
{
  return _getrusage(a1, a2);
}

uint8_t *__cdecl getsectiondata(const mach_header_64 *mhp, const char *segname, const char *sectname, unint64_t *size)
{
  return _getsectiondata(mhp, segname, sectname, size);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return _getsockname(a1, a2, a3);
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

uid_t getuid(void)
{
  return _getuid();
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return _gmtime_r(a1, a2);
}

uint64_t guarded_close_np()
{
  return _guarded_close_np();
}

uint64_t guarded_open_np()
{
  return _guarded_open_np();
}

kern_return_t host_get_exception_ports(host_priv_t host_priv, exception_mask_t exception_mask, exception_mask_array_t masks, mach_msg_type_number_t *masksCnt, exception_handler_array_t old_handlers, exception_behavior_array_t old_behaviors, exception_flavor_array_t old_flavors)
{
  return _host_get_exception_ports(host_priv, exception_mask, masks, masksCnt, old_handlers, old_behaviors, old_flavors);
}

kern_return_t host_get_multiuser_config_flags(host_t host, uint32_t *multiuser_flags)
{
  return _host_get_multiuser_config_flags(host, multiuser_flags);
}

kern_return_t host_get_special_port(host_priv_t host_priv, int node, int which, mach_port_t *port)
{
  return _host_get_special_port(host_priv, node, which, port);
}

kern_return_t host_reboot(host_priv_t host_priv, int options)
{
  return _host_reboot(host_priv, options);
}

kern_return_t host_set_exception_ports(host_priv_t host_priv, exception_mask_t exception_mask, mach_port_t new_port, exception_behavior_t behavior, thread_state_flavor_t new_flavor)
{
  return _host_set_exception_ports(host_priv, exception_mask, new_port, behavior, new_flavor);
}

kern_return_t host_set_special_port(host_priv_t host_priv, int which, mach_port_t port)
{
  return _host_set_special_port(host_priv, which, port);
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

int isatty(int a1)
{
  return _isatty(a1);
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

int kill(pid_t a1, int a2)
{
  return _kill(a1, a2);
}

int killpg(pid_t a1, int a2)
{
  return _killpg(a1, a2);
}

uint64_t kpersona_alloc()
{
  return _kpersona_alloc();
}

uint64_t kpersona_dealloc()
{
  return _kpersona_dealloc();
}

uint64_t kpersona_find_by_type()
{
  return _kpersona_find_by_type();
}

uint64_t kpersona_info()
{
  return _kpersona_info();
}

uint64_t kpersona_pidinfo()
{
  return _kpersona_pidinfo();
}

uint64_t libSystem_init_after_boot_tasks_4launchd()
{
  return _libSystem_init_after_boot_tasks_4launchd();
}

int listen(int a1, int a2)
{
  return _listen(a1, a2);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return _localtime_r(a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return _mach_error_string(error_value);
}

mach_port_t mach_host_self(void)
{
  return _mach_host_self();
}

uint64_t mach_host_special_port_description()
{
  return _mach_host_special_port_description();
}

uint64_t mach_host_special_port_for_id()
{
  return _mach_host_special_port_for_id();
}

mach_msg_return_t mach_msg(mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify)
{
  return _mach_msg(msg, option, send_size, rcv_size, rcv_name, timeout, notify);
}

uint64_t mach_msg2_internal()
{
  return _mach_msg2_internal();
}

void mach_msg_destroy(mach_msg_header_t *a1)
{
}

kern_return_t mach_port_assert_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t info, mach_msg_type_number_t infoCnt)
{
  return _mach_port_assert_attributes(task, name, flavor, info, infoCnt);
}

kern_return_t mach_port_construct(ipc_space_t task, mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  return _mach_port_construct(task, options, context, name);
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

kern_return_t mach_port_destruct(ipc_space_t task, mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return _mach_port_destruct(task, name, srdelta, guard);
}

kern_return_t mach_port_extract_right(ipc_space_t task, mach_port_name_t name, mach_msg_type_name_t msgt_name, mach_port_t *poly, mach_msg_type_name_t *polyPoly)
{
  return _mach_port_extract_right(task, name, msgt_name, poly, polyPoly);
}

kern_return_t mach_port_insert_right(ipc_space_t task, mach_port_name_t name, mach_port_t poly, mach_msg_type_name_t polyPoly)
{
  return _mach_port_insert_right(task, name, poly, polyPoly);
}

kern_return_t mach_port_kernel_object(ipc_space_read_t task, mach_port_name_t name, unsigned int *object_type, unsigned int *object_addr)
{
  return _mach_port_kernel_object(task, name, object_type, object_addr);
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return _mach_port_mod_refs(task, name, right, delta);
}

kern_return_t mach_port_peek(ipc_space_t task, mach_port_name_t name, mach_msg_trailer_type_t trailer_type, mach_port_seqno_t *request_seqnop, mach_msg_size_t *msg_sizep, mach_msg_id_t *msg_idp, mach_msg_trailer_info_t trailer_infop, mach_msg_type_number_t *trailer_infopCnt)
{
  return _mach_port_peek(task, name, trailer_type, request_seqnop, msg_sizep, msg_idp, trailer_infop, trailer_infopCnt);
}

kern_return_t mach_port_request_notification(ipc_space_t task, mach_port_name_t name, mach_msg_id_t msgid, mach_port_mscount_t sync, mach_port_t notify, mach_msg_type_name_t notifyPoly, mach_port_t *previous)
{
  return _mach_port_request_notification(task, name, msgid, sync, notify, notifyPoly, previous);
}

kern_return_t mach_port_set_attributes(ipc_space_t task, mach_port_name_t name, mach_port_flavor_t flavor, mach_port_info_t port_info, mach_msg_type_number_t port_infoCnt)
{
  return _mach_port_set_attributes(task, name, flavor, port_info, port_infoCnt);
}

kern_return_t mach_port_type(ipc_space_t task, mach_port_name_t name, mach_port_type_t *ptype)
{
  return _mach_port_type(task, name, ptype);
}

kern_return_t mach_port_unguard(ipc_space_t task, mach_port_name_t name, mach_port_context_t guard)
{
  return _mach_port_unguard(task, name, guard);
}

kern_return_t mach_ports_lookup(task_t target_task, mach_port_array_t *init_port_set, mach_msg_type_number_t *init_port_setCnt)
{
  return _mach_ports_lookup(target_task, init_port_set, init_port_setCnt);
}

kern_return_t mach_ports_register(task_t target_task, mach_port_array_t init_port_set, mach_msg_type_number_t init_port_setCnt)
{
  return _mach_ports_register(target_task, init_port_set, init_port_setCnt);
}

uint64_t mach_task_special_port_description()
{
  return _mach_task_special_port_description();
}

uint64_t mach_task_special_port_for_id()
{
  return _mach_task_special_port_for_id();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

kern_return_t mach_vm_map(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, mem_entry_name_port_t object, memory_object_offset_t offset, BOOLean_t copy, vm_prot_t cur_protection, vm_prot_t max_protection, vm_inherit_t inheritance)
{
  return _mach_vm_map(target_task, address, size, mask, flags, object, offset, copy, cur_protection, max_protection, inheritance);
}

kern_return_t mach_vm_remap(vm_map_t target_task, mach_vm_address_t *target_address, mach_vm_size_t size, mach_vm_offset_t mask, int flags, vm_map_t src_task, mach_vm_address_t src_address, BOOLean_t copy, vm_prot_t *cur_protection, vm_prot_t *max_protection, vm_inherit_t inheritance)
{
  return _mach_vm_remap(target_task, target_address, size, mask, flags, src_task, src_address, copy, cur_protection, max_protection, inheritance);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return _memchr(__s, __c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

uint64_t memorystatus_control()
{
  return _memorystatus_control();
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

void mig_dealloc_reply_port(mach_port_t reply_port)
{
}

void mig_deallocate(vm_address_t a1, vm_size_t a2)
{
}

mach_port_t mig_get_reply_port(void)
{
  return _mig_get_reply_port();
}

void mig_put_reply_port(mach_port_t reply_port)
{
}

int mig_strncpy(char *dest, const char *src, int len)
{
  return _mig_strncpy(dest, src, len);
}

int mig_strncpy_zerofill(char *dest, const char *src, int len)
{
  return _mig_strncpy_zerofill(dest, src, len);
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

char *__cdecl mkdtemp(char *a1)
{
  return _mkdtemp(a1);
}

int mkpath_np(const char *path, mode_t omode)
{
  return _mkpath_np(path, omode);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint64_t ne_session_initialize_necp_drop_all()
{
  return _ne_session_initialize_necp_drop_all();
}

uint64_t notify_set_options()
{
  return _notify_set_options();
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

void objc_release(id a1)
{
}

Class object_getClass(id a1)
{
  return _object_getClass(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return _open_dprotected_np(a1, a2, a3, a4);
}

uint64_t os_log_simple_now()
{
  return _os_log_simple_now();
}

uint64_t os_log_simple_type_from_asl()
{
  return _os_log_simple_type_from_asl();
}

uint64_t os_map_32_count()
{
  return _os_map_32_count();
}

uint64_t os_map_32_destroy()
{
  return _os_map_32_destroy();
}

uint64_t os_map_32_find()
{
  return _os_map_32_find();
}

uint64_t os_map_32_init()
{
  return _os_map_32_init();
}

uint64_t os_map_str_clear()
{
  return _os_map_str_clear();
}

uint64_t os_map_str_count()
{
  return _os_map_str_count();
}

uint64_t os_map_str_delete()
{
  return _os_map_str_delete();
}

uint64_t os_map_str_destroy()
{
  return _os_map_str_destroy();
}

uint64_t os_map_str_find()
{
  return _os_map_str_find();
}

uint64_t os_map_str_foreach()
{
  return _os_map_str_foreach();
}

uint64_t os_map_str_init()
{
  return _os_map_str_init();
}

uint64_t os_map_str_insert()
{
  return _os_map_str_insert();
}

uint64_t os_parse_boot_arg_from_buffer_int()
{
  return _os_parse_boot_arg_from_buffer_int();
}

void os_release(void *object)
{
}

void *__cdecl os_retain(void *object)
{
  return _os_retain(object);
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return _os_unfair_lock_lock_with_options();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_allows_internal_security_policies()
{
  return _os_variant_allows_internal_security_policies();
}

uint64_t os_variant_has_internal_content()
{
  return _os_variant_has_internal_content();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return _os_variant_has_internal_diagnostics();
}

uint64_t os_variant_init_4launchd()
{
  return _os_variant_init_4launchd();
}

uint64_t os_variant_is_darwinos()
{
  return _os_variant_is_darwinos();
}

void panic_init(mach_port_t a1)
{
}

int pause(void)
{
  return _pause();
}

int posix_spawn(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return _posix_spawn(a1, a2, a3, a4, __argv, __envp);
}

uint64_t posix_spawn_file_actions_add_fileportdup2_np()
{
  return _posix_spawn_file_actions_add_fileportdup2_np();
}

int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *a1, int a2, int a3)
{
  return _posix_spawn_file_actions_adddup2(a1, a2, a3);
}

int posix_spawn_file_actions_addinherit_np(posix_spawn_file_actions_t *a1, int a2)
{
  return _posix_spawn_file_actions_addinherit_np(a1, a2);
}

int posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *a1, int a2, const char *a3, int a4, mode_t a5)
{
  return _posix_spawn_file_actions_addopen(a1, a2, a3, a4, a5);
}

int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *a1)
{
  return _posix_spawn_file_actions_destroy(a1);
}

int posix_spawn_file_actions_init(posix_spawn_file_actions_t *a1)
{
  return _posix_spawn_file_actions_init(a1);
}

int posix_spawnattr_destroy(posix_spawnattr_t *a1)
{
  return _posix_spawnattr_destroy(a1);
}

uint64_t posix_spawnattr_disable_ptr_auth_a_keys_np()
{
  return _posix_spawnattr_disable_ptr_auth_a_keys_np();
}

int posix_spawnattr_getflags(const posix_spawnattr_t *a1, __int16 *a2)
{
  return _posix_spawnattr_getflags(a1, a2);
}

int posix_spawnattr_init(posix_spawnattr_t *a1)
{
  return _posix_spawnattr_init(a1);
}

uint64_t posix_spawnattr_set_conclave_id_np()
{
  return _posix_spawnattr_set_conclave_id_np();
}

uint64_t posix_spawnattr_set_crash_behavior_deadline_np()
{
  return _posix_spawnattr_set_crash_behavior_deadline_np();
}

uint64_t posix_spawnattr_set_crash_behavior_np()
{
  return _posix_spawnattr_set_crash_behavior_np();
}

uint64_t posix_spawnattr_set_crash_count_np()
{
  return _posix_spawnattr_set_crash_count_np();
}

uint64_t posix_spawnattr_set_darwin_role_np()
{
  return _posix_spawnattr_set_darwin_role_np();
}

uint64_t posix_spawnattr_set_filedesclimit_ext()
{
  return _posix_spawnattr_set_filedesclimit_ext();
}

uint64_t posix_spawnattr_set_gid_np()
{
  return _posix_spawnattr_set_gid_np();
}

uint64_t posix_spawnattr_set_groups_np()
{
  return _posix_spawnattr_set_groups_np();
}

uint64_t posix_spawnattr_set_importancewatch_port_np()
{
  return _posix_spawnattr_set_importancewatch_port_np();
}

uint64_t posix_spawnattr_set_jetsam_ttr_np()
{
  return _posix_spawnattr_set_jetsam_ttr_np();
}

uint64_t posix_spawnattr_set_kqworklooplimit_ext()
{
  return _posix_spawnattr_set_kqworklooplimit_ext();
}

uint64_t posix_spawnattr_set_launch_type_np()
{
  return _posix_spawnattr_set_launch_type_np();
}

uint64_t posix_spawnattr_set_login_np()
{
  return _posix_spawnattr_set_login_np();
}

uint64_t posix_spawnattr_set_max_addr_np()
{
  return _posix_spawnattr_set_max_addr_np();
}

uint64_t posix_spawnattr_set_persona_gid_np()
{
  return _posix_spawnattr_set_persona_gid_np();
}

uint64_t posix_spawnattr_set_persona_groups_np()
{
  return _posix_spawnattr_set_persona_groups_np();
}

uint64_t posix_spawnattr_set_persona_np()
{
  return _posix_spawnattr_set_persona_np();
}

uint64_t posix_spawnattr_set_persona_uid_np()
{
  return _posix_spawnattr_set_persona_uid_np();
}

uint64_t posix_spawnattr_set_portlimits_ext()
{
  return _posix_spawnattr_set_portlimits_ext();
}

int posix_spawnattr_set_qos_class_np(posix_spawnattr_t *__attr, qos_class_t __qos_class)
{
  return _posix_spawnattr_set_qos_class_np(__attr, __qos_class);
}

uint64_t posix_spawnattr_set_registered_ports_np()
{
  return _posix_spawnattr_set_registered_ports_np();
}

uint64_t posix_spawnattr_set_subsystem_root_path_np()
{
  return _posix_spawnattr_set_subsystem_root_path_np();
}

uint64_t posix_spawnattr_set_threadlimit_ext()
{
  return _posix_spawnattr_set_threadlimit_ext();
}

uint64_t posix_spawnattr_set_uid_np()
{
  return _posix_spawnattr_set_uid_np();
}

uint64_t posix_spawnattr_set_use_sec_transition_shims_np()
{
  return _posix_spawnattr_set_use_sec_transition_shims_np();
}

int posix_spawnattr_setarchpref_np(posix_spawnattr_t *a1, size_t a2, cpu_type_t *a3, cpu_subtype_t *a4, size_t *a5)
{
  return _posix_spawnattr_setarchpref_np(a1, a2, a3, a4, a5);
}

uint64_t posix_spawnattr_setcoalition_np()
{
  return _posix_spawnattr_setcoalition_np();
}

uint64_t posix_spawnattr_setcpumonitor()
{
  return _posix_spawnattr_setcpumonitor();
}

uint64_t posix_spawnattr_setcpumonitor_default()
{
  return _posix_spawnattr_setcpumonitor_default();
}

uint64_t posix_spawnattr_setdataless_iopolicy_np()
{
  return _posix_spawnattr_setdataless_iopolicy_np();
}

int posix_spawnattr_setexceptionports_np(posix_spawnattr_t *a1, exception_mask_t a2, mach_port_t a3, exception_behavior_t a4, thread_state_flavor_t a5)
{
  return _posix_spawnattr_setexceptionports_np(a1, a2, a3, a4, a5);
}

int posix_spawnattr_setflags(posix_spawnattr_t *a1, __int16 a2)
{
  return _posix_spawnattr_setflags(a1, a2);
}

uint64_t posix_spawnattr_setjetsam_ext()
{
  return _posix_spawnattr_setjetsam_ext();
}

uint64_t posix_spawnattr_setmacpolicyinfo_np()
{
  return _posix_spawnattr_setmacpolicyinfo_np();
}

uint64_t posix_spawnattr_setprocesstype_np()
{
  return _posix_spawnattr_setprocesstype_np();
}

int posix_spawnattr_setsigdefault(posix_spawnattr_t *a1, const sigset_t *a2)
{
  return _posix_spawnattr_setsigdefault(a1, a2);
}

int posix_spawnattr_setsigmask(posix_spawnattr_t *a1, const sigset_t *a2)
{
  return _posix_spawnattr_setsigmask(a1, a2);
}

int posix_spawnattr_setspecialport_np(posix_spawnattr_t *a1, mach_port_t a2, int a3)
{
  return _posix_spawnattr_setspecialport_np(a1, a2, a3);
}

int posix_spawnp(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return _posix_spawnp(a1, a2, a3, a4, __argv, __envp);
}

uint64_t proc_disable_wakemon()
{
  return _proc_disable_wakemon();
}

int proc_get_dirty(pid_t pid, uint32_t *flags)
{
  return _proc_get_dirty(pid, flags);
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return _proc_pid_rusage(pid, flavor, buffer);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return _proc_pidinfo(pid, flavor, arg, buffer, buffersize);
}

uint64_t proc_signal_with_audittoken()
{
  return _proc_signal_with_audittoken();
}

uint64_t proc_terminate_with_audittoken()
{
  return _proc_terminate_with_audittoken();
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return _pthread_attr_destroy(a1);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return _pthread_attr_init(a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return _pthread_attr_setdetachstate(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_setname_np(const char *a1)
{
  return _pthread_setname_np(a1);
}

int pthread_threadid_np(pthread_t a1, __uint64_t *a2)
{
  return _pthread_threadid_np(a1, a2);
}

qos_class_t qos_class_main(void)
{
  return _qos_class_main();
}

size_t rb_tree_count(rb_tree_t *a1)
{
  return _rb_tree_count(a1);
}

void *__cdecl rb_tree_find_node(rb_tree_t *a1, const void *a2)
{
  return _rb_tree_find_node(a1, a2);
}

void rb_tree_init(rb_tree_t *a1, const rb_tree_ops_t *a2)
{
}

void *__cdecl rb_tree_insert_node(rb_tree_t *a1, void *a2)
{
  return _rb_tree_insert_node(a1, a2);
}

void *__cdecl rb_tree_iterate(rb_tree_t *a1, void *a2, const unsigned int a3)
{
  return _rb_tree_iterate(a1, a2, a3);
}

void rb_tree_remove_node(rb_tree_t *a1, void *a2)
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return _read(a1, a2, a3);
}

int reboot(int a1)
{
  return _reboot(a1);
}

uint64_t record_system_event_as_kernel()
{
  return _record_system_event_as_kernel();
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

int renamex_np(const char *a1, const char *a2, unsigned int a3)
{
  return _renamex_np(a1, a2, a3);
}

uint64_t sandbox_check_by_audit_token()
{
  return _sandbox_check_by_audit_token();
}

uint64_t sandbox_check_process_signal_target()
{
  return _sandbox_check_process_signal_target();
}

uint64_t sandbox_spawnattrs_init()
{
  return _sandbox_spawnattrs_init();
}

uint64_t sandbox_spawnattrs_setcontainer()
{
  return _sandbox_spawnattrs_setcontainer();
}

uint64_t sandbox_spawnattrs_setprofilename()
{
  return _sandbox_spawnattrs_setprofilename();
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  return _setenv(__name, __value, __overwrite);
}

int setiopolicy_np(int a1, int a2, int a3)
{
  return _setiopolicy_np(a1, a2, a3);
}

int setlogin(const char *a1)
{
  return _setlogin(a1);
}

int setrlimit(int a1, const rlimit *a2)
{
  return _setrlimit(a1, a2);
}

pid_t setsid(void)
{
  return _setsid();
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return _setsockopt(a1, a2, a3, a4, a5);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  return _setvbuf(a1, a2, a3, a4);
}

uint64_t si_search_module_set_flags()
{
  return _si_search_module_set_flags();
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return _statfs(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return _strlcat(__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return _strncpy(__dst, __src, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return _strndup(__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  return _strsep(__stringp, __delim);
}

char *__cdecl strsignal(int __sig)
{
  return _strsignal(__sig);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return _strstr(__s1, __s2);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

uint64_t strtonum(const char *__numstr, uint64_t __minval, uint64_t __maxval, const char **__errstrp)
{
  return _strtonum(__numstr, __minval, __maxval, __errstrp);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return _strtoull(__str, __endptr, __base);
}

void sync(void)
{
}

int syscall(int a1, ...)
{
  return _syscall(a1);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

uint64_t sysctlbyname_get_data_np()
{
  return _sysctlbyname_get_data_np();
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  return _sysctlnametomib(a1, a2, a3);
}

uint64_t system_override()
{
  return _system_override();
}

kern_return_t task_get_exception_ports(task_t task, exception_mask_t exception_mask, exception_mask_array_t masks, mach_msg_type_number_t *masksCnt, exception_handler_array_t old_handlers, exception_behavior_array_t old_behaviors, exception_flavor_array_t old_flavors)
{
  return _task_get_exception_ports(task, exception_mask, masks, masksCnt, old_handlers, old_behaviors, old_flavors);
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return _task_info(target_task, flavor, task_info_out, task_info_outCnt);
}

kern_return_t task_name_for_pid(mach_port_name_t target_tport, int pid, mach_port_name_t *tn)
{
  return _task_name_for_pid(target_tport, pid, tn);
}

kern_return_t task_set_exception_ports(task_t task, exception_mask_t exception_mask, mach_port_t new_port, exception_behavior_t behavior, thread_state_flavor_t new_flavor)
{
  return _task_set_exception_ports(task, exception_mask, new_port, behavior, new_flavor);
}

kern_return_t task_set_special_port(task_t task, int which_port, mach_port_t special_port)
{
  return _task_set_special_port(task, which_port, special_port);
}

uint64_t terminate_with_reason()
{
  return _terminate_with_reason();
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

int unsetenv(const char *a1)
{
  return _unsetenv(a1);
}

int usrctl(uint32_t flags)
{
  return _usrctl(flags);
}

void uuid_clear(uuid_t uu)
{
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return _uuid_compare(uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_generate(uuid_t out)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return _vasprintf(a1, a2, a3);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return _vfprintf(a1, a2, a3);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return _vm_allocate(target_task, address, size, flags);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return _vsnprintf(__str, __size, __format, a4);
}

void vsyslog(int a1, const char *a2, __darwin_va_list a3)
{
}

pid_t wait4(pid_t a1, int *a2, int a3, rusage *a4)
{
  return _wait4(a1, a2, a3, a4);
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  return _waitpid(a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return _xpc_array_apply(xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return _xpc_array_create(objects, count);
}

xpc_object_t xpc_array_create_empty(void)
{
  return _xpc_array_create_empty();
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return _xpc_array_get_count(xarray);
}

int64_t xpc_array_get_int64(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_int64(xarray, index);
}

const char *__cdecl xpc_array_get_string(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_string(xarray, index);
}

uint64_t xpc_array_get_uint64(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_uint64(xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_value(xarray, index);
}

void xpc_array_set_data(xpc_object_t xarray, size_t index, const void *bytes, size_t length)
{
}

void xpc_array_set_fd(xpc_object_t xarray, size_t index, int fd)
{
}

void xpc_array_set_int64(xpc_object_t xarray, size_t index, int64_t value)
{
}

uint64_t xpc_array_set_mach_send()
{
  return _xpc_array_set_mach_send();
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
}

void xpc_array_set_uint64(xpc_object_t xarray, size_t index, uint64_t value)
{
}

void xpc_array_set_uuid(xpc_object_t xarray, size_t index, const unsigned __int8 *uuid)
{
}

void xpc_array_set_value(xpc_object_t xarray, size_t index, xpc_object_t value)
{
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return _xpc_BOOL_create(value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

uint64_t xpc_bundle_copy_normalized_cryptex_path()
{
  return _xpc_bundle_copy_normalized_cryptex_path();
}

uint64_t xpc_bundle_copy_services()
{
  return _xpc_bundle_copy_services();
}

uint64_t xpc_bundle_create()
{
  return _xpc_bundle_create();
}

uint64_t xpc_bundle_create_from_origin()
{
  return _xpc_bundle_create_from_origin();
}

uint64_t xpc_bundle_get_error()
{
  return _xpc_bundle_get_error();
}

uint64_t xpc_bundle_get_executable_path()
{
  return _xpc_bundle_get_executable_path();
}

uint64_t xpc_bundle_get_info_dictionary()
{
  return _xpc_bundle_get_info_dictionary();
}

uint64_t xpc_bundle_get_path()
{
  return _xpc_bundle_get_path();
}

uint64_t xpc_bundle_get_property()
{
  return _xpc_bundle_get_property();
}

uint64_t xpc_bundle_populate()
{
  return _xpc_bundle_populate();
}

uint64_t xpc_bundle_resolve_sync()
{
  return _xpc_bundle_resolve_sync();
}

xpc_object_t xpc_copy(xpc_object_t object)
{
  return _xpc_copy(object);
}

uint64_t xpc_create_from_plist()
{
  return _xpc_create_from_plist();
}

uint64_t xpc_create_from_serialization()
{
  return _xpc_create_from_serialization();
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return _xpc_data_create(bytes, length);
}

xpc_object_t xpc_data_create_with_dispatch_data(dispatch_data_t ddata)
{
  return _xpc_data_create_with_dispatch_data(ddata);
}

size_t xpc_data_get_bytes(xpc_object_t xdata, void *buffer, size_t off, size_t length)
{
  return _xpc_data_get_bytes(xdata, buffer, off, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

uint64_t xpc_date_get_value_absolute()
{
  return _xpc_date_get_value_absolute();
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return _xpc_dictionary_apply(xdict, applier);
}

uint64_t xpc_dictionary_apply_f()
{
  return _xpc_dictionary_apply_f();
}

uint64_t xpc_dictionary_copy_mach_send()
{
  return _xpc_dictionary_copy_mach_send();
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return _xpc_dictionary_create_empty();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

uint64_t xpc_dictionary_expects_reply()
{
  return _xpc_dictionary_expects_reply();
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_array(xdict, key);
}

uint64_t xpc_dictionary_get_audit_token()
{
  return _xpc_dictionary_get_audit_token();
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return _xpc_dictionary_get_count(xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return _xpc_dictionary_get_data(xdict, key, length);
}

xpc_object_t xpc_dictionary_get_dictionary(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_dictionary(xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

uint64_t xpc_dictionary_get_pointer()
{
  return _xpc_dictionary_get_pointer();
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

const uint8_t *__cdecl xpc_dictionary_get_uuid(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uuid(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

uint64_t xpc_dictionary_handoff_reply()
{
  return _xpc_dictionary_handoff_reply();
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

uint64_t xpc_dictionary_set_mach_recv()
{
  return _xpc_dictionary_set_mach_recv();
}

uint64_t xpc_dictionary_set_mach_send()
{
  return _xpc_dictionary_set_mach_send();
}

uint64_t xpc_dictionary_set_pointer()
{
  return _xpc_dictionary_set_pointer();
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_uuid(xpc_object_t xdict, const char *key, const unsigned __int8 *uuid)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return _xpc_double_get_value(xdouble);
}

BOOL xpc_equal(xpc_object_t object1, xpc_object_t object2)
{
  return _xpc_equal(object1, object2);
}

uint64_t xpc_exit_reason_get_label()
{
  return _xpc_exit_reason_get_label();
}

int xpc_fd_dup(xpc_object_t xfd)
{
  return _xpc_fd_dup(xfd);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return _xpc_int64_create(value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return _xpc_int64_get_value(xint);
}

uint64_t xpc_mach_send_copy_right()
{
  return _xpc_mach_send_copy_right();
}

uint64_t xpc_mach_send_create_with_disposition()
{
  return _xpc_mach_send_create_with_disposition();
}

uint64_t xpc_mach_send_get_right()
{
  return _xpc_mach_send_get_right();
}

uint64_t xpc_make_serialization()
{
  return _xpc_make_serialization();
}

xpc_object_t xpc_null_create(void)
{
  return _xpc_null_create();
}

uint64_t xpc_pipe_routine_reply()
{
  return _xpc_pipe_routine_reply();
}

uint64_t xpc_receive_mach_msg()
{
  return _xpc_receive_mach_msg();
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return _xpc_shmem_create(region, length);
}

uint64_t xpc_shmem_create_readonly()
{
  return _xpc_shmem_create_readonly();
}

size_t xpc_shmem_map(xpc_object_t xshmem, void **region)
{
  return _xpc_shmem_map(xshmem, region);
}

uint64_t xpc_strerror()
{
  return _xpc_strerror();
}

xpc_object_t xpc_string_create(const char *string)
{
  return _xpc_string_create(string);
}

uint64_t xpc_string_create_no_copy()
{
  return _xpc_string_create_no_copy();
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return _xpc_string_get_length(xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

const char *__cdecl xpc_type_get_name(xpc_type_t type)
{
  return _xpc_type_get_name(type);
}

xpc_object_t xpc_uint64_create(uint64_t value)
{
  return _xpc_uint64_create(value);
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return _xpc_uint64_get_value(xuint);
}